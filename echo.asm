
_echo：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
#include "stat.h"
#include "user.h"

int
main(int argc, char *argv[])
{
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	53                   	push   %ebx
       e:	51                   	push   %ecx
       f:	83 ec 10             	sub    $0x10,%esp
      12:	89 cb                	mov    %ecx,%ebx
  int i;

  for(i = 1; i < argc; i++)
      14:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
      1b:	eb 3c                	jmp    59 <main+0x59>
    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
      1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
      20:	83 c0 01             	add    $0x1,%eax
      23:	3b 03                	cmp    (%ebx),%eax
      25:	7d 07                	jge    2e <main+0x2e>
      27:	ba c0 5d 01 00       	mov    $0x15dc0,%edx
      2c:	eb 05                	jmp    33 <main+0x33>
      2e:	ba c2 5d 01 00       	mov    $0x15dc2,%edx
      33:	8b 45 f4             	mov    -0xc(%ebp),%eax
      36:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
      3d:	8b 43 04             	mov    0x4(%ebx),%eax
      40:	01 c8                	add    %ecx,%eax
      42:	8b 00                	mov    (%eax),%eax
      44:	52                   	push   %edx
      45:	50                   	push   %eax
      46:	68 c4 5d 01 00       	push   $0x15dc4
      4b:	6a 01                	push   $0x1
      4d:	e8 11 04 00 00       	call   463 <printf>
      52:	83 c4 10             	add    $0x10,%esp
int
main(int argc, char *argv[])
{
  int i;

  for(i = 1; i < argc; i++)
      55:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      59:	8b 45 f4             	mov    -0xc(%ebp),%eax
      5c:	3b 03                	cmp    (%ebx),%eax
      5e:	7c bd                	jl     1d <main+0x1d>
    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
  exit();
      60:	e8 57 02 00 00       	call   2bc <exit>

00000065 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
      65:	55                   	push   %ebp
      66:	89 e5                	mov    %esp,%ebp
      68:	57                   	push   %edi
      69:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
      6a:	8b 4d 08             	mov    0x8(%ebp),%ecx
      6d:	8b 55 10             	mov    0x10(%ebp),%edx
      70:	8b 45 0c             	mov    0xc(%ebp),%eax
      73:	89 cb                	mov    %ecx,%ebx
      75:	89 df                	mov    %ebx,%edi
      77:	89 d1                	mov    %edx,%ecx
      79:	fc                   	cld    
      7a:	f3 aa                	rep stos %al,%es:(%edi)
      7c:	89 ca                	mov    %ecx,%edx
      7e:	89 fb                	mov    %edi,%ebx
      80:	89 5d 08             	mov    %ebx,0x8(%ebp)
      83:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
      86:	90                   	nop
      87:	5b                   	pop    %ebx
      88:	5f                   	pop    %edi
      89:	5d                   	pop    %ebp
      8a:	c3                   	ret    

0000008b <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
      8b:	55                   	push   %ebp
      8c:	89 e5                	mov    %esp,%ebp
      8e:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
      91:	8b 45 08             	mov    0x8(%ebp),%eax
      94:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
      97:	90                   	nop
      98:	8b 45 08             	mov    0x8(%ebp),%eax
      9b:	8d 50 01             	lea    0x1(%eax),%edx
      9e:	89 55 08             	mov    %edx,0x8(%ebp)
      a1:	8b 55 0c             	mov    0xc(%ebp),%edx
      a4:	8d 4a 01             	lea    0x1(%edx),%ecx
      a7:	89 4d 0c             	mov    %ecx,0xc(%ebp)
      aa:	0f b6 12             	movzbl (%edx),%edx
      ad:	88 10                	mov    %dl,(%eax)
      af:	0f b6 00             	movzbl (%eax),%eax
      b2:	84 c0                	test   %al,%al
      b4:	75 e2                	jne    98 <strcpy+0xd>
    ;
  return os;
      b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
      b9:	c9                   	leave  
      ba:	c3                   	ret    

000000bb <strcmp>:

int
strcmp(const char *p, const char *q)
{
      bb:	55                   	push   %ebp
      bc:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
      be:	eb 08                	jmp    c8 <strcmp+0xd>
    p++, q++;
      c0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      c4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
      c8:	8b 45 08             	mov    0x8(%ebp),%eax
      cb:	0f b6 00             	movzbl (%eax),%eax
      ce:	84 c0                	test   %al,%al
      d0:	74 10                	je     e2 <strcmp+0x27>
      d2:	8b 45 08             	mov    0x8(%ebp),%eax
      d5:	0f b6 10             	movzbl (%eax),%edx
      d8:	8b 45 0c             	mov    0xc(%ebp),%eax
      db:	0f b6 00             	movzbl (%eax),%eax
      de:	38 c2                	cmp    %al,%dl
      e0:	74 de                	je     c0 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
      e2:	8b 45 08             	mov    0x8(%ebp),%eax
      e5:	0f b6 00             	movzbl (%eax),%eax
      e8:	0f b6 d0             	movzbl %al,%edx
      eb:	8b 45 0c             	mov    0xc(%ebp),%eax
      ee:	0f b6 00             	movzbl (%eax),%eax
      f1:	0f b6 c0             	movzbl %al,%eax
      f4:	29 c2                	sub    %eax,%edx
      f6:	89 d0                	mov    %edx,%eax
}
      f8:	5d                   	pop    %ebp
      f9:	c3                   	ret    

000000fa <strlen>:

uint
strlen(char *s)
{
      fa:	55                   	push   %ebp
      fb:	89 e5                	mov    %esp,%ebp
      fd:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     100:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     107:	eb 04                	jmp    10d <strlen+0x13>
     109:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     10d:	8b 55 fc             	mov    -0x4(%ebp),%edx
     110:	8b 45 08             	mov    0x8(%ebp),%eax
     113:	01 d0                	add    %edx,%eax
     115:	0f b6 00             	movzbl (%eax),%eax
     118:	84 c0                	test   %al,%al
     11a:	75 ed                	jne    109 <strlen+0xf>
    ;
  return n;
     11c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     11f:	c9                   	leave  
     120:	c3                   	ret    

00000121 <memset>:

void*
memset(void *dst, int c, uint n)
{
     121:	55                   	push   %ebp
     122:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     124:	8b 45 10             	mov    0x10(%ebp),%eax
     127:	50                   	push   %eax
     128:	ff 75 0c             	pushl  0xc(%ebp)
     12b:	ff 75 08             	pushl  0x8(%ebp)
     12e:	e8 32 ff ff ff       	call   65 <stosb>
     133:	83 c4 0c             	add    $0xc,%esp
  return dst;
     136:	8b 45 08             	mov    0x8(%ebp),%eax
}
     139:	c9                   	leave  
     13a:	c3                   	ret    

0000013b <strchr>:

char*
strchr(const char *s, char c)
{
     13b:	55                   	push   %ebp
     13c:	89 e5                	mov    %esp,%ebp
     13e:	83 ec 04             	sub    $0x4,%esp
     141:	8b 45 0c             	mov    0xc(%ebp),%eax
     144:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     147:	eb 14                	jmp    15d <strchr+0x22>
    if(*s == c)
     149:	8b 45 08             	mov    0x8(%ebp),%eax
     14c:	0f b6 00             	movzbl (%eax),%eax
     14f:	3a 45 fc             	cmp    -0x4(%ebp),%al
     152:	75 05                	jne    159 <strchr+0x1e>
      return (char*)s;
     154:	8b 45 08             	mov    0x8(%ebp),%eax
     157:	eb 13                	jmp    16c <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     159:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     15d:	8b 45 08             	mov    0x8(%ebp),%eax
     160:	0f b6 00             	movzbl (%eax),%eax
     163:	84 c0                	test   %al,%al
     165:	75 e2                	jne    149 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     167:	b8 00 00 00 00       	mov    $0x0,%eax
}
     16c:	c9                   	leave  
     16d:	c3                   	ret    

0000016e <gets>:

char*
gets(char *buf, int max)
{
     16e:	55                   	push   %ebp
     16f:	89 e5                	mov    %esp,%ebp
     171:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     174:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     17b:	eb 42                	jmp    1bf <gets+0x51>
    cc = read(0, &c, 1);
     17d:	83 ec 04             	sub    $0x4,%esp
     180:	6a 01                	push   $0x1
     182:	8d 45 ef             	lea    -0x11(%ebp),%eax
     185:	50                   	push   %eax
     186:	6a 00                	push   $0x0
     188:	e8 47 01 00 00       	call   2d4 <read>
     18d:	83 c4 10             	add    $0x10,%esp
     190:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     193:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     197:	7e 33                	jle    1cc <gets+0x5e>
      break;
    buf[i++] = c;
     199:	8b 45 f4             	mov    -0xc(%ebp),%eax
     19c:	8d 50 01             	lea    0x1(%eax),%edx
     19f:	89 55 f4             	mov    %edx,-0xc(%ebp)
     1a2:	89 c2                	mov    %eax,%edx
     1a4:	8b 45 08             	mov    0x8(%ebp),%eax
     1a7:	01 c2                	add    %eax,%edx
     1a9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1ad:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     1af:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1b3:	3c 0a                	cmp    $0xa,%al
     1b5:	74 16                	je     1cd <gets+0x5f>
     1b7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1bb:	3c 0d                	cmp    $0xd,%al
     1bd:	74 0e                	je     1cd <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     1bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1c2:	83 c0 01             	add    $0x1,%eax
     1c5:	3b 45 0c             	cmp    0xc(%ebp),%eax
     1c8:	7c b3                	jl     17d <gets+0xf>
     1ca:	eb 01                	jmp    1cd <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     1cc:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     1cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
     1d0:	8b 45 08             	mov    0x8(%ebp),%eax
     1d3:	01 d0                	add    %edx,%eax
     1d5:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     1d8:	8b 45 08             	mov    0x8(%ebp),%eax
}
     1db:	c9                   	leave  
     1dc:	c3                   	ret    

000001dd <stat>:

int
stat(char *n, struct stat *st)
{
     1dd:	55                   	push   %ebp
     1de:	89 e5                	mov    %esp,%ebp
     1e0:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     1e3:	83 ec 08             	sub    $0x8,%esp
     1e6:	6a 00                	push   $0x0
     1e8:	ff 75 08             	pushl  0x8(%ebp)
     1eb:	e8 0c 01 00 00       	call   2fc <open>
     1f0:	83 c4 10             	add    $0x10,%esp
     1f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     1f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     1fa:	79 07                	jns    203 <stat+0x26>
    return -1;
     1fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     201:	eb 25                	jmp    228 <stat+0x4b>
  r = fstat(fd, st);
     203:	83 ec 08             	sub    $0x8,%esp
     206:	ff 75 0c             	pushl  0xc(%ebp)
     209:	ff 75 f4             	pushl  -0xc(%ebp)
     20c:	e8 03 01 00 00       	call   314 <fstat>
     211:	83 c4 10             	add    $0x10,%esp
     214:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     217:	83 ec 0c             	sub    $0xc,%esp
     21a:	ff 75 f4             	pushl  -0xc(%ebp)
     21d:	e8 c2 00 00 00       	call   2e4 <close>
     222:	83 c4 10             	add    $0x10,%esp
  return r;
     225:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     228:	c9                   	leave  
     229:	c3                   	ret    

0000022a <atoi>:

int
atoi(const char *s)
{
     22a:	55                   	push   %ebp
     22b:	89 e5                	mov    %esp,%ebp
     22d:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     230:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     237:	eb 25                	jmp    25e <atoi+0x34>
    n = n*10 + *s++ - '0';
     239:	8b 55 fc             	mov    -0x4(%ebp),%edx
     23c:	89 d0                	mov    %edx,%eax
     23e:	c1 e0 02             	shl    $0x2,%eax
     241:	01 d0                	add    %edx,%eax
     243:	01 c0                	add    %eax,%eax
     245:	89 c1                	mov    %eax,%ecx
     247:	8b 45 08             	mov    0x8(%ebp),%eax
     24a:	8d 50 01             	lea    0x1(%eax),%edx
     24d:	89 55 08             	mov    %edx,0x8(%ebp)
     250:	0f b6 00             	movzbl (%eax),%eax
     253:	0f be c0             	movsbl %al,%eax
     256:	01 c8                	add    %ecx,%eax
     258:	83 e8 30             	sub    $0x30,%eax
     25b:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     25e:	8b 45 08             	mov    0x8(%ebp),%eax
     261:	0f b6 00             	movzbl (%eax),%eax
     264:	3c 2f                	cmp    $0x2f,%al
     266:	7e 0a                	jle    272 <atoi+0x48>
     268:	8b 45 08             	mov    0x8(%ebp),%eax
     26b:	0f b6 00             	movzbl (%eax),%eax
     26e:	3c 39                	cmp    $0x39,%al
     270:	7e c7                	jle    239 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     272:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     275:	c9                   	leave  
     276:	c3                   	ret    

00000277 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     277:	55                   	push   %ebp
     278:	89 e5                	mov    %esp,%ebp
     27a:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     27d:	8b 45 08             	mov    0x8(%ebp),%eax
     280:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     283:	8b 45 0c             	mov    0xc(%ebp),%eax
     286:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     289:	eb 17                	jmp    2a2 <memmove+0x2b>
    *dst++ = *src++;
     28b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     28e:	8d 50 01             	lea    0x1(%eax),%edx
     291:	89 55 fc             	mov    %edx,-0x4(%ebp)
     294:	8b 55 f8             	mov    -0x8(%ebp),%edx
     297:	8d 4a 01             	lea    0x1(%edx),%ecx
     29a:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     29d:	0f b6 12             	movzbl (%edx),%edx
     2a0:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     2a2:	8b 45 10             	mov    0x10(%ebp),%eax
     2a5:	8d 50 ff             	lea    -0x1(%eax),%edx
     2a8:	89 55 10             	mov    %edx,0x10(%ebp)
     2ab:	85 c0                	test   %eax,%eax
     2ad:	7f dc                	jg     28b <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     2af:	8b 45 08             	mov    0x8(%ebp),%eax
}
     2b2:	c9                   	leave  
     2b3:	c3                   	ret    

000002b4 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     2b4:	b8 01 00 00 00       	mov    $0x1,%eax
     2b9:	cd 40                	int    $0x40
     2bb:	c3                   	ret    

000002bc <exit>:
SYSCALL(exit)
     2bc:	b8 02 00 00 00       	mov    $0x2,%eax
     2c1:	cd 40                	int    $0x40
     2c3:	c3                   	ret    

000002c4 <wait>:
SYSCALL(wait)
     2c4:	b8 03 00 00 00       	mov    $0x3,%eax
     2c9:	cd 40                	int    $0x40
     2cb:	c3                   	ret    

000002cc <pipe>:
SYSCALL(pipe)
     2cc:	b8 04 00 00 00       	mov    $0x4,%eax
     2d1:	cd 40                	int    $0x40
     2d3:	c3                   	ret    

000002d4 <read>:
SYSCALL(read)
     2d4:	b8 05 00 00 00       	mov    $0x5,%eax
     2d9:	cd 40                	int    $0x40
     2db:	c3                   	ret    

000002dc <write>:
SYSCALL(write)
     2dc:	b8 10 00 00 00       	mov    $0x10,%eax
     2e1:	cd 40                	int    $0x40
     2e3:	c3                   	ret    

000002e4 <close>:
SYSCALL(close)
     2e4:	b8 15 00 00 00       	mov    $0x15,%eax
     2e9:	cd 40                	int    $0x40
     2eb:	c3                   	ret    

000002ec <kill>:
SYSCALL(kill)
     2ec:	b8 06 00 00 00       	mov    $0x6,%eax
     2f1:	cd 40                	int    $0x40
     2f3:	c3                   	ret    

000002f4 <exec>:
SYSCALL(exec)
     2f4:	b8 07 00 00 00       	mov    $0x7,%eax
     2f9:	cd 40                	int    $0x40
     2fb:	c3                   	ret    

000002fc <open>:
SYSCALL(open)
     2fc:	b8 0f 00 00 00       	mov    $0xf,%eax
     301:	cd 40                	int    $0x40
     303:	c3                   	ret    

00000304 <mknod>:
SYSCALL(mknod)
     304:	b8 11 00 00 00       	mov    $0x11,%eax
     309:	cd 40                	int    $0x40
     30b:	c3                   	ret    

0000030c <unlink>:
SYSCALL(unlink)
     30c:	b8 12 00 00 00       	mov    $0x12,%eax
     311:	cd 40                	int    $0x40
     313:	c3                   	ret    

00000314 <fstat>:
SYSCALL(fstat)
     314:	b8 08 00 00 00       	mov    $0x8,%eax
     319:	cd 40                	int    $0x40
     31b:	c3                   	ret    

0000031c <link>:
SYSCALL(link)
     31c:	b8 13 00 00 00       	mov    $0x13,%eax
     321:	cd 40                	int    $0x40
     323:	c3                   	ret    

00000324 <mkdir>:
SYSCALL(mkdir)
     324:	b8 14 00 00 00       	mov    $0x14,%eax
     329:	cd 40                	int    $0x40
     32b:	c3                   	ret    

0000032c <chdir>:
SYSCALL(chdir)
     32c:	b8 09 00 00 00       	mov    $0x9,%eax
     331:	cd 40                	int    $0x40
     333:	c3                   	ret    

00000334 <dup>:
SYSCALL(dup)
     334:	b8 0a 00 00 00       	mov    $0xa,%eax
     339:	cd 40                	int    $0x40
     33b:	c3                   	ret    

0000033c <getpid>:
SYSCALL(getpid)
     33c:	b8 0b 00 00 00       	mov    $0xb,%eax
     341:	cd 40                	int    $0x40
     343:	c3                   	ret    

00000344 <sbrk>:
SYSCALL(sbrk)
     344:	b8 0c 00 00 00       	mov    $0xc,%eax
     349:	cd 40                	int    $0x40
     34b:	c3                   	ret    

0000034c <sleep>:
SYSCALL(sleep)
     34c:	b8 0d 00 00 00       	mov    $0xd,%eax
     351:	cd 40                	int    $0x40
     353:	c3                   	ret    

00000354 <uptime>:
SYSCALL(uptime)
     354:	b8 0e 00 00 00       	mov    $0xe,%eax
     359:	cd 40                	int    $0x40
     35b:	c3                   	ret    

0000035c <createwindow>:
SYSCALL(createwindow)
     35c:	b8 16 00 00 00       	mov    $0x16,%eax
     361:	cd 40                	int    $0x40
     363:	c3                   	ret    

00000364 <repaintwindow>:
SYSCALL(repaintwindow)
     364:	b8 17 00 00 00       	mov    $0x17,%eax
     369:	cd 40                	int    $0x40
     36b:	c3                   	ret    

0000036c <getmessage>:
SYSCALL(getmessage)
     36c:	b8 18 00 00 00       	mov    $0x18,%eax
     371:	cd 40                	int    $0x40
     373:	c3                   	ret    

00000374 <settimer>:
SYSCALL(settimer)
     374:	b8 19 00 00 00       	mov    $0x19,%eax
     379:	cd 40                	int    $0x40
     37b:	c3                   	ret    

0000037c <updatewindow>:
SYSCALL(updatewindow)
     37c:	b8 1a 00 00 00       	mov    $0x1a,%eax
     381:	cd 40                	int    $0x40
     383:	c3                   	ret    

00000384 <destroywindow>:
SYSCALL(destroywindow)
     384:	b8 1b 00 00 00       	mov    $0x1b,%eax
     389:	cd 40                	int    $0x40
     38b:	c3                   	ret    

0000038c <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     38c:	55                   	push   %ebp
     38d:	89 e5                	mov    %esp,%ebp
     38f:	83 ec 18             	sub    $0x18,%esp
     392:	8b 45 0c             	mov    0xc(%ebp),%eax
     395:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     398:	83 ec 04             	sub    $0x4,%esp
     39b:	6a 01                	push   $0x1
     39d:	8d 45 f4             	lea    -0xc(%ebp),%eax
     3a0:	50                   	push   %eax
     3a1:	ff 75 08             	pushl  0x8(%ebp)
     3a4:	e8 33 ff ff ff       	call   2dc <write>
     3a9:	83 c4 10             	add    $0x10,%esp
}
     3ac:	90                   	nop
     3ad:	c9                   	leave  
     3ae:	c3                   	ret    

000003af <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     3af:	55                   	push   %ebp
     3b0:	89 e5                	mov    %esp,%ebp
     3b2:	53                   	push   %ebx
     3b3:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     3b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     3bd:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     3c1:	74 17                	je     3da <printint+0x2b>
     3c3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     3c7:	79 11                	jns    3da <printint+0x2b>
    neg = 1;
     3c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     3d0:	8b 45 0c             	mov    0xc(%ebp),%eax
     3d3:	f7 d8                	neg    %eax
     3d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
     3d8:	eb 06                	jmp    3e0 <printint+0x31>
  } else {
    x = xx;
     3da:	8b 45 0c             	mov    0xc(%ebp),%eax
     3dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     3e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     3e7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     3ea:	8d 41 01             	lea    0x1(%ecx),%eax
     3ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
     3f0:	8b 5d 10             	mov    0x10(%ebp),%ebx
     3f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
     3f6:	ba 00 00 00 00       	mov    $0x0,%edx
     3fb:	f7 f3                	div    %ebx
     3fd:	89 d0                	mov    %edx,%eax
     3ff:	0f b6 80 c0 e0 01 00 	movzbl 0x1e0c0(%eax),%eax
     406:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     40a:	8b 5d 10             	mov    0x10(%ebp),%ebx
     40d:	8b 45 ec             	mov    -0x14(%ebp),%eax
     410:	ba 00 00 00 00       	mov    $0x0,%edx
     415:	f7 f3                	div    %ebx
     417:	89 45 ec             	mov    %eax,-0x14(%ebp)
     41a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     41e:	75 c7                	jne    3e7 <printint+0x38>
  if(neg)
     420:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     424:	74 2d                	je     453 <printint+0xa4>
    buf[i++] = '-';
     426:	8b 45 f4             	mov    -0xc(%ebp),%eax
     429:	8d 50 01             	lea    0x1(%eax),%edx
     42c:	89 55 f4             	mov    %edx,-0xc(%ebp)
     42f:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     434:	eb 1d                	jmp    453 <printint+0xa4>
    putc(fd, buf[i]);
     436:	8d 55 dc             	lea    -0x24(%ebp),%edx
     439:	8b 45 f4             	mov    -0xc(%ebp),%eax
     43c:	01 d0                	add    %edx,%eax
     43e:	0f b6 00             	movzbl (%eax),%eax
     441:	0f be c0             	movsbl %al,%eax
     444:	83 ec 08             	sub    $0x8,%esp
     447:	50                   	push   %eax
     448:	ff 75 08             	pushl  0x8(%ebp)
     44b:	e8 3c ff ff ff       	call   38c <putc>
     450:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     453:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     457:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     45b:	79 d9                	jns    436 <printint+0x87>
    putc(fd, buf[i]);
}
     45d:	90                   	nop
     45e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     461:	c9                   	leave  
     462:	c3                   	ret    

00000463 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     463:	55                   	push   %ebp
     464:	89 e5                	mov    %esp,%ebp
     466:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     469:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     470:	8d 45 0c             	lea    0xc(%ebp),%eax
     473:	83 c0 04             	add    $0x4,%eax
     476:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     479:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     480:	e9 59 01 00 00       	jmp    5de <printf+0x17b>
    c = fmt[i] & 0xff;
     485:	8b 55 0c             	mov    0xc(%ebp),%edx
     488:	8b 45 f0             	mov    -0x10(%ebp),%eax
     48b:	01 d0                	add    %edx,%eax
     48d:	0f b6 00             	movzbl (%eax),%eax
     490:	0f be c0             	movsbl %al,%eax
     493:	25 ff 00 00 00       	and    $0xff,%eax
     498:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     49b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     49f:	75 2c                	jne    4cd <printf+0x6a>
      if(c == '%'){
     4a1:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     4a5:	75 0c                	jne    4b3 <printf+0x50>
        state = '%';
     4a7:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     4ae:	e9 27 01 00 00       	jmp    5da <printf+0x177>
      } else {
        putc(fd, c);
     4b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     4b6:	0f be c0             	movsbl %al,%eax
     4b9:	83 ec 08             	sub    $0x8,%esp
     4bc:	50                   	push   %eax
     4bd:	ff 75 08             	pushl  0x8(%ebp)
     4c0:	e8 c7 fe ff ff       	call   38c <putc>
     4c5:	83 c4 10             	add    $0x10,%esp
     4c8:	e9 0d 01 00 00       	jmp    5da <printf+0x177>
      }
    } else if(state == '%'){
     4cd:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     4d1:	0f 85 03 01 00 00    	jne    5da <printf+0x177>
      if(c == 'd'){
     4d7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     4db:	75 1e                	jne    4fb <printf+0x98>
        printint(fd, *ap, 10, 1);
     4dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
     4e0:	8b 00                	mov    (%eax),%eax
     4e2:	6a 01                	push   $0x1
     4e4:	6a 0a                	push   $0xa
     4e6:	50                   	push   %eax
     4e7:	ff 75 08             	pushl  0x8(%ebp)
     4ea:	e8 c0 fe ff ff       	call   3af <printint>
     4ef:	83 c4 10             	add    $0x10,%esp
        ap++;
     4f2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     4f6:	e9 d8 00 00 00       	jmp    5d3 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     4fb:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     4ff:	74 06                	je     507 <printf+0xa4>
     501:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     505:	75 1e                	jne    525 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     507:	8b 45 e8             	mov    -0x18(%ebp),%eax
     50a:	8b 00                	mov    (%eax),%eax
     50c:	6a 00                	push   $0x0
     50e:	6a 10                	push   $0x10
     510:	50                   	push   %eax
     511:	ff 75 08             	pushl  0x8(%ebp)
     514:	e8 96 fe ff ff       	call   3af <printint>
     519:	83 c4 10             	add    $0x10,%esp
        ap++;
     51c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     520:	e9 ae 00 00 00       	jmp    5d3 <printf+0x170>
      } else if(c == 's'){
     525:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     529:	75 43                	jne    56e <printf+0x10b>
        s = (char*)*ap;
     52b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     52e:	8b 00                	mov    (%eax),%eax
     530:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     533:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     537:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     53b:	75 25                	jne    562 <printf+0xff>
          s = "(null)";
     53d:	c7 45 f4 c9 5d 01 00 	movl   $0x15dc9,-0xc(%ebp)
        while(*s != 0){
     544:	eb 1c                	jmp    562 <printf+0xff>
          putc(fd, *s);
     546:	8b 45 f4             	mov    -0xc(%ebp),%eax
     549:	0f b6 00             	movzbl (%eax),%eax
     54c:	0f be c0             	movsbl %al,%eax
     54f:	83 ec 08             	sub    $0x8,%esp
     552:	50                   	push   %eax
     553:	ff 75 08             	pushl  0x8(%ebp)
     556:	e8 31 fe ff ff       	call   38c <putc>
     55b:	83 c4 10             	add    $0x10,%esp
          s++;
     55e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     562:	8b 45 f4             	mov    -0xc(%ebp),%eax
     565:	0f b6 00             	movzbl (%eax),%eax
     568:	84 c0                	test   %al,%al
     56a:	75 da                	jne    546 <printf+0xe3>
     56c:	eb 65                	jmp    5d3 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     56e:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     572:	75 1d                	jne    591 <printf+0x12e>
        putc(fd, *ap);
     574:	8b 45 e8             	mov    -0x18(%ebp),%eax
     577:	8b 00                	mov    (%eax),%eax
     579:	0f be c0             	movsbl %al,%eax
     57c:	83 ec 08             	sub    $0x8,%esp
     57f:	50                   	push   %eax
     580:	ff 75 08             	pushl  0x8(%ebp)
     583:	e8 04 fe ff ff       	call   38c <putc>
     588:	83 c4 10             	add    $0x10,%esp
        ap++;
     58b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     58f:	eb 42                	jmp    5d3 <printf+0x170>
      } else if(c == '%'){
     591:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     595:	75 17                	jne    5ae <printf+0x14b>
        putc(fd, c);
     597:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     59a:	0f be c0             	movsbl %al,%eax
     59d:	83 ec 08             	sub    $0x8,%esp
     5a0:	50                   	push   %eax
     5a1:	ff 75 08             	pushl  0x8(%ebp)
     5a4:	e8 e3 fd ff ff       	call   38c <putc>
     5a9:	83 c4 10             	add    $0x10,%esp
     5ac:	eb 25                	jmp    5d3 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     5ae:	83 ec 08             	sub    $0x8,%esp
     5b1:	6a 25                	push   $0x25
     5b3:	ff 75 08             	pushl  0x8(%ebp)
     5b6:	e8 d1 fd ff ff       	call   38c <putc>
     5bb:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     5be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5c1:	0f be c0             	movsbl %al,%eax
     5c4:	83 ec 08             	sub    $0x8,%esp
     5c7:	50                   	push   %eax
     5c8:	ff 75 08             	pushl  0x8(%ebp)
     5cb:	e8 bc fd ff ff       	call   38c <putc>
     5d0:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     5d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     5da:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     5de:	8b 55 0c             	mov    0xc(%ebp),%edx
     5e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
     5e4:	01 d0                	add    %edx,%eax
     5e6:	0f b6 00             	movzbl (%eax),%eax
     5e9:	84 c0                	test   %al,%al
     5eb:	0f 85 94 fe ff ff    	jne    485 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     5f1:	90                   	nop
     5f2:	c9                   	leave  
     5f3:	c3                   	ret    

000005f4 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     5f4:	55                   	push   %ebp
     5f5:	89 e5                	mov    %esp,%ebp
     5f7:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     5fa:	8b 45 08             	mov    0x8(%ebp),%eax
     5fd:	83 e8 08             	sub    $0x8,%eax
     600:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     603:	a1 08 e5 01 00       	mov    0x1e508,%eax
     608:	89 45 fc             	mov    %eax,-0x4(%ebp)
     60b:	eb 24                	jmp    631 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     60d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     610:	8b 00                	mov    (%eax),%eax
     612:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     615:	77 12                	ja     629 <free+0x35>
     617:	8b 45 f8             	mov    -0x8(%ebp),%eax
     61a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     61d:	77 24                	ja     643 <free+0x4f>
     61f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     622:	8b 00                	mov    (%eax),%eax
     624:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     627:	77 1a                	ja     643 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     629:	8b 45 fc             	mov    -0x4(%ebp),%eax
     62c:	8b 00                	mov    (%eax),%eax
     62e:	89 45 fc             	mov    %eax,-0x4(%ebp)
     631:	8b 45 f8             	mov    -0x8(%ebp),%eax
     634:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     637:	76 d4                	jbe    60d <free+0x19>
     639:	8b 45 fc             	mov    -0x4(%ebp),%eax
     63c:	8b 00                	mov    (%eax),%eax
     63e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     641:	76 ca                	jbe    60d <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     643:	8b 45 f8             	mov    -0x8(%ebp),%eax
     646:	8b 40 04             	mov    0x4(%eax),%eax
     649:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     650:	8b 45 f8             	mov    -0x8(%ebp),%eax
     653:	01 c2                	add    %eax,%edx
     655:	8b 45 fc             	mov    -0x4(%ebp),%eax
     658:	8b 00                	mov    (%eax),%eax
     65a:	39 c2                	cmp    %eax,%edx
     65c:	75 24                	jne    682 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     65e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     661:	8b 50 04             	mov    0x4(%eax),%edx
     664:	8b 45 fc             	mov    -0x4(%ebp),%eax
     667:	8b 00                	mov    (%eax),%eax
     669:	8b 40 04             	mov    0x4(%eax),%eax
     66c:	01 c2                	add    %eax,%edx
     66e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     671:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     674:	8b 45 fc             	mov    -0x4(%ebp),%eax
     677:	8b 00                	mov    (%eax),%eax
     679:	8b 10                	mov    (%eax),%edx
     67b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     67e:	89 10                	mov    %edx,(%eax)
     680:	eb 0a                	jmp    68c <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     682:	8b 45 fc             	mov    -0x4(%ebp),%eax
     685:	8b 10                	mov    (%eax),%edx
     687:	8b 45 f8             	mov    -0x8(%ebp),%eax
     68a:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     68c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     68f:	8b 40 04             	mov    0x4(%eax),%eax
     692:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     699:	8b 45 fc             	mov    -0x4(%ebp),%eax
     69c:	01 d0                	add    %edx,%eax
     69e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6a1:	75 20                	jne    6c3 <free+0xcf>
    p->s.size += bp->s.size;
     6a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6a6:	8b 50 04             	mov    0x4(%eax),%edx
     6a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6ac:	8b 40 04             	mov    0x4(%eax),%eax
     6af:	01 c2                	add    %eax,%edx
     6b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6b4:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     6b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6ba:	8b 10                	mov    (%eax),%edx
     6bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6bf:	89 10                	mov    %edx,(%eax)
     6c1:	eb 08                	jmp    6cb <free+0xd7>
  } else
    p->s.ptr = bp;
     6c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6c6:	8b 55 f8             	mov    -0x8(%ebp),%edx
     6c9:	89 10                	mov    %edx,(%eax)
  freep = p;
     6cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6ce:	a3 08 e5 01 00       	mov    %eax,0x1e508
}
     6d3:	90                   	nop
     6d4:	c9                   	leave  
     6d5:	c3                   	ret    

000006d6 <morecore>:

static Header*
morecore(uint nu)
{
     6d6:	55                   	push   %ebp
     6d7:	89 e5                	mov    %esp,%ebp
     6d9:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     6dc:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     6e3:	77 07                	ja     6ec <morecore+0x16>
    nu = 4096;
     6e5:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     6ec:	8b 45 08             	mov    0x8(%ebp),%eax
     6ef:	c1 e0 03             	shl    $0x3,%eax
     6f2:	83 ec 0c             	sub    $0xc,%esp
     6f5:	50                   	push   %eax
     6f6:	e8 49 fc ff ff       	call   344 <sbrk>
     6fb:	83 c4 10             	add    $0x10,%esp
     6fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     701:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     705:	75 07                	jne    70e <morecore+0x38>
    return 0;
     707:	b8 00 00 00 00       	mov    $0x0,%eax
     70c:	eb 26                	jmp    734 <morecore+0x5e>
  hp = (Header*)p;
     70e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     711:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     714:	8b 45 f0             	mov    -0x10(%ebp),%eax
     717:	8b 55 08             	mov    0x8(%ebp),%edx
     71a:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     71d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     720:	83 c0 08             	add    $0x8,%eax
     723:	83 ec 0c             	sub    $0xc,%esp
     726:	50                   	push   %eax
     727:	e8 c8 fe ff ff       	call   5f4 <free>
     72c:	83 c4 10             	add    $0x10,%esp
  return freep;
     72f:	a1 08 e5 01 00       	mov    0x1e508,%eax
}
     734:	c9                   	leave  
     735:	c3                   	ret    

00000736 <malloc>:

void*
malloc(uint nbytes)
{
     736:	55                   	push   %ebp
     737:	89 e5                	mov    %esp,%ebp
     739:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     73c:	8b 45 08             	mov    0x8(%ebp),%eax
     73f:	83 c0 07             	add    $0x7,%eax
     742:	c1 e8 03             	shr    $0x3,%eax
     745:	83 c0 01             	add    $0x1,%eax
     748:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     74b:	a1 08 e5 01 00       	mov    0x1e508,%eax
     750:	89 45 f0             	mov    %eax,-0x10(%ebp)
     753:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     757:	75 23                	jne    77c <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     759:	c7 45 f0 00 e5 01 00 	movl   $0x1e500,-0x10(%ebp)
     760:	8b 45 f0             	mov    -0x10(%ebp),%eax
     763:	a3 08 e5 01 00       	mov    %eax,0x1e508
     768:	a1 08 e5 01 00       	mov    0x1e508,%eax
     76d:	a3 00 e5 01 00       	mov    %eax,0x1e500
    base.s.size = 0;
     772:	c7 05 04 e5 01 00 00 	movl   $0x0,0x1e504
     779:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     77c:	8b 45 f0             	mov    -0x10(%ebp),%eax
     77f:	8b 00                	mov    (%eax),%eax
     781:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     784:	8b 45 f4             	mov    -0xc(%ebp),%eax
     787:	8b 40 04             	mov    0x4(%eax),%eax
     78a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     78d:	72 4d                	jb     7dc <malloc+0xa6>
      if(p->s.size == nunits)
     78f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     792:	8b 40 04             	mov    0x4(%eax),%eax
     795:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     798:	75 0c                	jne    7a6 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     79a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     79d:	8b 10                	mov    (%eax),%edx
     79f:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7a2:	89 10                	mov    %edx,(%eax)
     7a4:	eb 26                	jmp    7cc <malloc+0x96>
      else {
        p->s.size -= nunits;
     7a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7a9:	8b 40 04             	mov    0x4(%eax),%eax
     7ac:	2b 45 ec             	sub    -0x14(%ebp),%eax
     7af:	89 c2                	mov    %eax,%edx
     7b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7b4:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     7b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7ba:	8b 40 04             	mov    0x4(%eax),%eax
     7bd:	c1 e0 03             	shl    $0x3,%eax
     7c0:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     7c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
     7c9:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     7cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7cf:	a3 08 e5 01 00       	mov    %eax,0x1e508
      return (void*)(p + 1);
     7d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7d7:	83 c0 08             	add    $0x8,%eax
     7da:	eb 3b                	jmp    817 <malloc+0xe1>
    }
    if(p == freep)
     7dc:	a1 08 e5 01 00       	mov    0x1e508,%eax
     7e1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     7e4:	75 1e                	jne    804 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     7e6:	83 ec 0c             	sub    $0xc,%esp
     7e9:	ff 75 ec             	pushl  -0x14(%ebp)
     7ec:	e8 e5 fe ff ff       	call   6d6 <morecore>
     7f1:	83 c4 10             	add    $0x10,%esp
     7f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
     7f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     7fb:	75 07                	jne    804 <malloc+0xce>
        return 0;
     7fd:	b8 00 00 00 00       	mov    $0x0,%eax
     802:	eb 13                	jmp    817 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     804:	8b 45 f4             	mov    -0xc(%ebp),%eax
     807:	89 45 f0             	mov    %eax,-0x10(%ebp)
     80a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     80d:	8b 00                	mov    (%eax),%eax
     80f:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     812:	e9 6d ff ff ff       	jmp    784 <malloc+0x4e>
}
     817:	c9                   	leave  
     818:	c3                   	ret    

00000819 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     819:	55                   	push   %ebp
     81a:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     81c:	a1 0c e5 01 00       	mov    0x1e50c,%eax
     821:	83 c0 01             	add    $0x1,%eax
     824:	a3 0c e5 01 00       	mov    %eax,0x1e50c
    g_seed = (214013*g_seed+2531011);
     829:	a1 0c e5 01 00       	mov    0x1e50c,%eax
     82e:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     834:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     839:	a3 0c e5 01 00       	mov    %eax,0x1e50c
    return (g_seed>>16)&0x7FFF;
     83e:	a1 0c e5 01 00       	mov    0x1e50c,%eax
     843:	c1 e8 10             	shr    $0x10,%eax
     846:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     84b:	5d                   	pop    %ebp
     84c:	c3                   	ret    

0000084d <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     84d:	55                   	push   %ebp
     84e:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     850:	d9 45 08             	flds   0x8(%ebp)
     853:	d9 ee                	fldz   
     855:	d9 c9                	fxch   %st(1)
     857:	df e9                	fucomip %st(1),%st
     859:	dd d8                	fstp   %st(0)
     85b:	76 05                	jbe    862 <abs+0x15>
     85d:	d9 45 08             	flds   0x8(%ebp)
     860:	eb 05                	jmp    867 <abs+0x1a>
	return -x;
     862:	d9 45 08             	flds   0x8(%ebp)
     865:	d9 e0                	fchs   
}
     867:	5d                   	pop    %ebp
     868:	c3                   	ret    

00000869 <pow>:

float pow(float a, int b)
{
     869:	55                   	push   %ebp
     86a:	89 e5                	mov    %esp,%ebp
     86c:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     86f:	d9 45 08             	flds   0x8(%ebp)
     872:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     875:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     879:	7e 17                	jle    892 <pow+0x29>
		while (--b)
     87b:	eb 09                	jmp    886 <pow+0x1d>
			r *= a;
     87d:	d9 45 fc             	flds   -0x4(%ebp)
     880:	d8 4d 08             	fmuls  0x8(%ebp)
     883:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     886:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     88a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     88e:	75 ed                	jne    87d <pow+0x14>
     890:	eb 2a                	jmp    8bc <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     892:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     896:	79 1f                	jns    8b7 <pow+0x4e>
		while (++b)
     898:	eb 09                	jmp    8a3 <pow+0x3a>
			r *= a;
     89a:	d9 45 fc             	flds   -0x4(%ebp)
     89d:	d8 4d 08             	fmuls  0x8(%ebp)
     8a0:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     8a3:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     8a7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8ab:	75 ed                	jne    89a <pow+0x31>
			r *= a;
		r = 1.0 / r;
     8ad:	d9 e8                	fld1   
     8af:	d8 75 fc             	fdivs  -0x4(%ebp)
     8b2:	d9 5d fc             	fstps  -0x4(%ebp)
     8b5:	eb 05                	jmp    8bc <pow+0x53>
	}
	else r = 0;
     8b7:	d9 ee                	fldz   
     8b9:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     8bc:	d9 45 fc             	flds   -0x4(%ebp)
}
     8bf:	c9                   	leave  
     8c0:	c3                   	ret    

000008c1 <sqrt>:

float sqrt(float number) {
     8c1:	55                   	push   %ebp
     8c2:	89 e5                	mov    %esp,%ebp
     8c4:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     8c7:	d9 ee                	fldz   
     8c9:	d9 45 08             	flds   0x8(%ebp)
     8cc:	d9 c9                	fxch   %st(1)
     8ce:	df e9                	fucomip %st(1),%st
     8d0:	dd d8                	fstp   %st(0)
     8d2:	76 06                	jbe    8da <sqrt+0x19>
		return -1;
     8d4:	d9 e8                	fld1   
     8d6:	d9 e0                	fchs   
     8d8:	eb 3a                	jmp    914 <sqrt+0x53>
	}

	new_guess = 1;
     8da:	d9 e8                	fld1   
     8dc:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     8df:	d9 45 fc             	flds   -0x4(%ebp)
     8e2:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     8e5:	d9 45 08             	flds   0x8(%ebp)
     8e8:	d8 75 f8             	fdivs  -0x8(%ebp)
     8eb:	d8 45 f8             	fadds  -0x8(%ebp)
     8ee:	d9 05 d0 5d 01 00    	flds   0x15dd0
     8f4:	de f9                	fdivrp %st,%st(1)
     8f6:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     8f9:	d9 45 fc             	flds   -0x4(%ebp)
     8fc:	d9 45 f8             	flds   -0x8(%ebp)
     8ff:	df e9                	fucomip %st(1),%st
     901:	dd d8                	fstp   %st(0)
     903:	7a da                	jp     8df <sqrt+0x1e>
     905:	d9 45 fc             	flds   -0x4(%ebp)
     908:	d9 45 f8             	flds   -0x8(%ebp)
     90b:	df e9                	fucomip %st(1),%st
     90d:	dd d8                	fstp   %st(0)
     90f:	75 ce                	jne    8df <sqrt+0x1e>

	return new_guess;
     911:	d9 45 fc             	flds   -0x4(%ebp)
}
     914:	c9                   	leave  
     915:	c3                   	ret    

00000916 <cos>:

float cos(float x)
{
     916:	55                   	push   %ebp
     917:	89 e5                	mov    %esp,%ebp
     919:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     91c:	d9 e8                	fld1   
     91e:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     921:	d9 45 08             	flds   0x8(%ebp)
     924:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     92a:	d9 c9                	fxch   %st(1)
     92c:	df e9                	fucomip %st(1),%st
     92e:	dd d8                	fstp   %st(0)
     930:	77 0f                	ja     941 <cos+0x2b>
     932:	d9 45 08             	flds   0x8(%ebp)
     935:	dd 05 e0 5d 01 00    	fldl   0x15de0
     93b:	df e9                	fucomip %st(1),%st
     93d:	dd d8                	fstp   %st(0)
     93f:	76 3c                	jbe    97d <cos+0x67>
     941:	d9 45 08             	flds   0x8(%ebp)
     944:	d9 45 08             	flds   0x8(%ebp)
     947:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     94d:	de f9                	fdivrp %st,%st(1)
     94f:	d9 7d e2             	fnstcw -0x1e(%ebp)
     952:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     956:	b4 0c                	mov    $0xc,%ah
     958:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     95c:	d9 6d e0             	fldcw  -0x20(%ebp)
     95f:	db 5d dc             	fistpl -0x24(%ebp)
     962:	d9 6d e2             	fldcw  -0x1e(%ebp)
     965:	8b 45 dc             	mov    -0x24(%ebp),%eax
     968:	01 c0                	add    %eax,%eax
     96a:	89 45 d8             	mov    %eax,-0x28(%ebp)
     96d:	db 45 d8             	fildl  -0x28(%ebp)
     970:	dd 05 e8 5d 01 00    	fldl   0x15de8
     976:	de c9                	fmulp  %st,%st(1)
     978:	de e9                	fsubrp %st,%st(1)
     97a:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     97d:	d9 45 08             	flds   0x8(%ebp)
     980:	dd 05 e8 5d 01 00    	fldl   0x15de8
     986:	d9 c9                	fxch   %st(1)
     988:	df e9                	fucomip %st(1),%st
     98a:	dd d8                	fstp   %st(0)
     98c:	76 0e                	jbe    99c <cos+0x86>
     98e:	d9 45 08             	flds   0x8(%ebp)
     991:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     997:	de e9                	fsubrp %st,%st(1)
     999:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     99c:	d9 45 08             	flds   0x8(%ebp)
     99f:	dd 05 f0 5d 01 00    	fldl   0x15df0
     9a5:	df e9                	fucomip %st(1),%st
     9a7:	dd d8                	fstp   %st(0)
     9a9:	76 0e                	jbe    9b9 <cos+0xa3>
     9ab:	d9 45 08             	flds   0x8(%ebp)
     9ae:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     9b4:	de c1                	faddp  %st,%st(1)
     9b6:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     9b9:	d9 45 08             	flds   0x8(%ebp)
     9bc:	dd 05 f8 5d 01 00    	fldl   0x15df8
     9c2:	d9 c9                	fxch   %st(1)
     9c4:	df e9                	fucomip %st(1),%st
     9c6:	dd d8                	fstp   %st(0)
     9c8:	76 16                	jbe    9e0 <cos+0xca>
    {
        x -= PI;
     9ca:	d9 45 08             	flds   0x8(%ebp)
     9cd:	dd 05 e8 5d 01 00    	fldl   0x15de8
     9d3:	de e9                	fsubrp %st,%st(1)
     9d5:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     9d8:	d9 45 f4             	flds   -0xc(%ebp)
     9db:	d9 e0                	fchs   
     9dd:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     9e0:	d9 45 08             	flds   0x8(%ebp)
     9e3:	dd 05 00 5e 01 00    	fldl   0x15e00
     9e9:	df e9                	fucomip %st(1),%st
     9eb:	dd d8                	fstp   %st(0)
     9ed:	76 16                	jbe    a05 <cos+0xef>
    {
        x += PI;
     9ef:	d9 45 08             	flds   0x8(%ebp)
     9f2:	dd 05 e8 5d 01 00    	fldl   0x15de8
     9f8:	de c1                	faddp  %st,%st(1)
     9fa:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     9fd:	d9 45 f4             	flds   -0xc(%ebp)
     a00:	d9 e0                	fchs   
     a02:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     a05:	d9 45 08             	flds   0x8(%ebp)
     a08:	dd 05 08 5e 01 00    	fldl   0x15e08
     a0e:	d9 c9                	fxch   %st(1)
     a10:	df e9                	fucomip %st(1),%st
     a12:	dd d8                	fstp   %st(0)
     a14:	76 28                	jbe    a3e <cos+0x128>
     a16:	d9 45 08             	flds   0x8(%ebp)
     a19:	dd 05 f8 5d 01 00    	fldl   0x15df8
     a1f:	de e1                	fsubp  %st,%st(1)
     a21:	d9 5d e4             	fstps  -0x1c(%ebp)
     a24:	d9 45 e4             	flds   -0x1c(%ebp)
     a27:	83 ec 0c             	sub    $0xc,%esp
     a2a:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     a2e:	d9 1c 24             	fstps  (%esp)
     a31:	e8 83 00 00 00       	call   ab9 <sin>
     a36:	83 c4 10             	add    $0x10,%esp
     a39:	d8 4d f4             	fmuls  -0xc(%ebp)
     a3c:	eb 79                	jmp    ab7 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     a3e:	83 ec 08             	sub    $0x8,%esp
     a41:	6a 02                	push   $0x2
     a43:	ff 75 08             	pushl  0x8(%ebp)
     a46:	e8 1e fe ff ff       	call   869 <pow>
     a4b:	83 c4 10             	add    $0x10,%esp
     a4e:	d9 05 d0 5d 01 00    	flds   0x15dd0
     a54:	de f9                	fdivrp %st,%st(1)
     a56:	d9 e8                	fld1   
     a58:	de e1                	fsubp  %st,%st(1)
     a5a:	d9 5d d8             	fstps  -0x28(%ebp)
     a5d:	83 ec 08             	sub    $0x8,%esp
     a60:	6a 04                	push   $0x4
     a62:	ff 75 08             	pushl  0x8(%ebp)
     a65:	e8 ff fd ff ff       	call   869 <pow>
     a6a:	83 c4 10             	add    $0x10,%esp
     a6d:	d9 05 10 5e 01 00    	flds   0x15e10
     a73:	de f9                	fdivrp %st,%st(1)
     a75:	d8 45 d8             	fadds  -0x28(%ebp)
     a78:	d9 5d d8             	fstps  -0x28(%ebp)
     a7b:	83 ec 08             	sub    $0x8,%esp
     a7e:	6a 06                	push   $0x6
     a80:	ff 75 08             	pushl  0x8(%ebp)
     a83:	e8 e1 fd ff ff       	call   869 <pow>
     a88:	83 c4 10             	add    $0x10,%esp
     a8b:	d9 05 14 5e 01 00    	flds   0x15e14
     a91:	de f9                	fdivrp %st,%st(1)
     a93:	d8 6d d8             	fsubrs -0x28(%ebp)
     a96:	d9 5d d8             	fstps  -0x28(%ebp)
     a99:	83 ec 08             	sub    $0x8,%esp
     a9c:	6a 08                	push   $0x8
     a9e:	ff 75 08             	pushl  0x8(%ebp)
     aa1:	e8 c3 fd ff ff       	call   869 <pow>
     aa6:	83 c4 10             	add    $0x10,%esp
     aa9:	d9 05 18 5e 01 00    	flds   0x15e18
     aaf:	de f9                	fdivrp %st,%st(1)
     ab1:	d8 45 d8             	fadds  -0x28(%ebp)
     ab4:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     ab7:	c9                   	leave  
     ab8:	c3                   	ret    

00000ab9 <sin>:

float sin(float x)
{
     ab9:	55                   	push   %ebp
     aba:	89 e5                	mov    %esp,%ebp
     abc:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     abf:	d9 e8                	fld1   
     ac1:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     ac4:	d9 45 08             	flds   0x8(%ebp)
     ac7:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     acd:	d9 c9                	fxch   %st(1)
     acf:	df e9                	fucomip %st(1),%st
     ad1:	dd d8                	fstp   %st(0)
     ad3:	77 0f                	ja     ae4 <sin+0x2b>
     ad5:	d9 45 08             	flds   0x8(%ebp)
     ad8:	dd 05 e0 5d 01 00    	fldl   0x15de0
     ade:	df e9                	fucomip %st(1),%st
     ae0:	dd d8                	fstp   %st(0)
     ae2:	76 3c                	jbe    b20 <sin+0x67>
     ae4:	d9 45 08             	flds   0x8(%ebp)
     ae7:	d9 45 08             	flds   0x8(%ebp)
     aea:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     af0:	de f9                	fdivrp %st,%st(1)
     af2:	d9 7d e2             	fnstcw -0x1e(%ebp)
     af5:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     af9:	b4 0c                	mov    $0xc,%ah
     afb:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     aff:	d9 6d e0             	fldcw  -0x20(%ebp)
     b02:	db 5d dc             	fistpl -0x24(%ebp)
     b05:	d9 6d e2             	fldcw  -0x1e(%ebp)
     b08:	8b 45 dc             	mov    -0x24(%ebp),%eax
     b0b:	01 c0                	add    %eax,%eax
     b0d:	89 45 d8             	mov    %eax,-0x28(%ebp)
     b10:	db 45 d8             	fildl  -0x28(%ebp)
     b13:	dd 05 e8 5d 01 00    	fldl   0x15de8
     b19:	de c9                	fmulp  %st,%st(1)
     b1b:	de e9                	fsubrp %st,%st(1)
     b1d:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     b20:	d9 45 08             	flds   0x8(%ebp)
     b23:	dd 05 e8 5d 01 00    	fldl   0x15de8
     b29:	d9 c9                	fxch   %st(1)
     b2b:	df e9                	fucomip %st(1),%st
     b2d:	dd d8                	fstp   %st(0)
     b2f:	76 0e                	jbe    b3f <sin+0x86>
     b31:	d9 45 08             	flds   0x8(%ebp)
     b34:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     b3a:	de e9                	fsubrp %st,%st(1)
     b3c:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     b3f:	d9 45 08             	flds   0x8(%ebp)
     b42:	dd 05 f0 5d 01 00    	fldl   0x15df0
     b48:	df e9                	fucomip %st(1),%st
     b4a:	dd d8                	fstp   %st(0)
     b4c:	76 0e                	jbe    b5c <sin+0xa3>
     b4e:	d9 45 08             	flds   0x8(%ebp)
     b51:	dd 05 d8 5d 01 00    	fldl   0x15dd8
     b57:	de c1                	faddp  %st,%st(1)
     b59:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     b5c:	d9 45 08             	flds   0x8(%ebp)
     b5f:	dd 05 f8 5d 01 00    	fldl   0x15df8
     b65:	d9 c9                	fxch   %st(1)
     b67:	df e9                	fucomip %st(1),%st
     b69:	dd d8                	fstp   %st(0)
     b6b:	76 16                	jbe    b83 <sin+0xca>
    {
        x -= PI;
     b6d:	d9 45 08             	flds   0x8(%ebp)
     b70:	dd 05 e8 5d 01 00    	fldl   0x15de8
     b76:	de e9                	fsubrp %st,%st(1)
     b78:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b7b:	d9 45 f4             	flds   -0xc(%ebp)
     b7e:	d9 e0                	fchs   
     b80:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     b83:	d9 45 08             	flds   0x8(%ebp)
     b86:	dd 05 00 5e 01 00    	fldl   0x15e00
     b8c:	df e9                	fucomip %st(1),%st
     b8e:	dd d8                	fstp   %st(0)
     b90:	76 16                	jbe    ba8 <sin+0xef>
    {
        x += PI;
     b92:	d9 45 08             	flds   0x8(%ebp)
     b95:	dd 05 e8 5d 01 00    	fldl   0x15de8
     b9b:	de c1                	faddp  %st,%st(1)
     b9d:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     ba0:	d9 45 f4             	flds   -0xc(%ebp)
     ba3:	d9 e0                	fchs   
     ba5:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     ba8:	d9 ee                	fldz   
     baa:	d9 45 08             	flds   0x8(%ebp)
     bad:	d9 c9                	fxch   %st(1)
     baf:	df e9                	fucomip %st(1),%st
     bb1:	dd d8                	fstp   %st(0)
     bb3:	76 10                	jbe    bc5 <sin+0x10c>
    {
        x *= -1;
     bb5:	d9 45 08             	flds   0x8(%ebp)
     bb8:	d9 e0                	fchs   
     bba:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     bbd:	d9 45 f4             	flds   -0xc(%ebp)
     bc0:	d9 e0                	fchs   
     bc2:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     bc5:	d9 45 08             	flds   0x8(%ebp)
     bc8:	dd 05 08 5e 01 00    	fldl   0x15e08
     bce:	d9 c9                	fxch   %st(1)
     bd0:	df e9                	fucomip %st(1),%st
     bd2:	dd d8                	fstp   %st(0)
     bd4:	76 28                	jbe    bfe <sin+0x145>
     bd6:	d9 45 08             	flds   0x8(%ebp)
     bd9:	dd 05 f8 5d 01 00    	fldl   0x15df8
     bdf:	de e1                	fsubp  %st,%st(1)
     be1:	d9 5d e4             	fstps  -0x1c(%ebp)
     be4:	d9 45 e4             	flds   -0x1c(%ebp)
     be7:	83 ec 0c             	sub    $0xc,%esp
     bea:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     bee:	d9 1c 24             	fstps  (%esp)
     bf1:	e8 20 fd ff ff       	call   916 <cos>
     bf6:	83 c4 10             	add    $0x10,%esp
     bf9:	d8 4d f4             	fmuls  -0xc(%ebp)
     bfc:	eb 7a                	jmp    c78 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     bfe:	83 ec 08             	sub    $0x8,%esp
     c01:	6a 03                	push   $0x3
     c03:	ff 75 08             	pushl  0x8(%ebp)
     c06:	e8 5e fc ff ff       	call   869 <pow>
     c0b:	83 c4 10             	add    $0x10,%esp
     c0e:	d9 05 1c 5e 01 00    	flds   0x15e1c
     c14:	de f9                	fdivrp %st,%st(1)
     c16:	d9 45 08             	flds   0x8(%ebp)
     c19:	de e1                	fsubp  %st,%st(1)
     c1b:	d9 5d d8             	fstps  -0x28(%ebp)
     c1e:	83 ec 08             	sub    $0x8,%esp
     c21:	6a 05                	push   $0x5
     c23:	ff 75 08             	pushl  0x8(%ebp)
     c26:	e8 3e fc ff ff       	call   869 <pow>
     c2b:	83 c4 10             	add    $0x10,%esp
     c2e:	d9 05 20 5e 01 00    	flds   0x15e20
     c34:	de f9                	fdivrp %st,%st(1)
     c36:	d8 45 d8             	fadds  -0x28(%ebp)
     c39:	d9 5d d8             	fstps  -0x28(%ebp)
     c3c:	83 ec 08             	sub    $0x8,%esp
     c3f:	6a 07                	push   $0x7
     c41:	ff 75 08             	pushl  0x8(%ebp)
     c44:	e8 20 fc ff ff       	call   869 <pow>
     c49:	83 c4 10             	add    $0x10,%esp
     c4c:	d9 05 24 5e 01 00    	flds   0x15e24
     c52:	de f9                	fdivrp %st,%st(1)
     c54:	d8 6d d8             	fsubrs -0x28(%ebp)
     c57:	d9 5d d8             	fstps  -0x28(%ebp)
     c5a:	83 ec 08             	sub    $0x8,%esp
     c5d:	6a 09                	push   $0x9
     c5f:	ff 75 08             	pushl  0x8(%ebp)
     c62:	e8 02 fc ff ff       	call   869 <pow>
     c67:	83 c4 10             	add    $0x10,%esp
     c6a:	d9 05 28 5e 01 00    	flds   0x15e28
     c70:	de f9                	fdivrp %st,%st(1)
     c72:	d8 45 d8             	fadds  -0x28(%ebp)
     c75:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     c78:	c9                   	leave  
     c79:	c3                   	ret    

00000c7a <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     c7a:	55                   	push   %ebp
     c7b:	89 e5                	mov    %esp,%ebp
     c7d:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     c80:	83 ec 04             	sub    $0x4,%esp
     c83:	6a 0e                	push   $0xe
     c85:	ff 75 0c             	pushl  0xc(%ebp)
     c88:	ff 75 08             	pushl  0x8(%ebp)
     c8b:	e8 44 f6 ff ff       	call   2d4 <read>
     c90:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     c93:	83 ec 04             	sub    $0x4,%esp
     c96:	6a 28                	push   $0x28
     c98:	ff 75 10             	pushl  0x10(%ebp)
     c9b:	ff 75 08             	pushl  0x8(%ebp)
     c9e:	e8 31 f6 ff ff       	call   2d4 <read>
     ca3:	83 c4 10             	add    $0x10,%esp
}
     ca6:	90                   	nop
     ca7:	c9                   	leave  
     ca8:	c3                   	ret    

00000ca9 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     ca9:	55                   	push   %ebp
     caa:	89 e5                	mov    %esp,%ebp
     cac:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     cb2:	83 ec 08             	sub    $0x8,%esp
     cb5:	6a 00                	push   $0x0
     cb7:	ff 75 08             	pushl  0x8(%ebp)
     cba:	e8 3d f6 ff ff       	call   2fc <open>
     cbf:	83 c4 10             	add    $0x10,%esp
     cc2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     cc5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     cc9:	79 0a                	jns    cd5 <readBitmapFile+0x2c>
        return -1;
     ccb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     cd0:	e9 6e 01 00 00       	jmp    e43 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     cd5:	83 ec 04             	sub    $0x4,%esp
     cd8:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     cdb:	50                   	push   %eax
     cdc:	8d 45 ca             	lea    -0x36(%ebp),%eax
     cdf:	50                   	push   %eax
     ce0:	ff 75 ec             	pushl  -0x14(%ebp)
     ce3:	e8 92 ff ff ff       	call   c7a <readBitmapHeader>
     ce8:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     ceb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     cee:	83 e8 36             	sub    $0x36,%eax
     cf1:	83 ec 04             	sub    $0x4,%esp
     cf4:	50                   	push   %eax
     cf5:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     cfb:	50                   	push   %eax
     cfc:	ff 75 ec             	pushl  -0x14(%ebp)
     cff:	e8 d0 f5 ff ff       	call   2d4 <read>
     d04:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     d07:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     d0a:	8b 45 14             	mov    0x14(%ebp),%eax
     d0d:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     d0f:	8b 55 aa             	mov    -0x56(%ebp),%edx
     d12:	8b 45 10             	mov    0x10(%ebp),%eax
     d15:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     d17:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     d1a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     d1d:	8b 45 aa             	mov    -0x56(%ebp),%eax
     d20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     d23:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     d27:	0f b7 c0             	movzwl %ax,%eax
     d2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     d2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
     d30:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     d34:	8d 50 07             	lea    0x7(%eax),%edx
     d37:	85 c0                	test   %eax,%eax
     d39:	0f 48 c2             	cmovs  %edx,%eax
     d3c:	c1 f8 03             	sar    $0x3,%eax
     d3f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     d42:	8b 45 0c             	mov    0xc(%ebp),%eax
     d45:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     d48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     d4b:	83 e8 01             	sub    $0x1,%eax
     d4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d51:	e9 d0 00 00 00       	jmp    e26 <readBitmapFile+0x17d>
        if (bits == 32) {
     d56:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     d5a:	75 22                	jne    d7e <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d5f:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     d63:	89 c2                	mov    %eax,%edx
     d65:	8b 45 d8             	mov    -0x28(%ebp),%eax
     d68:	01 d0                	add    %edx,%eax
     d6a:	83 ec 04             	sub    $0x4,%esp
     d6d:	ff 75 dc             	pushl  -0x24(%ebp)
     d70:	50                   	push   %eax
     d71:	ff 75 ec             	pushl  -0x14(%ebp)
     d74:	e8 5b f5 ff ff       	call   2d4 <read>
     d79:	83 c4 10             	add    $0x10,%esp
     d7c:	eb 65                	jmp    de3 <readBitmapFile+0x13a>
        } else {
            int j = 0;
     d7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     d85:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     d8c:	eb 4d                	jmp    ddb <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     d8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d91:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     d95:	c1 e0 02             	shl    $0x2,%eax
     d98:	89 c2                	mov    %eax,%edx
     d9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     d9d:	c1 e0 02             	shl    $0x2,%eax
     da0:	01 c2                	add    %eax,%edx
     da2:	8b 45 d8             	mov    -0x28(%ebp),%eax
     da5:	01 d0                	add    %edx,%eax
     da7:	83 ec 04             	sub    $0x4,%esp
     daa:	6a 03                	push   $0x3
     dac:	50                   	push   %eax
     dad:	ff 75 ec             	pushl  -0x14(%ebp)
     db0:	e8 1f f5 ff ff       	call   2d4 <read>
     db5:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     dbb:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     dbf:	c1 e0 02             	shl    $0x2,%eax
     dc2:	89 c2                	mov    %eax,%edx
     dc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
     dc7:	c1 e0 02             	shl    $0x2,%eax
     dca:	01 d0                	add    %edx,%eax
     dcc:	8d 50 03             	lea    0x3(%eax),%edx
     dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
     dd2:	01 d0                	add    %edx,%eax
     dd4:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     dd7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     ddb:	8b 45 f0             	mov    -0x10(%ebp),%eax
     dde:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     de1:	7c ab                	jl     d8e <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     de3:	8b 45 dc             	mov    -0x24(%ebp),%eax
     de6:	99                   	cltd   
     de7:	c1 ea 1e             	shr    $0x1e,%edx
     dea:	01 d0                	add    %edx,%eax
     dec:	83 e0 03             	and    $0x3,%eax
     def:	29 d0                	sub    %edx,%eax
     df1:	85 c0                	test   %eax,%eax
     df3:	7e 2d                	jle    e22 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     df5:	8b 45 dc             	mov    -0x24(%ebp),%eax
     df8:	99                   	cltd   
     df9:	c1 ea 1e             	shr    $0x1e,%edx
     dfc:	01 d0                	add    %edx,%eax
     dfe:	83 e0 03             	and    $0x3,%eax
     e01:	29 d0                	sub    %edx,%eax
     e03:	ba 04 00 00 00       	mov    $0x4,%edx
     e08:	29 c2                	sub    %eax,%edx
     e0a:	89 d0                	mov    %edx,%eax
     e0c:	83 ec 04             	sub    $0x4,%esp
     e0f:	50                   	push   %eax
     e10:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     e16:	50                   	push   %eax
     e17:	ff 75 ec             	pushl  -0x14(%ebp)
     e1a:	e8 b5 f4 ff ff       	call   2d4 <read>
     e1f:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     e22:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     e26:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     e2a:	0f 89 26 ff ff ff    	jns    d56 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     e30:	83 ec 0c             	sub    $0xc,%esp
     e33:	ff 75 ec             	pushl  -0x14(%ebp)
     e36:	e8 a9 f4 ff ff       	call   2e4 <close>
     e3b:	83 c4 10             	add    $0x10,%esp
    return 0;
     e3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
     e43:	c9                   	leave  
     e44:	c3                   	ret    

00000e45 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     e45:	55                   	push   %ebp
     e46:	89 e5                	mov    %esp,%ebp
     e48:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     e4e:	83 ec 08             	sub    $0x8,%esp
     e51:	6a 00                	push   $0x0
     e53:	ff 75 08             	pushl  0x8(%ebp)
     e56:	e8 a1 f4 ff ff       	call   2fc <open>
     e5b:	83 c4 10             	add    $0x10,%esp
     e5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     e61:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     e65:	79 0a                	jns    e71 <read24BitmapFile+0x2c>
        return -1;
     e67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     e6c:	e9 66 01 00 00       	jmp    fd7 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     e71:	83 ec 04             	sub    $0x4,%esp
     e74:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     e77:	50                   	push   %eax
     e78:	8d 45 ca             	lea    -0x36(%ebp),%eax
     e7b:	50                   	push   %eax
     e7c:	ff 75 ec             	pushl  -0x14(%ebp)
     e7f:	e8 f6 fd ff ff       	call   c7a <readBitmapHeader>
     e84:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     e87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     e8a:	83 e8 36             	sub    $0x36,%eax
     e8d:	83 ec 04             	sub    $0x4,%esp
     e90:	50                   	push   %eax
     e91:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     e97:	50                   	push   %eax
     e98:	ff 75 ec             	pushl  -0x14(%ebp)
     e9b:	e8 34 f4 ff ff       	call   2d4 <read>
     ea0:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     ea3:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     ea6:	8b 45 14             	mov    0x14(%ebp),%eax
     ea9:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     eab:	8b 55 aa             	mov    -0x56(%ebp),%edx
     eae:	8b 45 10             	mov    0x10(%ebp),%eax
     eb1:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     eb3:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     eb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     eb9:	8b 45 aa             	mov    -0x56(%ebp),%eax
     ebc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     ebf:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     ec3:	0f b7 c0             	movzwl %ax,%eax
     ec6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     ec9:	8b 55 e8             	mov    -0x18(%ebp),%edx
     ecc:	89 d0                	mov    %edx,%eax
     ece:	01 c0                	add    %eax,%eax
     ed0:	01 d0                	add    %edx,%eax
     ed2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     ed5:	8b 45 0c             	mov    0xc(%ebp),%eax
     ed8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     edb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     ede:	83 e8 01             	sub    $0x1,%eax
     ee1:	89 45 f4             	mov    %eax,-0xc(%ebp)
     ee4:	e9 d1 00 00 00       	jmp    fba <read24BitmapFile+0x175>
        if (bits == 24) {
     ee9:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     eed:	75 22                	jne    f11 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     eef:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ef2:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     ef6:	89 c2                	mov    %eax,%edx
     ef8:	8b 45 d8             	mov    -0x28(%ebp),%eax
     efb:	01 d0                	add    %edx,%eax
     efd:	83 ec 04             	sub    $0x4,%esp
     f00:	ff 75 dc             	pushl  -0x24(%ebp)
     f03:	50                   	push   %eax
     f04:	ff 75 ec             	pushl  -0x14(%ebp)
     f07:	e8 c8 f3 ff ff       	call   2d4 <read>
     f0c:	83 c4 10             	add    $0x10,%esp
     f0f:	eb 66                	jmp    f77 <read24BitmapFile+0x132>
        } else {
            int j = 0;
     f11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     f18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     f1f:	eb 4e                	jmp    f6f <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
     f21:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f24:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     f28:	89 c2                	mov    %eax,%edx
     f2a:	89 d0                	mov    %edx,%eax
     f2c:	01 c0                	add    %eax,%eax
     f2e:	01 d0                	add    %edx,%eax
     f30:	89 c1                	mov    %eax,%ecx
     f32:	8b 55 f0             	mov    -0x10(%ebp),%edx
     f35:	89 d0                	mov    %edx,%eax
     f37:	01 c0                	add    %eax,%eax
     f39:	01 d0                	add    %edx,%eax
     f3b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
     f3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f41:	01 d0                	add    %edx,%eax
     f43:	83 ec 04             	sub    $0x4,%esp
     f46:	6a 03                	push   $0x3
     f48:	50                   	push   %eax
     f49:	ff 75 ec             	pushl  -0x14(%ebp)
     f4c:	e8 83 f3 ff ff       	call   2d4 <read>
     f51:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
     f54:	83 ec 04             	sub    $0x4,%esp
     f57:	6a 01                	push   $0x1
     f59:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f5f:	50                   	push   %eax
     f60:	ff 75 ec             	pushl  -0x14(%ebp)
     f63:	e8 6c f3 ff ff       	call   2d4 <read>
     f68:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     f6b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     f6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f72:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     f75:	7c aa                	jl     f21 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
     f77:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f7a:	99                   	cltd   
     f7b:	c1 ea 1e             	shr    $0x1e,%edx
     f7e:	01 d0                	add    %edx,%eax
     f80:	83 e0 03             	and    $0x3,%eax
     f83:	29 d0                	sub    %edx,%eax
     f85:	85 c0                	test   %eax,%eax
     f87:	7e 2d                	jle    fb6 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     f89:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f8c:	99                   	cltd   
     f8d:	c1 ea 1e             	shr    $0x1e,%edx
     f90:	01 d0                	add    %edx,%eax
     f92:	83 e0 03             	and    $0x3,%eax
     f95:	29 d0                	sub    %edx,%eax
     f97:	ba 04 00 00 00       	mov    $0x4,%edx
     f9c:	29 c2                	sub    %eax,%edx
     f9e:	89 d0                	mov    %edx,%eax
     fa0:	83 ec 04             	sub    $0x4,%esp
     fa3:	50                   	push   %eax
     fa4:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     faa:	50                   	push   %eax
     fab:	ff 75 ec             	pushl  -0x14(%ebp)
     fae:	e8 21 f3 ff ff       	call   2d4 <read>
     fb3:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     fb6:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     fba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     fbe:	0f 89 25 ff ff ff    	jns    ee9 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     fc4:	83 ec 0c             	sub    $0xc,%esp
     fc7:	ff 75 ec             	pushl  -0x14(%ebp)
     fca:	e8 15 f3 ff ff       	call   2e4 <close>
     fcf:	83 c4 10             	add    $0x10,%esp
    return 0;
     fd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
     fd7:	c9                   	leave  
     fd8:	c3                   	ret    

00000fd9 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
     fd9:	55                   	push   %ebp
     fda:	89 e5                	mov    %esp,%ebp
     fdc:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
     fdf:	8b 55 10             	mov    0x10(%ebp),%edx
     fe2:	89 d0                	mov    %edx,%eax
     fe4:	01 c0                	add    %eax,%eax
     fe6:	01 d0                	add    %edx,%eax
     fe8:	c1 e0 03             	shl    $0x3,%eax
     feb:	83 c0 1f             	add    $0x1f,%eax
     fee:	8d 50 1f             	lea    0x1f(%eax),%edx
     ff1:	85 c0                	test   %eax,%eax
     ff3:	0f 48 c2             	cmovs  %edx,%eax
     ff6:	c1 f8 05             	sar    $0x5,%eax
     ff9:	c1 e0 02             	shl    $0x2,%eax
     ffc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
     fff:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    1005:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1008:	0f af 45 0c          	imul   0xc(%ebp),%eax
    100c:	83 c0 36             	add    $0x36,%eax
    100f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    1012:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    1018:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    101e:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    1025:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    102c:	8b 45 10             	mov    0x10(%ebp),%eax
    102f:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    1032:	8b 45 0c             	mov    0xc(%ebp),%eax
    1035:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1038:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    103e:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1044:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    104b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    104e:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1052:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1055:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    105c:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1063:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    106a:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1071:	83 ec 04             	sub    $0x4,%esp
    1074:	6a 0e                	push   $0xe
    1076:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1079:	50                   	push   %eax
    107a:	ff 75 08             	pushl  0x8(%ebp)
    107d:	e8 5a f2 ff ff       	call   2dc <write>
    1082:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1085:	83 ec 04             	sub    $0x4,%esp
    1088:	6a 28                	push   $0x28
    108a:	8d 45 be             	lea    -0x42(%ebp),%eax
    108d:	50                   	push   %eax
    108e:	ff 75 08             	pushl  0x8(%ebp)
    1091:	e8 46 f2 ff ff       	call   2dc <write>
    1096:	83 c4 10             	add    $0x10,%esp
}
    1099:	90                   	nop
    109a:	c9                   	leave  
    109b:	c3                   	ret    

0000109c <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    109c:	55                   	push   %ebp
    109d:	89 e5                	mov    %esp,%ebp
    109f:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    10a2:	83 ec 08             	sub    $0x8,%esp
    10a5:	68 02 02 00 00       	push   $0x202
    10aa:	ff 75 08             	pushl  0x8(%ebp)
    10ad:	e8 4a f2 ff ff       	call   2fc <open>
    10b2:	83 c4 10             	add    $0x10,%esp
    10b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    10b8:	8b 55 14             	mov    0x14(%ebp),%edx
    10bb:	89 d0                	mov    %edx,%eax
    10bd:	01 c0                	add    %eax,%eax
    10bf:	01 d0                	add    %edx,%eax
    10c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    10c4:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    10c8:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    10cc:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    10d0:	83 ec 04             	sub    $0x4,%esp
    10d3:	ff 75 14             	pushl  0x14(%ebp)
    10d6:	ff 75 10             	pushl  0x10(%ebp)
    10d9:	ff 75 f0             	pushl  -0x10(%ebp)
    10dc:	e8 f8 fe ff ff       	call   fd9 <write24BitmapFileHeader>
    10e1:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    10e4:	8b 45 10             	mov    0x10(%ebp),%eax
    10e7:	83 e8 01             	sub    $0x1,%eax
    10ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
    10ed:	eb 66                	jmp    1155 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    10ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10f2:	0f af 45 14          	imul   0x14(%ebp),%eax
    10f6:	89 c2                	mov    %eax,%edx
    10f8:	89 d0                	mov    %edx,%eax
    10fa:	01 c0                	add    %eax,%eax
    10fc:	01 c2                	add    %eax,%edx
    10fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    1101:	01 d0                	add    %edx,%eax
    1103:	83 ec 04             	sub    $0x4,%esp
    1106:	ff 75 ec             	pushl  -0x14(%ebp)
    1109:	50                   	push   %eax
    110a:	ff 75 f0             	pushl  -0x10(%ebp)
    110d:	e8 ca f1 ff ff       	call   2dc <write>
    1112:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    1115:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1118:	99                   	cltd   
    1119:	c1 ea 1e             	shr    $0x1e,%edx
    111c:	01 d0                	add    %edx,%eax
    111e:	83 e0 03             	and    $0x3,%eax
    1121:	29 d0                	sub    %edx,%eax
    1123:	85 c0                	test   %eax,%eax
    1125:	7e 2a                	jle    1151 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1127:	8b 45 ec             	mov    -0x14(%ebp),%eax
    112a:	99                   	cltd   
    112b:	c1 ea 1e             	shr    $0x1e,%edx
    112e:	01 d0                	add    %edx,%eax
    1130:	83 e0 03             	and    $0x3,%eax
    1133:	29 d0                	sub    %edx,%eax
    1135:	ba 04 00 00 00       	mov    $0x4,%edx
    113a:	29 c2                	sub    %eax,%edx
    113c:	89 d0                	mov    %edx,%eax
    113e:	83 ec 04             	sub    $0x4,%esp
    1141:	50                   	push   %eax
    1142:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1145:	50                   	push   %eax
    1146:	ff 75 f0             	pushl  -0x10(%ebp)
    1149:	e8 8e f1 ff ff       	call   2dc <write>
    114e:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1151:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1155:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1159:	79 94                	jns    10ef <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    115b:	83 ec 0c             	sub    $0xc,%esp
    115e:	ff 75 f0             	pushl  -0x10(%ebp)
    1161:	e8 7e f1 ff ff       	call   2e4 <close>
    1166:	83 c4 10             	add    $0x10,%esp
    return 0;
    1169:	b8 00 00 00 00       	mov    $0x0,%eax
    116e:	c9                   	leave  
    116f:	c3                   	ret    

00001170 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    1170:	55                   	push   %ebp
    1171:	89 e5                	mov    %esp,%ebp
    1173:	57                   	push   %edi
    1174:	56                   	push   %esi
    1175:	53                   	push   %ebx
    1176:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1179:	8b 45 08             	mov    0x8(%ebp),%eax
    117c:	8b 50 10             	mov    0x10(%eax),%edx
    117f:	8b 40 0c             	mov    0xc(%eax),%eax
    1182:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1185:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1188:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    118b:	8b 55 e0             	mov    -0x20(%ebp),%edx
    118e:	83 c2 1e             	add    $0x1e,%edx
    1191:	0f af d0             	imul   %eax,%edx
    1194:	89 d0                	mov    %edx,%eax
    1196:	01 c0                	add    %eax,%eax
    1198:	01 d0                	add    %edx,%eax
    119a:	83 ec 0c             	sub    $0xc,%esp
    119d:	50                   	push   %eax
    119e:	e8 93 f5 ff ff       	call   736 <malloc>
    11a3:	83 c4 10             	add    $0x10,%esp
    11a6:	89 c2                	mov    %eax,%edx
    11a8:	8b 45 08             	mov    0x8(%ebp),%eax
    11ab:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    11ae:	8b 45 08             	mov    0x8(%ebp),%eax
    11b1:	8b 40 1c             	mov    0x1c(%eax),%eax
    11b4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11b7:	6b d2 5a             	imul   $0x5a,%edx,%edx
    11ba:	01 c2                	add    %eax,%edx
    11bc:	8b 45 08             	mov    0x8(%ebp),%eax
    11bf:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    11c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    11c8:	0f af d0             	imul   %eax,%edx
    11cb:	89 d0                	mov    %edx,%eax
    11cd:	01 c0                	add    %eax,%eax
    11cf:	01 d0                	add    %edx,%eax
    11d1:	89 c2                	mov    %eax,%edx
    11d3:	8b 45 08             	mov    0x8(%ebp),%eax
    11d6:	8b 40 18             	mov    0x18(%eax),%eax
    11d9:	83 ec 04             	sub    $0x4,%esp
    11dc:	52                   	push   %edx
    11dd:	68 ff 00 00 00       	push   $0xff
    11e2:	50                   	push   %eax
    11e3:	e8 39 ef ff ff       	call   121 <memset>
    11e8:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    11eb:	8b 45 08             	mov    0x8(%ebp),%eax
    11ee:	8b 78 1c             	mov    0x1c(%eax),%edi
    11f1:	8b 45 08             	mov    0x8(%ebp),%eax
    11f4:	8b 70 14             	mov    0x14(%eax),%esi
    11f7:	8b 45 08             	mov    0x8(%ebp),%eax
    11fa:	8b 58 0c             	mov    0xc(%eax),%ebx
    11fd:	8b 45 08             	mov    0x8(%ebp),%eax
    1200:	8b 48 10             	mov    0x10(%eax),%ecx
    1203:	8b 45 08             	mov    0x8(%ebp),%eax
    1206:	8b 50 08             	mov    0x8(%eax),%edx
    1209:	8b 45 08             	mov    0x8(%ebp),%eax
    120c:	8b 40 04             	mov    0x4(%eax),%eax
    120f:	83 ec 08             	sub    $0x8,%esp
    1212:	57                   	push   %edi
    1213:	56                   	push   %esi
    1214:	53                   	push   %ebx
    1215:	51                   	push   %ecx
    1216:	52                   	push   %edx
    1217:	50                   	push   %eax
    1218:	e8 3f f1 ff ff       	call   35c <createwindow>
    121d:	83 c4 20             	add    $0x20,%esp
    1220:	89 c2                	mov    %eax,%edx
    1222:	8b 45 08             	mov    0x8(%ebp),%eax
    1225:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    1227:	8b 45 08             	mov    0x8(%ebp),%eax
    122a:	8b 00                	mov    (%eax),%eax
}
    122c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    122f:	5b                   	pop    %ebx
    1230:	5e                   	pop    %esi
    1231:	5f                   	pop    %edi
    1232:	5d                   	pop    %ebp
    1233:	c3                   	ret    

00001234 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    1234:	55                   	push   %ebp
    1235:	89 e5                	mov    %esp,%ebp
    1237:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    123a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1241:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1248:	8b 45 08             	mov    0x8(%ebp),%eax
    124b:	8b 40 18             	mov    0x18(%eax),%eax
    124e:	ff 75 1c             	pushl  0x1c(%ebp)
    1251:	ff 75 18             	pushl  0x18(%ebp)
    1254:	ff 75 1c             	pushl  0x1c(%ebp)
    1257:	ff 75 18             	pushl  0x18(%ebp)
    125a:	8b 55 08             	mov    0x8(%ebp),%edx
    125d:	ff 72 10             	pushl  0x10(%edx)
    1260:	ff 72 0c             	pushl  0xc(%edx)
    1263:	ff 75 f4             	pushl  -0xc(%ebp)
    1266:	ff 75 f0             	pushl  -0x10(%ebp)
    1269:	ff 75 14             	pushl  0x14(%ebp)
    126c:	ff 75 10             	pushl  0x10(%ebp)
    126f:	ff 75 0c             	pushl  0xc(%ebp)
    1272:	50                   	push   %eax
    1273:	e8 d5 07 00 00       	call   1a4d <drawBitmap>
    1278:	83 c4 30             	add    $0x30,%esp
    return 0;
    127b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1280:	c9                   	leave  
    1281:	c3                   	ret    

00001282 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1282:	55                   	push   %ebp
    1283:	89 e5                	mov    %esp,%ebp
    1285:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1288:	8b 45 08             	mov    0x8(%ebp),%eax
    128b:	8b 40 18             	mov    0x18(%eax),%eax
    128e:	ff 75 2c             	pushl  0x2c(%ebp)
    1291:	ff 75 28             	pushl  0x28(%ebp)
    1294:	ff 75 24             	pushl  0x24(%ebp)
    1297:	ff 75 20             	pushl  0x20(%ebp)
    129a:	8b 55 08             	mov    0x8(%ebp),%edx
    129d:	ff 72 10             	pushl  0x10(%edx)
    12a0:	ff 72 0c             	pushl  0xc(%edx)
    12a3:	ff 75 1c             	pushl  0x1c(%ebp)
    12a6:	ff 75 18             	pushl  0x18(%ebp)
    12a9:	ff 75 14             	pushl  0x14(%ebp)
    12ac:	ff 75 10             	pushl  0x10(%ebp)
    12af:	ff 75 0c             	pushl  0xc(%ebp)
    12b2:	50                   	push   %eax
    12b3:	e8 95 07 00 00       	call   1a4d <drawBitmap>
    12b8:	83 c4 30             	add    $0x30,%esp
    return 0;
    12bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12c0:	c9                   	leave  
    12c1:	c3                   	ret    

000012c2 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    12c2:	55                   	push   %ebp
    12c3:	89 e5                	mov    %esp,%ebp
    12c5:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    12c8:	8b 45 08             	mov    0x8(%ebp),%eax
    12cb:	8b 40 18             	mov    0x18(%eax),%eax
    12ce:	ff 75 2c             	pushl  0x2c(%ebp)
    12d1:	ff 75 28             	pushl  0x28(%ebp)
    12d4:	ff 75 24             	pushl  0x24(%ebp)
    12d7:	ff 75 20             	pushl  0x20(%ebp)
    12da:	8b 55 08             	mov    0x8(%ebp),%edx
    12dd:	ff 72 10             	pushl  0x10(%edx)
    12e0:	ff 72 0c             	pushl  0xc(%edx)
    12e3:	ff 75 1c             	pushl  0x1c(%ebp)
    12e6:	ff 75 18             	pushl  0x18(%ebp)
    12e9:	ff 75 14             	pushl  0x14(%ebp)
    12ec:	ff 75 10             	pushl  0x10(%ebp)
    12ef:	ff 75 0c             	pushl  0xc(%ebp)
    12f2:	50                   	push   %eax
    12f3:	e8 75 08 00 00       	call   1b6d <drawTransparentBitmap>
    12f8:	83 c4 30             	add    $0x30,%esp
    return 0;
    12fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1300:	c9                   	leave  
    1301:	c3                   	ret    

00001302 <api_repaint>:

int api_repaint(Window* wnd)
{
    1302:	55                   	push   %ebp
    1303:	89 e5                	mov    %esp,%ebp
    1305:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1308:	8b 45 08             	mov    0x8(%ebp),%eax
    130b:	8b 00                	mov    (%eax),%eax
    130d:	83 ec 0c             	sub    $0xc,%esp
    1310:	50                   	push   %eax
    1311:	e8 4e f0 ff ff       	call   364 <repaintwindow>
    1316:	83 c4 10             	add    $0x10,%esp
    return 0;
    1319:	b8 00 00 00 00       	mov    $0x0,%eax
}
    131e:	c9                   	leave  
    131f:	c3                   	ret    

00001320 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    1320:	55                   	push   %ebp
    1321:	89 e5                	mov    %esp,%ebp
    1323:	56                   	push   %esi
    1324:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1325:	8b 75 18             	mov    0x18(%ebp),%esi
    1328:	8b 5d 14             	mov    0x14(%ebp),%ebx
    132b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    132e:	8b 55 0c             	mov    0xc(%ebp),%edx
    1331:	8b 45 08             	mov    0x8(%ebp),%eax
    1334:	8b 00                	mov    (%eax),%eax
    1336:	83 ec 0c             	sub    $0xc,%esp
    1339:	56                   	push   %esi
    133a:	53                   	push   %ebx
    133b:	51                   	push   %ecx
    133c:	52                   	push   %edx
    133d:	50                   	push   %eax
    133e:	e8 39 f0 ff ff       	call   37c <updatewindow>
    1343:	83 c4 20             	add    $0x20,%esp
    return 0;
    1346:	b8 00 00 00 00       	mov    $0x0,%eax
}
    134b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    134e:	5b                   	pop    %ebx
    134f:	5e                   	pop    %esi
    1350:	5d                   	pop    %ebp
    1351:	c3                   	ret    

00001352 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1352:	55                   	push   %ebp
    1353:	89 e5                	mov    %esp,%ebp
    1355:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1358:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    135f:	8b 45 08             	mov    0x8(%ebp),%eax
    1362:	8b 00                	mov    (%eax),%eax
    1364:	83 ec 08             	sub    $0x8,%esp
    1367:	8d 55 c8             	lea    -0x38(%ebp),%edx
    136a:	52                   	push   %edx
    136b:	50                   	push   %eax
    136c:	e8 fb ef ff ff       	call   36c <getmessage>
    1371:	83 c4 10             	add    $0x10,%esp
    1374:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1377:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    137b:	74 e2                	je     135f <api_exec+0xd>
        {
            pf(&msg);
    137d:	83 ec 0c             	sub    $0xc,%esp
    1380:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1383:	50                   	push   %eax
    1384:	8b 45 0c             	mov    0xc(%ebp),%eax
    1387:	ff d0                	call   *%eax
    1389:	83 c4 10             	add    $0x10,%esp
        }
    }
    138c:	eb d1                	jmp    135f <api_exec+0xd>

0000138e <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    138e:	55                   	push   %ebp
    138f:	89 e5                	mov    %esp,%ebp
    1391:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1394:	8b 45 08             	mov    0x8(%ebp),%eax
    1397:	8b 00                	mov    (%eax),%eax
    1399:	83 ec 08             	sub    $0x8,%esp
    139c:	ff 75 0c             	pushl  0xc(%ebp)
    139f:	50                   	push   %eax
    13a0:	e8 cf ef ff ff       	call   374 <settimer>
    13a5:	83 c4 10             	add    $0x10,%esp
    return 0;
    13a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13ad:	c9                   	leave  
    13ae:	c3                   	ret    

000013af <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    13af:	55                   	push   %ebp
    13b0:	89 e5                	mov    %esp,%ebp
    13b2:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    13b5:	8b 45 08             	mov    0x8(%ebp),%eax
    13b8:	8b 50 18             	mov    0x18(%eax),%edx
    13bb:	ff 75 18             	pushl  0x18(%ebp)
    13be:	ff 75 14             	pushl  0x14(%ebp)
    13c1:	83 ec 04             	sub    $0x4,%esp
    13c4:	89 e0                	mov    %esp,%eax
    13c6:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    13ca:	66 89 08             	mov    %cx,(%eax)
    13cd:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    13d1:	88 48 02             	mov    %cl,0x2(%eax)
    13d4:	8b 45 08             	mov    0x8(%ebp),%eax
    13d7:	ff 70 10             	pushl  0x10(%eax)
    13da:	ff 70 0c             	pushl  0xc(%eax)
    13dd:	ff 75 10             	pushl  0x10(%ebp)
    13e0:	ff 75 0c             	pushl  0xc(%ebp)
    13e3:	52                   	push   %edx
    13e4:	e8 6f 04 00 00       	call   1858 <drawRect>
    13e9:	83 c4 20             	add    $0x20,%esp
    return 0;
    13ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13f1:	c9                   	leave  
    13f2:	c3                   	ret    

000013f3 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    13f3:	55                   	push   %ebp
    13f4:	89 e5                	mov    %esp,%ebp
    13f6:	83 ec 28             	sub    $0x28,%esp
    13f9:	8b 45 14             	mov    0x14(%ebp),%eax
    13fc:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    13ff:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    1403:	8b 45 0c             	mov    0xc(%ebp),%eax
    1406:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1409:	8b 45 10             	mov    0x10(%ebp),%eax
    140c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    140f:	8b 45 08             	mov    0x8(%ebp),%eax
    1412:	8b 40 18             	mov    0x18(%eax),%eax
    1415:	83 ec 04             	sub    $0x4,%esp
    1418:	ff 75 18             	pushl  0x18(%ebp)
    141b:	52                   	push   %edx
    141c:	8b 55 08             	mov    0x8(%ebp),%edx
    141f:	ff 72 10             	pushl  0x10(%edx)
    1422:	ff 72 0c             	pushl  0xc(%edx)
    1425:	ff 75 f4             	pushl  -0xc(%ebp)
    1428:	ff 75 f0             	pushl  -0x10(%ebp)
    142b:	50                   	push   %eax
    142c:	e8 d4 02 00 00       	call   1705 <drawCharacter>
    1431:	83 c4 20             	add    $0x20,%esp
    return 0;
    1434:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1439:	c9                   	leave  
    143a:	c3                   	ret    

0000143b <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    143b:	55                   	push   %ebp
    143c:	89 e5                	mov    %esp,%ebp
    143e:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1441:	8b 45 0c             	mov    0xc(%ebp),%eax
    1444:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1447:	8b 45 10             	mov    0x10(%ebp),%eax
    144a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    144d:	8b 45 08             	mov    0x8(%ebp),%eax
    1450:	8b 40 18             	mov    0x18(%eax),%eax
    1453:	83 ec 04             	sub    $0x4,%esp
    1456:	ff 75 18             	pushl  0x18(%ebp)
    1459:	ff 75 14             	pushl  0x14(%ebp)
    145c:	8b 55 08             	mov    0x8(%ebp),%edx
    145f:	ff 72 10             	pushl  0x10(%edx)
    1462:	ff 72 0c             	pushl  0xc(%edx)
    1465:	ff 75 f4             	pushl  -0xc(%ebp)
    1468:	ff 75 f0             	pushl  -0x10(%ebp)
    146b:	50                   	push   %eax
    146c:	e8 8e 03 00 00       	call   17ff <drawString>
    1471:	83 c4 20             	add    $0x20,%esp
    return 0;
    1474:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1479:	c9                   	leave  
    147a:	c3                   	ret    

0000147b <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    147b:	55                   	push   %ebp
    147c:	89 e5                	mov    %esp,%ebp
    147e:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1481:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1485:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1489:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    148d:	83 ec 08             	sub    $0x8,%esp
    1490:	83 ec 04             	sub    $0x4,%esp
    1493:	89 e0                	mov    %esp,%eax
    1495:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    1499:	66 89 10             	mov    %dx,(%eax)
    149c:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    14a0:	88 50 02             	mov    %dl,0x2(%eax)
    14a3:	ff 75 18             	pushl  0x18(%ebp)
    14a6:	ff 75 14             	pushl  0x14(%ebp)
    14a9:	ff 75 10             	pushl  0x10(%ebp)
    14ac:	ff 75 0c             	pushl  0xc(%ebp)
    14af:	ff 75 08             	pushl  0x8(%ebp)
    14b2:	e8 f8 fe ff ff       	call   13af <api_drawRect>
    14b7:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    14ba:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    14be:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    14c2:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    14c6:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    14ca:	8b 45 10             	mov    0x10(%ebp),%eax
    14cd:	8d 50 0a             	lea    0xa(%eax),%edx
    14d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    14d3:	83 c0 0a             	add    $0xa,%eax
    14d6:	83 ec 0c             	sub    $0xc,%esp
    14d9:	ff 75 f4             	pushl  -0xc(%ebp)
    14dc:	ff 75 1c             	pushl  0x1c(%ebp)
    14df:	52                   	push   %edx
    14e0:	50                   	push   %eax
    14e1:	ff 75 08             	pushl  0x8(%ebp)
    14e4:	e8 52 ff ff ff       	call   143b <api_drawString>
    14e9:	83 c4 20             	add    $0x20,%esp
    return 0;
    14ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14f1:	c9                   	leave  
    14f2:	c3                   	ret    

000014f3 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    14f3:	55                   	push   %ebp
    14f4:	89 e5                	mov    %esp,%ebp
    14f6:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    14f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1500:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1507:	8b 45 08             	mov    0x8(%ebp),%eax
    150a:	8b 40 18             	mov    0x18(%eax),%eax
    150d:	ff 75 1c             	pushl  0x1c(%ebp)
    1510:	ff 75 18             	pushl  0x18(%ebp)
    1513:	ff 75 1c             	pushl  0x1c(%ebp)
    1516:	ff 75 18             	pushl  0x18(%ebp)
    1519:	8b 55 08             	mov    0x8(%ebp),%edx
    151c:	ff 72 10             	pushl  0x10(%edx)
    151f:	ff 72 0c             	pushl  0xc(%edx)
    1522:	ff 75 f4             	pushl  -0xc(%ebp)
    1525:	ff 75 f0             	pushl  -0x10(%ebp)
    1528:	ff 75 14             	pushl  0x14(%ebp)
    152b:	ff 75 10             	pushl  0x10(%ebp)
    152e:	ff 75 0c             	pushl  0xc(%ebp)
    1531:	50                   	push   %eax
    1532:	e8 16 05 00 00       	call   1a4d <drawBitmap>
    1537:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    153a:	8b 45 08             	mov    0x8(%ebp),%eax
    153d:	8b 40 18             	mov    0x18(%eax),%eax
    1540:	ff 75 28             	pushl  0x28(%ebp)
    1543:	ff 75 1c             	pushl  0x1c(%ebp)
    1546:	ff 75 18             	pushl  0x18(%ebp)
    1549:	8b 55 08             	mov    0x8(%ebp),%edx
    154c:	ff 72 10             	pushl  0x10(%edx)
    154f:	ff 72 0c             	pushl  0xc(%edx)
    1552:	ff 75 14             	pushl  0x14(%ebp)
    1555:	ff 75 10             	pushl  0x10(%ebp)
    1558:	50                   	push   %eax
    1559:	e8 99 07 00 00       	call   1cf7 <colorShift>
    155e:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1561:	8b 45 08             	mov    0x8(%ebp),%eax
    1564:	8b 50 18             	mov    0x18(%eax),%edx
    1567:	83 ec 0c             	sub    $0xc,%esp
    156a:	ff 75 20             	pushl  0x20(%ebp)
    156d:	ff 75 1c             	pushl  0x1c(%ebp)
    1570:	ff 75 18             	pushl  0x18(%ebp)
    1573:	83 ec 04             	sub    $0x4,%esp
    1576:	89 e0                	mov    %esp,%eax
    1578:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    157c:	66 89 08             	mov    %cx,(%eax)
    157f:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1583:	88 48 02             	mov    %cl,0x2(%eax)
    1586:	8b 45 08             	mov    0x8(%ebp),%eax
    1589:	ff 70 10             	pushl  0x10(%eax)
    158c:	ff 70 0c             	pushl  0xc(%eax)
    158f:	ff 75 14             	pushl  0x14(%ebp)
    1592:	ff 75 10             	pushl  0x10(%ebp)
    1595:	52                   	push   %edx
    1596:	e8 6d 03 00 00       	call   1908 <drawBorder>
    159b:	83 c4 30             	add    $0x30,%esp
    return 0;
    159e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15a3:	c9                   	leave  
    15a4:	c3                   	ret    

000015a5 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    15a5:	55                   	push   %ebp
    15a6:	89 e5                	mov    %esp,%ebp
    15a8:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    15ab:	8b 45 08             	mov    0x8(%ebp),%eax
    15ae:	8b 00                	mov    (%eax),%eax
    15b0:	83 ec 0c             	sub    $0xc,%esp
    15b3:	50                   	push   %eax
    15b4:	e8 cb ed ff ff       	call   384 <destroywindow>
    15b9:	83 c4 10             	add    $0x10,%esp
    return 0;
    15bc:	b8 00 00 00 00       	mov    $0x0,%eax
    15c1:	c9                   	leave  
    15c2:	c3                   	ret    

000015c3 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    15c3:	55                   	push   %ebp
    15c4:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    15c6:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    15ca:	8b 45 08             	mov    0x8(%ebp),%eax
    15cd:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    15d0:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    15d4:	8b 45 08             	mov    0x8(%ebp),%eax
    15d7:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    15da:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    15de:	8b 45 08             	mov    0x8(%ebp),%eax
    15e1:	88 10                	mov    %dl,(%eax)
}
    15e3:	90                   	nop
    15e4:	5d                   	pop    %ebp
    15e5:	c3                   	ret    

000015e6 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    15e6:	55                   	push   %ebp
    15e7:	89 e5                	mov    %esp,%ebp
    15e9:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    15ec:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    15f0:	3c ff                	cmp    $0xff,%al
    15f2:	75 22                	jne    1616 <drawPointAlpha+0x30>
        color->R = origin.R;
    15f4:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    15f8:	8b 45 08             	mov    0x8(%ebp),%eax
    15fb:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    15fe:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1602:	8b 45 08             	mov    0x8(%ebp),%eax
    1605:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    1608:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    160c:	8b 45 08             	mov    0x8(%ebp),%eax
    160f:	88 10                	mov    %dl,(%eax)
        return;
    1611:	e9 ed 00 00 00       	jmp    1703 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    1616:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    161a:	84 c0                	test   %al,%al
    161c:	0f 84 e0 00 00 00    	je     1702 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    1622:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1626:	0f b6 c0             	movzbl %al,%eax
    1629:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    162d:	df 45 e4             	fild   -0x1c(%ebp)
    1630:	d9 05 80 9c 01 00    	flds   0x19c80
    1636:	de f9                	fdivrp %st,%st(1)
    1638:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    163b:	8b 45 08             	mov    0x8(%ebp),%eax
    163e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1642:	0f b6 c0             	movzbl %al,%eax
    1645:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1648:	db 45 e4             	fildl  -0x1c(%ebp)
    164b:	d9 e8                	fld1   
    164d:	d8 65 fc             	fsubs  -0x4(%ebp)
    1650:	de c9                	fmulp  %st,%st(1)
    1652:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1656:	0f b6 c0             	movzbl %al,%eax
    1659:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    165c:	db 45 e4             	fildl  -0x1c(%ebp)
    165f:	d8 4d fc             	fmuls  -0x4(%ebp)
    1662:	de c1                	faddp  %st,%st(1)
    1664:	d9 7d ee             	fnstcw -0x12(%ebp)
    1667:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    166b:	b4 0c                	mov    $0xc,%ah
    166d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1671:	d9 6d ec             	fldcw  -0x14(%ebp)
    1674:	df 5d ea             	fistp  -0x16(%ebp)
    1677:	d9 6d ee             	fldcw  -0x12(%ebp)
    167a:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    167e:	89 c2                	mov    %eax,%edx
    1680:	8b 45 08             	mov    0x8(%ebp),%eax
    1683:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1686:	8b 45 08             	mov    0x8(%ebp),%eax
    1689:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    168d:	0f b6 c0             	movzbl %al,%eax
    1690:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1693:	db 45 e4             	fildl  -0x1c(%ebp)
    1696:	d9 e8                	fld1   
    1698:	d8 65 fc             	fsubs  -0x4(%ebp)
    169b:	de c9                	fmulp  %st,%st(1)
    169d:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    16a1:	0f b6 c0             	movzbl %al,%eax
    16a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16a7:	db 45 e4             	fildl  -0x1c(%ebp)
    16aa:	d8 4d fc             	fmuls  -0x4(%ebp)
    16ad:	de c1                	faddp  %st,%st(1)
    16af:	d9 6d ec             	fldcw  -0x14(%ebp)
    16b2:	df 5d ea             	fistp  -0x16(%ebp)
    16b5:	d9 6d ee             	fldcw  -0x12(%ebp)
    16b8:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    16bc:	89 c2                	mov    %eax,%edx
    16be:	8b 45 08             	mov    0x8(%ebp),%eax
    16c1:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    16c4:	8b 45 08             	mov    0x8(%ebp),%eax
    16c7:	0f b6 00             	movzbl (%eax),%eax
    16ca:	0f b6 c0             	movzbl %al,%eax
    16cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16d0:	db 45 e4             	fildl  -0x1c(%ebp)
    16d3:	d9 e8                	fld1   
    16d5:	d8 65 fc             	fsubs  -0x4(%ebp)
    16d8:	de c9                	fmulp  %st,%st(1)
    16da:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    16de:	0f b6 c0             	movzbl %al,%eax
    16e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16e4:	db 45 e4             	fildl  -0x1c(%ebp)
    16e7:	d8 4d fc             	fmuls  -0x4(%ebp)
    16ea:	de c1                	faddp  %st,%st(1)
    16ec:	d9 6d ec             	fldcw  -0x14(%ebp)
    16ef:	df 5d ea             	fistp  -0x16(%ebp)
    16f2:	d9 6d ee             	fldcw  -0x12(%ebp)
    16f5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    16f9:	89 c2                	mov    %eax,%edx
    16fb:	8b 45 08             	mov    0x8(%ebp),%eax
    16fe:	88 10                	mov    %dl,(%eax)
    1700:	eb 01                	jmp    1703 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    1702:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    1703:	c9                   	leave  
    1704:	c3                   	ret    

00001705 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    1705:	55                   	push   %ebp
    1706:	89 e5                	mov    %esp,%ebp
    1708:	83 ec 14             	sub    $0x14,%esp
    170b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    170e:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    1711:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1715:	83 e8 20             	sub    $0x20,%eax
    1718:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    171b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    171f:	0f 88 d7 00 00 00    	js     17fc <drawCharacter+0xf7>
    1725:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1729:	0f 8f cd 00 00 00    	jg     17fc <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    172f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1736:	e9 b5 00 00 00       	jmp    17f0 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    173b:	8b 55 10             	mov    0x10(%ebp),%edx
    173e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1741:	01 c2                	add    %eax,%edx
    1743:	8b 45 14             	mov    0x14(%ebp),%eax
    1746:	39 c2                	cmp    %eax,%edx
    1748:	0f 8f af 00 00 00    	jg     17fd <drawCharacter+0xf8>
    174e:	8b 55 10             	mov    0x10(%ebp),%edx
    1751:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1754:	01 d0                	add    %edx,%eax
    1756:	85 c0                	test   %eax,%eax
    1758:	0f 88 9f 00 00 00    	js     17fd <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    175e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1765:	eb 7b                	jmp    17e2 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1767:	8b 55 fc             	mov    -0x4(%ebp),%edx
    176a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    176d:	89 d0                	mov    %edx,%eax
    176f:	c1 e0 03             	shl    $0x3,%eax
    1772:	01 d0                	add    %edx,%eax
    1774:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    177a:	01 c2                	add    %eax,%edx
    177c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    177f:	01 d0                	add    %edx,%eax
    1781:	05 60 60 01 00       	add    $0x16060,%eax
    1786:	0f b6 00             	movzbl (%eax),%eax
    1789:	3c 01                	cmp    $0x1,%al
    178b:	75 51                	jne    17de <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    178d:	8b 55 0c             	mov    0xc(%ebp),%edx
    1790:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1793:	01 c2                	add    %eax,%edx
    1795:	8b 45 18             	mov    0x18(%ebp),%eax
    1798:	39 c2                	cmp    %eax,%edx
    179a:	7f 50                	jg     17ec <drawCharacter+0xe7>
    179c:	8b 55 0c             	mov    0xc(%ebp),%edx
    179f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17a2:	01 d0                	add    %edx,%eax
    17a4:	85 c0                	test   %eax,%eax
    17a6:	78 44                	js     17ec <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    17a8:	8b 55 10             	mov    0x10(%ebp),%edx
    17ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17ae:	01 c2                	add    %eax,%edx
    17b0:	8b 45 18             	mov    0x18(%ebp),%eax
    17b3:	0f af c2             	imul   %edx,%eax
    17b6:	89 c2                	mov    %eax,%edx
    17b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    17bb:	01 c2                	add    %eax,%edx
    17bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17c0:	01 c2                	add    %eax,%edx
    17c2:	89 d0                	mov    %edx,%eax
    17c4:	01 c0                	add    %eax,%eax
    17c6:	01 c2                	add    %eax,%edx
    17c8:	8b 45 08             	mov    0x8(%ebp),%eax
    17cb:	01 d0                	add    %edx,%eax
    17cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    17d0:	ff 75 20             	pushl  0x20(%ebp)
    17d3:	ff 75 f0             	pushl  -0x10(%ebp)
    17d6:	e8 0b fe ff ff       	call   15e6 <drawPointAlpha>
    17db:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    17de:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    17e2:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    17e6:	0f 8e 7b ff ff ff    	jle    1767 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    17ec:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    17f0:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    17f4:	0f 8e 41 ff ff ff    	jle    173b <drawCharacter+0x36>
    17fa:	eb 01                	jmp    17fd <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    17fc:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    17fd:	c9                   	leave  
    17fe:	c3                   	ret    

000017ff <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    17ff:	55                   	push   %ebp
    1800:	89 e5                	mov    %esp,%ebp
    1802:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1805:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    180c:	eb 3d                	jmp    184b <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    180e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1811:	0f b6 00             	movzbl (%eax),%eax
    1814:	0f be c0             	movsbl %al,%eax
    1817:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    181a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    181d:	01 ca                	add    %ecx,%edx
    181f:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1822:	8b 55 10             	mov    0x10(%ebp),%edx
    1825:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1828:	ff 75 20             	pushl  0x20(%ebp)
    182b:	50                   	push   %eax
    182c:	ff 75 18             	pushl  0x18(%ebp)
    182f:	ff 75 14             	pushl  0x14(%ebp)
    1832:	ff 75 f8             	pushl  -0x8(%ebp)
    1835:	ff 75 f4             	pushl  -0xc(%ebp)
    1838:	ff 75 08             	pushl  0x8(%ebp)
    183b:	e8 c5 fe ff ff       	call   1705 <drawCharacter>
    1840:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1843:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1847:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    184b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    184e:	0f b6 00             	movzbl (%eax),%eax
    1851:	84 c0                	test   %al,%al
    1853:	75 b9                	jne    180e <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1855:	90                   	nop
    1856:	c9                   	leave  
    1857:	c3                   	ret    

00001858 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1858:	55                   	push   %ebp
    1859:	89 e5                	mov    %esp,%ebp
    185b:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    185e:	8b 45 20             	mov    0x20(%ebp),%eax
    1861:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1864:	8b 45 24             	mov    0x24(%ebp),%eax
    1867:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    186a:	8b 55 14             	mov    0x14(%ebp),%edx
    186d:	8b 45 10             	mov    0x10(%ebp),%eax
    1870:	29 c2                	sub    %eax,%edx
    1872:	89 d0                	mov    %edx,%eax
    1874:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1877:	7d 0d                	jge    1886 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1879:	8b 55 14             	mov    0x14(%ebp),%edx
    187c:	8b 45 10             	mov    0x10(%ebp),%eax
    187f:	29 c2                	sub    %eax,%edx
    1881:	89 d0                	mov    %edx,%eax
    1883:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1886:	8b 55 18             	mov    0x18(%ebp),%edx
    1889:	8b 45 0c             	mov    0xc(%ebp),%eax
    188c:	29 c2                	sub    %eax,%edx
    188e:	89 d0                	mov    %edx,%eax
    1890:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1893:	7d 0d                	jge    18a2 <drawRect+0x4a>
        draw_w = s.w - p.x;
    1895:	8b 55 18             	mov    0x18(%ebp),%edx
    1898:	8b 45 0c             	mov    0xc(%ebp),%eax
    189b:	29 c2                	sub    %eax,%edx
    189d:	89 d0                	mov    %edx,%eax
    189f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    18a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    18a9:	eb 52                	jmp    18fd <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    18ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    18b2:	eb 3d                	jmp    18f1 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    18b4:	8b 55 10             	mov    0x10(%ebp),%edx
    18b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18ba:	01 c2                	add    %eax,%edx
    18bc:	8b 45 18             	mov    0x18(%ebp),%eax
    18bf:	0f af c2             	imul   %edx,%eax
    18c2:	89 c2                	mov    %eax,%edx
    18c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    18c7:	01 c2                	add    %eax,%edx
    18c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    18cc:	01 c2                	add    %eax,%edx
    18ce:	89 d0                	mov    %edx,%eax
    18d0:	01 c0                	add    %eax,%eax
    18d2:	01 c2                	add    %eax,%edx
    18d4:	8b 45 08             	mov    0x8(%ebp),%eax
    18d7:	01 d0                	add    %edx,%eax
    18d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    18dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    18df:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    18e3:	66 89 10             	mov    %dx,(%eax)
    18e6:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    18ea:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    18ed:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    18f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    18f4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    18f7:	7c bb                	jl     18b4 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    18f9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    18fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1900:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1903:	7c a6                	jl     18ab <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1905:	90                   	nop
    1906:	c9                   	leave  
    1907:	c3                   	ret    

00001908 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1908:	55                   	push   %ebp
    1909:	89 e5                	mov    %esp,%ebp
    190b:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    190e:	8b 45 28             	mov    0x28(%ebp),%eax
    1911:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1914:	8b 45 24             	mov    0x24(%ebp),%eax
    1917:	89 45 cc             	mov    %eax,-0x34(%ebp)
    191a:	ff 75 cc             	pushl  -0x34(%ebp)
    191d:	ff 75 c8             	pushl  -0x38(%ebp)
    1920:	83 ec 04             	sub    $0x4,%esp
    1923:	89 e0                	mov    %esp,%eax
    1925:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1929:	66 89 10             	mov    %dx,(%eax)
    192c:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1930:	88 50 02             	mov    %dl,0x2(%eax)
    1933:	ff 75 18             	pushl  0x18(%ebp)
    1936:	ff 75 14             	pushl  0x14(%ebp)
    1939:	ff 75 10             	pushl  0x10(%ebp)
    193c:	ff 75 0c             	pushl  0xc(%ebp)
    193f:	ff 75 08             	pushl  0x8(%ebp)
    1942:	e8 11 ff ff ff       	call   1858 <drawRect>
    1947:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    194a:	8b 45 28             	mov    0x28(%ebp),%eax
    194d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1950:	8b 45 24             	mov    0x24(%ebp),%eax
    1953:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1956:	8b 45 0c             	mov    0xc(%ebp),%eax
    1959:	89 45 d8             	mov    %eax,-0x28(%ebp)
    195c:	8b 55 10             	mov    0x10(%ebp),%edx
    195f:	8b 45 20             	mov    0x20(%ebp),%eax
    1962:	01 d0                	add    %edx,%eax
    1964:	2b 45 28             	sub    0x28(%ebp),%eax
    1967:	89 45 dc             	mov    %eax,-0x24(%ebp)
    196a:	ff 75 d4             	pushl  -0x2c(%ebp)
    196d:	ff 75 d0             	pushl  -0x30(%ebp)
    1970:	83 ec 04             	sub    $0x4,%esp
    1973:	89 e0                	mov    %esp,%eax
    1975:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1979:	66 89 10             	mov    %dx,(%eax)
    197c:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1980:	88 50 02             	mov    %dl,0x2(%eax)
    1983:	ff 75 18             	pushl  0x18(%ebp)
    1986:	ff 75 14             	pushl  0x14(%ebp)
    1989:	ff 75 dc             	pushl  -0x24(%ebp)
    198c:	ff 75 d8             	pushl  -0x28(%ebp)
    198f:	ff 75 08             	pushl  0x8(%ebp)
    1992:	e8 c1 fe ff ff       	call   1858 <drawRect>
    1997:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    199a:	8b 45 20             	mov    0x20(%ebp),%eax
    199d:	8b 55 28             	mov    0x28(%ebp),%edx
    19a0:	01 d2                	add    %edx,%edx
    19a2:	29 d0                	sub    %edx,%eax
    19a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    19a7:	8b 45 28             	mov    0x28(%ebp),%eax
    19aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    19b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    19b3:	8b 55 10             	mov    0x10(%ebp),%edx
    19b6:	8b 45 28             	mov    0x28(%ebp),%eax
    19b9:	01 d0                	add    %edx,%eax
    19bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    19be:	ff 75 e4             	pushl  -0x1c(%ebp)
    19c1:	ff 75 e0             	pushl  -0x20(%ebp)
    19c4:	83 ec 04             	sub    $0x4,%esp
    19c7:	89 e0                	mov    %esp,%eax
    19c9:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19cd:	66 89 10             	mov    %dx,(%eax)
    19d0:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19d4:	88 50 02             	mov    %dl,0x2(%eax)
    19d7:	ff 75 18             	pushl  0x18(%ebp)
    19da:	ff 75 14             	pushl  0x14(%ebp)
    19dd:	ff 75 ec             	pushl  -0x14(%ebp)
    19e0:	ff 75 e8             	pushl  -0x18(%ebp)
    19e3:	ff 75 08             	pushl  0x8(%ebp)
    19e6:	e8 6d fe ff ff       	call   1858 <drawRect>
    19eb:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    19ee:	8b 45 20             	mov    0x20(%ebp),%eax
    19f1:	8b 55 28             	mov    0x28(%ebp),%edx
    19f4:	01 d2                	add    %edx,%edx
    19f6:	29 d0                	sub    %edx,%eax
    19f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    19fb:	8b 45 28             	mov    0x28(%ebp),%eax
    19fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1a01:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a04:	8b 45 24             	mov    0x24(%ebp),%eax
    1a07:	01 d0                	add    %edx,%eax
    1a09:	2b 45 28             	sub    0x28(%ebp),%eax
    1a0c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1a0f:	8b 55 10             	mov    0x10(%ebp),%edx
    1a12:	8b 45 28             	mov    0x28(%ebp),%eax
    1a15:	01 d0                	add    %edx,%eax
    1a17:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1a1a:	ff 75 f4             	pushl  -0xc(%ebp)
    1a1d:	ff 75 f0             	pushl  -0x10(%ebp)
    1a20:	83 ec 04             	sub    $0x4,%esp
    1a23:	89 e0                	mov    %esp,%eax
    1a25:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a29:	66 89 10             	mov    %dx,(%eax)
    1a2c:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a30:	88 50 02             	mov    %dl,0x2(%eax)
    1a33:	ff 75 18             	pushl  0x18(%ebp)
    1a36:	ff 75 14             	pushl  0x14(%ebp)
    1a39:	ff 75 fc             	pushl  -0x4(%ebp)
    1a3c:	ff 75 f8             	pushl  -0x8(%ebp)
    1a3f:	ff 75 08             	pushl  0x8(%ebp)
    1a42:	e8 11 fe ff ff       	call   1858 <drawRect>
    1a47:	83 c4 20             	add    $0x20,%esp
}
    1a4a:	90                   	nop
    1a4b:	c9                   	leave  
    1a4c:	c3                   	ret    

00001a4d <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1a4d:	55                   	push   %ebp
    1a4e:	89 e5                	mov    %esp,%ebp
    1a50:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1a53:	8b 45 30             	mov    0x30(%ebp),%eax
    1a56:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1a59:	8b 45 34             	mov    0x34(%ebp),%eax
    1a5c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1a5f:	8b 55 20             	mov    0x20(%ebp),%edx
    1a62:	8b 45 14             	mov    0x14(%ebp),%eax
    1a65:	29 c2                	sub    %eax,%edx
    1a67:	89 d0                	mov    %edx,%eax
    1a69:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a6c:	7d 0d                	jge    1a7b <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1a6e:	8b 55 20             	mov    0x20(%ebp),%edx
    1a71:	8b 45 14             	mov    0x14(%ebp),%eax
    1a74:	29 c2                	sub    %eax,%edx
    1a76:	89 d0                	mov    %edx,%eax
    1a78:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1a7b:	8b 55 28             	mov    0x28(%ebp),%edx
    1a7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a81:	29 c2                	sub    %eax,%edx
    1a83:	89 d0                	mov    %edx,%eax
    1a85:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a88:	7d 0d                	jge    1a97 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1a8a:	8b 55 28             	mov    0x28(%ebp),%edx
    1a8d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a90:	29 c2                	sub    %eax,%edx
    1a92:	89 d0                	mov    %edx,%eax
    1a94:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1a97:	8b 55 24             	mov    0x24(%ebp),%edx
    1a9a:	8b 45 10             	mov    0x10(%ebp),%eax
    1a9d:	29 c2                	sub    %eax,%edx
    1a9f:	89 d0                	mov    %edx,%eax
    1aa1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1aa4:	7d 0d                	jge    1ab3 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1aa6:	8b 55 24             	mov    0x24(%ebp),%edx
    1aa9:	8b 45 10             	mov    0x10(%ebp),%eax
    1aac:	29 c2                	sub    %eax,%edx
    1aae:	89 d0                	mov    %edx,%eax
    1ab0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1ab3:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ab6:	8b 45 18             	mov    0x18(%ebp),%eax
    1ab9:	29 c2                	sub    %eax,%edx
    1abb:	89 d0                	mov    %edx,%eax
    1abd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1ac0:	7d 0d                	jge    1acf <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1ac2:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ac5:	8b 45 18             	mov    0x18(%ebp),%eax
    1ac8:	29 c2                	sub    %eax,%edx
    1aca:	89 d0                	mov    %edx,%eax
    1acc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1acf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1ad6:	e9 83 00 00 00       	jmp    1b5e <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1adb:	8b 55 14             	mov    0x14(%ebp),%edx
    1ade:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ae1:	01 d0                	add    %edx,%eax
    1ae3:	85 c0                	test   %eax,%eax
    1ae5:	78 72                	js     1b59 <drawBitmap+0x10c>
    1ae7:	8b 55 14             	mov    0x14(%ebp),%edx
    1aea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1aed:	01 c2                	add    %eax,%edx
    1aef:	8b 45 20             	mov    0x20(%ebp),%eax
    1af2:	39 c2                	cmp    %eax,%edx
    1af4:	7d 63                	jge    1b59 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1af6:	8b 55 14             	mov    0x14(%ebp),%edx
    1af9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1afc:	01 c2                	add    %eax,%edx
    1afe:	8b 45 24             	mov    0x24(%ebp),%eax
    1b01:	0f af c2             	imul   %edx,%eax
    1b04:	89 c2                	mov    %eax,%edx
    1b06:	8b 45 10             	mov    0x10(%ebp),%eax
    1b09:	01 c2                	add    %eax,%edx
    1b0b:	89 d0                	mov    %edx,%eax
    1b0d:	01 c0                	add    %eax,%eax
    1b0f:	01 c2                	add    %eax,%edx
    1b11:	8b 45 08             	mov    0x8(%ebp),%eax
    1b14:	01 d0                	add    %edx,%eax
    1b16:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1b19:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1b1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b1f:	01 c2                	add    %eax,%edx
    1b21:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1b24:	0f af c2             	imul   %edx,%eax
    1b27:	89 c2                	mov    %eax,%edx
    1b29:	8b 45 18             	mov    0x18(%ebp),%eax
    1b2c:	01 c2                	add    %eax,%edx
    1b2e:	89 d0                	mov    %edx,%eax
    1b30:	01 c0                	add    %eax,%eax
    1b32:	01 c2                	add    %eax,%edx
    1b34:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b37:	01 d0                	add    %edx,%eax
    1b39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1b3c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1b3f:	89 d0                	mov    %edx,%eax
    1b41:	01 c0                	add    %eax,%eax
    1b43:	01 d0                	add    %edx,%eax
    1b45:	83 ec 04             	sub    $0x4,%esp
    1b48:	50                   	push   %eax
    1b49:	ff 75 e4             	pushl  -0x1c(%ebp)
    1b4c:	ff 75 e8             	pushl  -0x18(%ebp)
    1b4f:	e8 23 e7 ff ff       	call   277 <memmove>
    1b54:	83 c4 10             	add    $0x10,%esp
    1b57:	eb 01                	jmp    1b5a <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1b59:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1b5a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1b5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b61:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b64:	0f 8c 71 ff ff ff    	jl     1adb <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1b6a:	90                   	nop
    1b6b:	c9                   	leave  
    1b6c:	c3                   	ret    

00001b6d <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1b6d:	55                   	push   %ebp
    1b6e:	89 e5                	mov    %esp,%ebp
    1b70:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1b73:	8b 45 30             	mov    0x30(%ebp),%eax
    1b76:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1b79:	8b 45 34             	mov    0x34(%ebp),%eax
    1b7c:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1b7f:	8b 55 20             	mov    0x20(%ebp),%edx
    1b82:	8b 45 14             	mov    0x14(%ebp),%eax
    1b85:	29 c2                	sub    %eax,%edx
    1b87:	89 d0                	mov    %edx,%eax
    1b89:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1b8c:	7d 0d                	jge    1b9b <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1b8e:	8b 55 20             	mov    0x20(%ebp),%edx
    1b91:	8b 45 14             	mov    0x14(%ebp),%eax
    1b94:	29 c2                	sub    %eax,%edx
    1b96:	89 d0                	mov    %edx,%eax
    1b98:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1b9b:	8b 55 28             	mov    0x28(%ebp),%edx
    1b9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1ba1:	29 c2                	sub    %eax,%edx
    1ba3:	89 d0                	mov    %edx,%eax
    1ba5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1ba8:	7d 0d                	jge    1bb7 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1baa:	8b 55 28             	mov    0x28(%ebp),%edx
    1bad:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bb0:	29 c2                	sub    %eax,%edx
    1bb2:	89 d0                	mov    %edx,%eax
    1bb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1bb7:	8b 55 24             	mov    0x24(%ebp),%edx
    1bba:	8b 45 10             	mov    0x10(%ebp),%eax
    1bbd:	29 c2                	sub    %eax,%edx
    1bbf:	89 d0                	mov    %edx,%eax
    1bc1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bc4:	7d 0d                	jge    1bd3 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1bc6:	8b 55 24             	mov    0x24(%ebp),%edx
    1bc9:	8b 45 10             	mov    0x10(%ebp),%eax
    1bcc:	29 c2                	sub    %eax,%edx
    1bce:	89 d0                	mov    %edx,%eax
    1bd0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1bd3:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1bd6:	8b 45 18             	mov    0x18(%ebp),%eax
    1bd9:	29 c2                	sub    %eax,%edx
    1bdb:	89 d0                	mov    %edx,%eax
    1bdd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1be0:	7d 0d                	jge    1bef <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1be2:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1be5:	8b 45 18             	mov    0x18(%ebp),%eax
    1be8:	29 c2                	sub    %eax,%edx
    1bea:	89 d0                	mov    %edx,%eax
    1bec:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1bef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1bf6:	e9 b8 00 00 00       	jmp    1cb3 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1bfb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1c02:	e9 9c 00 00 00       	jmp    1ca3 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1c07:	8b 55 14             	mov    0x14(%ebp),%edx
    1c0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c0d:	01 c2                	add    %eax,%edx
    1c0f:	8b 45 24             	mov    0x24(%ebp),%eax
    1c12:	0f af c2             	imul   %edx,%eax
    1c15:	89 c2                	mov    %eax,%edx
    1c17:	8b 45 10             	mov    0x10(%ebp),%eax
    1c1a:	01 c2                	add    %eax,%edx
    1c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c1f:	01 c2                	add    %eax,%edx
    1c21:	89 d0                	mov    %edx,%eax
    1c23:	01 c0                	add    %eax,%eax
    1c25:	01 c2                	add    %eax,%edx
    1c27:	8b 45 08             	mov    0x8(%ebp),%eax
    1c2a:	01 d0                	add    %edx,%eax
    1c2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1c2f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1c32:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c35:	01 c2                	add    %eax,%edx
    1c37:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1c3a:	0f af c2             	imul   %edx,%eax
    1c3d:	89 c2                	mov    %eax,%edx
    1c3f:	8b 45 18             	mov    0x18(%ebp),%eax
    1c42:	01 c2                	add    %eax,%edx
    1c44:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c47:	01 c2                	add    %eax,%edx
    1c49:	89 d0                	mov    %edx,%eax
    1c4b:	01 c0                	add    %eax,%eax
    1c4d:	01 c2                	add    %eax,%edx
    1c4f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c52:	01 d0                	add    %edx,%eax
    1c54:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1c57:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c5a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1c5e:	3c ff                	cmp    $0xff,%al
    1c60:	75 15                	jne    1c77 <drawTransparentBitmap+0x10a>
    1c62:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c65:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1c69:	3c ff                	cmp    $0xff,%al
    1c6b:	75 0a                	jne    1c77 <drawTransparentBitmap+0x10a>
    1c6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c70:	0f b6 00             	movzbl (%eax),%eax
    1c73:	3c ff                	cmp    $0xff,%al
    1c75:	74 27                	je     1c9e <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1c77:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c7a:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1c7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c81:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1c84:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c87:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c8e:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1c91:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c94:	0f b6 10             	movzbl (%eax),%edx
    1c97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c9a:	88 10                	mov    %dl,(%eax)
    1c9c:	eb 01                	jmp    1c9f <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1c9e:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1c9f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1ca3:	8b 45 34             	mov    0x34(%ebp),%eax
    1ca6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1ca9:	0f 8f 58 ff ff ff    	jg     1c07 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1caf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1cb3:	8b 45 30             	mov    0x30(%ebp),%eax
    1cb6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1cb9:	0f 8f 3c ff ff ff    	jg     1bfb <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1cbf:	90                   	nop
    1cc0:	c9                   	leave  
    1cc1:	c3                   	ret    

00001cc2 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1cc2:	55                   	push   %ebp
    1cc3:	89 e5                	mov    %esp,%ebp
    1cc5:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1cc8:	ff 75 24             	pushl  0x24(%ebp)
    1ccb:	ff 75 20             	pushl  0x20(%ebp)
    1cce:	ff 75 1c             	pushl  0x1c(%ebp)
    1cd1:	ff 75 18             	pushl  0x18(%ebp)
    1cd4:	ff 75 1c             	pushl  0x1c(%ebp)
    1cd7:	ff 75 18             	pushl  0x18(%ebp)
    1cda:	ff 75 14             	pushl  0x14(%ebp)
    1cdd:	ff 75 10             	pushl  0x10(%ebp)
    1ce0:	ff 75 14             	pushl  0x14(%ebp)
    1ce3:	ff 75 10             	pushl  0x10(%ebp)
    1ce6:	ff 75 0c             	pushl  0xc(%ebp)
    1ce9:	ff 75 08             	pushl  0x8(%ebp)
    1cec:	e8 5c fd ff ff       	call   1a4d <drawBitmap>
    1cf1:	83 c4 30             	add    $0x30,%esp
}
    1cf4:	90                   	nop
    1cf5:	c9                   	leave  
    1cf6:	c3                   	ret    

00001cf7 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1cf7:	55                   	push   %ebp
    1cf8:	89 e5                	mov    %esp,%ebp
    1cfa:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1cfd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d00:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1d03:	8b 45 20             	mov    0x20(%ebp),%eax
    1d06:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1d09:	8b 55 14             	mov    0x14(%ebp),%edx
    1d0c:	8b 45 10             	mov    0x10(%ebp),%eax
    1d0f:	29 c2                	sub    %eax,%edx
    1d11:	89 d0                	mov    %edx,%eax
    1d13:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d16:	7d 0d                	jge    1d25 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1d18:	8b 55 14             	mov    0x14(%ebp),%edx
    1d1b:	8b 45 10             	mov    0x10(%ebp),%eax
    1d1e:	29 c2                	sub    %eax,%edx
    1d20:	89 d0                	mov    %edx,%eax
    1d22:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1d25:	8b 55 18             	mov    0x18(%ebp),%edx
    1d28:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d2b:	29 c2                	sub    %eax,%edx
    1d2d:	89 d0                	mov    %edx,%eax
    1d2f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d32:	7d 0d                	jge    1d41 <colorShift+0x4a>
        draw_w = s.w - p.x;
    1d34:	8b 55 18             	mov    0x18(%ebp),%edx
    1d37:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d3a:	29 c2                	sub    %eax,%edx
    1d3c:	89 d0                	mov    %edx,%eax
    1d3e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1d41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1d48:	e9 fc 00 00 00       	jmp    1e49 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1d4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1d54:	e9 e0 00 00 00       	jmp    1e39 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1d59:	8b 55 10             	mov    0x10(%ebp),%edx
    1d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d5f:	01 c2                	add    %eax,%edx
    1d61:	8b 45 18             	mov    0x18(%ebp),%eax
    1d64:	0f af c2             	imul   %edx,%eax
    1d67:	89 c2                	mov    %eax,%edx
    1d69:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d6c:	01 c2                	add    %eax,%edx
    1d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d71:	01 c2                	add    %eax,%edx
    1d73:	89 d0                	mov    %edx,%eax
    1d75:	01 c0                	add    %eax,%eax
    1d77:	01 c2                	add    %eax,%edx
    1d79:	8b 45 08             	mov    0x8(%ebp),%eax
    1d7c:	01 d0                	add    %edx,%eax
    1d7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1d81:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d84:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d88:	3c c8                	cmp    $0xc8,%al
    1d8a:	0f 86 a5 00 00 00    	jbe    1e35 <colorShift+0x13e>
    1d90:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d93:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1d97:	3c c8                	cmp    $0xc8,%al
    1d99:	0f 86 96 00 00 00    	jbe    1e35 <colorShift+0x13e>
    1d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1da2:	0f b6 00             	movzbl (%eax),%eax
    1da5:	3c c8                	cmp    $0xc8,%al
    1da7:	0f 86 88 00 00 00    	jbe    1e35 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1dad:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1db0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1db4:	0f b6 d0             	movzbl %al,%edx
    1db7:	8b 45 24             	mov    0x24(%ebp),%eax
    1dba:	01 d0                	add    %edx,%eax
    1dbc:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1dc2:	89 d0                	mov    %edx,%eax
    1dc4:	c1 f8 1f             	sar    $0x1f,%eax
    1dc7:	c1 e8 18             	shr    $0x18,%eax
    1dca:	01 c2                	add    %eax,%edx
    1dcc:	0f b6 d2             	movzbl %dl,%edx
    1dcf:	29 c2                	sub    %eax,%edx
    1dd1:	89 d0                	mov    %edx,%eax
    1dd3:	89 c2                	mov    %eax,%edx
    1dd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dd8:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1ddb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dde:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1de2:	0f b6 d0             	movzbl %al,%edx
    1de5:	8b 45 24             	mov    0x24(%ebp),%eax
    1de8:	01 d0                	add    %edx,%eax
    1dea:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1df0:	89 d0                	mov    %edx,%eax
    1df2:	c1 f8 1f             	sar    $0x1f,%eax
    1df5:	c1 e8 18             	shr    $0x18,%eax
    1df8:	01 c2                	add    %eax,%edx
    1dfa:	0f b6 d2             	movzbl %dl,%edx
    1dfd:	29 c2                	sub    %eax,%edx
    1dff:	89 d0                	mov    %edx,%eax
    1e01:	89 c2                	mov    %eax,%edx
    1e03:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e06:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1e09:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e0c:	0f b6 00             	movzbl (%eax),%eax
    1e0f:	0f b6 d0             	movzbl %al,%edx
    1e12:	8b 45 24             	mov    0x24(%ebp),%eax
    1e15:	01 d0                	add    %edx,%eax
    1e17:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e1d:	89 d0                	mov    %edx,%eax
    1e1f:	c1 f8 1f             	sar    $0x1f,%eax
    1e22:	c1 e8 18             	shr    $0x18,%eax
    1e25:	01 c2                	add    %eax,%edx
    1e27:	0f b6 d2             	movzbl %dl,%edx
    1e2a:	29 c2                	sub    %eax,%edx
    1e2c:	89 d0                	mov    %edx,%eax
    1e2e:	89 c2                	mov    %eax,%edx
    1e30:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e33:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1e35:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1e39:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e3c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e3f:	0f 8c 14 ff ff ff    	jl     1d59 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e45:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e4c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e4f:	0f 8c f8 fe ff ff    	jl     1d4d <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1e55:	90                   	nop
    1e56:	c9                   	leave  
    1e57:	c3                   	ret    

00001e58 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1e58:	55                   	push   %ebp
    1e59:	89 e5                	mov    %esp,%ebp
    1e5b:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1e5e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1e65:	e9 fb 00 00 00       	jmp    1f65 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1e6a:	8b 55 14             	mov    0x14(%ebp),%edx
    1e6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e70:	01 c2                	add    %eax,%edx
    1e72:	0f b7 05 16 e5 01 00 	movzwl 0x1e516,%eax
    1e79:	0f b7 c0             	movzwl %ax,%eax
    1e7c:	39 c2                	cmp    %eax,%edx
    1e7e:	0f 8f eb 00 00 00    	jg     1f6f <drawMouse+0x117>
    1e84:	8b 55 14             	mov    0x14(%ebp),%edx
    1e87:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e8a:	01 d0                	add    %edx,%eax
    1e8c:	85 c0                	test   %eax,%eax
    1e8e:	0f 88 db 00 00 00    	js     1f6f <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1e94:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1e9b:	e9 b7 00 00 00       	jmp    1f57 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1ea0:	8b 55 10             	mov    0x10(%ebp),%edx
    1ea3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ea6:	01 c2                	add    %eax,%edx
    1ea8:	0f b7 05 14 e5 01 00 	movzwl 0x1e514,%eax
    1eaf:	0f b7 c0             	movzwl %ax,%eax
    1eb2:	39 c2                	cmp    %eax,%edx
    1eb4:	0f 8f a7 00 00 00    	jg     1f61 <drawMouse+0x109>
    1eba:	8b 55 10             	mov    0x10(%ebp),%edx
    1ebd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ec0:	01 d0                	add    %edx,%eax
    1ec2:	85 c0                	test   %eax,%eax
    1ec4:	0f 88 97 00 00 00    	js     1f61 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1eca:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1ecd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1ed0:	89 d0                	mov    %edx,%eax
    1ed2:	c1 e0 04             	shl    $0x4,%eax
    1ed5:	29 d0                	sub    %edx,%eax
    1ed7:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1edd:	01 c2                	add    %eax,%edx
    1edf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ee2:	01 d0                	add    %edx,%eax
    1ee4:	05 40 5e 01 00       	add    $0x15e40,%eax
    1ee9:	0f b6 00             	movzbl (%eax),%eax
    1eec:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1eef:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1ef3:	74 5e                	je     1f53 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1ef5:	8b 55 14             	mov    0x14(%ebp),%edx
    1ef8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1efb:	01 c2                	add    %eax,%edx
    1efd:	0f b7 05 14 e5 01 00 	movzwl 0x1e514,%eax
    1f04:	0f b7 c0             	movzwl %ax,%eax
    1f07:	0f af c2             	imul   %edx,%eax
    1f0a:	89 c2                	mov    %eax,%edx
    1f0c:	8b 45 10             	mov    0x10(%ebp),%eax
    1f0f:	01 c2                	add    %eax,%edx
    1f11:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f14:	01 c2                	add    %eax,%edx
    1f16:	89 d0                	mov    %edx,%eax
    1f18:	01 c0                	add    %eax,%eax
    1f1a:	01 c2                	add    %eax,%edx
    1f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    1f1f:	01 d0                	add    %edx,%eax
    1f21:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    1f24:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    1f28:	8d 50 ff             	lea    -0x1(%eax),%edx
    1f2b:	89 d0                	mov    %edx,%eax
    1f2d:	01 c0                	add    %eax,%eax
    1f2f:	01 d0                	add    %edx,%eax
    1f31:	05 1c e5 01 00       	add    $0x1e51c,%eax
    1f36:	83 ec 04             	sub    $0x4,%esp
    1f39:	89 e2                	mov    %esp,%edx
    1f3b:	0f b7 08             	movzwl (%eax),%ecx
    1f3e:	66 89 0a             	mov    %cx,(%edx)
    1f41:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f45:	88 42 02             	mov    %al,0x2(%edx)
    1f48:	ff 75 f0             	pushl  -0x10(%ebp)
    1f4b:	e8 73 f6 ff ff       	call   15c3 <drawPoint>
    1f50:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f53:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1f57:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    1f5b:	0f 8e 3f ff ff ff    	jle    1ea0 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1f61:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1f65:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1f69:	0f 8e fb fe ff ff    	jle    1e6a <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    1f6f:	90                   	nop
    1f70:	c9                   	leave  
    1f71:	c3                   	ret    

00001f72 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    1f72:	55                   	push   %ebp
    1f73:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    1f75:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1f79:	78 1b                	js     1f96 <getColor+0x24>
    1f7b:	8b 45 08             	mov    0x8(%ebp),%eax
    1f7e:	8b 40 04             	mov    0x4(%eax),%eax
    1f81:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1f84:	7c 10                	jl     1f96 <getColor+0x24>
    1f86:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    1f8a:	78 0a                	js     1f96 <getColor+0x24>
    1f8c:	8b 45 08             	mov    0x8(%ebp),%eax
    1f8f:	8b 00                	mov    (%eax),%eax
    1f91:	3b 45 10             	cmp    0x10(%ebp),%eax
    1f94:	7d 10                	jge    1fa6 <getColor+0x34>
    {
        *isInPic = 1;
    1f96:	8b 45 14             	mov    0x14(%ebp),%eax
    1f99:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    1f9f:	b8 d1 e0 01 00       	mov    $0x1e0d1,%eax
    1fa4:	eb 44                	jmp    1fea <getColor+0x78>
    }

    if (y == pic->height)
    1fa6:	8b 45 08             	mov    0x8(%ebp),%eax
    1fa9:	8b 40 04             	mov    0x4(%eax),%eax
    1fac:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1faf:	75 04                	jne    1fb5 <getColor+0x43>
        y--;
    1fb1:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    1fb5:	8b 45 08             	mov    0x8(%ebp),%eax
    1fb8:	8b 00                	mov    (%eax),%eax
    1fba:	3b 45 10             	cmp    0x10(%ebp),%eax
    1fbd:	75 04                	jne    1fc3 <getColor+0x51>
        x--;
    1fbf:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    1fc3:	8b 45 14             	mov    0x14(%ebp),%eax
    1fc6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    1fcc:	8b 45 08             	mov    0x8(%ebp),%eax
    1fcf:	8b 48 08             	mov    0x8(%eax),%ecx
    1fd2:	8b 45 08             	mov    0x8(%ebp),%eax
    1fd5:	8b 00                	mov    (%eax),%eax
    1fd7:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1fdb:	89 c2                	mov    %eax,%edx
    1fdd:	8b 45 10             	mov    0x10(%ebp),%eax
    1fe0:	01 c2                	add    %eax,%edx
    1fe2:	89 d0                	mov    %edx,%eax
    1fe4:	01 c0                	add    %eax,%eax
    1fe6:	01 d0                	add    %edx,%eax
    1fe8:	01 c8                	add    %ecx,%eax
}
    1fea:	5d                   	pop    %ebp
    1feb:	c3                   	ret    

00001fec <setColor>:

int setColor(RGB *src, RGB *dst)
{
    1fec:	55                   	push   %ebp
    1fed:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    1fef:	8b 45 08             	mov    0x8(%ebp),%eax
    1ff2:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1ff6:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ff9:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    1ffc:	8b 45 08             	mov    0x8(%ebp),%eax
    1fff:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2003:	8b 45 0c             	mov    0xc(%ebp),%eax
    2006:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2009:	8b 45 08             	mov    0x8(%ebp),%eax
    200c:	0f b6 10             	movzbl (%eax),%edx
    200f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2012:	88 10                	mov    %dl,(%eax)

    return 1;
    2014:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2019:	5d                   	pop    %ebp
    201a:	c3                   	ret    

0000201b <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    201b:	55                   	push   %ebp
    201c:	89 e5                	mov    %esp,%ebp
    201e:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    2021:	d9 45 10             	flds   0x10(%ebp)
    2024:	d9 7d be             	fnstcw -0x42(%ebp)
    2027:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    202b:	b4 0c                	mov    $0xc,%ah
    202d:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2031:	d9 6d bc             	fldcw  -0x44(%ebp)
    2034:	db 5d fc             	fistpl -0x4(%ebp)
    2037:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    203a:	d9 45 0c             	flds   0xc(%ebp)
    203d:	d9 6d bc             	fldcw  -0x44(%ebp)
    2040:	db 5d f8             	fistpl -0x8(%ebp)
    2043:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2046:	db 45 fc             	fildl  -0x4(%ebp)
    2049:	d9 45 10             	flds   0x10(%ebp)
    204c:	d9 c9                	fxch   %st(1)
    204e:	df e9                	fucomip %st(1),%st
    2050:	dd d8                	fstp   %st(0)
    2052:	76 04                	jbe    2058 <mixColor+0x3d>
        x--;
    2054:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2058:	db 45 f8             	fildl  -0x8(%ebp)
    205b:	d9 45 0c             	flds   0xc(%ebp)
    205e:	d9 c9                	fxch   %st(1)
    2060:	df e9                	fucomip %st(1),%st
    2062:	dd d8                	fstp   %st(0)
    2064:	76 04                	jbe    206a <mixColor+0x4f>
        y--;
    2066:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    206a:	8d 45 c0             	lea    -0x40(%ebp),%eax
    206d:	50                   	push   %eax
    206e:	ff 75 fc             	pushl  -0x4(%ebp)
    2071:	ff 75 f8             	pushl  -0x8(%ebp)
    2074:	ff 75 08             	pushl  0x8(%ebp)
    2077:	e8 f6 fe ff ff       	call   1f72 <getColor>
    207c:	83 c4 10             	add    $0x10,%esp
    207f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2082:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2085:	83 c0 01             	add    $0x1,%eax
    2088:	8d 55 c0             	lea    -0x40(%ebp),%edx
    208b:	83 c2 04             	add    $0x4,%edx
    208e:	52                   	push   %edx
    208f:	ff 75 fc             	pushl  -0x4(%ebp)
    2092:	50                   	push   %eax
    2093:	ff 75 08             	pushl  0x8(%ebp)
    2096:	e8 d7 fe ff ff       	call   1f72 <getColor>
    209b:	83 c4 10             	add    $0x10,%esp
    209e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    20a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20a4:	83 c0 01             	add    $0x1,%eax
    20a7:	8d 55 c0             	lea    -0x40(%ebp),%edx
    20aa:	83 c2 08             	add    $0x8,%edx
    20ad:	52                   	push   %edx
    20ae:	50                   	push   %eax
    20af:	ff 75 f8             	pushl  -0x8(%ebp)
    20b2:	ff 75 08             	pushl  0x8(%ebp)
    20b5:	e8 b8 fe ff ff       	call   1f72 <getColor>
    20ba:	83 c4 10             	add    $0x10,%esp
    20bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    20c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20c3:	8d 50 01             	lea    0x1(%eax),%edx
    20c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    20c9:	83 c0 01             	add    $0x1,%eax
    20cc:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    20cf:	83 c1 0c             	add    $0xc,%ecx
    20d2:	51                   	push   %ecx
    20d3:	52                   	push   %edx
    20d4:	50                   	push   %eax
    20d5:	ff 75 08             	pushl  0x8(%ebp)
    20d8:	e8 95 fe ff ff       	call   1f72 <getColor>
    20dd:	83 c4 10             	add    $0x10,%esp
    20e0:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    20e3:	db 45 fc             	fildl  -0x4(%ebp)
    20e6:	d9 45 10             	flds   0x10(%ebp)
    20e9:	de e1                	fsubp  %st,%st(1)
    20eb:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    20ee:	db 45 f8             	fildl  -0x8(%ebp)
    20f1:	d9 45 0c             	flds   0xc(%ebp)
    20f4:	de e1                	fsubp  %st,%st(1)
    20f6:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    20f9:	d9 45 e4             	flds   -0x1c(%ebp)
    20fc:	d8 4d e0             	fmuls  -0x20(%ebp)
    20ff:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    2102:	d9 e8                	fld1   
    2104:	d8 65 e0             	fsubs  -0x20(%ebp)
    2107:	d8 4d e4             	fmuls  -0x1c(%ebp)
    210a:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    210d:	d9 e8                	fld1   
    210f:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2112:	d8 4d e0             	fmuls  -0x20(%ebp)
    2115:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    2118:	d9 e8                	fld1   
    211a:	d8 65 e4             	fsubs  -0x1c(%ebp)
    211d:	d9 e8                	fld1   
    211f:	d8 65 e0             	fsubs  -0x20(%ebp)
    2122:	de c9                	fmulp  %st,%st(1)
    2124:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    2127:	8b 45 f4             	mov    -0xc(%ebp),%eax
    212a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    212e:	0f b6 c0             	movzbl %al,%eax
    2131:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2134:	db 45 b4             	fildl  -0x4c(%ebp)
    2137:	d8 4d d0             	fmuls  -0x30(%ebp)
    213a:	8b 45 c0             	mov    -0x40(%ebp),%eax
    213d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2140:	db 45 b4             	fildl  -0x4c(%ebp)
    2143:	de c9                	fmulp  %st,%st(1)
    2145:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2148:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    214c:	0f b6 c0             	movzbl %al,%eax
    214f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2152:	db 45 b4             	fildl  -0x4c(%ebp)
    2155:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2158:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    215b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    215e:	db 45 b4             	fildl  -0x4c(%ebp)
    2161:	de c9                	fmulp  %st,%st(1)
    2163:	de c1                	faddp  %st,%st(1)
    2165:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2168:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    216c:	0f b6 c0             	movzbl %al,%eax
    216f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2172:	db 45 b4             	fildl  -0x4c(%ebp)
    2175:	d8 4d d8             	fmuls  -0x28(%ebp)
    2178:	8b 45 c8             	mov    -0x38(%ebp),%eax
    217b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    217e:	db 45 b4             	fildl  -0x4c(%ebp)
    2181:	de c9                	fmulp  %st,%st(1)
    2183:	de c1                	faddp  %st,%st(1)
    2185:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2188:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    218c:	0f b6 c0             	movzbl %al,%eax
    218f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2192:	db 45 b4             	fildl  -0x4c(%ebp)
    2195:	d8 4d dc             	fmuls  -0x24(%ebp)
    2198:	8b 45 cc             	mov    -0x34(%ebp),%eax
    219b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    219e:	db 45 b4             	fildl  -0x4c(%ebp)
    21a1:	de c9                	fmulp  %st,%st(1)
    21a3:	de c1                	faddp  %st,%st(1)
    21a5:	d9 7d be             	fnstcw -0x42(%ebp)
    21a8:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    21ac:	b4 0c                	mov    $0xc,%ah
    21ae:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    21b2:	d9 6d bc             	fldcw  -0x44(%ebp)
    21b5:	db 5d b8             	fistpl -0x48(%ebp)
    21b8:	d9 6d be             	fldcw  -0x42(%ebp)
    21bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
    21be:	89 c2                	mov    %eax,%edx
    21c0:	8b 45 14             	mov    0x14(%ebp),%eax
    21c3:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    21c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21c9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21cd:	0f b6 c0             	movzbl %al,%eax
    21d0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21d3:	db 45 b4             	fildl  -0x4c(%ebp)
    21d6:	d8 4d d0             	fmuls  -0x30(%ebp)
    21d9:	8b 45 c0             	mov    -0x40(%ebp),%eax
    21dc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21df:	db 45 b4             	fildl  -0x4c(%ebp)
    21e2:	de c9                	fmulp  %st,%st(1)
    21e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21e7:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21eb:	0f b6 c0             	movzbl %al,%eax
    21ee:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21f1:	db 45 b4             	fildl  -0x4c(%ebp)
    21f4:	d8 4d d4             	fmuls  -0x2c(%ebp)
    21f7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    21fa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21fd:	db 45 b4             	fildl  -0x4c(%ebp)
    2200:	de c9                	fmulp  %st,%st(1)
    2202:	de c1                	faddp  %st,%st(1)
    2204:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2207:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    220b:	0f b6 c0             	movzbl %al,%eax
    220e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2211:	db 45 b4             	fildl  -0x4c(%ebp)
    2214:	d8 4d d8             	fmuls  -0x28(%ebp)
    2217:	8b 45 c8             	mov    -0x38(%ebp),%eax
    221a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    221d:	db 45 b4             	fildl  -0x4c(%ebp)
    2220:	de c9                	fmulp  %st,%st(1)
    2222:	de c1                	faddp  %st,%st(1)
    2224:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2227:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    222b:	0f b6 c0             	movzbl %al,%eax
    222e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2231:	db 45 b4             	fildl  -0x4c(%ebp)
    2234:	d8 4d dc             	fmuls  -0x24(%ebp)
    2237:	8b 45 cc             	mov    -0x34(%ebp),%eax
    223a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    223d:	db 45 b4             	fildl  -0x4c(%ebp)
    2240:	de c9                	fmulp  %st,%st(1)
    2242:	de c1                	faddp  %st,%st(1)
    2244:	d9 6d bc             	fldcw  -0x44(%ebp)
    2247:	db 5d b8             	fistpl -0x48(%ebp)
    224a:	d9 6d be             	fldcw  -0x42(%ebp)
    224d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2250:	89 c2                	mov    %eax,%edx
    2252:	8b 45 14             	mov    0x14(%ebp),%eax
    2255:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2258:	8b 45 f4             	mov    -0xc(%ebp),%eax
    225b:	0f b6 00             	movzbl (%eax),%eax
    225e:	0f b6 c0             	movzbl %al,%eax
    2261:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2264:	db 45 b4             	fildl  -0x4c(%ebp)
    2267:	d8 4d d0             	fmuls  -0x30(%ebp)
    226a:	8b 45 c0             	mov    -0x40(%ebp),%eax
    226d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2270:	db 45 b4             	fildl  -0x4c(%ebp)
    2273:	de c9                	fmulp  %st,%st(1)
    2275:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2278:	0f b6 00             	movzbl (%eax),%eax
    227b:	0f b6 c0             	movzbl %al,%eax
    227e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2281:	db 45 b4             	fildl  -0x4c(%ebp)
    2284:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2287:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    228a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    228d:	db 45 b4             	fildl  -0x4c(%ebp)
    2290:	de c9                	fmulp  %st,%st(1)
    2292:	de c1                	faddp  %st,%st(1)
    2294:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2297:	0f b6 00             	movzbl (%eax),%eax
    229a:	0f b6 c0             	movzbl %al,%eax
    229d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22a0:	db 45 b4             	fildl  -0x4c(%ebp)
    22a3:	d8 4d d8             	fmuls  -0x28(%ebp)
    22a6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    22a9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ac:	db 45 b4             	fildl  -0x4c(%ebp)
    22af:	de c9                	fmulp  %st,%st(1)
    22b1:	de c1                	faddp  %st,%st(1)
    22b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    22b6:	0f b6 00             	movzbl (%eax),%eax
    22b9:	0f b6 c0             	movzbl %al,%eax
    22bc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22bf:	db 45 b4             	fildl  -0x4c(%ebp)
    22c2:	d8 4d dc             	fmuls  -0x24(%ebp)
    22c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    22c8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22cb:	db 45 b4             	fildl  -0x4c(%ebp)
    22ce:	de c9                	fmulp  %st,%st(1)
    22d0:	de c1                	faddp  %st,%st(1)
    22d2:	d9 6d bc             	fldcw  -0x44(%ebp)
    22d5:	db 5d b8             	fistpl -0x48(%ebp)
    22d8:	d9 6d be             	fldcw  -0x42(%ebp)
    22db:	8b 45 b8             	mov    -0x48(%ebp),%eax
    22de:	89 c2                	mov    %eax,%edx
    22e0:	8b 45 14             	mov    0x14(%ebp),%eax
    22e3:	88 10                	mov    %dl,(%eax)

    return 1;
    22e5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    22ea:	c9                   	leave  
    22eb:	c3                   	ret    

000022ec <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    22ec:	55                   	push   %ebp
    22ed:	89 e5                	mov    %esp,%ebp
    22ef:	53                   	push   %ebx
    22f0:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    22f3:	8b 45 10             	mov    0x10(%ebp),%eax
    22f6:	c1 f8 10             	sar    $0x10,%eax
    22f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    22fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    22ff:	c1 f8 10             	sar    $0x10,%eax
    2302:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2305:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2308:	50                   	push   %eax
    2309:	ff 75 f8             	pushl  -0x8(%ebp)
    230c:	ff 75 f4             	pushl  -0xc(%ebp)
    230f:	ff 75 08             	pushl  0x8(%ebp)
    2312:	e8 5b fc ff ff       	call   1f72 <getColor>
    2317:	83 c4 10             	add    $0x10,%esp
    231a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    231d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2320:	83 c0 01             	add    $0x1,%eax
    2323:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2326:	83 c2 04             	add    $0x4,%edx
    2329:	52                   	push   %edx
    232a:	ff 75 f8             	pushl  -0x8(%ebp)
    232d:	50                   	push   %eax
    232e:	ff 75 08             	pushl  0x8(%ebp)
    2331:	e8 3c fc ff ff       	call   1f72 <getColor>
    2336:	83 c4 10             	add    $0x10,%esp
    2339:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    233c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    233f:	83 c0 01             	add    $0x1,%eax
    2342:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2345:	83 c2 08             	add    $0x8,%edx
    2348:	52                   	push   %edx
    2349:	50                   	push   %eax
    234a:	ff 75 f4             	pushl  -0xc(%ebp)
    234d:	ff 75 08             	pushl  0x8(%ebp)
    2350:	e8 1d fc ff ff       	call   1f72 <getColor>
    2355:	83 c4 10             	add    $0x10,%esp
    2358:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    235b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    235e:	8d 50 01             	lea    0x1(%eax),%edx
    2361:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2364:	83 c0 01             	add    $0x1,%eax
    2367:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    236a:	83 c1 0c             	add    $0xc,%ecx
    236d:	51                   	push   %ecx
    236e:	52                   	push   %edx
    236f:	50                   	push   %eax
    2370:	ff 75 08             	pushl  0x8(%ebp)
    2373:	e8 fa fb ff ff       	call   1f72 <getColor>
    2378:	83 c4 10             	add    $0x10,%esp
    237b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    237e:	8b 45 10             	mov    0x10(%ebp),%eax
    2381:	0f b7 c0             	movzwl %ax,%eax
    2384:	c1 f8 08             	sar    $0x8,%eax
    2387:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    238a:	8b 45 0c             	mov    0xc(%ebp),%eax
    238d:	0f b7 c0             	movzwl %ax,%eax
    2390:	c1 f8 08             	sar    $0x8,%eax
    2393:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2396:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2399:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    239d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    23a0:	b8 ff 00 00 00       	mov    $0xff,%eax
    23a5:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23a8:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    23ac:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    23af:	b8 ff 00 00 00       	mov    $0xff,%eax
    23b4:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23b7:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    23bb:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    23be:	b8 ff 00 00 00       	mov    $0xff,%eax
    23c3:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23c6:	89 c2                	mov    %eax,%edx
    23c8:	b8 ff 00 00 00       	mov    $0xff,%eax
    23cd:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23d0:	0f af c2             	imul   %edx,%eax
    23d3:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    23d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23d9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23dd:	0f b6 c0             	movzbl %al,%eax
    23e0:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    23e4:	8b 55 bc             	mov    -0x44(%ebp),%edx
    23e7:	0f af d0             	imul   %eax,%edx
    23ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23ed:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23f1:	0f b6 c0             	movzbl %al,%eax
    23f4:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    23f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    23fb:	0f af c1             	imul   %ecx,%eax
    23fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2404:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2408:	0f b6 c0             	movzbl %al,%eax
    240b:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    240f:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2412:	0f af d0             	imul   %eax,%edx
    2415:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2418:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    241c:	0f b6 c0             	movzbl %al,%eax
    241f:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2423:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2426:	0f af c1             	imul   %ecx,%eax
    2429:	01 d0                	add    %edx,%eax
    242b:	01 d8                	add    %ebx,%eax
    242d:	c1 e8 10             	shr    $0x10,%eax
    2430:	89 c2                	mov    %eax,%edx
    2432:	8b 45 14             	mov    0x14(%ebp),%eax
    2435:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2438:	8b 45 f0             	mov    -0x10(%ebp),%eax
    243b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    243f:	0f b6 c0             	movzbl %al,%eax
    2442:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2446:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2449:	0f af d0             	imul   %eax,%edx
    244c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    244f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2453:	0f b6 c0             	movzbl %al,%eax
    2456:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    245a:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    245d:	0f af c1             	imul   %ecx,%eax
    2460:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2463:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2466:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    246a:	0f b6 c0             	movzbl %al,%eax
    246d:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2471:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2474:	0f af d0             	imul   %eax,%edx
    2477:	8b 45 e8             	mov    -0x18(%ebp),%eax
    247a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    247e:	0f b6 c0             	movzbl %al,%eax
    2481:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2485:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2488:	0f af c1             	imul   %ecx,%eax
    248b:	01 d0                	add    %edx,%eax
    248d:	01 d8                	add    %ebx,%eax
    248f:	c1 e8 10             	shr    $0x10,%eax
    2492:	89 c2                	mov    %eax,%edx
    2494:	8b 45 14             	mov    0x14(%ebp),%eax
    2497:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    249a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    249d:	0f b6 00             	movzbl (%eax),%eax
    24a0:	0f b6 c0             	movzbl %al,%eax
    24a3:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    24a7:	8b 55 bc             	mov    -0x44(%ebp),%edx
    24aa:	0f af d0             	imul   %eax,%edx
    24ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24b0:	0f b6 00             	movzbl (%eax),%eax
    24b3:	0f b6 c0             	movzbl %al,%eax
    24b6:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    24ba:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    24bd:	0f af c1             	imul   %ecx,%eax
    24c0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    24c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    24c6:	0f b6 00             	movzbl (%eax),%eax
    24c9:	0f b6 c0             	movzbl %al,%eax
    24cc:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    24d0:	8b 55 c8             	mov    -0x38(%ebp),%edx
    24d3:	0f af d0             	imul   %eax,%edx
    24d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24d9:	0f b6 00             	movzbl (%eax),%eax
    24dc:	0f b6 c0             	movzbl %al,%eax
    24df:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    24e3:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    24e6:	0f af c1             	imul   %ecx,%eax
    24e9:	01 d0                	add    %edx,%eax
    24eb:	01 d8                	add    %ebx,%eax
    24ed:	c1 e8 10             	shr    $0x10,%eax
    24f0:	89 c2                	mov    %eax,%edx
    24f2:	8b 45 14             	mov    0x14(%ebp),%eax
    24f5:	88 10                	mov    %dl,(%eax)
}
    24f7:	90                   	nop
    24f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    24fb:	c9                   	leave  
    24fc:	c3                   	ret    

000024fd <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    24fd:	55                   	push   %ebp
    24fe:	89 e5                	mov    %esp,%ebp
    2500:	53                   	push   %ebx
    2501:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    2504:	8b 45 08             	mov    0x8(%ebp),%eax
    2507:	8b 00                	mov    (%eax),%eax
    2509:	c1 e0 10             	shl    $0x10,%eax
    250c:	89 c1                	mov    %eax,%ecx
    250e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2511:	8b 18                	mov    (%eax),%ebx
    2513:	89 c8                	mov    %ecx,%eax
    2515:	99                   	cltd   
    2516:	f7 fb                	idiv   %ebx
    2518:	83 c0 01             	add    $0x1,%eax
    251b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    251e:	8b 45 08             	mov    0x8(%ebp),%eax
    2521:	8b 40 04             	mov    0x4(%eax),%eax
    2524:	c1 e0 10             	shl    $0x10,%eax
    2527:	89 c1                	mov    %eax,%ecx
    2529:	8b 45 0c             	mov    0xc(%ebp),%eax
    252c:	8b 58 04             	mov    0x4(%eax),%ebx
    252f:	89 c8                	mov    %ecx,%eax
    2531:	99                   	cltd   
    2532:	f7 fb                	idiv   %ebx
    2534:	83 c0 01             	add    $0x1,%eax
    2537:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    253a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    253d:	d1 f8                	sar    %eax
    253f:	2d 00 80 00 00       	sub    $0x8000,%eax
    2544:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2547:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    254a:	d1 f8                	sar    %eax
    254c:	2d 00 80 00 00       	sub    $0x8000,%eax
    2551:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2554:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2557:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    255a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2561:	eb 5d                	jmp    25c0 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2563:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2566:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2569:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2570:	eb 3a                	jmp    25ac <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2572:	8b 45 0c             	mov    0xc(%ebp),%eax
    2575:	8b 48 08             	mov    0x8(%eax),%ecx
    2578:	8b 45 0c             	mov    0xc(%ebp),%eax
    257b:	8b 00                	mov    (%eax),%eax
    257d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2581:	89 c2                	mov    %eax,%edx
    2583:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2586:	01 c2                	add    %eax,%edx
    2588:	89 d0                	mov    %edx,%eax
    258a:	01 c0                	add    %eax,%eax
    258c:	01 d0                	add    %edx,%eax
    258e:	01 c8                	add    %ecx,%eax
    2590:	50                   	push   %eax
    2591:	ff 75 f0             	pushl  -0x10(%ebp)
    2594:	ff 75 f8             	pushl  -0x8(%ebp)
    2597:	ff 75 08             	pushl  0x8(%ebp)
    259a:	e8 4d fd ff ff       	call   22ec <mixColorInt>
    259f:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    25a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25a5:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    25a8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    25ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    25af:	8b 00                	mov    (%eax),%eax
    25b1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    25b4:	7f bc                	jg     2572 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    25b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25b9:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    25bc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    25c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    25c3:	8b 40 04             	mov    0x4(%eax),%eax
    25c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    25c9:	7f 98                	jg     2563 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    25cb:	b8 01 00 00 00       	mov    $0x1,%eax
}
    25d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    25d3:	c9                   	leave  
    25d4:	c3                   	ret    

000025d5 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    25d5:	55                   	push   %ebp
    25d6:	89 e5                	mov    %esp,%ebp
    25d8:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    25db:	8b 45 08             	mov    0x8(%ebp),%eax
    25de:	8b 00                	mov    (%eax),%eax
    25e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25e3:	db 45 e4             	fildl  -0x1c(%ebp)
    25e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    25e9:	8b 00                	mov    (%eax),%eax
    25eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25ee:	db 45 e4             	fildl  -0x1c(%ebp)
    25f1:	de f9                	fdivrp %st,%st(1)
    25f3:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    25f6:	8b 45 08             	mov    0x8(%ebp),%eax
    25f9:	8b 40 04             	mov    0x4(%eax),%eax
    25fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25ff:	db 45 e4             	fildl  -0x1c(%ebp)
    2602:	8b 45 0c             	mov    0xc(%ebp),%eax
    2605:	8b 40 04             	mov    0x4(%eax),%eax
    2608:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    260b:	db 45 e4             	fildl  -0x1c(%ebp)
    260e:	de f9                	fdivrp %st,%st(1)
    2610:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    2613:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    261a:	eb 5e                	jmp    267a <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    261c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2623:	eb 47                	jmp    266c <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2625:	db 45 f8             	fildl  -0x8(%ebp)
    2628:	d8 4d f4             	fmuls  -0xc(%ebp)
    262b:	d9 7d ee             	fnstcw -0x12(%ebp)
    262e:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2632:	b4 0c                	mov    $0xc,%ah
    2634:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2638:	d9 6d ec             	fldcw  -0x14(%ebp)
    263b:	db 5d e8             	fistpl -0x18(%ebp)
    263e:	d9 6d ee             	fldcw  -0x12(%ebp)
    2641:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2644:	db 45 fc             	fildl  -0x4(%ebp)
    2647:	d8 4d f0             	fmuls  -0x10(%ebp)
    264a:	d9 6d ec             	fldcw  -0x14(%ebp)
    264d:	db 5d e8             	fistpl -0x18(%ebp)
    2650:	d9 6d ee             	fldcw  -0x12(%ebp)
    2653:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2656:	6a 00                	push   $0x0
    2658:	52                   	push   %edx
    2659:	50                   	push   %eax
    265a:	ff 75 08             	pushl  0x8(%ebp)
    265d:	e8 10 f9 ff ff       	call   1f72 <getColor>
    2662:	83 c4 10             	add    $0x10,%esp
    2665:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2668:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    266c:	8b 45 0c             	mov    0xc(%ebp),%eax
    266f:	8b 00                	mov    (%eax),%eax
    2671:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2674:	7f af                	jg     2625 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2676:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    267a:	8b 45 0c             	mov    0xc(%ebp),%eax
    267d:	8b 40 04             	mov    0x4(%eax),%eax
    2680:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2683:	7f 97                	jg     261c <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2685:	b8 01 00 00 00       	mov    $0x1,%eax
}
    268a:	c9                   	leave  
    268b:	c3                   	ret    

0000268c <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    268c:	55                   	push   %ebp
    268d:	89 e5                	mov    %esp,%ebp
    268f:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    2692:	8b 45 08             	mov    0x8(%ebp),%eax
    2695:	8b 00                	mov    (%eax),%eax
    2697:	89 45 e0             	mov    %eax,-0x20(%ebp)
    269a:	db 45 e0             	fildl  -0x20(%ebp)
    269d:	d9 5d e0             	fstps  -0x20(%ebp)
    26a0:	83 ec 0c             	sub    $0xc,%esp
    26a3:	ff 75 10             	pushl  0x10(%ebp)
    26a6:	e8 6b e2 ff ff       	call   916 <cos>
    26ab:	83 c4 10             	add    $0x10,%esp
    26ae:	d9 5d dc             	fstps  -0x24(%ebp)
    26b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    26b4:	83 ec 0c             	sub    $0xc,%esp
    26b7:	50                   	push   %eax
    26b8:	e8 90 e1 ff ff       	call   84d <abs>
    26bd:	83 c4 10             	add    $0x10,%esp
    26c0:	d8 4d e0             	fmuls  -0x20(%ebp)
    26c3:	d9 5d e0             	fstps  -0x20(%ebp)
    26c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    26c9:	8b 00                	mov    (%eax),%eax
    26cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    26ce:	db 45 dc             	fildl  -0x24(%ebp)
    26d1:	d9 5d dc             	fstps  -0x24(%ebp)
    26d4:	83 ec 0c             	sub    $0xc,%esp
    26d7:	ff 75 10             	pushl  0x10(%ebp)
    26da:	e8 da e3 ff ff       	call   ab9 <sin>
    26df:	83 c4 10             	add    $0x10,%esp
    26e2:	d9 5d d8             	fstps  -0x28(%ebp)
    26e5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    26e8:	83 ec 0c             	sub    $0xc,%esp
    26eb:	50                   	push   %eax
    26ec:	e8 5c e1 ff ff       	call   84d <abs>
    26f1:	83 c4 10             	add    $0x10,%esp
    26f4:	d8 4d dc             	fmuls  -0x24(%ebp)
    26f7:	d8 45 e0             	fadds  -0x20(%ebp)
    26fa:	d9 7d e6             	fnstcw -0x1a(%ebp)
    26fd:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2701:	b4 0c                	mov    $0xc,%ah
    2703:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2707:	d9 6d e4             	fldcw  -0x1c(%ebp)
    270a:	db 5d f4             	fistpl -0xc(%ebp)
    270d:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    2710:	8b 45 08             	mov    0x8(%ebp),%eax
    2713:	8b 00                	mov    (%eax),%eax
    2715:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2718:	db 45 e0             	fildl  -0x20(%ebp)
    271b:	d9 5d e0             	fstps  -0x20(%ebp)
    271e:	83 ec 0c             	sub    $0xc,%esp
    2721:	ff 75 10             	pushl  0x10(%ebp)
    2724:	e8 90 e3 ff ff       	call   ab9 <sin>
    2729:	83 c4 10             	add    $0x10,%esp
    272c:	d9 5d dc             	fstps  -0x24(%ebp)
    272f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2732:	83 ec 0c             	sub    $0xc,%esp
    2735:	50                   	push   %eax
    2736:	e8 12 e1 ff ff       	call   84d <abs>
    273b:	83 c4 10             	add    $0x10,%esp
    273e:	d8 4d e0             	fmuls  -0x20(%ebp)
    2741:	d9 5d e0             	fstps  -0x20(%ebp)
    2744:	8b 45 0c             	mov    0xc(%ebp),%eax
    2747:	8b 00                	mov    (%eax),%eax
    2749:	89 45 dc             	mov    %eax,-0x24(%ebp)
    274c:	db 45 dc             	fildl  -0x24(%ebp)
    274f:	d9 5d dc             	fstps  -0x24(%ebp)
    2752:	83 ec 0c             	sub    $0xc,%esp
    2755:	ff 75 10             	pushl  0x10(%ebp)
    2758:	e8 b9 e1 ff ff       	call   916 <cos>
    275d:	83 c4 10             	add    $0x10,%esp
    2760:	d9 5d d8             	fstps  -0x28(%ebp)
    2763:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2766:	83 ec 0c             	sub    $0xc,%esp
    2769:	50                   	push   %eax
    276a:	e8 de e0 ff ff       	call   84d <abs>
    276f:	83 c4 10             	add    $0x10,%esp
    2772:	d8 4d dc             	fmuls  -0x24(%ebp)
    2775:	d8 45 e0             	fadds  -0x20(%ebp)
    2778:	d9 7d e6             	fnstcw -0x1a(%ebp)
    277b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    277f:	b4 0c                	mov    $0xc,%ah
    2781:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2785:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2788:	db 5d f0             	fistpl -0x10(%ebp)
    278b:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    278e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2791:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2794:	89 10                	mov    %edx,(%eax)
    *width = w;
    2796:	8b 45 08             	mov    0x8(%ebp),%eax
    2799:	8b 55 f4             	mov    -0xc(%ebp),%edx
    279c:	89 10                	mov    %edx,(%eax)
    return 1;
    279e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    27a3:	c9                   	leave  
    27a4:	c3                   	ret    

000027a5 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    27a5:	55                   	push   %ebp
    27a6:	89 e5                	mov    %esp,%ebp
    27a8:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    27ab:	8b 45 08             	mov    0x8(%ebp),%eax
    27ae:	8b 40 04             	mov    0x4(%eax),%eax
    27b1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27b4:	db 45 c4             	fildl  -0x3c(%ebp)
    27b7:	d9 05 84 9c 01 00    	flds   0x19c84
    27bd:	de f9                	fdivrp %st,%st(1)
    27bf:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    27c2:	8b 45 08             	mov    0x8(%ebp),%eax
    27c5:	8b 00                	mov    (%eax),%eax
    27c7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27ca:	db 45 c4             	fildl  -0x3c(%ebp)
    27cd:	d9 05 84 9c 01 00    	flds   0x19c84
    27d3:	de f9                	fdivrp %st,%st(1)
    27d5:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    27d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    27db:	8b 50 04             	mov    0x4(%eax),%edx
    27de:	8b 45 08             	mov    0x8(%ebp),%eax
    27e1:	8b 40 04             	mov    0x4(%eax),%eax
    27e4:	29 c2                	sub    %eax,%edx
    27e6:	89 d0                	mov    %edx,%eax
    27e8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27eb:	db 45 c4             	fildl  -0x3c(%ebp)
    27ee:	d9 05 84 9c 01 00    	flds   0x19c84
    27f4:	de f9                	fdivrp %st,%st(1)
    27f6:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    27f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    27fc:	8b 10                	mov    (%eax),%edx
    27fe:	8b 45 08             	mov    0x8(%ebp),%eax
    2801:	8b 00                	mov    (%eax),%eax
    2803:	29 c2                	sub    %eax,%edx
    2805:	89 d0                	mov    %edx,%eax
    2807:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    280a:	db 45 c4             	fildl  -0x3c(%ebp)
    280d:	d9 05 84 9c 01 00    	flds   0x19c84
    2813:	de f9                	fdivrp %st,%st(1)
    2815:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2818:	d9 45 10             	flds   0x10(%ebp)
    281b:	d9 e0                	fchs   
    281d:	83 ec 0c             	sub    $0xc,%esp
    2820:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2824:	d9 1c 24             	fstps  (%esp)
    2827:	e8 ea e0 ff ff       	call   916 <cos>
    282c:	83 c4 10             	add    $0x10,%esp
    282f:	d9 5d c4             	fstps  -0x3c(%ebp)
    2832:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2835:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2838:	d9 45 10             	flds   0x10(%ebp)
    283b:	d9 e0                	fchs   
    283d:	83 ec 0c             	sub    $0xc,%esp
    2840:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2844:	d9 1c 24             	fstps  (%esp)
    2847:	e8 6d e2 ff ff       	call   ab9 <sin>
    284c:	83 c4 10             	add    $0x10,%esp
    284f:	d9 5d c4             	fstps  -0x3c(%ebp)
    2852:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2855:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2858:	d9 ee                	fldz   
    285a:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    285d:	d9 ee                	fldz   
    285f:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2862:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2869:	e9 28 01 00 00       	jmp    2996 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    286e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2875:	e9 0a 01 00 00       	jmp    2984 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    287a:	db 45 f4             	fildl  -0xc(%ebp)
    287d:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2880:	d8 65 ec             	fsubs  -0x14(%ebp)
    2883:	d8 4d dc             	fmuls  -0x24(%ebp)
    2886:	db 45 f0             	fildl  -0x10(%ebp)
    2889:	d8 65 e0             	fsubs  -0x20(%ebp)
    288c:	d8 65 e8             	fsubs  -0x18(%ebp)
    288f:	d8 4d d8             	fmuls  -0x28(%ebp)
    2892:	de c1                	faddp  %st,%st(1)
    2894:	d8 45 ec             	fadds  -0x14(%ebp)
    2897:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    289a:	db 45 f0             	fildl  -0x10(%ebp)
    289d:	d8 65 e0             	fsubs  -0x20(%ebp)
    28a0:	d8 65 e8             	fsubs  -0x18(%ebp)
    28a3:	d8 4d dc             	fmuls  -0x24(%ebp)
    28a6:	db 45 f4             	fildl  -0xc(%ebp)
    28a9:	d8 65 e4             	fsubs  -0x1c(%ebp)
    28ac:	d8 65 ec             	fsubs  -0x14(%ebp)
    28af:	d8 4d d8             	fmuls  -0x28(%ebp)
    28b2:	de e9                	fsubrp %st,%st(1)
    28b4:	d8 45 e8             	fadds  -0x18(%ebp)
    28b7:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    28ba:	d9 45 d4             	flds   -0x2c(%ebp)
    28bd:	d9 ee                	fldz   
    28bf:	d9 c9                	fxch   %st(1)
    28c1:	df e9                	fucomip %st(1),%st
    28c3:	dd d8                	fstp   %st(0)
    28c5:	0f 93 c0             	setae  %al
    28c8:	83 f0 01             	xor    $0x1,%eax
    28cb:	84 c0                	test   %al,%al
    28cd:	75 52                	jne    2921 <picTurn+0x17c>
    28cf:	8b 45 08             	mov    0x8(%ebp),%eax
    28d2:	8b 40 04             	mov    0x4(%eax),%eax
    28d5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28d8:	db 45 c4             	fildl  -0x3c(%ebp)
    28db:	d9 45 d4             	flds   -0x2c(%ebp)
    28de:	d9 c9                	fxch   %st(1)
    28e0:	df e9                	fucomip %st(1),%st
    28e2:	dd d8                	fstp   %st(0)
    28e4:	0f 97 c0             	seta   %al
    28e7:	83 f0 01             	xor    $0x1,%eax
    28ea:	84 c0                	test   %al,%al
    28ec:	75 33                	jne    2921 <picTurn+0x17c>
    28ee:	d9 45 d0             	flds   -0x30(%ebp)
    28f1:	d9 ee                	fldz   
    28f3:	d9 c9                	fxch   %st(1)
    28f5:	df e9                	fucomip %st(1),%st
    28f7:	dd d8                	fstp   %st(0)
    28f9:	0f 93 c0             	setae  %al
    28fc:	83 f0 01             	xor    $0x1,%eax
    28ff:	84 c0                	test   %al,%al
    2901:	75 1e                	jne    2921 <picTurn+0x17c>
    2903:	8b 45 08             	mov    0x8(%ebp),%eax
    2906:	8b 00                	mov    (%eax),%eax
    2908:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    290b:	db 45 c4             	fildl  -0x3c(%ebp)
    290e:	d9 45 d0             	flds   -0x30(%ebp)
    2911:	d9 c9                	fxch   %st(1)
    2913:	df e9                	fucomip %st(1),%st
    2915:	dd d8                	fstp   %st(0)
    2917:	0f 97 c0             	seta   %al
    291a:	83 f0 01             	xor    $0x1,%eax
    291d:	84 c0                	test   %al,%al
    291f:	74 2f                	je     2950 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2921:	8b 45 0c             	mov    0xc(%ebp),%eax
    2924:	8b 48 08             	mov    0x8(%eax),%ecx
    2927:	8b 45 0c             	mov    0xc(%ebp),%eax
    292a:	8b 00                	mov    (%eax),%eax
    292c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2930:	89 c2                	mov    %eax,%edx
    2932:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2935:	01 c2                	add    %eax,%edx
    2937:	89 d0                	mov    %edx,%eax
    2939:	01 c0                	add    %eax,%eax
    293b:	01 d0                	add    %edx,%eax
    293d:	01 c8                	add    %ecx,%eax
    293f:	83 ec 08             	sub    $0x8,%esp
    2942:	50                   	push   %eax
    2943:	68 d1 e0 01 00       	push   $0x1e0d1
    2948:	e8 9f f6 ff ff       	call   1fec <setColor>
    294d:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2950:	8b 45 0c             	mov    0xc(%ebp),%eax
    2953:	8b 48 08             	mov    0x8(%eax),%ecx
    2956:	8b 45 0c             	mov    0xc(%ebp),%eax
    2959:	8b 00                	mov    (%eax),%eax
    295b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    295f:	89 c2                	mov    %eax,%edx
    2961:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2964:	01 c2                	add    %eax,%edx
    2966:	89 d0                	mov    %edx,%eax
    2968:	01 c0                	add    %eax,%eax
    296a:	01 d0                	add    %edx,%eax
    296c:	01 c8                	add    %ecx,%eax
    296e:	50                   	push   %eax
    296f:	ff 75 d0             	pushl  -0x30(%ebp)
    2972:	ff 75 d4             	pushl  -0x2c(%ebp)
    2975:	ff 75 08             	pushl  0x8(%ebp)
    2978:	e8 9e f6 ff ff       	call   201b <mixColor>
    297d:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2980:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2984:	8b 45 0c             	mov    0xc(%ebp),%eax
    2987:	8b 00                	mov    (%eax),%eax
    2989:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    298c:	0f 8f e8 fe ff ff    	jg     287a <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2992:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2996:	8b 45 0c             	mov    0xc(%ebp),%eax
    2999:	8b 40 04             	mov    0x4(%eax),%eax
    299c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    299f:	0f 8f c9 fe ff ff    	jg     286e <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    29a5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    29aa:	c9                   	leave  
    29ab:	c3                   	ret    

000029ac <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    29ac:	55                   	push   %ebp
    29ad:	89 e5                	mov    %esp,%ebp
    29af:	53                   	push   %ebx
    29b0:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    29b3:	8b 45 08             	mov    0x8(%ebp),%eax
    29b6:	8b 10                	mov    (%eax),%edx
    29b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    29bb:	8b 00                	mov    (%eax),%eax
    29bd:	39 c2                	cmp    %eax,%edx
    29bf:	75 10                	jne    29d1 <picRollingOver+0x25>
    29c1:	8b 45 08             	mov    0x8(%ebp),%eax
    29c4:	8b 50 04             	mov    0x4(%eax),%edx
    29c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    29ca:	8b 40 04             	mov    0x4(%eax),%eax
    29cd:	39 c2                	cmp    %eax,%edx
    29cf:	74 0a                	je     29db <picRollingOver+0x2f>
        return 0;
    29d1:	b8 00 00 00 00       	mov    $0x0,%eax
    29d6:	e9 88 00 00 00       	jmp    2a63 <picRollingOver+0xb7>

    int h = src->height;
    29db:	8b 45 08             	mov    0x8(%ebp),%eax
    29de:	8b 40 04             	mov    0x4(%eax),%eax
    29e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    29e4:	8b 45 08             	mov    0x8(%ebp),%eax
    29e7:	8b 00                	mov    (%eax),%eax
    29e9:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    29ec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    29f3:	eb 61                	jmp    2a56 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    29f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    29fc:	eb 4c                	jmp    2a4a <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    29fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a01:	8b 48 08             	mov    0x8(%eax),%ecx
    2a04:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a07:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2a0a:	83 e8 01             	sub    $0x1,%eax
    2a0d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a11:	89 c2                	mov    %eax,%edx
    2a13:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a16:	01 c2                	add    %eax,%edx
    2a18:	89 d0                	mov    %edx,%eax
    2a1a:	01 c0                	add    %eax,%eax
    2a1c:	01 d0                	add    %edx,%eax
    2a1e:	01 c1                	add    %eax,%ecx
    2a20:	8b 45 08             	mov    0x8(%ebp),%eax
    2a23:	8b 58 08             	mov    0x8(%eax),%ebx
    2a26:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a29:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a2d:	89 c2                	mov    %eax,%edx
    2a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a32:	01 c2                	add    %eax,%edx
    2a34:	89 d0                	mov    %edx,%eax
    2a36:	01 c0                	add    %eax,%eax
    2a38:	01 d0                	add    %edx,%eax
    2a3a:	01 d8                	add    %ebx,%eax
    2a3c:	51                   	push   %ecx
    2a3d:	50                   	push   %eax
    2a3e:	e8 a9 f5 ff ff       	call   1fec <setColor>
    2a43:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2a46:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a4d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2a50:	7c ac                	jl     29fe <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2a52:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2a56:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a59:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a5c:	7c 97                	jl     29f5 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2a5e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a63:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2a66:	c9                   	leave  
    2a67:	c3                   	ret    

00002a68 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2a68:	55                   	push   %ebp
    2a69:	89 e5                	mov    %esp,%ebp
    2a6b:	53                   	push   %ebx
    2a6c:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2a6f:	8b 45 08             	mov    0x8(%ebp),%eax
    2a72:	8b 10                	mov    (%eax),%edx
    2a74:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a77:	8b 00                	mov    (%eax),%eax
    2a79:	39 c2                	cmp    %eax,%edx
    2a7b:	75 10                	jne    2a8d <picTurnAround+0x25>
    2a7d:	8b 45 08             	mov    0x8(%ebp),%eax
    2a80:	8b 50 04             	mov    0x4(%eax),%edx
    2a83:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a86:	8b 40 04             	mov    0x4(%eax),%eax
    2a89:	39 c2                	cmp    %eax,%edx
    2a8b:	74 0a                	je     2a97 <picTurnAround+0x2f>
        return 0;
    2a8d:	b8 00 00 00 00       	mov    $0x0,%eax
    2a92:	e9 88 00 00 00       	jmp    2b1f <picTurnAround+0xb7>

    int h = src->height;
    2a97:	8b 45 08             	mov    0x8(%ebp),%eax
    2a9a:	8b 40 04             	mov    0x4(%eax),%eax
    2a9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    2aa3:	8b 00                	mov    (%eax),%eax
    2aa5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2aa8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2aaf:	eb 61                	jmp    2b12 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2ab1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2ab8:	eb 4c                	jmp    2b06 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2aba:	8b 45 0c             	mov    0xc(%ebp),%eax
    2abd:	8b 48 08             	mov    0x8(%eax),%ecx
    2ac0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ac3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ac7:	89 c2                	mov    %eax,%edx
    2ac9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2acc:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2acf:	01 c2                	add    %eax,%edx
    2ad1:	89 d0                	mov    %edx,%eax
    2ad3:	01 c0                	add    %eax,%eax
    2ad5:	01 d0                	add    %edx,%eax
    2ad7:	83 e8 03             	sub    $0x3,%eax
    2ada:	01 c1                	add    %eax,%ecx
    2adc:	8b 45 08             	mov    0x8(%ebp),%eax
    2adf:	8b 58 08             	mov    0x8(%eax),%ebx
    2ae2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ae5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ae9:	89 c2                	mov    %eax,%edx
    2aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2aee:	01 c2                	add    %eax,%edx
    2af0:	89 d0                	mov    %edx,%eax
    2af2:	01 c0                	add    %eax,%eax
    2af4:	01 d0                	add    %edx,%eax
    2af6:	01 d8                	add    %ebx,%eax
    2af8:	51                   	push   %ecx
    2af9:	50                   	push   %eax
    2afa:	e8 ed f4 ff ff       	call   1fec <setColor>
    2aff:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2b02:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b09:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2b0c:	7c ac                	jl     2aba <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2b0e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2b12:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b15:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2b18:	7c 97                	jl     2ab1 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2b1a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b22:	c9                   	leave  
    2b23:	c3                   	ret    

00002b24 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2b24:	55                   	push   %ebp
    2b25:	89 e5                	mov    %esp,%ebp
    2b27:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2b2a:	83 ec 0c             	sub    $0xc,%esp
    2b2d:	ff 75 08             	pushl  0x8(%ebp)
    2b30:	e8 c5 d5 ff ff       	call   fa <strlen>
    2b35:	83 c4 10             	add    $0x10,%esp
    2b38:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2b3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b3e:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b41:	8b 45 08             	mov    0x8(%ebp),%eax
    2b44:	01 d0                	add    %edx,%eax
    2b46:	0f b6 00             	movzbl (%eax),%eax
    2b49:	3c 67                	cmp    $0x67,%al
    2b4b:	75 2b                	jne    2b78 <type+0x54>
    2b4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b50:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b53:	8b 45 08             	mov    0x8(%ebp),%eax
    2b56:	01 d0                	add    %edx,%eax
    2b58:	0f b6 00             	movzbl (%eax),%eax
    2b5b:	3c 70                	cmp    $0x70,%al
    2b5d:	75 19                	jne    2b78 <type+0x54>
    2b5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b62:	8d 50 fd             	lea    -0x3(%eax),%edx
    2b65:	8b 45 08             	mov    0x8(%ebp),%eax
    2b68:	01 d0                	add    %edx,%eax
    2b6a:	0f b6 00             	movzbl (%eax),%eax
    2b6d:	3c 6a                	cmp    $0x6a,%al
    2b6f:	75 07                	jne    2b78 <type+0x54>
    2b71:	b8 00 00 00 00       	mov    $0x0,%eax
    2b76:	eb 7f                	jmp    2bf7 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b7b:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b7e:	8b 45 08             	mov    0x8(%ebp),%eax
    2b81:	01 d0                	add    %edx,%eax
    2b83:	0f b6 00             	movzbl (%eax),%eax
    2b86:	3c 70                	cmp    $0x70,%al
    2b88:	75 2b                	jne    2bb5 <type+0x91>
    2b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b8d:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b90:	8b 45 08             	mov    0x8(%ebp),%eax
    2b93:	01 d0                	add    %edx,%eax
    2b95:	0f b6 00             	movzbl (%eax),%eax
    2b98:	3c 6d                	cmp    $0x6d,%al
    2b9a:	75 19                	jne    2bb5 <type+0x91>
    2b9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b9f:	8d 50 fd             	lea    -0x3(%eax),%edx
    2ba2:	8b 45 08             	mov    0x8(%ebp),%eax
    2ba5:	01 d0                	add    %edx,%eax
    2ba7:	0f b6 00             	movzbl (%eax),%eax
    2baa:	3c 62                	cmp    $0x62,%al
    2bac:	75 07                	jne    2bb5 <type+0x91>
    2bae:	b8 01 00 00 00       	mov    $0x1,%eax
    2bb3:	eb 42                	jmp    2bf7 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bb8:	8d 50 ff             	lea    -0x1(%eax),%edx
    2bbb:	8b 45 08             	mov    0x8(%ebp),%eax
    2bbe:	01 d0                	add    %edx,%eax
    2bc0:	0f b6 00             	movzbl (%eax),%eax
    2bc3:	3c 67                	cmp    $0x67,%al
    2bc5:	75 2b                	jne    2bf2 <type+0xce>
    2bc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bca:	8d 50 fe             	lea    -0x2(%eax),%edx
    2bcd:	8b 45 08             	mov    0x8(%ebp),%eax
    2bd0:	01 d0                	add    %edx,%eax
    2bd2:	0f b6 00             	movzbl (%eax),%eax
    2bd5:	3c 6e                	cmp    $0x6e,%al
    2bd7:	75 19                	jne    2bf2 <type+0xce>
    2bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bdc:	8d 50 fd             	lea    -0x3(%eax),%edx
    2bdf:	8b 45 08             	mov    0x8(%ebp),%eax
    2be2:	01 d0                	add    %edx,%eax
    2be4:	0f b6 00             	movzbl (%eax),%eax
    2be7:	3c 70                	cmp    $0x70,%al
    2be9:	75 07                	jne    2bf2 <type+0xce>
    2beb:	b8 02 00 00 00       	mov    $0x2,%eax
    2bf0:	eb 05                	jmp    2bf7 <type+0xd3>
    else return NONE;
    2bf2:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2bf7:	c9                   	leave  
    2bf8:	c3                   	ret    

00002bf9 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2bf9:	55                   	push   %ebp
    2bfa:	89 e5                	mov    %esp,%ebp
    2bfc:	56                   	push   %esi
    2bfd:	53                   	push   %ebx
    2bfe:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2c01:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2c08:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2c0f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2c16:	83 ec 08             	sub    $0x8,%esp
    2c19:	6a 00                	push   $0x0
    2c1b:	ff 75 0c             	pushl  0xc(%ebp)
    2c1e:	e8 d9 d6 ff ff       	call   2fc <open>
    2c23:	83 c4 10             	add    $0x10,%esp
    2c26:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2c29:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2c2d:	79 2c                	jns    2c5b <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2c2f:	83 ec 08             	sub    $0x8,%esp
    2c32:	ff 75 0c             	pushl  0xc(%ebp)
    2c35:	68 88 9c 01 00       	push   $0x19c88
    2c3a:	e8 24 d8 ff ff       	call   463 <printf>
    2c3f:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2c42:	8b 45 08             	mov    0x8(%ebp),%eax
    2c45:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2c48:	89 10                	mov    %edx,(%eax)
    2c4a:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2c4d:	89 50 04             	mov    %edx,0x4(%eax)
    2c50:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2c53:	89 50 08             	mov    %edx,0x8(%eax)
    2c56:	e9 2d 02 00 00       	jmp    2e88 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2c5b:	83 ec 04             	sub    $0x4,%esp
    2c5e:	6a 0e                	push   $0xe
    2c60:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2c63:	50                   	push   %eax
    2c64:	ff 75 ec             	pushl  -0x14(%ebp)
    2c67:	e8 68 d6 ff ff       	call   2d4 <read>
    2c6c:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2c6f:	83 ec 04             	sub    $0x4,%esp
    2c72:	6a 28                	push   $0x28
    2c74:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2c77:	50                   	push   %eax
    2c78:	ff 75 ec             	pushl  -0x14(%ebp)
    2c7b:	e8 54 d6 ff ff       	call   2d4 <read>
    2c80:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c83:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c87:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c8a:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c8e:	0f b7 d8             	movzwl %ax,%ebx
    2c91:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2c94:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2c97:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2c9b:	0f b7 c0             	movzwl %ax,%eax
    2c9e:	83 ec 04             	sub    $0x4,%esp
    2ca1:	6a 36                	push   $0x36
    2ca3:	56                   	push   %esi
    2ca4:	53                   	push   %ebx
    2ca5:	51                   	push   %ecx
    2ca6:	52                   	push   %edx
    2ca7:	50                   	push   %eax
    2ca8:	68 98 9c 01 00       	push   $0x19c98
    2cad:	e8 b1 d7 ff ff       	call   463 <printf>
    2cb2:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2cb5:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2cb8:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2cbb:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2cbe:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2cc1:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2cc4:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2cc7:	0f af c2             	imul   %edx,%eax
    2cca:	89 c2                	mov    %eax,%edx
    2ccc:	89 d0                	mov    %edx,%eax
    2cce:	01 c0                	add    %eax,%eax
    2cd0:	01 d0                	add    %edx,%eax
    2cd2:	83 ec 0c             	sub    $0xc,%esp
    2cd5:	50                   	push   %eax
    2cd6:	e8 5b da ff ff       	call   736 <malloc>
    2cdb:	83 c4 10             	add    $0x10,%esp
    2cde:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2ce1:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2ce5:	0f b7 c0             	movzwl %ax,%eax
    2ce8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2ceb:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2cee:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2cf2:	83 c0 1f             	add    $0x1f,%eax
    2cf5:	c1 f8 05             	sar    $0x5,%eax
    2cf8:	c1 e0 02             	shl    $0x2,%eax
    2cfb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2cfe:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d01:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2d05:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2d08:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2d0b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d0e:	83 ec 08             	sub    $0x8,%esp
    2d11:	52                   	push   %edx
    2d12:	50                   	push   %eax
    2d13:	ff 75 e8             	pushl  -0x18(%ebp)
    2d16:	ff 75 e0             	pushl  -0x20(%ebp)
    2d19:	ff 75 e4             	pushl  -0x1c(%ebp)
    2d1c:	68 c0 9c 01 00       	push   $0x19cc0
    2d21:	e8 3d d7 ff ff       	call   463 <printf>
    2d26:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2d29:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2d2c:	83 e8 36             	sub    $0x36,%eax
    2d2f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2d32:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2d35:	83 ec 0c             	sub    $0xc,%esp
    2d38:	50                   	push   %eax
    2d39:	e8 f8 d9 ff ff       	call   736 <malloc>
    2d3e:	83 c4 10             	add    $0x10,%esp
    2d41:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2d44:	83 ec 04             	sub    $0x4,%esp
    2d47:	ff 75 dc             	pushl  -0x24(%ebp)
    2d4a:	ff 75 d8             	pushl  -0x28(%ebp)
    2d4d:	ff 75 ec             	pushl  -0x14(%ebp)
    2d50:	e8 7f d5 ff ff       	call   2d4 <read>
    2d55:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2d58:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d5b:	83 ec 0c             	sub    $0xc,%esp
    2d5e:	50                   	push   %eax
    2d5f:	e8 d2 d9 ff ff       	call   736 <malloc>
    2d64:	83 c4 10             	add    $0x10,%esp
    2d67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2d6a:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d6d:	83 ec 04             	sub    $0x4,%esp
    2d70:	50                   	push   %eax
    2d71:	ff 75 d4             	pushl  -0x2c(%ebp)
    2d74:	ff 75 ec             	pushl  -0x14(%ebp)
    2d77:	e8 58 d5 ff ff       	call   2d4 <read>
    2d7c:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2d7f:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2d83:	66 c1 e8 03          	shr    $0x3,%ax
    2d87:	0f b7 c0             	movzwl %ax,%eax
    2d8a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2d8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2d94:	e9 c1 00 00 00       	jmp    2e5a <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2d99:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d9c:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2d9f:	8d 50 ff             	lea    -0x1(%eax),%edx
    2da2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2da5:	0f af c2             	imul   %edx,%eax
    2da8:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2dab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dae:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2db2:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2db5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2dbc:	e9 89 00 00 00       	jmp    2e4a <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2dc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2dc4:	83 c0 01             	add    $0x1,%eax
    2dc7:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2dcb:	89 c2                	mov    %eax,%edx
    2dcd:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2dd0:	01 d0                	add    %edx,%eax
    2dd2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2dd5:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2dd8:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2ddb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2dde:	01 c8                	add    %ecx,%eax
    2de0:	89 c1                	mov    %eax,%ecx
    2de2:	89 c8                	mov    %ecx,%eax
    2de4:	01 c0                	add    %eax,%eax
    2de6:	01 c8                	add    %ecx,%eax
    2de8:	01 c2                	add    %eax,%edx
    2dea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2ded:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2df0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2df3:	01 c8                	add    %ecx,%eax
    2df5:	0f b6 00             	movzbl (%eax),%eax
    2df8:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2dfb:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2dfe:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e04:	01 c8                	add    %ecx,%eax
    2e06:	89 c1                	mov    %eax,%ecx
    2e08:	89 c8                	mov    %ecx,%eax
    2e0a:	01 c0                	add    %eax,%eax
    2e0c:	01 c8                	add    %ecx,%eax
    2e0e:	01 c2                	add    %eax,%edx
    2e10:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e13:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2e16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e19:	01 c8                	add    %ecx,%eax
    2e1b:	0f b6 00             	movzbl (%eax),%eax
    2e1e:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2e21:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e24:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e27:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e2a:	01 c8                	add    %ecx,%eax
    2e2c:	89 c1                	mov    %eax,%ecx
    2e2e:	89 c8                	mov    %ecx,%eax
    2e30:	01 c0                	add    %eax,%eax
    2e32:	01 c8                	add    %ecx,%eax
    2e34:	01 c2                	add    %eax,%edx
    2e36:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e39:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2e3c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e3f:	01 c8                	add    %ecx,%eax
    2e41:	0f b6 00             	movzbl (%eax),%eax
    2e44:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2e46:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2e4a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e4d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2e50:	0f 8f 6b ff ff ff    	jg     2dc1 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2e56:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2e5a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e5d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2e60:	0f 8f 33 ff ff ff    	jg     2d99 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2e66:	83 ec 0c             	sub    $0xc,%esp
    2e69:	ff 75 ec             	pushl  -0x14(%ebp)
    2e6c:	e8 73 d4 ff ff       	call   2e4 <close>
    2e71:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2e74:	8b 45 08             	mov    0x8(%ebp),%eax
    2e77:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2e7a:	89 10                	mov    %edx,(%eax)
    2e7c:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2e7f:	89 50 04             	mov    %edx,0x4(%eax)
    2e82:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e85:	89 50 08             	mov    %edx,0x8(%eax)
}
    2e88:	8b 45 08             	mov    0x8(%ebp),%eax
    2e8b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2e8e:	5b                   	pop    %ebx
    2e8f:	5e                   	pop    %esi
    2e90:	5d                   	pop    %ebp
    2e91:	c2 04 00             	ret    $0x4

00002e94 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2e94:	55                   	push   %ebp
    2e95:	89 e5                	mov    %esp,%ebp
    2e97:	53                   	push   %ebx
    2e98:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2e9b:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2e9f:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2ea3:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2ea7:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2eab:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2eaf:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2eb3:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2eb7:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2ebb:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2ebf:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2ec3:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2ec7:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2ecb:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2ecf:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2ed3:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2ed7:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2edb:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2edf:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2ee3:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2ee7:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2eeb:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2eef:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2ef3:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2ef7:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2efb:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2eff:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2f03:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2f07:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2f0b:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2f0f:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    2f13:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    2f17:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    2f1b:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    2f1f:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    2f23:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    2f27:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    2f2b:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    2f2f:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    2f33:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    2f37:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    2f3b:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    2f3f:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    2f43:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    2f47:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    2f4b:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    2f4f:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    2f53:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    2f57:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    2f5b:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    2f5f:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    2f63:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    2f67:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    2f6b:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    2f6f:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    2f73:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    2f77:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    2f7b:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    2f7f:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    2f83:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    2f87:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    2f8b:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    2f8f:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    2f93:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    2f97:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    2f9b:	83 ec 0c             	sub    $0xc,%esp
    2f9e:	68 c8 02 08 00       	push   $0x802c8
    2fa3:	e8 8e d7 ff ff       	call   736 <malloc>
    2fa8:	83 c4 10             	add    $0x10,%esp
    2fab:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    2fae:	83 ec 04             	sub    $0x4,%esp
    2fb1:	68 c8 02 08 00       	push   $0x802c8
    2fb6:	6a 00                	push   $0x0
    2fb8:	ff 75 f0             	pushl  -0x10(%ebp)
    2fbb:	e8 61 d1 ff ff       	call   121 <memset>
    2fc0:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    2fc3:	83 ec 08             	sub    $0x8,%esp
    2fc6:	6a 00                	push   $0x0
    2fc8:	ff 75 0c             	pushl  0xc(%ebp)
    2fcb:	e8 2c d3 ff ff       	call   2fc <open>
    2fd0:	83 c4 10             	add    $0x10,%esp
    2fd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    2fd6:	83 ec 0c             	sub    $0xc,%esp
    2fd9:	68 40 42 0f 00       	push   $0xf4240
    2fde:	e8 53 d7 ff ff       	call   736 <malloc>
    2fe3:	83 c4 10             	add    $0x10,%esp
    2fe6:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    2fe9:	83 ec 04             	sub    $0x4,%esp
    2fec:	68 40 42 0f 00       	push   $0xf4240
    2ff1:	ff 75 e8             	pushl  -0x18(%ebp)
    2ff4:	ff 75 ec             	pushl  -0x14(%ebp)
    2ff7:	e8 d8 d2 ff ff       	call   2d4 <read>
    2ffc:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    2fff:	83 ec 0c             	sub    $0xc,%esp
    3002:	ff 75 ec             	pushl  -0x14(%ebp)
    3005:	e8 da d2 ff ff       	call   2e4 <close>
    300a:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    300d:	68 40 42 0f 00       	push   $0xf4240
    3012:	ff 75 e8             	pushl  -0x18(%ebp)
    3015:	8d 45 9c             	lea    -0x64(%ebp),%eax
    3018:	50                   	push   %eax
    3019:	ff 75 f0             	pushl  -0x10(%ebp)
    301c:	e8 5e 0c 01 00       	call   13c7f <_DecodeJPEG>
    3021:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    3024:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    302b:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    3032:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3039:	83 ec 0c             	sub    $0xc,%esp
    303c:	ff 75 f0             	pushl  -0x10(%ebp)
    303f:	e8 29 0b 01 00       	call   13b6d <GetImageSize>
    3044:	83 c4 10             	add    $0x10,%esp
    3047:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    304a:	83 ec 0c             	sub    $0xc,%esp
    304d:	ff 75 f0             	pushl  -0x10(%ebp)
    3050:	e8 e1 0a 01 00       	call   13b36 <GetImage>
    3055:	83 c4 10             	add    $0x10,%esp
    3058:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    305b:	83 ec 0c             	sub    $0xc,%esp
    305e:	ff 75 f0             	pushl  -0x10(%ebp)
    3061:	e8 f1 0a 01 00       	call   13b57 <GetWidth>
    3066:	83 c4 10             	add    $0x10,%esp
    3069:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    306c:	83 ec 0c             	sub    $0xc,%esp
    306f:	ff 75 f0             	pushl  -0x10(%ebp)
    3072:	e8 eb 0a 01 00       	call   13b62 <GetHeight>
    3077:	83 c4 10             	add    $0x10,%esp
    307a:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    307d:	8b 55 90             	mov    -0x70(%ebp),%edx
    3080:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3083:	0f af c2             	imul   %edx,%eax
    3086:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3089:	8b 55 dc             	mov    -0x24(%ebp),%edx
    308c:	89 d0                	mov    %edx,%eax
    308e:	01 c0                	add    %eax,%eax
    3090:	01 d0                	add    %edx,%eax
    3092:	83 ec 0c             	sub    $0xc,%esp
    3095:	50                   	push   %eax
    3096:	e8 9b d6 ff ff       	call   736 <malloc>
    309b:	83 c4 10             	add    $0x10,%esp
    309e:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    30a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    30a8:	e9 9c 00 00 00       	jmp    3149 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    30ad:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30b0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30b3:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30b8:	89 c8                	mov    %ecx,%eax
    30ba:	f7 ea                	imul   %edx
    30bc:	89 c8                	mov    %ecx,%eax
    30be:	c1 f8 1f             	sar    $0x1f,%eax
    30c1:	29 c2                	sub    %eax,%edx
    30c3:	89 d0                	mov    %edx,%eax
    30c5:	89 c2                	mov    %eax,%edx
    30c7:	89 d0                	mov    %edx,%eax
    30c9:	01 c0                	add    %eax,%eax
    30cb:	01 d0                	add    %edx,%eax
    30cd:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    30d0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    30d6:	01 c8                	add    %ecx,%eax
    30d8:	0f b6 00             	movzbl (%eax),%eax
    30db:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    30de:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30e1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30e4:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30e9:	89 c8                	mov    %ecx,%eax
    30eb:	f7 ea                	imul   %edx
    30ed:	89 c8                	mov    %ecx,%eax
    30ef:	c1 f8 1f             	sar    $0x1f,%eax
    30f2:	29 c2                	sub    %eax,%edx
    30f4:	89 d0                	mov    %edx,%eax
    30f6:	89 c2                	mov    %eax,%edx
    30f8:	89 d0                	mov    %edx,%eax
    30fa:	01 c0                	add    %eax,%eax
    30fc:	01 d0                	add    %edx,%eax
    30fe:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3101:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3104:	8d 48 01             	lea    0x1(%eax),%ecx
    3107:	8b 45 e0             	mov    -0x20(%ebp),%eax
    310a:	01 c8                	add    %ecx,%eax
    310c:	0f b6 00             	movzbl (%eax),%eax
    310f:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    3112:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3115:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3118:	ba 56 55 55 55       	mov    $0x55555556,%edx
    311d:	89 c8                	mov    %ecx,%eax
    311f:	f7 ea                	imul   %edx
    3121:	89 c8                	mov    %ecx,%eax
    3123:	c1 f8 1f             	sar    $0x1f,%eax
    3126:	29 c2                	sub    %eax,%edx
    3128:	89 d0                	mov    %edx,%eax
    312a:	89 c2                	mov    %eax,%edx
    312c:	89 d0                	mov    %edx,%eax
    312e:	01 c0                	add    %eax,%eax
    3130:	01 d0                	add    %edx,%eax
    3132:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3135:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3138:	8d 48 02             	lea    0x2(%eax),%ecx
    313b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    313e:	01 c8                	add    %ecx,%eax
    3140:	0f b6 00             	movzbl (%eax),%eax
    3143:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3145:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3149:	8b 45 f4             	mov    -0xc(%ebp),%eax
    314c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    314f:	0f 8c 58 ff ff ff    	jl     30ad <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3155:	8b 45 08             	mov    0x8(%ebp),%eax
    3158:	8b 55 90             	mov    -0x70(%ebp),%edx
    315b:	89 10                	mov    %edx,(%eax)
    315d:	8b 55 94             	mov    -0x6c(%ebp),%edx
    3160:	89 50 04             	mov    %edx,0x4(%eax)
    3163:	8b 55 98             	mov    -0x68(%ebp),%edx
    3166:	89 50 08             	mov    %edx,0x8(%eax)
}
    3169:	8b 45 08             	mov    0x8(%ebp),%eax
    316c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    316f:	c9                   	leave  
    3170:	c2 04 00             	ret    $0x4

00003173 <LoadPng>:

PBitmap LoadPng(char* filename){
    3173:	55                   	push   %ebp
    3174:	89 e5                	mov    %esp,%ebp
    3176:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3179:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    3180:	ff 75 0c             	pushl  0xc(%ebp)
    3183:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3186:	50                   	push   %eax
    3187:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    318a:	50                   	push   %eax
    318b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    318e:	50                   	push   %eax
    318f:	e8 d3 d3 00 00       	call   10567 <lodepng_decode24_file>
    3194:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3197:	8b 45 e0             	mov    -0x20(%ebp),%eax
    319a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    319d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    31a0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    31a3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    31aa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    31ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
    31b0:	0f af c2             	imul   %edx,%eax
    31b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    31b6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    31b9:	89 d0                	mov    %edx,%eax
    31bb:	01 c0                	add    %eax,%eax
    31bd:	01 d0                	add    %edx,%eax
    31bf:	83 ec 0c             	sub    $0xc,%esp
    31c2:	50                   	push   %eax
    31c3:	e8 6e d5 ff ff       	call   736 <malloc>
    31c8:	83 c4 10             	add    $0x10,%esp
    31cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    31ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    31d5:	e9 87 00 00 00       	jmp    3261 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    31da:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31e0:	89 d0                	mov    %edx,%eax
    31e2:	01 c0                	add    %eax,%eax
    31e4:	01 d0                	add    %edx,%eax
    31e6:	01 c8                	add    %ecx,%eax
    31e8:	0f b6 00             	movzbl (%eax),%eax
    31eb:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    31ee:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31f4:	89 d0                	mov    %edx,%eax
    31f6:	01 c0                	add    %eax,%eax
    31f8:	01 d0                	add    %edx,%eax
    31fa:	83 c0 01             	add    $0x1,%eax
    31fd:	01 c8                	add    %ecx,%eax
    31ff:	0f b6 00             	movzbl (%eax),%eax
    3202:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    3205:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3208:	8b 55 f4             	mov    -0xc(%ebp),%edx
    320b:	89 d0                	mov    %edx,%eax
    320d:	01 c0                	add    %eax,%eax
    320f:	01 d0                	add    %edx,%eax
    3211:	83 c0 02             	add    $0x2,%eax
    3214:	01 c8                	add    %ecx,%eax
    3216:	0f b6 00             	movzbl (%eax),%eax
    3219:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    321c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    321f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3222:	89 d0                	mov    %edx,%eax
    3224:	01 c0                	add    %eax,%eax
    3226:	01 d0                	add    %edx,%eax
    3228:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    322b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    322f:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    3232:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3235:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3238:	89 d0                	mov    %edx,%eax
    323a:	01 c0                	add    %eax,%eax
    323c:	01 d0                	add    %edx,%eax
    323e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3241:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3245:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3248:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    324b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    324e:	89 d0                	mov    %edx,%eax
    3250:	01 c0                	add    %eax,%eax
    3252:	01 d0                	add    %edx,%eax
    3254:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3257:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    325b:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    325d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3261:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3264:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3267:	0f 8c 6d ff ff ff    	jl     31da <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    326d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3270:	83 ec 0c             	sub    $0xc,%esp
    3273:	50                   	push   %eax
    3274:	e8 7b d3 ff ff       	call   5f4 <free>
    3279:	83 c4 10             	add    $0x10,%esp
    return bmp;
    327c:	8b 45 08             	mov    0x8(%ebp),%eax
    327f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3282:	89 10                	mov    %edx,(%eax)
    3284:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3287:	89 50 04             	mov    %edx,0x4(%eax)
    328a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    328d:	89 50 08             	mov    %edx,0x8(%eax)

}
    3290:	8b 45 08             	mov    0x8(%ebp),%eax
    3293:	c9                   	leave  
    3294:	c2 04 00             	ret    $0x4

00003297 <LoadImg>:

PBitmap LoadImg(char* filename){
    3297:	55                   	push   %ebp
    3298:	89 e5                	mov    %esp,%ebp
    329a:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    329d:	83 ec 0c             	sub    $0xc,%esp
    32a0:	ff 75 0c             	pushl  0xc(%ebp)
    32a3:	e8 7c f8 ff ff       	call   2b24 <type>
    32a8:	83 c4 10             	add    $0x10,%esp
    32ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    32ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32b1:	83 f8 01             	cmp    $0x1,%eax
    32b4:	74 1d                	je     32d3 <LoadImg+0x3c>
    32b6:	83 f8 02             	cmp    $0x2,%eax
    32b9:	74 2c                	je     32e7 <LoadImg+0x50>
    32bb:	85 c0                	test   %eax,%eax
    32bd:	75 3c                	jne    32fb <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    32bf:	8b 45 08             	mov    0x8(%ebp),%eax
    32c2:	83 ec 08             	sub    $0x8,%esp
    32c5:	ff 75 0c             	pushl  0xc(%ebp)
    32c8:	50                   	push   %eax
    32c9:	e8 c6 fb ff ff       	call   2e94 <LoadJpeg>
    32ce:	83 c4 0c             	add    $0xc,%esp
    32d1:	eb 3c                	jmp    330f <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    32d3:	8b 45 08             	mov    0x8(%ebp),%eax
    32d6:	83 ec 08             	sub    $0x8,%esp
    32d9:	ff 75 0c             	pushl  0xc(%ebp)
    32dc:	50                   	push   %eax
    32dd:	e8 17 f9 ff ff       	call   2bf9 <LoadBmp>
    32e2:	83 c4 0c             	add    $0xc,%esp
    32e5:	eb 28                	jmp    330f <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    32e7:	8b 45 08             	mov    0x8(%ebp),%eax
    32ea:	83 ec 08             	sub    $0x8,%esp
    32ed:	ff 75 0c             	pushl  0xc(%ebp)
    32f0:	50                   	push   %eax
    32f1:	e8 7d fe ff ff       	call   3173 <LoadPng>
    32f6:	83 c4 0c             	add    $0xc,%esp
    32f9:	eb 14                	jmp    330f <LoadImg+0x78>

        default: return bmp;
    32fb:	8b 45 08             	mov    0x8(%ebp),%eax
    32fe:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3301:	89 10                	mov    %edx,(%eax)
    3303:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3306:	89 50 04             	mov    %edx,0x4(%eax)
    3309:	8b 55 f0             	mov    -0x10(%ebp),%edx
    330c:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    330f:	8b 45 08             	mov    0x8(%ebp),%eax
    3312:	c9                   	leave  
    3313:	c2 04 00             	ret    $0x4

00003316 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    3316:	55                   	push   %ebp
    3317:	89 e5                	mov    %esp,%ebp
    3319:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    331c:	8b 45 08             	mov    0x8(%ebp),%eax
    331f:	83 ec 0c             	sub    $0xc,%esp
    3322:	50                   	push   %eax
    3323:	e8 0e d4 ff ff       	call   736 <malloc>
    3328:	83 c4 10             	add    $0x10,%esp
}
    332b:	c9                   	leave  
    332c:	c3                   	ret    

0000332d <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    332d:	55                   	push   %ebp
    332e:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    3330:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3335:	5d                   	pop    %ebp
    3336:	c3                   	ret    

00003337 <lodepng_free>:

static void lodepng_free(void* ptr) {
    3337:	55                   	push   %ebp
    3338:	89 e5                	mov    %esp,%ebp
    333a:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    333d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3341:	74 0e                	je     3351 <lodepng_free+0x1a>
    free(ptr);
    3343:	83 ec 0c             	sub    $0xc,%esp
    3346:	ff 75 08             	pushl  0x8(%ebp)
    3349:	e8 a6 d2 ff ff       	call   5f4 <free>
    334e:	83 c4 10             	add    $0x10,%esp
}
    3351:	90                   	nop
    3352:	c9                   	leave  
    3353:	c3                   	ret    

00003354 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3354:	55                   	push   %ebp
    3355:	89 e5                	mov    %esp,%ebp
    3357:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    335a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3361:	eb 19                	jmp    337c <lodepng_memcpy+0x28>
    3363:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3366:	8b 45 08             	mov    0x8(%ebp),%eax
    3369:	01 c2                	add    %eax,%edx
    336b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    336e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3371:	01 c8                	add    %ecx,%eax
    3373:	0f b6 00             	movzbl (%eax),%eax
    3376:	88 02                	mov    %al,(%edx)
    3378:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    337c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    337f:	3b 45 10             	cmp    0x10(%ebp),%eax
    3382:	7c df                	jl     3363 <lodepng_memcpy+0xf>
}
    3384:	90                   	nop
    3385:	c9                   	leave  
    3386:	c3                   	ret    

00003387 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3387:	55                   	push   %ebp
    3388:	89 e5                	mov    %esp,%ebp
    338a:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    338d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3394:	eb 11                	jmp    33a7 <lodepng_memset+0x20>
    3396:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3399:	8b 45 08             	mov    0x8(%ebp),%eax
    339c:	01 d0                	add    %edx,%eax
    339e:	8b 55 0c             	mov    0xc(%ebp),%edx
    33a1:	88 10                	mov    %dl,(%eax)
    33a3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    33a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33aa:	3b 45 10             	cmp    0x10(%ebp),%eax
    33ad:	7c e7                	jl     3396 <lodepng_memset+0xf>
}
    33af:	90                   	nop
    33b0:	c9                   	leave  
    33b1:	c3                   	ret    

000033b2 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    33b2:	55                   	push   %ebp
    33b3:	89 e5                	mov    %esp,%ebp
    33b5:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    33b8:	8b 45 08             	mov    0x8(%ebp),%eax
    33bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    33be:	eb 04                	jmp    33c4 <lodepng_strlen+0x12>
    33c0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    33c4:	8b 45 08             	mov    0x8(%ebp),%eax
    33c7:	0f b6 00             	movzbl (%eax),%eax
    33ca:	84 c0                	test   %al,%al
    33cc:	75 f2                	jne    33c0 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    33ce:	8b 55 08             	mov    0x8(%ebp),%edx
    33d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33d4:	29 c2                	sub    %eax,%edx
    33d6:	89 d0                	mov    %edx,%eax
}
    33d8:	c9                   	leave  
    33d9:	c3                   	ret    

000033da <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    33da:	55                   	push   %ebp
    33db:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    33dd:	8b 55 08             	mov    0x8(%ebp),%edx
    33e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    33e3:	01 c2                	add    %eax,%edx
    33e5:	8b 45 10             	mov    0x10(%ebp),%eax
    33e8:	89 10                	mov    %edx,(%eax)
  return *result < a;
    33ea:	8b 45 10             	mov    0x10(%ebp),%eax
    33ed:	8b 00                	mov    (%eax),%eax
    33ef:	3b 45 08             	cmp    0x8(%ebp),%eax
    33f2:	0f 9c c0             	setl   %al
    33f5:	0f b6 c0             	movzbl %al,%eax
}
    33f8:	5d                   	pop    %ebp
    33f9:	c3                   	ret    

000033fa <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    33fa:	55                   	push   %ebp
    33fb:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    33fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3400:	0f af 45 0c          	imul   0xc(%ebp),%eax
    3404:	89 c2                	mov    %eax,%edx
    3406:	8b 45 10             	mov    0x10(%ebp),%eax
    3409:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    340b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    340f:	74 15                	je     3426 <lodepng_mulofl+0x2c>
    3411:	8b 45 10             	mov    0x10(%ebp),%eax
    3414:	8b 00                	mov    (%eax),%eax
    3416:	99                   	cltd   
    3417:	f7 7d 08             	idivl  0x8(%ebp)
    341a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    341d:	74 07                	je     3426 <lodepng_mulofl+0x2c>
    341f:	b8 01 00 00 00       	mov    $0x1,%eax
    3424:	eb 05                	jmp    342b <lodepng_mulofl+0x31>
    3426:	b8 00 00 00 00       	mov    $0x0,%eax
}
    342b:	5d                   	pop    %ebp
    342c:	c3                   	ret    

0000342d <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    342d:	55                   	push   %ebp
    342e:	89 e5                	mov    %esp,%ebp
    3430:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3433:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3436:	50                   	push   %eax
    3437:	ff 75 0c             	pushl  0xc(%ebp)
    343a:	ff 75 08             	pushl  0x8(%ebp)
    343d:	e8 98 ff ff ff       	call   33da <lodepng_addofl>
    3442:	83 c4 0c             	add    $0xc,%esp
    3445:	85 c0                	test   %eax,%eax
    3447:	74 07                	je     3450 <lodepng_gtofl+0x23>
    3449:	b8 01 00 00 00       	mov    $0x1,%eax
    344e:	eb 0c                	jmp    345c <lodepng_gtofl+0x2f>
  return d > c;
    3450:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3453:	3b 45 10             	cmp    0x10(%ebp),%eax
    3456:	0f 9f c0             	setg   %al
    3459:	0f b6 c0             	movzbl %al,%eax
}
    345c:	c9                   	leave  
    345d:	c3                   	ret    

0000345e <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    345e:	55                   	push   %ebp
    345f:	89 e5                	mov    %esp,%ebp
    3461:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3464:	8b 45 08             	mov    0x8(%ebp),%eax
    3467:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    346e:	8b 45 08             	mov    0x8(%ebp),%eax
    3471:	8b 50 08             	mov    0x8(%eax),%edx
    3474:	8b 45 08             	mov    0x8(%ebp),%eax
    3477:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    347a:	8b 45 08             	mov    0x8(%ebp),%eax
    347d:	8b 00                	mov    (%eax),%eax
    347f:	83 ec 0c             	sub    $0xc,%esp
    3482:	50                   	push   %eax
    3483:	e8 af fe ff ff       	call   3337 <lodepng_free>
    3488:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    348b:	8b 45 08             	mov    0x8(%ebp),%eax
    348e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3494:	90                   	nop
    3495:	c9                   	leave  
    3496:	c3                   	ret    

00003497 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3497:	55                   	push   %ebp
    3498:	89 e5                	mov    %esp,%ebp
    349a:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    349d:	8b 45 0c             	mov    0xc(%ebp),%eax
    34a0:	c1 e0 02             	shl    $0x2,%eax
    34a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    34a6:	8b 45 08             	mov    0x8(%ebp),%eax
    34a9:	8b 40 08             	mov    0x8(%eax),%eax
    34ac:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    34af:	7d 46                	jge    34f7 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    34b1:	8b 45 08             	mov    0x8(%ebp),%eax
    34b4:	8b 40 08             	mov    0x8(%eax),%eax
    34b7:	d1 f8                	sar    %eax
    34b9:	89 c2                	mov    %eax,%edx
    34bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34be:	01 d0                	add    %edx,%eax
    34c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    34c3:	8b 45 08             	mov    0x8(%ebp),%eax
    34c6:	8b 00                	mov    (%eax),%eax
    34c8:	ff 75 f8             	pushl  -0x8(%ebp)
    34cb:	50                   	push   %eax
    34cc:	e8 5c fe ff ff       	call   332d <lodepng_realloc>
    34d1:	83 c4 08             	add    $0x8,%esp
    34d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    34d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    34db:	74 13                	je     34f0 <uivector_resize+0x59>
      p->allocsize = newsize;
    34dd:	8b 45 08             	mov    0x8(%ebp),%eax
    34e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    34e3:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    34e6:	8b 45 08             	mov    0x8(%ebp),%eax
    34e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34ec:	89 10                	mov    %edx,(%eax)
    34ee:	eb 07                	jmp    34f7 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    34f0:	b8 00 00 00 00       	mov    $0x0,%eax
    34f5:	eb 0e                	jmp    3505 <uivector_resize+0x6e>
  }
  p->size = size;
    34f7:	8b 45 08             	mov    0x8(%ebp),%eax
    34fa:	8b 55 0c             	mov    0xc(%ebp),%edx
    34fd:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3500:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3505:	c9                   	leave  
    3506:	c3                   	ret    

00003507 <uivector_init>:

static void uivector_init(uivector* p) {
    3507:	55                   	push   %ebp
    3508:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    350a:	8b 45 08             	mov    0x8(%ebp),%eax
    350d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    3513:	8b 45 08             	mov    0x8(%ebp),%eax
    3516:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    351d:	8b 45 08             	mov    0x8(%ebp),%eax
    3520:	8b 50 08             	mov    0x8(%eax),%edx
    3523:	8b 45 08             	mov    0x8(%ebp),%eax
    3526:	89 50 04             	mov    %edx,0x4(%eax)
}
    3529:	90                   	nop
    352a:	5d                   	pop    %ebp
    352b:	c3                   	ret    

0000352c <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    352c:	55                   	push   %ebp
    352d:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    352f:	8b 45 08             	mov    0x8(%ebp),%eax
    3532:	8b 40 04             	mov    0x4(%eax),%eax
    3535:	83 c0 01             	add    $0x1,%eax
    3538:	50                   	push   %eax
    3539:	ff 75 08             	pushl  0x8(%ebp)
    353c:	e8 56 ff ff ff       	call   3497 <uivector_resize>
    3541:	83 c4 08             	add    $0x8,%esp
    3544:	85 c0                	test   %eax,%eax
    3546:	75 07                	jne    354f <uivector_push_back+0x23>
    3548:	b8 00 00 00 00       	mov    $0x0,%eax
    354d:	eb 1f                	jmp    356e <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    354f:	8b 45 08             	mov    0x8(%ebp),%eax
    3552:	8b 10                	mov    (%eax),%edx
    3554:	8b 45 08             	mov    0x8(%ebp),%eax
    3557:	8b 40 04             	mov    0x4(%eax),%eax
    355a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    355f:	c1 e0 02             	shl    $0x2,%eax
    3562:	01 c2                	add    %eax,%edx
    3564:	8b 45 0c             	mov    0xc(%ebp),%eax
    3567:	89 02                	mov    %eax,(%edx)
  return 1;
    3569:	b8 01 00 00 00       	mov    $0x1,%eax
}
    356e:	c9                   	leave  
    356f:	c3                   	ret    

00003570 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    3570:	55                   	push   %ebp
    3571:	89 e5                	mov    %esp,%ebp
    3573:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3576:	8b 45 08             	mov    0x8(%ebp),%eax
    3579:	8b 40 08             	mov    0x8(%eax),%eax
    357c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    357f:	7d 46                	jge    35c7 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3581:	8b 45 08             	mov    0x8(%ebp),%eax
    3584:	8b 40 08             	mov    0x8(%eax),%eax
    3587:	d1 f8                	sar    %eax
    3589:	89 c2                	mov    %eax,%edx
    358b:	8b 45 0c             	mov    0xc(%ebp),%eax
    358e:	01 d0                	add    %edx,%eax
    3590:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3593:	8b 45 08             	mov    0x8(%ebp),%eax
    3596:	8b 00                	mov    (%eax),%eax
    3598:	ff 75 fc             	pushl  -0x4(%ebp)
    359b:	50                   	push   %eax
    359c:	e8 8c fd ff ff       	call   332d <lodepng_realloc>
    35a1:	83 c4 08             	add    $0x8,%esp
    35a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    35a7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    35ab:	74 13                	je     35c0 <ucvector_resize+0x50>
      p->allocsize = newsize;
    35ad:	8b 45 08             	mov    0x8(%ebp),%eax
    35b0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    35b3:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    35b6:	8b 45 08             	mov    0x8(%ebp),%eax
    35b9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    35bc:	89 10                	mov    %edx,(%eax)
    35be:	eb 07                	jmp    35c7 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    35c0:	b8 00 00 00 00       	mov    $0x0,%eax
    35c5:	eb 0e                	jmp    35d5 <ucvector_resize+0x65>
  }
  p->size = size;
    35c7:	8b 45 08             	mov    0x8(%ebp),%eax
    35ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    35cd:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    35d0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    35d5:	c9                   	leave  
    35d6:	c3                   	ret    

000035d7 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    35d7:	55                   	push   %ebp
    35d8:	89 e5                	mov    %esp,%ebp
    35da:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    35dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    35e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    35e3:	8b 45 10             	mov    0x10(%ebp),%eax
    35e6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    35e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    35ef:	8b 45 08             	mov    0x8(%ebp),%eax
    35f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35f5:	89 10                	mov    %edx,(%eax)
    35f7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    35fa:	89 50 04             	mov    %edx,0x4(%eax)
    35fd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3600:	89 50 08             	mov    %edx,0x8(%eax)
}
    3603:	8b 45 08             	mov    0x8(%ebp),%eax
    3606:	c9                   	leave  
    3607:	c2 04 00             	ret    $0x4

0000360a <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    360a:	55                   	push   %ebp
    360b:	89 e5                	mov    %esp,%ebp
    360d:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    3610:	8b 45 08             	mov    0x8(%ebp),%eax
    3613:	8b 00                	mov    (%eax),%eax
    3615:	83 ec 0c             	sub    $0xc,%esp
    3618:	50                   	push   %eax
    3619:	e8 19 fd ff ff       	call   3337 <lodepng_free>
    361e:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    3621:	8b 45 08             	mov    0x8(%ebp),%eax
    3624:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    362a:	90                   	nop
    362b:	c9                   	leave  
    362c:	c3                   	ret    

0000362d <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    362d:	55                   	push   %ebp
    362e:	89 e5                	mov    %esp,%ebp
    3630:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3633:	8b 45 0c             	mov    0xc(%ebp),%eax
    3636:	83 c0 01             	add    $0x1,%eax
    3639:	83 ec 0c             	sub    $0xc,%esp
    363c:	50                   	push   %eax
    363d:	e8 d4 fc ff ff       	call   3316 <lodepng_malloc>
    3642:	83 c4 10             	add    $0x10,%esp
    3645:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3648:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    364c:	74 1f                	je     366d <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    364e:	83 ec 04             	sub    $0x4,%esp
    3651:	ff 75 0c             	pushl  0xc(%ebp)
    3654:	ff 75 08             	pushl  0x8(%ebp)
    3657:	ff 75 f4             	pushl  -0xc(%ebp)
    365a:	e8 f5 fc ff ff       	call   3354 <lodepng_memcpy>
    365f:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3662:	8b 55 0c             	mov    0xc(%ebp),%edx
    3665:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3668:	01 d0                	add    %edx,%eax
    366a:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    366d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3670:	c9                   	leave  
    3671:	c3                   	ret    

00003672 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3672:	55                   	push   %ebp
    3673:	89 e5                	mov    %esp,%ebp
    3675:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3678:	ff 75 08             	pushl  0x8(%ebp)
    367b:	e8 32 fd ff ff       	call   33b2 <lodepng_strlen>
    3680:	83 c4 04             	add    $0x4,%esp
    3683:	83 ec 08             	sub    $0x8,%esp
    3686:	50                   	push   %eax
    3687:	ff 75 08             	pushl  0x8(%ebp)
    368a:	e8 9e ff ff ff       	call   362d <alloc_string_sized>
    368f:	83 c4 10             	add    $0x10,%esp
}
    3692:	c9                   	leave  
    3693:	c3                   	ret    

00003694 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3694:	55                   	push   %ebp
    3695:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3697:	8b 45 08             	mov    0x8(%ebp),%eax
    369a:	0f b6 00             	movzbl (%eax),%eax
    369d:	0f b6 c0             	movzbl %al,%eax
    36a0:	c1 e0 18             	shl    $0x18,%eax
    36a3:	89 c2                	mov    %eax,%edx
    36a5:	8b 45 08             	mov    0x8(%ebp),%eax
    36a8:	83 c0 01             	add    $0x1,%eax
    36ab:	0f b6 00             	movzbl (%eax),%eax
    36ae:	0f b6 c0             	movzbl %al,%eax
    36b1:	c1 e0 10             	shl    $0x10,%eax
    36b4:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36b6:	8b 45 08             	mov    0x8(%ebp),%eax
    36b9:	83 c0 02             	add    $0x2,%eax
    36bc:	0f b6 00             	movzbl (%eax),%eax
    36bf:	0f b6 c0             	movzbl %al,%eax
    36c2:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36c5:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36c7:	8b 45 08             	mov    0x8(%ebp),%eax
    36ca:	83 c0 03             	add    $0x3,%eax
    36cd:	0f b6 00             	movzbl (%eax),%eax
    36d0:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36d3:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    36d5:	5d                   	pop    %ebp
    36d6:	c3                   	ret    

000036d7 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    36d7:	55                   	push   %ebp
    36d8:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    36da:	8b 45 0c             	mov    0xc(%ebp),%eax
    36dd:	c1 e8 18             	shr    $0x18,%eax
    36e0:	89 c2                	mov    %eax,%edx
    36e2:	8b 45 08             	mov    0x8(%ebp),%eax
    36e5:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    36e7:	8b 45 08             	mov    0x8(%ebp),%eax
    36ea:	83 c0 01             	add    $0x1,%eax
    36ed:	8b 55 0c             	mov    0xc(%ebp),%edx
    36f0:	c1 ea 10             	shr    $0x10,%edx
    36f3:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    36f5:	8b 45 08             	mov    0x8(%ebp),%eax
    36f8:	83 c0 02             	add    $0x2,%eax
    36fb:	8b 55 0c             	mov    0xc(%ebp),%edx
    36fe:	c1 ea 08             	shr    $0x8,%edx
    3701:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    3703:	8b 45 08             	mov    0x8(%ebp),%eax
    3706:	83 c0 03             	add    $0x3,%eax
    3709:	8b 55 0c             	mov    0xc(%ebp),%edx
    370c:	88 10                	mov    %dl,(%eax)
}
    370e:	90                   	nop
    370f:	5d                   	pop    %ebp
    3710:	c3                   	ret    

00003711 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    3711:	55                   	push   %ebp
    3712:	89 e5                	mov    %esp,%ebp
    3714:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3717:	83 ec 08             	sub    $0x8,%esp
    371a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    371d:	50                   	push   %eax
    371e:	ff 75 08             	pushl  0x8(%ebp)
    3721:	e8 b7 ca ff ff       	call   1dd <stat>
    3726:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3729:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    372c:	c9                   	leave  
    372d:	c3                   	ret    

0000372e <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    372e:	55                   	push   %ebp
    372f:	89 e5                	mov    %esp,%ebp
    3731:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3734:	83 ec 08             	sub    $0x8,%esp
    3737:	6a 00                	push   $0x0
    3739:	ff 75 10             	pushl  0x10(%ebp)
    373c:	e8 bb cb ff ff       	call   2fc <open>
    3741:	83 c4 10             	add    $0x10,%esp
    3744:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3747:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    374b:	79 07                	jns    3754 <lodepng_buffer_file+0x26>
  {
      return -1;
    374d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3752:	eb 19                	jmp    376d <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3754:	83 ec 04             	sub    $0x4,%esp
    3757:	ff 75 0c             	pushl  0xc(%ebp)
    375a:	ff 75 08             	pushl  0x8(%ebp)
    375d:	ff 75 f4             	pushl  -0xc(%ebp)
    3760:	e8 6f cb ff ff       	call   2d4 <read>
    3765:	83 c4 10             	add    $0x10,%esp
  return 0;
    3768:	b8 00 00 00 00       	mov    $0x0,%eax
}
    376d:	c9                   	leave  
    376e:	c3                   	ret    

0000376f <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    376f:	55                   	push   %ebp
    3770:	89 e5                	mov    %esp,%ebp
    3772:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3775:	83 ec 0c             	sub    $0xc,%esp
    3778:	ff 75 10             	pushl  0x10(%ebp)
    377b:	e8 91 ff ff ff       	call   3711 <lodepng_filesize>
    3780:	83 c4 10             	add    $0x10,%esp
    3783:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3786:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    378a:	79 07                	jns    3793 <lodepng_load_file+0x24>
    378c:	b8 4e 00 00 00       	mov    $0x4e,%eax
    3791:	eb 4a                	jmp    37dd <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    3793:	8b 45 0c             	mov    0xc(%ebp),%eax
    3796:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3799:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    379b:	83 ec 0c             	sub    $0xc,%esp
    379e:	ff 75 f4             	pushl  -0xc(%ebp)
    37a1:	e8 70 fb ff ff       	call   3316 <lodepng_malloc>
    37a6:	83 c4 10             	add    $0x10,%esp
    37a9:	89 c2                	mov    %eax,%edx
    37ab:	8b 45 08             	mov    0x8(%ebp),%eax
    37ae:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    37b0:	8b 45 08             	mov    0x8(%ebp),%eax
    37b3:	8b 00                	mov    (%eax),%eax
    37b5:	85 c0                	test   %eax,%eax
    37b7:	75 0d                	jne    37c6 <lodepng_load_file+0x57>
    37b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37bd:	7e 07                	jle    37c6 <lodepng_load_file+0x57>
    37bf:	b8 53 00 00 00       	mov    $0x53,%eax
    37c4:	eb 17                	jmp    37dd <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    37c6:	8b 45 08             	mov    0x8(%ebp),%eax
    37c9:	8b 00                	mov    (%eax),%eax
    37cb:	83 ec 04             	sub    $0x4,%esp
    37ce:	ff 75 10             	pushl  0x10(%ebp)
    37d1:	ff 75 f4             	pushl  -0xc(%ebp)
    37d4:	50                   	push   %eax
    37d5:	e8 54 ff ff ff       	call   372e <lodepng_buffer_file>
    37da:	83 c4 10             	add    $0x10,%esp
}
    37dd:	c9                   	leave  
    37de:	c3                   	ret    

000037df <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    37df:	55                   	push   %ebp
    37e0:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    37e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    37e7:	5d                   	pop    %ebp
    37e8:	c3                   	ret    

000037e9 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    37e9:	55                   	push   %ebp
    37ea:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    37ec:	8b 45 08             	mov    0x8(%ebp),%eax
    37ef:	8b 55 0c             	mov    0xc(%ebp),%edx
    37f2:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    37f4:	8b 45 08             	mov    0x8(%ebp),%eax
    37f7:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    37fb:	90                   	nop
    37fc:	5d                   	pop    %ebp
    37fd:	c3                   	ret    

000037fe <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    37fe:	55                   	push   %ebp
    37ff:	89 e5                	mov    %esp,%ebp
    3801:	56                   	push   %esi
    3802:	53                   	push   %ebx
    3803:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3806:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    380a:	0f 85 aa 00 00 00    	jne    38ba <writeBits+0xbc>
    WRITEBIT(writer, value);
    3810:	8b 45 08             	mov    0x8(%ebp),%eax
    3813:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3817:	0f b6 c0             	movzbl %al,%eax
    381a:	83 e0 07             	and    $0x7,%eax
    381d:	85 c0                	test   %eax,%eax
    381f:	75 39                	jne    385a <writeBits+0x5c>
    3821:	8b 45 08             	mov    0x8(%ebp),%eax
    3824:	8b 00                	mov    (%eax),%eax
    3826:	8b 40 04             	mov    0x4(%eax),%eax
    3829:	8d 50 01             	lea    0x1(%eax),%edx
    382c:	8b 45 08             	mov    0x8(%ebp),%eax
    382f:	8b 00                	mov    (%eax),%eax
    3831:	52                   	push   %edx
    3832:	50                   	push   %eax
    3833:	e8 38 fd ff ff       	call   3570 <ucvector_resize>
    3838:	83 c4 08             	add    $0x8,%esp
    383b:	85 c0                	test   %eax,%eax
    383d:	0f 84 44 01 00 00    	je     3987 <writeBits+0x189>
    3843:	8b 45 08             	mov    0x8(%ebp),%eax
    3846:	8b 00                	mov    (%eax),%eax
    3848:	8b 10                	mov    (%eax),%edx
    384a:	8b 45 08             	mov    0x8(%ebp),%eax
    384d:	8b 00                	mov    (%eax),%eax
    384f:	8b 40 04             	mov    0x4(%eax),%eax
    3852:	83 e8 01             	sub    $0x1,%eax
    3855:	01 d0                	add    %edx,%eax
    3857:	c6 00 00             	movb   $0x0,(%eax)
    385a:	8b 45 08             	mov    0x8(%ebp),%eax
    385d:	8b 00                	mov    (%eax),%eax
    385f:	8b 10                	mov    (%eax),%edx
    3861:	8b 45 08             	mov    0x8(%ebp),%eax
    3864:	8b 00                	mov    (%eax),%eax
    3866:	8b 40 04             	mov    0x4(%eax),%eax
    3869:	83 e8 01             	sub    $0x1,%eax
    386c:	01 c2                	add    %eax,%edx
    386e:	8b 45 08             	mov    0x8(%ebp),%eax
    3871:	8b 00                	mov    (%eax),%eax
    3873:	8b 08                	mov    (%eax),%ecx
    3875:	8b 45 08             	mov    0x8(%ebp),%eax
    3878:	8b 00                	mov    (%eax),%eax
    387a:	8b 40 04             	mov    0x4(%eax),%eax
    387d:	83 e8 01             	sub    $0x1,%eax
    3880:	01 c8                	add    %ecx,%eax
    3882:	0f b6 00             	movzbl (%eax),%eax
    3885:	88 45 e7             	mov    %al,-0x19(%ebp)
    3888:	8b 45 08             	mov    0x8(%ebp),%eax
    388b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    388f:	0f b6 c0             	movzbl %al,%eax
    3892:	83 e0 07             	and    $0x7,%eax
    3895:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3898:	89 de                	mov    %ebx,%esi
    389a:	89 c1                	mov    %eax,%ecx
    389c:	d3 e6                	shl    %cl,%esi
    389e:	89 f0                	mov    %esi,%eax
    38a0:	0a 45 e7             	or     -0x19(%ebp),%al
    38a3:	88 02                	mov    %al,(%edx)
    38a5:	8b 45 08             	mov    0x8(%ebp),%eax
    38a8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38ac:	8d 50 01             	lea    0x1(%eax),%edx
    38af:	8b 45 08             	mov    0x8(%ebp),%eax
    38b2:	88 50 04             	mov    %dl,0x4(%eax)
    38b5:	e9 d1 00 00 00       	jmp    398b <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    38ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    38c1:	e9 b3 00 00 00       	jmp    3979 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    38c6:	8b 45 08             	mov    0x8(%ebp),%eax
    38c9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38cd:	0f b6 c0             	movzbl %al,%eax
    38d0:	83 e0 07             	and    $0x7,%eax
    38d3:	85 c0                	test   %eax,%eax
    38d5:	75 39                	jne    3910 <writeBits+0x112>
    38d7:	8b 45 08             	mov    0x8(%ebp),%eax
    38da:	8b 00                	mov    (%eax),%eax
    38dc:	8b 40 04             	mov    0x4(%eax),%eax
    38df:	8d 50 01             	lea    0x1(%eax),%edx
    38e2:	8b 45 08             	mov    0x8(%ebp),%eax
    38e5:	8b 00                	mov    (%eax),%eax
    38e7:	52                   	push   %edx
    38e8:	50                   	push   %eax
    38e9:	e8 82 fc ff ff       	call   3570 <ucvector_resize>
    38ee:	83 c4 08             	add    $0x8,%esp
    38f1:	85 c0                	test   %eax,%eax
    38f3:	0f 84 91 00 00 00    	je     398a <writeBits+0x18c>
    38f9:	8b 45 08             	mov    0x8(%ebp),%eax
    38fc:	8b 00                	mov    (%eax),%eax
    38fe:	8b 10                	mov    (%eax),%edx
    3900:	8b 45 08             	mov    0x8(%ebp),%eax
    3903:	8b 00                	mov    (%eax),%eax
    3905:	8b 40 04             	mov    0x4(%eax),%eax
    3908:	83 e8 01             	sub    $0x1,%eax
    390b:	01 d0                	add    %edx,%eax
    390d:	c6 00 00             	movb   $0x0,(%eax)
    3910:	8b 45 08             	mov    0x8(%ebp),%eax
    3913:	8b 00                	mov    (%eax),%eax
    3915:	8b 10                	mov    (%eax),%edx
    3917:	8b 45 08             	mov    0x8(%ebp),%eax
    391a:	8b 00                	mov    (%eax),%eax
    391c:	8b 40 04             	mov    0x4(%eax),%eax
    391f:	83 e8 01             	sub    $0x1,%eax
    3922:	01 c2                	add    %eax,%edx
    3924:	8b 45 08             	mov    0x8(%ebp),%eax
    3927:	8b 00                	mov    (%eax),%eax
    3929:	8b 08                	mov    (%eax),%ecx
    392b:	8b 45 08             	mov    0x8(%ebp),%eax
    392e:	8b 00                	mov    (%eax),%eax
    3930:	8b 40 04             	mov    0x4(%eax),%eax
    3933:	83 e8 01             	sub    $0x1,%eax
    3936:	01 c8                	add    %ecx,%eax
    3938:	0f b6 00             	movzbl (%eax),%eax
    393b:	89 c6                	mov    %eax,%esi
    393d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3940:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3943:	89 c1                	mov    %eax,%ecx
    3945:	d3 eb                	shr    %cl,%ebx
    3947:	89 d8                	mov    %ebx,%eax
    3949:	83 e0 01             	and    $0x1,%eax
    394c:	89 c3                	mov    %eax,%ebx
    394e:	8b 45 08             	mov    0x8(%ebp),%eax
    3951:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3955:	0f b6 c0             	movzbl %al,%eax
    3958:	83 e0 07             	and    $0x7,%eax
    395b:	89 c1                	mov    %eax,%ecx
    395d:	d3 e3                	shl    %cl,%ebx
    395f:	89 d8                	mov    %ebx,%eax
    3961:	09 f0                	or     %esi,%eax
    3963:	88 02                	mov    %al,(%edx)
    3965:	8b 45 08             	mov    0x8(%ebp),%eax
    3968:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    396c:	8d 50 01             	lea    0x1(%eax),%edx
    396f:	8b 45 08             	mov    0x8(%ebp),%eax
    3972:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3975:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3979:	8b 45 f4             	mov    -0xc(%ebp),%eax
    397c:	3b 45 10             	cmp    0x10(%ebp),%eax
    397f:	0f 85 41 ff ff ff    	jne    38c6 <writeBits+0xc8>
    3985:	eb 04                	jmp    398b <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3987:	90                   	nop
    3988:	eb 01                	jmp    398b <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    398a:	90                   	nop
    }
  }
}
    398b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    398e:	5b                   	pop    %ebx
    398f:	5e                   	pop    %esi
    3990:	5d                   	pop    %ebp
    3991:	c3                   	ret    

00003992 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3992:	55                   	push   %ebp
    3993:	89 e5                	mov    %esp,%ebp
    3995:	56                   	push   %esi
    3996:	53                   	push   %ebx
    3997:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    399a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    39a1:	e9 bd 00 00 00       	jmp    3a63 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    39a6:	8b 45 08             	mov    0x8(%ebp),%eax
    39a9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39ad:	0f b6 c0             	movzbl %al,%eax
    39b0:	83 e0 07             	and    $0x7,%eax
    39b3:	85 c0                	test   %eax,%eax
    39b5:	75 39                	jne    39f0 <writeBitsReversed+0x5e>
    39b7:	8b 45 08             	mov    0x8(%ebp),%eax
    39ba:	8b 00                	mov    (%eax),%eax
    39bc:	8b 40 04             	mov    0x4(%eax),%eax
    39bf:	8d 50 01             	lea    0x1(%eax),%edx
    39c2:	8b 45 08             	mov    0x8(%ebp),%eax
    39c5:	8b 00                	mov    (%eax),%eax
    39c7:	52                   	push   %edx
    39c8:	50                   	push   %eax
    39c9:	e8 a2 fb ff ff       	call   3570 <ucvector_resize>
    39ce:	83 c4 08             	add    $0x8,%esp
    39d1:	85 c0                	test   %eax,%eax
    39d3:	0f 84 98 00 00 00    	je     3a71 <writeBitsReversed+0xdf>
    39d9:	8b 45 08             	mov    0x8(%ebp),%eax
    39dc:	8b 00                	mov    (%eax),%eax
    39de:	8b 10                	mov    (%eax),%edx
    39e0:	8b 45 08             	mov    0x8(%ebp),%eax
    39e3:	8b 00                	mov    (%eax),%eax
    39e5:	8b 40 04             	mov    0x4(%eax),%eax
    39e8:	83 e8 01             	sub    $0x1,%eax
    39eb:	01 d0                	add    %edx,%eax
    39ed:	c6 00 00             	movb   $0x0,(%eax)
    39f0:	8b 45 08             	mov    0x8(%ebp),%eax
    39f3:	8b 00                	mov    (%eax),%eax
    39f5:	8b 10                	mov    (%eax),%edx
    39f7:	8b 45 08             	mov    0x8(%ebp),%eax
    39fa:	8b 00                	mov    (%eax),%eax
    39fc:	8b 40 04             	mov    0x4(%eax),%eax
    39ff:	83 e8 01             	sub    $0x1,%eax
    3a02:	01 c2                	add    %eax,%edx
    3a04:	8b 45 08             	mov    0x8(%ebp),%eax
    3a07:	8b 00                	mov    (%eax),%eax
    3a09:	8b 08                	mov    (%eax),%ecx
    3a0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3a0e:	8b 00                	mov    (%eax),%eax
    3a10:	8b 40 04             	mov    0x4(%eax),%eax
    3a13:	83 e8 01             	sub    $0x1,%eax
    3a16:	01 c8                	add    %ecx,%eax
    3a18:	0f b6 00             	movzbl (%eax),%eax
    3a1b:	89 c6                	mov    %eax,%esi
    3a1d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3a20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a23:	29 c1                	sub    %eax,%ecx
    3a25:	89 c8                	mov    %ecx,%eax
    3a27:	83 e8 01             	sub    $0x1,%eax
    3a2a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3a2d:	89 c1                	mov    %eax,%ecx
    3a2f:	d3 eb                	shr    %cl,%ebx
    3a31:	89 d8                	mov    %ebx,%eax
    3a33:	83 e0 01             	and    $0x1,%eax
    3a36:	89 c3                	mov    %eax,%ebx
    3a38:	8b 45 08             	mov    0x8(%ebp),%eax
    3a3b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a3f:	0f b6 c0             	movzbl %al,%eax
    3a42:	83 e0 07             	and    $0x7,%eax
    3a45:	89 c1                	mov    %eax,%ecx
    3a47:	d3 e3                	shl    %cl,%ebx
    3a49:	89 d8                	mov    %ebx,%eax
    3a4b:	09 f0                	or     %esi,%eax
    3a4d:	88 02                	mov    %al,(%edx)
    3a4f:	8b 45 08             	mov    0x8(%ebp),%eax
    3a52:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a56:	8d 50 01             	lea    0x1(%eax),%edx
    3a59:	8b 45 08             	mov    0x8(%ebp),%eax
    3a5c:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a5f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a63:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a66:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a69:	0f 85 37 ff ff ff    	jne    39a6 <writeBitsReversed+0x14>
    3a6f:	eb 01                	jmp    3a72 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a71:	90                   	nop
  }
}
    3a72:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a75:	5b                   	pop    %ebx
    3a76:	5e                   	pop    %esi
    3a77:	5d                   	pop    %ebp
    3a78:	c3                   	ret    

00003a79 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3a79:	55                   	push   %ebp
    3a7a:	89 e5                	mov    %esp,%ebp
    3a7c:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3a7f:	8b 45 08             	mov    0x8(%ebp),%eax
    3a82:	8b 55 0c             	mov    0xc(%ebp),%edx
    3a85:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3a87:	8b 45 08             	mov    0x8(%ebp),%eax
    3a8a:	8b 55 10             	mov    0x10(%ebp),%edx
    3a8d:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3a90:	8b 45 08             	mov    0x8(%ebp),%eax
    3a93:	83 c0 08             	add    $0x8,%eax
    3a96:	50                   	push   %eax
    3a97:	6a 08                	push   $0x8
    3a99:	ff 75 10             	pushl  0x10(%ebp)
    3a9c:	e8 59 f9 ff ff       	call   33fa <lodepng_mulofl>
    3aa1:	83 c4 0c             	add    $0xc,%esp
    3aa4:	85 c0                	test   %eax,%eax
    3aa6:	74 07                	je     3aaf <LodePNGBitReader_init+0x36>
    3aa8:	b8 69 00 00 00       	mov    $0x69,%eax
    3aad:	eb 39                	jmp    3ae8 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ab2:	8b 40 08             	mov    0x8(%eax),%eax
    3ab5:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3ab8:	52                   	push   %edx
    3ab9:	6a 40                	push   $0x40
    3abb:	50                   	push   %eax
    3abc:	e8 19 f9 ff ff       	call   33da <lodepng_addofl>
    3ac1:	83 c4 0c             	add    $0xc,%esp
    3ac4:	85 c0                	test   %eax,%eax
    3ac6:	74 07                	je     3acf <LodePNGBitReader_init+0x56>
    3ac8:	b8 69 00 00 00       	mov    $0x69,%eax
    3acd:	eb 19                	jmp    3ae8 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3acf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ad2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3ad9:	8b 45 08             	mov    0x8(%ebp),%eax
    3adc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3ae3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3ae8:	c9                   	leave  
    3ae9:	c3                   	ret    

00003aea <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3aea:	55                   	push   %ebp
    3aeb:	89 e5                	mov    %esp,%ebp
    3aed:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3af0:	8b 45 08             	mov    0x8(%ebp),%eax
    3af3:	8b 40 0c             	mov    0xc(%eax),%eax
    3af6:	c1 f8 03             	sar    $0x3,%eax
    3af9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3afc:	8b 45 08             	mov    0x8(%ebp),%eax
    3aff:	8b 40 04             	mov    0x4(%eax),%eax
    3b02:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3b05:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b08:	8d 50 01             	lea    0x1(%eax),%edx
    3b0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b0e:	39 c2                	cmp    %eax,%edx
    3b10:	73 4e                	jae    3b60 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3b12:	8b 45 08             	mov    0x8(%ebp),%eax
    3b15:	8b 10                	mov    (%eax),%edx
    3b17:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b1a:	01 d0                	add    %edx,%eax
    3b1c:	0f b6 00             	movzbl (%eax),%eax
    3b1f:	0f b6 d0             	movzbl %al,%edx
    3b22:	8b 45 08             	mov    0x8(%ebp),%eax
    3b25:	8b 00                	mov    (%eax),%eax
    3b27:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3b2a:	83 c1 01             	add    $0x1,%ecx
    3b2d:	01 c8                	add    %ecx,%eax
    3b2f:	0f b6 00             	movzbl (%eax),%eax
    3b32:	0f b6 c0             	movzbl %al,%eax
    3b35:	c1 e0 08             	shl    $0x8,%eax
    3b38:	09 c2                	or     %eax,%edx
    3b3a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b3d:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b40:	8b 45 08             	mov    0x8(%ebp),%eax
    3b43:	8b 50 10             	mov    0x10(%eax),%edx
    3b46:	8b 45 08             	mov    0x8(%ebp),%eax
    3b49:	8b 40 0c             	mov    0xc(%eax),%eax
    3b4c:	83 e0 07             	and    $0x7,%eax
    3b4f:	89 c1                	mov    %eax,%ecx
    3b51:	d3 ea                	shr    %cl,%edx
    3b53:	8b 45 08             	mov    0x8(%ebp),%eax
    3b56:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3b59:	b8 01 00 00 00       	mov    $0x1,%eax
    3b5e:	eb 64                	jmp    3bc4 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3b60:	8b 45 08             	mov    0x8(%ebp),%eax
    3b63:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3b6a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3b6d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b70:	39 c2                	cmp    %eax,%edx
    3b72:	73 1e                	jae    3b92 <ensureBits9+0xa8>
    3b74:	8b 45 08             	mov    0x8(%ebp),%eax
    3b77:	8b 50 10             	mov    0x10(%eax),%edx
    3b7a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b7d:	8b 08                	mov    (%eax),%ecx
    3b7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b82:	01 c8                	add    %ecx,%eax
    3b84:	0f b6 00             	movzbl (%eax),%eax
    3b87:	0f b6 c0             	movzbl %al,%eax
    3b8a:	09 c2                	or     %eax,%edx
    3b8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b8f:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b92:	8b 45 08             	mov    0x8(%ebp),%eax
    3b95:	8b 50 10             	mov    0x10(%eax),%edx
    3b98:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9b:	8b 40 0c             	mov    0xc(%eax),%eax
    3b9e:	83 e0 07             	and    $0x7,%eax
    3ba1:	89 c1                	mov    %eax,%ecx
    3ba3:	d3 ea                	shr    %cl,%edx
    3ba5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba8:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3bab:	8b 45 08             	mov    0x8(%ebp),%eax
    3bae:	8b 50 0c             	mov    0xc(%eax),%edx
    3bb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    3bb4:	01 c2                	add    %eax,%edx
    3bb6:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb9:	8b 40 08             	mov    0x8(%eax),%eax
    3bbc:	39 c2                	cmp    %eax,%edx
    3bbe:	0f 9e c0             	setle  %al
    3bc1:	0f b6 c0             	movzbl %al,%eax
  }
}
    3bc4:	c9                   	leave  
    3bc5:	c3                   	ret    

00003bc6 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3bc6:	55                   	push   %ebp
    3bc7:	89 e5                	mov    %esp,%ebp
    3bc9:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3bcc:	8b 45 08             	mov    0x8(%ebp),%eax
    3bcf:	8b 40 0c             	mov    0xc(%eax),%eax
    3bd2:	c1 f8 03             	sar    $0x3,%eax
    3bd5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3bd8:	8b 45 08             	mov    0x8(%ebp),%eax
    3bdb:	8b 40 04             	mov    0x4(%eax),%eax
    3bde:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3be1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3be4:	8d 50 02             	lea    0x2(%eax),%edx
    3be7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bea:	39 c2                	cmp    %eax,%edx
    3bec:	73 6d                	jae    3c5b <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3bee:	8b 45 08             	mov    0x8(%ebp),%eax
    3bf1:	8b 10                	mov    (%eax),%edx
    3bf3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bf6:	01 d0                	add    %edx,%eax
    3bf8:	0f b6 00             	movzbl (%eax),%eax
    3bfb:	0f b6 d0             	movzbl %al,%edx
    3bfe:	8b 45 08             	mov    0x8(%ebp),%eax
    3c01:	8b 00                	mov    (%eax),%eax
    3c03:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3c06:	83 c1 01             	add    $0x1,%ecx
    3c09:	01 c8                	add    %ecx,%eax
    3c0b:	0f b6 00             	movzbl (%eax),%eax
    3c0e:	0f b6 c0             	movzbl %al,%eax
    3c11:	c1 e0 08             	shl    $0x8,%eax
    3c14:	89 d1                	mov    %edx,%ecx
    3c16:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3c18:	8b 45 08             	mov    0x8(%ebp),%eax
    3c1b:	8b 00                	mov    (%eax),%eax
    3c1d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c20:	83 c2 02             	add    $0x2,%edx
    3c23:	01 d0                	add    %edx,%eax
    3c25:	0f b6 00             	movzbl (%eax),%eax
    3c28:	0f b6 c0             	movzbl %al,%eax
    3c2b:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3c2e:	09 c1                	or     %eax,%ecx
    3c30:	89 ca                	mov    %ecx,%edx
    3c32:	8b 45 08             	mov    0x8(%ebp),%eax
    3c35:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3c38:	8b 45 08             	mov    0x8(%ebp),%eax
    3c3b:	8b 50 10             	mov    0x10(%eax),%edx
    3c3e:	8b 45 08             	mov    0x8(%ebp),%eax
    3c41:	8b 40 0c             	mov    0xc(%eax),%eax
    3c44:	83 e0 07             	and    $0x7,%eax
    3c47:	89 c1                	mov    %eax,%ecx
    3c49:	d3 ea                	shr    %cl,%edx
    3c4b:	8b 45 08             	mov    0x8(%ebp),%eax
    3c4e:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3c51:	b8 01 00 00 00       	mov    $0x1,%eax
    3c56:	e9 95 00 00 00       	jmp    3cf0 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3c5b:	8b 45 08             	mov    0x8(%ebp),%eax
    3c5e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c65:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c68:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c6b:	39 c2                	cmp    %eax,%edx
    3c6d:	73 1e                	jae    3c8d <ensureBits17+0xc7>
    3c6f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c72:	8b 50 10             	mov    0x10(%eax),%edx
    3c75:	8b 45 08             	mov    0x8(%ebp),%eax
    3c78:	8b 08                	mov    (%eax),%ecx
    3c7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c7d:	01 c8                	add    %ecx,%eax
    3c7f:	0f b6 00             	movzbl (%eax),%eax
    3c82:	0f b6 c0             	movzbl %al,%eax
    3c85:	09 c2                	or     %eax,%edx
    3c87:	8b 45 08             	mov    0x8(%ebp),%eax
    3c8a:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3c8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c90:	8d 50 01             	lea    0x1(%eax),%edx
    3c93:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c96:	39 c2                	cmp    %eax,%edx
    3c98:	73 24                	jae    3cbe <ensureBits17+0xf8>
    3c9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9d:	8b 50 10             	mov    0x10(%eax),%edx
    3ca0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca3:	8b 00                	mov    (%eax),%eax
    3ca5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3ca8:	83 c1 01             	add    $0x1,%ecx
    3cab:	01 c8                	add    %ecx,%eax
    3cad:	0f b6 00             	movzbl (%eax),%eax
    3cb0:	0f b6 c0             	movzbl %al,%eax
    3cb3:	c1 e0 08             	shl    $0x8,%eax
    3cb6:	09 c2                	or     %eax,%edx
    3cb8:	8b 45 08             	mov    0x8(%ebp),%eax
    3cbb:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3cbe:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc1:	8b 50 10             	mov    0x10(%eax),%edx
    3cc4:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc7:	8b 40 0c             	mov    0xc(%eax),%eax
    3cca:	83 e0 07             	and    $0x7,%eax
    3ccd:	89 c1                	mov    %eax,%ecx
    3ccf:	d3 ea                	shr    %cl,%edx
    3cd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd4:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3cd7:	8b 45 08             	mov    0x8(%ebp),%eax
    3cda:	8b 50 0c             	mov    0xc(%eax),%edx
    3cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ce0:	01 c2                	add    %eax,%edx
    3ce2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce5:	8b 40 08             	mov    0x8(%eax),%eax
    3ce8:	39 c2                	cmp    %eax,%edx
    3cea:	0f 9e c0             	setle  %al
    3ced:	0f b6 c0             	movzbl %al,%eax
  }
}
    3cf0:	c9                   	leave  
    3cf1:	c3                   	ret    

00003cf2 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3cf2:	55                   	push   %ebp
    3cf3:	89 e5                	mov    %esp,%ebp
    3cf5:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3cf8:	8b 45 08             	mov    0x8(%ebp),%eax
    3cfb:	8b 40 0c             	mov    0xc(%eax),%eax
    3cfe:	c1 f8 03             	sar    $0x3,%eax
    3d01:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3d04:	8b 45 08             	mov    0x8(%ebp),%eax
    3d07:	8b 40 04             	mov    0x4(%eax),%eax
    3d0a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3d0d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d10:	8d 50 03             	lea    0x3(%eax),%edx
    3d13:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d16:	39 c2                	cmp    %eax,%edx
    3d18:	0f 83 85 00 00 00    	jae    3da3 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d1e:	8b 45 08             	mov    0x8(%ebp),%eax
    3d21:	8b 10                	mov    (%eax),%edx
    3d23:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d26:	01 d0                	add    %edx,%eax
    3d28:	0f b6 00             	movzbl (%eax),%eax
    3d2b:	0f b6 d0             	movzbl %al,%edx
    3d2e:	8b 45 08             	mov    0x8(%ebp),%eax
    3d31:	8b 00                	mov    (%eax),%eax
    3d33:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d36:	83 c1 01             	add    $0x1,%ecx
    3d39:	01 c8                	add    %ecx,%eax
    3d3b:	0f b6 00             	movzbl (%eax),%eax
    3d3e:	0f b6 c0             	movzbl %al,%eax
    3d41:	c1 e0 08             	shl    $0x8,%eax
    3d44:	89 d1                	mov    %edx,%ecx
    3d46:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d48:	8b 45 08             	mov    0x8(%ebp),%eax
    3d4b:	8b 00                	mov    (%eax),%eax
    3d4d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d50:	83 c2 02             	add    $0x2,%edx
    3d53:	01 d0                	add    %edx,%eax
    3d55:	0f b6 00             	movzbl (%eax),%eax
    3d58:	0f b6 c0             	movzbl %al,%eax
    3d5b:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d5e:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d60:	8b 45 08             	mov    0x8(%ebp),%eax
    3d63:	8b 00                	mov    (%eax),%eax
    3d65:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d68:	83 c2 03             	add    $0x3,%edx
    3d6b:	01 d0                	add    %edx,%eax
    3d6d:	0f b6 00             	movzbl (%eax),%eax
    3d70:	0f b6 c0             	movzbl %al,%eax
    3d73:	c1 e0 18             	shl    $0x18,%eax
    3d76:	09 c1                	or     %eax,%ecx
    3d78:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d7a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d7d:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3d80:	8b 45 08             	mov    0x8(%ebp),%eax
    3d83:	8b 50 10             	mov    0x10(%eax),%edx
    3d86:	8b 45 08             	mov    0x8(%ebp),%eax
    3d89:	8b 40 0c             	mov    0xc(%eax),%eax
    3d8c:	83 e0 07             	and    $0x7,%eax
    3d8f:	89 c1                	mov    %eax,%ecx
    3d91:	d3 ea                	shr    %cl,%edx
    3d93:	8b 45 08             	mov    0x8(%ebp),%eax
    3d96:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3d99:	b8 01 00 00 00       	mov    $0x1,%eax
    3d9e:	e9 c6 00 00 00       	jmp    3e69 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3da3:	8b 45 08             	mov    0x8(%ebp),%eax
    3da6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3dad:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3db0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3db3:	39 c2                	cmp    %eax,%edx
    3db5:	73 1e                	jae    3dd5 <ensureBits25+0xe3>
    3db7:	8b 45 08             	mov    0x8(%ebp),%eax
    3dba:	8b 50 10             	mov    0x10(%eax),%edx
    3dbd:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc0:	8b 08                	mov    (%eax),%ecx
    3dc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dc5:	01 c8                	add    %ecx,%eax
    3dc7:	0f b6 00             	movzbl (%eax),%eax
    3dca:	0f b6 c0             	movzbl %al,%eax
    3dcd:	09 c2                	or     %eax,%edx
    3dcf:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd2:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3dd5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dd8:	8d 50 01             	lea    0x1(%eax),%edx
    3ddb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dde:	39 c2                	cmp    %eax,%edx
    3de0:	73 24                	jae    3e06 <ensureBits25+0x114>
    3de2:	8b 45 08             	mov    0x8(%ebp),%eax
    3de5:	8b 50 10             	mov    0x10(%eax),%edx
    3de8:	8b 45 08             	mov    0x8(%ebp),%eax
    3deb:	8b 00                	mov    (%eax),%eax
    3ded:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3df0:	83 c1 01             	add    $0x1,%ecx
    3df3:	01 c8                	add    %ecx,%eax
    3df5:	0f b6 00             	movzbl (%eax),%eax
    3df8:	0f b6 c0             	movzbl %al,%eax
    3dfb:	c1 e0 08             	shl    $0x8,%eax
    3dfe:	09 c2                	or     %eax,%edx
    3e00:	8b 45 08             	mov    0x8(%ebp),%eax
    3e03:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3e06:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e09:	8d 50 02             	lea    0x2(%eax),%edx
    3e0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e0f:	39 c2                	cmp    %eax,%edx
    3e11:	73 24                	jae    3e37 <ensureBits25+0x145>
    3e13:	8b 45 08             	mov    0x8(%ebp),%eax
    3e16:	8b 50 10             	mov    0x10(%eax),%edx
    3e19:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1c:	8b 00                	mov    (%eax),%eax
    3e1e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e21:	83 c1 02             	add    $0x2,%ecx
    3e24:	01 c8                	add    %ecx,%eax
    3e26:	0f b6 00             	movzbl (%eax),%eax
    3e29:	0f b6 c0             	movzbl %al,%eax
    3e2c:	c1 e0 10             	shl    $0x10,%eax
    3e2f:	09 c2                	or     %eax,%edx
    3e31:	8b 45 08             	mov    0x8(%ebp),%eax
    3e34:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e37:	8b 45 08             	mov    0x8(%ebp),%eax
    3e3a:	8b 50 10             	mov    0x10(%eax),%edx
    3e3d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e40:	8b 40 0c             	mov    0xc(%eax),%eax
    3e43:	83 e0 07             	and    $0x7,%eax
    3e46:	89 c1                	mov    %eax,%ecx
    3e48:	d3 ea                	shr    %cl,%edx
    3e4a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e4d:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e50:	8b 45 08             	mov    0x8(%ebp),%eax
    3e53:	8b 50 0c             	mov    0xc(%eax),%edx
    3e56:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e59:	01 c2                	add    %eax,%edx
    3e5b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5e:	8b 40 08             	mov    0x8(%eax),%eax
    3e61:	39 c2                	cmp    %eax,%edx
    3e63:	0f 9e c0             	setle  %al
    3e66:	0f b6 c0             	movzbl %al,%eax
  }
}
    3e69:	c9                   	leave  
    3e6a:	c3                   	ret    

00003e6b <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3e6b:	55                   	push   %ebp
    3e6c:	89 e5                	mov    %esp,%ebp
    3e6e:	53                   	push   %ebx
    3e6f:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3e72:	8b 45 08             	mov    0x8(%ebp),%eax
    3e75:	8b 40 0c             	mov    0xc(%eax),%eax
    3e78:	c1 f8 03             	sar    $0x3,%eax
    3e7b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3e7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3e81:	8b 40 04             	mov    0x4(%eax),%eax
    3e84:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3e87:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e8a:	8d 50 04             	lea    0x4(%eax),%edx
    3e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3e90:	39 c2                	cmp    %eax,%edx
    3e92:	0f 83 c3 00 00 00    	jae    3f5b <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e98:	8b 45 08             	mov    0x8(%ebp),%eax
    3e9b:	8b 10                	mov    (%eax),%edx
    3e9d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ea0:	01 d0                	add    %edx,%eax
    3ea2:	0f b6 00             	movzbl (%eax),%eax
    3ea5:	0f b6 d0             	movzbl %al,%edx
    3ea8:	8b 45 08             	mov    0x8(%ebp),%eax
    3eab:	8b 00                	mov    (%eax),%eax
    3ead:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3eb0:	83 c1 01             	add    $0x1,%ecx
    3eb3:	01 c8                	add    %ecx,%eax
    3eb5:	0f b6 00             	movzbl (%eax),%eax
    3eb8:	0f b6 c0             	movzbl %al,%eax
    3ebb:	c1 e0 08             	shl    $0x8,%eax
    3ebe:	89 d1                	mov    %edx,%ecx
    3ec0:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3ec2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec5:	8b 00                	mov    (%eax),%eax
    3ec7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3eca:	83 c2 02             	add    $0x2,%edx
    3ecd:	01 d0                	add    %edx,%eax
    3ecf:	0f b6 00             	movzbl (%eax),%eax
    3ed2:	0f b6 c0             	movzbl %al,%eax
    3ed5:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ed8:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3eda:	8b 45 08             	mov    0x8(%ebp),%eax
    3edd:	8b 00                	mov    (%eax),%eax
    3edf:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3ee2:	83 c2 03             	add    $0x3,%edx
    3ee5:	01 d0                	add    %edx,%eax
    3ee7:	0f b6 00             	movzbl (%eax),%eax
    3eea:	0f b6 c0             	movzbl %al,%eax
    3eed:	c1 e0 18             	shl    $0x18,%eax
    3ef0:	09 c1                	or     %eax,%ecx
    3ef2:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ef4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ef7:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3efa:	8b 45 08             	mov    0x8(%ebp),%eax
    3efd:	8b 50 10             	mov    0x10(%eax),%edx
    3f00:	8b 45 08             	mov    0x8(%ebp),%eax
    3f03:	8b 40 0c             	mov    0xc(%eax),%eax
    3f06:	83 e0 07             	and    $0x7,%eax
    3f09:	89 c1                	mov    %eax,%ecx
    3f0b:	d3 ea                	shr    %cl,%edx
    3f0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3f10:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    3f13:	8b 45 08             	mov    0x8(%ebp),%eax
    3f16:	8b 50 10             	mov    0x10(%eax),%edx
    3f19:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1c:	8b 00                	mov    (%eax),%eax
    3f1e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f21:	83 c1 04             	add    $0x4,%ecx
    3f24:	01 c8                	add    %ecx,%eax
    3f26:	0f b6 00             	movzbl (%eax),%eax
    3f29:	0f b6 c0             	movzbl %al,%eax
    3f2c:	c1 e0 18             	shl    $0x18,%eax
    3f2f:	89 c3                	mov    %eax,%ebx
    3f31:	8b 45 08             	mov    0x8(%ebp),%eax
    3f34:	8b 40 0c             	mov    0xc(%eax),%eax
    3f37:	83 e0 07             	and    $0x7,%eax
    3f3a:	b9 08 00 00 00       	mov    $0x8,%ecx
    3f3f:	29 c1                	sub    %eax,%ecx
    3f41:	89 c8                	mov    %ecx,%eax
    3f43:	89 c1                	mov    %eax,%ecx
    3f45:	d3 e3                	shl    %cl,%ebx
    3f47:	89 d8                	mov    %ebx,%eax
    3f49:	09 c2                	or     %eax,%edx
    3f4b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f4e:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f51:	b8 01 00 00 00       	mov    $0x1,%eax
    3f56:	e9 f7 00 00 00       	jmp    4052 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    3f5b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f65:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f68:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f6b:	39 c2                	cmp    %eax,%edx
    3f6d:	73 1e                	jae    3f8d <ensureBits32+0x122>
    3f6f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f72:	8b 50 10             	mov    0x10(%eax),%edx
    3f75:	8b 45 08             	mov    0x8(%ebp),%eax
    3f78:	8b 08                	mov    (%eax),%ecx
    3f7a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f7d:	01 c8                	add    %ecx,%eax
    3f7f:	0f b6 00             	movzbl (%eax),%eax
    3f82:	0f b6 c0             	movzbl %al,%eax
    3f85:	09 c2                	or     %eax,%edx
    3f87:	8b 45 08             	mov    0x8(%ebp),%eax
    3f8a:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3f8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f90:	8d 50 01             	lea    0x1(%eax),%edx
    3f93:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f96:	39 c2                	cmp    %eax,%edx
    3f98:	73 24                	jae    3fbe <ensureBits32+0x153>
    3f9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9d:	8b 50 10             	mov    0x10(%eax),%edx
    3fa0:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa3:	8b 00                	mov    (%eax),%eax
    3fa5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fa8:	83 c1 01             	add    $0x1,%ecx
    3fab:	01 c8                	add    %ecx,%eax
    3fad:	0f b6 00             	movzbl (%eax),%eax
    3fb0:	0f b6 c0             	movzbl %al,%eax
    3fb3:	c1 e0 08             	shl    $0x8,%eax
    3fb6:	09 c2                	or     %eax,%edx
    3fb8:	8b 45 08             	mov    0x8(%ebp),%eax
    3fbb:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3fbe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fc1:	8d 50 02             	lea    0x2(%eax),%edx
    3fc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fc7:	39 c2                	cmp    %eax,%edx
    3fc9:	73 24                	jae    3fef <ensureBits32+0x184>
    3fcb:	8b 45 08             	mov    0x8(%ebp),%eax
    3fce:	8b 50 10             	mov    0x10(%eax),%edx
    3fd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3fd4:	8b 00                	mov    (%eax),%eax
    3fd6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fd9:	83 c1 02             	add    $0x2,%ecx
    3fdc:	01 c8                	add    %ecx,%eax
    3fde:	0f b6 00             	movzbl (%eax),%eax
    3fe1:	0f b6 c0             	movzbl %al,%eax
    3fe4:	c1 e0 10             	shl    $0x10,%eax
    3fe7:	09 c2                	or     %eax,%edx
    3fe9:	8b 45 08             	mov    0x8(%ebp),%eax
    3fec:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    3fef:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ff2:	8d 50 03             	lea    0x3(%eax),%edx
    3ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ff8:	39 c2                	cmp    %eax,%edx
    3ffa:	73 24                	jae    4020 <ensureBits32+0x1b5>
    3ffc:	8b 45 08             	mov    0x8(%ebp),%eax
    3fff:	8b 50 10             	mov    0x10(%eax),%edx
    4002:	8b 45 08             	mov    0x8(%ebp),%eax
    4005:	8b 00                	mov    (%eax),%eax
    4007:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    400a:	83 c1 03             	add    $0x3,%ecx
    400d:	01 c8                	add    %ecx,%eax
    400f:	0f b6 00             	movzbl (%eax),%eax
    4012:	0f b6 c0             	movzbl %al,%eax
    4015:	c1 e0 18             	shl    $0x18,%eax
    4018:	09 c2                	or     %eax,%edx
    401a:	8b 45 08             	mov    0x8(%ebp),%eax
    401d:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4020:	8b 45 08             	mov    0x8(%ebp),%eax
    4023:	8b 50 10             	mov    0x10(%eax),%edx
    4026:	8b 45 08             	mov    0x8(%ebp),%eax
    4029:	8b 40 0c             	mov    0xc(%eax),%eax
    402c:	83 e0 07             	and    $0x7,%eax
    402f:	89 c1                	mov    %eax,%ecx
    4031:	d3 ea                	shr    %cl,%edx
    4033:	8b 45 08             	mov    0x8(%ebp),%eax
    4036:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4039:	8b 45 08             	mov    0x8(%ebp),%eax
    403c:	8b 50 0c             	mov    0xc(%eax),%edx
    403f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4042:	01 c2                	add    %eax,%edx
    4044:	8b 45 08             	mov    0x8(%ebp),%eax
    4047:	8b 40 08             	mov    0x8(%eax),%eax
    404a:	39 c2                	cmp    %eax,%edx
    404c:	0f 9e c0             	setle  %al
    404f:	0f b6 c0             	movzbl %al,%eax
  }
}
    4052:	83 c4 10             	add    $0x10,%esp
    4055:	5b                   	pop    %ebx
    4056:	5d                   	pop    %ebp
    4057:	c3                   	ret    

00004058 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4058:	55                   	push   %ebp
    4059:	89 e5                	mov    %esp,%ebp
    405b:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    405c:	8b 45 08             	mov    0x8(%ebp),%eax
    405f:	8b 50 10             	mov    0x10(%eax),%edx
    4062:	8b 45 0c             	mov    0xc(%ebp),%eax
    4065:	bb 01 00 00 00       	mov    $0x1,%ebx
    406a:	89 c1                	mov    %eax,%ecx
    406c:	d3 e3                	shl    %cl,%ebx
    406e:	89 d8                	mov    %ebx,%eax
    4070:	83 e8 01             	sub    $0x1,%eax
    4073:	21 d0                	and    %edx,%eax
}
    4075:	5b                   	pop    %ebx
    4076:	5d                   	pop    %ebp
    4077:	c3                   	ret    

00004078 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4078:	55                   	push   %ebp
    4079:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    407b:	8b 45 08             	mov    0x8(%ebp),%eax
    407e:	8b 50 10             	mov    0x10(%eax),%edx
    4081:	8b 45 0c             	mov    0xc(%ebp),%eax
    4084:	89 c1                	mov    %eax,%ecx
    4086:	d3 ea                	shr    %cl,%edx
    4088:	8b 45 08             	mov    0x8(%ebp),%eax
    408b:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    408e:	8b 45 08             	mov    0x8(%ebp),%eax
    4091:	8b 50 0c             	mov    0xc(%eax),%edx
    4094:	8b 45 0c             	mov    0xc(%ebp),%eax
    4097:	01 c2                	add    %eax,%edx
    4099:	8b 45 08             	mov    0x8(%ebp),%eax
    409c:	89 50 0c             	mov    %edx,0xc(%eax)
}
    409f:	90                   	nop
    40a0:	5d                   	pop    %ebp
    40a1:	c3                   	ret    

000040a2 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    40a2:	55                   	push   %ebp
    40a3:	89 e5                	mov    %esp,%ebp
    40a5:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    40a8:	ff 75 0c             	pushl  0xc(%ebp)
    40ab:	ff 75 08             	pushl  0x8(%ebp)
    40ae:	e8 a5 ff ff ff       	call   4058 <peekBits>
    40b3:	83 c4 08             	add    $0x8,%esp
    40b6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    40b9:	ff 75 0c             	pushl  0xc(%ebp)
    40bc:	ff 75 08             	pushl  0x8(%ebp)
    40bf:	e8 b4 ff ff ff       	call   4078 <advanceBits>
    40c4:	83 c4 08             	add    $0x8,%esp
  return result;
    40c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    40ca:	c9                   	leave  
    40cb:	c3                   	ret    

000040cc <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    40cc:	55                   	push   %ebp
    40cd:	89 e5                	mov    %esp,%ebp
    40cf:	53                   	push   %ebx
    40d0:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    40d3:	ff 75 0c             	pushl  0xc(%ebp)
    40d6:	ff 75 08             	pushl  0x8(%ebp)
    40d9:	8d 45 d8             	lea    -0x28(%ebp),%eax
    40dc:	50                   	push   %eax
    40dd:	e8 97 f9 ff ff       	call   3a79 <LodePNGBitReader_init>
    40e2:	83 c4 0c             	add    $0xc,%esp
    40e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    40e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    40ec:	74 0a                	je     40f8 <lode_png_test_bitreader+0x2c>
    40ee:	b8 00 00 00 00       	mov    $0x0,%eax
    40f3:	e9 c3 00 00 00       	jmp    41bb <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    40f8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    40ff:	e9 a6 00 00 00       	jmp    41aa <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    4104:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4107:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    410e:	8b 45 14             	mov    0x14(%ebp),%eax
    4111:	01 d0                	add    %edx,%eax
    4113:	8b 00                	mov    (%eax),%eax
    4115:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    4118:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    411c:	7e 14                	jle    4132 <lode_png_test_bitreader+0x66>
    411e:	ff 75 ec             	pushl  -0x14(%ebp)
    4121:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4124:	50                   	push   %eax
    4125:	e8 41 fd ff ff       	call   3e6b <ensureBits32>
    412a:	83 c4 08             	add    $0x8,%esp
    412d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4130:	eb 46                	jmp    4178 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    4132:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4136:	7e 14                	jle    414c <lode_png_test_bitreader+0x80>
    4138:	ff 75 ec             	pushl  -0x14(%ebp)
    413b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    413e:	50                   	push   %eax
    413f:	e8 ae fb ff ff       	call   3cf2 <ensureBits25>
    4144:	83 c4 08             	add    $0x8,%esp
    4147:	89 45 f4             	mov    %eax,-0xc(%ebp)
    414a:	eb 2c                	jmp    4178 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    414c:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    4150:	7e 14                	jle    4166 <lode_png_test_bitreader+0x9a>
    4152:	ff 75 ec             	pushl  -0x14(%ebp)
    4155:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4158:	50                   	push   %eax
    4159:	e8 68 fa ff ff       	call   3bc6 <ensureBits17>
    415e:	83 c4 08             	add    $0x8,%esp
    4161:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4164:	eb 12                	jmp    4178 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4166:	ff 75 ec             	pushl  -0x14(%ebp)
    4169:	8d 45 d8             	lea    -0x28(%ebp),%eax
    416c:	50                   	push   %eax
    416d:	e8 78 f9 ff ff       	call   3aea <ensureBits9>
    4172:	83 c4 08             	add    $0x8,%esp
    4175:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4178:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    417c:	75 07                	jne    4185 <lode_png_test_bitreader+0xb9>
    417e:	b8 00 00 00 00       	mov    $0x0,%eax
    4183:	eb 36                	jmp    41bb <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4185:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4188:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    418f:	8b 45 18             	mov    0x18(%ebp),%eax
    4192:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4195:	ff 75 ec             	pushl  -0x14(%ebp)
    4198:	8d 45 d8             	lea    -0x28(%ebp),%eax
    419b:	50                   	push   %eax
    419c:	e8 01 ff ff ff       	call   40a2 <readBits>
    41a1:	83 c4 08             	add    $0x8,%esp
    41a4:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    41a6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    41aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41ad:	3b 45 10             	cmp    0x10(%ebp),%eax
    41b0:	0f 8c 4e ff ff ff    	jl     4104 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    41b6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    41bb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    41be:	c9                   	leave  
    41bf:	c3                   	ret    

000041c0 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    41c0:	55                   	push   %ebp
    41c1:	89 e5                	mov    %esp,%ebp
    41c3:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    41c6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    41cd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    41d4:	eb 27                	jmp    41fd <reverseBits+0x3d>
    41d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    41d9:	2b 45 fc             	sub    -0x4(%ebp),%eax
    41dc:	83 e8 01             	sub    $0x1,%eax
    41df:	8b 55 08             	mov    0x8(%ebp),%edx
    41e2:	89 c1                	mov    %eax,%ecx
    41e4:	d3 ea                	shr    %cl,%edx
    41e6:	89 d0                	mov    %edx,%eax
    41e8:	83 e0 01             	and    $0x1,%eax
    41eb:	89 c2                	mov    %eax,%edx
    41ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
    41f0:	89 c1                	mov    %eax,%ecx
    41f2:	d3 e2                	shl    %cl,%edx
    41f4:	89 d0                	mov    %edx,%eax
    41f6:	09 45 f8             	or     %eax,-0x8(%ebp)
    41f9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    41fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4200:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4203:	72 d1                	jb     41d6 <reverseBits+0x16>
  return result;
    4205:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    4208:	c9                   	leave  
    4209:	c3                   	ret    

0000420a <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    420a:	55                   	push   %ebp
    420b:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    420d:	8b 45 08             	mov    0x8(%ebp),%eax
    4210:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    4216:	8b 45 08             	mov    0x8(%ebp),%eax
    4219:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    4220:	8b 45 08             	mov    0x8(%ebp),%eax
    4223:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    422a:	8b 45 08             	mov    0x8(%ebp),%eax
    422d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    4234:	90                   	nop
    4235:	5d                   	pop    %ebp
    4236:	c3                   	ret    

00004237 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4237:	55                   	push   %ebp
    4238:	89 e5                	mov    %esp,%ebp
    423a:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    423d:	8b 45 08             	mov    0x8(%ebp),%eax
    4240:	8b 00                	mov    (%eax),%eax
    4242:	83 ec 0c             	sub    $0xc,%esp
    4245:	50                   	push   %eax
    4246:	e8 ec f0 ff ff       	call   3337 <lodepng_free>
    424b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    424e:	8b 45 08             	mov    0x8(%ebp),%eax
    4251:	8b 40 04             	mov    0x4(%eax),%eax
    4254:	83 ec 0c             	sub    $0xc,%esp
    4257:	50                   	push   %eax
    4258:	e8 da f0 ff ff       	call   3337 <lodepng_free>
    425d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    4260:	8b 45 08             	mov    0x8(%ebp),%eax
    4263:	8b 40 10             	mov    0x10(%eax),%eax
    4266:	83 ec 0c             	sub    $0xc,%esp
    4269:	50                   	push   %eax
    426a:	e8 c8 f0 ff ff       	call   3337 <lodepng_free>
    426f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4272:	8b 45 08             	mov    0x8(%ebp),%eax
    4275:	8b 40 14             	mov    0x14(%eax),%eax
    4278:	83 ec 0c             	sub    $0xc,%esp
    427b:	50                   	push   %eax
    427c:	e8 b6 f0 ff ff       	call   3337 <lodepng_free>
    4281:	83 c4 10             	add    $0x10,%esp
}
    4284:	90                   	nop
    4285:	c9                   	leave  
    4286:	c3                   	ret    

00004287 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4287:	55                   	push   %ebp
    4288:	89 e5                	mov    %esp,%ebp
    428a:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    428d:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    4292:	c1 e0 02             	shl    $0x2,%eax
    4295:	83 ec 0c             	sub    $0xc,%esp
    4298:	50                   	push   %eax
    4299:	e8 78 f0 ff ff       	call   3316 <lodepng_malloc>
    429e:	83 c4 10             	add    $0x10,%esp
    42a1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    42a4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    42a8:	75 0a                	jne    42b4 <HuffmanTree_makeTable+0x2d>
    42aa:	b8 53 00 00 00       	mov    $0x53,%eax
    42af:	e9 61 04 00 00       	jmp    4715 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    42b4:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    42b9:	c1 e0 02             	shl    $0x2,%eax
    42bc:	83 ec 04             	sub    $0x4,%esp
    42bf:	50                   	push   %eax
    42c0:	6a 00                	push   $0x0
    42c2:	ff 75 dc             	pushl  -0x24(%ebp)
    42c5:	e8 bd f0 ff ff       	call   3387 <lodepng_memset>
    42ca:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    42cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    42d4:	eb 7d                	jmp    4353 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    42d6:	8b 45 08             	mov    0x8(%ebp),%eax
    42d9:	8b 00                	mov    (%eax),%eax
    42db:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42de:	c1 e2 02             	shl    $0x2,%edx
    42e1:	01 d0                	add    %edx,%eax
    42e3:	8b 00                	mov    (%eax),%eax
    42e5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    42e8:	8b 45 08             	mov    0x8(%ebp),%eax
    42eb:	8b 40 04             	mov    0x4(%eax),%eax
    42ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42f1:	c1 e2 02             	shl    $0x2,%edx
    42f4:	01 d0                	add    %edx,%eax
    42f6:	8b 00                	mov    (%eax),%eax
    42f8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    42fb:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    42ff:	76 4d                	jbe    434e <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    4301:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4304:	83 e8 09             	sub    $0x9,%eax
    4307:	8b 55 d8             	mov    -0x28(%ebp),%edx
    430a:	89 c1                	mov    %eax,%ecx
    430c:	d3 ea                	shr    %cl,%edx
    430e:	89 d0                	mov    %edx,%eax
    4310:	83 ec 08             	sub    $0x8,%esp
    4313:	6a 09                	push   $0x9
    4315:	50                   	push   %eax
    4316:	e8 a5 fe ff ff       	call   41c0 <reverseBits>
    431b:	83 c4 10             	add    $0x10,%esp
    431e:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    4321:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4324:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    432b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    432e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    4331:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4334:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    433b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    433e:	01 d0                	add    %edx,%eax
    4340:	8b 10                	mov    (%eax),%edx
    4342:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4345:	39 c2                	cmp    %eax,%edx
    4347:	0f 43 c2             	cmovae %edx,%eax
    434a:	89 01                	mov    %eax,(%ecx)
    434c:	eb 01                	jmp    434f <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    434e:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    434f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4353:	8b 45 08             	mov    0x8(%ebp),%eax
    4356:	8b 50 0c             	mov    0xc(%eax),%edx
    4359:	8b 45 f4             	mov    -0xc(%ebp),%eax
    435c:	39 c2                	cmp    %eax,%edx
    435e:	0f 87 72 ff ff ff    	ja     42d6 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4364:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    4369:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    436c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4373:	eb 35                	jmp    43aa <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4375:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4378:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    437f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4382:	01 d0                	add    %edx,%eax
    4384:	8b 00                	mov    (%eax),%eax
    4386:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4389:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    438d:	76 17                	jbe    43a6 <HuffmanTree_makeTable+0x11f>
    438f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4392:	83 e8 09             	sub    $0x9,%eax
    4395:	ba 01 00 00 00       	mov    $0x1,%edx
    439a:	89 c1                	mov    %eax,%ecx
    439c:	d3 e2                	shl    %cl,%edx
    439e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43a1:	01 d0                	add    %edx,%eax
    43a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    43a6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    43aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
    43ad:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    43b2:	39 c2                	cmp    %eax,%edx
    43b4:	72 bf                	jb     4375 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    43b6:	83 ec 0c             	sub    $0xc,%esp
    43b9:	ff 75 e8             	pushl  -0x18(%ebp)
    43bc:	e8 55 ef ff ff       	call   3316 <lodepng_malloc>
    43c1:	83 c4 10             	add    $0x10,%esp
    43c4:	89 c2                	mov    %eax,%edx
    43c6:	8b 45 08             	mov    0x8(%ebp),%eax
    43c9:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    43cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43cf:	01 c0                	add    %eax,%eax
    43d1:	83 ec 0c             	sub    $0xc,%esp
    43d4:	50                   	push   %eax
    43d5:	e8 3c ef ff ff       	call   3316 <lodepng_malloc>
    43da:	83 c4 10             	add    $0x10,%esp
    43dd:	89 c2                	mov    %eax,%edx
    43df:	8b 45 08             	mov    0x8(%ebp),%eax
    43e2:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    43e5:	8b 45 08             	mov    0x8(%ebp),%eax
    43e8:	8b 40 10             	mov    0x10(%eax),%eax
    43eb:	85 c0                	test   %eax,%eax
    43ed:	74 0a                	je     43f9 <HuffmanTree_makeTable+0x172>
    43ef:	8b 45 08             	mov    0x8(%ebp),%eax
    43f2:	8b 40 14             	mov    0x14(%eax),%eax
    43f5:	85 c0                	test   %eax,%eax
    43f7:	75 18                	jne    4411 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    43f9:	83 ec 0c             	sub    $0xc,%esp
    43fc:	ff 75 dc             	pushl  -0x24(%ebp)
    43ff:	e8 33 ef ff ff       	call   3337 <lodepng_free>
    4404:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    4407:	b8 53 00 00 00       	mov    $0x53,%eax
    440c:	e9 04 03 00 00       	jmp    4715 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    4411:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4418:	eb 12                	jmp    442c <HuffmanTree_makeTable+0x1a5>
    441a:	8b 45 08             	mov    0x8(%ebp),%eax
    441d:	8b 50 10             	mov    0x10(%eax),%edx
    4420:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4423:	01 d0                	add    %edx,%eax
    4425:	c6 00 10             	movb   $0x10,(%eax)
    4428:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    442c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    442f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4432:	7c e6                	jl     441a <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4434:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    4439:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    443c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4443:	eb 5b                	jmp    44a0 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4445:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4448:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    444f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4452:	01 d0                	add    %edx,%eax
    4454:	8b 00                	mov    (%eax),%eax
    4456:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4459:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    445d:	76 3c                	jbe    449b <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    445f:	8b 45 08             	mov    0x8(%ebp),%eax
    4462:	8b 50 10             	mov    0x10(%eax),%edx
    4465:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4468:	01 d0                	add    %edx,%eax
    446a:	8b 55 c8             	mov    -0x38(%ebp),%edx
    446d:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    446f:	8b 45 08             	mov    0x8(%ebp),%eax
    4472:	8b 40 14             	mov    0x14(%eax),%eax
    4475:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4478:	01 d2                	add    %edx,%edx
    447a:	01 d0                	add    %edx,%eax
    447c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    447f:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4482:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4485:	83 e8 09             	sub    $0x9,%eax
    4488:	ba 01 00 00 00       	mov    $0x1,%edx
    448d:	89 c1                	mov    %eax,%ecx
    448f:	d3 e2                	shl    %cl,%edx
    4491:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4494:	01 d0                	add    %edx,%eax
    4496:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4499:	eb 01                	jmp    449c <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    449b:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    449c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    44a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44a3:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    44a8:	39 c2                	cmp    %eax,%edx
    44aa:	72 99                	jb     4445 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    44ac:	83 ec 0c             	sub    $0xc,%esp
    44af:	ff 75 dc             	pushl  -0x24(%ebp)
    44b2:	e8 80 ee ff ff       	call   3337 <lodepng_free>
    44b7:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    44ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    44c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44c8:	e9 9d 01 00 00       	jmp    466a <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    44cd:	8b 45 08             	mov    0x8(%ebp),%eax
    44d0:	8b 40 04             	mov    0x4(%eax),%eax
    44d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44d6:	c1 e2 02             	shl    $0x2,%edx
    44d9:	01 d0                	add    %edx,%eax
    44db:	8b 00                	mov    (%eax),%eax
    44dd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    44e0:	8b 45 08             	mov    0x8(%ebp),%eax
    44e3:	8b 00                	mov    (%eax),%eax
    44e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44e8:	c1 e2 02             	shl    $0x2,%edx
    44eb:	01 d0                	add    %edx,%eax
    44ed:	8b 00                	mov    (%eax),%eax
    44ef:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    44f2:	83 ec 08             	sub    $0x8,%esp
    44f5:	ff 75 c4             	pushl  -0x3c(%ebp)
    44f8:	ff 75 c0             	pushl  -0x40(%ebp)
    44fb:	e8 c0 fc ff ff       	call   41c0 <reverseBits>
    4500:	83 c4 10             	add    $0x10,%esp
    4503:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    4506:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    450a:	0f 84 55 01 00 00    	je     4665 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    4510:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    4514:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4518:	0f 87 81 00 00 00    	ja     459f <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    451e:	b8 09 00 00 00       	mov    $0x9,%eax
    4523:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4526:	ba 01 00 00 00       	mov    $0x1,%edx
    452b:	89 c1                	mov    %eax,%ecx
    452d:	d3 e2                	shl    %cl,%edx
    452f:	89 d0                	mov    %edx,%eax
    4531:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4534:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    453b:	eb 55                	jmp    4592 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    453d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4540:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4543:	89 c1                	mov    %eax,%ecx
    4545:	d3 e2                	shl    %cl,%edx
    4547:	89 d0                	mov    %edx,%eax
    4549:	0b 45 bc             	or     -0x44(%ebp),%eax
    454c:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    454f:	8b 45 08             	mov    0x8(%ebp),%eax
    4552:	8b 50 10             	mov    0x10(%eax),%edx
    4555:	8b 45 98             	mov    -0x68(%ebp),%eax
    4558:	01 d0                	add    %edx,%eax
    455a:	0f b6 00             	movzbl (%eax),%eax
    455d:	3c 10                	cmp    $0x10,%al
    455f:	74 0a                	je     456b <HuffmanTree_makeTable+0x2e4>
    4561:	b8 37 00 00 00       	mov    $0x37,%eax
    4566:	e9 aa 01 00 00       	jmp    4715 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    456b:	8b 45 08             	mov    0x8(%ebp),%eax
    456e:	8b 50 10             	mov    0x10(%eax),%edx
    4571:	8b 45 98             	mov    -0x68(%ebp),%eax
    4574:	01 d0                	add    %edx,%eax
    4576:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4579:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    457b:	8b 45 08             	mov    0x8(%ebp),%eax
    457e:	8b 40 14             	mov    0x14(%eax),%eax
    4581:	8b 55 98             	mov    -0x68(%ebp),%edx
    4584:	01 d2                	add    %edx,%edx
    4586:	01 d0                	add    %edx,%eax
    4588:	8b 55 f4             	mov    -0xc(%ebp),%edx
    458b:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    458e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    4592:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4595:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4598:	72 a3                	jb     453d <HuffmanTree_makeTable+0x2b6>
    459a:	e9 c7 00 00 00       	jmp    4666 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    459f:	a1 ac b5 01 00       	mov    0x1b5ac,%eax
    45a4:	23 45 bc             	and    -0x44(%ebp),%eax
    45a7:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    45aa:	8b 45 08             	mov    0x8(%ebp),%eax
    45ad:	8b 50 10             	mov    0x10(%eax),%edx
    45b0:	8b 45 b8             	mov    -0x48(%ebp),%eax
    45b3:	01 d0                	add    %edx,%eax
    45b5:	0f b6 00             	movzbl (%eax),%eax
    45b8:	0f b6 c0             	movzbl %al,%eax
    45bb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    45be:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    45c1:	83 e8 09             	sub    $0x9,%eax
    45c4:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    45c7:	8b 45 08             	mov    0x8(%ebp),%eax
    45ca:	8b 40 14             	mov    0x14(%eax),%eax
    45cd:	8b 55 b8             	mov    -0x48(%ebp),%edx
    45d0:	01 d2                	add    %edx,%edx
    45d2:	01 d0                	add    %edx,%eax
    45d4:	0f b7 00             	movzwl (%eax),%eax
    45d7:	0f b7 c0             	movzwl %ax,%eax
    45da:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    45dd:	8b 45 b0             	mov    -0x50(%ebp),%eax
    45e0:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    45e3:	83 c0 09             	add    $0x9,%eax
    45e6:	ba 01 00 00 00       	mov    $0x1,%edx
    45eb:	89 c1                	mov    %eax,%ecx
    45ed:	d3 e2                	shl    %cl,%edx
    45ef:	89 d0                	mov    %edx,%eax
    45f1:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    45f4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    45f7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    45fa:	73 0a                	jae    4606 <HuffmanTree_makeTable+0x37f>
    45fc:	b8 37 00 00 00       	mov    $0x37,%eax
    4601:	e9 0f 01 00 00       	jmp    4715 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    4606:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    460d:	eb 4c                	jmp    465b <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    460f:	8b 45 bc             	mov    -0x44(%ebp),%eax
    4612:	c1 e8 09             	shr    $0x9,%eax
    4615:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4618:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    461b:	83 e8 09             	sub    $0x9,%eax
    461e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4621:	89 c1                	mov    %eax,%ecx
    4623:	d3 e2                	shl    %cl,%edx
    4625:	89 d0                	mov    %edx,%eax
    4627:	0b 45 a4             	or     -0x5c(%ebp),%eax
    462a:	89 c2                	mov    %eax,%edx
    462c:	8b 45 ac             	mov    -0x54(%ebp),%eax
    462f:	01 d0                	add    %edx,%eax
    4631:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4634:	8b 45 08             	mov    0x8(%ebp),%eax
    4637:	8b 50 10             	mov    0x10(%eax),%edx
    463a:	8b 45 a0             	mov    -0x60(%ebp),%eax
    463d:	01 d0                	add    %edx,%eax
    463f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4642:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4644:	8b 45 08             	mov    0x8(%ebp),%eax
    4647:	8b 40 14             	mov    0x14(%eax),%eax
    464a:	8b 55 a0             	mov    -0x60(%ebp),%edx
    464d:	01 d2                	add    %edx,%edx
    464f:	01 d0                	add    %edx,%eax
    4651:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4654:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4657:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    465b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    465e:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4661:	72 ac                	jb     460f <HuffmanTree_makeTable+0x388>
    4663:	eb 01                	jmp    4666 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4665:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4666:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    466a:	8b 45 08             	mov    0x8(%ebp),%eax
    466d:	8b 50 0c             	mov    0xc(%eax),%edx
    4670:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4673:	39 c2                	cmp    %eax,%edx
    4675:	0f 87 52 fe ff ff    	ja     44cd <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    467b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    467f:	7f 61                	jg     46e2 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4681:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4688:	eb 4e                	jmp    46d8 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    468a:	8b 45 08             	mov    0x8(%ebp),%eax
    468d:	8b 50 10             	mov    0x10(%eax),%edx
    4690:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4693:	01 d0                	add    %edx,%eax
    4695:	0f b6 00             	movzbl (%eax),%eax
    4698:	3c 10                	cmp    $0x10,%al
    469a:	75 38                	jne    46d4 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    469c:	8b 45 08             	mov    0x8(%ebp),%eax
    469f:	8b 50 10             	mov    0x10(%eax),%edx
    46a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46a5:	01 d0                	add    %edx,%eax
    46a7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    46aa:	8b 15 a8 b5 01 00    	mov    0x1b5a8,%edx
    46b0:	39 d1                	cmp    %edx,%ecx
    46b2:	73 07                	jae    46bb <HuffmanTree_makeTable+0x434>
    46b4:	ba 01 00 00 00       	mov    $0x1,%edx
    46b9:	eb 05                	jmp    46c0 <HuffmanTree_makeTable+0x439>
    46bb:	ba 0a 00 00 00       	mov    $0xa,%edx
    46c0:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    46c2:	8b 45 08             	mov    0x8(%ebp),%eax
    46c5:	8b 40 14             	mov    0x14(%eax),%eax
    46c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46cb:	01 d2                	add    %edx,%edx
    46cd:	01 d0                	add    %edx,%eax
    46cf:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    46d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    46d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46db:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    46de:	7c aa                	jl     468a <HuffmanTree_makeTable+0x403>
    46e0:	eb 2e                	jmp    4710 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    46e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    46e9:	eb 1d                	jmp    4708 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    46eb:	8b 45 08             	mov    0x8(%ebp),%eax
    46ee:	8b 50 10             	mov    0x10(%eax),%edx
    46f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46f4:	01 d0                	add    %edx,%eax
    46f6:	0f b6 00             	movzbl (%eax),%eax
    46f9:	3c 10                	cmp    $0x10,%al
    46fb:	75 07                	jne    4704 <HuffmanTree_makeTable+0x47d>
    46fd:	b8 37 00 00 00       	mov    $0x37,%eax
    4702:	eb 11                	jmp    4715 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4704:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4708:	8b 45 f4             	mov    -0xc(%ebp),%eax
    470b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    470e:	7c db                	jl     46eb <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    4710:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4715:	c9                   	leave  
    4716:	c3                   	ret    

00004717 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4717:	55                   	push   %ebp
    4718:	89 e5                	mov    %esp,%ebp
    471a:	56                   	push   %esi
    471b:	53                   	push   %ebx
    471c:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    471f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4726:	8b 45 08             	mov    0x8(%ebp),%eax
    4729:	8b 40 0c             	mov    0xc(%eax),%eax
    472c:	c1 e0 02             	shl    $0x2,%eax
    472f:	83 ec 0c             	sub    $0xc,%esp
    4732:	50                   	push   %eax
    4733:	e8 de eb ff ff       	call   3316 <lodepng_malloc>
    4738:	83 c4 10             	add    $0x10,%esp
    473b:	89 c2                	mov    %eax,%edx
    473d:	8b 45 08             	mov    0x8(%ebp),%eax
    4740:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4742:	8b 45 08             	mov    0x8(%ebp),%eax
    4745:	8b 40 08             	mov    0x8(%eax),%eax
    4748:	83 c0 01             	add    $0x1,%eax
    474b:	c1 e0 02             	shl    $0x2,%eax
    474e:	83 ec 0c             	sub    $0xc,%esp
    4751:	50                   	push   %eax
    4752:	e8 bf eb ff ff       	call   3316 <lodepng_malloc>
    4757:	83 c4 10             	add    $0x10,%esp
    475a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    475d:	8b 45 08             	mov    0x8(%ebp),%eax
    4760:	8b 40 08             	mov    0x8(%eax),%eax
    4763:	83 c0 01             	add    $0x1,%eax
    4766:	c1 e0 02             	shl    $0x2,%eax
    4769:	83 ec 0c             	sub    $0xc,%esp
    476c:	50                   	push   %eax
    476d:	e8 a4 eb ff ff       	call   3316 <lodepng_malloc>
    4772:	83 c4 10             	add    $0x10,%esp
    4775:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4778:	8b 45 08             	mov    0x8(%ebp),%eax
    477b:	8b 00                	mov    (%eax),%eax
    477d:	85 c0                	test   %eax,%eax
    477f:	74 0c                	je     478d <HuffmanTree_makeFromLengths2+0x76>
    4781:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4785:	74 06                	je     478d <HuffmanTree_makeFromLengths2+0x76>
    4787:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    478b:	75 07                	jne    4794 <HuffmanTree_makeFromLengths2+0x7d>
    478d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4794:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4798:	0f 85 7d 01 00 00    	jne    491b <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    479e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    47a5:	eb 2c                	jmp    47d3 <HuffmanTree_makeFromLengths2+0xbc>
    47a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    47b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    47b4:	01 c2                	add    %eax,%edx
    47b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47b9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    47c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    47c3:	01 c8                	add    %ecx,%eax
    47c5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    47cb:	8b 00                	mov    (%eax),%eax
    47cd:	89 02                	mov    %eax,(%edx)
    47cf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    47d3:	8b 45 08             	mov    0x8(%ebp),%eax
    47d6:	8b 40 08             	mov    0x8(%eax),%eax
    47d9:	83 c0 01             	add    $0x1,%eax
    47dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    47df:	75 c6                	jne    47a7 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    47e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    47e8:	eb 27                	jmp    4811 <HuffmanTree_makeFromLengths2+0xfa>
    47ea:	8b 45 08             	mov    0x8(%ebp),%eax
    47ed:	8b 40 04             	mov    0x4(%eax),%eax
    47f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    47f3:	c1 e2 02             	shl    $0x2,%edx
    47f6:	01 d0                	add    %edx,%eax
    47f8:	8b 00                	mov    (%eax),%eax
    47fa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4801:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4804:	01 d0                	add    %edx,%eax
    4806:	8b 10                	mov    (%eax),%edx
    4808:	83 c2 01             	add    $0x1,%edx
    480b:	89 10                	mov    %edx,(%eax)
    480d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4811:	8b 45 08             	mov    0x8(%ebp),%eax
    4814:	8b 40 0c             	mov    0xc(%eax),%eax
    4817:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    481a:	75 ce                	jne    47ea <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    481c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4823:	eb 47                	jmp    486c <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4825:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4828:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    482f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4832:	01 d0                	add    %edx,%eax
    4834:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4837:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    483d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4844:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4847:	01 ca                	add    %ecx,%edx
    4849:	8b 0a                	mov    (%edx),%ecx
    484b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    484e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4854:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    485b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    485e:	01 da                	add    %ebx,%edx
    4860:	8b 12                	mov    (%edx),%edx
    4862:	01 ca                	add    %ecx,%edx
    4864:	01 d2                	add    %edx,%edx
    4866:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4868:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    486c:	8b 45 08             	mov    0x8(%ebp),%eax
    486f:	8b 40 08             	mov    0x8(%eax),%eax
    4872:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4875:	73 ae                	jae    4825 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4877:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    487e:	e9 89 00 00 00       	jmp    490c <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4883:	8b 45 08             	mov    0x8(%ebp),%eax
    4886:	8b 40 04             	mov    0x4(%eax),%eax
    4889:	8b 55 ec             	mov    -0x14(%ebp),%edx
    488c:	c1 e2 02             	shl    $0x2,%edx
    488f:	01 d0                	add    %edx,%eax
    4891:	8b 00                	mov    (%eax),%eax
    4893:	85 c0                	test   %eax,%eax
    4895:	74 71                	je     4908 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4897:	8b 45 08             	mov    0x8(%ebp),%eax
    489a:	8b 00                	mov    (%eax),%eax
    489c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    489f:	c1 e2 02             	shl    $0x2,%edx
    48a2:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    48a5:	8b 45 08             	mov    0x8(%ebp),%eax
    48a8:	8b 40 04             	mov    0x4(%eax),%eax
    48ab:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48ae:	c1 e2 02             	shl    $0x2,%edx
    48b1:	01 d0                	add    %edx,%eax
    48b3:	8b 00                	mov    (%eax),%eax
    48b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48bf:	01 c2                	add    %eax,%edx
    48c1:	8b 02                	mov    (%edx),%eax
    48c3:	8d 48 01             	lea    0x1(%eax),%ecx
    48c6:	89 0a                	mov    %ecx,(%edx)
    48c8:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    48ca:	8b 45 08             	mov    0x8(%ebp),%eax
    48cd:	8b 00                	mov    (%eax),%eax
    48cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48d2:	c1 e2 02             	shl    $0x2,%edx
    48d5:	01 c2                	add    %eax,%edx
    48d7:	8b 45 08             	mov    0x8(%ebp),%eax
    48da:	8b 00                	mov    (%eax),%eax
    48dc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48df:	c1 e1 02             	shl    $0x2,%ecx
    48e2:	01 c8                	add    %ecx,%eax
    48e4:	8b 18                	mov    (%eax),%ebx
    48e6:	8b 45 08             	mov    0x8(%ebp),%eax
    48e9:	8b 40 04             	mov    0x4(%eax),%eax
    48ec:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48ef:	c1 e1 02             	shl    $0x2,%ecx
    48f2:	01 c8                	add    %ecx,%eax
    48f4:	8b 00                	mov    (%eax),%eax
    48f6:	be 01 00 00 00       	mov    $0x1,%esi
    48fb:	89 c1                	mov    %eax,%ecx
    48fd:	d3 e6                	shl    %cl,%esi
    48ff:	89 f0                	mov    %esi,%eax
    4901:	83 e8 01             	sub    $0x1,%eax
    4904:	21 d8                	and    %ebx,%eax
    4906:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4908:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    490c:	8b 45 08             	mov    0x8(%ebp),%eax
    490f:	8b 40 0c             	mov    0xc(%eax),%eax
    4912:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4915:	0f 85 68 ff ff ff    	jne    4883 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    491b:	83 ec 0c             	sub    $0xc,%esp
    491e:	ff 75 e8             	pushl  -0x18(%ebp)
    4921:	e8 11 ea ff ff       	call   3337 <lodepng_free>
    4926:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4929:	83 ec 0c             	sub    $0xc,%esp
    492c:	ff 75 e4             	pushl  -0x1c(%ebp)
    492f:	e8 03 ea ff ff       	call   3337 <lodepng_free>
    4934:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4937:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    493b:	75 11                	jne    494e <HuffmanTree_makeFromLengths2+0x237>
    493d:	83 ec 0c             	sub    $0xc,%esp
    4940:	ff 75 08             	pushl  0x8(%ebp)
    4943:	e8 3f f9 ff ff       	call   4287 <HuffmanTree_makeTable>
    4948:	83 c4 10             	add    $0x10,%esp
    494b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    494e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4951:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4954:	5b                   	pop    %ebx
    4955:	5e                   	pop    %esi
    4956:	5d                   	pop    %ebp
    4957:	c3                   	ret    

00004958 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4958:	55                   	push   %ebp
    4959:	89 e5                	mov    %esp,%ebp
    495b:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    495e:	8b 45 10             	mov    0x10(%ebp),%eax
    4961:	c1 e0 02             	shl    $0x2,%eax
    4964:	83 ec 0c             	sub    $0xc,%esp
    4967:	50                   	push   %eax
    4968:	e8 a9 e9 ff ff       	call   3316 <lodepng_malloc>
    496d:	83 c4 10             	add    $0x10,%esp
    4970:	89 c2                	mov    %eax,%edx
    4972:	8b 45 08             	mov    0x8(%ebp),%eax
    4975:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4978:	8b 45 08             	mov    0x8(%ebp),%eax
    497b:	8b 40 04             	mov    0x4(%eax),%eax
    497e:	85 c0                	test   %eax,%eax
    4980:	75 07                	jne    4989 <HuffmanTree_makeFromLengths+0x31>
    4982:	b8 53 00 00 00       	mov    $0x53,%eax
    4987:	eb 56                	jmp    49df <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4989:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4990:	eb 25                	jmp    49b7 <HuffmanTree_makeFromLengths+0x5f>
    4992:	8b 45 08             	mov    0x8(%ebp),%eax
    4995:	8b 40 04             	mov    0x4(%eax),%eax
    4998:	8b 55 f4             	mov    -0xc(%ebp),%edx
    499b:	c1 e2 02             	shl    $0x2,%edx
    499e:	01 c2                	add    %eax,%edx
    49a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49a3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    49aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    49ad:	01 c8                	add    %ecx,%eax
    49af:	8b 00                	mov    (%eax),%eax
    49b1:	89 02                	mov    %eax,(%edx)
    49b3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49b7:	8b 45 10             	mov    0x10(%ebp),%eax
    49ba:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    49bd:	75 d3                	jne    4992 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    49bf:	8b 55 10             	mov    0x10(%ebp),%edx
    49c2:	8b 45 08             	mov    0x8(%ebp),%eax
    49c5:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    49c8:	8b 45 08             	mov    0x8(%ebp),%eax
    49cb:	8b 55 14             	mov    0x14(%ebp),%edx
    49ce:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    49d1:	83 ec 0c             	sub    $0xc,%esp
    49d4:	ff 75 08             	pushl  0x8(%ebp)
    49d7:	e8 3b fd ff ff       	call   4717 <HuffmanTree_makeFromLengths2>
    49dc:	83 c4 10             	add    $0x10,%esp
}
    49df:	c9                   	leave  
    49e0:	c3                   	ret    

000049e1 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    49e1:	55                   	push   %ebp
    49e2:	89 e5                	mov    %esp,%ebp
    49e4:	53                   	push   %ebx
    49e5:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    49e8:	8b 45 08             	mov    0x8(%ebp),%eax
    49eb:	8b 50 0c             	mov    0xc(%eax),%edx
    49ee:	8b 45 08             	mov    0x8(%ebp),%eax
    49f1:	8b 40 08             	mov    0x8(%eax),%eax
    49f4:	39 c2                	cmp    %eax,%edx
    49f6:	0f 82 0b 01 00 00    	jb     4b07 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    49fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a03:	eb 19                	jmp    4a1e <bpmnode_create+0x3d>
    4a05:	8b 45 08             	mov    0x8(%ebp),%eax
    4a08:	8b 40 04             	mov    0x4(%eax),%eax
    4a0b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a0e:	c1 e2 04             	shl    $0x4,%edx
    4a11:	01 d0                	add    %edx,%eax
    4a13:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4a1a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4a1e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a21:	8b 00                	mov    (%eax),%eax
    4a23:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4a26:	75 dd                	jne    4a05 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4a28:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a2f:	eb 60                	jmp    4a91 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4a31:	8b 45 08             	mov    0x8(%ebp),%eax
    4a34:	8b 40 18             	mov    0x18(%eax),%eax
    4a37:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a3a:	c1 e2 02             	shl    $0x2,%edx
    4a3d:	01 d0                	add    %edx,%eax
    4a3f:	8b 00                	mov    (%eax),%eax
    4a41:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a44:	eb 13                	jmp    4a59 <bpmnode_create+0x78>
    4a46:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a49:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a53:	8b 40 08             	mov    0x8(%eax),%eax
    4a56:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a5d:	75 e7                	jne    4a46 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4a5f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a62:	8b 40 1c             	mov    0x1c(%eax),%eax
    4a65:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a68:	c1 e2 02             	shl    $0x2,%edx
    4a6b:	01 d0                	add    %edx,%eax
    4a6d:	8b 00                	mov    (%eax),%eax
    4a6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a72:	eb 13                	jmp    4a87 <bpmnode_create+0xa6>
    4a74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a77:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a81:	8b 40 08             	mov    0x8(%eax),%eax
    4a84:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a87:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a8b:	75 e7                	jne    4a74 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4a8d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4a91:	8b 45 08             	mov    0x8(%ebp),%eax
    4a94:	8b 40 14             	mov    0x14(%eax),%eax
    4a97:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4a9a:	75 95                	jne    4a31 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4a9c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a9f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4aa6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4aad:	eb 44                	jmp    4af3 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab2:	8b 40 04             	mov    0x4(%eax),%eax
    4ab5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ab8:	c1 e2 04             	shl    $0x4,%edx
    4abb:	01 d0                	add    %edx,%eax
    4abd:	8b 40 0c             	mov    0xc(%eax),%eax
    4ac0:	85 c0                	test   %eax,%eax
    4ac2:	75 2b                	jne    4aef <bpmnode_create+0x10e>
    4ac4:	8b 45 08             	mov    0x8(%ebp),%eax
    4ac7:	8b 58 10             	mov    0x10(%eax),%ebx
    4aca:	8b 45 08             	mov    0x8(%ebp),%eax
    4acd:	8b 40 08             	mov    0x8(%eax),%eax
    4ad0:	8d 48 01             	lea    0x1(%eax),%ecx
    4ad3:	8b 55 08             	mov    0x8(%ebp),%edx
    4ad6:	89 4a 08             	mov    %ecx,0x8(%edx)
    4ad9:	c1 e0 02             	shl    $0x2,%eax
    4adc:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4adf:	8b 45 08             	mov    0x8(%ebp),%eax
    4ae2:	8b 40 04             	mov    0x4(%eax),%eax
    4ae5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4ae8:	c1 e1 04             	shl    $0x4,%ecx
    4aeb:	01 c8                	add    %ecx,%eax
    4aed:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4aef:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4af3:	8b 45 08             	mov    0x8(%ebp),%eax
    4af6:	8b 00                	mov    (%eax),%eax
    4af8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4afb:	75 b2                	jne    4aaf <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4afd:	8b 45 08             	mov    0x8(%ebp),%eax
    4b00:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4b07:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0a:	8b 58 10             	mov    0x10(%eax),%ebx
    4b0d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b10:	8b 40 0c             	mov    0xc(%eax),%eax
    4b13:	8d 48 01             	lea    0x1(%eax),%ecx
    4b16:	8b 55 08             	mov    0x8(%ebp),%edx
    4b19:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4b1c:	c1 e0 02             	shl    $0x2,%eax
    4b1f:	01 d8                	add    %ebx,%eax
    4b21:	8b 00                	mov    (%eax),%eax
    4b23:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b29:	8b 55 0c             	mov    0xc(%ebp),%edx
    4b2c:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4b2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b31:	8b 55 10             	mov    0x10(%ebp),%edx
    4b34:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4b37:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b3a:	8b 55 14             	mov    0x14(%ebp),%edx
    4b3d:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4b40:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4b43:	83 c4 10             	add    $0x10,%esp
    4b46:	5b                   	pop    %ebx
    4b47:	5d                   	pop    %ebp
    4b48:	c3                   	ret    

00004b49 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4b49:	55                   	push   %ebp
    4b4a:	89 e5                	mov    %esp,%ebp
    4b4c:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4b4f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b52:	c1 e0 04             	shl    $0x4,%eax
    4b55:	83 ec 0c             	sub    $0xc,%esp
    4b58:	50                   	push   %eax
    4b59:	e8 b8 e7 ff ff       	call   3316 <lodepng_malloc>
    4b5e:	83 c4 10             	add    $0x10,%esp
    4b61:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4b64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4b6b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4b72:	e9 41 01 00 00       	jmp    4cb8 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4b77:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b7a:	83 e0 01             	and    $0x1,%eax
    4b7d:	85 c0                	test   %eax,%eax
    4b7f:	74 05                	je     4b86 <bpmnode_sort+0x3d>
    4b81:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b84:	eb 03                	jmp    4b89 <bpmnode_sort+0x40>
    4b86:	8b 45 08             	mov    0x8(%ebp),%eax
    4b89:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4b8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b8f:	83 e0 01             	and    $0x1,%eax
    4b92:	85 c0                	test   %eax,%eax
    4b94:	74 05                	je     4b9b <bpmnode_sort+0x52>
    4b96:	8b 45 08             	mov    0x8(%ebp),%eax
    4b99:	eb 03                	jmp    4b9e <bpmnode_sort+0x55>
    4b9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b9e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4ba1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4ba8:	e9 f8 00 00 00       	jmp    4ca5 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4bad:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bb3:	01 c2                	add    %eax,%edx
    4bb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bb8:	39 c2                	cmp    %eax,%edx
    4bba:	0f 4e c2             	cmovle %edx,%eax
    4bbd:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4bc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bc3:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4bc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bc9:	01 c2                	add    %eax,%edx
    4bcb:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bce:	39 c2                	cmp    %eax,%edx
    4bd0:	0f 4e c2             	cmovle %edx,%eax
    4bd3:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4bd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4bdc:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4bdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4be2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4be5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4be8:	e9 a4 00 00 00       	jmp    4c91 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4bed:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4bf0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4bf3:	7d 62                	jge    4c57 <bpmnode_sort+0x10e>
    4bf5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4bf8:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4bfb:	7d 22                	jge    4c1f <bpmnode_sort+0xd6>
    4bfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c00:	c1 e0 04             	shl    $0x4,%eax
    4c03:	89 c2                	mov    %eax,%edx
    4c05:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c08:	01 d0                	add    %edx,%eax
    4c0a:	8b 10                	mov    (%eax),%edx
    4c0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c0f:	c1 e0 04             	shl    $0x4,%eax
    4c12:	89 c1                	mov    %eax,%ecx
    4c14:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c17:	01 c8                	add    %ecx,%eax
    4c19:	8b 00                	mov    (%eax),%eax
    4c1b:	39 c2                	cmp    %eax,%edx
    4c1d:	7f 38                	jg     4c57 <bpmnode_sort+0x10e>
    4c1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c22:	c1 e0 04             	shl    $0x4,%eax
    4c25:	89 c2                	mov    %eax,%edx
    4c27:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c2a:	01 d0                	add    %edx,%eax
    4c2c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4c2f:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c32:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4c35:	89 d1                	mov    %edx,%ecx
    4c37:	c1 e1 04             	shl    $0x4,%ecx
    4c3a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c3d:	01 ca                	add    %ecx,%edx
    4c3f:	8b 0a                	mov    (%edx),%ecx
    4c41:	89 08                	mov    %ecx,(%eax)
    4c43:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c46:	89 48 04             	mov    %ecx,0x4(%eax)
    4c49:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c4c:	89 48 08             	mov    %ecx,0x8(%eax)
    4c4f:	8b 52 0c             	mov    0xc(%edx),%edx
    4c52:	89 50 0c             	mov    %edx,0xc(%eax)
    4c55:	eb 36                	jmp    4c8d <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4c57:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c5a:	c1 e0 04             	shl    $0x4,%eax
    4c5d:	89 c2                	mov    %eax,%edx
    4c5f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c62:	01 d0                	add    %edx,%eax
    4c64:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4c67:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c6a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4c6d:	89 d1                	mov    %edx,%ecx
    4c6f:	c1 e1 04             	shl    $0x4,%ecx
    4c72:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c75:	01 ca                	add    %ecx,%edx
    4c77:	8b 0a                	mov    (%edx),%ecx
    4c79:	89 08                	mov    %ecx,(%eax)
    4c7b:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c7e:	89 48 04             	mov    %ecx,0x4(%eax)
    4c81:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c84:	89 48 08             	mov    %ecx,0x8(%eax)
    4c87:	8b 52 0c             	mov    0xc(%edx),%edx
    4c8a:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4c8d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4c91:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c94:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4c97:	0f 8c 50 ff ff ff    	jl     4bed <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4c9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ca0:	01 c0                	add    %eax,%eax
    4ca2:	01 45 ec             	add    %eax,-0x14(%ebp)
    4ca5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4ca8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4cab:	0f 8c fc fe ff ff    	jl     4bad <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4cb1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4cb5:	d1 65 f4             	shll   -0xc(%ebp)
    4cb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4cbb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4cbe:	0f 8c b3 fe ff ff    	jl     4b77 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4cc7:	83 e0 01             	and    $0x1,%eax
    4cca:	85 c0                	test   %eax,%eax
    4ccc:	74 18                	je     4ce6 <bpmnode_sort+0x19d>
    4cce:	8b 45 0c             	mov    0xc(%ebp),%eax
    4cd1:	c1 e0 04             	shl    $0x4,%eax
    4cd4:	83 ec 04             	sub    $0x4,%esp
    4cd7:	50                   	push   %eax
    4cd8:	ff 75 dc             	pushl  -0x24(%ebp)
    4cdb:	ff 75 08             	pushl  0x8(%ebp)
    4cde:	e8 71 e6 ff ff       	call   3354 <lodepng_memcpy>
    4ce3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4ce6:	83 ec 0c             	sub    $0xc,%esp
    4ce9:	ff 75 dc             	pushl  -0x24(%ebp)
    4cec:	e8 46 e6 ff ff       	call   3337 <lodepng_free>
    4cf1:	83 c4 10             	add    $0x10,%esp
}
    4cf4:	90                   	nop
    4cf5:	c9                   	leave  
    4cf6:	c3                   	ret    

00004cf7 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4cf7:	55                   	push   %ebp
    4cf8:	89 e5                	mov    %esp,%ebp
    4cfa:	56                   	push   %esi
    4cfb:	53                   	push   %ebx
    4cfc:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4cff:	8b 45 08             	mov    0x8(%ebp),%eax
    4d02:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d05:	8b 55 14             	mov    0x14(%ebp),%edx
    4d08:	c1 e2 02             	shl    $0x2,%edx
    4d0b:	01 d0                	add    %edx,%eax
    4d0d:	8b 00                	mov    (%eax),%eax
    4d0f:	8b 40 04             	mov    0x4(%eax),%eax
    4d12:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4d15:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4d19:	75 66                	jne    4d81 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4d1b:	8b 45 10             	mov    0x10(%ebp),%eax
    4d1e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4d21:	0f 83 a0 01 00 00    	jae    4ec7 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4d27:	8b 45 08             	mov    0x8(%ebp),%eax
    4d2a:	8b 40 18             	mov    0x18(%eax),%eax
    4d2d:	8b 55 14             	mov    0x14(%ebp),%edx
    4d30:	c1 e2 02             	shl    $0x2,%edx
    4d33:	01 c2                	add    %eax,%edx
    4d35:	8b 45 08             	mov    0x8(%ebp),%eax
    4d38:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d3b:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4d3e:	c1 e1 02             	shl    $0x2,%ecx
    4d41:	01 c8                	add    %ecx,%eax
    4d43:	8b 00                	mov    (%eax),%eax
    4d45:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4d47:	8b 45 08             	mov    0x8(%ebp),%eax
    4d4a:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d4d:	8b 55 14             	mov    0x14(%ebp),%edx
    4d50:	c1 e2 02             	shl    $0x2,%edx
    4d53:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4d56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d59:	8d 50 01             	lea    0x1(%eax),%edx
    4d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d5f:	c1 e0 04             	shl    $0x4,%eax
    4d62:	89 c1                	mov    %eax,%ecx
    4d64:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d67:	01 c8                	add    %ecx,%eax
    4d69:	8b 00                	mov    (%eax),%eax
    4d6b:	6a 00                	push   $0x0
    4d6d:	52                   	push   %edx
    4d6e:	50                   	push   %eax
    4d6f:	ff 75 08             	pushl  0x8(%ebp)
    4d72:	e8 6a fc ff ff       	call   49e1 <bpmnode_create>
    4d77:	83 c4 10             	add    $0x10,%esp
    4d7a:	89 03                	mov    %eax,(%ebx)
    4d7c:	e9 47 01 00 00       	jmp    4ec8 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4d81:	8b 45 08             	mov    0x8(%ebp),%eax
    4d84:	8b 40 18             	mov    0x18(%eax),%eax
    4d87:	8b 55 14             	mov    0x14(%ebp),%edx
    4d8a:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4d90:	c1 e2 02             	shl    $0x2,%edx
    4d93:	01 d0                	add    %edx,%eax
    4d95:	8b 00                	mov    (%eax),%eax
    4d97:	8b 10                	mov    (%eax),%edx
    4d99:	8b 45 08             	mov    0x8(%ebp),%eax
    4d9c:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d9f:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4da2:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4da8:	c1 e1 02             	shl    $0x2,%ecx
    4dab:	01 c8                	add    %ecx,%eax
    4dad:	8b 00                	mov    (%eax),%eax
    4daf:	8b 00                	mov    (%eax),%eax
    4db1:	01 d0                	add    %edx,%eax
    4db3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4db6:	8b 45 08             	mov    0x8(%ebp),%eax
    4db9:	8b 40 18             	mov    0x18(%eax),%eax
    4dbc:	8b 55 14             	mov    0x14(%ebp),%edx
    4dbf:	c1 e2 02             	shl    $0x2,%edx
    4dc2:	01 c2                	add    %eax,%edx
    4dc4:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc7:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dca:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4dcd:	c1 e1 02             	shl    $0x2,%ecx
    4dd0:	01 c8                	add    %ecx,%eax
    4dd2:	8b 00                	mov    (%eax),%eax
    4dd4:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4dd6:	8b 45 10             	mov    0x10(%ebp),%eax
    4dd9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4ddc:	73 60                	jae    4e3e <boundaryPM+0x147>
    4dde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4de1:	c1 e0 04             	shl    $0x4,%eax
    4de4:	89 c2                	mov    %eax,%edx
    4de6:	8b 45 0c             	mov    0xc(%ebp),%eax
    4de9:	01 d0                	add    %edx,%eax
    4deb:	8b 00                	mov    (%eax),%eax
    4ded:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4df0:	7d 4c                	jge    4e3e <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4df2:	8b 45 08             	mov    0x8(%ebp),%eax
    4df5:	8b 40 1c             	mov    0x1c(%eax),%eax
    4df8:	8b 55 14             	mov    0x14(%ebp),%edx
    4dfb:	c1 e2 02             	shl    $0x2,%edx
    4dfe:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e01:	8b 45 08             	mov    0x8(%ebp),%eax
    4e04:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e07:	8b 55 14             	mov    0x14(%ebp),%edx
    4e0a:	c1 e2 02             	shl    $0x2,%edx
    4e0d:	01 d0                	add    %edx,%eax
    4e0f:	8b 00                	mov    (%eax),%eax
    4e11:	8b 50 08             	mov    0x8(%eax),%edx
    4e14:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e17:	8d 48 01             	lea    0x1(%eax),%ecx
    4e1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e1d:	c1 e0 04             	shl    $0x4,%eax
    4e20:	89 c6                	mov    %eax,%esi
    4e22:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e25:	01 f0                	add    %esi,%eax
    4e27:	8b 00                	mov    (%eax),%eax
    4e29:	52                   	push   %edx
    4e2a:	51                   	push   %ecx
    4e2b:	50                   	push   %eax
    4e2c:	ff 75 08             	pushl  0x8(%ebp)
    4e2f:	e8 ad fb ff ff       	call   49e1 <bpmnode_create>
    4e34:	83 c4 10             	add    $0x10,%esp
    4e37:	89 03                	mov    %eax,(%ebx)
      return;
    4e39:	e9 8a 00 00 00       	jmp    4ec8 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4e3e:	8b 45 08             	mov    0x8(%ebp),%eax
    4e41:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e44:	8b 55 14             	mov    0x14(%ebp),%edx
    4e47:	c1 e2 02             	shl    $0x2,%edx
    4e4a:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e50:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e53:	8b 55 14             	mov    0x14(%ebp),%edx
    4e56:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e5c:	c1 e2 02             	shl    $0x2,%edx
    4e5f:	01 d0                	add    %edx,%eax
    4e61:	8b 00                	mov    (%eax),%eax
    4e63:	50                   	push   %eax
    4e64:	ff 75 f4             	pushl  -0xc(%ebp)
    4e67:	ff 75 f0             	pushl  -0x10(%ebp)
    4e6a:	ff 75 08             	pushl  0x8(%ebp)
    4e6d:	e8 6f fb ff ff       	call   49e1 <bpmnode_create>
    4e72:	83 c4 10             	add    $0x10,%esp
    4e75:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4e77:	8b 45 18             	mov    0x18(%ebp),%eax
    4e7a:	8d 50 01             	lea    0x1(%eax),%edx
    4e7d:	8b 45 10             	mov    0x10(%ebp),%eax
    4e80:	83 e8 01             	sub    $0x1,%eax
    4e83:	01 c0                	add    %eax,%eax
    4e85:	39 c2                	cmp    %eax,%edx
    4e87:	7d 3f                	jge    4ec8 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4e89:	8b 45 14             	mov    0x14(%ebp),%eax
    4e8c:	83 e8 01             	sub    $0x1,%eax
    4e8f:	83 ec 0c             	sub    $0xc,%esp
    4e92:	ff 75 18             	pushl  0x18(%ebp)
    4e95:	50                   	push   %eax
    4e96:	ff 75 10             	pushl  0x10(%ebp)
    4e99:	ff 75 0c             	pushl  0xc(%ebp)
    4e9c:	ff 75 08             	pushl  0x8(%ebp)
    4e9f:	e8 53 fe ff ff       	call   4cf7 <boundaryPM>
    4ea4:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4ea7:	8b 45 14             	mov    0x14(%ebp),%eax
    4eaa:	83 e8 01             	sub    $0x1,%eax
    4ead:	83 ec 0c             	sub    $0xc,%esp
    4eb0:	ff 75 18             	pushl  0x18(%ebp)
    4eb3:	50                   	push   %eax
    4eb4:	ff 75 10             	pushl  0x10(%ebp)
    4eb7:	ff 75 0c             	pushl  0xc(%ebp)
    4eba:	ff 75 08             	pushl  0x8(%ebp)
    4ebd:	e8 35 fe ff ff       	call   4cf7 <boundaryPM>
    4ec2:	83 c4 20             	add    $0x20,%esp
    4ec5:	eb 01                	jmp    4ec8 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4ec7:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4ec8:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4ecb:	5b                   	pop    %ebx
    4ecc:	5e                   	pop    %esi
    4ecd:	5d                   	pop    %ebp
    4ece:	c3                   	ret    

00004ecf <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4ecf:	55                   	push   %ebp
    4ed0:	89 e5                	mov    %esp,%ebp
    4ed2:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4ed5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4edc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4ee3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4ee7:	75 0a                	jne    4ef3 <lodepng_huffman_code_lengths+0x24>
    4ee9:	b8 50 00 00 00       	mov    $0x50,%eax
    4eee:	e9 4d 03 00 00       	jmp    5240 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4ef3:	8b 45 14             	mov    0x14(%ebp),%eax
    4ef6:	ba 01 00 00 00       	mov    $0x1,%edx
    4efb:	89 c1                	mov    %eax,%ecx
    4efd:	d3 e2                	shl    %cl,%edx
    4eff:	8b 45 10             	mov    0x10(%ebp),%eax
    4f02:	39 c2                	cmp    %eax,%edx
    4f04:	73 0a                	jae    4f10 <lodepng_huffman_code_lengths+0x41>
    4f06:	b8 50 00 00 00       	mov    $0x50,%eax
    4f0b:	e9 30 03 00 00       	jmp    5240 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4f10:	8b 45 10             	mov    0x10(%ebp),%eax
    4f13:	c1 e0 04             	shl    $0x4,%eax
    4f16:	83 ec 0c             	sub    $0xc,%esp
    4f19:	50                   	push   %eax
    4f1a:	e8 f7 e3 ff ff       	call   3316 <lodepng_malloc>
    4f1f:	83 c4 10             	add    $0x10,%esp
    4f22:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    4f25:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4f29:	75 0a                	jne    4f35 <lodepng_huffman_code_lengths+0x66>
    4f2b:	b8 53 00 00 00       	mov    $0x53,%eax
    4f30:	e9 0b 03 00 00       	jmp    5240 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    4f35:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4f3c:	eb 50                	jmp    4f8e <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    4f3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f41:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f48:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f4b:	01 d0                	add    %edx,%eax
    4f4d:	8b 00                	mov    (%eax),%eax
    4f4f:	85 c0                	test   %eax,%eax
    4f51:	74 37                	je     4f8a <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    4f53:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f56:	c1 e0 04             	shl    $0x4,%eax
    4f59:	89 c2                	mov    %eax,%edx
    4f5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f5e:	01 d0                	add    %edx,%eax
    4f60:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f63:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4f6a:	8b 55 0c             	mov    0xc(%ebp),%edx
    4f6d:	01 ca                	add    %ecx,%edx
    4f6f:	8b 12                	mov    (%edx),%edx
    4f71:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    4f73:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f76:	c1 e0 04             	shl    $0x4,%eax
    4f79:	89 c2                	mov    %eax,%edx
    4f7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f7e:	01 c2                	add    %eax,%edx
    4f80:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f83:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    4f86:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    4f8a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4f8e:	8b 45 10             	mov    0x10(%ebp),%eax
    4f91:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    4f94:	75 a8                	jne    4f3e <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    4f96:	8b 45 10             	mov    0x10(%ebp),%eax
    4f99:	c1 e0 02             	shl    $0x2,%eax
    4f9c:	83 ec 04             	sub    $0x4,%esp
    4f9f:	50                   	push   %eax
    4fa0:	6a 00                	push   $0x0
    4fa2:	ff 75 08             	pushl  0x8(%ebp)
    4fa5:	e8 dd e3 ff ff       	call   3387 <lodepng_memset>
    4faa:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    4fad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4fb1:	75 18                	jne    4fcb <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    4fb3:	8b 45 08             	mov    0x8(%ebp),%eax
    4fb6:	83 c0 04             	add    $0x4,%eax
    4fb9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    4fbf:	8b 10                	mov    (%eax),%edx
    4fc1:	8b 45 08             	mov    0x8(%ebp),%eax
    4fc4:	89 10                	mov    %edx,(%eax)
    4fc6:	e9 64 02 00 00       	jmp    522f <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    4fcb:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    4fcf:	75 3e                	jne    500f <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    4fd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fd4:	8b 40 04             	mov    0x4(%eax),%eax
    4fd7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4fde:	8b 45 08             	mov    0x8(%ebp),%eax
    4fe1:	01 d0                	add    %edx,%eax
    4fe3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    4fe9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fec:	8b 40 04             	mov    0x4(%eax),%eax
    4fef:	85 c0                	test   %eax,%eax
    4ff1:	75 07                	jne    4ffa <lodepng_huffman_code_lengths+0x12b>
    4ff3:	ba 04 00 00 00       	mov    $0x4,%edx
    4ff8:	eb 05                	jmp    4fff <lodepng_huffman_code_lengths+0x130>
    4ffa:	ba 00 00 00 00       	mov    $0x0,%edx
    4fff:	8b 45 08             	mov    0x8(%ebp),%eax
    5002:	01 d0                	add    %edx,%eax
    5004:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    500a:	e9 20 02 00 00       	jmp    522f <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    500f:	83 ec 08             	sub    $0x8,%esp
    5012:	ff 75 ec             	pushl  -0x14(%ebp)
    5015:	ff 75 e4             	pushl  -0x1c(%ebp)
    5018:	e8 2c fb ff ff       	call   4b49 <bpmnode_sort>
    501d:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    5020:	8b 45 14             	mov    0x14(%ebp),%eax
    5023:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    5026:	8b 45 14             	mov    0x14(%ebp),%eax
    5029:	83 c0 01             	add    $0x1,%eax
    502c:	0f af 45 14          	imul   0x14(%ebp),%eax
    5030:	01 c0                	add    %eax,%eax
    5032:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5035:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    503c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    503f:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5042:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5045:	c1 e0 04             	shl    $0x4,%eax
    5048:	83 ec 0c             	sub    $0xc,%esp
    504b:	50                   	push   %eax
    504c:	e8 c5 e2 ff ff       	call   3316 <lodepng_malloc>
    5051:	83 c4 10             	add    $0x10,%esp
    5054:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5057:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    505a:	c1 e0 02             	shl    $0x2,%eax
    505d:	83 ec 0c             	sub    $0xc,%esp
    5060:	50                   	push   %eax
    5061:	e8 b0 e2 ff ff       	call   3316 <lodepng_malloc>
    5066:	83 c4 10             	add    $0x10,%esp
    5069:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    506c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    506f:	c1 e0 02             	shl    $0x2,%eax
    5072:	83 ec 0c             	sub    $0xc,%esp
    5075:	50                   	push   %eax
    5076:	e8 9b e2 ff ff       	call   3316 <lodepng_malloc>
    507b:	83 c4 10             	add    $0x10,%esp
    507e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5081:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5084:	c1 e0 02             	shl    $0x2,%eax
    5087:	83 ec 0c             	sub    $0xc,%esp
    508a:	50                   	push   %eax
    508b:	e8 86 e2 ff ff       	call   3316 <lodepng_malloc>
    5090:	83 c4 10             	add    $0x10,%esp
    5093:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5096:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5099:	85 c0                	test   %eax,%eax
    509b:	74 15                	je     50b2 <lodepng_huffman_code_lengths+0x1e3>
    509d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50a0:	85 c0                	test   %eax,%eax
    50a2:	74 0e                	je     50b2 <lodepng_huffman_code_lengths+0x1e3>
    50a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    50a7:	85 c0                	test   %eax,%eax
    50a9:	74 07                	je     50b2 <lodepng_huffman_code_lengths+0x1e3>
    50ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
    50ae:	85 c0                	test   %eax,%eax
    50b0:	75 07                	jne    50b9 <lodepng_huffman_code_lengths+0x1ea>
    50b2:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    50b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    50bd:	0f 85 30 01 00 00    	jne    51f3 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    50c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    50ca:	eb 1c                	jmp    50e8 <lodepng_huffman_code_lengths+0x219>
    50cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50cf:	8b 55 f0             	mov    -0x10(%ebp),%edx
    50d2:	c1 e2 02             	shl    $0x2,%edx
    50d5:	01 d0                	add    %edx,%eax
    50d7:	8b 55 c8             	mov    -0x38(%ebp),%edx
    50da:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    50dd:	c1 e1 04             	shl    $0x4,%ecx
    50e0:	01 ca                	add    %ecx,%edx
    50e2:	89 10                	mov    %edx,(%eax)
    50e4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    50e8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50eb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    50ee:	75 dc                	jne    50cc <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    50f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    50f3:	8b 00                	mov    (%eax),%eax
    50f5:	6a 00                	push   $0x0
    50f7:	6a 01                	push   $0x1
    50f9:	50                   	push   %eax
    50fa:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    50fd:	50                   	push   %eax
    50fe:	e8 de f8 ff ff       	call   49e1 <bpmnode_create>
    5103:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    5106:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5109:	83 c0 10             	add    $0x10,%eax
    510c:	8b 00                	mov    (%eax),%eax
    510e:	6a 00                	push   $0x0
    5110:	6a 02                	push   $0x2
    5112:	50                   	push   %eax
    5113:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5116:	50                   	push   %eax
    5117:	e8 c5 f8 ff ff       	call   49e1 <bpmnode_create>
    511c:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    511f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5126:	eb 27                	jmp    514f <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5128:	8b 45 dc             	mov    -0x24(%ebp),%eax
    512b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    512e:	c1 e2 02             	shl    $0x2,%edx
    5131:	01 c2                	add    %eax,%edx
    5133:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5136:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5138:	8b 45 e0             	mov    -0x20(%ebp),%eax
    513b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    513e:	c1 e2 02             	shl    $0x2,%edx
    5141:	01 d0                	add    %edx,%eax
    5143:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5146:	83 c2 10             	add    $0x10,%edx
    5149:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    514b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    514f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5152:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5155:	75 d1                	jne    5128 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5157:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    515e:	eb 24                	jmp    5184 <lodepng_huffman_code_lengths+0x2b5>
    5160:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5163:	8b 55 14             	mov    0x14(%ebp),%edx
    5166:	83 ea 01             	sub    $0x1,%edx
    5169:	83 ec 0c             	sub    $0xc,%esp
    516c:	50                   	push   %eax
    516d:	52                   	push   %edx
    516e:	ff 75 ec             	pushl  -0x14(%ebp)
    5171:	ff 75 e4             	pushl  -0x1c(%ebp)
    5174:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5177:	50                   	push   %eax
    5178:	e8 7a fb ff ff       	call   4cf7 <boundaryPM>
    517d:	83 c4 20             	add    $0x20,%esp
    5180:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5184:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5187:	83 e8 01             	sub    $0x1,%eax
    518a:	01 c0                	add    %eax,%eax
    518c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    518f:	75 cf                	jne    5160 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5191:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5194:	8b 55 14             	mov    0x14(%ebp),%edx
    5197:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    519d:	c1 e2 02             	shl    $0x2,%edx
    51a0:	01 d0                	add    %edx,%eax
    51a2:	8b 00                	mov    (%eax),%eax
    51a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51a7:	eb 44                	jmp    51ed <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    51a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    51b0:	eb 27                	jmp    51d9 <lodepng_huffman_code_lengths+0x30a>
    51b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    51b5:	c1 e0 04             	shl    $0x4,%eax
    51b8:	89 c2                	mov    %eax,%edx
    51ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51bd:	01 d0                	add    %edx,%eax
    51bf:	8b 40 04             	mov    0x4(%eax),%eax
    51c2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    51c9:	8b 45 08             	mov    0x8(%ebp),%eax
    51cc:	01 d0                	add    %edx,%eax
    51ce:	8b 10                	mov    (%eax),%edx
    51d0:	83 c2 01             	add    $0x1,%edx
    51d3:	89 10                	mov    %edx,(%eax)
    51d5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51dc:	8b 40 04             	mov    0x4(%eax),%eax
    51df:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51e2:	75 ce                	jne    51b2 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    51e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51e7:	8b 40 08             	mov    0x8(%eax),%eax
    51ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51ed:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    51f1:	75 b6                	jne    51a9 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    51f3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    51f6:	83 ec 0c             	sub    $0xc,%esp
    51f9:	50                   	push   %eax
    51fa:	e8 38 e1 ff ff       	call   3337 <lodepng_free>
    51ff:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    5202:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5205:	83 ec 0c             	sub    $0xc,%esp
    5208:	50                   	push   %eax
    5209:	e8 29 e1 ff ff       	call   3337 <lodepng_free>
    520e:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    5211:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5214:	83 ec 0c             	sub    $0xc,%esp
    5217:	50                   	push   %eax
    5218:	e8 1a e1 ff ff       	call   3337 <lodepng_free>
    521d:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    5220:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5223:	83 ec 0c             	sub    $0xc,%esp
    5226:	50                   	push   %eax
    5227:	e8 0b e1 ff ff       	call   3337 <lodepng_free>
    522c:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    522f:	83 ec 0c             	sub    $0xc,%esp
    5232:	ff 75 e4             	pushl  -0x1c(%ebp)
    5235:	e8 fd e0 ff ff       	call   3337 <lodepng_free>
    523a:	83 c4 10             	add    $0x10,%esp
  return error;
    523d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5240:	c9                   	leave  
    5241:	c3                   	ret    

00005242 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5242:	55                   	push   %ebp
    5243:	89 e5                	mov    %esp,%ebp
    5245:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5248:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    524f:	eb 04                	jmp    5255 <HuffmanTree_makeFromFrequencies+0x13>
    5251:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5255:	8b 45 14             	mov    0x14(%ebp),%eax
    5258:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    525d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5264:	8b 45 0c             	mov    0xc(%ebp),%eax
    5267:	01 d0                	add    %edx,%eax
    5269:	8b 00                	mov    (%eax),%eax
    526b:	85 c0                	test   %eax,%eax
    526d:	75 08                	jne    5277 <HuffmanTree_makeFromFrequencies+0x35>
    526f:	8b 45 14             	mov    0x14(%ebp),%eax
    5272:	3b 45 10             	cmp    0x10(%ebp),%eax
    5275:	7f da                	jg     5251 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5277:	8b 45 14             	mov    0x14(%ebp),%eax
    527a:	c1 e0 02             	shl    $0x2,%eax
    527d:	83 ec 0c             	sub    $0xc,%esp
    5280:	50                   	push   %eax
    5281:	e8 90 e0 ff ff       	call   3316 <lodepng_malloc>
    5286:	83 c4 10             	add    $0x10,%esp
    5289:	89 c2                	mov    %eax,%edx
    528b:	8b 45 08             	mov    0x8(%ebp),%eax
    528e:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    5291:	8b 45 08             	mov    0x8(%ebp),%eax
    5294:	8b 40 04             	mov    0x4(%eax),%eax
    5297:	85 c0                	test   %eax,%eax
    5299:	75 07                	jne    52a2 <HuffmanTree_makeFromFrequencies+0x60>
    529b:	b8 53 00 00 00       	mov    $0x53,%eax
    52a0:	eb 47                	jmp    52e9 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    52a2:	8b 45 08             	mov    0x8(%ebp),%eax
    52a5:	8b 55 18             	mov    0x18(%ebp),%edx
    52a8:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    52ab:	8b 55 14             	mov    0x14(%ebp),%edx
    52ae:	8b 45 08             	mov    0x8(%ebp),%eax
    52b1:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    52b4:	8b 45 08             	mov    0x8(%ebp),%eax
    52b7:	8b 40 04             	mov    0x4(%eax),%eax
    52ba:	ff 75 18             	pushl  0x18(%ebp)
    52bd:	ff 75 14             	pushl  0x14(%ebp)
    52c0:	ff 75 0c             	pushl  0xc(%ebp)
    52c3:	50                   	push   %eax
    52c4:	e8 06 fc ff ff       	call   4ecf <lodepng_huffman_code_lengths>
    52c9:	83 c4 10             	add    $0x10,%esp
    52cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    52cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    52d3:	75 11                	jne    52e6 <HuffmanTree_makeFromFrequencies+0xa4>
    52d5:	83 ec 0c             	sub    $0xc,%esp
    52d8:	ff 75 08             	pushl  0x8(%ebp)
    52db:	e8 37 f4 ff ff       	call   4717 <HuffmanTree_makeFromLengths2>
    52e0:	83 c4 10             	add    $0x10,%esp
    52e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    52e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    52e9:	c9                   	leave  
    52ea:	c3                   	ret    

000052eb <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    52eb:	55                   	push   %ebp
    52ec:	89 e5                	mov    %esp,%ebp
    52ee:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    52f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    52f8:	83 ec 0c             	sub    $0xc,%esp
    52fb:	68 80 04 00 00       	push   $0x480
    5300:	e8 11 e0 ff ff       	call   3316 <lodepng_malloc>
    5305:	83 c4 10             	add    $0x10,%esp
    5308:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    530b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    530f:	75 0a                	jne    531b <generateFixedLitLenTree+0x30>
    5311:	b8 53 00 00 00       	mov    $0x53,%eax
    5316:	e9 d5 00 00 00       	jmp    53f0 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    531b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5322:	eb 19                	jmp    533d <generateFixedLitLenTree+0x52>
    5324:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5327:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    532e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5331:	01 d0                	add    %edx,%eax
    5333:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5339:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    533d:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5344:	76 de                	jbe    5324 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5346:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    534d:	eb 19                	jmp    5368 <generateFixedLitLenTree+0x7d>
    534f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5352:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5359:	8b 45 ec             	mov    -0x14(%ebp),%eax
    535c:	01 d0                	add    %edx,%eax
    535e:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5364:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5368:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    536f:	76 de                	jbe    534f <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5371:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5378:	eb 19                	jmp    5393 <generateFixedLitLenTree+0xa8>
    537a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    537d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5384:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5387:	01 d0                	add    %edx,%eax
    5389:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    538f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5393:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    539a:	76 de                	jbe    537a <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    539c:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    53a3:	eb 19                	jmp    53be <generateFixedLitLenTree+0xd3>
    53a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53b2:	01 d0                	add    %edx,%eax
    53b4:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    53ba:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53be:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    53c5:	76 de                	jbe    53a5 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    53c7:	6a 0f                	push   $0xf
    53c9:	68 20 01 00 00       	push   $0x120
    53ce:	ff 75 ec             	pushl  -0x14(%ebp)
    53d1:	ff 75 08             	pushl  0x8(%ebp)
    53d4:	e8 7f f5 ff ff       	call   4958 <HuffmanTree_makeFromLengths>
    53d9:	83 c4 10             	add    $0x10,%esp
    53dc:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    53df:	83 ec 0c             	sub    $0xc,%esp
    53e2:	ff 75 ec             	pushl  -0x14(%ebp)
    53e5:	e8 4d df ff ff       	call   3337 <lodepng_free>
    53ea:	83 c4 10             	add    $0x10,%esp
  return error;
    53ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    53f0:	c9                   	leave  
    53f1:	c3                   	ret    

000053f2 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    53f2:	55                   	push   %ebp
    53f3:	89 e5                	mov    %esp,%ebp
    53f5:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    53f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    53ff:	83 ec 0c             	sub    $0xc,%esp
    5402:	68 80 00 00 00       	push   $0x80
    5407:	e8 0a df ff ff       	call   3316 <lodepng_malloc>
    540c:	83 c4 10             	add    $0x10,%esp
    540f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5412:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5416:	75 07                	jne    541f <generateFixedDistanceTree+0x2d>
    5418:	b8 53 00 00 00       	mov    $0x53,%eax
    541d:	eb 4e                	jmp    546d <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    541f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5426:	eb 19                	jmp    5441 <generateFixedDistanceTree+0x4f>
    5428:	8b 45 f4             	mov    -0xc(%ebp),%eax
    542b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5432:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5435:	01 d0                	add    %edx,%eax
    5437:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    543d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5441:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5445:	75 e1                	jne    5428 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5447:	6a 0f                	push   $0xf
    5449:	6a 20                	push   $0x20
    544b:	ff 75 ec             	pushl  -0x14(%ebp)
    544e:	ff 75 08             	pushl  0x8(%ebp)
    5451:	e8 02 f5 ff ff       	call   4958 <HuffmanTree_makeFromLengths>
    5456:	83 c4 10             	add    $0x10,%esp
    5459:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    545c:	83 ec 0c             	sub    $0xc,%esp
    545f:	ff 75 ec             	pushl  -0x14(%ebp)
    5462:	e8 d0 de ff ff       	call   3337 <lodepng_free>
    5467:	83 c4 10             	add    $0x10,%esp
  return error;
    546a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    546d:	c9                   	leave  
    546e:	c3                   	ret    

0000546f <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    546f:	55                   	push   %ebp
    5470:	89 e5                	mov    %esp,%ebp
    5472:	53                   	push   %ebx
    5473:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5476:	6a 09                	push   $0x9
    5478:	ff 75 08             	pushl  0x8(%ebp)
    547b:	e8 d8 eb ff ff       	call   4058 <peekBits>
    5480:	83 c4 08             	add    $0x8,%esp
    5483:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5487:	8b 45 0c             	mov    0xc(%ebp),%eax
    548a:	8b 50 10             	mov    0x10(%eax),%edx
    548d:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    5491:	01 d0                	add    %edx,%eax
    5493:	0f b6 00             	movzbl (%eax),%eax
    5496:	0f b6 c0             	movzbl %al,%eax
    5499:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    549d:	8b 45 0c             	mov    0xc(%ebp),%eax
    54a0:	8b 40 14             	mov    0x14(%eax),%eax
    54a3:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    54a7:	01 d2                	add    %edx,%edx
    54a9:	01 d0                	add    %edx,%eax
    54ab:	0f b7 00             	movzwl (%eax),%eax
    54ae:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    54b2:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    54b7:	77 16                	ja     54cf <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    54b9:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54bd:	50                   	push   %eax
    54be:	ff 75 08             	pushl  0x8(%ebp)
    54c1:	e8 b2 eb ff ff       	call   4078 <advanceBits>
    54c6:	83 c4 08             	add    $0x8,%esp
    return value;
    54c9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    54cd:	eb 5c                	jmp    552b <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    54cf:	6a 09                	push   $0x9
    54d1:	ff 75 08             	pushl  0x8(%ebp)
    54d4:	e8 9f eb ff ff       	call   4078 <advanceBits>
    54d9:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    54dc:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    54e0:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54e4:	83 e8 09             	sub    $0x9,%eax
    54e7:	50                   	push   %eax
    54e8:	ff 75 08             	pushl  0x8(%ebp)
    54eb:	e8 68 eb ff ff       	call   4058 <peekBits>
    54f0:	83 c4 08             	add    $0x8,%esp
    54f3:	01 d8                	add    %ebx,%eax
    54f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    54f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    54fb:	8b 50 10             	mov    0x10(%eax),%edx
    54fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5501:	01 d0                	add    %edx,%eax
    5503:	0f b6 00             	movzbl (%eax),%eax
    5506:	0f b6 c0             	movzbl %al,%eax
    5509:	83 e8 09             	sub    $0x9,%eax
    550c:	50                   	push   %eax
    550d:	ff 75 08             	pushl  0x8(%ebp)
    5510:	e8 63 eb ff ff       	call   4078 <advanceBits>
    5515:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5518:	8b 45 0c             	mov    0xc(%ebp),%eax
    551b:	8b 40 14             	mov    0x14(%eax),%eax
    551e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5521:	01 d2                	add    %edx,%edx
    5523:	01 d0                	add    %edx,%eax
    5525:	0f b7 00             	movzwl (%eax),%eax
    5528:	0f b7 c0             	movzwl %ax,%eax
  }
}
    552b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    552e:	c9                   	leave  
    552f:	c3                   	ret    

00005530 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    5530:	55                   	push   %ebp
    5531:	89 e5                	mov    %esp,%ebp
    5533:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5536:	83 ec 0c             	sub    $0xc,%esp
    5539:	ff 75 08             	pushl  0x8(%ebp)
    553c:	e8 aa fd ff ff       	call   52eb <generateFixedLitLenTree>
    5541:	83 c4 10             	add    $0x10,%esp
    5544:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5547:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    554b:	74 05                	je     5552 <getTreeInflateFixed+0x22>
    554d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5550:	eb 0e                	jmp    5560 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5552:	83 ec 0c             	sub    $0xc,%esp
    5555:	ff 75 0c             	pushl  0xc(%ebp)
    5558:	e8 95 fe ff ff       	call   53f2 <generateFixedDistanceTree>
    555d:	83 c4 10             	add    $0x10,%esp
}
    5560:	c9                   	leave  
    5561:	c3                   	ret    

00005562 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5562:	55                   	push   %ebp
    5563:	89 e5                	mov    %esp,%ebp
    5565:	53                   	push   %ebx
    5566:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5569:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    5570:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5577:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    557e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5585:	6a 0e                	push   $0xe
    5587:	ff 75 10             	pushl  0x10(%ebp)
    558a:	e8 37 e6 ff ff       	call   3bc6 <ensureBits17>
    558f:	83 c4 08             	add    $0x8,%esp
    5592:	85 c0                	test   %eax,%eax
    5594:	75 0a                	jne    55a0 <getTreeInflateDynamic+0x3e>
    5596:	b8 31 00 00 00       	mov    $0x31,%eax
    559b:	e9 ec 04 00 00       	jmp    5a8c <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    55a0:	6a 05                	push   $0x5
    55a2:	ff 75 10             	pushl  0x10(%ebp)
    55a5:	e8 f8 ea ff ff       	call   40a2 <readBits>
    55aa:	83 c4 08             	add    $0x8,%esp
    55ad:	05 01 01 00 00       	add    $0x101,%eax
    55b2:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    55b5:	6a 05                	push   $0x5
    55b7:	ff 75 10             	pushl  0x10(%ebp)
    55ba:	e8 e3 ea ff ff       	call   40a2 <readBits>
    55bf:	83 c4 08             	add    $0x8,%esp
    55c2:	83 c0 01             	add    $0x1,%eax
    55c5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    55c8:	6a 04                	push   $0x4
    55ca:	ff 75 10             	pushl  0x10(%ebp)
    55cd:	e8 d0 ea ff ff       	call   40a2 <readBits>
    55d2:	83 c4 08             	add    $0x8,%esp
    55d5:	83 c0 04             	add    $0x4,%eax
    55d8:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    55db:	83 ec 0c             	sub    $0xc,%esp
    55de:	6a 4c                	push   $0x4c
    55e0:	e8 31 dd ff ff       	call   3316 <lodepng_malloc>
    55e5:	83 c4 10             	add    $0x10,%esp
    55e8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    55eb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    55ef:	75 0a                	jne    55fb <getTreeInflateDynamic+0x99>
    55f1:	b8 53 00 00 00       	mov    $0x53,%eax
    55f6:	e9 91 04 00 00       	jmp    5a8c <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    55fb:	83 ec 0c             	sub    $0xc,%esp
    55fe:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5601:	50                   	push   %eax
    5602:	e8 03 ec ff ff       	call   420a <HuffmanTree_init>
    5607:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    560a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    560e:	0f 85 3c 04 00 00    	jne    5a50 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    5614:	8b 45 10             	mov    0x10(%ebp),%eax
    5617:	8b 48 08             	mov    0x8(%eax),%ecx
    561a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    561d:	89 d0                	mov    %edx,%eax
    561f:	01 c0                	add    %eax,%eax
    5621:	01 d0                	add    %edx,%eax
    5623:	89 c2                	mov    %eax,%edx
    5625:	8b 45 10             	mov    0x10(%ebp),%eax
    5628:	8b 40 0c             	mov    0xc(%eax),%eax
    562b:	83 ec 04             	sub    $0x4,%esp
    562e:	51                   	push   %ecx
    562f:	52                   	push   %edx
    5630:	50                   	push   %eax
    5631:	e8 f7 dd ff ff       	call   342d <lodepng_gtofl>
    5636:	83 c4 10             	add    $0x10,%esp
    5639:	85 c0                	test   %eax,%eax
    563b:	74 0c                	je     5649 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    563d:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5644:	e9 07 04 00 00       	jmp    5a50 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5649:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5650:	eb 3d                	jmp    568f <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5652:	83 ec 08             	sub    $0x8,%esp
    5655:	6a 03                	push   $0x3
    5657:	ff 75 10             	pushl  0x10(%ebp)
    565a:	e8 8b e4 ff ff       	call   3aea <ensureBits9>
    565f:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5662:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5665:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    566c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5673:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5676:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5679:	83 ec 08             	sub    $0x8,%esp
    567c:	6a 03                	push   $0x3
    567e:	ff 75 10             	pushl  0x10(%ebp)
    5681:	e8 1c ea ff ff       	call   40a2 <readBits>
    5686:	83 c4 10             	add    $0x10,%esp
    5689:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    568b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    568f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5692:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5695:	75 bb                	jne    5652 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5697:	8b 45 d0             	mov    -0x30(%ebp),%eax
    569a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    569d:	eb 20                	jmp    56bf <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    569f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56a2:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    56a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    56b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    56b3:	01 d0                	add    %edx,%eax
    56b5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    56bb:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    56bf:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    56c3:	75 da                	jne    569f <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    56c5:	6a 07                	push   $0x7
    56c7:	6a 13                	push   $0x13
    56c9:	ff 75 dc             	pushl  -0x24(%ebp)
    56cc:	8d 45 a8             	lea    -0x58(%ebp),%eax
    56cf:	50                   	push   %eax
    56d0:	e8 83 f2 ff ff       	call   4958 <HuffmanTree_makeFromLengths>
    56d5:	83 c4 10             	add    $0x10,%esp
    56d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    56db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56df:	0f 85 64 03 00 00    	jne    5a49 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    56e5:	83 ec 0c             	sub    $0xc,%esp
    56e8:	68 80 04 00 00       	push   $0x480
    56ed:	e8 24 dc ff ff       	call   3316 <lodepng_malloc>
    56f2:	83 c4 10             	add    $0x10,%esp
    56f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    56f8:	83 ec 0c             	sub    $0xc,%esp
    56fb:	68 80 00 00 00       	push   $0x80
    5700:	e8 11 dc ff ff       	call   3316 <lodepng_malloc>
    5705:	83 c4 10             	add    $0x10,%esp
    5708:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    570b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    570f:	74 06                	je     5717 <getTreeInflateDynamic+0x1b5>
    5711:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5715:	75 0c                	jne    5723 <getTreeInflateDynamic+0x1c1>
    5717:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    571e:	e9 2d 03 00 00       	jmp    5a50 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5723:	83 ec 04             	sub    $0x4,%esp
    5726:	68 80 04 00 00       	push   $0x480
    572b:	6a 00                	push   $0x0
    572d:	ff 75 e8             	pushl  -0x18(%ebp)
    5730:	e8 52 dc ff ff       	call   3387 <lodepng_memset>
    5735:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5738:	83 ec 04             	sub    $0x4,%esp
    573b:	68 80 00 00 00       	push   $0x80
    5740:	6a 00                	push   $0x0
    5742:	ff 75 e4             	pushl  -0x1c(%ebp)
    5745:	e8 3d dc ff ff       	call   3387 <lodepng_memset>
    574a:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    574d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5754:	e9 8d 02 00 00       	jmp    59e6 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5759:	83 ec 08             	sub    $0x8,%esp
    575c:	6a 16                	push   $0x16
    575e:	ff 75 10             	pushl  0x10(%ebp)
    5761:	e8 8c e5 ff ff       	call   3cf2 <ensureBits25>
    5766:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5769:	83 ec 08             	sub    $0x8,%esp
    576c:	8d 45 a8             	lea    -0x58(%ebp),%eax
    576f:	50                   	push   %eax
    5770:	ff 75 10             	pushl  0x10(%ebp)
    5773:	e8 f7 fc ff ff       	call   546f <huffmanDecodeSymbol>
    5778:	83 c4 10             	add    $0x10,%esp
    577b:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    577e:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5782:	77 3e                	ja     57c2 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5784:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5787:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    578a:	73 16                	jae    57a2 <getTreeInflateDynamic+0x240>
    578c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    578f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5796:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5799:	01 c2                	add    %eax,%edx
    579b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    579e:	89 02                	mov    %eax,(%edx)
    57a0:	eb 17                	jmp    57b9 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    57a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57a5:	2b 45 d8             	sub    -0x28(%ebp),%eax
    57a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    57b2:	01 c2                	add    %eax,%edx
    57b4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    57b7:	89 02                	mov    %eax,(%edx)
        ++i;
    57b9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    57bd:	e9 0b 02 00 00       	jmp    59cd <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    57c2:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    57c6:	0f 85 da 00 00 00    	jne    58a6 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    57cc:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    57d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    57d7:	75 0c                	jne    57e5 <getTreeInflateDynamic+0x283>
    57d9:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    57e0:	e9 12 02 00 00       	jmp    59f7 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    57e5:	83 ec 08             	sub    $0x8,%esp
    57e8:	6a 02                	push   $0x2
    57ea:	ff 75 10             	pushl  0x10(%ebp)
    57ed:	e8 b0 e8 ff ff       	call   40a2 <readBits>
    57f2:	83 c4 10             	add    $0x10,%esp
    57f5:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    57f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    57fb:	83 c0 01             	add    $0x1,%eax
    57fe:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5801:	76 1b                	jbe    581e <getTreeInflateDynamic+0x2bc>
    5803:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5806:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    580b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5812:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5815:	01 d0                	add    %edx,%eax
    5817:	8b 00                	mov    (%eax),%eax
    5819:	89 45 e0             	mov    %eax,-0x20(%ebp)
    581c:	eb 1c                	jmp    583a <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    581e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5821:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5824:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5829:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5830:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5833:	01 d0                	add    %edx,%eax
    5835:	8b 00                	mov    (%eax),%eax
    5837:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    583a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5841:	eb 56                	jmp    5899 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5843:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5846:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5849:	01 d0                	add    %edx,%eax
    584b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    584e:	77 0c                	ja     585c <getTreeInflateDynamic+0x2fa>
    5850:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5857:	e9 71 01 00 00       	jmp    59cd <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    585c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    585f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5862:	73 16                	jae    587a <getTreeInflateDynamic+0x318>
    5864:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    586e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5871:	01 c2                	add    %eax,%edx
    5873:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5876:	89 02                	mov    %eax,(%edx)
    5878:	eb 17                	jmp    5891 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    587a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    587d:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5880:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5887:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    588a:	01 c2                	add    %eax,%edx
    588c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    588f:	89 02                	mov    %eax,(%edx)
          ++i;
    5891:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5895:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5899:	8b 45 f0             	mov    -0x10(%ebp),%eax
    589c:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    589f:	72 a2                	jb     5843 <getTreeInflateDynamic+0x2e1>
    58a1:	e9 27 01 00 00       	jmp    59cd <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    58a6:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    58aa:	0f 85 88 00 00 00    	jne    5938 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    58b0:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    58b7:	83 ec 08             	sub    $0x8,%esp
    58ba:	6a 03                	push   $0x3
    58bc:	ff 75 10             	pushl  0x10(%ebp)
    58bf:	e8 de e7 ff ff       	call   40a2 <readBits>
    58c4:	83 c4 10             	add    $0x10,%esp
    58c7:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58d1:	eb 58                	jmp    592b <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    58d3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    58d6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    58d9:	01 d0                	add    %edx,%eax
    58db:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58de:	77 0c                	ja     58ec <getTreeInflateDynamic+0x38a>
    58e0:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    58e7:	e9 e1 00 00 00       	jmp    59cd <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    58ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58ef:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    58f2:	73 17                	jae    590b <getTreeInflateDynamic+0x3a9>
    58f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5901:	01 d0                	add    %edx,%eax
    5903:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5909:	eb 18                	jmp    5923 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    590b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    590e:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5911:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5918:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    591b:	01 d0                	add    %edx,%eax
    591d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5923:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5927:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    592b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    592e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5931:	72 a0                	jb     58d3 <getTreeInflateDynamic+0x371>
    5933:	e9 95 00 00 00       	jmp    59cd <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5938:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    593c:	0f 85 82 00 00 00    	jne    59c4 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5942:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5949:	83 ec 08             	sub    $0x8,%esp
    594c:	6a 07                	push   $0x7
    594e:	ff 75 10             	pushl  0x10(%ebp)
    5951:	e8 4c e7 ff ff       	call   40a2 <readBits>
    5956:	83 c4 10             	add    $0x10,%esp
    5959:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    595c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5963:	eb 55                	jmp    59ba <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5965:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5968:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    596b:	01 d0                	add    %edx,%eax
    596d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5970:	77 09                	ja     597b <getTreeInflateDynamic+0x419>
    5972:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5979:	eb 52                	jmp    59cd <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    597b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    597e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5981:	73 17                	jae    599a <getTreeInflateDynamic+0x438>
    5983:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5986:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    598d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5990:	01 d0                	add    %edx,%eax
    5992:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5998:	eb 18                	jmp    59b2 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    599a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    599d:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59a0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59aa:	01 d0                	add    %edx,%eax
    59ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    59b2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59b6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    59ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    59bd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    59c0:	72 a3                	jb     5965 <getTreeInflateDynamic+0x403>
    59c2:	eb 09                	jmp    59cd <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    59c4:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    59cb:	eb 2a                	jmp    59f7 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    59cd:	8b 45 10             	mov    0x10(%ebp),%eax
    59d0:	8b 50 0c             	mov    0xc(%eax),%edx
    59d3:	8b 45 10             	mov    0x10(%ebp),%eax
    59d6:	8b 40 08             	mov    0x8(%eax),%eax
    59d9:	39 c2                	cmp    %eax,%edx
    59db:	7e 09                	jle    59e6 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    59dd:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    59e4:	eb 11                	jmp    59f7 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    59e6:	8b 55 d8             	mov    -0x28(%ebp),%edx
    59e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    59ec:	01 d0                	add    %edx,%eax
    59ee:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    59f1:	0f 87 62 fd ff ff    	ja     5759 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    59f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    59fb:	75 4f                	jne    5a4c <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    59fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a00:	05 00 04 00 00       	add    $0x400,%eax
    5a05:	8b 00                	mov    (%eax),%eax
    5a07:	85 c0                	test   %eax,%eax
    5a09:	75 09                	jne    5a14 <getTreeInflateDynamic+0x4b2>
    5a0b:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5a12:	eb 3c                	jmp    5a50 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5a14:	6a 0f                	push   $0xf
    5a16:	68 20 01 00 00       	push   $0x120
    5a1b:	ff 75 e8             	pushl  -0x18(%ebp)
    5a1e:	ff 75 08             	pushl  0x8(%ebp)
    5a21:	e8 32 ef ff ff       	call   4958 <HuffmanTree_makeFromLengths>
    5a26:	83 c4 10             	add    $0x10,%esp
    5a29:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5a2c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a30:	75 1d                	jne    5a4f <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5a32:	6a 0f                	push   $0xf
    5a34:	6a 20                	push   $0x20
    5a36:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a39:	ff 75 0c             	pushl  0xc(%ebp)
    5a3c:	e8 17 ef ff ff       	call   4958 <HuffmanTree_makeFromLengths>
    5a41:	83 c4 10             	add    $0x10,%esp
    5a44:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5a47:	eb 07                	jmp    5a50 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5a49:	90                   	nop
    5a4a:	eb 04                	jmp    5a50 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a4c:	90                   	nop
    5a4d:	eb 01                	jmp    5a50 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5a4f:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5a50:	83 ec 0c             	sub    $0xc,%esp
    5a53:	ff 75 dc             	pushl  -0x24(%ebp)
    5a56:	e8 dc d8 ff ff       	call   3337 <lodepng_free>
    5a5b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5a5e:	83 ec 0c             	sub    $0xc,%esp
    5a61:	ff 75 e8             	pushl  -0x18(%ebp)
    5a64:	e8 ce d8 ff ff       	call   3337 <lodepng_free>
    5a69:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5a6c:	83 ec 0c             	sub    $0xc,%esp
    5a6f:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a72:	e8 c0 d8 ff ff       	call   3337 <lodepng_free>
    5a77:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5a7a:	83 ec 0c             	sub    $0xc,%esp
    5a7d:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5a80:	50                   	push   %eax
    5a81:	e8 b1 e7 ff ff       	call   4237 <HuffmanTree_cleanup>
    5a86:	83 c4 10             	add    $0x10,%esp

  return error;
    5a89:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5a8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5a8f:	c9                   	leave  
    5a90:	c3                   	ret    

00005a91 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5a91:	55                   	push   %ebp
    5a92:	89 e5                	mov    %esp,%ebp
    5a94:	53                   	push   %ebx
    5a95:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5a98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5a9f:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5aa2:	50                   	push   %eax
    5aa3:	e8 62 e7 ff ff       	call   420a <HuffmanTree_init>
    5aa8:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5aab:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5aae:	50                   	push   %eax
    5aaf:	e8 56 e7 ff ff       	call   420a <HuffmanTree_init>
    5ab4:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5ab7:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5abb:	75 1b                	jne    5ad8 <inflateHuffmanBlock+0x47>
    5abd:	83 ec 08             	sub    $0x8,%esp
    5ac0:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ac3:	50                   	push   %eax
    5ac4:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ac7:	50                   	push   %eax
    5ac8:	e8 63 fa ff ff       	call   5530 <getTreeInflateFixed>
    5acd:	83 c4 10             	add    $0x10,%esp
    5ad0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5ad3:	e9 9a 02 00 00       	jmp    5d72 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5ad8:	83 ec 04             	sub    $0x4,%esp
    5adb:	ff 75 0c             	pushl  0xc(%ebp)
    5ade:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ae1:	50                   	push   %eax
    5ae2:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ae5:	50                   	push   %eax
    5ae6:	e8 77 fa ff ff       	call   5562 <getTreeInflateDynamic>
    5aeb:	83 c4 10             	add    $0x10,%esp
    5aee:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5af1:	e9 7c 02 00 00       	jmp    5d72 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5af6:	83 ec 08             	sub    $0x8,%esp
    5af9:	6a 14                	push   $0x14
    5afb:	ff 75 0c             	pushl  0xc(%ebp)
    5afe:	e8 ef e1 ff ff       	call   3cf2 <ensureBits25>
    5b03:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5b06:	83 ec 08             	sub    $0x8,%esp
    5b09:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b0c:	50                   	push   %eax
    5b0d:	ff 75 0c             	pushl  0xc(%ebp)
    5b10:	e8 5a f9 ff ff       	call   546f <huffmanDecodeSymbol>
    5b15:	83 c4 10             	add    $0x10,%esp
    5b18:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5b1b:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5b22:	77 42                	ja     5b66 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5b24:	8b 45 08             	mov    0x8(%ebp),%eax
    5b27:	8b 40 04             	mov    0x4(%eax),%eax
    5b2a:	83 c0 01             	add    $0x1,%eax
    5b2d:	83 ec 08             	sub    $0x8,%esp
    5b30:	50                   	push   %eax
    5b31:	ff 75 08             	pushl  0x8(%ebp)
    5b34:	e8 37 da ff ff       	call   3570 <ucvector_resize>
    5b39:	83 c4 10             	add    $0x10,%esp
    5b3c:	85 c0                	test   %eax,%eax
    5b3e:	75 0c                	jne    5b4c <inflateHuffmanBlock+0xbb>
    5b40:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5b47:	e9 33 02 00 00       	jmp    5d7f <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5b4c:	8b 45 08             	mov    0x8(%ebp),%eax
    5b4f:	8b 10                	mov    (%eax),%edx
    5b51:	8b 45 08             	mov    0x8(%ebp),%eax
    5b54:	8b 40 04             	mov    0x4(%eax),%eax
    5b57:	83 e8 01             	sub    $0x1,%eax
    5b5a:	01 d0                	add    %edx,%eax
    5b5c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5b5f:	88 10                	mov    %dl,(%eax)
    5b61:	e9 d9 01 00 00       	jmp    5d3f <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5b66:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5b6d:	0f 86 ba 01 00 00    	jbe    5d2d <inflateHuffmanBlock+0x29c>
    5b73:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5b7a:	0f 87 ad 01 00 00    	ja     5d2d <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5b80:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5b83:	2d 01 01 00 00       	sub    $0x101,%eax
    5b88:	8b 04 85 20 9d 01 00 	mov    0x19d20(,%eax,4),%eax
    5b8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5b92:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5b95:	2d 01 01 00 00       	sub    $0x101,%eax
    5b9a:	8b 04 85 a0 9d 01 00 	mov    0x19da0(,%eax,4),%eax
    5ba1:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5ba4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5ba8:	74 1c                	je     5bc6 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5baa:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5bad:	83 ec 08             	sub    $0x8,%esp
    5bb0:	50                   	push   %eax
    5bb1:	ff 75 0c             	pushl  0xc(%ebp)
    5bb4:	e8 e9 e4 ff ff       	call   40a2 <readBits>
    5bb9:	83 c4 10             	add    $0x10,%esp
    5bbc:	89 c2                	mov    %eax,%edx
    5bbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5bc1:	01 d0                	add    %edx,%eax
    5bc3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5bc6:	83 ec 08             	sub    $0x8,%esp
    5bc9:	6a 1c                	push   $0x1c
    5bcb:	ff 75 0c             	pushl  0xc(%ebp)
    5bce:	e8 98 e2 ff ff       	call   3e6b <ensureBits32>
    5bd3:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5bd6:	83 ec 08             	sub    $0x8,%esp
    5bd9:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5bdc:	50                   	push   %eax
    5bdd:	ff 75 0c             	pushl  0xc(%ebp)
    5be0:	e8 8a f8 ff ff       	call   546f <huffmanDecodeSymbol>
    5be5:	83 c4 10             	add    $0x10,%esp
    5be8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5beb:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5bef:	76 1e                	jbe    5c0f <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5bf1:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5bf5:	77 0c                	ja     5c03 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5bf7:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5bfe:	e9 7c 01 00 00       	jmp    5d7f <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5c03:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5c0a:	e9 70 01 00 00       	jmp    5d7f <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5c0f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c12:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    5c19:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5c1c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c1f:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    5c26:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5c29:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5c2d:	74 15                	je     5c44 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5c2f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5c32:	83 ec 08             	sub    $0x8,%esp
    5c35:	50                   	push   %eax
    5c36:	ff 75 0c             	pushl  0xc(%ebp)
    5c39:	e8 64 e4 ff ff       	call   40a2 <readBits>
    5c3e:	83 c4 10             	add    $0x10,%esp
    5c41:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5c44:	8b 45 08             	mov    0x8(%ebp),%eax
    5c47:	8b 40 04             	mov    0x4(%eax),%eax
    5c4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5c4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c50:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5c53:	76 0c                	jbe    5c61 <inflateHuffmanBlock+0x1d0>
    5c55:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5c5c:	e9 1e 01 00 00       	jmp    5d7f <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5c61:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c64:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5c67:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5c6a:	8b 45 08             	mov    0x8(%ebp),%eax
    5c6d:	8b 50 04             	mov    0x4(%eax),%edx
    5c70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c73:	01 d0                	add    %edx,%eax
    5c75:	83 ec 08             	sub    $0x8,%esp
    5c78:	50                   	push   %eax
    5c79:	ff 75 08             	pushl  0x8(%ebp)
    5c7c:	e8 ef d8 ff ff       	call   3570 <ucvector_resize>
    5c81:	83 c4 10             	add    $0x10,%esp
    5c84:	85 c0                	test   %eax,%eax
    5c86:	75 0c                	jne    5c94 <inflateHuffmanBlock+0x203>
    5c88:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5c8f:	e9 eb 00 00 00       	jmp    5d7f <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5c94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c97:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5c9a:	73 6b                	jae    5d07 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5c9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c9f:	8b 55 08             	mov    0x8(%ebp),%edx
    5ca2:	8b 0a                	mov    (%edx),%ecx
    5ca4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5ca7:	01 d1                	add    %edx,%ecx
    5ca9:	8b 55 08             	mov    0x8(%ebp),%edx
    5cac:	8b 1a                	mov    (%edx),%ebx
    5cae:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cb1:	01 da                	add    %ebx,%edx
    5cb3:	83 ec 04             	sub    $0x4,%esp
    5cb6:	50                   	push   %eax
    5cb7:	51                   	push   %ecx
    5cb8:	52                   	push   %edx
    5cb9:	e8 96 d6 ff ff       	call   3354 <lodepng_memcpy>
    5cbe:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5cc1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cc7:	01 d0                	add    %edx,%eax
    5cc9:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5ccc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ccf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5cd2:	eb 29                	jmp    5cfd <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5cd4:	8b 45 08             	mov    0x8(%ebp),%eax
    5cd7:	8b 08                	mov    (%eax),%ecx
    5cd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cdc:	8d 50 01             	lea    0x1(%eax),%edx
    5cdf:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5ce2:	01 c1                	add    %eax,%ecx
    5ce4:	8b 45 08             	mov    0x8(%ebp),%eax
    5ce7:	8b 18                	mov    (%eax),%ebx
    5ce9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cec:	8d 50 01             	lea    0x1(%eax),%edx
    5cef:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5cf2:	01 d8                	add    %ebx,%eax
    5cf4:	0f b6 00             	movzbl (%eax),%eax
    5cf7:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5cf9:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5cfd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d00:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5d03:	7c cf                	jl     5cd4 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d05:	eb 38                	jmp    5d3f <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5d07:	8b 45 08             	mov    0x8(%ebp),%eax
    5d0a:	8b 10                	mov    (%eax),%edx
    5d0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d0f:	01 c2                	add    %eax,%edx
    5d11:	8b 45 08             	mov    0x8(%ebp),%eax
    5d14:	8b 08                	mov    (%eax),%ecx
    5d16:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d19:	01 c8                	add    %ecx,%eax
    5d1b:	83 ec 04             	sub    $0x4,%esp
    5d1e:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d21:	52                   	push   %edx
    5d22:	50                   	push   %eax
    5d23:	e8 2c d6 ff ff       	call   3354 <lodepng_memcpy>
    5d28:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d2b:	eb 12                	jmp    5d3f <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5d2d:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5d34:	74 48                	je     5d7e <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5d36:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5d3d:	eb 40                	jmp    5d7f <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5d3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d42:	8b 50 0c             	mov    0xc(%eax),%edx
    5d45:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d48:	8b 40 08             	mov    0x8(%eax),%eax
    5d4b:	39 c2                	cmp    %eax,%edx
    5d4d:	7e 09                	jle    5d58 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5d4f:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5d56:	eb 27                	jmp    5d7f <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5d58:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5d5c:	74 14                	je     5d72 <inflateHuffmanBlock+0x2e1>
    5d5e:	8b 45 08             	mov    0x8(%ebp),%eax
    5d61:	8b 40 04             	mov    0x4(%eax),%eax
    5d64:	3b 45 14             	cmp    0x14(%ebp),%eax
    5d67:	7e 09                	jle    5d72 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5d69:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5d70:	eb 0d                	jmp    5d7f <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5d72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5d76:	0f 84 7a fd ff ff    	je     5af6 <inflateHuffmanBlock+0x65>
    5d7c:	eb 01                	jmp    5d7f <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5d7e:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5d7f:	83 ec 0c             	sub    $0xc,%esp
    5d82:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5d85:	50                   	push   %eax
    5d86:	e8 ac e4 ff ff       	call   4237 <HuffmanTree_cleanup>
    5d8b:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5d8e:	83 ec 0c             	sub    $0xc,%esp
    5d91:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5d94:	50                   	push   %eax
    5d95:	e8 9d e4 ff ff       	call   4237 <HuffmanTree_cleanup>
    5d9a:	83 c4 10             	add    $0x10,%esp

  return error;
    5d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5da0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5da3:	c9                   	leave  
    5da4:	c3                   	ret    

00005da5 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5da5:	55                   	push   %ebp
    5da6:	89 e5                	mov    %esp,%ebp
    5da8:	53                   	push   %ebx
    5da9:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5dac:	8b 45 0c             	mov    0xc(%ebp),%eax
    5daf:	8b 40 04             	mov    0x4(%eax),%eax
    5db2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5db5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5dbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dbf:	8b 40 0c             	mov    0xc(%eax),%eax
    5dc2:	83 c0 07             	add    $0x7,%eax
    5dc5:	c1 e8 03             	shr    $0x3,%eax
    5dc8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5dcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5dce:	83 c0 04             	add    $0x4,%eax
    5dd1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5dd4:	7c 0a                	jl     5de0 <inflateNoCompression+0x3b>
    5dd6:	b8 34 00 00 00       	mov    $0x34,%eax
    5ddb:	e9 01 01 00 00       	jmp    5ee1 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5de0:	8b 45 0c             	mov    0xc(%ebp),%eax
    5de3:	8b 10                	mov    (%eax),%edx
    5de5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5de8:	01 d0                	add    %edx,%eax
    5dea:	0f b6 00             	movzbl (%eax),%eax
    5ded:	0f b6 d0             	movzbl %al,%edx
    5df0:	8b 45 0c             	mov    0xc(%ebp),%eax
    5df3:	8b 00                	mov    (%eax),%eax
    5df5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5df8:	83 c1 01             	add    $0x1,%ecx
    5dfb:	01 c8                	add    %ecx,%eax
    5dfd:	0f b6 00             	movzbl (%eax),%eax
    5e00:	0f b6 c0             	movzbl %al,%eax
    5e03:	c1 e0 08             	shl    $0x8,%eax
    5e06:	01 d0                	add    %edx,%eax
    5e08:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5e0b:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e12:	8b 10                	mov    (%eax),%edx
    5e14:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e17:	01 d0                	add    %edx,%eax
    5e19:	0f b6 00             	movzbl (%eax),%eax
    5e1c:	0f b6 d0             	movzbl %al,%edx
    5e1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e22:	8b 00                	mov    (%eax),%eax
    5e24:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e27:	83 c1 01             	add    $0x1,%ecx
    5e2a:	01 c8                	add    %ecx,%eax
    5e2c:	0f b6 00             	movzbl (%eax),%eax
    5e2f:	0f b6 c0             	movzbl %al,%eax
    5e32:	c1 e0 08             	shl    $0x8,%eax
    5e35:	01 d0                	add    %edx,%eax
    5e37:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5e3a:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5e3e:	8b 45 10             	mov    0x10(%ebp),%eax
    5e41:	8b 40 04             	mov    0x4(%eax),%eax
    5e44:	85 c0                	test   %eax,%eax
    5e46:	75 19                	jne    5e61 <inflateNoCompression+0xbc>
    5e48:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5e4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e4e:	01 d0                	add    %edx,%eax
    5e50:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5e55:	74 0a                	je     5e61 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5e57:	b8 15 00 00 00       	mov    $0x15,%eax
    5e5c:	e9 80 00 00 00       	jmp    5ee1 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5e61:	8b 45 08             	mov    0x8(%ebp),%eax
    5e64:	8b 40 04             	mov    0x4(%eax),%eax
    5e67:	89 c2                	mov    %eax,%edx
    5e69:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e6c:	01 d0                	add    %edx,%eax
    5e6e:	50                   	push   %eax
    5e6f:	ff 75 08             	pushl  0x8(%ebp)
    5e72:	e8 f9 d6 ff ff       	call   3570 <ucvector_resize>
    5e77:	83 c4 08             	add    $0x8,%esp
    5e7a:	85 c0                	test   %eax,%eax
    5e7c:	75 07                	jne    5e85 <inflateNoCompression+0xe0>
    5e7e:	b8 53 00 00 00       	mov    $0x53,%eax
    5e83:	eb 5c                	jmp    5ee1 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5e85:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5e88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e8b:	01 c2                	add    %eax,%edx
    5e8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5e90:	39 c2                	cmp    %eax,%edx
    5e92:	76 07                	jbe    5e9b <inflateNoCompression+0xf6>
    5e94:	b8 17 00 00 00       	mov    $0x17,%eax
    5e99:	eb 46                	jmp    5ee1 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5e9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e9e:	8b 55 0c             	mov    0xc(%ebp),%edx
    5ea1:	8b 0a                	mov    (%edx),%ecx
    5ea3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ea6:	01 d1                	add    %edx,%ecx
    5ea8:	8b 55 08             	mov    0x8(%ebp),%edx
    5eab:	8b 1a                	mov    (%edx),%ebx
    5ead:	8b 55 08             	mov    0x8(%ebp),%edx
    5eb0:	8b 52 04             	mov    0x4(%edx),%edx
    5eb3:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5eb6:	01 da                	add    %ebx,%edx
    5eb8:	50                   	push   %eax
    5eb9:	51                   	push   %ecx
    5eba:	52                   	push   %edx
    5ebb:	e8 94 d4 ff ff       	call   3354 <lodepng_memcpy>
    5ec0:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5ec3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ec6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ec9:	01 d0                	add    %edx,%eax
    5ecb:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5ece:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ed1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5ed8:	8b 45 0c             	mov    0xc(%ebp),%eax
    5edb:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5ee1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5ee4:	c9                   	leave  
    5ee5:	c3                   	ret    

00005ee6 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5ee6:	55                   	push   %ebp
    5ee7:	89 e5                	mov    %esp,%ebp
    5ee9:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5eec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5ef3:	ff 75 10             	pushl  0x10(%ebp)
    5ef6:	ff 75 0c             	pushl  0xc(%ebp)
    5ef9:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5efc:	50                   	push   %eax
    5efd:	e8 77 db ff ff       	call   3a79 <LodePNGBitReader_init>
    5f02:	83 c4 0c             	add    $0xc,%esp
    5f05:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5f08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5f0c:	0f 84 b9 00 00 00    	je     5fcb <lodepng_inflatev+0xe5>
    5f12:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f15:	e9 c1 00 00 00       	jmp    5fdb <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    5f1a:	6a 03                	push   $0x3
    5f1c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f1f:	50                   	push   %eax
    5f20:	e8 c5 db ff ff       	call   3aea <ensureBits9>
    5f25:	83 c4 08             	add    $0x8,%esp
    5f28:	85 c0                	test   %eax,%eax
    5f2a:	75 0a                	jne    5f36 <lodepng_inflatev+0x50>
    5f2c:	b8 34 00 00 00       	mov    $0x34,%eax
    5f31:	e9 a5 00 00 00       	jmp    5fdb <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    5f36:	6a 01                	push   $0x1
    5f38:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f3b:	50                   	push   %eax
    5f3c:	e8 61 e1 ff ff       	call   40a2 <readBits>
    5f41:	83 c4 08             	add    $0x8,%esp
    5f44:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    5f47:	6a 02                	push   $0x2
    5f49:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f4c:	50                   	push   %eax
    5f4d:	e8 50 e1 ff ff       	call   40a2 <readBits>
    5f52:	83 c4 08             	add    $0x8,%esp
    5f55:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    5f58:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    5f5c:	75 07                	jne    5f65 <lodepng_inflatev+0x7f>
    5f5e:	b8 14 00 00 00       	mov    $0x14,%eax
    5f63:	eb 76                	jmp    5fdb <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    5f65:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5f69:	75 17                	jne    5f82 <lodepng_inflatev+0x9c>
    5f6b:	ff 75 14             	pushl  0x14(%ebp)
    5f6e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f71:	50                   	push   %eax
    5f72:	ff 75 08             	pushl  0x8(%ebp)
    5f75:	e8 2b fe ff ff       	call   5da5 <inflateNoCompression>
    5f7a:	83 c4 0c             	add    $0xc,%esp
    5f7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    5f80:	eb 1c                	jmp    5f9e <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    5f82:	8b 45 14             	mov    0x14(%ebp),%eax
    5f85:	8b 40 08             	mov    0x8(%eax),%eax
    5f88:	50                   	push   %eax
    5f89:	ff 75 ec             	pushl  -0x14(%ebp)
    5f8c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f8f:	50                   	push   %eax
    5f90:	ff 75 08             	pushl  0x8(%ebp)
    5f93:	e8 f9 fa ff ff       	call   5a91 <inflateHuffmanBlock>
    5f98:	83 c4 10             	add    $0x10,%esp
    5f9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    5f9e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fa2:	75 21                	jne    5fc5 <lodepng_inflatev+0xdf>
    5fa4:	8b 45 14             	mov    0x14(%ebp),%eax
    5fa7:	8b 40 08             	mov    0x8(%eax),%eax
    5faa:	85 c0                	test   %eax,%eax
    5fac:	74 17                	je     5fc5 <lodepng_inflatev+0xdf>
    5fae:	8b 45 08             	mov    0x8(%ebp),%eax
    5fb1:	8b 50 04             	mov    0x4(%eax),%edx
    5fb4:	8b 45 14             	mov    0x14(%ebp),%eax
    5fb7:	8b 40 08             	mov    0x8(%eax),%eax
    5fba:	39 c2                	cmp    %eax,%edx
    5fbc:	7e 07                	jle    5fc5 <lodepng_inflatev+0xdf>
    5fbe:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    5fc5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fc9:	75 0c                	jne    5fd7 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    5fcb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5fcf:	0f 84 45 ff ff ff    	je     5f1a <lodepng_inflatev+0x34>
    5fd5:	eb 01                	jmp    5fd8 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    5fd7:	90                   	nop
  }

  return error;
    5fd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5fdb:	c9                   	leave  
    5fdc:	c3                   	ret    

00005fdd <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    5fdd:	55                   	push   %ebp
    5fde:	89 e5                	mov    %esp,%ebp
    5fe0:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    5fe3:	8b 45 0c             	mov    0xc(%ebp),%eax
    5fe6:	8b 08                	mov    (%eax),%ecx
    5fe8:	8b 45 08             	mov    0x8(%ebp),%eax
    5feb:	8b 10                	mov    (%eax),%edx
    5fed:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5ff0:	51                   	push   %ecx
    5ff1:	52                   	push   %edx
    5ff2:	50                   	push   %eax
    5ff3:	e8 df d5 ff ff       	call   35d7 <ucvector_init>
    5ff8:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    5ffb:	ff 75 18             	pushl  0x18(%ebp)
    5ffe:	ff 75 14             	pushl  0x14(%ebp)
    6001:	ff 75 10             	pushl  0x10(%ebp)
    6004:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6007:	50                   	push   %eax
    6008:	e8 d9 fe ff ff       	call   5ee6 <lodepng_inflatev>
    600d:	83 c4 10             	add    $0x10,%esp
    6010:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    6013:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6016:	8b 45 08             	mov    0x8(%ebp),%eax
    6019:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    601b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    601e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6021:	89 10                	mov    %edx,(%eax)
  return error;
    6023:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6026:	c9                   	leave  
    6027:	c3                   	ret    

00006028 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6028:	55                   	push   %ebp
    6029:	89 e5                	mov    %esp,%ebp
    602b:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    602e:	8b 45 14             	mov    0x14(%ebp),%eax
    6031:	8b 40 10             	mov    0x10(%eax),%eax
    6034:	85 c0                	test   %eax,%eax
    6036:	74 64                	je     609c <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6038:	8b 45 14             	mov    0x14(%ebp),%eax
    603b:	8b 40 10             	mov    0x10(%eax),%eax
    603e:	8b 55 08             	mov    0x8(%ebp),%edx
    6041:	8d 4a 04             	lea    0x4(%edx),%ecx
    6044:	8b 55 08             	mov    0x8(%ebp),%edx
    6047:	83 ec 0c             	sub    $0xc,%esp
    604a:	ff 75 14             	pushl  0x14(%ebp)
    604d:	ff 75 10             	pushl  0x10(%ebp)
    6050:	ff 75 0c             	pushl  0xc(%ebp)
    6053:	51                   	push   %ecx
    6054:	52                   	push   %edx
    6055:	ff d0                	call   *%eax
    6057:	83 c4 20             	add    $0x20,%esp
    605a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    605d:	8b 45 08             	mov    0x8(%ebp),%eax
    6060:	8b 50 04             	mov    0x4(%eax),%edx
    6063:	8b 45 08             	mov    0x8(%ebp),%eax
    6066:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6069:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    606d:	74 28                	je     6097 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    606f:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6076:	8b 45 14             	mov    0x14(%ebp),%eax
    6079:	8b 40 08             	mov    0x8(%eax),%eax
    607c:	85 c0                	test   %eax,%eax
    607e:	74 17                	je     6097 <inflatev+0x6f>
    6080:	8b 45 08             	mov    0x8(%ebp),%eax
    6083:	8b 50 04             	mov    0x4(%eax),%edx
    6086:	8b 45 14             	mov    0x14(%ebp),%eax
    6089:	8b 40 08             	mov    0x8(%eax),%eax
    608c:	39 c2                	cmp    %eax,%edx
    608e:	7e 07                	jle    6097 <inflatev+0x6f>
    6090:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6097:	8b 45 f4             	mov    -0xc(%ebp),%eax
    609a:	eb 14                	jmp    60b0 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    609c:	ff 75 14             	pushl  0x14(%ebp)
    609f:	ff 75 10             	pushl  0x10(%ebp)
    60a2:	ff 75 0c             	pushl  0xc(%ebp)
    60a5:	ff 75 08             	pushl  0x8(%ebp)
    60a8:	e8 39 fe ff ff       	call   5ee6 <lodepng_inflatev>
    60ad:	83 c4 10             	add    $0x10,%esp
  }
}
    60b0:	c9                   	leave  
    60b1:	c3                   	ret    

000060b2 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    60b2:	55                   	push   %ebp
    60b3:	89 e5                	mov    %esp,%ebp
    60b5:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    60b8:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    60bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    60c2:	83 e8 01             	sub    $0x1,%eax
    60c5:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    60c8:	eb 39                	jmp    6103 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    60ca:	8b 55 fc             	mov    -0x4(%ebp),%edx
    60cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    60d0:	01 d0                	add    %edx,%eax
    60d2:	d1 f8                	sar    %eax
    60d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    60d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60e1:	8b 45 08             	mov    0x8(%ebp),%eax
    60e4:	01 d0                	add    %edx,%eax
    60e6:	8b 10                	mov    (%eax),%edx
    60e8:	8b 45 10             	mov    0x10(%ebp),%eax
    60eb:	39 c2                	cmp    %eax,%edx
    60ed:	72 0b                	jb     60fa <searchCodeIndex+0x48>
    60ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60f2:	83 e8 01             	sub    $0x1,%eax
    60f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    60f8:	eb 09                	jmp    6103 <searchCodeIndex+0x51>
    else left = mid + 1;
    60fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60fd:	83 c0 01             	add    $0x1,%eax
    6100:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    6103:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6106:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6109:	7e bf                	jle    60ca <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    610b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    610e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6111:	7d 18                	jge    612b <searchCodeIndex+0x79>
    6113:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6116:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    611d:	8b 45 08             	mov    0x8(%ebp),%eax
    6120:	01 d0                	add    %edx,%eax
    6122:	8b 10                	mov    (%eax),%edx
    6124:	8b 45 10             	mov    0x10(%ebp),%eax
    6127:	39 c2                	cmp    %eax,%edx
    6129:	76 04                	jbe    612f <searchCodeIndex+0x7d>
    612b:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    612f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6132:	c9                   	leave  
    6133:	c3                   	ret    

00006134 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    6134:	55                   	push   %ebp
    6135:	89 e5                	mov    %esp,%ebp
    6137:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    613a:	ff 75 0c             	pushl  0xc(%ebp)
    613d:	6a 1d                	push   $0x1d
    613f:	68 20 9d 01 00       	push   $0x19d20
    6144:	e8 69 ff ff ff       	call   60b2 <searchCodeIndex>
    6149:	83 c4 0c             	add    $0xc,%esp
    614c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    614f:	8b 55 0c             	mov    0xc(%ebp),%edx
    6152:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6155:	8b 04 85 20 9d 01 00 	mov    0x19d20(,%eax,4),%eax
    615c:	29 c2                	sub    %eax,%edx
    615e:	89 d0                	mov    %edx,%eax
    6160:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6163:	ff 75 10             	pushl  0x10(%ebp)
    6166:	6a 1e                	push   $0x1e
    6168:	68 20 9e 01 00       	push   $0x19e20
    616d:	e8 40 ff ff ff       	call   60b2 <searchCodeIndex>
    6172:	83 c4 0c             	add    $0xc,%esp
    6175:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6178:	8b 55 10             	mov    0x10(%ebp),%edx
    617b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    617e:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    6185:	29 c2                	sub    %eax,%edx
    6187:	89 d0                	mov    %edx,%eax
    6189:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    618c:	8b 45 08             	mov    0x8(%ebp),%eax
    618f:	8b 40 04             	mov    0x4(%eax),%eax
    6192:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6195:	8b 45 08             	mov    0x8(%ebp),%eax
    6198:	8b 40 04             	mov    0x4(%eax),%eax
    619b:	83 c0 04             	add    $0x4,%eax
    619e:	50                   	push   %eax
    619f:	ff 75 08             	pushl  0x8(%ebp)
    61a2:	e8 f0 d2 ff ff       	call   3497 <uivector_resize>
    61a7:	83 c4 08             	add    $0x8,%esp
    61aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    61ad:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    61b1:	74 57                	je     620a <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    61b3:	8b 45 08             	mov    0x8(%ebp),%eax
    61b6:	8b 00                	mov    (%eax),%eax
    61b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61bb:	c1 e2 02             	shl    $0x2,%edx
    61be:	01 d0                	add    %edx,%eax
    61c0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    61c3:	81 c2 01 01 00 00    	add    $0x101,%edx
    61c9:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    61cb:	8b 45 08             	mov    0x8(%ebp),%eax
    61ce:	8b 00                	mov    (%eax),%eax
    61d0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61d3:	83 c2 01             	add    $0x1,%edx
    61d6:	c1 e2 02             	shl    $0x2,%edx
    61d9:	01 c2                	add    %eax,%edx
    61db:	8b 45 f8             	mov    -0x8(%ebp),%eax
    61de:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    61e0:	8b 45 08             	mov    0x8(%ebp),%eax
    61e3:	8b 00                	mov    (%eax),%eax
    61e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61e8:	83 c2 02             	add    $0x2,%edx
    61eb:	c1 e2 02             	shl    $0x2,%edx
    61ee:	01 c2                	add    %eax,%edx
    61f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61f3:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    61f5:	8b 45 08             	mov    0x8(%ebp),%eax
    61f8:	8b 00                	mov    (%eax),%eax
    61fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61fd:	83 c2 03             	add    $0x3,%edx
    6200:	c1 e2 02             	shl    $0x2,%edx
    6203:	01 c2                	add    %eax,%edx
    6205:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6208:	89 02                	mov    %eax,(%edx)
  }
}
    620a:	90                   	nop
    620b:	c9                   	leave  
    620c:	c3                   	ret    

0000620d <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    620d:	55                   	push   %ebp
    620e:	89 e5                	mov    %esp,%ebp
    6210:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    6213:	b8 00 00 01 00       	mov    $0x10000,%eax
    6218:	c1 e0 02             	shl    $0x2,%eax
    621b:	83 ec 0c             	sub    $0xc,%esp
    621e:	50                   	push   %eax
    621f:	e8 f2 d0 ff ff       	call   3316 <lodepng_malloc>
    6224:	83 c4 10             	add    $0x10,%esp
    6227:	89 c2                	mov    %eax,%edx
    6229:	8b 45 08             	mov    0x8(%ebp),%eax
    622c:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    622e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6231:	c1 e0 02             	shl    $0x2,%eax
    6234:	83 ec 0c             	sub    $0xc,%esp
    6237:	50                   	push   %eax
    6238:	e8 d9 d0 ff ff       	call   3316 <lodepng_malloc>
    623d:	83 c4 10             	add    $0x10,%esp
    6240:	89 c2                	mov    %eax,%edx
    6242:	8b 45 08             	mov    0x8(%ebp),%eax
    6245:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6248:	8b 45 0c             	mov    0xc(%ebp),%eax
    624b:	01 c0                	add    %eax,%eax
    624d:	83 ec 0c             	sub    $0xc,%esp
    6250:	50                   	push   %eax
    6251:	e8 c0 d0 ff ff       	call   3316 <lodepng_malloc>
    6256:	83 c4 10             	add    $0x10,%esp
    6259:	89 c2                	mov    %eax,%edx
    625b:	8b 45 08             	mov    0x8(%ebp),%eax
    625e:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6261:	8b 45 0c             	mov    0xc(%ebp),%eax
    6264:	01 c0                	add    %eax,%eax
    6266:	83 ec 0c             	sub    $0xc,%esp
    6269:	50                   	push   %eax
    626a:	e8 a7 d0 ff ff       	call   3316 <lodepng_malloc>
    626f:	83 c4 10             	add    $0x10,%esp
    6272:	89 c2                	mov    %eax,%edx
    6274:	8b 45 08             	mov    0x8(%ebp),%eax
    6277:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    627a:	b8 02 01 00 00       	mov    $0x102,%eax
    627f:	83 c0 01             	add    $0x1,%eax
    6282:	c1 e0 02             	shl    $0x2,%eax
    6285:	83 ec 0c             	sub    $0xc,%esp
    6288:	50                   	push   %eax
    6289:	e8 88 d0 ff ff       	call   3316 <lodepng_malloc>
    628e:	83 c4 10             	add    $0x10,%esp
    6291:	89 c2                	mov    %eax,%edx
    6293:	8b 45 08             	mov    0x8(%ebp),%eax
    6296:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6299:	8b 45 0c             	mov    0xc(%ebp),%eax
    629c:	01 c0                	add    %eax,%eax
    629e:	83 ec 0c             	sub    $0xc,%esp
    62a1:	50                   	push   %eax
    62a2:	e8 6f d0 ff ff       	call   3316 <lodepng_malloc>
    62a7:	83 c4 10             	add    $0x10,%esp
    62aa:	89 c2                	mov    %eax,%edx
    62ac:	8b 45 08             	mov    0x8(%ebp),%eax
    62af:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    62b2:	8b 45 08             	mov    0x8(%ebp),%eax
    62b5:	8b 00                	mov    (%eax),%eax
    62b7:	85 c0                	test   %eax,%eax
    62b9:	74 32                	je     62ed <hash_init+0xe0>
    62bb:	8b 45 08             	mov    0x8(%ebp),%eax
    62be:	8b 40 04             	mov    0x4(%eax),%eax
    62c1:	85 c0                	test   %eax,%eax
    62c3:	74 28                	je     62ed <hash_init+0xe0>
    62c5:	8b 45 08             	mov    0x8(%ebp),%eax
    62c8:	8b 40 08             	mov    0x8(%eax),%eax
    62cb:	85 c0                	test   %eax,%eax
    62cd:	74 1e                	je     62ed <hash_init+0xe0>
    62cf:	8b 45 08             	mov    0x8(%ebp),%eax
    62d2:	8b 40 0c             	mov    0xc(%eax),%eax
    62d5:	85 c0                	test   %eax,%eax
    62d7:	74 14                	je     62ed <hash_init+0xe0>
    62d9:	8b 45 08             	mov    0x8(%ebp),%eax
    62dc:	8b 40 10             	mov    0x10(%eax),%eax
    62df:	85 c0                	test   %eax,%eax
    62e1:	74 0a                	je     62ed <hash_init+0xe0>
    62e3:	8b 45 08             	mov    0x8(%ebp),%eax
    62e6:	8b 40 14             	mov    0x14(%eax),%eax
    62e9:	85 c0                	test   %eax,%eax
    62eb:	75 0a                	jne    62f7 <hash_init+0xea>
    return 83; /*alloc fail*/
    62ed:	b8 53 00 00 00       	mov    $0x53,%eax
    62f2:	e9 d3 00 00 00       	jmp    63ca <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    62f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    62fe:	eb 17                	jmp    6317 <hash_init+0x10a>
    6300:	8b 45 08             	mov    0x8(%ebp),%eax
    6303:	8b 00                	mov    (%eax),%eax
    6305:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6308:	c1 e2 02             	shl    $0x2,%edx
    630b:	01 d0                	add    %edx,%eax
    630d:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6313:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6317:	b8 00 00 01 00       	mov    $0x10000,%eax
    631c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    631f:	75 df                	jne    6300 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    6321:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6328:	eb 18                	jmp    6342 <hash_init+0x135>
    632a:	8b 45 08             	mov    0x8(%ebp),%eax
    632d:	8b 40 08             	mov    0x8(%eax),%eax
    6330:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6333:	c1 e2 02             	shl    $0x2,%edx
    6336:	01 d0                	add    %edx,%eax
    6338:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    633e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6342:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6345:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6348:	75 e0                	jne    632a <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    634a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6351:	eb 17                	jmp    636a <hash_init+0x15d>
    6353:	8b 45 08             	mov    0x8(%ebp),%eax
    6356:	8b 40 04             	mov    0x4(%eax),%eax
    6359:	8b 55 f4             	mov    -0xc(%ebp),%edx
    635c:	01 d2                	add    %edx,%edx
    635e:	01 d0                	add    %edx,%eax
    6360:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6363:	66 89 10             	mov    %dx,(%eax)
    6366:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    636a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    636d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6370:	75 e1                	jne    6353 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6372:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6379:	eb 18                	jmp    6393 <hash_init+0x186>
    637b:	8b 45 08             	mov    0x8(%ebp),%eax
    637e:	8b 40 0c             	mov    0xc(%eax),%eax
    6381:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6384:	c1 e2 02             	shl    $0x2,%edx
    6387:	01 d0                	add    %edx,%eax
    6389:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    638f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6393:	b8 02 01 00 00       	mov    $0x102,%eax
    6398:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    639b:	76 de                	jbe    637b <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    639d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63a4:	eb 17                	jmp    63bd <hash_init+0x1b0>
    63a6:	8b 45 08             	mov    0x8(%ebp),%eax
    63a9:	8b 40 10             	mov    0x10(%eax),%eax
    63ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63af:	01 d2                	add    %edx,%edx
    63b1:	01 d0                	add    %edx,%eax
    63b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63b6:	66 89 10             	mov    %dx,(%eax)
    63b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63c0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63c3:	75 e1                	jne    63a6 <hash_init+0x199>

  return 0;
    63c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    63ca:	c9                   	leave  
    63cb:	c3                   	ret    

000063cc <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    63cc:	55                   	push   %ebp
    63cd:	89 e5                	mov    %esp,%ebp
    63cf:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    63d2:	8b 45 08             	mov    0x8(%ebp),%eax
    63d5:	8b 00                	mov    (%eax),%eax
    63d7:	83 ec 0c             	sub    $0xc,%esp
    63da:	50                   	push   %eax
    63db:	e8 57 cf ff ff       	call   3337 <lodepng_free>
    63e0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    63e3:	8b 45 08             	mov    0x8(%ebp),%eax
    63e6:	8b 40 08             	mov    0x8(%eax),%eax
    63e9:	83 ec 0c             	sub    $0xc,%esp
    63ec:	50                   	push   %eax
    63ed:	e8 45 cf ff ff       	call   3337 <lodepng_free>
    63f2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    63f5:	8b 45 08             	mov    0x8(%ebp),%eax
    63f8:	8b 40 04             	mov    0x4(%eax),%eax
    63fb:	83 ec 0c             	sub    $0xc,%esp
    63fe:	50                   	push   %eax
    63ff:	e8 33 cf ff ff       	call   3337 <lodepng_free>
    6404:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    6407:	8b 45 08             	mov    0x8(%ebp),%eax
    640a:	8b 40 14             	mov    0x14(%eax),%eax
    640d:	83 ec 0c             	sub    $0xc,%esp
    6410:	50                   	push   %eax
    6411:	e8 21 cf ff ff       	call   3337 <lodepng_free>
    6416:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6419:	8b 45 08             	mov    0x8(%ebp),%eax
    641c:	8b 40 0c             	mov    0xc(%eax),%eax
    641f:	83 ec 0c             	sub    $0xc,%esp
    6422:	50                   	push   %eax
    6423:	e8 0f cf ff ff       	call   3337 <lodepng_free>
    6428:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    642b:	8b 45 08             	mov    0x8(%ebp),%eax
    642e:	8b 40 10             	mov    0x10(%eax),%eax
    6431:	83 ec 0c             	sub    $0xc,%esp
    6434:	50                   	push   %eax
    6435:	e8 fd ce ff ff       	call   3337 <lodepng_free>
    643a:	83 c4 10             	add    $0x10,%esp
}
    643d:	90                   	nop
    643e:	c9                   	leave  
    643f:	c3                   	ret    

00006440 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6440:	55                   	push   %ebp
    6441:	89 e5                	mov    %esp,%ebp
    6443:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6446:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    644d:	8b 45 10             	mov    0x10(%ebp),%eax
    6450:	83 c0 02             	add    $0x2,%eax
    6453:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6456:	7d 41                	jge    6499 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6458:	8b 55 10             	mov    0x10(%ebp),%edx
    645b:	8b 45 08             	mov    0x8(%ebp),%eax
    645e:	01 d0                	add    %edx,%eax
    6460:	0f b6 00             	movzbl (%eax),%eax
    6463:	0f b6 c0             	movzbl %al,%eax
    6466:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6469:	8b 45 10             	mov    0x10(%ebp),%eax
    646c:	8d 50 01             	lea    0x1(%eax),%edx
    646f:	8b 45 08             	mov    0x8(%ebp),%eax
    6472:	01 d0                	add    %edx,%eax
    6474:	0f b6 00             	movzbl (%eax),%eax
    6477:	0f b6 c0             	movzbl %al,%eax
    647a:	c1 e0 04             	shl    $0x4,%eax
    647d:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    6480:	8b 45 10             	mov    0x10(%ebp),%eax
    6483:	8d 50 02             	lea    0x2(%eax),%edx
    6486:	8b 45 08             	mov    0x8(%ebp),%eax
    6489:	01 d0                	add    %edx,%eax
    648b:	0f b6 00             	movzbl (%eax),%eax
    648e:	0f b6 c0             	movzbl %al,%eax
    6491:	c1 e0 08             	shl    $0x8,%eax
    6494:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6497:	eb 51                	jmp    64ea <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    6499:	8b 45 10             	mov    0x10(%ebp),%eax
    649c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    649f:	7c 07                	jl     64a8 <getHash+0x68>
    64a1:	b8 00 00 00 00       	mov    $0x0,%eax
    64a6:	eb 4a                	jmp    64f2 <getHash+0xb2>
    amount = size - pos;
    64a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    64ab:	2b 45 10             	sub    0x10(%ebp),%eax
    64ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    64b1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    64b8:	eb 28                	jmp    64e2 <getHash+0xa2>
    64ba:	8b 55 10             	mov    0x10(%ebp),%edx
    64bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64c0:	01 d0                	add    %edx,%eax
    64c2:	89 c2                	mov    %eax,%edx
    64c4:	8b 45 08             	mov    0x8(%ebp),%eax
    64c7:	01 d0                	add    %edx,%eax
    64c9:	0f b6 00             	movzbl (%eax),%eax
    64cc:	0f b6 d0             	movzbl %al,%edx
    64cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64d2:	c1 e0 03             	shl    $0x3,%eax
    64d5:	89 c1                	mov    %eax,%ecx
    64d7:	d3 e2                	shl    %cl,%edx
    64d9:	89 d0                	mov    %edx,%eax
    64db:	31 45 fc             	xor    %eax,-0x4(%ebp)
    64de:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    64e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64e5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    64e8:	75 d0                	jne    64ba <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    64ea:	b8 ff ff 00 00       	mov    $0xffff,%eax
    64ef:	23 45 fc             	and    -0x4(%ebp),%eax
}
    64f2:	c9                   	leave  
    64f3:	c3                   	ret    

000064f4 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    64f4:	55                   	push   %ebp
    64f5:	89 e5                	mov    %esp,%ebp
    64f7:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    64fa:	8b 55 10             	mov    0x10(%ebp),%edx
    64fd:	8b 45 08             	mov    0x8(%ebp),%eax
    6500:	01 d0                	add    %edx,%eax
    6502:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    6505:	b8 02 01 00 00       	mov    $0x102,%eax
    650a:	89 c2                	mov    %eax,%edx
    650c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    650f:	01 d0                	add    %edx,%eax
    6511:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    6514:	8b 55 0c             	mov    0xc(%ebp),%edx
    6517:	8b 45 08             	mov    0x8(%ebp),%eax
    651a:	01 d0                	add    %edx,%eax
    651c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    651f:	73 0b                	jae    652c <countZeros+0x38>
    6521:	8b 55 0c             	mov    0xc(%ebp),%edx
    6524:	8b 45 08             	mov    0x8(%ebp),%eax
    6527:	01 d0                	add    %edx,%eax
    6529:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    652c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    652f:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    6532:	eb 04                	jmp    6538 <countZeros+0x44>
    6534:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6538:	8b 45 08             	mov    0x8(%ebp),%eax
    653b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    653e:	74 0a                	je     654a <countZeros+0x56>
    6540:	8b 45 08             	mov    0x8(%ebp),%eax
    6543:	0f b6 00             	movzbl (%eax),%eax
    6546:	84 c0                	test   %al,%al
    6548:	74 ea                	je     6534 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    654a:	8b 55 08             	mov    0x8(%ebp),%edx
    654d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6550:	29 c2                	sub    %eax,%edx
    6552:	89 d0                	mov    %edx,%eax
}
    6554:	c9                   	leave  
    6555:	c3                   	ret    

00006556 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6556:	55                   	push   %ebp
    6557:	89 e5                	mov    %esp,%ebp
    6559:	83 ec 04             	sub    $0x4,%esp
    655c:	8b 45 14             	mov    0x14(%ebp),%eax
    655f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6563:	8b 45 08             	mov    0x8(%ebp),%eax
    6566:	8b 40 08             	mov    0x8(%eax),%eax
    6569:	8b 55 0c             	mov    0xc(%ebp),%edx
    656c:	c1 e2 02             	shl    $0x2,%edx
    656f:	01 c2                	add    %eax,%edx
    6571:	8b 45 10             	mov    0x10(%ebp),%eax
    6574:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6576:	8b 45 08             	mov    0x8(%ebp),%eax
    6579:	8b 00                	mov    (%eax),%eax
    657b:	8b 55 10             	mov    0x10(%ebp),%edx
    657e:	c1 e2 02             	shl    $0x2,%edx
    6581:	01 d0                	add    %edx,%eax
    6583:	8b 00                	mov    (%eax),%eax
    6585:	83 f8 ff             	cmp    $0xffffffff,%eax
    6588:	74 1f                	je     65a9 <updateHashChain+0x53>
    658a:	8b 45 08             	mov    0x8(%ebp),%eax
    658d:	8b 40 04             	mov    0x4(%eax),%eax
    6590:	8b 55 0c             	mov    0xc(%ebp),%edx
    6593:	01 d2                	add    %edx,%edx
    6595:	01 c2                	add    %eax,%edx
    6597:	8b 45 08             	mov    0x8(%ebp),%eax
    659a:	8b 00                	mov    (%eax),%eax
    659c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    659f:	c1 e1 02             	shl    $0x2,%ecx
    65a2:	01 c8                	add    %ecx,%eax
    65a4:	8b 00                	mov    (%eax),%eax
    65a6:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    65a9:	8b 45 08             	mov    0x8(%ebp),%eax
    65ac:	8b 00                	mov    (%eax),%eax
    65ae:	8b 55 10             	mov    0x10(%ebp),%edx
    65b1:	c1 e2 02             	shl    $0x2,%edx
    65b4:	01 c2                	add    %eax,%edx
    65b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    65b9:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    65bb:	8b 45 08             	mov    0x8(%ebp),%eax
    65be:	8b 40 14             	mov    0x14(%eax),%eax
    65c1:	8b 55 0c             	mov    0xc(%ebp),%edx
    65c4:	01 d2                	add    %edx,%edx
    65c6:	01 c2                	add    %eax,%edx
    65c8:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    65cc:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    65cf:	8b 45 08             	mov    0x8(%ebp),%eax
    65d2:	8b 40 0c             	mov    0xc(%eax),%eax
    65d5:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    65d9:	c1 e2 02             	shl    $0x2,%edx
    65dc:	01 d0                	add    %edx,%eax
    65de:	8b 00                	mov    (%eax),%eax
    65e0:	83 f8 ff             	cmp    $0xffffffff,%eax
    65e3:	74 21                	je     6606 <updateHashChain+0xb0>
    65e5:	8b 45 08             	mov    0x8(%ebp),%eax
    65e8:	8b 40 10             	mov    0x10(%eax),%eax
    65eb:	8b 55 0c             	mov    0xc(%ebp),%edx
    65ee:	01 d2                	add    %edx,%edx
    65f0:	01 c2                	add    %eax,%edx
    65f2:	8b 45 08             	mov    0x8(%ebp),%eax
    65f5:	8b 40 0c             	mov    0xc(%eax),%eax
    65f8:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    65fc:	c1 e1 02             	shl    $0x2,%ecx
    65ff:	01 c8                	add    %ecx,%eax
    6601:	8b 00                	mov    (%eax),%eax
    6603:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    6606:	8b 45 08             	mov    0x8(%ebp),%eax
    6609:	8b 40 0c             	mov    0xc(%eax),%eax
    660c:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6610:	c1 e2 02             	shl    $0x2,%edx
    6613:	01 c2                	add    %eax,%edx
    6615:	8b 45 0c             	mov    0xc(%ebp),%eax
    6618:	89 02                	mov    %eax,(%edx)
}
    661a:	90                   	nop
    661b:	c9                   	leave  
    661c:	c3                   	ret    

0000661d <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    661d:	55                   	push   %ebp
    661e:	89 e5                	mov    %esp,%ebp
    6620:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    6623:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    662a:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6631:	77 08                	ja     663b <encodeLZ77+0x1e>
    6633:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6636:	c1 e8 03             	shr    $0x3,%eax
    6639:	eb 03                	jmp    663e <encodeLZ77+0x21>
    663b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    663e:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6641:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6648:	76 07                	jbe    6651 <encodeLZ77+0x34>
    664a:	b8 02 01 00 00       	mov    $0x102,%eax
    664f:	eb 05                	jmp    6656 <encodeLZ77+0x39>
    6651:	b8 40 00 00 00       	mov    $0x40,%eax
    6656:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6659:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    6660:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6667:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    666e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6675:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    667c:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    6680:	74 09                	je     668b <encodeLZ77+0x6e>
    6682:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6689:	76 0a                	jbe    6695 <encodeLZ77+0x78>
    668b:	b8 3c 00 00 00       	mov    $0x3c,%eax
    6690:	e9 e3 04 00 00       	jmp    6b78 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6695:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6698:	83 e8 01             	sub    $0x1,%eax
    669b:	23 45 1c             	and    0x1c(%ebp),%eax
    669e:	85 c0                	test   %eax,%eax
    66a0:	74 0a                	je     66ac <encodeLZ77+0x8f>
    66a2:	b8 5a 00 00 00       	mov    $0x5a,%eax
    66a7:	e9 cc 04 00 00       	jmp    6b78 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    66ac:	b8 02 01 00 00       	mov    $0x102,%eax
    66b1:	39 45 24             	cmp    %eax,0x24(%ebp)
    66b4:	76 08                	jbe    66be <encodeLZ77+0xa1>
    66b6:	b8 02 01 00 00       	mov    $0x102,%eax
    66bb:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    66be:	8b 45 14             	mov    0x14(%ebp),%eax
    66c1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    66c4:	e9 a0 04 00 00       	jmp    6b69 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    66c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66cc:	8d 50 ff             	lea    -0x1(%eax),%edx
    66cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    66d2:	21 d0                	and    %edx,%eax
    66d4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    66d7:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    66de:	ff 75 fc             	pushl  -0x4(%ebp)
    66e1:	ff 75 18             	pushl  0x18(%ebp)
    66e4:	ff 75 10             	pushl  0x10(%ebp)
    66e7:	e8 54 fd ff ff       	call   6440 <getHash>
    66ec:	83 c4 0c             	add    $0xc,%esp
    66ef:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    66f2:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    66f6:	74 4e                	je     6746 <encodeLZ77+0x129>
    66f8:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    66fc:	75 48                	jne    6746 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    66fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6702:	75 16                	jne    671a <encodeLZ77+0xfd>
    6704:	ff 75 fc             	pushl  -0x4(%ebp)
    6707:	ff 75 18             	pushl  0x18(%ebp)
    670a:	ff 75 10             	pushl  0x10(%ebp)
    670d:	e8 e2 fd ff ff       	call   64f4 <countZeros>
    6712:	83 c4 0c             	add    $0xc,%esp
    6715:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6718:	eb 35                	jmp    674f <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    671a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    671d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6720:	01 c2                	add    %eax,%edx
    6722:	8b 45 18             	mov    0x18(%ebp),%eax
    6725:	39 c2                	cmp    %eax,%edx
    6727:	77 17                	ja     6740 <encodeLZ77+0x123>
    6729:	8b 55 fc             	mov    -0x4(%ebp),%edx
    672c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    672f:	01 d0                	add    %edx,%eax
    6731:	8d 50 ff             	lea    -0x1(%eax),%edx
    6734:	8b 45 10             	mov    0x10(%ebp),%eax
    6737:	01 d0                	add    %edx,%eax
    6739:	0f b6 00             	movzbl (%eax),%eax
    673c:	84 c0                	test   %al,%al
    673e:	74 0f                	je     674f <encodeLZ77+0x132>
    6740:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6744:	eb 09                	jmp    674f <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6746:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    674d:	eb 01                	jmp    6750 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    674f:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    6750:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6753:	0f b7 c0             	movzwl %ax,%eax
    6756:	50                   	push   %eax
    6757:	ff 75 b0             	pushl  -0x50(%ebp)
    675a:	ff 75 b4             	pushl  -0x4c(%ebp)
    675d:	ff 75 0c             	pushl  0xc(%ebp)
    6760:	e8 f1 fd ff ff       	call   6556 <updateHashChain>
    6765:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6768:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    676f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6776:	8b 45 0c             	mov    0xc(%ebp),%eax
    6779:	8b 40 04             	mov    0x4(%eax),%eax
    677c:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    677f:	01 d2                	add    %edx,%edx
    6781:	01 d0                	add    %edx,%eax
    6783:	0f b7 00             	movzwl (%eax),%eax
    6786:	0f b7 c0             	movzwl %ax,%eax
    6789:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    678c:	ba 02 01 00 00       	mov    $0x102,%edx
    6791:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6794:	01 c2                	add    %eax,%edx
    6796:	8b 45 18             	mov    0x18(%ebp),%eax
    6799:	39 c2                	cmp    %eax,%edx
    679b:	0f 4e c2             	cmovle %edx,%eax
    679e:	89 c2                	mov    %eax,%edx
    67a0:	8b 45 10             	mov    0x10(%ebp),%eax
    67a3:	01 d0                	add    %edx,%eax
    67a5:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    67a8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    67af:	8b 45 c8             	mov    -0x38(%ebp),%eax
    67b2:	8d 50 01             	lea    0x1(%eax),%edx
    67b5:	89 55 c8             	mov    %edx,-0x38(%ebp)
    67b8:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    67bb:	0f 83 67 01 00 00    	jae    6928 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    67c1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67c4:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    67c7:	77 08                	ja     67d1 <encodeLZ77+0x1b4>
    67c9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67cc:	2b 45 cc             	sub    -0x34(%ebp),%eax
    67cf:	eb 0d                	jmp    67de <encodeLZ77+0x1c1>
    67d1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67d4:	2b 45 cc             	sub    -0x34(%ebp),%eax
    67d7:	89 c2                	mov    %eax,%edx
    67d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    67dc:	01 d0                	add    %edx,%eax
    67de:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    67e1:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67e4:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    67e7:	0f 82 3e 01 00 00    	jb     692b <encodeLZ77+0x30e>
      prev_offset = current_offset;
    67ed:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67f0:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    67f3:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    67f7:	0f 84 a3 00 00 00    	je     68a0 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    67fd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6800:	8b 45 10             	mov    0x10(%ebp),%eax
    6803:	01 d0                	add    %edx,%eax
    6805:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6808:	8b 45 fc             	mov    -0x4(%ebp),%eax
    680b:	2b 45 a8             	sub    -0x58(%ebp),%eax
    680e:	89 c2                	mov    %eax,%edx
    6810:	8b 45 10             	mov    0x10(%ebp),%eax
    6813:	01 d0                	add    %edx,%eax
    6815:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6818:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    681c:	76 3a                	jbe    6858 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    681e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6821:	8b 40 14             	mov    0x14(%eax),%eax
    6824:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6827:	01 d2                	add    %edx,%edx
    6829:	01 d0                	add    %edx,%eax
    682b:	0f b7 00             	movzwl (%eax),%eax
    682e:	0f b7 c0             	movzwl %ax,%eax
    6831:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6834:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6837:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    683a:	76 06                	jbe    6842 <encodeLZ77+0x225>
    683c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    683f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6842:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6845:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6848:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    684b:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    684e:	eb 08                	jmp    6858 <encodeLZ77+0x23b>
          ++backptr;
    6850:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6854:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6858:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    685b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    685e:	74 10                	je     6870 <encodeLZ77+0x253>
    6860:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6863:	0f b6 10             	movzbl (%eax),%edx
    6866:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6869:	0f b6 00             	movzbl (%eax),%eax
    686c:	38 c2                	cmp    %al,%dl
    686e:	74 e0                	je     6850 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    6870:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6873:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6876:	8b 55 10             	mov    0x10(%ebp),%edx
    6879:	01 ca                	add    %ecx,%edx
    687b:	29 d0                	sub    %edx,%eax
    687d:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    6880:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6883:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6886:	76 18                	jbe    68a0 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6888:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    688b:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    688e:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6891:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6894:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6897:	3b 45 24             	cmp    0x24(%ebp),%eax
    689a:	0f 83 8e 00 00 00    	jae    692e <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    68a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    68a3:	8b 40 04             	mov    0x4(%eax),%eax
    68a6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68a9:	01 d2                	add    %edx,%edx
    68ab:	01 d0                	add    %edx,%eax
    68ad:	0f b7 00             	movzwl (%eax),%eax
    68b0:	0f b7 c0             	movzwl %ax,%eax
    68b3:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    68b6:	74 79                	je     6931 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    68b8:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    68bc:	76 38                	jbe    68f6 <encodeLZ77+0x2d9>
    68be:	8b 45 e8             	mov    -0x18(%ebp),%eax
    68c1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68c4:	76 30                	jbe    68f6 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    68c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    68c9:	8b 40 10             	mov    0x10(%eax),%eax
    68cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68cf:	01 d2                	add    %edx,%edx
    68d1:	01 d0                	add    %edx,%eax
    68d3:	0f b7 00             	movzwl (%eax),%eax
    68d6:	0f b7 c0             	movzwl %ax,%eax
    68d9:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    68dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    68df:	8b 40 14             	mov    0x14(%eax),%eax
    68e2:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68e5:	01 d2                	add    %edx,%edx
    68e7:	01 d0                	add    %edx,%eax
    68e9:	0f b7 00             	movzwl (%eax),%eax
    68ec:	0f b7 c0             	movzwl %ax,%eax
    68ef:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68f2:	74 2f                	je     6923 <encodeLZ77+0x306>
    68f4:	eb 3f                	jmp    6935 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    68f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    68f9:	8b 40 04             	mov    0x4(%eax),%eax
    68fc:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68ff:	01 d2                	add    %edx,%edx
    6901:	01 d0                	add    %edx,%eax
    6903:	0f b7 00             	movzwl (%eax),%eax
    6906:	0f b7 c0             	movzwl %ax,%eax
    6909:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    690c:	8b 45 0c             	mov    0xc(%ebp),%eax
    690f:	8b 40 08             	mov    0x8(%eax),%eax
    6912:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6915:	c1 e2 02             	shl    $0x2,%edx
    6918:	01 d0                	add    %edx,%eax
    691a:	8b 10                	mov    (%eax),%edx
    691c:	8b 45 b0             	mov    -0x50(%ebp),%eax
    691f:	39 c2                	cmp    %eax,%edx
    6921:	75 11                	jne    6934 <encodeLZ77+0x317>
      }
    }
    6923:	e9 87 fe ff ff       	jmp    67af <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6928:	90                   	nop
    6929:	eb 0a                	jmp    6935 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    692b:	90                   	nop
    692c:	eb 07                	jmp    6935 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    692e:	90                   	nop
    692f:	eb 04                	jmp    6935 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6931:	90                   	nop
    6932:	eb 01                	jmp    6935 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6934:	90                   	nop
      }
    }

    if(lazymatching) {
    6935:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6939:	0f 84 c8 00 00 00    	je     6a07 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    693f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6943:	75 30                	jne    6975 <encodeLZ77+0x358>
    6945:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6949:	76 2a                	jbe    6975 <encodeLZ77+0x358>
    694b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    694e:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6951:	77 22                	ja     6975 <encodeLZ77+0x358>
    6953:	b8 02 01 00 00       	mov    $0x102,%eax
    6958:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    695b:	73 18                	jae    6975 <encodeLZ77+0x358>
        lazy = 1;
    695d:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6964:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6967:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    696a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    696d:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6970:	e9 f0 01 00 00       	jmp    6b65 <encodeLZ77+0x548>
      }
      if(lazy) {
    6975:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6979:	0f 84 88 00 00 00    	je     6a07 <encodeLZ77+0x3ea>
        lazy = 0;
    697f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6986:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    698a:	75 0c                	jne    6998 <encodeLZ77+0x37b>
    698c:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6993:	e9 dd 01 00 00       	jmp    6b75 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6998:	8b 45 e0             	mov    -0x20(%ebp),%eax
    699b:	83 c0 01             	add    $0x1,%eax
    699e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    69a1:	73 2d                	jae    69d0 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    69a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    69a6:	8d 50 ff             	lea    -0x1(%eax),%edx
    69a9:	8b 45 10             	mov    0x10(%ebp),%eax
    69ac:	01 d0                	add    %edx,%eax
    69ae:	0f b6 00             	movzbl (%eax),%eax
    69b1:	0f b6 c0             	movzbl %al,%eax
    69b4:	50                   	push   %eax
    69b5:	ff 75 08             	pushl  0x8(%ebp)
    69b8:	e8 6f cb ff ff       	call   352c <uivector_push_back>
    69bd:	83 c4 08             	add    $0x8,%esp
    69c0:	85 c0                	test   %eax,%eax
    69c2:	75 43                	jne    6a07 <encodeLZ77+0x3ea>
    69c4:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    69cb:	e9 a5 01 00 00       	jmp    6b75 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    69d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    69d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    69d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    69d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    69dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    69df:	8b 00                	mov    (%eax),%eax
    69e1:	8b 55 b0             	mov    -0x50(%ebp),%edx
    69e4:	c1 e2 02             	shl    $0x2,%edx
    69e7:	01 d0                	add    %edx,%eax
    69e9:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    69ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    69f2:	8b 40 0c             	mov    0xc(%eax),%eax
    69f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    69f8:	c1 e2 02             	shl    $0x2,%edx
    69fb:	01 d0                	add    %edx,%eax
    69fd:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6a03:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6a07:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a0b:	76 14                	jbe    6a21 <encodeLZ77+0x404>
    6a0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a10:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6a13:	76 0c                	jbe    6a21 <encodeLZ77+0x404>
    6a15:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6a1c:	e9 54 01 00 00       	jmp    6b75 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6a21:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a25:	77 2e                	ja     6a55 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a27:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a2a:	8b 45 10             	mov    0x10(%ebp),%eax
    6a2d:	01 d0                	add    %edx,%eax
    6a2f:	0f b6 00             	movzbl (%eax),%eax
    6a32:	0f b6 c0             	movzbl %al,%eax
    6a35:	50                   	push   %eax
    6a36:	ff 75 08             	pushl  0x8(%ebp)
    6a39:	e8 ee ca ff ff       	call   352c <uivector_push_back>
    6a3e:	83 c4 08             	add    $0x8,%esp
    6a41:	85 c0                	test   %eax,%eax
    6a43:	0f 85 1c 01 00 00    	jne    6b65 <encodeLZ77+0x548>
    6a49:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a50:	e9 20 01 00 00       	jmp    6b75 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6a55:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a58:	3b 45 20             	cmp    0x20(%ebp),%eax
    6a5b:	72 0f                	jb     6a6c <encodeLZ77+0x44f>
    6a5d:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6a61:	75 37                	jne    6a9a <encodeLZ77+0x47d>
    6a63:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6a6a:	76 2e                	jbe    6a9a <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a6c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a6f:	8b 45 10             	mov    0x10(%ebp),%eax
    6a72:	01 d0                	add    %edx,%eax
    6a74:	0f b6 00             	movzbl (%eax),%eax
    6a77:	0f b6 c0             	movzbl %al,%eax
    6a7a:	50                   	push   %eax
    6a7b:	ff 75 08             	pushl  0x8(%ebp)
    6a7e:	e8 a9 ca ff ff       	call   352c <uivector_push_back>
    6a83:	83 c4 08             	add    $0x8,%esp
    6a86:	85 c0                	test   %eax,%eax
    6a88:	0f 85 d7 00 00 00    	jne    6b65 <encodeLZ77+0x548>
    6a8e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a95:	e9 db 00 00 00       	jmp    6b75 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6a9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6a9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6aa0:	52                   	push   %edx
    6aa1:	50                   	push   %eax
    6aa2:	ff 75 08             	pushl  0x8(%ebp)
    6aa5:	e8 8a f6 ff ff       	call   6134 <addLengthDistance>
    6aaa:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6aad:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6ab4:	e9 a0 00 00 00       	jmp    6b59 <encodeLZ77+0x53c>
        ++pos;
    6ab9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6abd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6ac0:	8d 50 ff             	lea    -0x1(%eax),%edx
    6ac3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6ac6:	21 d0                	and    %edx,%eax
    6ac8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6acb:	ff 75 fc             	pushl  -0x4(%ebp)
    6ace:	ff 75 18             	pushl  0x18(%ebp)
    6ad1:	ff 75 10             	pushl  0x10(%ebp)
    6ad4:	e8 67 f9 ff ff       	call   6440 <getHash>
    6ad9:	83 c4 0c             	add    $0xc,%esp
    6adc:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6adf:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6ae3:	74 4e                	je     6b33 <encodeLZ77+0x516>
    6ae5:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6ae9:	75 48                	jne    6b33 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6aeb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6aef:	75 16                	jne    6b07 <encodeLZ77+0x4ea>
    6af1:	ff 75 fc             	pushl  -0x4(%ebp)
    6af4:	ff 75 18             	pushl  0x18(%ebp)
    6af7:	ff 75 10             	pushl  0x10(%ebp)
    6afa:	e8 f5 f9 ff ff       	call   64f4 <countZeros>
    6aff:	83 c4 0c             	add    $0xc,%esp
    6b02:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6b05:	eb 35                	jmp    6b3c <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6b07:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b0d:	01 c2                	add    %eax,%edx
    6b0f:	8b 45 18             	mov    0x18(%ebp),%eax
    6b12:	39 c2                	cmp    %eax,%edx
    6b14:	77 17                	ja     6b2d <encodeLZ77+0x510>
    6b16:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b19:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b1c:	01 d0                	add    %edx,%eax
    6b1e:	8d 50 ff             	lea    -0x1(%eax),%edx
    6b21:	8b 45 10             	mov    0x10(%ebp),%eax
    6b24:	01 d0                	add    %edx,%eax
    6b26:	0f b6 00             	movzbl (%eax),%eax
    6b29:	84 c0                	test   %al,%al
    6b2b:	74 0f                	je     6b3c <encodeLZ77+0x51f>
    6b2d:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b31:	eb 09                	jmp    6b3c <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6b33:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6b3a:	eb 01                	jmp    6b3d <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b3c:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6b3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b40:	0f b7 c0             	movzwl %ax,%eax
    6b43:	50                   	push   %eax
    6b44:	ff 75 b0             	pushl  -0x50(%ebp)
    6b47:	ff 75 b4             	pushl  -0x4c(%ebp)
    6b4a:	ff 75 0c             	pushl  0xc(%ebp)
    6b4d:	e8 04 fa ff ff       	call   6556 <updateHashChain>
    6b52:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6b55:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6b59:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6b5c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6b5f:	0f 82 54 ff ff ff    	jb     6ab9 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6b65:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6b69:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b6c:	3b 45 18             	cmp    0x18(%ebp),%eax
    6b6f:	0f 8c 54 fb ff ff    	jl     66c9 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6b75:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6b78:	c9                   	leave  
    6b79:	c3                   	ret    

00006b7a <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6b7a:	55                   	push   %ebp
    6b7b:	89 e5                	mov    %esp,%ebp
    6b7d:	53                   	push   %ebx
    6b7e:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6b81:	8b 45 10             	mov    0x10(%ebp),%eax
    6b84:	05 fe ff 00 00       	add    $0xfffe,%eax
    6b89:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6b8e:	f7 e2                	mul    %edx
    6b90:	89 d0                	mov    %edx,%eax
    6b92:	c1 e8 0f             	shr    $0xf,%eax
    6b95:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6b98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6b9f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6ba6:	e9 1b 01 00 00       	jmp    6cc6 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6bab:	8b 45 08             	mov    0x8(%ebp),%eax
    6bae:	8b 40 04             	mov    0x4(%eax),%eax
    6bb1:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6bb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6bb7:	83 e8 01             	sub    $0x1,%eax
    6bba:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6bbd:	0f 94 c0             	sete   %al
    6bc0:	0f b6 c0             	movzbl %al,%eax
    6bc3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6bc6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6bcd:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6bd4:	8b 45 10             	mov    0x10(%ebp),%eax
    6bd7:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6bda:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6bdf:	77 09                	ja     6bea <deflateNoCompression+0x70>
    6be1:	8b 45 10             	mov    0x10(%ebp),%eax
    6be4:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6be7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6bea:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6bef:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6bf2:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6bf5:	8b 45 08             	mov    0x8(%ebp),%eax
    6bf8:	8b 40 04             	mov    0x4(%eax),%eax
    6bfb:	89 c2                	mov    %eax,%edx
    6bfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c00:	01 d0                	add    %edx,%eax
    6c02:	83 c0 05             	add    $0x5,%eax
    6c05:	50                   	push   %eax
    6c06:	ff 75 08             	pushl  0x8(%ebp)
    6c09:	e8 62 c9 ff ff       	call   3570 <ucvector_resize>
    6c0e:	83 c4 08             	add    $0x8,%esp
    6c11:	85 c0                	test   %eax,%eax
    6c13:	75 0a                	jne    6c1f <deflateNoCompression+0xa5>
    6c15:	b8 53 00 00 00       	mov    $0x53,%eax
    6c1a:	e9 b8 00 00 00       	jmp    6cd7 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6c1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6c22:	89 c2                	mov    %eax,%edx
    6c24:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c27:	83 e0 01             	and    $0x1,%eax
    6c2a:	01 c0                	add    %eax,%eax
    6c2c:	01 c2                	add    %eax,%edx
    6c2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c31:	83 e0 02             	and    $0x2,%eax
    6c34:	01 c0                	add    %eax,%eax
    6c36:	01 d0                	add    %edx,%eax
    6c38:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6c3b:	8b 45 08             	mov    0x8(%ebp),%eax
    6c3e:	8b 10                	mov    (%eax),%edx
    6c40:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c43:	01 c2                	add    %eax,%edx
    6c45:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6c49:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6c4b:	8b 45 08             	mov    0x8(%ebp),%eax
    6c4e:	8b 00                	mov    (%eax),%eax
    6c50:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c53:	83 c2 01             	add    $0x1,%edx
    6c56:	01 d0                	add    %edx,%eax
    6c58:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c5b:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6c5d:	8b 45 08             	mov    0x8(%ebp),%eax
    6c60:	8b 00                	mov    (%eax),%eax
    6c62:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c65:	83 c2 02             	add    $0x2,%edx
    6c68:	01 d0                	add    %edx,%eax
    6c6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c6d:	c1 ea 08             	shr    $0x8,%edx
    6c70:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6c72:	8b 45 08             	mov    0x8(%ebp),%eax
    6c75:	8b 00                	mov    (%eax),%eax
    6c77:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c7a:	83 c2 03             	add    $0x3,%edx
    6c7d:	01 d0                	add    %edx,%eax
    6c7f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c82:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6c84:	8b 45 08             	mov    0x8(%ebp),%eax
    6c87:	8b 00                	mov    (%eax),%eax
    6c89:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c8c:	83 c2 04             	add    $0x4,%edx
    6c8f:	01 d0                	add    %edx,%eax
    6c91:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c94:	c1 ea 08             	shr    $0x8,%edx
    6c97:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6c99:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c9c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6c9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6ca2:	01 d1                	add    %edx,%ecx
    6ca4:	8b 55 08             	mov    0x8(%ebp),%edx
    6ca7:	8b 12                	mov    (%edx),%edx
    6ca9:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6cac:	83 c3 05             	add    $0x5,%ebx
    6caf:	01 da                	add    %ebx,%edx
    6cb1:	50                   	push   %eax
    6cb2:	51                   	push   %ecx
    6cb3:	52                   	push   %edx
    6cb4:	e8 9b c6 ff ff       	call   3354 <lodepng_memcpy>
    6cb9:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6cbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6cbf:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6cc2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6cc6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6cc9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6ccc:	0f 85 d9 fe ff ff    	jne    6bab <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6cd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6cd7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6cda:	c9                   	leave  
    6cdb:	c3                   	ret    

00006cdc <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6cdc:	55                   	push   %ebp
    6cdd:	89 e5                	mov    %esp,%ebp
    6cdf:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6ce2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6ce9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6cf0:	e9 10 01 00 00       	jmp    6e05 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6cf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cf8:	8b 00                	mov    (%eax),%eax
    6cfa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6cfd:	c1 e2 02             	shl    $0x2,%edx
    6d00:	01 d0                	add    %edx,%eax
    6d02:	8b 00                	mov    (%eax),%eax
    6d04:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6d07:	8b 45 10             	mov    0x10(%ebp),%eax
    6d0a:	8b 40 04             	mov    0x4(%eax),%eax
    6d0d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d10:	c1 e2 02             	shl    $0x2,%edx
    6d13:	01 d0                	add    %edx,%eax
    6d15:	8b 00                	mov    (%eax),%eax
    6d17:	89 c1                	mov    %eax,%ecx
    6d19:	8b 45 10             	mov    0x10(%ebp),%eax
    6d1c:	8b 00                	mov    (%eax),%eax
    6d1e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d21:	c1 e2 02             	shl    $0x2,%edx
    6d24:	01 d0                	add    %edx,%eax
    6d26:	8b 00                	mov    (%eax),%eax
    6d28:	51                   	push   %ecx
    6d29:	50                   	push   %eax
    6d2a:	ff 75 08             	pushl  0x8(%ebp)
    6d2d:	e8 60 cc ff ff       	call   3992 <writeBitsReversed>
    6d32:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6d35:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6d3c:	0f 86 bf 00 00 00    	jbe    6e01 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6d42:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d45:	2d 01 01 00 00       	sub    $0x101,%eax
    6d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6d4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d50:	8b 04 85 a0 9d 01 00 	mov    0x19da0(,%eax,4),%eax
    6d57:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6d5a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d5d:	8b 00                	mov    (%eax),%eax
    6d5f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d63:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d66:	c1 e2 02             	shl    $0x2,%edx
    6d69:	01 d0                	add    %edx,%eax
    6d6b:	8b 00                	mov    (%eax),%eax
    6d6d:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6d70:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d73:	8b 00                	mov    (%eax),%eax
    6d75:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d79:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d7c:	c1 e2 02             	shl    $0x2,%edx
    6d7f:	01 d0                	add    %edx,%eax
    6d81:	8b 00                	mov    (%eax),%eax
    6d83:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6d86:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6d8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d8f:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    6d96:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6d99:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d9c:	8b 00                	mov    (%eax),%eax
    6d9e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6da2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6da5:	c1 e2 02             	shl    $0x2,%edx
    6da8:	01 d0                	add    %edx,%eax
    6daa:	8b 00                	mov    (%eax),%eax
    6dac:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6daf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6db2:	50                   	push   %eax
    6db3:	ff 75 ec             	pushl  -0x14(%ebp)
    6db6:	ff 75 08             	pushl  0x8(%ebp)
    6db9:	e8 40 ca ff ff       	call   37fe <writeBits>
    6dbe:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6dc1:	8b 45 14             	mov    0x14(%ebp),%eax
    6dc4:	8b 40 04             	mov    0x4(%eax),%eax
    6dc7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6dca:	c1 e2 02             	shl    $0x2,%edx
    6dcd:	01 d0                	add    %edx,%eax
    6dcf:	8b 00                	mov    (%eax),%eax
    6dd1:	89 c1                	mov    %eax,%ecx
    6dd3:	8b 45 14             	mov    0x14(%ebp),%eax
    6dd6:	8b 00                	mov    (%eax),%eax
    6dd8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6ddb:	c1 e2 02             	shl    $0x2,%edx
    6dde:	01 d0                	add    %edx,%eax
    6de0:	8b 00                	mov    (%eax),%eax
    6de2:	51                   	push   %ecx
    6de3:	50                   	push   %eax
    6de4:	ff 75 08             	pushl  0x8(%ebp)
    6de7:	e8 a6 cb ff ff       	call   3992 <writeBitsReversed>
    6dec:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6def:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6df2:	50                   	push   %eax
    6df3:	ff 75 dc             	pushl  -0x24(%ebp)
    6df6:	ff 75 08             	pushl  0x8(%ebp)
    6df9:	e8 00 ca ff ff       	call   37fe <writeBits>
    6dfe:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6e01:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e05:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e08:	8b 40 04             	mov    0x4(%eax),%eax
    6e0b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6e0e:	0f 85 e1 fe ff ff    	jne    6cf5 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6e14:	90                   	nop
    6e15:	c9                   	leave  
    6e16:	c3                   	ret    

00006e17 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6e17:	55                   	push   %ebp
    6e18:	89 e5                	mov    %esp,%ebp
    6e1a:	53                   	push   %ebx
    6e1b:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6e21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6e28:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6e2f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6e36:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6e3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6e44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6e4b:	8b 45 18             	mov    0x18(%ebp),%eax
    6e4e:	2b 45 14             	sub    0x14(%ebp),%eax
    6e51:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6e54:	8b 45 20             	mov    0x20(%ebp),%eax
    6e57:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6e5a:	8d 45 90             	lea    -0x70(%ebp),%eax
    6e5d:	50                   	push   %eax
    6e5e:	e8 a4 c6 ff ff       	call   3507 <uivector_init>
    6e63:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6e66:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6e6c:	50                   	push   %eax
    6e6d:	e8 98 d3 ff ff       	call   420a <HuffmanTree_init>
    6e72:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6e75:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6e7b:	50                   	push   %eax
    6e7c:	e8 89 d3 ff ff       	call   420a <HuffmanTree_init>
    6e81:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6e84:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6e8a:	50                   	push   %eax
    6e8b:	e8 7a d3 ff ff       	call   420a <HuffmanTree_init>
    6e90:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6e93:	83 ec 0c             	sub    $0xc,%esp
    6e96:	68 78 04 00 00       	push   $0x478
    6e9b:	e8 76 c4 ff ff       	call   3316 <lodepng_malloc>
    6ea0:	83 c4 10             	add    $0x10,%esp
    6ea3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6ea6:	83 ec 0c             	sub    $0xc,%esp
    6ea9:	6a 78                	push   $0x78
    6eab:	e8 66 c4 ff ff       	call   3316 <lodepng_malloc>
    6eb0:	83 c4 10             	add    $0x10,%esp
    6eb3:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6eb6:	83 ec 0c             	sub    $0xc,%esp
    6eb9:	6a 4c                	push   $0x4c
    6ebb:	e8 56 c4 ff ff       	call   3316 <lodepng_malloc>
    6ec0:	83 c4 10             	add    $0x10,%esp
    6ec3:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6ec6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6eca:	74 0c                	je     6ed8 <deflateDynamic+0xc1>
    6ecc:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6ed0:	74 06                	je     6ed8 <deflateDynamic+0xc1>
    6ed2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6ed6:	75 07                	jne    6edf <deflateDynamic+0xc8>
    6ed8:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6edf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6ee3:	0f 85 f6 07 00 00    	jne    76df <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6ee9:	83 ec 04             	sub    $0x4,%esp
    6eec:	68 78 04 00 00       	push   $0x478
    6ef1:	6a 00                	push   $0x0
    6ef3:	ff 75 d4             	pushl  -0x2c(%ebp)
    6ef6:	e8 8c c4 ff ff       	call   3387 <lodepng_memset>
    6efb:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6efe:	83 ec 04             	sub    $0x4,%esp
    6f01:	6a 78                	push   $0x78
    6f03:	6a 00                	push   $0x0
    6f05:	ff 75 d0             	pushl  -0x30(%ebp)
    6f08:	e8 7a c4 ff ff       	call   3387 <lodepng_memset>
    6f0d:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6f10:	83 ec 04             	sub    $0x4,%esp
    6f13:	6a 4c                	push   $0x4c
    6f15:	6a 00                	push   $0x0
    6f17:	ff 75 cc             	pushl  -0x34(%ebp)
    6f1a:	e8 68 c4 ff ff       	call   3387 <lodepng_memset>
    6f1f:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    6f22:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f25:	8b 40 04             	mov    0x4(%eax),%eax
    6f28:	85 c0                	test   %eax,%eax
    6f2a:	74 45                	je     6f71 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    6f2c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f2f:	8b 58 14             	mov    0x14(%eax),%ebx
    6f32:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f35:	8b 48 10             	mov    0x10(%eax),%ecx
    6f38:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f3b:	8b 50 0c             	mov    0xc(%eax),%edx
    6f3e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f41:	8b 40 08             	mov    0x8(%eax),%eax
    6f44:	83 ec 0c             	sub    $0xc,%esp
    6f47:	53                   	push   %ebx
    6f48:	51                   	push   %ecx
    6f49:	52                   	push   %edx
    6f4a:	50                   	push   %eax
    6f4b:	ff 75 18             	pushl  0x18(%ebp)
    6f4e:	ff 75 14             	pushl  0x14(%ebp)
    6f51:	ff 75 10             	pushl  0x10(%ebp)
    6f54:	ff 75 0c             	pushl  0xc(%ebp)
    6f57:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f5a:	50                   	push   %eax
    6f5b:	e8 bd f6 ff ff       	call   661d <encodeLZ77>
    6f60:	83 c4 30             	add    $0x30,%esp
    6f63:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    6f66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f6a:	74 59                	je     6fc5 <deflateDynamic+0x1ae>
    6f6c:	e9 6e 07 00 00       	jmp    76df <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    6f71:	83 ec 08             	sub    $0x8,%esp
    6f74:	ff 75 c8             	pushl  -0x38(%ebp)
    6f77:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f7a:	50                   	push   %eax
    6f7b:	e8 17 c5 ff ff       	call   3497 <uivector_resize>
    6f80:	83 c4 10             	add    $0x10,%esp
    6f83:	85 c0                	test   %eax,%eax
    6f85:	75 0c                	jne    6f93 <deflateDynamic+0x17c>
    6f87:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6f8e:	e9 4c 07 00 00       	jmp    76df <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    6f93:	8b 45 14             	mov    0x14(%ebp),%eax
    6f96:	89 45 e8             	mov    %eax,-0x18(%ebp)
    6f99:	eb 22                	jmp    6fbd <deflateDynamic+0x1a6>
    6f9b:	8b 55 90             	mov    -0x70(%ebp),%edx
    6f9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fa1:	2b 45 14             	sub    0x14(%ebp),%eax
    6fa4:	c1 e0 02             	shl    $0x2,%eax
    6fa7:	01 c2                	add    %eax,%edx
    6fa9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6fac:	8b 45 10             	mov    0x10(%ebp),%eax
    6faf:	01 c8                	add    %ecx,%eax
    6fb1:	0f b6 00             	movzbl (%eax),%eax
    6fb4:	0f b6 c0             	movzbl %al,%eax
    6fb7:	89 02                	mov    %eax,(%edx)
    6fb9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    6fbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fc0:	3b 45 18             	cmp    0x18(%ebp),%eax
    6fc3:	7c d6                	jl     6f9b <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    6fc5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    6fcc:	eb 60                	jmp    702e <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    6fce:	8b 45 90             	mov    -0x70(%ebp),%eax
    6fd1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6fd4:	c1 e2 02             	shl    $0x2,%edx
    6fd7:	01 d0                	add    %edx,%eax
    6fd9:	8b 00                	mov    (%eax),%eax
    6fdb:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    6fde:	8b 45 c0             	mov    -0x40(%ebp),%eax
    6fe1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6fe8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6feb:	01 d0                	add    %edx,%eax
    6fed:	8b 10                	mov    (%eax),%edx
    6fef:	83 c2 01             	add    $0x1,%edx
    6ff2:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    6ff4:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    6ffb:	76 2d                	jbe    702a <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    6ffd:	8b 45 90             	mov    -0x70(%ebp),%eax
    7000:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7003:	83 c2 02             	add    $0x2,%edx
    7006:	c1 e2 02             	shl    $0x2,%edx
    7009:	01 d0                	add    %edx,%eax
    700b:	8b 00                	mov    (%eax),%eax
    700d:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    7010:	8b 45 bc             	mov    -0x44(%ebp),%eax
    7013:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    701a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    701d:	01 d0                	add    %edx,%eax
    701f:	8b 10                	mov    (%eax),%edx
    7021:	83 c2 01             	add    $0x1,%edx
    7024:	89 10                	mov    %edx,(%eax)
        i += 3;
    7026:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    702a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    702e:	8b 45 94             	mov    -0x6c(%ebp),%eax
    7031:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7034:	75 98                	jne    6fce <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7036:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7039:	05 00 04 00 00       	add    $0x400,%eax
    703e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7044:	83 ec 0c             	sub    $0xc,%esp
    7047:	6a 0f                	push   $0xf
    7049:	68 1e 01 00 00       	push   $0x11e
    704e:	68 01 01 00 00       	push   $0x101
    7053:	ff 75 d4             	pushl  -0x2c(%ebp)
    7056:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    705c:	50                   	push   %eax
    705d:	e8 e0 e1 ff ff       	call   5242 <HuffmanTree_makeFromFrequencies>
    7062:	83 c4 20             	add    $0x20,%esp
    7065:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7068:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    706c:	0f 85 66 06 00 00    	jne    76d8 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7072:	83 ec 0c             	sub    $0xc,%esp
    7075:	6a 0f                	push   $0xf
    7077:	6a 1e                	push   $0x1e
    7079:	6a 02                	push   $0x2
    707b:	ff 75 d0             	pushl  -0x30(%ebp)
    707e:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7084:	50                   	push   %eax
    7085:	e8 b8 e1 ff ff       	call   5242 <HuffmanTree_makeFromFrequencies>
    708a:	83 c4 20             	add    $0x20,%esp
    708d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7090:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7094:	0f 85 41 06 00 00    	jne    76db <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    709a:	8b 45 84             	mov    -0x7c(%ebp),%eax
    709d:	ba 1e 01 00 00       	mov    $0x11e,%edx
    70a2:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    70a7:	0f 47 c2             	cmova  %edx,%eax
    70aa:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    70ad:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    70b3:	ba 1e 00 00 00       	mov    $0x1e,%edx
    70b8:	83 f8 1e             	cmp    $0x1e,%eax
    70bb:	0f 47 c2             	cmova  %edx,%eax
    70be:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    70c1:	8b 55 b8             	mov    -0x48(%ebp),%edx
    70c4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    70c7:	01 d0                	add    %edx,%eax
    70c9:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    70cc:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70cf:	c1 e0 02             	shl    $0x2,%eax
    70d2:	83 ec 0c             	sub    $0xc,%esp
    70d5:	50                   	push   %eax
    70d6:	e8 3b c2 ff ff       	call   3316 <lodepng_malloc>
    70db:	83 c4 10             	add    $0x10,%esp
    70de:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    70e1:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70e4:	c1 e0 02             	shl    $0x2,%eax
    70e7:	83 ec 0c             	sub    $0xc,%esp
    70ea:	50                   	push   %eax
    70eb:	e8 26 c2 ff ff       	call   3316 <lodepng_malloc>
    70f0:	83 c4 10             	add    $0x10,%esp
    70f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    70f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    70fa:	74 06                	je     7102 <deflateDynamic+0x2eb>
    70fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    7100:	75 0c                	jne    710e <deflateDynamic+0x2f7>
    7102:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7109:	e9 d1 05 00 00       	jmp    76df <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    710e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    7115:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    711c:	eb 25                	jmp    7143 <deflateDynamic+0x32c>
    711e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7121:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7128:	8b 45 f0             	mov    -0x10(%ebp),%eax
    712b:	01 c2                	add    %eax,%edx
    712d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7133:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7136:	c1 e1 02             	shl    $0x2,%ecx
    7139:	01 c8                	add    %ecx,%eax
    713b:	8b 00                	mov    (%eax),%eax
    713d:	89 02                	mov    %eax,(%edx)
    713f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7143:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7146:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7149:	75 d3                	jne    711e <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    714b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7152:	eb 2a                	jmp    717e <deflateDynamic+0x367>
    7154:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7157:	8b 45 e8             	mov    -0x18(%ebp),%eax
    715a:	01 d0                	add    %edx,%eax
    715c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7163:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7166:	01 c2                	add    %eax,%edx
    7168:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    716e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7171:	c1 e1 02             	shl    $0x2,%ecx
    7174:	01 c8                	add    %ecx,%eax
    7176:	8b 00                	mov    (%eax),%eax
    7178:	89 02                	mov    %eax,(%edx)
    717a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    717e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7181:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7184:	75 ce                	jne    7154 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7186:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    718d:	e9 3b 02 00 00       	jmp    73cd <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    7192:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    7199:	eb 04                	jmp    719f <deflateDynamic+0x388>
    719b:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    719f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71a5:	01 d0                	add    %edx,%eax
    71a7:	8d 50 01             	lea    0x1(%eax),%edx
    71aa:	8b 45 b0             	mov    -0x50(%ebp),%eax
    71ad:	39 c2                	cmp    %eax,%edx
    71af:	73 2e                	jae    71df <deflateDynamic+0x3c8>
    71b1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71b7:	01 d0                	add    %edx,%eax
    71b9:	83 c0 01             	add    $0x1,%eax
    71bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71c6:	01 d0                	add    %edx,%eax
    71c8:	8b 10                	mov    (%eax),%edx
    71ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71cd:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    71d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71d7:	01 c8                	add    %ecx,%eax
    71d9:	8b 00                	mov    (%eax),%eax
    71db:	39 c2                	cmp    %eax,%edx
    71dd:	74 bc                	je     719b <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    71df:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71e2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71ec:	01 d0                	add    %edx,%eax
    71ee:	8b 00                	mov    (%eax),%eax
    71f0:	85 c0                	test   %eax,%eax
    71f2:	0f 85 a9 00 00 00    	jne    72a1 <deflateDynamic+0x48a>
    71f8:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    71fc:	0f 86 9f 00 00 00    	jbe    72a1 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    7202:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    7206:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    720a:	77 3a                	ja     7246 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    720c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    720f:	8d 50 01             	lea    0x1(%eax),%edx
    7212:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7215:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    721c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    721f:	01 d0                	add    %edx,%eax
    7221:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    7227:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    722a:	8d 50 01             	lea    0x1(%eax),%edx
    722d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7230:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7237:	8b 45 ec             	mov    -0x14(%ebp),%eax
    723a:	01 d0                	add    %edx,%eax
    723c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    723f:	83 ea 03             	sub    $0x3,%edx
    7242:	89 10                	mov    %edx,(%eax)
    7244:	eb 48                	jmp    728e <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7246:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    724d:	76 07                	jbe    7256 <deflateDynamic+0x43f>
    724f:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7256:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7259:	8d 50 01             	lea    0x1(%eax),%edx
    725c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    725f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7266:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7269:	01 d0                	add    %edx,%eax
    726b:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7271:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7274:	8d 50 01             	lea    0x1(%eax),%edx
    7277:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    727a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7281:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7284:	01 d0                	add    %edx,%eax
    7286:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7289:	83 ea 0b             	sub    $0xb,%edx
    728c:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    728e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7291:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7294:	01 d0                	add    %edx,%eax
    7296:	83 e8 01             	sub    $0x1,%eax
    7299:	89 45 e8             	mov    %eax,-0x18(%ebp)
    729c:	e9 28 01 00 00       	jmp    73c9 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    72a1:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    72a5:	0f 86 f6 00 00 00    	jbe    73a1 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    72ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72ae:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72b3:	f7 e2                	mul    %edx
    72b5:	89 d0                	mov    %edx,%eax
    72b7:	c1 e8 02             	shr    $0x2,%eax
    72ba:	89 45 ac             	mov    %eax,-0x54(%ebp)
    72bd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    72c0:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72c5:	89 c8                	mov    %ecx,%eax
    72c7:	f7 e2                	mul    %edx
    72c9:	c1 ea 02             	shr    $0x2,%edx
    72cc:	89 d0                	mov    %edx,%eax
    72ce:	01 c0                	add    %eax,%eax
    72d0:	01 d0                	add    %edx,%eax
    72d2:	01 c0                	add    %eax,%eax
    72d4:	29 c1                	sub    %eax,%ecx
    72d6:	89 c8                	mov    %ecx,%eax
    72d8:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    72db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72de:	8d 50 01             	lea    0x1(%eax),%edx
    72e1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72ee:	01 c2                	add    %eax,%edx
    72f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72f3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    72fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72fd:	01 c8                	add    %ecx,%eax
    72ff:	8b 00                	mov    (%eax),%eax
    7301:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    7303:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    730a:	eb 3a                	jmp    7346 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    730c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    730f:	8d 50 01             	lea    0x1(%eax),%edx
    7312:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7315:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    731c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    731f:	01 d0                	add    %edx,%eax
    7321:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7327:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    732a:	8d 50 01             	lea    0x1(%eax),%edx
    732d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7330:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7337:	8b 45 ec             	mov    -0x14(%ebp),%eax
    733a:	01 d0                	add    %edx,%eax
    733c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7342:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7346:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7349:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    734c:	72 be                	jb     730c <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    734e:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7352:	76 3a                	jbe    738e <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7354:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7357:	8d 50 01             	lea    0x1(%eax),%edx
    735a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    735d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7364:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7367:	01 d0                	add    %edx,%eax
    7369:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    736f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7372:	8d 50 01             	lea    0x1(%eax),%edx
    7375:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7378:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    737f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7382:	01 d0                	add    %edx,%eax
    7384:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7387:	83 ea 03             	sub    $0x3,%edx
    738a:	89 10                	mov    %edx,(%eax)
    738c:	eb 06                	jmp    7394 <deflateDynamic+0x57d>
        }
        else j -= rest;
    738e:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7391:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7394:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7397:	8b 45 dc             	mov    -0x24(%ebp),%eax
    739a:	01 d0                	add    %edx,%eax
    739c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    739f:	eb 28                	jmp    73c9 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    73a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73a4:	8d 50 01             	lea    0x1(%eax),%edx
    73a7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73b4:	01 c2                	add    %eax,%edx
    73b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73b9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    73c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73c3:	01 c8                	add    %ecx,%eax
    73c5:	8b 00                	mov    (%eax),%eax
    73c7:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    73c9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    73cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73d0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    73d3:	0f 85 b9 fd ff ff    	jne    7192 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    73d9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    73e0:	eb 42                	jmp    7424 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    73e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73ef:	01 d0                	add    %edx,%eax
    73f1:	8b 00                	mov    (%eax),%eax
    73f3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
    73fd:	01 d0                	add    %edx,%eax
    73ff:	8b 10                	mov    (%eax),%edx
    7401:	83 c2 01             	add    $0x1,%edx
    7404:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    7406:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7409:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7410:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7413:	01 d0                	add    %edx,%eax
    7415:	8b 00                	mov    (%eax),%eax
    7417:	83 f8 0f             	cmp    $0xf,%eax
    741a:	76 04                	jbe    7420 <deflateDynamic+0x609>
    741c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7420:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7424:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7427:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    742a:	75 b6                	jne    73e2 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    742c:	83 ec 0c             	sub    $0xc,%esp
    742f:	6a 07                	push   $0x7
    7431:	6a 13                	push   $0x13
    7433:	6a 13                	push   $0x13
    7435:	ff 75 cc             	pushl  -0x34(%ebp)
    7438:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    743e:	50                   	push   %eax
    743f:	e8 fe dd ff ff       	call   5242 <HuffmanTree_makeFromFrequencies>
    7444:	83 c4 20             	add    $0x20,%esp
    7447:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    744a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    744e:	0f 85 8a 02 00 00    	jne    76de <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7454:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    745b:	eb 04                	jmp    7461 <deflateDynamic+0x64a>
      numcodes_cl--;
    745d:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7461:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7464:	83 f8 04             	cmp    $0x4,%eax
    7467:	76 1e                	jbe    7487 <deflateDynamic+0x670>
    7469:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    746f:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7472:	83 ea 01             	sub    $0x1,%edx
    7475:	8b 14 95 20 9f 01 00 	mov    0x19f20(,%edx,4),%edx
    747c:	c1 e2 02             	shl    $0x2,%edx
    747f:	01 d0                	add    %edx,%eax
    7481:	8b 00                	mov    (%eax),%eax
    7483:	85 c0                	test   %eax,%eax
    7485:	74 d6                	je     745d <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7487:	83 ec 04             	sub    $0x4,%esp
    748a:	6a 01                	push   $0x1
    748c:	ff 75 c4             	pushl  -0x3c(%ebp)
    748f:	ff 75 08             	pushl  0x8(%ebp)
    7492:	e8 67 c3 ff ff       	call   37fe <writeBits>
    7497:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    749a:	83 ec 04             	sub    $0x4,%esp
    749d:	6a 01                	push   $0x1
    749f:	6a 00                	push   $0x0
    74a1:	ff 75 08             	pushl  0x8(%ebp)
    74a4:	e8 55 c3 ff ff       	call   37fe <writeBits>
    74a9:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    74ac:	83 ec 04             	sub    $0x4,%esp
    74af:	6a 01                	push   $0x1
    74b1:	6a 01                	push   $0x1
    74b3:	ff 75 08             	pushl  0x8(%ebp)
    74b6:	e8 43 c3 ff ff       	call   37fe <writeBits>
    74bb:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    74be:	8b 45 b8             	mov    -0x48(%ebp),%eax
    74c1:	2d 01 01 00 00       	sub    $0x101,%eax
    74c6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    74c9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    74cc:	83 e8 01             	sub    $0x1,%eax
    74cf:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    74d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    74d5:	83 e8 04             	sub    $0x4,%eax
    74d8:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    74db:	83 ec 04             	sub    $0x4,%esp
    74de:	6a 05                	push   $0x5
    74e0:	ff 75 a4             	pushl  -0x5c(%ebp)
    74e3:	ff 75 08             	pushl  0x8(%ebp)
    74e6:	e8 13 c3 ff ff       	call   37fe <writeBits>
    74eb:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    74ee:	83 ec 04             	sub    $0x4,%esp
    74f1:	6a 05                	push   $0x5
    74f3:	ff 75 a0             	pushl  -0x60(%ebp)
    74f6:	ff 75 08             	pushl  0x8(%ebp)
    74f9:	e8 00 c3 ff ff       	call   37fe <writeBits>
    74fe:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    7501:	83 ec 04             	sub    $0x4,%esp
    7504:	6a 04                	push   $0x4
    7506:	ff 75 9c             	pushl  -0x64(%ebp)
    7509:	ff 75 08             	pushl  0x8(%ebp)
    750c:	e8 ed c2 ff ff       	call   37fe <writeBits>
    7511:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    7514:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    751b:	eb 2c                	jmp    7549 <deflateDynamic+0x732>
    751d:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    7523:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7526:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    752d:	c1 e0 02             	shl    $0x2,%eax
    7530:	01 d0                	add    %edx,%eax
    7532:	8b 00                	mov    (%eax),%eax
    7534:	83 ec 04             	sub    $0x4,%esp
    7537:	6a 03                	push   $0x3
    7539:	50                   	push   %eax
    753a:	ff 75 08             	pushl  0x8(%ebp)
    753d:	e8 bc c2 ff ff       	call   37fe <writeBits>
    7542:	83 c4 10             	add    $0x10,%esp
    7545:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7549:	8b 45 e8             	mov    -0x18(%ebp),%eax
    754c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    754f:	75 cc                	jne    751d <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7551:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7558:	e9 0a 01 00 00       	jmp    7667 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    755d:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7563:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7566:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    756d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7570:	01 ca                	add    %ecx,%edx
    7572:	8b 12                	mov    (%edx),%edx
    7574:	c1 e2 02             	shl    $0x2,%edx
    7577:	01 d0                	add    %edx,%eax
    7579:	8b 00                	mov    (%eax),%eax
    757b:	89 c3                	mov    %eax,%ebx
    757d:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7583:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7586:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    758d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7590:	01 ca                	add    %ecx,%edx
    7592:	8b 12                	mov    (%edx),%edx
    7594:	c1 e2 02             	shl    $0x2,%edx
    7597:	01 d0                	add    %edx,%eax
    7599:	8b 00                	mov    (%eax),%eax
    759b:	83 ec 04             	sub    $0x4,%esp
    759e:	53                   	push   %ebx
    759f:	50                   	push   %eax
    75a0:	ff 75 08             	pushl  0x8(%ebp)
    75a3:	e8 ea c3 ff ff       	call   3992 <writeBitsReversed>
    75a8:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    75ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75b8:	01 d0                	add    %edx,%eax
    75ba:	8b 00                	mov    (%eax),%eax
    75bc:	83 f8 10             	cmp    $0x10,%eax
    75bf:	75 28                	jne    75e9 <deflateDynamic+0x7d2>
    75c1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75d2:	01 d0                	add    %edx,%eax
    75d4:	8b 00                	mov    (%eax),%eax
    75d6:	83 ec 04             	sub    $0x4,%esp
    75d9:	6a 02                	push   $0x2
    75db:	50                   	push   %eax
    75dc:	ff 75 08             	pushl  0x8(%ebp)
    75df:	e8 1a c2 ff ff       	call   37fe <writeBits>
    75e4:	83 c4 10             	add    $0x10,%esp
    75e7:	eb 7a                	jmp    7663 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    75e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75ec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75f6:	01 d0                	add    %edx,%eax
    75f8:	8b 00                	mov    (%eax),%eax
    75fa:	83 f8 11             	cmp    $0x11,%eax
    75fd:	75 28                	jne    7627 <deflateDynamic+0x810>
    75ff:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7603:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7606:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    760d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7610:	01 d0                	add    %edx,%eax
    7612:	8b 00                	mov    (%eax),%eax
    7614:	83 ec 04             	sub    $0x4,%esp
    7617:	6a 03                	push   $0x3
    7619:	50                   	push   %eax
    761a:	ff 75 08             	pushl  0x8(%ebp)
    761d:	e8 dc c1 ff ff       	call   37fe <writeBits>
    7622:	83 c4 10             	add    $0x10,%esp
    7625:	eb 3c                	jmp    7663 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7627:	8b 45 e8             	mov    -0x18(%ebp),%eax
    762a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7631:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7634:	01 d0                	add    %edx,%eax
    7636:	8b 00                	mov    (%eax),%eax
    7638:	83 f8 12             	cmp    $0x12,%eax
    763b:	75 26                	jne    7663 <deflateDynamic+0x84c>
    763d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7641:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    764b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    764e:	01 d0                	add    %edx,%eax
    7650:	8b 00                	mov    (%eax),%eax
    7652:	83 ec 04             	sub    $0x4,%esp
    7655:	6a 07                	push   $0x7
    7657:	50                   	push   %eax
    7658:	ff 75 08             	pushl  0x8(%ebp)
    765b:	e8 9e c1 ff ff       	call   37fe <writeBits>
    7660:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7663:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7667:	8b 45 e8             	mov    -0x18(%ebp),%eax
    766a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    766d:	0f 85 ea fe ff ff    	jne    755d <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7673:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7679:	50                   	push   %eax
    767a:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7680:	50                   	push   %eax
    7681:	8d 45 90             	lea    -0x70(%ebp),%eax
    7684:	50                   	push   %eax
    7685:	ff 75 08             	pushl  0x8(%ebp)
    7688:	e8 4f f6 ff ff       	call   6cdc <writeLZ77data>
    768d:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    7690:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7696:	05 00 04 00 00       	add    $0x400,%eax
    769b:	8b 00                	mov    (%eax),%eax
    769d:	85 c0                	test   %eax,%eax
    769f:	75 09                	jne    76aa <deflateDynamic+0x893>
    76a1:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    76a8:	eb 35                	jmp    76df <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    76aa:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76b0:	05 00 04 00 00       	add    $0x400,%eax
    76b5:	8b 00                	mov    (%eax),%eax
    76b7:	89 c2                	mov    %eax,%edx
    76b9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    76bf:	05 00 04 00 00       	add    $0x400,%eax
    76c4:	8b 00                	mov    (%eax),%eax
    76c6:	83 ec 04             	sub    $0x4,%esp
    76c9:	52                   	push   %edx
    76ca:	50                   	push   %eax
    76cb:	ff 75 08             	pushl  0x8(%ebp)
    76ce:	e8 bf c2 ff ff       	call   3992 <writeBitsReversed>
    76d3:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    76d6:	eb 07                	jmp    76df <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    76d8:	90                   	nop
    76d9:	eb 04                	jmp    76df <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    76db:	90                   	nop
    76dc:	eb 01                	jmp    76df <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    76de:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    76df:	83 ec 0c             	sub    $0xc,%esp
    76e2:	8d 45 90             	lea    -0x70(%ebp),%eax
    76e5:	50                   	push   %eax
    76e6:	e8 73 bd ff ff       	call   345e <uivector_cleanup>
    76eb:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    76ee:	83 ec 0c             	sub    $0xc,%esp
    76f1:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    76f7:	50                   	push   %eax
    76f8:	e8 3a cb ff ff       	call   4237 <HuffmanTree_cleanup>
    76fd:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7700:	83 ec 0c             	sub    $0xc,%esp
    7703:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7709:	50                   	push   %eax
    770a:	e8 28 cb ff ff       	call   4237 <HuffmanTree_cleanup>
    770f:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    7712:	83 ec 0c             	sub    $0xc,%esp
    7715:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    771b:	50                   	push   %eax
    771c:	e8 16 cb ff ff       	call   4237 <HuffmanTree_cleanup>
    7721:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7724:	83 ec 0c             	sub    $0xc,%esp
    7727:	ff 75 d4             	pushl  -0x2c(%ebp)
    772a:	e8 08 bc ff ff       	call   3337 <lodepng_free>
    772f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    7732:	83 ec 0c             	sub    $0xc,%esp
    7735:	ff 75 d0             	pushl  -0x30(%ebp)
    7738:	e8 fa bb ff ff       	call   3337 <lodepng_free>
    773d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7740:	83 ec 0c             	sub    $0xc,%esp
    7743:	ff 75 cc             	pushl  -0x34(%ebp)
    7746:	e8 ec bb ff ff       	call   3337 <lodepng_free>
    774b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    774e:	83 ec 0c             	sub    $0xc,%esp
    7751:	ff 75 f0             	pushl  -0x10(%ebp)
    7754:	e8 de bb ff ff       	call   3337 <lodepng_free>
    7759:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    775c:	83 ec 0c             	sub    $0xc,%esp
    775f:	ff 75 ec             	pushl  -0x14(%ebp)
    7762:	e8 d0 bb ff ff       	call   3337 <lodepng_free>
    7767:	83 c4 10             	add    $0x10,%esp

  return error;
    776a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    776d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7770:	c9                   	leave  
    7771:	c3                   	ret    

00007772 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7772:	55                   	push   %ebp
    7773:	89 e5                	mov    %esp,%ebp
    7775:	53                   	push   %ebx
    7776:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7779:	8b 45 20             	mov    0x20(%ebp),%eax
    777c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    777f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7786:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7789:	50                   	push   %eax
    778a:	e8 7b ca ff ff       	call   420a <HuffmanTree_init>
    778f:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7792:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7795:	50                   	push   %eax
    7796:	e8 6f ca ff ff       	call   420a <HuffmanTree_init>
    779b:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    779e:	83 ec 0c             	sub    $0xc,%esp
    77a1:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    77a4:	50                   	push   %eax
    77a5:	e8 41 db ff ff       	call   52eb <generateFixedLitLenTree>
    77aa:	83 c4 10             	add    $0x10,%esp
    77ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    77b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77b4:	75 12                	jne    77c8 <deflateFixed+0x56>
    77b6:	83 ec 0c             	sub    $0xc,%esp
    77b9:	8d 45 bc             	lea    -0x44(%ebp),%eax
    77bc:	50                   	push   %eax
    77bd:	e8 30 dc ff ff       	call   53f2 <generateFixedDistanceTree>
    77c2:	83 c4 10             	add    $0x10,%esp
    77c5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    77c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77cc:	0f 85 3a 01 00 00    	jne    790c <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    77d2:	83 ec 04             	sub    $0x4,%esp
    77d5:	6a 01                	push   $0x1
    77d7:	ff 75 ec             	pushl  -0x14(%ebp)
    77da:	ff 75 08             	pushl  0x8(%ebp)
    77dd:	e8 1c c0 ff ff       	call   37fe <writeBits>
    77e2:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    77e5:	83 ec 04             	sub    $0x4,%esp
    77e8:	6a 01                	push   $0x1
    77ea:	6a 01                	push   $0x1
    77ec:	ff 75 08             	pushl  0x8(%ebp)
    77ef:	e8 0a c0 ff ff       	call   37fe <writeBits>
    77f4:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    77f7:	83 ec 04             	sub    $0x4,%esp
    77fa:	6a 01                	push   $0x1
    77fc:	6a 00                	push   $0x0
    77fe:	ff 75 08             	pushl  0x8(%ebp)
    7801:	e8 f8 bf ff ff       	call   37fe <writeBits>
    7806:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7809:	8b 45 1c             	mov    0x1c(%ebp),%eax
    780c:	8b 40 04             	mov    0x4(%eax),%eax
    780f:	85 c0                	test   %eax,%eax
    7811:	74 77                	je     788a <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7813:	83 ec 0c             	sub    $0xc,%esp
    7816:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7819:	50                   	push   %eax
    781a:	e8 e8 bc ff ff       	call   3507 <uivector_init>
    781f:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7822:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7825:	8b 58 14             	mov    0x14(%eax),%ebx
    7828:	8b 45 1c             	mov    0x1c(%ebp),%eax
    782b:	8b 48 10             	mov    0x10(%eax),%ecx
    782e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7831:	8b 50 0c             	mov    0xc(%eax),%edx
    7834:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7837:	8b 40 08             	mov    0x8(%eax),%eax
    783a:	83 ec 0c             	sub    $0xc,%esp
    783d:	53                   	push   %ebx
    783e:	51                   	push   %ecx
    783f:	52                   	push   %edx
    7840:	50                   	push   %eax
    7841:	ff 75 18             	pushl  0x18(%ebp)
    7844:	ff 75 14             	pushl  0x14(%ebp)
    7847:	ff 75 10             	pushl  0x10(%ebp)
    784a:	ff 75 0c             	pushl  0xc(%ebp)
    784d:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7850:	50                   	push   %eax
    7851:	e8 c7 ed ff ff       	call   661d <encodeLZ77>
    7856:	83 c4 30             	add    $0x30,%esp
    7859:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    785c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7860:	75 17                	jne    7879 <deflateFixed+0x107>
    7862:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7865:	50                   	push   %eax
    7866:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7869:	50                   	push   %eax
    786a:	8d 45 b0             	lea    -0x50(%ebp),%eax
    786d:	50                   	push   %eax
    786e:	ff 75 08             	pushl  0x8(%ebp)
    7871:	e8 66 f4 ff ff       	call   6cdc <writeLZ77data>
    7876:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7879:	83 ec 0c             	sub    $0xc,%esp
    787c:	8d 45 b0             	lea    -0x50(%ebp),%eax
    787f:	50                   	push   %eax
    7880:	e8 d9 bb ff ff       	call   345e <uivector_cleanup>
    7885:	83 c4 10             	add    $0x10,%esp
    7888:	eb 56                	jmp    78e0 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    788a:	8b 45 14             	mov    0x14(%ebp),%eax
    788d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7890:	eb 46                	jmp    78d8 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    7892:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7895:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7898:	8b 55 10             	mov    0x10(%ebp),%edx
    789b:	01 ca                	add    %ecx,%edx
    789d:	0f b6 12             	movzbl (%edx),%edx
    78a0:	0f b6 d2             	movzbl %dl,%edx
    78a3:	c1 e2 02             	shl    $0x2,%edx
    78a6:	01 d0                	add    %edx,%eax
    78a8:	8b 00                	mov    (%eax),%eax
    78aa:	89 c3                	mov    %eax,%ebx
    78ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    78af:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    78b2:	8b 55 10             	mov    0x10(%ebp),%edx
    78b5:	01 ca                	add    %ecx,%edx
    78b7:	0f b6 12             	movzbl (%edx),%edx
    78ba:	0f b6 d2             	movzbl %dl,%edx
    78bd:	c1 e2 02             	shl    $0x2,%edx
    78c0:	01 d0                	add    %edx,%eax
    78c2:	8b 00                	mov    (%eax),%eax
    78c4:	83 ec 04             	sub    $0x4,%esp
    78c7:	53                   	push   %ebx
    78c8:	50                   	push   %eax
    78c9:	ff 75 08             	pushl  0x8(%ebp)
    78cc:	e8 c1 c0 ff ff       	call   3992 <writeBitsReversed>
    78d1:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    78d4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    78d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    78db:	3b 45 18             	cmp    0x18(%ebp),%eax
    78de:	7c b2                	jl     7892 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    78e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    78e4:	75 26                	jne    790c <deflateFixed+0x19a>
    78e6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78e9:	05 00 04 00 00       	add    $0x400,%eax
    78ee:	8b 00                	mov    (%eax),%eax
    78f0:	89 c2                	mov    %eax,%edx
    78f2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    78f5:	05 00 04 00 00       	add    $0x400,%eax
    78fa:	8b 00                	mov    (%eax),%eax
    78fc:	83 ec 04             	sub    $0x4,%esp
    78ff:	52                   	push   %edx
    7900:	50                   	push   %eax
    7901:	ff 75 08             	pushl  0x8(%ebp)
    7904:	e8 89 c0 ff ff       	call   3992 <writeBitsReversed>
    7909:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    790c:	83 ec 0c             	sub    $0xc,%esp
    790f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7912:	50                   	push   %eax
    7913:	e8 1f c9 ff ff       	call   4237 <HuffmanTree_cleanup>
    7918:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    791b:	83 ec 0c             	sub    $0xc,%esp
    791e:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7921:	50                   	push   %eax
    7922:	e8 10 c9 ff ff       	call   4237 <HuffmanTree_cleanup>
    7927:	83 c4 10             	add    $0x10,%esp

  return error;
    792a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    792d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7930:	c9                   	leave  
    7931:	c3                   	ret    

00007932 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7932:	55                   	push   %ebp
    7933:	89 e5                	mov    %esp,%ebp
    7935:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7938:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    793f:	ff 75 08             	pushl  0x8(%ebp)
    7942:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7945:	50                   	push   %eax
    7946:	e8 9e be ff ff       	call   37e9 <LodePNGBitWriter_init>
    794b:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    794e:	8b 45 14             	mov    0x14(%ebp),%eax
    7951:	8b 00                	mov    (%eax),%eax
    7953:	83 f8 02             	cmp    $0x2,%eax
    7956:	76 0a                	jbe    7962 <lodepng_deflatev+0x30>
    7958:	b8 3d 00 00 00       	mov    $0x3d,%eax
    795d:	e9 68 01 00 00       	jmp    7aca <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7962:	8b 45 14             	mov    0x14(%ebp),%eax
    7965:	8b 00                	mov    (%eax),%eax
    7967:	85 c0                	test   %eax,%eax
    7969:	75 16                	jne    7981 <lodepng_deflatev+0x4f>
    796b:	ff 75 10             	pushl  0x10(%ebp)
    796e:	ff 75 0c             	pushl  0xc(%ebp)
    7971:	ff 75 08             	pushl  0x8(%ebp)
    7974:	e8 01 f2 ff ff       	call   6b7a <deflateNoCompression>
    7979:	83 c4 0c             	add    $0xc,%esp
    797c:	e9 49 01 00 00       	jmp    7aca <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7981:	8b 45 14             	mov    0x14(%ebp),%eax
    7984:	8b 00                	mov    (%eax),%eax
    7986:	83 f8 01             	cmp    $0x1,%eax
    7989:	75 08                	jne    7993 <lodepng_deflatev+0x61>
    798b:	8b 45 10             	mov    0x10(%ebp),%eax
    798e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7991:	eb 2c                	jmp    79bf <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7993:	8b 45 10             	mov    0x10(%ebp),%eax
    7996:	c1 e8 03             	shr    $0x3,%eax
    7999:	83 c0 08             	add    $0x8,%eax
    799c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    799f:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    79a6:	7f 07                	jg     79af <lodepng_deflatev+0x7d>
    79a8:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    79af:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    79b6:	7e 07                	jle    79bf <lodepng_deflatev+0x8d>
    79b8:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    79bf:	8b 55 10             	mov    0x10(%ebp),%edx
    79c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79c5:	01 d0                	add    %edx,%eax
    79c7:	83 e8 01             	sub    $0x1,%eax
    79ca:	99                   	cltd   
    79cb:	f7 7d ec             	idivl  -0x14(%ebp)
    79ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    79d1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    79d5:	75 07                	jne    79de <lodepng_deflatev+0xac>
    79d7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    79de:	8b 45 14             	mov    0x14(%ebp),%eax
    79e1:	8b 40 08             	mov    0x8(%eax),%eax
    79e4:	83 ec 08             	sub    $0x8,%esp
    79e7:	50                   	push   %eax
    79e8:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    79eb:	50                   	push   %eax
    79ec:	e8 1c e8 ff ff       	call   620d <hash_init>
    79f1:	83 c4 10             	add    $0x10,%esp
    79f4:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    79f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    79fb:	0f 85 b7 00 00 00    	jne    7ab8 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7a01:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7a08:	e9 99 00 00 00       	jmp    7aa6 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7a0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a10:	83 e8 01             	sub    $0x1,%eax
    7a13:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7a16:	0f 94 c0             	sete   %al
    7a19:	0f b6 c0             	movzbl %al,%eax
    7a1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7a1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7a22:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7a26:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7a29:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7a2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a2f:	01 d0                	add    %edx,%eax
    7a31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7a34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a37:	3b 45 10             	cmp    0x10(%ebp),%eax
    7a3a:	7e 06                	jle    7a42 <lodepng_deflatev+0x110>
    7a3c:	8b 45 10             	mov    0x10(%ebp),%eax
    7a3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7a42:	8b 45 14             	mov    0x14(%ebp),%eax
    7a45:	8b 00                	mov    (%eax),%eax
    7a47:	83 f8 01             	cmp    $0x1,%eax
    7a4a:	75 27                	jne    7a73 <lodepng_deflatev+0x141>
    7a4c:	83 ec 04             	sub    $0x4,%esp
    7a4f:	ff 75 e0             	pushl  -0x20(%ebp)
    7a52:	ff 75 14             	pushl  0x14(%ebp)
    7a55:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a58:	ff 75 dc             	pushl  -0x24(%ebp)
    7a5b:	ff 75 0c             	pushl  0xc(%ebp)
    7a5e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a61:	50                   	push   %eax
    7a62:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a65:	50                   	push   %eax
    7a66:	e8 07 fd ff ff       	call   7772 <deflateFixed>
    7a6b:	83 c4 20             	add    $0x20,%esp
    7a6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7a71:	eb 2f                	jmp    7aa2 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7a73:	8b 45 14             	mov    0x14(%ebp),%eax
    7a76:	8b 00                	mov    (%eax),%eax
    7a78:	83 f8 02             	cmp    $0x2,%eax
    7a7b:	75 25                	jne    7aa2 <lodepng_deflatev+0x170>
    7a7d:	83 ec 04             	sub    $0x4,%esp
    7a80:	ff 75 e0             	pushl  -0x20(%ebp)
    7a83:	ff 75 14             	pushl  0x14(%ebp)
    7a86:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a89:	ff 75 dc             	pushl  -0x24(%ebp)
    7a8c:	ff 75 0c             	pushl  0xc(%ebp)
    7a8f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a92:	50                   	push   %eax
    7a93:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a96:	50                   	push   %eax
    7a97:	e8 7b f3 ff ff       	call   6e17 <deflateDynamic>
    7a9c:	83 c4 20             	add    $0x20,%esp
    7a9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7aa2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7aa6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7aa9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7aac:	74 0a                	je     7ab8 <lodepng_deflatev+0x186>
    7aae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ab2:	0f 84 55 ff ff ff    	je     7a0d <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7ab8:	83 ec 0c             	sub    $0xc,%esp
    7abb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7abe:	50                   	push   %eax
    7abf:	e8 08 e9 ff ff       	call   63cc <hash_cleanup>
    7ac4:	83 c4 10             	add    $0x10,%esp

  return error;
    7ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7aca:	c9                   	leave  
    7acb:	c3                   	ret    

00007acc <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7acc:	55                   	push   %ebp
    7acd:	89 e5                	mov    %esp,%ebp
    7acf:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7ad2:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ad5:	8b 08                	mov    (%eax),%ecx
    7ad7:	8b 45 08             	mov    0x8(%ebp),%eax
    7ada:	8b 10                	mov    (%eax),%edx
    7adc:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7adf:	51                   	push   %ecx
    7ae0:	52                   	push   %edx
    7ae1:	50                   	push   %eax
    7ae2:	e8 f0 ba ff ff       	call   35d7 <ucvector_init>
    7ae7:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7aea:	ff 75 18             	pushl  0x18(%ebp)
    7aed:	ff 75 14             	pushl  0x14(%ebp)
    7af0:	ff 75 10             	pushl  0x10(%ebp)
    7af3:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7af6:	50                   	push   %eax
    7af7:	e8 36 fe ff ff       	call   7932 <lodepng_deflatev>
    7afc:	83 c4 10             	add    $0x10,%esp
    7aff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7b02:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7b05:	8b 45 08             	mov    0x8(%ebp),%eax
    7b08:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7b0a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7b0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b10:	89 10                	mov    %edx,(%eax)
  return error;
    7b12:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7b15:	c9                   	leave  
    7b16:	c3                   	ret    

00007b17 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7b17:	55                   	push   %ebp
    7b18:	89 e5                	mov    %esp,%ebp
    7b1a:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7b1d:	8b 45 18             	mov    0x18(%ebp),%eax
    7b20:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b23:	85 c0                	test   %eax,%eax
    7b25:	74 34                	je     7b5b <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7b27:	8b 45 18             	mov    0x18(%ebp),%eax
    7b2a:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b2d:	83 ec 0c             	sub    $0xc,%esp
    7b30:	ff 75 18             	pushl  0x18(%ebp)
    7b33:	ff 75 14             	pushl  0x14(%ebp)
    7b36:	ff 75 10             	pushl  0x10(%ebp)
    7b39:	ff 75 0c             	pushl  0xc(%ebp)
    7b3c:	ff 75 08             	pushl  0x8(%ebp)
    7b3f:	ff d0                	call   *%eax
    7b41:	83 c4 20             	add    $0x20,%esp
    7b44:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7b47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b4b:	74 07                	je     7b54 <deflate+0x3d>
    7b4d:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7b52:	eb 21                	jmp    7b75 <deflate+0x5e>
    7b54:	b8 00 00 00 00       	mov    $0x0,%eax
    7b59:	eb 1a                	jmp    7b75 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7b5b:	83 ec 0c             	sub    $0xc,%esp
    7b5e:	ff 75 18             	pushl  0x18(%ebp)
    7b61:	ff 75 14             	pushl  0x14(%ebp)
    7b64:	ff 75 10             	pushl  0x10(%ebp)
    7b67:	ff 75 0c             	pushl  0xc(%ebp)
    7b6a:	ff 75 08             	pushl  0x8(%ebp)
    7b6d:	e8 5a ff ff ff       	call   7acc <lodepng_deflate>
    7b72:	83 c4 20             	add    $0x20,%esp
  }
}
    7b75:	c9                   	leave  
    7b76:	c3                   	ret    

00007b77 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7b77:	55                   	push   %ebp
    7b78:	89 e5                	mov    %esp,%ebp
    7b7a:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7b7d:	8b 45 08             	mov    0x8(%ebp),%eax
    7b80:	0f b7 c0             	movzwl %ax,%eax
    7b83:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7b86:	8b 45 08             	mov    0x8(%ebp),%eax
    7b89:	c1 e8 10             	shr    $0x10,%eax
    7b8c:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7b8f:	e9 82 00 00 00       	jmp    7c16 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7b94:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7b99:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7ba0:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7ba4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7ba7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7baa:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7bad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7bb4:	eb 1c                	jmp    7bd2 <update_adler32+0x5b>
      s1 += (*data++);
    7bb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bb9:	8d 50 01             	lea    0x1(%eax),%edx
    7bbc:	89 55 0c             	mov    %edx,0xc(%ebp)
    7bbf:	0f b6 00             	movzbl (%eax),%eax
    7bc2:	0f b6 c0             	movzbl %al,%eax
    7bc5:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7bc8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7bcb:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7bce:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7bd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7bd5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7bd8:	75 dc                	jne    7bb6 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7bda:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7bdd:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7be2:	89 c8                	mov    %ecx,%eax
    7be4:	f7 e2                	mul    %edx
    7be6:	89 d0                	mov    %edx,%eax
    7be8:	c1 e8 0f             	shr    $0xf,%eax
    7beb:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7bf1:	29 c1                	sub    %eax,%ecx
    7bf3:	89 c8                	mov    %ecx,%eax
    7bf5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7bf8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7bfb:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c00:	89 c8                	mov    %ecx,%eax
    7c02:	f7 e2                	mul    %edx
    7c04:	89 d0                	mov    %edx,%eax
    7c06:	c1 e8 0f             	shr    $0xf,%eax
    7c09:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c0f:	29 c1                	sub    %eax,%ecx
    7c11:	89 c8                	mov    %ecx,%eax
    7c13:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7c16:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7c1a:	0f 85 74 ff ff ff    	jne    7b94 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7c20:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c23:	c1 e0 10             	shl    $0x10,%eax
    7c26:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7c29:	c9                   	leave  
    7c2a:	c3                   	ret    

00007c2b <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7c2b:	55                   	push   %ebp
    7c2c:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7c2e:	ff 75 0c             	pushl  0xc(%ebp)
    7c31:	ff 75 08             	pushl  0x8(%ebp)
    7c34:	6a 01                	push   $0x1
    7c36:	e8 3c ff ff ff       	call   7b77 <update_adler32>
    7c3b:	83 c4 0c             	add    $0xc,%esp
}
    7c3e:	c9                   	leave  
    7c3f:	c3                   	ret    

00007c40 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7c40:	55                   	push   %ebp
    7c41:	89 e5                	mov    %esp,%ebp
    7c43:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7c46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7c4d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7c51:	7f 0a                	jg     7c5d <lodepng_zlib_decompressv+0x1d>
    7c53:	b8 35 00 00 00       	mov    $0x35,%eax
    7c58:	e9 27 01 00 00       	jmp    7d84 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7c5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c60:	0f b6 00             	movzbl (%eax),%eax
    7c63:	0f b6 c0             	movzbl %al,%eax
    7c66:	c1 e0 08             	shl    $0x8,%eax
    7c69:	89 c2                	mov    %eax,%edx
    7c6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c6e:	83 c0 01             	add    $0x1,%eax
    7c71:	0f b6 00             	movzbl (%eax),%eax
    7c74:	0f b6 c0             	movzbl %al,%eax
    7c77:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7c7a:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7c7f:	89 c8                	mov    %ecx,%eax
    7c81:	f7 ea                	imul   %edx
    7c83:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7c86:	c1 f8 04             	sar    $0x4,%eax
    7c89:	89 c2                	mov    %eax,%edx
    7c8b:	89 c8                	mov    %ecx,%eax
    7c8d:	c1 f8 1f             	sar    $0x1f,%eax
    7c90:	29 c2                	sub    %eax,%edx
    7c92:	89 d0                	mov    %edx,%eax
    7c94:	89 c2                	mov    %eax,%edx
    7c96:	c1 e2 05             	shl    $0x5,%edx
    7c99:	29 c2                	sub    %eax,%edx
    7c9b:	89 c8                	mov    %ecx,%eax
    7c9d:	29 d0                	sub    %edx,%eax
    7c9f:	85 c0                	test   %eax,%eax
    7ca1:	74 0a                	je     7cad <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7ca3:	b8 18 00 00 00       	mov    $0x18,%eax
    7ca8:	e9 d7 00 00 00       	jmp    7d84 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7cad:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cb0:	0f b6 00             	movzbl (%eax),%eax
    7cb3:	0f b6 c0             	movzbl %al,%eax
    7cb6:	83 e0 0f             	and    $0xf,%eax
    7cb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7cbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cbf:	0f b6 00             	movzbl (%eax),%eax
    7cc2:	c0 e8 04             	shr    $0x4,%al
    7cc5:	0f b6 c0             	movzbl %al,%eax
    7cc8:	83 e0 0f             	and    $0xf,%eax
    7ccb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7cce:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cd1:	83 c0 01             	add    $0x1,%eax
    7cd4:	0f b6 00             	movzbl (%eax),%eax
    7cd7:	c0 e8 05             	shr    $0x5,%al
    7cda:	0f b6 c0             	movzbl %al,%eax
    7cdd:	83 e0 01             	and    $0x1,%eax
    7ce0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7ce3:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7ce7:	75 06                	jne    7cef <lodepng_zlib_decompressv+0xaf>
    7ce9:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7ced:	76 0a                	jbe    7cf9 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7cef:	b8 19 00 00 00       	mov    $0x19,%eax
    7cf4:	e9 8b 00 00 00       	jmp    7d84 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7cf9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7cfd:	74 07                	je     7d06 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7cff:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7d04:	eb 7e                	jmp    7d84 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7d06:	8b 45 10             	mov    0x10(%ebp),%eax
    7d09:	8d 50 fe             	lea    -0x2(%eax),%edx
    7d0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d0f:	83 c0 02             	add    $0x2,%eax
    7d12:	ff 75 14             	pushl  0x14(%ebp)
    7d15:	52                   	push   %edx
    7d16:	50                   	push   %eax
    7d17:	ff 75 08             	pushl  0x8(%ebp)
    7d1a:	e8 09 e3 ff ff       	call   6028 <inflatev>
    7d1f:	83 c4 10             	add    $0x10,%esp
    7d22:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7d25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d29:	74 05                	je     7d30 <lodepng_zlib_decompressv+0xf0>
    7d2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7d2e:	eb 54                	jmp    7d84 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7d30:	8b 45 14             	mov    0x14(%ebp),%eax
    7d33:	8b 00                	mov    (%eax),%eax
    7d35:	85 c0                	test   %eax,%eax
    7d37:	75 46                	jne    7d7f <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7d39:	8b 45 10             	mov    0x10(%ebp),%eax
    7d3c:	8d 50 fc             	lea    -0x4(%eax),%edx
    7d3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d42:	01 d0                	add    %edx,%eax
    7d44:	83 ec 0c             	sub    $0xc,%esp
    7d47:	50                   	push   %eax
    7d48:	e8 47 b9 ff ff       	call   3694 <lodepng_read32bitInt>
    7d4d:	83 c4 10             	add    $0x10,%esp
    7d50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7d53:	8b 45 08             	mov    0x8(%ebp),%eax
    7d56:	8b 40 04             	mov    0x4(%eax),%eax
    7d59:	89 c2                	mov    %eax,%edx
    7d5b:	8b 45 08             	mov    0x8(%ebp),%eax
    7d5e:	8b 00                	mov    (%eax),%eax
    7d60:	83 ec 08             	sub    $0x8,%esp
    7d63:	52                   	push   %edx
    7d64:	50                   	push   %eax
    7d65:	e8 c1 fe ff ff       	call   7c2b <adler32>
    7d6a:	83 c4 10             	add    $0x10,%esp
    7d6d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7d70:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d73:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7d76:	74 07                	je     7d7f <lodepng_zlib_decompressv+0x13f>
    7d78:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7d7d:	eb 05                	jmp    7d84 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7d7f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7d84:	c9                   	leave  
    7d85:	c3                   	ret    

00007d86 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7d86:	55                   	push   %ebp
    7d87:	89 e5                	mov    %esp,%ebp
    7d89:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d8f:	8b 08                	mov    (%eax),%ecx
    7d91:	8b 45 08             	mov    0x8(%ebp),%eax
    7d94:	8b 10                	mov    (%eax),%edx
    7d96:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7d99:	51                   	push   %ecx
    7d9a:	52                   	push   %edx
    7d9b:	50                   	push   %eax
    7d9c:	e8 36 b8 ff ff       	call   35d7 <ucvector_init>
    7da1:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7da4:	ff 75 18             	pushl  0x18(%ebp)
    7da7:	ff 75 14             	pushl  0x14(%ebp)
    7daa:	ff 75 10             	pushl  0x10(%ebp)
    7dad:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7db0:	50                   	push   %eax
    7db1:	e8 8a fe ff ff       	call   7c40 <lodepng_zlib_decompressv>
    7db6:	83 c4 10             	add    $0x10,%esp
    7db9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7dbc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7dbf:	8b 45 08             	mov    0x8(%ebp),%eax
    7dc2:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7dc4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7dc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dca:	89 10                	mov    %edx,(%eax)
  return error;
    7dcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7dcf:	c9                   	leave  
    7dd0:	c3                   	ret    

00007dd1 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7dd1:	55                   	push   %ebp
    7dd2:	89 e5                	mov    %esp,%ebp
    7dd4:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7dd7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7dda:	8b 40 0c             	mov    0xc(%eax),%eax
    7ddd:	85 c0                	test   %eax,%eax
    7ddf:	74 57                	je     7e38 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7de1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7de4:	8b 40 0c             	mov    0xc(%eax),%eax
    7de7:	83 ec 0c             	sub    $0xc,%esp
    7dea:	ff 75 1c             	pushl  0x1c(%ebp)
    7ded:	ff 75 18             	pushl  0x18(%ebp)
    7df0:	ff 75 14             	pushl  0x14(%ebp)
    7df3:	ff 75 0c             	pushl  0xc(%ebp)
    7df6:	ff 75 08             	pushl  0x8(%ebp)
    7df9:	ff d0                	call   *%eax
    7dfb:	83 c4 20             	add    $0x20,%esp
    7dfe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7e01:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e05:	0f 84 98 00 00 00    	je     7ea3 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7e0b:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7e12:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e15:	8b 40 08             	mov    0x8(%eax),%eax
    7e18:	85 c0                	test   %eax,%eax
    7e1a:	0f 84 83 00 00 00    	je     7ea3 <zlib_decompress+0xd2>
    7e20:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e23:	8b 10                	mov    (%eax),%edx
    7e25:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e28:	8b 40 08             	mov    0x8(%eax),%eax
    7e2b:	39 c2                	cmp    %eax,%edx
    7e2d:	7e 74                	jle    7ea3 <zlib_decompress+0xd2>
    7e2f:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7e36:	eb 6b                	jmp    7ea3 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7e38:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e3b:	8b 08                	mov    (%eax),%ecx
    7e3d:	8b 45 08             	mov    0x8(%ebp),%eax
    7e40:	8b 10                	mov    (%eax),%edx
    7e42:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e45:	83 ec 04             	sub    $0x4,%esp
    7e48:	51                   	push   %ecx
    7e49:	52                   	push   %edx
    7e4a:	50                   	push   %eax
    7e4b:	e8 87 b7 ff ff       	call   35d7 <ucvector_init>
    7e50:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7e53:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7e57:	74 22                	je     7e7b <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7e59:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e5c:	8b 10                	mov    (%eax),%edx
    7e5e:	8b 45 10             	mov    0x10(%ebp),%eax
    7e61:	01 d0                	add    %edx,%eax
    7e63:	83 ec 08             	sub    $0x8,%esp
    7e66:	50                   	push   %eax
    7e67:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e6a:	50                   	push   %eax
    7e6b:	e8 00 b7 ff ff       	call   3570 <ucvector_resize>
    7e70:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7e73:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e76:	8b 00                	mov    (%eax),%eax
    7e78:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7e7b:	ff 75 1c             	pushl  0x1c(%ebp)
    7e7e:	ff 75 18             	pushl  0x18(%ebp)
    7e81:	ff 75 14             	pushl  0x14(%ebp)
    7e84:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e87:	50                   	push   %eax
    7e88:	e8 b3 fd ff ff       	call   7c40 <lodepng_zlib_decompressv>
    7e8d:	83 c4 10             	add    $0x10,%esp
    7e90:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7e93:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7e96:	8b 45 08             	mov    0x8(%ebp),%eax
    7e99:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7e9b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7e9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ea1:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7ea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ea6:	c9                   	leave  
    7ea7:	c3                   	ret    

00007ea8 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7ea8:	55                   	push   %ebp
    7ea9:	89 e5                	mov    %esp,%ebp
    7eab:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7eae:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7eb5:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7ebc:	83 ec 0c             	sub    $0xc,%esp
    7ebf:	ff 75 18             	pushl  0x18(%ebp)
    7ec2:	ff 75 14             	pushl  0x14(%ebp)
    7ec5:	ff 75 10             	pushl  0x10(%ebp)
    7ec8:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7ecb:	50                   	push   %eax
    7ecc:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7ecf:	50                   	push   %eax
    7ed0:	e8 42 fc ff ff       	call   7b17 <deflate>
    7ed5:	83 c4 20             	add    $0x20,%esp
    7ed8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7edb:	8b 45 08             	mov    0x8(%ebp),%eax
    7ede:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ee7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7eed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7ef1:	75 33                	jne    7f26 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7ef3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7ef6:	8d 50 06             	lea    0x6(%eax),%edx
    7ef9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7efc:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7efe:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f01:	8b 00                	mov    (%eax),%eax
    7f03:	83 ec 0c             	sub    $0xc,%esp
    7f06:	50                   	push   %eax
    7f07:	e8 0a b4 ff ff       	call   3316 <lodepng_malloc>
    7f0c:	83 c4 10             	add    $0x10,%esp
    7f0f:	89 c2                	mov    %eax,%edx
    7f11:	8b 45 08             	mov    0x8(%ebp),%eax
    7f14:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    7f16:	8b 45 08             	mov    0x8(%ebp),%eax
    7f19:	8b 00                	mov    (%eax),%eax
    7f1b:	85 c0                	test   %eax,%eax
    7f1d:	75 07                	jne    7f26 <lodepng_zlib_compress+0x7e>
    7f1f:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    7f26:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f2a:	0f 85 e2 00 00 00    	jne    8012 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    7f30:	8b 45 14             	mov    0x14(%ebp),%eax
    7f33:	83 ec 08             	sub    $0x8,%esp
    7f36:	50                   	push   %eax
    7f37:	ff 75 10             	pushl  0x10(%ebp)
    7f3a:	e8 ec fc ff ff       	call   7c2b <adler32>
    7f3f:	83 c4 10             	add    $0x10,%esp
    7f42:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    7f45:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    7f4c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    7f53:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    7f5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f5d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f67:	01 d0                	add    %edx,%eax
    7f69:	8d 14 00             	lea    (%eax,%eax,1),%edx
    7f6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7f6f:	01 d0                	add    %edx,%eax
    7f71:	c1 e0 05             	shl    $0x5,%eax
    7f74:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    7f77:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7f7a:	ba 85 10 42 08       	mov    $0x8421085,%edx
    7f7f:	89 c8                	mov    %ecx,%eax
    7f81:	f7 e2                	mul    %edx
    7f83:	89 c8                	mov    %ecx,%eax
    7f85:	29 d0                	sub    %edx,%eax
    7f87:	d1 e8                	shr    %eax
    7f89:	01 d0                	add    %edx,%eax
    7f8b:	c1 e8 04             	shr    $0x4,%eax
    7f8e:	89 c2                	mov    %eax,%edx
    7f90:	c1 e2 05             	shl    $0x5,%edx
    7f93:	29 c2                	sub    %eax,%edx
    7f95:	89 c8                	mov    %ecx,%eax
    7f97:	29 d0                	sub    %edx,%eax
    7f99:	ba 1f 00 00 00       	mov    $0x1f,%edx
    7f9e:	29 c2                	sub    %eax,%edx
    7fa0:	89 d0                	mov    %edx,%eax
    7fa2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    7fa5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7fa8:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    7fab:	8b 45 08             	mov    0x8(%ebp),%eax
    7fae:	8b 00                	mov    (%eax),%eax
    7fb0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fb3:	c1 ea 08             	shr    $0x8,%edx
    7fb6:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    7fb8:	8b 45 08             	mov    0x8(%ebp),%eax
    7fbb:	8b 00                	mov    (%eax),%eax
    7fbd:	83 c0 01             	add    $0x1,%eax
    7fc0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fc3:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    7fc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7fcc:	eb 1e                	jmp    7fec <lodepng_zlib_compress+0x144>
    7fce:	8b 45 08             	mov    0x8(%ebp),%eax
    7fd1:	8b 00                	mov    (%eax),%eax
    7fd3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7fd6:	83 c2 02             	add    $0x2,%edx
    7fd9:	01 c2                	add    %eax,%edx
    7fdb:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    7fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7fe1:	01 c8                	add    %ecx,%eax
    7fe3:	0f b6 00             	movzbl (%eax),%eax
    7fe6:	88 02                	mov    %al,(%edx)
    7fe8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7fec:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7fef:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    7ff2:	75 da                	jne    7fce <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    7ff4:	8b 45 08             	mov    0x8(%ebp),%eax
    7ff7:	8b 10                	mov    (%eax),%edx
    7ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ffc:	8b 00                	mov    (%eax),%eax
    7ffe:	83 e8 04             	sub    $0x4,%eax
    8001:	01 d0                	add    %edx,%eax
    8003:	83 ec 08             	sub    $0x8,%esp
    8006:	ff 75 ec             	pushl  -0x14(%ebp)
    8009:	50                   	push   %eax
    800a:	e8 c8 b6 ff ff       	call   36d7 <lodepng_set32bitInt>
    800f:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    8012:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8015:	83 ec 0c             	sub    $0xc,%esp
    8018:	50                   	push   %eax
    8019:	e8 19 b3 ff ff       	call   3337 <lodepng_free>
    801e:	83 c4 10             	add    $0x10,%esp
  return error;
    8021:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    8024:	c9                   	leave  
    8025:	c3                   	ret    

00008026 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    8026:	55                   	push   %ebp
    8027:	89 e5                	mov    %esp,%ebp
    8029:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    802c:	8b 45 18             	mov    0x18(%ebp),%eax
    802f:	8b 40 18             	mov    0x18(%eax),%eax
    8032:	85 c0                	test   %eax,%eax
    8034:	74 34                	je     806a <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8036:	8b 45 18             	mov    0x18(%ebp),%eax
    8039:	8b 40 18             	mov    0x18(%eax),%eax
    803c:	83 ec 0c             	sub    $0xc,%esp
    803f:	ff 75 18             	pushl  0x18(%ebp)
    8042:	ff 75 14             	pushl  0x14(%ebp)
    8045:	ff 75 10             	pushl  0x10(%ebp)
    8048:	ff 75 0c             	pushl  0xc(%ebp)
    804b:	ff 75 08             	pushl  0x8(%ebp)
    804e:	ff d0                	call   *%eax
    8050:	83 c4 20             	add    $0x20,%esp
    8053:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8056:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    805a:	74 07                	je     8063 <zlib_compress+0x3d>
    805c:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8061:	eb 21                	jmp    8084 <zlib_compress+0x5e>
    8063:	b8 00 00 00 00       	mov    $0x0,%eax
    8068:	eb 1a                	jmp    8084 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    806a:	83 ec 0c             	sub    $0xc,%esp
    806d:	ff 75 18             	pushl  0x18(%ebp)
    8070:	ff 75 14             	pushl  0x14(%ebp)
    8073:	ff 75 10             	pushl  0x10(%ebp)
    8076:	ff 75 0c             	pushl  0xc(%ebp)
    8079:	ff 75 08             	pushl  0x8(%ebp)
    807c:	e8 27 fe ff ff       	call   7ea8 <lodepng_zlib_compress>
    8081:	83 c4 20             	add    $0x20,%esp
  }
}
    8084:	c9                   	leave  
    8085:	c3                   	ret    

00008086 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8086:	55                   	push   %ebp
    8087:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8089:	8b 45 08             	mov    0x8(%ebp),%eax
    808c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    8092:	8b 45 08             	mov    0x8(%ebp),%eax
    8095:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    809c:	8b 45 08             	mov    0x8(%ebp),%eax
    809f:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    80a6:	8b 45 08             	mov    0x8(%ebp),%eax
    80a9:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    80b0:	8b 45 08             	mov    0x8(%ebp),%eax
    80b3:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    80ba:	8b 45 08             	mov    0x8(%ebp),%eax
    80bd:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    80c4:	8b 45 08             	mov    0x8(%ebp),%eax
    80c7:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    80ce:	8b 45 08             	mov    0x8(%ebp),%eax
    80d1:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    80d8:	8b 45 08             	mov    0x8(%ebp),%eax
    80db:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    80e2:	90                   	nop
    80e3:	5d                   	pop    %ebp
    80e4:	c3                   	ret    

000080e5 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    80e5:	55                   	push   %ebp
    80e6:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    80e8:	8b 45 08             	mov    0x8(%ebp),%eax
    80eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    80f1:	8b 45 08             	mov    0x8(%ebp),%eax
    80f4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    80fb:	8b 45 08             	mov    0x8(%ebp),%eax
    80fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    8105:	8b 45 08             	mov    0x8(%ebp),%eax
    8108:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    810f:	8b 45 08             	mov    0x8(%ebp),%eax
    8112:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8119:	8b 45 08             	mov    0x8(%ebp),%eax
    811c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    8123:	90                   	nop
    8124:	5d                   	pop    %ebp
    8125:	c3                   	ret    

00008126 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    8126:	55                   	push   %ebp
    8127:	89 e5                	mov    %esp,%ebp
    8129:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    812c:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    8133:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    813a:	eb 2a                	jmp    8166 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    813c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    813f:	8b 45 08             	mov    0x8(%ebp),%eax
    8142:	01 d0                	add    %edx,%eax
    8144:	0f b6 00             	movzbl (%eax),%eax
    8147:	0f b6 c0             	movzbl %al,%eax
    814a:	33 45 fc             	xor    -0x4(%ebp),%eax
    814d:	0f b6 c0             	movzbl %al,%eax
    8150:	8b 04 85 00 e1 01 00 	mov    0x1e100(,%eax,4),%eax
    8157:	8b 55 fc             	mov    -0x4(%ebp),%edx
    815a:	c1 ea 08             	shr    $0x8,%edx
    815d:	31 d0                	xor    %edx,%eax
    815f:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8162:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8166:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8169:	3b 45 0c             	cmp    0xc(%ebp),%eax
    816c:	7c ce                	jl     813c <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    816e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8171:	f7 d0                	not    %eax
}
    8173:	c9                   	leave  
    8174:	c3                   	ret    

00008175 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8175:	55                   	push   %ebp
    8176:	89 e5                	mov    %esp,%ebp
    8178:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    817b:	8b 45 08             	mov    0x8(%ebp),%eax
    817e:	8b 00                	mov    (%eax),%eax
    8180:	c1 f8 03             	sar    $0x3,%eax
    8183:	89 c2                	mov    %eax,%edx
    8185:	8b 45 0c             	mov    0xc(%ebp),%eax
    8188:	01 d0                	add    %edx,%eax
    818a:	0f b6 00             	movzbl (%eax),%eax
    818d:	0f b6 d0             	movzbl %al,%edx
    8190:	8b 45 08             	mov    0x8(%ebp),%eax
    8193:	8b 00                	mov    (%eax),%eax
    8195:	f7 d0                	not    %eax
    8197:	83 e0 07             	and    $0x7,%eax
    819a:	89 c1                	mov    %eax,%ecx
    819c:	d3 fa                	sar    %cl,%edx
    819e:	89 d0                	mov    %edx,%eax
    81a0:	83 e0 01             	and    $0x1,%eax
    81a3:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    81a6:	8b 45 08             	mov    0x8(%ebp),%eax
    81a9:	8b 00                	mov    (%eax),%eax
    81ab:	8d 50 01             	lea    0x1(%eax),%edx
    81ae:	8b 45 08             	mov    0x8(%ebp),%eax
    81b1:	89 10                	mov    %edx,(%eax)
  return result;
    81b3:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    81b7:	c9                   	leave  
    81b8:	c3                   	ret    

000081b9 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    81b9:	55                   	push   %ebp
    81ba:	89 e5                	mov    %esp,%ebp
    81bc:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    81bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81c6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    81cd:	eb 1b                	jmp    81ea <readBitsFromReversedStream+0x31>
    result <<= 1u;
    81cf:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    81d2:	ff 75 0c             	pushl  0xc(%ebp)
    81d5:	ff 75 08             	pushl  0x8(%ebp)
    81d8:	e8 98 ff ff ff       	call   8175 <readBitFromReversedStream>
    81dd:	83 c4 08             	add    $0x8,%esp
    81e0:	0f b6 c0             	movzbl %al,%eax
    81e3:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81e6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    81ea:	8b 45 f8             	mov    -0x8(%ebp),%eax
    81ed:	3b 45 10             	cmp    0x10(%ebp),%eax
    81f0:	7c dd                	jl     81cf <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    81f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    81f5:	c9                   	leave  
    81f6:	c3                   	ret    

000081f7 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    81f7:	55                   	push   %ebp
    81f8:	89 e5                	mov    %esp,%ebp
    81fa:	56                   	push   %esi
    81fb:	53                   	push   %ebx
    81fc:	83 ec 04             	sub    $0x4,%esp
    81ff:	8b 45 10             	mov    0x10(%ebp),%eax
    8202:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    8205:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8209:	75 3e                	jne    8249 <setBitOfReversedStream+0x52>
    820b:	8b 45 08             	mov    0x8(%ebp),%eax
    820e:	8b 00                	mov    (%eax),%eax
    8210:	c1 f8 03             	sar    $0x3,%eax
    8213:	89 c2                	mov    %eax,%edx
    8215:	8b 45 0c             	mov    0xc(%ebp),%eax
    8218:	01 c2                	add    %eax,%edx
    821a:	8b 45 08             	mov    0x8(%ebp),%eax
    821d:	8b 00                	mov    (%eax),%eax
    821f:	c1 f8 03             	sar    $0x3,%eax
    8222:	89 c1                	mov    %eax,%ecx
    8224:	8b 45 0c             	mov    0xc(%ebp),%eax
    8227:	01 c8                	add    %ecx,%eax
    8229:	0f b6 18             	movzbl (%eax),%ebx
    822c:	8b 45 08             	mov    0x8(%ebp),%eax
    822f:	8b 00                	mov    (%eax),%eax
    8231:	f7 d0                	not    %eax
    8233:	83 e0 07             	and    $0x7,%eax
    8236:	be 01 00 00 00       	mov    $0x1,%esi
    823b:	89 c1                	mov    %eax,%ecx
    823d:	d3 e6                	shl    %cl,%esi
    823f:	89 f0                	mov    %esi,%eax
    8241:	f7 d0                	not    %eax
    8243:	21 d8                	and    %ebx,%eax
    8245:	88 02                	mov    %al,(%edx)
    8247:	eb 3a                	jmp    8283 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8249:	8b 45 08             	mov    0x8(%ebp),%eax
    824c:	8b 00                	mov    (%eax),%eax
    824e:	c1 f8 03             	sar    $0x3,%eax
    8251:	89 c2                	mov    %eax,%edx
    8253:	8b 45 0c             	mov    0xc(%ebp),%eax
    8256:	01 c2                	add    %eax,%edx
    8258:	8b 45 08             	mov    0x8(%ebp),%eax
    825b:	8b 00                	mov    (%eax),%eax
    825d:	c1 f8 03             	sar    $0x3,%eax
    8260:	89 c1                	mov    %eax,%ecx
    8262:	8b 45 0c             	mov    0xc(%ebp),%eax
    8265:	01 c8                	add    %ecx,%eax
    8267:	0f b6 18             	movzbl (%eax),%ebx
    826a:	8b 45 08             	mov    0x8(%ebp),%eax
    826d:	8b 00                	mov    (%eax),%eax
    826f:	f7 d0                	not    %eax
    8271:	83 e0 07             	and    $0x7,%eax
    8274:	be 01 00 00 00       	mov    $0x1,%esi
    8279:	89 c1                	mov    %eax,%ecx
    827b:	d3 e6                	shl    %cl,%esi
    827d:	89 f0                	mov    %esi,%eax
    827f:	09 d8                	or     %ebx,%eax
    8281:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8283:	8b 45 08             	mov    0x8(%ebp),%eax
    8286:	8b 00                	mov    (%eax),%eax
    8288:	8d 50 01             	lea    0x1(%eax),%edx
    828b:	8b 45 08             	mov    0x8(%ebp),%eax
    828e:	89 10                	mov    %edx,(%eax)
}
    8290:	90                   	nop
    8291:	83 c4 04             	add    $0x4,%esp
    8294:	5b                   	pop    %ebx
    8295:	5e                   	pop    %esi
    8296:	5d                   	pop    %ebp
    8297:	c3                   	ret    

00008298 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8298:	55                   	push   %ebp
    8299:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    829b:	ff 75 08             	pushl  0x8(%ebp)
    829e:	e8 f1 b3 ff ff       	call   3694 <lodepng_read32bitInt>
    82a3:	83 c4 04             	add    $0x4,%esp
}
    82a6:	c9                   	leave  
    82a7:	c3                   	ret    

000082a8 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    82a8:	55                   	push   %ebp
    82a9:	89 e5                	mov    %esp,%ebp
    82ab:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    82ae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    82b5:	eb 1c                	jmp    82d3 <lodepng_chunk_type+0x2b>
    82b7:	8b 55 08             	mov    0x8(%ebp),%edx
    82ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    82bd:	01 d0                	add    %edx,%eax
    82bf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    82c2:	8d 4a 04             	lea    0x4(%edx),%ecx
    82c5:	8b 55 0c             	mov    0xc(%ebp),%edx
    82c8:	01 ca                	add    %ecx,%edx
    82ca:	0f b6 12             	movzbl (%edx),%edx
    82cd:	88 10                	mov    %dl,(%eax)
    82cf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    82d3:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    82d7:	75 de                	jne    82b7 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    82d9:	8b 45 08             	mov    0x8(%ebp),%eax
    82dc:	83 c0 04             	add    $0x4,%eax
    82df:	c6 00 00             	movb   $0x0,(%eax)
}
    82e2:	90                   	nop
    82e3:	c9                   	leave  
    82e4:	c3                   	ret    

000082e5 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    82e5:	55                   	push   %ebp
    82e6:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    82e8:	ff 75 0c             	pushl  0xc(%ebp)
    82eb:	e8 c2 b0 ff ff       	call   33b2 <lodepng_strlen>
    82f0:	83 c4 04             	add    $0x4,%esp
    82f3:	83 f8 04             	cmp    $0x4,%eax
    82f6:	74 07                	je     82ff <lodepng_chunk_type_equals+0x1a>
    82f8:	b8 00 00 00 00       	mov    $0x0,%eax
    82fd:	eb 79                	jmp    8378 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    82ff:	8b 45 08             	mov    0x8(%ebp),%eax
    8302:	83 c0 04             	add    $0x4,%eax
    8305:	0f b6 00             	movzbl (%eax),%eax
    8308:	0f b6 d0             	movzbl %al,%edx
    830b:	8b 45 0c             	mov    0xc(%ebp),%eax
    830e:	0f b6 00             	movzbl (%eax),%eax
    8311:	0f be c0             	movsbl %al,%eax
    8314:	39 c2                	cmp    %eax,%edx
    8316:	75 5b                	jne    8373 <lodepng_chunk_type_equals+0x8e>
    8318:	8b 45 08             	mov    0x8(%ebp),%eax
    831b:	83 c0 05             	add    $0x5,%eax
    831e:	0f b6 00             	movzbl (%eax),%eax
    8321:	0f b6 d0             	movzbl %al,%edx
    8324:	8b 45 0c             	mov    0xc(%ebp),%eax
    8327:	83 c0 01             	add    $0x1,%eax
    832a:	0f b6 00             	movzbl (%eax),%eax
    832d:	0f be c0             	movsbl %al,%eax
    8330:	39 c2                	cmp    %eax,%edx
    8332:	75 3f                	jne    8373 <lodepng_chunk_type_equals+0x8e>
    8334:	8b 45 08             	mov    0x8(%ebp),%eax
    8337:	83 c0 06             	add    $0x6,%eax
    833a:	0f b6 00             	movzbl (%eax),%eax
    833d:	0f b6 d0             	movzbl %al,%edx
    8340:	8b 45 0c             	mov    0xc(%ebp),%eax
    8343:	83 c0 02             	add    $0x2,%eax
    8346:	0f b6 00             	movzbl (%eax),%eax
    8349:	0f be c0             	movsbl %al,%eax
    834c:	39 c2                	cmp    %eax,%edx
    834e:	75 23                	jne    8373 <lodepng_chunk_type_equals+0x8e>
    8350:	8b 45 08             	mov    0x8(%ebp),%eax
    8353:	83 c0 07             	add    $0x7,%eax
    8356:	0f b6 00             	movzbl (%eax),%eax
    8359:	0f b6 d0             	movzbl %al,%edx
    835c:	8b 45 0c             	mov    0xc(%ebp),%eax
    835f:	83 c0 03             	add    $0x3,%eax
    8362:	0f b6 00             	movzbl (%eax),%eax
    8365:	0f be c0             	movsbl %al,%eax
    8368:	39 c2                	cmp    %eax,%edx
    836a:	75 07                	jne    8373 <lodepng_chunk_type_equals+0x8e>
    836c:	b8 01 00 00 00       	mov    $0x1,%eax
    8371:	eb 05                	jmp    8378 <lodepng_chunk_type_equals+0x93>
    8373:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8378:	c9                   	leave  
    8379:	c3                   	ret    

0000837a <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    837a:	55                   	push   %ebp
    837b:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    837d:	8b 45 08             	mov    0x8(%ebp),%eax
    8380:	83 c0 04             	add    $0x4,%eax
    8383:	0f b6 00             	movzbl (%eax),%eax
    8386:	0f b6 c0             	movzbl %al,%eax
    8389:	83 e0 20             	and    $0x20,%eax
    838c:	85 c0                	test   %eax,%eax
    838e:	0f 95 c0             	setne  %al
}
    8391:	5d                   	pop    %ebp
    8392:	c3                   	ret    

00008393 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8393:	55                   	push   %ebp
    8394:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8396:	8b 45 08             	mov    0x8(%ebp),%eax
    8399:	83 c0 06             	add    $0x6,%eax
    839c:	0f b6 00             	movzbl (%eax),%eax
    839f:	0f b6 c0             	movzbl %al,%eax
    83a2:	83 e0 20             	and    $0x20,%eax
    83a5:	85 c0                	test   %eax,%eax
    83a7:	0f 95 c0             	setne  %al
}
    83aa:	5d                   	pop    %ebp
    83ab:	c3                   	ret    

000083ac <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    83ac:	55                   	push   %ebp
    83ad:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    83af:	8b 45 08             	mov    0x8(%ebp),%eax
    83b2:	83 c0 07             	add    $0x7,%eax
    83b5:	0f b6 00             	movzbl (%eax),%eax
    83b8:	0f b6 c0             	movzbl %al,%eax
    83bb:	83 e0 20             	and    $0x20,%eax
    83be:	85 c0                	test   %eax,%eax
    83c0:	0f 95 c0             	setne  %al
}
    83c3:	5d                   	pop    %ebp
    83c4:	c3                   	ret    

000083c5 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    83c5:	55                   	push   %ebp
    83c6:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83c8:	8b 45 08             	mov    0x8(%ebp),%eax
    83cb:	83 c0 08             	add    $0x8,%eax
}
    83ce:	5d                   	pop    %ebp
    83cf:	c3                   	ret    

000083d0 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    83d0:	55                   	push   %ebp
    83d1:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83d3:	8b 45 08             	mov    0x8(%ebp),%eax
    83d6:	83 c0 08             	add    $0x8,%eax
}
    83d9:	5d                   	pop    %ebp
    83da:	c3                   	ret    

000083db <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    83db:	55                   	push   %ebp
    83dc:	89 e5                	mov    %esp,%ebp
    83de:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    83e1:	ff 75 08             	pushl  0x8(%ebp)
    83e4:	e8 af fe ff ff       	call   8298 <lodepng_chunk_length>
    83e9:	83 c4 04             	add    $0x4,%esp
    83ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    83ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
    83f2:	8d 50 08             	lea    0x8(%eax),%edx
    83f5:	8b 45 08             	mov    0x8(%ebp),%eax
    83f8:	01 d0                	add    %edx,%eax
    83fa:	50                   	push   %eax
    83fb:	e8 94 b2 ff ff       	call   3694 <lodepng_read32bitInt>
    8400:	83 c4 04             	add    $0x4,%esp
    8403:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    8406:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8409:	83 c0 04             	add    $0x4,%eax
    840c:	89 c2                	mov    %eax,%edx
    840e:	8b 45 08             	mov    0x8(%ebp),%eax
    8411:	83 c0 04             	add    $0x4,%eax
    8414:	52                   	push   %edx
    8415:	50                   	push   %eax
    8416:	e8 0b fd ff ff       	call   8126 <lodepng_crc32>
    841b:	83 c4 08             	add    $0x8,%esp
    841e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    8421:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8424:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8427:	74 07                	je     8430 <lodepng_chunk_check_crc+0x55>
    8429:	b8 01 00 00 00       	mov    $0x1,%eax
    842e:	eb 05                	jmp    8435 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    8430:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8435:	c9                   	leave  
    8436:	c3                   	ret    

00008437 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8437:	55                   	push   %ebp
    8438:	89 e5                	mov    %esp,%ebp
    843a:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    843d:	ff 75 08             	pushl  0x8(%ebp)
    8440:	e8 53 fe ff ff       	call   8298 <lodepng_chunk_length>
    8445:	83 c4 04             	add    $0x4,%esp
    8448:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    844b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    844e:	83 c0 04             	add    $0x4,%eax
    8451:	89 c2                	mov    %eax,%edx
    8453:	8b 45 08             	mov    0x8(%ebp),%eax
    8456:	83 c0 04             	add    $0x4,%eax
    8459:	52                   	push   %edx
    845a:	50                   	push   %eax
    845b:	e8 c6 fc ff ff       	call   8126 <lodepng_crc32>
    8460:	83 c4 08             	add    $0x8,%esp
    8463:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8466:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8469:	8d 50 08             	lea    0x8(%eax),%edx
    846c:	8b 45 08             	mov    0x8(%ebp),%eax
    846f:	01 d0                	add    %edx,%eax
    8471:	ff 75 f8             	pushl  -0x8(%ebp)
    8474:	50                   	push   %eax
    8475:	e8 5d b2 ff ff       	call   36d7 <lodepng_set32bitInt>
    847a:	83 c4 08             	add    $0x8,%esp
}
    847d:	90                   	nop
    847e:	c9                   	leave  
    847f:	c3                   	ret    

00008480 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    8480:	55                   	push   %ebp
    8481:	89 e5                	mov    %esp,%ebp
    8483:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8486:	8b 45 08             	mov    0x8(%ebp),%eax
    8489:	3b 45 0c             	cmp    0xc(%ebp),%eax
    848c:	73 0f                	jae    849d <lodepng_chunk_next+0x1d>
    848e:	8b 55 0c             	mov    0xc(%ebp),%edx
    8491:	8b 45 08             	mov    0x8(%ebp),%eax
    8494:	29 c2                	sub    %eax,%edx
    8496:	89 d0                	mov    %edx,%eax
    8498:	83 f8 0b             	cmp    $0xb,%eax
    849b:	7f 08                	jg     84a5 <lodepng_chunk_next+0x25>
    849d:	8b 45 0c             	mov    0xc(%ebp),%eax
    84a0:	e9 af 00 00 00       	jmp    8554 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    84a5:	8b 45 08             	mov    0x8(%ebp),%eax
    84a8:	0f b6 00             	movzbl (%eax),%eax
    84ab:	3c 89                	cmp    $0x89,%al
    84ad:	75 63                	jne    8512 <lodepng_chunk_next+0x92>
    84af:	8b 45 08             	mov    0x8(%ebp),%eax
    84b2:	83 c0 01             	add    $0x1,%eax
    84b5:	0f b6 00             	movzbl (%eax),%eax
    84b8:	3c 50                	cmp    $0x50,%al
    84ba:	75 56                	jne    8512 <lodepng_chunk_next+0x92>
    84bc:	8b 45 08             	mov    0x8(%ebp),%eax
    84bf:	83 c0 02             	add    $0x2,%eax
    84c2:	0f b6 00             	movzbl (%eax),%eax
    84c5:	3c 4e                	cmp    $0x4e,%al
    84c7:	75 49                	jne    8512 <lodepng_chunk_next+0x92>
    84c9:	8b 45 08             	mov    0x8(%ebp),%eax
    84cc:	83 c0 03             	add    $0x3,%eax
    84cf:	0f b6 00             	movzbl (%eax),%eax
    84d2:	3c 47                	cmp    $0x47,%al
    84d4:	75 3c                	jne    8512 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    84d6:	8b 45 08             	mov    0x8(%ebp),%eax
    84d9:	83 c0 04             	add    $0x4,%eax
    84dc:	0f b6 00             	movzbl (%eax),%eax
    84df:	3c 0d                	cmp    $0xd,%al
    84e1:	75 2f                	jne    8512 <lodepng_chunk_next+0x92>
    84e3:	8b 45 08             	mov    0x8(%ebp),%eax
    84e6:	83 c0 05             	add    $0x5,%eax
    84e9:	0f b6 00             	movzbl (%eax),%eax
    84ec:	3c 0a                	cmp    $0xa,%al
    84ee:	75 22                	jne    8512 <lodepng_chunk_next+0x92>
    84f0:	8b 45 08             	mov    0x8(%ebp),%eax
    84f3:	83 c0 06             	add    $0x6,%eax
    84f6:	0f b6 00             	movzbl (%eax),%eax
    84f9:	3c 1a                	cmp    $0x1a,%al
    84fb:	75 15                	jne    8512 <lodepng_chunk_next+0x92>
    84fd:	8b 45 08             	mov    0x8(%ebp),%eax
    8500:	83 c0 07             	add    $0x7,%eax
    8503:	0f b6 00             	movzbl (%eax),%eax
    8506:	3c 0a                	cmp    $0xa,%al
    8508:	75 08                	jne    8512 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    850a:	8b 45 08             	mov    0x8(%ebp),%eax
    850d:	83 c0 08             	add    $0x8,%eax
    8510:	eb 42                	jmp    8554 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8512:	ff 75 08             	pushl  0x8(%ebp)
    8515:	e8 7e fd ff ff       	call   8298 <lodepng_chunk_length>
    851a:	83 c4 04             	add    $0x4,%esp
    851d:	89 c2                	mov    %eax,%edx
    851f:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8522:	50                   	push   %eax
    8523:	6a 0c                	push   $0xc
    8525:	52                   	push   %edx
    8526:	e8 af ae ff ff       	call   33da <lodepng_addofl>
    852b:	83 c4 0c             	add    $0xc,%esp
    852e:	85 c0                	test   %eax,%eax
    8530:	74 05                	je     8537 <lodepng_chunk_next+0xb7>
    8532:	8b 45 0c             	mov    0xc(%ebp),%eax
    8535:	eb 1d                	jmp    8554 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8537:	8b 45 f8             	mov    -0x8(%ebp),%eax
    853a:	89 c2                	mov    %eax,%edx
    853c:	8b 45 08             	mov    0x8(%ebp),%eax
    853f:	01 d0                	add    %edx,%eax
    8541:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8544:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8547:	3b 45 08             	cmp    0x8(%ebp),%eax
    854a:	73 05                	jae    8551 <lodepng_chunk_next+0xd1>
    854c:	8b 45 0c             	mov    0xc(%ebp),%eax
    854f:	eb 03                	jmp    8554 <lodepng_chunk_next+0xd4>
    return result;
    8551:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8554:	c9                   	leave  
    8555:	c3                   	ret    

00008556 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8556:	55                   	push   %ebp
    8557:	89 e5                	mov    %esp,%ebp
    8559:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    855c:	8b 45 08             	mov    0x8(%ebp),%eax
    855f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8562:	73 0f                	jae    8573 <lodepng_chunk_next_const+0x1d>
    8564:	8b 55 0c             	mov    0xc(%ebp),%edx
    8567:	8b 45 08             	mov    0x8(%ebp),%eax
    856a:	29 c2                	sub    %eax,%edx
    856c:	89 d0                	mov    %edx,%eax
    856e:	83 f8 0b             	cmp    $0xb,%eax
    8571:	7f 08                	jg     857b <lodepng_chunk_next_const+0x25>
    8573:	8b 45 0c             	mov    0xc(%ebp),%eax
    8576:	e9 af 00 00 00       	jmp    862a <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    857b:	8b 45 08             	mov    0x8(%ebp),%eax
    857e:	0f b6 00             	movzbl (%eax),%eax
    8581:	3c 89                	cmp    $0x89,%al
    8583:	75 63                	jne    85e8 <lodepng_chunk_next_const+0x92>
    8585:	8b 45 08             	mov    0x8(%ebp),%eax
    8588:	83 c0 01             	add    $0x1,%eax
    858b:	0f b6 00             	movzbl (%eax),%eax
    858e:	3c 50                	cmp    $0x50,%al
    8590:	75 56                	jne    85e8 <lodepng_chunk_next_const+0x92>
    8592:	8b 45 08             	mov    0x8(%ebp),%eax
    8595:	83 c0 02             	add    $0x2,%eax
    8598:	0f b6 00             	movzbl (%eax),%eax
    859b:	3c 4e                	cmp    $0x4e,%al
    859d:	75 49                	jne    85e8 <lodepng_chunk_next_const+0x92>
    859f:	8b 45 08             	mov    0x8(%ebp),%eax
    85a2:	83 c0 03             	add    $0x3,%eax
    85a5:	0f b6 00             	movzbl (%eax),%eax
    85a8:	3c 47                	cmp    $0x47,%al
    85aa:	75 3c                	jne    85e8 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    85ac:	8b 45 08             	mov    0x8(%ebp),%eax
    85af:	83 c0 04             	add    $0x4,%eax
    85b2:	0f b6 00             	movzbl (%eax),%eax
    85b5:	3c 0d                	cmp    $0xd,%al
    85b7:	75 2f                	jne    85e8 <lodepng_chunk_next_const+0x92>
    85b9:	8b 45 08             	mov    0x8(%ebp),%eax
    85bc:	83 c0 05             	add    $0x5,%eax
    85bf:	0f b6 00             	movzbl (%eax),%eax
    85c2:	3c 0a                	cmp    $0xa,%al
    85c4:	75 22                	jne    85e8 <lodepng_chunk_next_const+0x92>
    85c6:	8b 45 08             	mov    0x8(%ebp),%eax
    85c9:	83 c0 06             	add    $0x6,%eax
    85cc:	0f b6 00             	movzbl (%eax),%eax
    85cf:	3c 1a                	cmp    $0x1a,%al
    85d1:	75 15                	jne    85e8 <lodepng_chunk_next_const+0x92>
    85d3:	8b 45 08             	mov    0x8(%ebp),%eax
    85d6:	83 c0 07             	add    $0x7,%eax
    85d9:	0f b6 00             	movzbl (%eax),%eax
    85dc:	3c 0a                	cmp    $0xa,%al
    85de:	75 08                	jne    85e8 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    85e0:	8b 45 08             	mov    0x8(%ebp),%eax
    85e3:	83 c0 08             	add    $0x8,%eax
    85e6:	eb 42                	jmp    862a <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    85e8:	ff 75 08             	pushl  0x8(%ebp)
    85eb:	e8 a8 fc ff ff       	call   8298 <lodepng_chunk_length>
    85f0:	83 c4 04             	add    $0x4,%esp
    85f3:	89 c2                	mov    %eax,%edx
    85f5:	8d 45 f8             	lea    -0x8(%ebp),%eax
    85f8:	50                   	push   %eax
    85f9:	6a 0c                	push   $0xc
    85fb:	52                   	push   %edx
    85fc:	e8 d9 ad ff ff       	call   33da <lodepng_addofl>
    8601:	83 c4 0c             	add    $0xc,%esp
    8604:	85 c0                	test   %eax,%eax
    8606:	74 05                	je     860d <lodepng_chunk_next_const+0xb7>
    8608:	8b 45 0c             	mov    0xc(%ebp),%eax
    860b:	eb 1d                	jmp    862a <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    860d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8610:	89 c2                	mov    %eax,%edx
    8612:	8b 45 08             	mov    0x8(%ebp),%eax
    8615:	01 d0                	add    %edx,%eax
    8617:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    861a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    861d:	3b 45 08             	cmp    0x8(%ebp),%eax
    8620:	73 05                	jae    8627 <lodepng_chunk_next_const+0xd1>
    8622:	8b 45 0c             	mov    0xc(%ebp),%eax
    8625:	eb 03                	jmp    862a <lodepng_chunk_next_const+0xd4>
    return result;
    8627:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    862a:	c9                   	leave  
    862b:	c3                   	ret    

0000862c <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    862c:	55                   	push   %ebp
    862d:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    862f:	8b 45 08             	mov    0x8(%ebp),%eax
    8632:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8635:	73 0f                	jae    8646 <lodepng_chunk_find+0x1a>
    8637:	8b 55 0c             	mov    0xc(%ebp),%edx
    863a:	8b 45 08             	mov    0x8(%ebp),%eax
    863d:	29 c2                	sub    %eax,%edx
    863f:	89 d0                	mov    %edx,%eax
    8641:	83 f8 0b             	cmp    $0xb,%eax
    8644:	7f 07                	jg     864d <lodepng_chunk_find+0x21>
    8646:	b8 00 00 00 00       	mov    $0x0,%eax
    864b:	eb 2a                	jmp    8677 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    864d:	ff 75 10             	pushl  0x10(%ebp)
    8650:	ff 75 08             	pushl  0x8(%ebp)
    8653:	e8 8d fc ff ff       	call   82e5 <lodepng_chunk_type_equals>
    8658:	83 c4 08             	add    $0x8,%esp
    865b:	84 c0                	test   %al,%al
    865d:	74 05                	je     8664 <lodepng_chunk_find+0x38>
    865f:	8b 45 08             	mov    0x8(%ebp),%eax
    8662:	eb 13                	jmp    8677 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8664:	ff 75 0c             	pushl  0xc(%ebp)
    8667:	ff 75 08             	pushl  0x8(%ebp)
    866a:	e8 11 fe ff ff       	call   8480 <lodepng_chunk_next>
    866f:	83 c4 08             	add    $0x8,%esp
    8672:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8675:	eb b8                	jmp    862f <lodepng_chunk_find+0x3>
}
    8677:	c9                   	leave  
    8678:	c3                   	ret    

00008679 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8679:	55                   	push   %ebp
    867a:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    867c:	8b 45 08             	mov    0x8(%ebp),%eax
    867f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8682:	73 0f                	jae    8693 <lodepng_chunk_find_const+0x1a>
    8684:	8b 55 0c             	mov    0xc(%ebp),%edx
    8687:	8b 45 08             	mov    0x8(%ebp),%eax
    868a:	29 c2                	sub    %eax,%edx
    868c:	89 d0                	mov    %edx,%eax
    868e:	83 f8 0b             	cmp    $0xb,%eax
    8691:	7f 07                	jg     869a <lodepng_chunk_find_const+0x21>
    8693:	b8 00 00 00 00       	mov    $0x0,%eax
    8698:	eb 2a                	jmp    86c4 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    869a:	ff 75 10             	pushl  0x10(%ebp)
    869d:	ff 75 08             	pushl  0x8(%ebp)
    86a0:	e8 40 fc ff ff       	call   82e5 <lodepng_chunk_type_equals>
    86a5:	83 c4 08             	add    $0x8,%esp
    86a8:	84 c0                	test   %al,%al
    86aa:	74 05                	je     86b1 <lodepng_chunk_find_const+0x38>
    86ac:	8b 45 08             	mov    0x8(%ebp),%eax
    86af:	eb 13                	jmp    86c4 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    86b1:	ff 75 0c             	pushl  0xc(%ebp)
    86b4:	ff 75 08             	pushl  0x8(%ebp)
    86b7:	e8 9a fe ff ff       	call   8556 <lodepng_chunk_next_const>
    86bc:	83 c4 08             	add    $0x8,%esp
    86bf:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    86c2:	eb b8                	jmp    867c <lodepng_chunk_find_const+0x3>
}
    86c4:	c9                   	leave  
    86c5:	c3                   	ret    

000086c6 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    86c6:	55                   	push   %ebp
    86c7:	89 e5                	mov    %esp,%ebp
    86c9:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    86cc:	ff 75 10             	pushl  0x10(%ebp)
    86cf:	e8 c4 fb ff ff       	call   8298 <lodepng_chunk_length>
    86d4:	83 c4 04             	add    $0x4,%esp
    86d7:	89 c2                	mov    %eax,%edx
    86d9:	8d 45 f0             	lea    -0x10(%ebp),%eax
    86dc:	50                   	push   %eax
    86dd:	6a 0c                	push   $0xc
    86df:	52                   	push   %edx
    86e0:	e8 f5 ac ff ff       	call   33da <lodepng_addofl>
    86e5:	83 c4 0c             	add    $0xc,%esp
    86e8:	85 c0                	test   %eax,%eax
    86ea:	74 0a                	je     86f6 <lodepng_chunk_append+0x30>
    86ec:	b8 4d 00 00 00       	mov    $0x4d,%eax
    86f1:	e9 96 00 00 00       	jmp    878c <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    86f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    86f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    86fc:	8b 00                	mov    (%eax),%eax
    86fe:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    8701:	51                   	push   %ecx
    8702:	52                   	push   %edx
    8703:	50                   	push   %eax
    8704:	e8 d1 ac ff ff       	call   33da <lodepng_addofl>
    8709:	83 c4 0c             	add    $0xc,%esp
    870c:	85 c0                	test   %eax,%eax
    870e:	74 07                	je     8717 <lodepng_chunk_append+0x51>
    8710:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8715:	eb 75                	jmp    878c <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8717:	8b 55 ec             	mov    -0x14(%ebp),%edx
    871a:	8b 45 08             	mov    0x8(%ebp),%eax
    871d:	8b 00                	mov    (%eax),%eax
    871f:	52                   	push   %edx
    8720:	50                   	push   %eax
    8721:	e8 07 ac ff ff       	call   332d <lodepng_realloc>
    8726:	83 c4 08             	add    $0x8,%esp
    8729:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    872c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    8730:	75 07                	jne    8739 <lodepng_chunk_append+0x73>
    8732:	b8 53 00 00 00       	mov    $0x53,%eax
    8737:	eb 53                	jmp    878c <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8739:	8b 45 08             	mov    0x8(%ebp),%eax
    873c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    873f:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8741:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8744:	8b 45 0c             	mov    0xc(%ebp),%eax
    8747:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8749:	8b 45 08             	mov    0x8(%ebp),%eax
    874c:	8b 00                	mov    (%eax),%eax
    874e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8751:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8754:	29 d1                	sub    %edx,%ecx
    8756:	89 ca                	mov    %ecx,%edx
    8758:	01 d0                	add    %edx,%eax
    875a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    875d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8764:	eb 19                	jmp    877f <lodepng_chunk_append+0xb9>
    8766:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8769:	8b 45 fc             	mov    -0x4(%ebp),%eax
    876c:	01 c2                	add    %eax,%edx
    876e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8771:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8774:	01 c8                	add    %ecx,%eax
    8776:	0f b6 00             	movzbl (%eax),%eax
    8779:	88 02                	mov    %al,(%edx)
    877b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    877f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8782:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8785:	75 df                	jne    8766 <lodepng_chunk_append+0xa0>

  return 0;
    8787:	b8 00 00 00 00       	mov    $0x0,%eax
}
    878c:	c9                   	leave  
    878d:	c3                   	ret    

0000878e <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    878e:	55                   	push   %ebp
    878f:	89 e5                	mov    %esp,%ebp
    8791:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8794:	8b 45 0c             	mov    0xc(%ebp),%eax
    8797:	8b 40 04             	mov    0x4(%eax),%eax
    879a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    879d:	8b 55 10             	mov    0x10(%ebp),%edx
    87a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87a3:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    87a6:	51                   	push   %ecx
    87a7:	52                   	push   %edx
    87a8:	50                   	push   %eax
    87a9:	e8 2c ac ff ff       	call   33da <lodepng_addofl>
    87ae:	83 c4 0c             	add    $0xc,%esp
    87b1:	85 c0                	test   %eax,%eax
    87b3:	74 07                	je     87bc <lodepng_chunk_init+0x2e>
    87b5:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87ba:	eb 78                	jmp    8834 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    87bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87bf:	8d 55 fc             	lea    -0x4(%ebp),%edx
    87c2:	52                   	push   %edx
    87c3:	6a 0c                	push   $0xc
    87c5:	50                   	push   %eax
    87c6:	e8 0f ac ff ff       	call   33da <lodepng_addofl>
    87cb:	83 c4 0c             	add    $0xc,%esp
    87ce:	85 c0                	test   %eax,%eax
    87d0:	74 07                	je     87d9 <lodepng_chunk_init+0x4b>
    87d2:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87d7:	eb 5b                	jmp    8834 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    87d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87dc:	50                   	push   %eax
    87dd:	ff 75 0c             	pushl  0xc(%ebp)
    87e0:	e8 8b ad ff ff       	call   3570 <ucvector_resize>
    87e5:	83 c4 08             	add    $0x8,%esp
    87e8:	85 c0                	test   %eax,%eax
    87ea:	75 07                	jne    87f3 <lodepng_chunk_init+0x65>
    87ec:	b8 53 00 00 00       	mov    $0x53,%eax
    87f1:	eb 41                	jmp    8834 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    87f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    87f6:	8b 00                	mov    (%eax),%eax
    87f8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    87fb:	2b 55 10             	sub    0x10(%ebp),%edx
    87fe:	83 ea 0c             	sub    $0xc,%edx
    8801:	01 c2                	add    %eax,%edx
    8803:	8b 45 08             	mov    0x8(%ebp),%eax
    8806:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8808:	8b 45 08             	mov    0x8(%ebp),%eax
    880b:	8b 00                	mov    (%eax),%eax
    880d:	ff 75 10             	pushl  0x10(%ebp)
    8810:	50                   	push   %eax
    8811:	e8 c1 ae ff ff       	call   36d7 <lodepng_set32bitInt>
    8816:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8819:	8b 45 08             	mov    0x8(%ebp),%eax
    881c:	8b 00                	mov    (%eax),%eax
    881e:	83 c0 04             	add    $0x4,%eax
    8821:	6a 04                	push   $0x4
    8823:	ff 75 14             	pushl  0x14(%ebp)
    8826:	50                   	push   %eax
    8827:	e8 28 ab ff ff       	call   3354 <lodepng_memcpy>
    882c:	83 c4 0c             	add    $0xc,%esp

  return 0;
    882f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8834:	c9                   	leave  
    8835:	c3                   	ret    

00008836 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8836:	55                   	push   %ebp
    8837:	89 e5                	mov    %esp,%ebp
    8839:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    883c:	ff 75 10             	pushl  0x10(%ebp)
    883f:	ff 75 0c             	pushl  0xc(%ebp)
    8842:	ff 75 08             	pushl  0x8(%ebp)
    8845:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8848:	50                   	push   %eax
    8849:	e8 40 ff ff ff       	call   878e <lodepng_chunk_init>
    884e:	83 c4 10             	add    $0x10,%esp
    8851:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8854:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8858:	74 05                	je     885f <lodepng_chunk_createv+0x29>
    885a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    885d:	eb 27                	jmp    8886 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    885f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8862:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8865:	83 c2 08             	add    $0x8,%edx
    8868:	50                   	push   %eax
    8869:	ff 75 14             	pushl  0x14(%ebp)
    886c:	52                   	push   %edx
    886d:	e8 e2 aa ff ff       	call   3354 <lodepng_memcpy>
    8872:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8875:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8878:	50                   	push   %eax
    8879:	e8 b9 fb ff ff       	call   8437 <lodepng_chunk_generate_crc>
    887e:	83 c4 04             	add    $0x4,%esp

  return 0;
    8881:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8886:	c9                   	leave  
    8887:	c3                   	ret    

00008888 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8888:	55                   	push   %ebp
    8889:	89 e5                	mov    %esp,%ebp
    888b:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    888e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8891:	8b 08                	mov    (%eax),%ecx
    8893:	8b 45 08             	mov    0x8(%ebp),%eax
    8896:	8b 10                	mov    (%eax),%edx
    8898:	8d 45 f0             	lea    -0x10(%ebp),%eax
    889b:	51                   	push   %ecx
    889c:	52                   	push   %edx
    889d:	50                   	push   %eax
    889e:	e8 34 ad ff ff       	call   35d7 <ucvector_init>
    88a3:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    88a6:	ff 75 18             	pushl  0x18(%ebp)
    88a9:	ff 75 14             	pushl  0x14(%ebp)
    88ac:	ff 75 10             	pushl  0x10(%ebp)
    88af:	8d 45 f0             	lea    -0x10(%ebp),%eax
    88b2:	50                   	push   %eax
    88b3:	e8 7e ff ff ff       	call   8836 <lodepng_chunk_createv>
    88b8:	83 c4 10             	add    $0x10,%esp
    88bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    88be:	8b 55 f0             	mov    -0x10(%ebp),%edx
    88c1:	8b 45 08             	mov    0x8(%ebp),%eax
    88c4:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    88c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    88c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    88cc:	89 10                	mov    %edx,(%eax)
  return error;
    88ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    88d1:	c9                   	leave  
    88d2:	c3                   	ret    

000088d3 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    88d3:	55                   	push   %ebp
    88d4:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    88d6:	8b 45 08             	mov    0x8(%ebp),%eax
    88d9:	83 f8 03             	cmp    $0x3,%eax
    88dc:	74 6d                	je     894b <checkColorValidity+0x78>
    88de:	83 f8 03             	cmp    $0x3,%eax
    88e1:	77 0e                	ja     88f1 <checkColorValidity+0x1e>
    88e3:	85 c0                	test   %eax,%eax
    88e5:	74 28                	je     890f <checkColorValidity+0x3c>
    88e7:	83 f8 02             	cmp    $0x2,%eax
    88ea:	74 4c                	je     8938 <checkColorValidity+0x65>
    88ec:	e9 a6 00 00 00       	jmp    8997 <checkColorValidity+0xc4>
    88f1:	83 f8 06             	cmp    $0x6,%eax
    88f4:	0f 84 83 00 00 00    	je     897d <checkColorValidity+0xaa>
    88fa:	3d ff 00 00 00       	cmp    $0xff,%eax
    88ff:	0f 84 8b 00 00 00    	je     8990 <checkColorValidity+0xbd>
    8905:	83 f8 04             	cmp    $0x4,%eax
    8908:	74 60                	je     896a <checkColorValidity+0x97>
    890a:	e9 88 00 00 00       	jmp    8997 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    890f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8913:	0f 84 85 00 00 00    	je     899e <checkColorValidity+0xcb>
    8919:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    891d:	74 7f                	je     899e <checkColorValidity+0xcb>
    891f:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8923:	74 79                	je     899e <checkColorValidity+0xcb>
    8925:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8929:	74 73                	je     899e <checkColorValidity+0xcb>
    892b:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    892f:	74 6d                	je     899e <checkColorValidity+0xcb>
    8931:	b8 25 00 00 00       	mov    $0x25,%eax
    8936:	eb 78                	jmp    89b0 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8938:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    893c:	74 63                	je     89a1 <checkColorValidity+0xce>
    893e:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8942:	74 5d                	je     89a1 <checkColorValidity+0xce>
    8944:	b8 25 00 00 00       	mov    $0x25,%eax
    8949:	eb 65                	jmp    89b0 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    894b:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    894f:	74 53                	je     89a4 <checkColorValidity+0xd1>
    8951:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8955:	74 4d                	je     89a4 <checkColorValidity+0xd1>
    8957:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    895b:	74 47                	je     89a4 <checkColorValidity+0xd1>
    895d:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8961:	74 41                	je     89a4 <checkColorValidity+0xd1>
    8963:	b8 25 00 00 00       	mov    $0x25,%eax
    8968:	eb 46                	jmp    89b0 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    896a:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    896e:	74 37                	je     89a7 <checkColorValidity+0xd4>
    8970:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8974:	74 31                	je     89a7 <checkColorValidity+0xd4>
    8976:	b8 25 00 00 00       	mov    $0x25,%eax
    897b:	eb 33                	jmp    89b0 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    897d:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8981:	74 27                	je     89aa <checkColorValidity+0xd7>
    8983:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8987:	74 21                	je     89aa <checkColorValidity+0xd7>
    8989:	b8 25 00 00 00       	mov    $0x25,%eax
    898e:	eb 20                	jmp    89b0 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8990:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8995:	eb 19                	jmp    89b0 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8997:	b8 1f 00 00 00       	mov    $0x1f,%eax
    899c:	eb 12                	jmp    89b0 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    899e:	90                   	nop
    899f:	eb 0a                	jmp    89ab <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89a1:	90                   	nop
    89a2:	eb 07                	jmp    89ab <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    89a4:	90                   	nop
    89a5:	eb 04                	jmp    89ab <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89a7:	90                   	nop
    89a8:	eb 01                	jmp    89ab <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89aa:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    89ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
    89b0:	5d                   	pop    %ebp
    89b1:	c3                   	ret    

000089b2 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    89b2:	55                   	push   %ebp
    89b3:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    89b5:	8b 45 08             	mov    0x8(%ebp),%eax
    89b8:	83 f8 03             	cmp    $0x3,%eax
    89bb:	74 31                	je     89ee <getNumColorChannels+0x3c>
    89bd:	83 f8 03             	cmp    $0x3,%eax
    89c0:	77 0b                	ja     89cd <getNumColorChannels+0x1b>
    89c2:	85 c0                	test   %eax,%eax
    89c4:	74 1a                	je     89e0 <getNumColorChannels+0x2e>
    89c6:	83 f8 02             	cmp    $0x2,%eax
    89c9:	74 1c                	je     89e7 <getNumColorChannels+0x35>
    89cb:	eb 3d                	jmp    8a0a <getNumColorChannels+0x58>
    89cd:	83 f8 06             	cmp    $0x6,%eax
    89d0:	74 2a                	je     89fc <getNumColorChannels+0x4a>
    89d2:	3d ff 00 00 00       	cmp    $0xff,%eax
    89d7:	74 2a                	je     8a03 <getNumColorChannels+0x51>
    89d9:	83 f8 04             	cmp    $0x4,%eax
    89dc:	74 17                	je     89f5 <getNumColorChannels+0x43>
    89de:	eb 2a                	jmp    8a0a <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    89e0:	b8 01 00 00 00       	mov    $0x1,%eax
    89e5:	eb 28                	jmp    8a0f <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    89e7:	b8 03 00 00 00       	mov    $0x3,%eax
    89ec:	eb 21                	jmp    8a0f <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    89ee:	b8 01 00 00 00       	mov    $0x1,%eax
    89f3:	eb 1a                	jmp    8a0f <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    89f5:	b8 02 00 00 00       	mov    $0x2,%eax
    89fa:	eb 13                	jmp    8a0f <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    89fc:	b8 04 00 00 00       	mov    $0x4,%eax
    8a01:	eb 0c                	jmp    8a0f <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8a03:	b8 00 00 00 00       	mov    $0x0,%eax
    8a08:	eb 05                	jmp    8a0f <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8a0a:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8a0f:	5d                   	pop    %ebp
    8a10:	c3                   	ret    

00008a11 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8a11:	55                   	push   %ebp
    8a12:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8a14:	ff 75 08             	pushl  0x8(%ebp)
    8a17:	e8 96 ff ff ff       	call   89b2 <getNumColorChannels>
    8a1c:	83 c4 04             	add    $0x4,%esp
    8a1f:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8a23:	c9                   	leave  
    8a24:	c3                   	ret    

00008a25 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8a25:	55                   	push   %ebp
    8a26:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8a28:	8b 45 08             	mov    0x8(%ebp),%eax
    8a2b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8a32:	8b 45 08             	mov    0x8(%ebp),%eax
    8a35:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8a3c:	8b 45 08             	mov    0x8(%ebp),%eax
    8a3f:	8b 50 1c             	mov    0x1c(%eax),%edx
    8a42:	8b 45 08             	mov    0x8(%ebp),%eax
    8a45:	89 50 18             	mov    %edx,0x18(%eax)
    8a48:	8b 45 08             	mov    0x8(%ebp),%eax
    8a4b:	8b 50 18             	mov    0x18(%eax),%edx
    8a4e:	8b 45 08             	mov    0x8(%ebp),%eax
    8a51:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8a54:	8b 45 08             	mov    0x8(%ebp),%eax
    8a57:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8a5d:	8b 45 08             	mov    0x8(%ebp),%eax
    8a60:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8a67:	8b 45 08             	mov    0x8(%ebp),%eax
    8a6a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8a71:	8b 45 08             	mov    0x8(%ebp),%eax
    8a74:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8a7b:	90                   	nop
    8a7c:	5d                   	pop    %ebp
    8a7d:	c3                   	ret    

00008a7e <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8a7e:	55                   	push   %ebp
    8a7f:	89 e5                	mov    %esp,%ebp
    8a81:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8a84:	8b 45 08             	mov    0x8(%ebp),%eax
    8a87:	8b 40 08             	mov    0x8(%eax),%eax
    8a8a:	85 c0                	test   %eax,%eax
    8a8c:	75 18                	jne    8aa6 <lodepng_color_mode_alloc_palette+0x28>
    8a8e:	83 ec 0c             	sub    $0xc,%esp
    8a91:	68 00 04 00 00       	push   $0x400
    8a96:	e8 7b a8 ff ff       	call   3316 <lodepng_malloc>
    8a9b:	83 c4 10             	add    $0x10,%esp
    8a9e:	89 c2                	mov    %eax,%edx
    8aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    8aa3:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8aa6:	8b 45 08             	mov    0x8(%ebp),%eax
    8aa9:	8b 40 08             	mov    0x8(%eax),%eax
    8aac:	85 c0                	test   %eax,%eax
    8aae:	74 65                	je     8b15 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8ab0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8ab7:	eb 51                	jmp    8b0a <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8ab9:	8b 45 08             	mov    0x8(%ebp),%eax
    8abc:	8b 40 08             	mov    0x8(%eax),%eax
    8abf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ac2:	c1 e2 02             	shl    $0x2,%edx
    8ac5:	01 d0                	add    %edx,%eax
    8ac7:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8aca:	8b 45 08             	mov    0x8(%ebp),%eax
    8acd:	8b 40 08             	mov    0x8(%eax),%eax
    8ad0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ad3:	c1 e2 02             	shl    $0x2,%edx
    8ad6:	83 c2 01             	add    $0x1,%edx
    8ad9:	01 d0                	add    %edx,%eax
    8adb:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8ade:	8b 45 08             	mov    0x8(%ebp),%eax
    8ae1:	8b 40 08             	mov    0x8(%eax),%eax
    8ae4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ae7:	c1 e2 02             	shl    $0x2,%edx
    8aea:	83 c2 02             	add    $0x2,%edx
    8aed:	01 d0                	add    %edx,%eax
    8aef:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8af2:	8b 45 08             	mov    0x8(%ebp),%eax
    8af5:	8b 40 08             	mov    0x8(%eax),%eax
    8af8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8afb:	c1 e2 02             	shl    $0x2,%edx
    8afe:	83 c2 03             	add    $0x3,%edx
    8b01:	01 d0                	add    %edx,%eax
    8b03:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8b06:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8b0a:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8b11:	75 a6                	jne    8ab9 <lodepng_color_mode_alloc_palette+0x3b>
    8b13:	eb 01                	jmp    8b16 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8b15:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8b16:	c9                   	leave  
    8b17:	c3                   	ret    

00008b18 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8b18:	55                   	push   %ebp
    8b19:	89 e5                	mov    %esp,%ebp
    8b1b:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8b1e:	83 ec 0c             	sub    $0xc,%esp
    8b21:	ff 75 08             	pushl  0x8(%ebp)
    8b24:	e8 f3 01 00 00       	call   8d1c <lodepng_palette_clear>
    8b29:	83 c4 10             	add    $0x10,%esp
}
    8b2c:	90                   	nop
    8b2d:	c9                   	leave  
    8b2e:	c3                   	ret    

00008b2f <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8b2f:	55                   	push   %ebp
    8b30:	89 e5                	mov    %esp,%ebp
    8b32:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8b35:	83 ec 0c             	sub    $0xc,%esp
    8b38:	ff 75 08             	pushl  0x8(%ebp)
    8b3b:	e8 d8 ff ff ff       	call   8b18 <lodepng_color_mode_cleanup>
    8b40:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8b43:	83 ec 04             	sub    $0x4,%esp
    8b46:	6a 20                	push   $0x20
    8b48:	ff 75 0c             	pushl  0xc(%ebp)
    8b4b:	ff 75 08             	pushl  0x8(%ebp)
    8b4e:	e8 01 a8 ff ff       	call   3354 <lodepng_memcpy>
    8b53:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8b56:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b59:	8b 40 08             	mov    0x8(%eax),%eax
    8b5c:	85 c0                	test   %eax,%eax
    8b5e:	74 5a                	je     8bba <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8b60:	83 ec 0c             	sub    $0xc,%esp
    8b63:	68 00 04 00 00       	push   $0x400
    8b68:	e8 a9 a7 ff ff       	call   3316 <lodepng_malloc>
    8b6d:	83 c4 10             	add    $0x10,%esp
    8b70:	89 c2                	mov    %eax,%edx
    8b72:	8b 45 08             	mov    0x8(%ebp),%eax
    8b75:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8b78:	8b 45 08             	mov    0x8(%ebp),%eax
    8b7b:	8b 40 08             	mov    0x8(%eax),%eax
    8b7e:	85 c0                	test   %eax,%eax
    8b80:	75 11                	jne    8b93 <lodepng_color_mode_copy+0x64>
    8b82:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b85:	8b 40 0c             	mov    0xc(%eax),%eax
    8b88:	85 c0                	test   %eax,%eax
    8b8a:	74 07                	je     8b93 <lodepng_color_mode_copy+0x64>
    8b8c:	b8 53 00 00 00       	mov    $0x53,%eax
    8b91:	eb 2c                	jmp    8bbf <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8b93:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b96:	8b 40 0c             	mov    0xc(%eax),%eax
    8b99:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8ba0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ba3:	8b 50 08             	mov    0x8(%eax),%edx
    8ba6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba9:	8b 40 08             	mov    0x8(%eax),%eax
    8bac:	83 ec 04             	sub    $0x4,%esp
    8baf:	51                   	push   %ecx
    8bb0:	52                   	push   %edx
    8bb1:	50                   	push   %eax
    8bb2:	e8 9d a7 ff ff       	call   3354 <lodepng_memcpy>
    8bb7:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8bba:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8bbf:	c9                   	leave  
    8bc0:	c3                   	ret    

00008bc1 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8bc1:	55                   	push   %ebp
    8bc2:	89 e5                	mov    %esp,%ebp
    8bc4:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8bc7:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8bca:	50                   	push   %eax
    8bcb:	e8 55 fe ff ff       	call   8a25 <lodepng_color_mode_init>
    8bd0:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8bd9:	8b 45 10             	mov    0x10(%ebp),%eax
    8bdc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8bdf:	8b 45 08             	mov    0x8(%ebp),%eax
    8be2:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8be5:	89 10                	mov    %edx,(%eax)
    8be7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8bea:	89 50 04             	mov    %edx,0x4(%eax)
    8bed:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8bf0:	89 50 08             	mov    %edx,0x8(%eax)
    8bf3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8bf6:	89 50 0c             	mov    %edx,0xc(%eax)
    8bf9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8bfc:	89 50 10             	mov    %edx,0x10(%eax)
    8bff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c02:	89 50 14             	mov    %edx,0x14(%eax)
    8c05:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8c08:	89 50 18             	mov    %edx,0x18(%eax)
    8c0b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8c0e:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8c11:	8b 45 08             	mov    0x8(%ebp),%eax
    8c14:	c9                   	leave  
    8c15:	c2 04 00             	ret    $0x4

00008c18 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8c18:	55                   	push   %ebp
    8c19:	89 e5                	mov    %esp,%ebp
    8c1b:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8c1e:	8b 45 08             	mov    0x8(%ebp),%eax
    8c21:	8b 10                	mov    (%eax),%edx
    8c23:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c26:	8b 00                	mov    (%eax),%eax
    8c28:	39 c2                	cmp    %eax,%edx
    8c2a:	74 0a                	je     8c36 <lodepng_color_mode_equal+0x1e>
    8c2c:	b8 00 00 00 00       	mov    $0x0,%eax
    8c31:	e9 e4 00 00 00       	jmp    8d1a <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8c36:	8b 45 08             	mov    0x8(%ebp),%eax
    8c39:	8b 50 04             	mov    0x4(%eax),%edx
    8c3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c3f:	8b 40 04             	mov    0x4(%eax),%eax
    8c42:	39 c2                	cmp    %eax,%edx
    8c44:	74 0a                	je     8c50 <lodepng_color_mode_equal+0x38>
    8c46:	b8 00 00 00 00       	mov    $0x0,%eax
    8c4b:	e9 ca 00 00 00       	jmp    8d1a <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8c50:	8b 45 08             	mov    0x8(%ebp),%eax
    8c53:	8b 50 10             	mov    0x10(%eax),%edx
    8c56:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c59:	8b 40 10             	mov    0x10(%eax),%eax
    8c5c:	39 c2                	cmp    %eax,%edx
    8c5e:	74 0a                	je     8c6a <lodepng_color_mode_equal+0x52>
    8c60:	b8 00 00 00 00       	mov    $0x0,%eax
    8c65:	e9 b0 00 00 00       	jmp    8d1a <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8c6a:	8b 45 08             	mov    0x8(%ebp),%eax
    8c6d:	8b 40 10             	mov    0x10(%eax),%eax
    8c70:	85 c0                	test   %eax,%eax
    8c72:	74 48                	je     8cbc <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8c74:	8b 45 08             	mov    0x8(%ebp),%eax
    8c77:	8b 50 14             	mov    0x14(%eax),%edx
    8c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c7d:	8b 40 14             	mov    0x14(%eax),%eax
    8c80:	39 c2                	cmp    %eax,%edx
    8c82:	74 0a                	je     8c8e <lodepng_color_mode_equal+0x76>
    8c84:	b8 00 00 00 00       	mov    $0x0,%eax
    8c89:	e9 8c 00 00 00       	jmp    8d1a <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8c8e:	8b 45 08             	mov    0x8(%ebp),%eax
    8c91:	8b 50 18             	mov    0x18(%eax),%edx
    8c94:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c97:	8b 40 18             	mov    0x18(%eax),%eax
    8c9a:	39 c2                	cmp    %eax,%edx
    8c9c:	74 07                	je     8ca5 <lodepng_color_mode_equal+0x8d>
    8c9e:	b8 00 00 00 00       	mov    $0x0,%eax
    8ca3:	eb 75                	jmp    8d1a <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8ca5:	8b 45 08             	mov    0x8(%ebp),%eax
    8ca8:	8b 50 1c             	mov    0x1c(%eax),%edx
    8cab:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cae:	8b 40 1c             	mov    0x1c(%eax),%eax
    8cb1:	39 c2                	cmp    %eax,%edx
    8cb3:	74 07                	je     8cbc <lodepng_color_mode_equal+0xa4>
    8cb5:	b8 00 00 00 00       	mov    $0x0,%eax
    8cba:	eb 5e                	jmp    8d1a <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8cbc:	8b 45 08             	mov    0x8(%ebp),%eax
    8cbf:	8b 50 0c             	mov    0xc(%eax),%edx
    8cc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cc5:	8b 40 0c             	mov    0xc(%eax),%eax
    8cc8:	39 c2                	cmp    %eax,%edx
    8cca:	74 07                	je     8cd3 <lodepng_color_mode_equal+0xbb>
    8ccc:	b8 00 00 00 00       	mov    $0x0,%eax
    8cd1:	eb 47                	jmp    8d1a <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8cd3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8cda:	eb 2b                	jmp    8d07 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8cdc:	8b 45 08             	mov    0x8(%ebp),%eax
    8cdf:	8b 50 08             	mov    0x8(%eax),%edx
    8ce2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8ce5:	01 d0                	add    %edx,%eax
    8ce7:	0f b6 10             	movzbl (%eax),%edx
    8cea:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ced:	8b 48 08             	mov    0x8(%eax),%ecx
    8cf0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8cf3:	01 c8                	add    %ecx,%eax
    8cf5:	0f b6 00             	movzbl (%eax),%eax
    8cf8:	38 c2                	cmp    %al,%dl
    8cfa:	74 07                	je     8d03 <lodepng_color_mode_equal+0xeb>
    8cfc:	b8 00 00 00 00       	mov    $0x0,%eax
    8d01:	eb 17                	jmp    8d1a <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8d03:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8d07:	8b 45 08             	mov    0x8(%ebp),%eax
    8d0a:	8b 40 0c             	mov    0xc(%eax),%eax
    8d0d:	c1 e0 02             	shl    $0x2,%eax
    8d10:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8d13:	75 c7                	jne    8cdc <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8d15:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8d1a:	c9                   	leave  
    8d1b:	c3                   	ret    

00008d1c <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8d1c:	55                   	push   %ebp
    8d1d:	89 e5                	mov    %esp,%ebp
    8d1f:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8d22:	8b 45 08             	mov    0x8(%ebp),%eax
    8d25:	8b 40 08             	mov    0x8(%eax),%eax
    8d28:	85 c0                	test   %eax,%eax
    8d2a:	74 12                	je     8d3e <lodepng_palette_clear+0x22>
    8d2c:	8b 45 08             	mov    0x8(%ebp),%eax
    8d2f:	8b 40 08             	mov    0x8(%eax),%eax
    8d32:	83 ec 0c             	sub    $0xc,%esp
    8d35:	50                   	push   %eax
    8d36:	e8 fc a5 ff ff       	call   3337 <lodepng_free>
    8d3b:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8d3e:	8b 45 08             	mov    0x8(%ebp),%eax
    8d41:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8d48:	8b 45 08             	mov    0x8(%ebp),%eax
    8d4b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8d52:	90                   	nop
    8d53:	c9                   	leave  
    8d54:	c3                   	ret    

00008d55 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8d55:	55                   	push   %ebp
    8d56:	89 e5                	mov    %esp,%ebp
    8d58:	53                   	push   %ebx
    8d59:	83 ec 14             	sub    $0x14,%esp
    8d5c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8d5f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8d62:	8b 55 14             	mov    0x14(%ebp),%edx
    8d65:	8b 45 18             	mov    0x18(%ebp),%eax
    8d68:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8d6b:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8d6e:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8d71:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8d74:	8b 45 08             	mov    0x8(%ebp),%eax
    8d77:	8b 40 08             	mov    0x8(%eax),%eax
    8d7a:	85 c0                	test   %eax,%eax
    8d7c:	75 22                	jne    8da0 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8d7e:	83 ec 0c             	sub    $0xc,%esp
    8d81:	ff 75 08             	pushl  0x8(%ebp)
    8d84:	e8 f5 fc ff ff       	call   8a7e <lodepng_color_mode_alloc_palette>
    8d89:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8d8c:	8b 45 08             	mov    0x8(%ebp),%eax
    8d8f:	8b 40 08             	mov    0x8(%eax),%eax
    8d92:	85 c0                	test   %eax,%eax
    8d94:	75 0a                	jne    8da0 <lodepng_palette_add+0x4b>
    8d96:	b8 53 00 00 00       	mov    $0x53,%eax
    8d9b:	e9 8d 00 00 00       	jmp    8e2d <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8da0:	8b 45 08             	mov    0x8(%ebp),%eax
    8da3:	8b 40 0c             	mov    0xc(%eax),%eax
    8da6:	3d ff 00 00 00       	cmp    $0xff,%eax
    8dab:	7e 07                	jle    8db4 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8dad:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8db2:	eb 79                	jmp    8e2d <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8db4:	8b 45 08             	mov    0x8(%ebp),%eax
    8db7:	8b 50 08             	mov    0x8(%eax),%edx
    8dba:	8b 45 08             	mov    0x8(%ebp),%eax
    8dbd:	8b 40 0c             	mov    0xc(%eax),%eax
    8dc0:	c1 e0 02             	shl    $0x2,%eax
    8dc3:	01 c2                	add    %eax,%edx
    8dc5:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8dc9:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8dcb:	8b 45 08             	mov    0x8(%ebp),%eax
    8dce:	8b 50 08             	mov    0x8(%eax),%edx
    8dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    8dd4:	8b 40 0c             	mov    0xc(%eax),%eax
    8dd7:	c1 e0 02             	shl    $0x2,%eax
    8dda:	83 c0 01             	add    $0x1,%eax
    8ddd:	01 c2                	add    %eax,%edx
    8ddf:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8de3:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8de5:	8b 45 08             	mov    0x8(%ebp),%eax
    8de8:	8b 50 08             	mov    0x8(%eax),%edx
    8deb:	8b 45 08             	mov    0x8(%ebp),%eax
    8dee:	8b 40 0c             	mov    0xc(%eax),%eax
    8df1:	c1 e0 02             	shl    $0x2,%eax
    8df4:	83 c0 02             	add    $0x2,%eax
    8df7:	01 c2                	add    %eax,%edx
    8df9:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8dfd:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8dff:	8b 45 08             	mov    0x8(%ebp),%eax
    8e02:	8b 50 08             	mov    0x8(%eax),%edx
    8e05:	8b 45 08             	mov    0x8(%ebp),%eax
    8e08:	8b 40 0c             	mov    0xc(%eax),%eax
    8e0b:	c1 e0 02             	shl    $0x2,%eax
    8e0e:	83 c0 03             	add    $0x3,%eax
    8e11:	01 c2                	add    %eax,%edx
    8e13:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8e17:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8e19:	8b 45 08             	mov    0x8(%ebp),%eax
    8e1c:	8b 40 0c             	mov    0xc(%eax),%eax
    8e1f:	8d 50 01             	lea    0x1(%eax),%edx
    8e22:	8b 45 08             	mov    0x8(%ebp),%eax
    8e25:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8e28:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8e30:	c9                   	leave  
    8e31:	c3                   	ret    

00008e32 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8e32:	55                   	push   %ebp
    8e33:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8e35:	8b 45 08             	mov    0x8(%ebp),%eax
    8e38:	8b 50 04             	mov    0x4(%eax),%edx
    8e3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e3e:	8b 00                	mov    (%eax),%eax
    8e40:	52                   	push   %edx
    8e41:	50                   	push   %eax
    8e42:	e8 ca fb ff ff       	call   8a11 <lodepng_get_bpp_lct>
    8e47:	83 c4 08             	add    $0x8,%esp
}
    8e4a:	c9                   	leave  
    8e4b:	c3                   	ret    

00008e4c <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8e4c:	55                   	push   %ebp
    8e4d:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8e4f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e52:	8b 00                	mov    (%eax),%eax
    8e54:	50                   	push   %eax
    8e55:	e8 58 fb ff ff       	call   89b2 <getNumColorChannels>
    8e5a:	83 c4 04             	add    $0x4,%esp
}
    8e5d:	c9                   	leave  
    8e5e:	c3                   	ret    

00008e5f <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8e5f:	55                   	push   %ebp
    8e60:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8e62:	8b 45 08             	mov    0x8(%ebp),%eax
    8e65:	8b 00                	mov    (%eax),%eax
    8e67:	85 c0                	test   %eax,%eax
    8e69:	74 0a                	je     8e75 <lodepng_is_greyscale_type+0x16>
    8e6b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e6e:	8b 00                	mov    (%eax),%eax
    8e70:	83 f8 04             	cmp    $0x4,%eax
    8e73:	75 07                	jne    8e7c <lodepng_is_greyscale_type+0x1d>
    8e75:	b8 01 00 00 00       	mov    $0x1,%eax
    8e7a:	eb 05                	jmp    8e81 <lodepng_is_greyscale_type+0x22>
    8e7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e81:	5d                   	pop    %ebp
    8e82:	c3                   	ret    

00008e83 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8e83:	55                   	push   %ebp
    8e84:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8e86:	8b 45 08             	mov    0x8(%ebp),%eax
    8e89:	8b 00                	mov    (%eax),%eax
    8e8b:	83 e0 04             	and    $0x4,%eax
    8e8e:	85 c0                	test   %eax,%eax
    8e90:	0f 95 c0             	setne  %al
    8e93:	0f b6 c0             	movzbl %al,%eax
}
    8e96:	5d                   	pop    %ebp
    8e97:	c3                   	ret    

00008e98 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8e98:	55                   	push   %ebp
    8e99:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8e9b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e9e:	8b 00                	mov    (%eax),%eax
    8ea0:	83 f8 03             	cmp    $0x3,%eax
    8ea3:	0f 94 c0             	sete   %al
    8ea6:	0f b6 c0             	movzbl %al,%eax
}
    8ea9:	5d                   	pop    %ebp
    8eaa:	c3                   	ret    

00008eab <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8eab:	55                   	push   %ebp
    8eac:	89 e5                	mov    %esp,%ebp
    8eae:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8eb1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8eb8:	eb 23                	jmp    8edd <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8eba:	8b 45 08             	mov    0x8(%ebp),%eax
    8ebd:	8b 40 08             	mov    0x8(%eax),%eax
    8ec0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8ec3:	c1 e2 02             	shl    $0x2,%edx
    8ec6:	83 c2 03             	add    $0x3,%edx
    8ec9:	01 d0                	add    %edx,%eax
    8ecb:	0f b6 00             	movzbl (%eax),%eax
    8ece:	3c ff                	cmp    $0xff,%al
    8ed0:	74 07                	je     8ed9 <lodepng_has_palette_alpha+0x2e>
    8ed2:	b8 01 00 00 00       	mov    $0x1,%eax
    8ed7:	eb 14                	jmp    8eed <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8ed9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8edd:	8b 45 08             	mov    0x8(%ebp),%eax
    8ee0:	8b 40 0c             	mov    0xc(%eax),%eax
    8ee3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8ee6:	75 d2                	jne    8eba <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8ee8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8eed:	c9                   	leave  
    8eee:	c3                   	ret    

00008eef <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8eef:	55                   	push   %ebp
    8ef0:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8ef2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ef5:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8ef8:	85 c0                	test   %eax,%eax
    8efa:	75 1e                	jne    8f1a <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8efc:	ff 75 08             	pushl  0x8(%ebp)
    8eff:	e8 7f ff ff ff       	call   8e83 <lodepng_is_alpha_type>
    8f04:	83 c4 04             	add    $0x4,%esp
    8f07:	85 c0                	test   %eax,%eax
    8f09:	75 0f                	jne    8f1a <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8f0b:	ff 75 08             	pushl  0x8(%ebp)
    8f0e:	e8 98 ff ff ff       	call   8eab <lodepng_has_palette_alpha>
    8f13:	83 c4 04             	add    $0x4,%esp
    8f16:	85 c0                	test   %eax,%eax
    8f18:	74 07                	je     8f21 <lodepng_can_have_alpha+0x32>
    8f1a:	b8 01 00 00 00       	mov    $0x1,%eax
    8f1f:	eb 05                	jmp    8f26 <lodepng_can_have_alpha+0x37>
    8f21:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f26:	c9                   	leave  
    8f27:	c3                   	ret    

00008f28 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    8f28:	55                   	push   %ebp
    8f29:	89 e5                	mov    %esp,%ebp
    8f2b:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    8f2e:	ff 75 14             	pushl  0x14(%ebp)
    8f31:	ff 75 10             	pushl  0x10(%ebp)
    8f34:	e8 d8 fa ff ff       	call   8a11 <lodepng_get_bpp_lct>
    8f39:	83 c4 08             	add    $0x8,%esp
    8f3c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    8f3f:	8b 55 08             	mov    0x8(%ebp),%edx
    8f42:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f45:	0f af c2             	imul   %edx,%eax
    8f48:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    8f4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8f4e:	c1 e8 03             	shr    $0x3,%eax
    8f51:	89 c2                	mov    %eax,%edx
    8f53:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f56:	0f af c2             	imul   %edx,%eax
    8f59:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8f5c:	89 d1                	mov    %edx,%ecx
    8f5e:	83 e1 07             	and    $0x7,%ecx
    8f61:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f64:	0f af d1             	imul   %ecx,%edx
    8f67:	83 c2 07             	add    $0x7,%edx
    8f6a:	c1 ea 03             	shr    $0x3,%edx
    8f6d:	01 d0                	add    %edx,%eax
}
    8f6f:	c9                   	leave  
    8f70:	c3                   	ret    

00008f71 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    8f71:	55                   	push   %ebp
    8f72:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    8f74:	8b 45 10             	mov    0x10(%ebp),%eax
    8f77:	8b 50 04             	mov    0x4(%eax),%edx
    8f7a:	8b 45 10             	mov    0x10(%ebp),%eax
    8f7d:	8b 00                	mov    (%eax),%eax
    8f7f:	52                   	push   %edx
    8f80:	50                   	push   %eax
    8f81:	ff 75 0c             	pushl  0xc(%ebp)
    8f84:	ff 75 08             	pushl  0x8(%ebp)
    8f87:	e8 9c ff ff ff       	call   8f28 <lodepng_get_raw_size_lct>
    8f8c:	83 c4 10             	add    $0x10,%esp
}
    8f8f:	c9                   	leave  
    8f90:	c3                   	ret    

00008f91 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    8f91:	55                   	push   %ebp
    8f92:	89 e5                	mov    %esp,%ebp
    8f94:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    8f97:	8b 45 08             	mov    0x8(%ebp),%eax
    8f9a:	c1 e8 03             	shr    $0x3,%eax
    8f9d:	0f af 45 10          	imul   0x10(%ebp),%eax
    8fa1:	8b 55 08             	mov    0x8(%ebp),%edx
    8fa4:	83 e2 07             	and    $0x7,%edx
    8fa7:	0f af 55 10          	imul   0x10(%ebp),%edx
    8fab:	83 c2 07             	add    $0x7,%edx
    8fae:	c1 ea 03             	shr    $0x3,%edx
    8fb1:	01 d0                	add    %edx,%eax
    8fb3:	83 c0 01             	add    $0x1,%eax
    8fb6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    8fb9:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fbc:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    8fc0:	c9                   	leave  
    8fc1:	c3                   	ret    

00008fc2 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    8fc2:	55                   	push   %ebp
    8fc3:	89 e5                	mov    %esp,%ebp
    8fc5:	53                   	push   %ebx
    8fc6:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    8fc9:	ff 75 10             	pushl  0x10(%ebp)
    8fcc:	e8 61 fe ff ff       	call   8e32 <lodepng_get_bpp>
    8fd1:	83 c4 04             	add    $0x4,%esp
    8fd4:	89 c3                	mov    %eax,%ebx
    8fd6:	ff 75 14             	pushl  0x14(%ebp)
    8fd9:	e8 54 fe ff ff       	call   8e32 <lodepng_get_bpp>
    8fde:	83 c4 04             	add    $0x4,%esp
    8fe1:	39 c3                	cmp    %eax,%ebx
    8fe3:	76 0d                	jbe    8ff2 <lodepng_pixel_overflow+0x30>
    8fe5:	ff 75 10             	pushl  0x10(%ebp)
    8fe8:	e8 45 fe ff ff       	call   8e32 <lodepng_get_bpp>
    8fed:	83 c4 04             	add    $0x4,%esp
    8ff0:	eb 0b                	jmp    8ffd <lodepng_pixel_overflow+0x3b>
    8ff2:	ff 75 14             	pushl  0x14(%ebp)
    8ff5:	e8 38 fe ff ff       	call   8e32 <lodepng_get_bpp>
    8ffa:	83 c4 04             	add    $0x4,%esp
    8ffd:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    9000:	8b 55 0c             	mov    0xc(%ebp),%edx
    9003:	8b 45 08             	mov    0x8(%ebp),%eax
    9006:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9009:	51                   	push   %ecx
    900a:	52                   	push   %edx
    900b:	50                   	push   %eax
    900c:	e8 e9 a3 ff ff       	call   33fa <lodepng_mulofl>
    9011:	83 c4 0c             	add    $0xc,%esp
    9014:	85 c0                	test   %eax,%eax
    9016:	74 0a                	je     9022 <lodepng_pixel_overflow+0x60>
    9018:	b8 01 00 00 00       	mov    $0x1,%eax
    901d:	e9 b6 00 00 00       	jmp    90d8 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    9022:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9025:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9028:	52                   	push   %edx
    9029:	6a 08                	push   $0x8
    902b:	50                   	push   %eax
    902c:	e8 c9 a3 ff ff       	call   33fa <lodepng_mulofl>
    9031:	83 c4 0c             	add    $0xc,%esp
    9034:	85 c0                	test   %eax,%eax
    9036:	74 0a                	je     9042 <lodepng_pixel_overflow+0x80>
    9038:	b8 01 00 00 00       	mov    $0x1,%eax
    903d:	e9 96 00 00 00       	jmp    90d8 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9042:	8b 45 08             	mov    0x8(%ebp),%eax
    9045:	c1 e8 03             	shr    $0x3,%eax
    9048:	89 c2                	mov    %eax,%edx
    904a:	8d 45 ec             	lea    -0x14(%ebp),%eax
    904d:	50                   	push   %eax
    904e:	ff 75 f8             	pushl  -0x8(%ebp)
    9051:	52                   	push   %edx
    9052:	e8 a3 a3 ff ff       	call   33fa <lodepng_mulofl>
    9057:	83 c4 0c             	add    $0xc,%esp
    905a:	85 c0                	test   %eax,%eax
    905c:	74 07                	je     9065 <lodepng_pixel_overflow+0xa3>
    905e:	b8 01 00 00 00       	mov    $0x1,%eax
    9063:	eb 73                	jmp    90d8 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9065:	8b 45 08             	mov    0x8(%ebp),%eax
    9068:	83 e0 07             	and    $0x7,%eax
    906b:	89 c2                	mov    %eax,%edx
    906d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9070:	0f af c2             	imul   %edx,%eax
    9073:	83 c0 07             	add    $0x7,%eax
    9076:	c1 e8 03             	shr    $0x3,%eax
    9079:	89 c1                	mov    %eax,%ecx
    907b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    907e:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9081:	52                   	push   %edx
    9082:	51                   	push   %ecx
    9083:	50                   	push   %eax
    9084:	e8 51 a3 ff ff       	call   33da <lodepng_addofl>
    9089:	83 c4 0c             	add    $0xc,%esp
    908c:	85 c0                	test   %eax,%eax
    908e:	74 07                	je     9097 <lodepng_pixel_overflow+0xd5>
    9090:	b8 01 00 00 00       	mov    $0x1,%eax
    9095:	eb 41                	jmp    90d8 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9097:	8b 45 ec             	mov    -0x14(%ebp),%eax
    909a:	8d 55 ec             	lea    -0x14(%ebp),%edx
    909d:	52                   	push   %edx
    909e:	6a 05                	push   $0x5
    90a0:	50                   	push   %eax
    90a1:	e8 34 a3 ff ff       	call   33da <lodepng_addofl>
    90a6:	83 c4 0c             	add    $0xc,%esp
    90a9:	85 c0                	test   %eax,%eax
    90ab:	74 07                	je     90b4 <lodepng_pixel_overflow+0xf2>
    90ad:	b8 01 00 00 00       	mov    $0x1,%eax
    90b2:	eb 24                	jmp    90d8 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    90b4:	8b 55 0c             	mov    0xc(%ebp),%edx
    90b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90ba:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    90bd:	51                   	push   %ecx
    90be:	52                   	push   %edx
    90bf:	50                   	push   %eax
    90c0:	e8 35 a3 ff ff       	call   33fa <lodepng_mulofl>
    90c5:	83 c4 0c             	add    $0xc,%esp
    90c8:	85 c0                	test   %eax,%eax
    90ca:	74 07                	je     90d3 <lodepng_pixel_overflow+0x111>
    90cc:	b8 01 00 00 00       	mov    $0x1,%eax
    90d1:	eb 05                	jmp    90d8 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    90d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    90d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    90db:	c9                   	leave  
    90dc:	c3                   	ret    

000090dd <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    90dd:	55                   	push   %ebp
    90de:	89 e5                	mov    %esp,%ebp
    90e0:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    90e3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    90ea:	eb 15                	jmp    9101 <LodePNGUnknownChunks_init+0x24>
    90ec:	8b 45 08             	mov    0x8(%ebp),%eax
    90ef:	8b 55 fc             	mov    -0x4(%ebp),%edx
    90f2:	83 c2 30             	add    $0x30,%edx
    90f5:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    90fc:	00 
    90fd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9101:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9105:	75 e5                	jne    90ec <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    9107:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    910e:	eb 15                	jmp    9125 <LodePNGUnknownChunks_init+0x48>
    9110:	8b 45 08             	mov    0x8(%ebp),%eax
    9113:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9116:	83 c2 34             	add    $0x34,%edx
    9119:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    9120:	00 
    9121:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9125:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9129:	75 e5                	jne    9110 <LodePNGUnknownChunks_init+0x33>
}
    912b:	90                   	nop
    912c:	c9                   	leave  
    912d:	c3                   	ret    

0000912e <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    912e:	55                   	push   %ebp
    912f:	89 e5                	mov    %esp,%ebp
    9131:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    9134:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    913b:	eb 1d                	jmp    915a <LodePNGUnknownChunks_cleanup+0x2c>
    913d:	8b 45 08             	mov    0x8(%ebp),%eax
    9140:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9143:	83 c2 30             	add    $0x30,%edx
    9146:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    914a:	83 ec 0c             	sub    $0xc,%esp
    914d:	50                   	push   %eax
    914e:	e8 e4 a1 ff ff       	call   3337 <lodepng_free>
    9153:	83 c4 10             	add    $0x10,%esp
    9156:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    915a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    915e:	75 dd                	jne    913d <LodePNGUnknownChunks_cleanup+0xf>
}
    9160:	90                   	nop
    9161:	c9                   	leave  
    9162:	c3                   	ret    

00009163 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9163:	55                   	push   %ebp
    9164:	89 e5                	mov    %esp,%ebp
    9166:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9169:	83 ec 0c             	sub    $0xc,%esp
    916c:	ff 75 08             	pushl  0x8(%ebp)
    916f:	e8 ba ff ff ff       	call   912e <LodePNGUnknownChunks_cleanup>
    9174:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9177:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    917e:	e9 b7 00 00 00       	jmp    923a <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9183:	8b 45 0c             	mov    0xc(%ebp),%eax
    9186:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9189:	83 c2 34             	add    $0x34,%edx
    918c:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    9190:	8b 45 08             	mov    0x8(%ebp),%eax
    9193:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9196:	83 c1 34             	add    $0x34,%ecx
    9199:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    919d:	8b 45 0c             	mov    0xc(%ebp),%eax
    91a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91a3:	83 c2 34             	add    $0x34,%edx
    91a6:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91aa:	83 ec 0c             	sub    $0xc,%esp
    91ad:	50                   	push   %eax
    91ae:	e8 63 a1 ff ff       	call   3316 <lodepng_malloc>
    91b3:	83 c4 10             	add    $0x10,%esp
    91b6:	89 c1                	mov    %eax,%ecx
    91b8:	8b 45 08             	mov    0x8(%ebp),%eax
    91bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91be:	83 c2 30             	add    $0x30,%edx
    91c1:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    91c5:	8b 45 08             	mov    0x8(%ebp),%eax
    91c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91cb:	83 c2 30             	add    $0x30,%edx
    91ce:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    91d2:	85 c0                	test   %eax,%eax
    91d4:	75 18                	jne    91ee <LodePNGUnknownChunks_copy+0x8b>
    91d6:	8b 45 08             	mov    0x8(%ebp),%eax
    91d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91dc:	83 c2 34             	add    $0x34,%edx
    91df:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91e3:	85 c0                	test   %eax,%eax
    91e5:	74 07                	je     91ee <LodePNGUnknownChunks_copy+0x8b>
    91e7:	b8 53 00 00 00       	mov    $0x53,%eax
    91ec:	eb 5b                	jmp    9249 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    91ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    91f5:	eb 2d                	jmp    9224 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    91f7:	8b 45 08             	mov    0x8(%ebp),%eax
    91fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91fd:	83 c2 30             	add    $0x30,%edx
    9200:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    9204:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9207:	01 c2                	add    %eax,%edx
    9209:	8b 45 0c             	mov    0xc(%ebp),%eax
    920c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    920f:	83 c1 30             	add    $0x30,%ecx
    9212:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    9216:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9219:	01 c8                	add    %ecx,%eax
    921b:	0f b6 00             	movzbl (%eax),%eax
    921e:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9220:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9224:	8b 45 0c             	mov    0xc(%ebp),%eax
    9227:	8b 55 f4             	mov    -0xc(%ebp),%edx
    922a:	83 c2 34             	add    $0x34,%edx
    922d:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9231:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9234:	7f c1                	jg     91f7 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9236:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    923a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    923e:	0f 85 3f ff ff ff    	jne    9183 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9244:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9249:	c9                   	leave  
    924a:	c3                   	ret    

0000924b <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    924b:	55                   	push   %ebp
    924c:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    924e:	8b 45 08             	mov    0x8(%ebp),%eax
    9251:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9258:	8b 45 08             	mov    0x8(%ebp),%eax
    925b:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9262:	8b 45 08             	mov    0x8(%ebp),%eax
    9265:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    926c:	90                   	nop
    926d:	5d                   	pop    %ebp
    926e:	c3                   	ret    

0000926f <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    926f:	55                   	push   %ebp
    9270:	89 e5                	mov    %esp,%ebp
    9272:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9275:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    927c:	eb 38                	jmp    92b6 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    927e:	8b 45 08             	mov    0x8(%ebp),%eax
    9281:	8b 40 40             	mov    0x40(%eax),%eax
    9284:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9287:	c1 e2 02             	shl    $0x2,%edx
    928a:	01 d0                	add    %edx,%eax
    928c:	83 ec 0c             	sub    $0xc,%esp
    928f:	50                   	push   %eax
    9290:	e8 75 a3 ff ff       	call   360a <string_cleanup>
    9295:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9298:	8b 45 08             	mov    0x8(%ebp),%eax
    929b:	8b 40 44             	mov    0x44(%eax),%eax
    929e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92a1:	c1 e2 02             	shl    $0x2,%edx
    92a4:	01 d0                	add    %edx,%eax
    92a6:	83 ec 0c             	sub    $0xc,%esp
    92a9:	50                   	push   %eax
    92aa:	e8 5b a3 ff ff       	call   360a <string_cleanup>
    92af:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    92b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92b6:	8b 45 08             	mov    0x8(%ebp),%eax
    92b9:	8b 40 3c             	mov    0x3c(%eax),%eax
    92bc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    92bf:	75 bd                	jne    927e <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    92c1:	8b 45 08             	mov    0x8(%ebp),%eax
    92c4:	8b 40 40             	mov    0x40(%eax),%eax
    92c7:	83 ec 0c             	sub    $0xc,%esp
    92ca:	50                   	push   %eax
    92cb:	e8 67 a0 ff ff       	call   3337 <lodepng_free>
    92d0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    92d3:	8b 45 08             	mov    0x8(%ebp),%eax
    92d6:	8b 40 44             	mov    0x44(%eax),%eax
    92d9:	83 ec 0c             	sub    $0xc,%esp
    92dc:	50                   	push   %eax
    92dd:	e8 55 a0 ff ff       	call   3337 <lodepng_free>
    92e2:	83 c4 10             	add    $0x10,%esp
}
    92e5:	90                   	nop
    92e6:	c9                   	leave  
    92e7:	c3                   	ret    

000092e8 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    92e8:	55                   	push   %ebp
    92e9:	89 e5                	mov    %esp,%ebp
    92eb:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    92ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    92f5:	8b 45 08             	mov    0x8(%ebp),%eax
    92f8:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    92ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9302:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9309:	8b 45 08             	mov    0x8(%ebp),%eax
    930c:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    9313:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    931a:	eb 42                	jmp    935e <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    931c:	8b 45 0c             	mov    0xc(%ebp),%eax
    931f:	8b 40 44             	mov    0x44(%eax),%eax
    9322:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9325:	c1 e2 02             	shl    $0x2,%edx
    9328:	01 d0                	add    %edx,%eax
    932a:	8b 10                	mov    (%eax),%edx
    932c:	8b 45 0c             	mov    0xc(%ebp),%eax
    932f:	8b 40 40             	mov    0x40(%eax),%eax
    9332:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9335:	c1 e1 02             	shl    $0x2,%ecx
    9338:	01 c8                	add    %ecx,%eax
    933a:	8b 00                	mov    (%eax),%eax
    933c:	83 ec 04             	sub    $0x4,%esp
    933f:	52                   	push   %edx
    9340:	50                   	push   %eax
    9341:	ff 75 08             	pushl  0x8(%ebp)
    9344:	e8 4d 01 00 00       	call   9496 <lodepng_add_text>
    9349:	83 c4 10             	add    $0x10,%esp
    934c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    934f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9353:	74 05                	je     935a <LodePNGText_copy+0x72>
    9355:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9358:	eb 14                	jmp    936e <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    935a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    935e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9361:	8b 40 3c             	mov    0x3c(%eax),%eax
    9364:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9367:	75 b3                	jne    931c <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9369:	b8 00 00 00 00       	mov    $0x0,%eax
}
    936e:	c9                   	leave  
    936f:	c3                   	ret    

00009370 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    9370:	55                   	push   %ebp
    9371:	89 e5                	mov    %esp,%ebp
    9373:	53                   	push   %ebx
    9374:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9377:	8b 45 08             	mov    0x8(%ebp),%eax
    937a:	8b 40 3c             	mov    0x3c(%eax),%eax
    937d:	83 c0 01             	add    $0x1,%eax
    9380:	c1 e0 02             	shl    $0x2,%eax
    9383:	89 c2                	mov    %eax,%edx
    9385:	8b 45 08             	mov    0x8(%ebp),%eax
    9388:	8b 40 40             	mov    0x40(%eax),%eax
    938b:	52                   	push   %edx
    938c:	50                   	push   %eax
    938d:	e8 9b 9f ff ff       	call   332d <lodepng_realloc>
    9392:	83 c4 08             	add    $0x8,%esp
    9395:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9398:	8b 45 08             	mov    0x8(%ebp),%eax
    939b:	8b 40 3c             	mov    0x3c(%eax),%eax
    939e:	83 c0 01             	add    $0x1,%eax
    93a1:	c1 e0 02             	shl    $0x2,%eax
    93a4:	89 c2                	mov    %eax,%edx
    93a6:	8b 45 08             	mov    0x8(%ebp),%eax
    93a9:	8b 40 44             	mov    0x44(%eax),%eax
    93ac:	52                   	push   %edx
    93ad:	50                   	push   %eax
    93ae:	e8 7a 9f ff ff       	call   332d <lodepng_realloc>
    93b3:	83 c4 08             	add    $0x8,%esp
    93b6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    93b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93bd:	74 09                	je     93c8 <lodepng_add_text_sized+0x58>
    93bf:	8b 45 08             	mov    0x8(%ebp),%eax
    93c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93c5:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    93c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93cc:	74 09                	je     93d7 <lodepng_add_text_sized+0x67>
    93ce:	8b 45 08             	mov    0x8(%ebp),%eax
    93d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    93d4:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    93d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93db:	74 06                	je     93e3 <lodepng_add_text_sized+0x73>
    93dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93e1:	75 0a                	jne    93ed <lodepng_add_text_sized+0x7d>
    93e3:	b8 53 00 00 00       	mov    $0x53,%eax
    93e8:	e9 a4 00 00 00       	jmp    9491 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    93ed:	8b 45 08             	mov    0x8(%ebp),%eax
    93f0:	8b 40 3c             	mov    0x3c(%eax),%eax
    93f3:	8d 50 01             	lea    0x1(%eax),%edx
    93f6:	8b 45 08             	mov    0x8(%ebp),%eax
    93f9:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    93fc:	8b 45 08             	mov    0x8(%ebp),%eax
    93ff:	8b 50 40             	mov    0x40(%eax),%edx
    9402:	8b 45 08             	mov    0x8(%ebp),%eax
    9405:	8b 40 3c             	mov    0x3c(%eax),%eax
    9408:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    940d:	c1 e0 02             	shl    $0x2,%eax
    9410:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9413:	83 ec 0c             	sub    $0xc,%esp
    9416:	ff 75 0c             	pushl  0xc(%ebp)
    9419:	e8 54 a2 ff ff       	call   3672 <alloc_string>
    941e:	83 c4 10             	add    $0x10,%esp
    9421:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    9423:	8b 45 08             	mov    0x8(%ebp),%eax
    9426:	8b 50 44             	mov    0x44(%eax),%edx
    9429:	8b 45 08             	mov    0x8(%ebp),%eax
    942c:	8b 40 3c             	mov    0x3c(%eax),%eax
    942f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9434:	c1 e0 02             	shl    $0x2,%eax
    9437:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    943a:	83 ec 08             	sub    $0x8,%esp
    943d:	ff 75 14             	pushl  0x14(%ebp)
    9440:	ff 75 10             	pushl  0x10(%ebp)
    9443:	e8 e5 a1 ff ff       	call   362d <alloc_string_sized>
    9448:	83 c4 10             	add    $0x10,%esp
    944b:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    944d:	8b 45 08             	mov    0x8(%ebp),%eax
    9450:	8b 50 40             	mov    0x40(%eax),%edx
    9453:	8b 45 08             	mov    0x8(%ebp),%eax
    9456:	8b 40 3c             	mov    0x3c(%eax),%eax
    9459:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    945e:	c1 e0 02             	shl    $0x2,%eax
    9461:	01 d0                	add    %edx,%eax
    9463:	8b 00                	mov    (%eax),%eax
    9465:	85 c0                	test   %eax,%eax
    9467:	74 1c                	je     9485 <lodepng_add_text_sized+0x115>
    9469:	8b 45 08             	mov    0x8(%ebp),%eax
    946c:	8b 50 44             	mov    0x44(%eax),%edx
    946f:	8b 45 08             	mov    0x8(%ebp),%eax
    9472:	8b 40 3c             	mov    0x3c(%eax),%eax
    9475:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    947a:	c1 e0 02             	shl    $0x2,%eax
    947d:	01 d0                	add    %edx,%eax
    947f:	8b 00                	mov    (%eax),%eax
    9481:	85 c0                	test   %eax,%eax
    9483:	75 07                	jne    948c <lodepng_add_text_sized+0x11c>
    9485:	b8 53 00 00 00       	mov    $0x53,%eax
    948a:	eb 05                	jmp    9491 <lodepng_add_text_sized+0x121>

  return 0;
    948c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9491:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9494:	c9                   	leave  
    9495:	c3                   	ret    

00009496 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9496:	55                   	push   %ebp
    9497:	89 e5                	mov    %esp,%ebp
    9499:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    949c:	ff 75 10             	pushl  0x10(%ebp)
    949f:	e8 0e 9f ff ff       	call   33b2 <lodepng_strlen>
    94a4:	83 c4 04             	add    $0x4,%esp
    94a7:	50                   	push   %eax
    94a8:	ff 75 10             	pushl  0x10(%ebp)
    94ab:	ff 75 0c             	pushl  0xc(%ebp)
    94ae:	ff 75 08             	pushl  0x8(%ebp)
    94b1:	e8 ba fe ff ff       	call   9370 <lodepng_add_text_sized>
    94b6:	83 c4 10             	add    $0x10,%esp
}
    94b9:	c9                   	leave  
    94ba:	c3                   	ret    

000094bb <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    94bb:	55                   	push   %ebp
    94bc:	89 e5                	mov    %esp,%ebp
    94be:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    94c1:	83 ec 0c             	sub    $0xc,%esp
    94c4:	ff 75 08             	pushl  0x8(%ebp)
    94c7:	e8 a3 fd ff ff       	call   926f <LodePNGText_cleanup>
    94cc:	83 c4 10             	add    $0x10,%esp
}
    94cf:	90                   	nop
    94d0:	c9                   	leave  
    94d1:	c3                   	ret    

000094d2 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    94d2:	55                   	push   %ebp
    94d3:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    94d5:	8b 45 08             	mov    0x8(%ebp),%eax
    94d8:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    94df:	8b 45 08             	mov    0x8(%ebp),%eax
    94e2:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    94e9:	8b 45 08             	mov    0x8(%ebp),%eax
    94ec:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    94f3:	8b 45 08             	mov    0x8(%ebp),%eax
    94f6:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    94fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9500:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    9507:	90                   	nop
    9508:	5d                   	pop    %ebp
    9509:	c3                   	ret    

0000950a <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    950a:	55                   	push   %ebp
    950b:	89 e5                	mov    %esp,%ebp
    950d:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9510:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9517:	eb 6c                	jmp    9585 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9519:	8b 45 08             	mov    0x8(%ebp),%eax
    951c:	8b 40 4c             	mov    0x4c(%eax),%eax
    951f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9522:	c1 e2 02             	shl    $0x2,%edx
    9525:	01 d0                	add    %edx,%eax
    9527:	83 ec 0c             	sub    $0xc,%esp
    952a:	50                   	push   %eax
    952b:	e8 da a0 ff ff       	call   360a <string_cleanup>
    9530:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9533:	8b 45 08             	mov    0x8(%ebp),%eax
    9536:	8b 40 50             	mov    0x50(%eax),%eax
    9539:	8b 55 f4             	mov    -0xc(%ebp),%edx
    953c:	c1 e2 02             	shl    $0x2,%edx
    953f:	01 d0                	add    %edx,%eax
    9541:	83 ec 0c             	sub    $0xc,%esp
    9544:	50                   	push   %eax
    9545:	e8 c0 a0 ff ff       	call   360a <string_cleanup>
    954a:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    954d:	8b 45 08             	mov    0x8(%ebp),%eax
    9550:	8b 40 54             	mov    0x54(%eax),%eax
    9553:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9556:	c1 e2 02             	shl    $0x2,%edx
    9559:	01 d0                	add    %edx,%eax
    955b:	83 ec 0c             	sub    $0xc,%esp
    955e:	50                   	push   %eax
    955f:	e8 a6 a0 ff ff       	call   360a <string_cleanup>
    9564:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9567:	8b 45 08             	mov    0x8(%ebp),%eax
    956a:	8b 40 58             	mov    0x58(%eax),%eax
    956d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9570:	c1 e2 02             	shl    $0x2,%edx
    9573:	01 d0                	add    %edx,%eax
    9575:	83 ec 0c             	sub    $0xc,%esp
    9578:	50                   	push   %eax
    9579:	e8 8c a0 ff ff       	call   360a <string_cleanup>
    957e:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9581:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9585:	8b 45 08             	mov    0x8(%ebp),%eax
    9588:	8b 40 48             	mov    0x48(%eax),%eax
    958b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    958e:	75 89                	jne    9519 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    9590:	8b 45 08             	mov    0x8(%ebp),%eax
    9593:	8b 40 4c             	mov    0x4c(%eax),%eax
    9596:	83 ec 0c             	sub    $0xc,%esp
    9599:	50                   	push   %eax
    959a:	e8 98 9d ff ff       	call   3337 <lodepng_free>
    959f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    95a2:	8b 45 08             	mov    0x8(%ebp),%eax
    95a5:	8b 40 50             	mov    0x50(%eax),%eax
    95a8:	83 ec 0c             	sub    $0xc,%esp
    95ab:	50                   	push   %eax
    95ac:	e8 86 9d ff ff       	call   3337 <lodepng_free>
    95b1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    95b4:	8b 45 08             	mov    0x8(%ebp),%eax
    95b7:	8b 40 54             	mov    0x54(%eax),%eax
    95ba:	83 ec 0c             	sub    $0xc,%esp
    95bd:	50                   	push   %eax
    95be:	e8 74 9d ff ff       	call   3337 <lodepng_free>
    95c3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    95c6:	8b 45 08             	mov    0x8(%ebp),%eax
    95c9:	8b 40 58             	mov    0x58(%eax),%eax
    95cc:	83 ec 0c             	sub    $0xc,%esp
    95cf:	50                   	push   %eax
    95d0:	e8 62 9d ff ff       	call   3337 <lodepng_free>
    95d5:	83 c4 10             	add    $0x10,%esp
}
    95d8:	90                   	nop
    95d9:	c9                   	leave  
    95da:	c3                   	ret    

000095db <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    95db:	55                   	push   %ebp
    95dc:	89 e5                	mov    %esp,%ebp
    95de:	56                   	push   %esi
    95df:	53                   	push   %ebx
    95e0:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    95e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    95ea:	8b 45 08             	mov    0x8(%ebp),%eax
    95ed:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    95f4:	8b 45 08             	mov    0x8(%ebp),%eax
    95f7:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    95fe:	8b 45 08             	mov    0x8(%ebp),%eax
    9601:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    9608:	8b 45 08             	mov    0x8(%ebp),%eax
    960b:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    9612:	8b 45 08             	mov    0x8(%ebp),%eax
    9615:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    961c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9623:	eb 64                	jmp    9689 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9625:	8b 45 0c             	mov    0xc(%ebp),%eax
    9628:	8b 40 58             	mov    0x58(%eax),%eax
    962b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    962e:	c1 e2 02             	shl    $0x2,%edx
    9631:	01 d0                	add    %edx,%eax
    9633:	8b 18                	mov    (%eax),%ebx
    9635:	8b 45 0c             	mov    0xc(%ebp),%eax
    9638:	8b 40 54             	mov    0x54(%eax),%eax
    963b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    963e:	c1 e2 02             	shl    $0x2,%edx
    9641:	01 d0                	add    %edx,%eax
    9643:	8b 08                	mov    (%eax),%ecx
    9645:	8b 45 0c             	mov    0xc(%ebp),%eax
    9648:	8b 40 50             	mov    0x50(%eax),%eax
    964b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    964e:	c1 e2 02             	shl    $0x2,%edx
    9651:	01 d0                	add    %edx,%eax
    9653:	8b 10                	mov    (%eax),%edx
    9655:	8b 45 0c             	mov    0xc(%ebp),%eax
    9658:	8b 40 4c             	mov    0x4c(%eax),%eax
    965b:	8b 75 f4             	mov    -0xc(%ebp),%esi
    965e:	c1 e6 02             	shl    $0x2,%esi
    9661:	01 f0                	add    %esi,%eax
    9663:	8b 00                	mov    (%eax),%eax
    9665:	83 ec 0c             	sub    $0xc,%esp
    9668:	53                   	push   %ebx
    9669:	51                   	push   %ecx
    966a:	52                   	push   %edx
    966b:	50                   	push   %eax
    966c:	ff 75 08             	pushl  0x8(%ebp)
    966f:	e8 e4 01 00 00       	call   9858 <lodepng_add_itext>
    9674:	83 c4 20             	add    $0x20,%esp
    9677:	89 45 f0             	mov    %eax,-0x10(%ebp)
    967a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    967e:	74 05                	je     9685 <LodePNGIText_copy+0xaa>
    9680:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9683:	eb 14                	jmp    9699 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9685:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9689:	8b 45 0c             	mov    0xc(%ebp),%eax
    968c:	8b 40 48             	mov    0x48(%eax),%eax
    968f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9692:	75 91                	jne    9625 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9694:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9699:	8d 65 f8             	lea    -0x8(%ebp),%esp
    969c:	5b                   	pop    %ebx
    969d:	5e                   	pop    %esi
    969e:	5d                   	pop    %ebp
    969f:	c3                   	ret    

000096a0 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    96a0:	55                   	push   %ebp
    96a1:	89 e5                	mov    %esp,%ebp
    96a3:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    96a6:	83 ec 0c             	sub    $0xc,%esp
    96a9:	ff 75 08             	pushl  0x8(%ebp)
    96ac:	e8 59 fe ff ff       	call   950a <LodePNGIText_cleanup>
    96b1:	83 c4 10             	add    $0x10,%esp
}
    96b4:	90                   	nop
    96b5:	c9                   	leave  
    96b6:	c3                   	ret    

000096b7 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    96b7:	55                   	push   %ebp
    96b8:	89 e5                	mov    %esp,%ebp
    96ba:	53                   	push   %ebx
    96bb:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    96be:	8b 45 08             	mov    0x8(%ebp),%eax
    96c1:	8b 40 48             	mov    0x48(%eax),%eax
    96c4:	83 c0 01             	add    $0x1,%eax
    96c7:	c1 e0 02             	shl    $0x2,%eax
    96ca:	89 c2                	mov    %eax,%edx
    96cc:	8b 45 08             	mov    0x8(%ebp),%eax
    96cf:	8b 40 4c             	mov    0x4c(%eax),%eax
    96d2:	52                   	push   %edx
    96d3:	50                   	push   %eax
    96d4:	e8 54 9c ff ff       	call   332d <lodepng_realloc>
    96d9:	83 c4 08             	add    $0x8,%esp
    96dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    96df:	8b 45 08             	mov    0x8(%ebp),%eax
    96e2:	8b 40 48             	mov    0x48(%eax),%eax
    96e5:	83 c0 01             	add    $0x1,%eax
    96e8:	c1 e0 02             	shl    $0x2,%eax
    96eb:	89 c2                	mov    %eax,%edx
    96ed:	8b 45 08             	mov    0x8(%ebp),%eax
    96f0:	8b 40 50             	mov    0x50(%eax),%eax
    96f3:	52                   	push   %edx
    96f4:	50                   	push   %eax
    96f5:	e8 33 9c ff ff       	call   332d <lodepng_realloc>
    96fa:	83 c4 08             	add    $0x8,%esp
    96fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    9700:	8b 45 08             	mov    0x8(%ebp),%eax
    9703:	8b 40 48             	mov    0x48(%eax),%eax
    9706:	83 c0 01             	add    $0x1,%eax
    9709:	c1 e0 02             	shl    $0x2,%eax
    970c:	89 c2                	mov    %eax,%edx
    970e:	8b 45 08             	mov    0x8(%ebp),%eax
    9711:	8b 40 54             	mov    0x54(%eax),%eax
    9714:	52                   	push   %edx
    9715:	50                   	push   %eax
    9716:	e8 12 9c ff ff       	call   332d <lodepng_realloc>
    971b:	83 c4 08             	add    $0x8,%esp
    971e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    9721:	8b 45 08             	mov    0x8(%ebp),%eax
    9724:	8b 40 48             	mov    0x48(%eax),%eax
    9727:	83 c0 01             	add    $0x1,%eax
    972a:	c1 e0 02             	shl    $0x2,%eax
    972d:	89 c2                	mov    %eax,%edx
    972f:	8b 45 08             	mov    0x8(%ebp),%eax
    9732:	8b 40 58             	mov    0x58(%eax),%eax
    9735:	52                   	push   %edx
    9736:	50                   	push   %eax
    9737:	e8 f1 9b ff ff       	call   332d <lodepng_realloc>
    973c:	83 c4 08             	add    $0x8,%esp
    973f:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9742:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9746:	74 09                	je     9751 <lodepng_add_itext_sized+0x9a>
    9748:	8b 45 08             	mov    0x8(%ebp),%eax
    974b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    974e:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9751:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9755:	74 09                	je     9760 <lodepng_add_itext_sized+0xa9>
    9757:	8b 45 08             	mov    0x8(%ebp),%eax
    975a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    975d:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    9760:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9764:	74 09                	je     976f <lodepng_add_itext_sized+0xb8>
    9766:	8b 45 08             	mov    0x8(%ebp),%eax
    9769:	8b 55 ec             	mov    -0x14(%ebp),%edx
    976c:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    976f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9773:	74 09                	je     977e <lodepng_add_itext_sized+0xc7>
    9775:	8b 45 08             	mov    0x8(%ebp),%eax
    9778:	8b 55 e8             	mov    -0x18(%ebp),%edx
    977b:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    977e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9782:	74 12                	je     9796 <lodepng_add_itext_sized+0xdf>
    9784:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9788:	74 0c                	je     9796 <lodepng_add_itext_sized+0xdf>
    978a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    978e:	74 06                	je     9796 <lodepng_add_itext_sized+0xdf>
    9790:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9794:	75 0a                	jne    97a0 <lodepng_add_itext_sized+0xe9>
    9796:	b8 53 00 00 00       	mov    $0x53,%eax
    979b:	e9 b3 00 00 00       	jmp    9853 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    97a0:	8b 45 08             	mov    0x8(%ebp),%eax
    97a3:	8b 40 48             	mov    0x48(%eax),%eax
    97a6:	8d 50 01             	lea    0x1(%eax),%edx
    97a9:	8b 45 08             	mov    0x8(%ebp),%eax
    97ac:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    97af:	8b 45 08             	mov    0x8(%ebp),%eax
    97b2:	8b 50 4c             	mov    0x4c(%eax),%edx
    97b5:	8b 45 08             	mov    0x8(%ebp),%eax
    97b8:	8b 40 48             	mov    0x48(%eax),%eax
    97bb:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97c0:	c1 e0 02             	shl    $0x2,%eax
    97c3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97c6:	83 ec 0c             	sub    $0xc,%esp
    97c9:	ff 75 0c             	pushl  0xc(%ebp)
    97cc:	e8 a1 9e ff ff       	call   3672 <alloc_string>
    97d1:	83 c4 10             	add    $0x10,%esp
    97d4:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    97d6:	8b 45 08             	mov    0x8(%ebp),%eax
    97d9:	8b 50 50             	mov    0x50(%eax),%edx
    97dc:	8b 45 08             	mov    0x8(%ebp),%eax
    97df:	8b 40 48             	mov    0x48(%eax),%eax
    97e2:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97e7:	c1 e0 02             	shl    $0x2,%eax
    97ea:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97ed:	83 ec 0c             	sub    $0xc,%esp
    97f0:	ff 75 10             	pushl  0x10(%ebp)
    97f3:	e8 7a 9e ff ff       	call   3672 <alloc_string>
    97f8:	83 c4 10             	add    $0x10,%esp
    97fb:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    97fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9800:	8b 50 54             	mov    0x54(%eax),%edx
    9803:	8b 45 08             	mov    0x8(%ebp),%eax
    9806:	8b 40 48             	mov    0x48(%eax),%eax
    9809:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    980e:	c1 e0 02             	shl    $0x2,%eax
    9811:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9814:	83 ec 0c             	sub    $0xc,%esp
    9817:	ff 75 14             	pushl  0x14(%ebp)
    981a:	e8 53 9e ff ff       	call   3672 <alloc_string>
    981f:	83 c4 10             	add    $0x10,%esp
    9822:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9824:	8b 45 08             	mov    0x8(%ebp),%eax
    9827:	8b 50 58             	mov    0x58(%eax),%edx
    982a:	8b 45 08             	mov    0x8(%ebp),%eax
    982d:	8b 40 48             	mov    0x48(%eax),%eax
    9830:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9835:	c1 e0 02             	shl    $0x2,%eax
    9838:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    983b:	83 ec 08             	sub    $0x8,%esp
    983e:	ff 75 1c             	pushl  0x1c(%ebp)
    9841:	ff 75 18             	pushl  0x18(%ebp)
    9844:	e8 e4 9d ff ff       	call   362d <alloc_string_sized>
    9849:	83 c4 10             	add    $0x10,%esp
    984c:	89 03                	mov    %eax,(%ebx)

  return 0;
    984e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9853:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9856:	c9                   	leave  
    9857:	c3                   	ret    

00009858 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9858:	55                   	push   %ebp
    9859:	89 e5                	mov    %esp,%ebp
    985b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    985e:	ff 75 18             	pushl  0x18(%ebp)
    9861:	e8 4c 9b ff ff       	call   33b2 <lodepng_strlen>
    9866:	83 c4 04             	add    $0x4,%esp
    9869:	83 ec 08             	sub    $0x8,%esp
    986c:	50                   	push   %eax
    986d:	ff 75 18             	pushl  0x18(%ebp)
    9870:	ff 75 14             	pushl  0x14(%ebp)
    9873:	ff 75 10             	pushl  0x10(%ebp)
    9876:	ff 75 0c             	pushl  0xc(%ebp)
    9879:	ff 75 08             	pushl  0x8(%ebp)
    987c:	e8 36 fe ff ff       	call   96b7 <lodepng_add_itext_sized>
    9881:	83 c4 20             	add    $0x20,%esp
}
    9884:	c9                   	leave  
    9885:	c3                   	ret    

00009886 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9886:	55                   	push   %ebp
    9887:	89 e5                	mov    %esp,%ebp
    9889:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    988c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    9890:	75 0a                	jne    989c <lodepng_assign_icc+0x16>
    9892:	b8 64 00 00 00       	mov    $0x64,%eax
    9897:	e9 81 00 00 00       	jmp    991d <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    989c:	83 ec 0c             	sub    $0xc,%esp
    989f:	ff 75 0c             	pushl  0xc(%ebp)
    98a2:	e8 cb 9d ff ff       	call   3672 <alloc_string>
    98a7:	83 c4 10             	add    $0x10,%esp
    98aa:	89 c2                	mov    %eax,%edx
    98ac:	8b 45 08             	mov    0x8(%ebp),%eax
    98af:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    98b5:	8b 45 14             	mov    0x14(%ebp),%eax
    98b8:	83 ec 0c             	sub    $0xc,%esp
    98bb:	50                   	push   %eax
    98bc:	e8 55 9a ff ff       	call   3316 <lodepng_malloc>
    98c1:	83 c4 10             	add    $0x10,%esp
    98c4:	89 c2                	mov    %eax,%edx
    98c6:	8b 45 08             	mov    0x8(%ebp),%eax
    98c9:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    98cf:	8b 45 08             	mov    0x8(%ebp),%eax
    98d2:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    98d8:	85 c0                	test   %eax,%eax
    98da:	74 0d                	je     98e9 <lodepng_assign_icc+0x63>
    98dc:	8b 45 08             	mov    0x8(%ebp),%eax
    98df:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    98e5:	85 c0                	test   %eax,%eax
    98e7:	75 07                	jne    98f0 <lodepng_assign_icc+0x6a>
    98e9:	b8 53 00 00 00       	mov    $0x53,%eax
    98ee:	eb 2d                	jmp    991d <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    98f0:	8b 55 14             	mov    0x14(%ebp),%edx
    98f3:	8b 45 08             	mov    0x8(%ebp),%eax
    98f6:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    98fc:	83 ec 04             	sub    $0x4,%esp
    98ff:	52                   	push   %edx
    9900:	ff 75 10             	pushl  0x10(%ebp)
    9903:	50                   	push   %eax
    9904:	e8 4b 9a ff ff       	call   3354 <lodepng_memcpy>
    9909:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    990c:	8b 45 08             	mov    0x8(%ebp),%eax
    990f:	8b 55 14             	mov    0x14(%ebp),%edx
    9912:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9918:	b8 00 00 00 00       	mov    $0x0,%eax
}
    991d:	c9                   	leave  
    991e:	c3                   	ret    

0000991f <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    991f:	55                   	push   %ebp
    9920:	89 e5                	mov    %esp,%ebp
    9922:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9925:	8b 45 08             	mov    0x8(%ebp),%eax
    9928:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    992e:	85 c0                	test   %eax,%eax
    9930:	74 0e                	je     9940 <lodepng_set_icc+0x21>
    9932:	83 ec 0c             	sub    $0xc,%esp
    9935:	ff 75 08             	pushl  0x8(%ebp)
    9938:	e8 26 00 00 00       	call   9963 <lodepng_clear_icc>
    993d:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9940:	8b 45 08             	mov    0x8(%ebp),%eax
    9943:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    994a:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    994d:	ff 75 14             	pushl  0x14(%ebp)
    9950:	ff 75 10             	pushl  0x10(%ebp)
    9953:	ff 75 0c             	pushl  0xc(%ebp)
    9956:	ff 75 08             	pushl  0x8(%ebp)
    9959:	e8 28 ff ff ff       	call   9886 <lodepng_assign_icc>
    995e:	83 c4 10             	add    $0x10,%esp
}
    9961:	c9                   	leave  
    9962:	c3                   	ret    

00009963 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9963:	55                   	push   %ebp
    9964:	89 e5                	mov    %esp,%ebp
    9966:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9969:	8b 45 08             	mov    0x8(%ebp),%eax
    996c:	05 c0 00 00 00       	add    $0xc0,%eax
    9971:	83 ec 0c             	sub    $0xc,%esp
    9974:	50                   	push   %eax
    9975:	e8 90 9c ff ff       	call   360a <string_cleanup>
    997a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    997d:	8b 45 08             	mov    0x8(%ebp),%eax
    9980:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9986:	83 ec 0c             	sub    $0xc,%esp
    9989:	50                   	push   %eax
    998a:	e8 a8 99 ff ff       	call   3337 <lodepng_free>
    998f:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9992:	8b 45 08             	mov    0x8(%ebp),%eax
    9995:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    999c:	00 00 00 
  info->iccp_profile_size = 0;
    999f:	8b 45 08             	mov    0x8(%ebp),%eax
    99a2:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    99a9:	00 00 00 
  info->iccp_defined = 0;
    99ac:	8b 45 08             	mov    0x8(%ebp),%eax
    99af:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    99b6:	00 00 00 
}
    99b9:	90                   	nop
    99ba:	c9                   	leave  
    99bb:	c3                   	ret    

000099bc <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    99bc:	55                   	push   %ebp
    99bd:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    99bf:	8b 45 08             	mov    0x8(%ebp),%eax
    99c2:	83 c0 0c             	add    $0xc,%eax
    99c5:	50                   	push   %eax
    99c6:	e8 5a f0 ff ff       	call   8a25 <lodepng_color_mode_init>
    99cb:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    99ce:	8b 45 08             	mov    0x8(%ebp),%eax
    99d1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    99d8:	8b 45 08             	mov    0x8(%ebp),%eax
    99db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    99e1:	8b 45 08             	mov    0x8(%ebp),%eax
    99e4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    99eb:	8b 45 08             	mov    0x8(%ebp),%eax
    99ee:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    99f5:	8b 45 08             	mov    0x8(%ebp),%eax
    99f8:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    99ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9a02:	8b 50 38             	mov    0x38(%eax),%edx
    9a05:	8b 45 08             	mov    0x8(%ebp),%eax
    9a08:	89 50 34             	mov    %edx,0x34(%eax)
    9a0b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a0e:	8b 50 34             	mov    0x34(%eax),%edx
    9a11:	8b 45 08             	mov    0x8(%ebp),%eax
    9a14:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9a17:	ff 75 08             	pushl  0x8(%ebp)
    9a1a:	e8 2c f8 ff ff       	call   924b <LodePNGText_init>
    9a1f:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9a22:	ff 75 08             	pushl  0x8(%ebp)
    9a25:	e8 a8 fa ff ff       	call   94d2 <LodePNGIText_init>
    9a2a:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9a2d:	8b 45 08             	mov    0x8(%ebp),%eax
    9a30:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9a37:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3a:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9a41:	8b 45 08             	mov    0x8(%ebp),%eax
    9a44:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9a4b:	00 00 00 
  info->chrm_defined = 0;
    9a4e:	8b 45 08             	mov    0x8(%ebp),%eax
    9a51:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9a58:	00 00 00 
  info->srgb_defined = 0;
    9a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a5e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9a65:	00 00 00 
  info->iccp_defined = 0;
    9a68:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6b:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9a72:	00 00 00 
  info->iccp_name = NULL;
    9a75:	8b 45 08             	mov    0x8(%ebp),%eax
    9a78:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9a7f:	00 00 00 
  info->iccp_profile = NULL;
    9a82:	8b 45 08             	mov    0x8(%ebp),%eax
    9a85:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9a8c:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9a8f:	ff 75 08             	pushl  0x8(%ebp)
    9a92:	e8 46 f6 ff ff       	call   90dd <LodePNGUnknownChunks_init>
    9a97:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9a9a:	90                   	nop
    9a9b:	c9                   	leave  
    9a9c:	c3                   	ret    

00009a9d <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9a9d:	55                   	push   %ebp
    9a9e:	89 e5                	mov    %esp,%ebp
    9aa0:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9aa3:	8b 45 08             	mov    0x8(%ebp),%eax
    9aa6:	83 c0 0c             	add    $0xc,%eax
    9aa9:	83 ec 0c             	sub    $0xc,%esp
    9aac:	50                   	push   %eax
    9aad:	e8 66 f0 ff ff       	call   8b18 <lodepng_color_mode_cleanup>
    9ab2:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9ab5:	83 ec 0c             	sub    $0xc,%esp
    9ab8:	ff 75 08             	pushl  0x8(%ebp)
    9abb:	e8 af f7 ff ff       	call   926f <LodePNGText_cleanup>
    9ac0:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9ac3:	83 ec 0c             	sub    $0xc,%esp
    9ac6:	ff 75 08             	pushl  0x8(%ebp)
    9ac9:	e8 3c fa ff ff       	call   950a <LodePNGIText_cleanup>
    9ace:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9ad1:	83 ec 0c             	sub    $0xc,%esp
    9ad4:	ff 75 08             	pushl  0x8(%ebp)
    9ad7:	e8 87 fe ff ff       	call   9963 <lodepng_clear_icc>
    9adc:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9adf:	83 ec 0c             	sub    $0xc,%esp
    9ae2:	ff 75 08             	pushl  0x8(%ebp)
    9ae5:	e8 44 f6 ff ff       	call   912e <LodePNGUnknownChunks_cleanup>
    9aea:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9aed:	90                   	nop
    9aee:	c9                   	leave  
    9aef:	c3                   	ret    

00009af0 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9af0:	55                   	push   %ebp
    9af1:	89 e5                	mov    %esp,%ebp
    9af3:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9af6:	83 ec 0c             	sub    $0xc,%esp
    9af9:	ff 75 08             	pushl  0x8(%ebp)
    9afc:	e8 9c ff ff ff       	call   9a9d <lodepng_info_cleanup>
    9b01:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9b04:	83 ec 04             	sub    $0x4,%esp
    9b07:	68 e4 00 00 00       	push   $0xe4
    9b0c:	ff 75 0c             	pushl  0xc(%ebp)
    9b0f:	ff 75 08             	pushl  0x8(%ebp)
    9b12:	e8 3d 98 ff ff       	call   3354 <lodepng_memcpy>
    9b17:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9b1d:	83 c0 0c             	add    $0xc,%eax
    9b20:	83 ec 0c             	sub    $0xc,%esp
    9b23:	50                   	push   %eax
    9b24:	e8 fc ee ff ff       	call   8a25 <lodepng_color_mode_init>
    9b29:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9b2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b2f:	8d 50 0c             	lea    0xc(%eax),%edx
    9b32:	8b 45 08             	mov    0x8(%ebp),%eax
    9b35:	83 c0 0c             	add    $0xc,%eax
    9b38:	83 ec 08             	sub    $0x8,%esp
    9b3b:	52                   	push   %edx
    9b3c:	50                   	push   %eax
    9b3d:	e8 ed ef ff ff       	call   8b2f <lodepng_color_mode_copy>
    9b42:	83 c4 10             	add    $0x10,%esp
    9b45:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9b48:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b4c:	74 08                	je     9b56 <lodepng_info_copy+0x66>
    9b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9b51:	e9 b7 00 00 00       	jmp    9c0d <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9b56:	83 ec 08             	sub    $0x8,%esp
    9b59:	ff 75 0c             	pushl  0xc(%ebp)
    9b5c:	ff 75 08             	pushl  0x8(%ebp)
    9b5f:	e8 84 f7 ff ff       	call   92e8 <LodePNGText_copy>
    9b64:	83 c4 10             	add    $0x10,%esp
    9b67:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9b6a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b6e:	74 08                	je     9b78 <lodepng_info_copy+0x88>
    9b70:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b73:	e9 95 00 00 00       	jmp    9c0d <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9b78:	83 ec 08             	sub    $0x8,%esp
    9b7b:	ff 75 0c             	pushl  0xc(%ebp)
    9b7e:	ff 75 08             	pushl  0x8(%ebp)
    9b81:	e8 55 fa ff ff       	call   95db <LodePNGIText_copy>
    9b86:	83 c4 10             	add    $0x10,%esp
    9b89:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9b8c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9b90:	74 05                	je     9b97 <lodepng_info_copy+0xa7>
    9b92:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9b95:	eb 76                	jmp    9c0d <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9b97:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b9a:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9ba0:	85 c0                	test   %eax,%eax
    9ba2:	74 37                	je     9bdb <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9ba4:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ba7:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9bad:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bb0:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9bb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bb9:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9bbf:	51                   	push   %ecx
    9bc0:	52                   	push   %edx
    9bc1:	50                   	push   %eax
    9bc2:	ff 75 08             	pushl  0x8(%ebp)
    9bc5:	e8 bc fc ff ff       	call   9886 <lodepng_assign_icc>
    9bca:	83 c4 10             	add    $0x10,%esp
    9bcd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9bd0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9bd4:	74 05                	je     9bdb <lodepng_info_copy+0xeb>
    9bd6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9bd9:	eb 32                	jmp    9c0d <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9bdb:	83 ec 0c             	sub    $0xc,%esp
    9bde:	ff 75 08             	pushl  0x8(%ebp)
    9be1:	e8 f7 f4 ff ff       	call   90dd <LodePNGUnknownChunks_init>
    9be6:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9be9:	83 ec 08             	sub    $0x8,%esp
    9bec:	ff 75 0c             	pushl  0xc(%ebp)
    9bef:	ff 75 08             	pushl  0x8(%ebp)
    9bf2:	e8 6c f5 ff ff       	call   9163 <LodePNGUnknownChunks_copy>
    9bf7:	83 c4 10             	add    $0x10,%esp
    9bfa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9bfd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9c01:	74 05                	je     9c08 <lodepng_info_copy+0x118>
    9c03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9c06:	eb 05                	jmp    9c0d <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9c08:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9c0d:	c9                   	leave  
    9c0e:	c3                   	ret    

00009c0f <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9c0f:	55                   	push   %ebp
    9c10:	89 e5                	mov    %esp,%ebp
    9c12:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9c15:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9c19:	74 14                	je     9c2f <addColorBits+0x20>
    9c1b:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9c1f:	75 07                	jne    9c28 <addColorBits+0x19>
    9c21:	b8 03 00 00 00       	mov    $0x3,%eax
    9c26:	eb 0c                	jmp    9c34 <addColorBits+0x25>
    9c28:	b8 01 00 00 00       	mov    $0x1,%eax
    9c2d:	eb 05                	jmp    9c34 <addColorBits+0x25>
    9c2f:	b8 07 00 00 00       	mov    $0x7,%eax
    9c34:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9c37:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c3a:	23 45 fc             	and    -0x4(%ebp),%eax
    9c3d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9c40:	8b 45 10             	mov    0x10(%ebp),%eax
    9c43:	ba 01 00 00 00       	mov    $0x1,%edx
    9c48:	89 c1                	mov    %eax,%ecx
    9c4a:	d3 e2                	shl    %cl,%edx
    9c4c:	89 d0                	mov    %edx,%eax
    9c4e:	83 e8 01             	sub    $0x1,%eax
    9c51:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9c54:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9c57:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9c5a:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c5e:	89 c1                	mov    %eax,%ecx
    9c60:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9c63:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9c67:	75 18                	jne    9c81 <addColorBits+0x72>
    9c69:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c6c:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c70:	c1 e8 03             	shr    $0x3,%eax
    9c73:	89 c2                	mov    %eax,%edx
    9c75:	8b 45 08             	mov    0x8(%ebp),%eax
    9c78:	01 d0                	add    %edx,%eax
    9c7a:	8b 55 14             	mov    0x14(%ebp),%edx
    9c7d:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9c7f:	eb 1e                	jmp    9c9f <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9c81:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c84:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c88:	c1 e8 03             	shr    $0x3,%eax
    9c8b:	8b 55 08             	mov    0x8(%ebp),%edx
    9c8e:	01 c2                	add    %eax,%edx
    9c90:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9c93:	01 c8                	add    %ecx,%eax
    9c95:	0f b6 08             	movzbl (%eax),%ecx
    9c98:	8b 45 14             	mov    0x14(%ebp),%eax
    9c9b:	09 c8                	or     %ecx,%eax
    9c9d:	88 02                	mov    %al,(%edx)
}
    9c9f:	90                   	nop
    9ca0:	c9                   	leave  
    9ca1:	c3                   	ret    

00009ca2 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9ca2:	55                   	push   %ebp
    9ca3:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9ca5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca8:	6a 40                	push   $0x40
    9caa:	6a 00                	push   $0x0
    9cac:	50                   	push   %eax
    9cad:	e8 d5 96 ff ff       	call   3387 <lodepng_memset>
    9cb2:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9cb5:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb8:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9cbf:	90                   	nop
    9cc0:	c9                   	leave  
    9cc1:	c3                   	ret    

00009cc2 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9cc2:	55                   	push   %ebp
    9cc3:	89 e5                	mov    %esp,%ebp
    9cc5:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9cc8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9ccf:	eb 3b                	jmp    9d0c <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9cd1:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cd7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9cda:	85 c0                	test   %eax,%eax
    9cdc:	74 2a                	je     9d08 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9cde:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ce4:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ce7:	83 ec 0c             	sub    $0xc,%esp
    9cea:	50                   	push   %eax
    9ceb:	e8 d2 ff ff ff       	call   9cc2 <color_tree_cleanup>
    9cf0:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9cf3:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cf9:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9cfc:	83 ec 0c             	sub    $0xc,%esp
    9cff:	50                   	push   %eax
    9d00:	e8 32 96 ff ff       	call   3337 <lodepng_free>
    9d05:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9d08:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9d0c:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9d10:	75 bf                	jne    9cd1 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9d12:	90                   	nop
    9d13:	c9                   	leave  
    9d14:	c3                   	ret    

00009d15 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9d15:	55                   	push   %ebp
    9d16:	89 e5                	mov    %esp,%ebp
    9d18:	53                   	push   %ebx
    9d19:	83 ec 20             	sub    $0x20,%esp
    9d1c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9d1f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9d22:	8b 55 14             	mov    0x14(%ebp),%edx
    9d25:	8b 45 18             	mov    0x18(%ebp),%eax
    9d28:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9d2b:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9d2e:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9d31:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9d34:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9d3b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9d42:	eb 76                	jmp    9dba <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9d44:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9d48:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d4b:	89 c1                	mov    %eax,%ecx
    9d4d:	d3 fa                	sar    %cl,%edx
    9d4f:	89 d0                	mov    %edx,%eax
    9d51:	83 e0 01             	and    $0x1,%eax
    9d54:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d57:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9d5b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d5e:	89 c1                	mov    %eax,%ecx
    9d60:	d3 fa                	sar    %cl,%edx
    9d62:	89 d0                	mov    %edx,%eax
    9d64:	83 e0 01             	and    $0x1,%eax
    9d67:	01 d8                	add    %ebx,%eax
    9d69:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d6c:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9d70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d73:	89 c1                	mov    %eax,%ecx
    9d75:	d3 fa                	sar    %cl,%edx
    9d77:	89 d0                	mov    %edx,%eax
    9d79:	83 e0 01             	and    $0x1,%eax
    9d7c:	01 d8                	add    %ebx,%eax
    9d7e:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d81:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9d85:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d88:	89 c1                	mov    %eax,%ecx
    9d8a:	d3 fa                	sar    %cl,%edx
    9d8c:	89 d0                	mov    %edx,%eax
    9d8e:	83 e0 01             	and    $0x1,%eax
    9d91:	01 d8                	add    %ebx,%eax
    9d93:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9d96:	8b 45 08             	mov    0x8(%ebp),%eax
    9d99:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d9c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d9f:	85 c0                	test   %eax,%eax
    9da1:	75 07                	jne    9daa <color_tree_get+0x95>
    9da3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9da8:	eb 2a                	jmp    9dd4 <color_tree_get+0xbf>
    else tree = tree->children[i];
    9daa:	8b 45 08             	mov    0x8(%ebp),%eax
    9dad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9db0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9db3:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9db6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9dba:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9dbe:	7e 84                	jle    9d44 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9dc0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9dc4:	74 08                	je     9dce <color_tree_get+0xb9>
    9dc6:	8b 45 08             	mov    0x8(%ebp),%eax
    9dc9:	8b 40 40             	mov    0x40(%eax),%eax
    9dcc:	eb 05                	jmp    9dd3 <color_tree_get+0xbe>
    9dce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9dd3:	90                   	nop
}
    9dd4:	83 c4 20             	add    $0x20,%esp
    9dd7:	5b                   	pop    %ebx
    9dd8:	5d                   	pop    %ebp
    9dd9:	c3                   	ret    

00009dda <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9dda:	55                   	push   %ebp
    9ddb:	89 e5                	mov    %esp,%ebp
    9ddd:	53                   	push   %ebx
    9dde:	83 ec 10             	sub    $0x10,%esp
    9de1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9de4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9de7:	8b 55 14             	mov    0x14(%ebp),%edx
    9dea:	8b 45 18             	mov    0x18(%ebp),%eax
    9ded:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9df0:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9df3:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9df6:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9df9:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9dfd:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9e01:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9e05:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9e09:	53                   	push   %ebx
    9e0a:	51                   	push   %ecx
    9e0b:	52                   	push   %edx
    9e0c:	50                   	push   %eax
    9e0d:	ff 75 08             	pushl  0x8(%ebp)
    9e10:	e8 00 ff ff ff       	call   9d15 <color_tree_get>
    9e15:	83 c4 14             	add    $0x14,%esp
    9e18:	f7 d0                	not    %eax
    9e1a:	c1 e8 1f             	shr    $0x1f,%eax
    9e1d:	0f b6 c0             	movzbl %al,%eax
}
    9e20:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9e23:	c9                   	leave  
    9e24:	c3                   	ret    

00009e25 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9e25:	55                   	push   %ebp
    9e26:	89 e5                	mov    %esp,%ebp
    9e28:	53                   	push   %ebx
    9e29:	83 ec 24             	sub    $0x24,%esp
    9e2c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e2f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e32:	8b 55 14             	mov    0x14(%ebp),%edx
    9e35:	8b 45 18             	mov    0x18(%ebp),%eax
    9e38:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9e3b:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9e3e:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9e41:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9e44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9e4b:	e9 b0 00 00 00       	jmp    9f00 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9e50:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9e54:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e57:	89 c1                	mov    %eax,%ecx
    9e59:	d3 fa                	sar    %cl,%edx
    9e5b:	89 d0                	mov    %edx,%eax
    9e5d:	83 e0 01             	and    $0x1,%eax
    9e60:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e63:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e67:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e6a:	89 c1                	mov    %eax,%ecx
    9e6c:	d3 fa                	sar    %cl,%edx
    9e6e:	89 d0                	mov    %edx,%eax
    9e70:	83 e0 01             	and    $0x1,%eax
    9e73:	01 d8                	add    %ebx,%eax
    9e75:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e78:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e7f:	89 c1                	mov    %eax,%ecx
    9e81:	d3 fa                	sar    %cl,%edx
    9e83:	89 d0                	mov    %edx,%eax
    9e85:	83 e0 01             	and    $0x1,%eax
    9e88:	01 d8                	add    %ebx,%eax
    9e8a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e8d:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9e91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e94:	89 c1                	mov    %eax,%ecx
    9e96:	d3 fa                	sar    %cl,%edx
    9e98:	89 d0                	mov    %edx,%eax
    9e9a:	83 e0 01             	and    $0x1,%eax
    9e9d:	01 d8                	add    %ebx,%eax
    9e9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9ea2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ea5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ea8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9eab:	85 c0                	test   %eax,%eax
    9ead:	75 41                	jne    9ef0 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9eaf:	83 ec 0c             	sub    $0xc,%esp
    9eb2:	6a 44                	push   $0x44
    9eb4:	e8 5d 94 ff ff       	call   3316 <lodepng_malloc>
    9eb9:	83 c4 10             	add    $0x10,%esp
    9ebc:	89 c1                	mov    %eax,%ecx
    9ebe:	8b 45 08             	mov    0x8(%ebp),%eax
    9ec1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ec4:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9ec7:	8b 45 08             	mov    0x8(%ebp),%eax
    9eca:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ecd:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ed0:	85 c0                	test   %eax,%eax
    9ed2:	75 07                	jne    9edb <color_tree_add+0xb6>
    9ed4:	b8 53 00 00 00       	mov    $0x53,%eax
    9ed9:	eb 3d                	jmp    9f18 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9edb:	8b 45 08             	mov    0x8(%ebp),%eax
    9ede:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ee1:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ee4:	83 ec 0c             	sub    $0xc,%esp
    9ee7:	50                   	push   %eax
    9ee8:	e8 b5 fd ff ff       	call   9ca2 <color_tree_init>
    9eed:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9ef0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ef3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ef6:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ef9:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9efc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f00:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9f04:	0f 8e 46 ff ff ff    	jle    9e50 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9f0a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9f0d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f10:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    9f13:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f1b:	c9                   	leave  
    9f1c:	c3                   	ret    

00009f1d <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9f1d:	55                   	push   %ebp
    9f1e:	89 e5                	mov    %esp,%ebp
    9f20:	53                   	push   %ebx
    9f21:	83 ec 20             	sub    $0x20,%esp
    9f24:	8b 5d 18             	mov    0x18(%ebp),%ebx
    9f27:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    9f2a:	8b 55 20             	mov    0x20(%ebp),%edx
    9f2d:	8b 45 24             	mov    0x24(%ebp),%eax
    9f30:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9f33:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9f36:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9f39:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    9f3c:	8b 45 10             	mov    0x10(%ebp),%eax
    9f3f:	8b 00                	mov    (%eax),%eax
    9f41:	85 c0                	test   %eax,%eax
    9f43:	0f 85 ad 00 00 00    	jne    9ff6 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    9f49:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9f4d:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    9f50:	8b 45 10             	mov    0x10(%ebp),%eax
    9f53:	8b 40 04             	mov    0x4(%eax),%eax
    9f56:	83 f8 08             	cmp    $0x8,%eax
    9f59:	75 13                	jne    9f6e <rgba8ToPixel+0x51>
    9f5b:	8b 55 0c             	mov    0xc(%ebp),%edx
    9f5e:	8b 45 08             	mov    0x8(%ebp),%eax
    9f61:	01 c2                	add    %eax,%edx
    9f63:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    9f67:	88 02                	mov    %al,(%edx)
    9f69:	e9 b4 03 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    9f6e:	8b 45 10             	mov    0x10(%ebp),%eax
    9f71:	8b 40 04             	mov    0x4(%eax),%eax
    9f74:	83 f8 10             	cmp    $0x10,%eax
    9f77:	75 2a                	jne    9fa3 <rgba8ToPixel+0x86>
    9f79:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f7c:	01 c0                	add    %eax,%eax
    9f7e:	89 c2                	mov    %eax,%edx
    9f80:	8b 45 08             	mov    0x8(%ebp),%eax
    9f83:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    9f86:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f89:	01 c0                	add    %eax,%eax
    9f8b:	8d 50 01             	lea    0x1(%eax),%edx
    9f8e:	8b 45 08             	mov    0x8(%ebp),%eax
    9f91:	01 d0                	add    %edx,%eax
    9f93:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9f97:	88 10                	mov    %dl,(%eax)
    9f99:	0f b6 00             	movzbl (%eax),%eax
    9f9c:	88 01                	mov    %al,(%ecx)
    9f9e:	e9 7f 03 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    9fa3:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fa7:	8b 45 10             	mov    0x10(%ebp),%eax
    9faa:	8b 40 04             	mov    0x4(%eax),%eax
    9fad:	b9 08 00 00 00       	mov    $0x8,%ecx
    9fb2:	29 c1                	sub    %eax,%ecx
    9fb4:	89 c8                	mov    %ecx,%eax
    9fb6:	89 c1                	mov    %eax,%ecx
    9fb8:	d3 ea                	shr    %cl,%edx
    9fba:	89 d0                	mov    %edx,%eax
    9fbc:	89 c2                	mov    %eax,%edx
    9fbe:	8b 45 10             	mov    0x10(%ebp),%eax
    9fc1:	8b 40 04             	mov    0x4(%eax),%eax
    9fc4:	bb 01 00 00 00       	mov    $0x1,%ebx
    9fc9:	89 c1                	mov    %eax,%ecx
    9fcb:	d3 e3                	shl    %cl,%ebx
    9fcd:	89 d8                	mov    %ebx,%eax
    9fcf:	83 e8 01             	sub    $0x1,%eax
    9fd2:	21 d0                	and    %edx,%eax
    9fd4:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    9fd7:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fdb:	8b 45 10             	mov    0x10(%ebp),%eax
    9fde:	8b 40 04             	mov    0x4(%eax),%eax
    9fe1:	52                   	push   %edx
    9fe2:	50                   	push   %eax
    9fe3:	ff 75 0c             	pushl  0xc(%ebp)
    9fe6:	ff 75 08             	pushl  0x8(%ebp)
    9fe9:	e8 21 fc ff ff       	call   9c0f <addColorBits>
    9fee:	83 c4 10             	add    $0x10,%esp
    9ff1:	e9 2c 03 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    9ff6:	8b 45 10             	mov    0x10(%ebp),%eax
    9ff9:	8b 00                	mov    (%eax),%eax
    9ffb:	83 f8 02             	cmp    $0x2,%eax
    9ffe:	0f 85 ee 00 00 00    	jne    a0f2 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a004:	8b 45 10             	mov    0x10(%ebp),%eax
    a007:	8b 40 04             	mov    0x4(%eax),%eax
    a00a:	83 f8 08             	cmp    $0x8,%eax
    a00d:	75 49                	jne    a058 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a00f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a012:	89 d0                	mov    %edx,%eax
    a014:	01 c0                	add    %eax,%eax
    a016:	01 d0                	add    %edx,%eax
    a018:	89 c2                	mov    %eax,%edx
    a01a:	8b 45 08             	mov    0x8(%ebp),%eax
    a01d:	01 c2                	add    %eax,%edx
    a01f:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a023:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a025:	8b 55 0c             	mov    0xc(%ebp),%edx
    a028:	89 d0                	mov    %edx,%eax
    a02a:	01 c0                	add    %eax,%eax
    a02c:	01 d0                	add    %edx,%eax
    a02e:	8d 50 01             	lea    0x1(%eax),%edx
    a031:	8b 45 08             	mov    0x8(%ebp),%eax
    a034:	01 c2                	add    %eax,%edx
    a036:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a03a:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a03c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a03f:	89 d0                	mov    %edx,%eax
    a041:	01 c0                	add    %eax,%eax
    a043:	01 d0                	add    %edx,%eax
    a045:	8d 50 02             	lea    0x2(%eax),%edx
    a048:	8b 45 08             	mov    0x8(%ebp),%eax
    a04b:	01 c2                	add    %eax,%edx
    a04d:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a051:	88 02                	mov    %al,(%edx)
    a053:	e9 ca 02 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a058:	8b 55 0c             	mov    0xc(%ebp),%edx
    a05b:	89 d0                	mov    %edx,%eax
    a05d:	01 c0                	add    %eax,%eax
    a05f:	01 d0                	add    %edx,%eax
    a061:	01 c0                	add    %eax,%eax
    a063:	89 c2                	mov    %eax,%edx
    a065:	8b 45 08             	mov    0x8(%ebp),%eax
    a068:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a06b:	8b 55 0c             	mov    0xc(%ebp),%edx
    a06e:	89 d0                	mov    %edx,%eax
    a070:	01 c0                	add    %eax,%eax
    a072:	01 d0                	add    %edx,%eax
    a074:	01 c0                	add    %eax,%eax
    a076:	8d 50 01             	lea    0x1(%eax),%edx
    a079:	8b 45 08             	mov    0x8(%ebp),%eax
    a07c:	01 d0                	add    %edx,%eax
    a07e:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a082:	88 10                	mov    %dl,(%eax)
    a084:	0f b6 00             	movzbl (%eax),%eax
    a087:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a089:	8b 55 0c             	mov    0xc(%ebp),%edx
    a08c:	89 d0                	mov    %edx,%eax
    a08e:	01 c0                	add    %eax,%eax
    a090:	01 d0                	add    %edx,%eax
    a092:	01 c0                	add    %eax,%eax
    a094:	8d 50 02             	lea    0x2(%eax),%edx
    a097:	8b 45 08             	mov    0x8(%ebp),%eax
    a09a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a09d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0a0:	89 d0                	mov    %edx,%eax
    a0a2:	01 c0                	add    %eax,%eax
    a0a4:	01 d0                	add    %edx,%eax
    a0a6:	01 c0                	add    %eax,%eax
    a0a8:	8d 50 03             	lea    0x3(%eax),%edx
    a0ab:	8b 45 08             	mov    0x8(%ebp),%eax
    a0ae:	01 d0                	add    %edx,%eax
    a0b0:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a0b4:	88 10                	mov    %dl,(%eax)
    a0b6:	0f b6 00             	movzbl (%eax),%eax
    a0b9:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a0bb:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0be:	89 d0                	mov    %edx,%eax
    a0c0:	01 c0                	add    %eax,%eax
    a0c2:	01 d0                	add    %edx,%eax
    a0c4:	01 c0                	add    %eax,%eax
    a0c6:	8d 50 04             	lea    0x4(%eax),%edx
    a0c9:	8b 45 08             	mov    0x8(%ebp),%eax
    a0cc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0cf:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0d2:	89 d0                	mov    %edx,%eax
    a0d4:	01 c0                	add    %eax,%eax
    a0d6:	01 d0                	add    %edx,%eax
    a0d8:	01 c0                	add    %eax,%eax
    a0da:	8d 50 05             	lea    0x5(%eax),%edx
    a0dd:	8b 45 08             	mov    0x8(%ebp),%eax
    a0e0:	01 d0                	add    %edx,%eax
    a0e2:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a0e6:	88 10                	mov    %dl,(%eax)
    a0e8:	0f b6 00             	movzbl (%eax),%eax
    a0eb:	88 01                	mov    %al,(%ecx)
    a0ed:	e9 30 02 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a0f2:	8b 45 10             	mov    0x10(%ebp),%eax
    a0f5:	8b 00                	mov    (%eax),%eax
    a0f7:	83 f8 03             	cmp    $0x3,%eax
    a0fa:	75 6d                	jne    a169 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a0fc:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a100:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a104:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a108:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a10c:	53                   	push   %ebx
    a10d:	51                   	push   %ecx
    a10e:	52                   	push   %edx
    a10f:	50                   	push   %eax
    a110:	ff 75 14             	pushl  0x14(%ebp)
    a113:	e8 fd fb ff ff       	call   9d15 <color_tree_get>
    a118:	83 c4 14             	add    $0x14,%esp
    a11b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a11e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a122:	79 0a                	jns    a12e <rgba8ToPixel+0x211>
    a124:	b8 52 00 00 00       	mov    $0x52,%eax
    a129:	e9 f9 01 00 00       	jmp    a327 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a12e:	8b 45 10             	mov    0x10(%ebp),%eax
    a131:	8b 40 04             	mov    0x4(%eax),%eax
    a134:	83 f8 08             	cmp    $0x8,%eax
    a137:	75 12                	jne    a14b <rgba8ToPixel+0x22e>
    a139:	8b 55 0c             	mov    0xc(%ebp),%edx
    a13c:	8b 45 08             	mov    0x8(%ebp),%eax
    a13f:	01 d0                	add    %edx,%eax
    a141:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a144:	88 10                	mov    %dl,(%eax)
    a146:	e9 d7 01 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a14b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a14e:	8b 45 10             	mov    0x10(%ebp),%eax
    a151:	8b 40 04             	mov    0x4(%eax),%eax
    a154:	52                   	push   %edx
    a155:	50                   	push   %eax
    a156:	ff 75 0c             	pushl  0xc(%ebp)
    a159:	ff 75 08             	pushl  0x8(%ebp)
    a15c:	e8 ae fa ff ff       	call   9c0f <addColorBits>
    a161:	83 c4 10             	add    $0x10,%esp
    a164:	e9 b9 01 00 00       	jmp    a322 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a169:	8b 45 10             	mov    0x10(%ebp),%eax
    a16c:	8b 00                	mov    (%eax),%eax
    a16e:	83 f8 04             	cmp    $0x4,%eax
    a171:	0f 85 9f 00 00 00    	jne    a216 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a177:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a17b:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a17e:	8b 45 10             	mov    0x10(%ebp),%eax
    a181:	8b 40 04             	mov    0x4(%eax),%eax
    a184:	83 f8 08             	cmp    $0x8,%eax
    a187:	75 2a                	jne    a1b3 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a189:	8b 45 0c             	mov    0xc(%ebp),%eax
    a18c:	01 c0                	add    %eax,%eax
    a18e:	89 c2                	mov    %eax,%edx
    a190:	8b 45 08             	mov    0x8(%ebp),%eax
    a193:	01 c2                	add    %eax,%edx
    a195:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a199:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a19b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a19e:	01 c0                	add    %eax,%eax
    a1a0:	8d 50 01             	lea    0x1(%eax),%edx
    a1a3:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a6:	01 c2                	add    %eax,%edx
    a1a8:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a1ac:	88 02                	mov    %al,(%edx)
    a1ae:	e9 6f 01 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a1b3:	8b 45 10             	mov    0x10(%ebp),%eax
    a1b6:	8b 40 04             	mov    0x4(%eax),%eax
    a1b9:	83 f8 10             	cmp    $0x10,%eax
    a1bc:	0f 85 60 01 00 00    	jne    a322 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a1c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1c5:	c1 e0 02             	shl    $0x2,%eax
    a1c8:	89 c2                	mov    %eax,%edx
    a1ca:	8b 45 08             	mov    0x8(%ebp),%eax
    a1cd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1d3:	c1 e0 02             	shl    $0x2,%eax
    a1d6:	8d 50 01             	lea    0x1(%eax),%edx
    a1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a1dc:	01 d0                	add    %edx,%eax
    a1de:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a1e2:	88 10                	mov    %dl,(%eax)
    a1e4:	0f b6 00             	movzbl (%eax),%eax
    a1e7:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a1e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1ec:	c1 e0 02             	shl    $0x2,%eax
    a1ef:	8d 50 02             	lea    0x2(%eax),%edx
    a1f2:	8b 45 08             	mov    0x8(%ebp),%eax
    a1f5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1fb:	c1 e0 02             	shl    $0x2,%eax
    a1fe:	8d 50 03             	lea    0x3(%eax),%edx
    a201:	8b 45 08             	mov    0x8(%ebp),%eax
    a204:	01 d0                	add    %edx,%eax
    a206:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a20a:	88 10                	mov    %dl,(%eax)
    a20c:	0f b6 00             	movzbl (%eax),%eax
    a20f:	88 01                	mov    %al,(%ecx)
    a211:	e9 0c 01 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a216:	8b 45 10             	mov    0x10(%ebp),%eax
    a219:	8b 00                	mov    (%eax),%eax
    a21b:	83 f8 06             	cmp    $0x6,%eax
    a21e:	0f 85 fe 00 00 00    	jne    a322 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a224:	8b 45 10             	mov    0x10(%ebp),%eax
    a227:	8b 40 04             	mov    0x4(%eax),%eax
    a22a:	83 f8 08             	cmp    $0x8,%eax
    a22d:	75 54                	jne    a283 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a22f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a232:	c1 e0 02             	shl    $0x2,%eax
    a235:	89 c2                	mov    %eax,%edx
    a237:	8b 45 08             	mov    0x8(%ebp),%eax
    a23a:	01 c2                	add    %eax,%edx
    a23c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a240:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a242:	8b 45 0c             	mov    0xc(%ebp),%eax
    a245:	c1 e0 02             	shl    $0x2,%eax
    a248:	8d 50 01             	lea    0x1(%eax),%edx
    a24b:	8b 45 08             	mov    0x8(%ebp),%eax
    a24e:	01 c2                	add    %eax,%edx
    a250:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a254:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a256:	8b 45 0c             	mov    0xc(%ebp),%eax
    a259:	c1 e0 02             	shl    $0x2,%eax
    a25c:	8d 50 02             	lea    0x2(%eax),%edx
    a25f:	8b 45 08             	mov    0x8(%ebp),%eax
    a262:	01 c2                	add    %eax,%edx
    a264:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a268:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a26a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a26d:	c1 e0 02             	shl    $0x2,%eax
    a270:	8d 50 03             	lea    0x3(%eax),%edx
    a273:	8b 45 08             	mov    0x8(%ebp),%eax
    a276:	01 c2                	add    %eax,%edx
    a278:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a27c:	88 02                	mov    %al,(%edx)
    a27e:	e9 9f 00 00 00       	jmp    a322 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a283:	8b 45 0c             	mov    0xc(%ebp),%eax
    a286:	c1 e0 03             	shl    $0x3,%eax
    a289:	89 c2                	mov    %eax,%edx
    a28b:	8b 45 08             	mov    0x8(%ebp),%eax
    a28e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a291:	8b 45 0c             	mov    0xc(%ebp),%eax
    a294:	c1 e0 03             	shl    $0x3,%eax
    a297:	8d 50 01             	lea    0x1(%eax),%edx
    a29a:	8b 45 08             	mov    0x8(%ebp),%eax
    a29d:	01 d0                	add    %edx,%eax
    a29f:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a2a3:	88 10                	mov    %dl,(%eax)
    a2a5:	0f b6 00             	movzbl (%eax),%eax
    a2a8:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a2aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2ad:	c1 e0 03             	shl    $0x3,%eax
    a2b0:	8d 50 02             	lea    0x2(%eax),%edx
    a2b3:	8b 45 08             	mov    0x8(%ebp),%eax
    a2b6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2bc:	c1 e0 03             	shl    $0x3,%eax
    a2bf:	8d 50 03             	lea    0x3(%eax),%edx
    a2c2:	8b 45 08             	mov    0x8(%ebp),%eax
    a2c5:	01 d0                	add    %edx,%eax
    a2c7:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a2cb:	88 10                	mov    %dl,(%eax)
    a2cd:	0f b6 00             	movzbl (%eax),%eax
    a2d0:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a2d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2d5:	c1 e0 03             	shl    $0x3,%eax
    a2d8:	8d 50 04             	lea    0x4(%eax),%edx
    a2db:	8b 45 08             	mov    0x8(%ebp),%eax
    a2de:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e4:	c1 e0 03             	shl    $0x3,%eax
    a2e7:	8d 50 05             	lea    0x5(%eax),%edx
    a2ea:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ed:	01 d0                	add    %edx,%eax
    a2ef:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a2f3:	88 10                	mov    %dl,(%eax)
    a2f5:	0f b6 00             	movzbl (%eax),%eax
    a2f8:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a2fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2fd:	c1 e0 03             	shl    $0x3,%eax
    a300:	8d 50 06             	lea    0x6(%eax),%edx
    a303:	8b 45 08             	mov    0x8(%ebp),%eax
    a306:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a309:	8b 45 0c             	mov    0xc(%ebp),%eax
    a30c:	c1 e0 03             	shl    $0x3,%eax
    a30f:	8d 50 07             	lea    0x7(%eax),%edx
    a312:	8b 45 08             	mov    0x8(%ebp),%eax
    a315:	01 d0                	add    %edx,%eax
    a317:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a31b:	88 10                	mov    %dl,(%eax)
    a31d:	0f b6 00             	movzbl (%eax),%eax
    a320:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a322:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a327:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a32a:	c9                   	leave  
    a32b:	c3                   	ret    

0000a32c <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a32c:	55                   	push   %ebp
    a32d:	89 e5                	mov    %esp,%ebp
    a32f:	53                   	push   %ebx
    a330:	83 ec 20             	sub    $0x20,%esp
    a333:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a336:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a339:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a33c:	8b 45 20             	mov    0x20(%ebp),%eax
    a33f:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a343:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a347:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a34b:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a34f:	8b 45 10             	mov    0x10(%ebp),%eax
    a352:	8b 00                	mov    (%eax),%eax
    a354:	85 c0                	test   %eax,%eax
    a356:	75 36                	jne    a38e <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a358:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a35c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a360:	8b 45 0c             	mov    0xc(%ebp),%eax
    a363:	01 c0                	add    %eax,%eax
    a365:	89 c2                	mov    %eax,%edx
    a367:	8b 45 08             	mov    0x8(%ebp),%eax
    a36a:	01 d0                	add    %edx,%eax
    a36c:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a370:	66 c1 ea 08          	shr    $0x8,%dx
    a374:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a376:	8b 45 0c             	mov    0xc(%ebp),%eax
    a379:	01 c0                	add    %eax,%eax
    a37b:	8d 50 01             	lea    0x1(%eax),%edx
    a37e:	8b 45 08             	mov    0x8(%ebp),%eax
    a381:	01 d0                	add    %edx,%eax
    a383:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a387:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a389:	e9 df 01 00 00       	jmp    a56d <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a38e:	8b 45 10             	mov    0x10(%ebp),%eax
    a391:	8b 00                	mov    (%eax),%eax
    a393:	83 f8 02             	cmp    $0x2,%eax
    a396:	0f 85 a6 00 00 00    	jne    a442 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a39c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a39f:	89 d0                	mov    %edx,%eax
    a3a1:	01 c0                	add    %eax,%eax
    a3a3:	01 d0                	add    %edx,%eax
    a3a5:	01 c0                	add    %eax,%eax
    a3a7:	89 c2                	mov    %eax,%edx
    a3a9:	8b 45 08             	mov    0x8(%ebp),%eax
    a3ac:	01 d0                	add    %edx,%eax
    a3ae:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3b2:	66 c1 ea 08          	shr    $0x8,%dx
    a3b6:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a3b8:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3bb:	89 d0                	mov    %edx,%eax
    a3bd:	01 c0                	add    %eax,%eax
    a3bf:	01 d0                	add    %edx,%eax
    a3c1:	01 c0                	add    %eax,%eax
    a3c3:	8d 50 01             	lea    0x1(%eax),%edx
    a3c6:	8b 45 08             	mov    0x8(%ebp),%eax
    a3c9:	01 d0                	add    %edx,%eax
    a3cb:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3cf:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a3d1:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3d4:	89 d0                	mov    %edx,%eax
    a3d6:	01 c0                	add    %eax,%eax
    a3d8:	01 d0                	add    %edx,%eax
    a3da:	01 c0                	add    %eax,%eax
    a3dc:	8d 50 02             	lea    0x2(%eax),%edx
    a3df:	8b 45 08             	mov    0x8(%ebp),%eax
    a3e2:	01 d0                	add    %edx,%eax
    a3e4:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a3e8:	66 c1 ea 08          	shr    $0x8,%dx
    a3ec:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a3ee:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3f1:	89 d0                	mov    %edx,%eax
    a3f3:	01 c0                	add    %eax,%eax
    a3f5:	01 d0                	add    %edx,%eax
    a3f7:	01 c0                	add    %eax,%eax
    a3f9:	8d 50 03             	lea    0x3(%eax),%edx
    a3fc:	8b 45 08             	mov    0x8(%ebp),%eax
    a3ff:	01 d0                	add    %edx,%eax
    a401:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a405:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a407:	8b 55 0c             	mov    0xc(%ebp),%edx
    a40a:	89 d0                	mov    %edx,%eax
    a40c:	01 c0                	add    %eax,%eax
    a40e:	01 d0                	add    %edx,%eax
    a410:	01 c0                	add    %eax,%eax
    a412:	8d 50 04             	lea    0x4(%eax),%edx
    a415:	8b 45 08             	mov    0x8(%ebp),%eax
    a418:	01 d0                	add    %edx,%eax
    a41a:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a41e:	66 c1 ea 08          	shr    $0x8,%dx
    a422:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a424:	8b 55 0c             	mov    0xc(%ebp),%edx
    a427:	89 d0                	mov    %edx,%eax
    a429:	01 c0                	add    %eax,%eax
    a42b:	01 d0                	add    %edx,%eax
    a42d:	01 c0                	add    %eax,%eax
    a42f:	8d 50 05             	lea    0x5(%eax),%edx
    a432:	8b 45 08             	mov    0x8(%ebp),%eax
    a435:	01 d0                	add    %edx,%eax
    a437:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a43b:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a43d:	e9 2b 01 00 00       	jmp    a56d <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a442:	8b 45 10             	mov    0x10(%ebp),%eax
    a445:	8b 00                	mov    (%eax),%eax
    a447:	83 f8 04             	cmp    $0x4,%eax
    a44a:	75 64                	jne    a4b0 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a44c:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a450:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a454:	8b 45 0c             	mov    0xc(%ebp),%eax
    a457:	c1 e0 02             	shl    $0x2,%eax
    a45a:	89 c2                	mov    %eax,%edx
    a45c:	8b 45 08             	mov    0x8(%ebp),%eax
    a45f:	01 d0                	add    %edx,%eax
    a461:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a465:	66 c1 ea 08          	shr    $0x8,%dx
    a469:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a46b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a46e:	c1 e0 02             	shl    $0x2,%eax
    a471:	8d 50 01             	lea    0x1(%eax),%edx
    a474:	8b 45 08             	mov    0x8(%ebp),%eax
    a477:	01 d0                	add    %edx,%eax
    a479:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a47d:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a47f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a482:	c1 e0 02             	shl    $0x2,%eax
    a485:	8d 50 02             	lea    0x2(%eax),%edx
    a488:	8b 45 08             	mov    0x8(%ebp),%eax
    a48b:	01 d0                	add    %edx,%eax
    a48d:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a491:	66 c1 ea 08          	shr    $0x8,%dx
    a495:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a497:	8b 45 0c             	mov    0xc(%ebp),%eax
    a49a:	c1 e0 02             	shl    $0x2,%eax
    a49d:	8d 50 03             	lea    0x3(%eax),%edx
    a4a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a3:	01 d0                	add    %edx,%eax
    a4a5:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a4a9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a4ab:	e9 bd 00 00 00       	jmp    a56d <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a4b0:	8b 45 10             	mov    0x10(%ebp),%eax
    a4b3:	8b 00                	mov    (%eax),%eax
    a4b5:	83 f8 06             	cmp    $0x6,%eax
    a4b8:	0f 85 af 00 00 00    	jne    a56d <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a4be:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4c1:	c1 e0 03             	shl    $0x3,%eax
    a4c4:	89 c2                	mov    %eax,%edx
    a4c6:	8b 45 08             	mov    0x8(%ebp),%eax
    a4c9:	01 d0                	add    %edx,%eax
    a4cb:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4cf:	66 c1 ea 08          	shr    $0x8,%dx
    a4d3:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a4d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4d8:	c1 e0 03             	shl    $0x3,%eax
    a4db:	8d 50 01             	lea    0x1(%eax),%edx
    a4de:	8b 45 08             	mov    0x8(%ebp),%eax
    a4e1:	01 d0                	add    %edx,%eax
    a4e3:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4e7:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a4e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4ec:	c1 e0 03             	shl    $0x3,%eax
    a4ef:	8d 50 02             	lea    0x2(%eax),%edx
    a4f2:	8b 45 08             	mov    0x8(%ebp),%eax
    a4f5:	01 d0                	add    %edx,%eax
    a4f7:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a4fb:	66 c1 ea 08          	shr    $0x8,%dx
    a4ff:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a501:	8b 45 0c             	mov    0xc(%ebp),%eax
    a504:	c1 e0 03             	shl    $0x3,%eax
    a507:	8d 50 03             	lea    0x3(%eax),%edx
    a50a:	8b 45 08             	mov    0x8(%ebp),%eax
    a50d:	01 d0                	add    %edx,%eax
    a50f:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a513:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a515:	8b 45 0c             	mov    0xc(%ebp),%eax
    a518:	c1 e0 03             	shl    $0x3,%eax
    a51b:	8d 50 04             	lea    0x4(%eax),%edx
    a51e:	8b 45 08             	mov    0x8(%ebp),%eax
    a521:	01 d0                	add    %edx,%eax
    a523:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a527:	66 c1 ea 08          	shr    $0x8,%dx
    a52b:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a52d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a530:	c1 e0 03             	shl    $0x3,%eax
    a533:	8d 50 05             	lea    0x5(%eax),%edx
    a536:	8b 45 08             	mov    0x8(%ebp),%eax
    a539:	01 d0                	add    %edx,%eax
    a53b:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a53f:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a541:	8b 45 0c             	mov    0xc(%ebp),%eax
    a544:	c1 e0 03             	shl    $0x3,%eax
    a547:	8d 50 06             	lea    0x6(%eax),%edx
    a54a:	8b 45 08             	mov    0x8(%ebp),%eax
    a54d:	01 d0                	add    %edx,%eax
    a54f:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a553:	66 c1 ea 08          	shr    $0x8,%dx
    a557:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a559:	8b 45 0c             	mov    0xc(%ebp),%eax
    a55c:	c1 e0 03             	shl    $0x3,%eax
    a55f:	8d 50 07             	lea    0x7(%eax),%edx
    a562:	8b 45 08             	mov    0x8(%ebp),%eax
    a565:	01 d0                	add    %edx,%eax
    a567:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a56b:	88 10                	mov    %dl,(%eax)
  }
}
    a56d:	90                   	nop
    a56e:	83 c4 20             	add    $0x20,%esp
    a571:	5b                   	pop    %ebx
    a572:	5d                   	pop    %ebp
    a573:	c3                   	ret    

0000a574 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a574:	55                   	push   %ebp
    a575:	89 e5                	mov    %esp,%ebp
    a577:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a57a:	8b 45 20             	mov    0x20(%ebp),%eax
    a57d:	8b 00                	mov    (%eax),%eax
    a57f:	85 c0                	test   %eax,%eax
    a581:	0f 85 8c 01 00 00    	jne    a713 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a587:	8b 45 20             	mov    0x20(%ebp),%eax
    a58a:	8b 40 04             	mov    0x4(%eax),%eax
    a58d:	83 f8 08             	cmp    $0x8,%eax
    a590:	75 59                	jne    a5eb <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a592:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a595:	8b 45 18             	mov    0x18(%ebp),%eax
    a598:	01 d0                	add    %edx,%eax
    a59a:	0f b6 10             	movzbl (%eax),%edx
    a59d:	8b 45 10             	mov    0x10(%ebp),%eax
    a5a0:	88 10                	mov    %dl,(%eax)
    a5a2:	8b 45 10             	mov    0x10(%ebp),%eax
    a5a5:	0f b6 10             	movzbl (%eax),%edx
    a5a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ab:	88 10                	mov    %dl,(%eax)
    a5ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5b0:	0f b6 10             	movzbl (%eax),%edx
    a5b3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5b6:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a5b8:	8b 45 20             	mov    0x20(%ebp),%eax
    a5bb:	8b 40 10             	mov    0x10(%eax),%eax
    a5be:	85 c0                	test   %eax,%eax
    a5c0:	74 1e                	je     a5e0 <getPixelColorRGBA8+0x6c>
    a5c2:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c5:	0f b6 00             	movzbl (%eax),%eax
    a5c8:	0f b6 d0             	movzbl %al,%edx
    a5cb:	8b 45 20             	mov    0x20(%ebp),%eax
    a5ce:	8b 40 14             	mov    0x14(%eax),%eax
    a5d1:	39 c2                	cmp    %eax,%edx
    a5d3:	75 0b                	jne    a5e0 <getPixelColorRGBA8+0x6c>
    a5d5:	8b 45 14             	mov    0x14(%ebp),%eax
    a5d8:	c6 00 00             	movb   $0x0,(%eax)
    a5db:	e9 5e 05 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a5e0:	8b 45 14             	mov    0x14(%ebp),%eax
    a5e3:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a5e6:	e9 53 05 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a5eb:	8b 45 20             	mov    0x20(%ebp),%eax
    a5ee:	8b 40 04             	mov    0x4(%eax),%eax
    a5f1:	83 f8 10             	cmp    $0x10,%eax
    a5f4:	0f 85 80 00 00 00    	jne    a67a <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a5fa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a5fd:	01 c0                	add    %eax,%eax
    a5ff:	89 c2                	mov    %eax,%edx
    a601:	8b 45 18             	mov    0x18(%ebp),%eax
    a604:	01 d0                	add    %edx,%eax
    a606:	0f b6 10             	movzbl (%eax),%edx
    a609:	8b 45 10             	mov    0x10(%ebp),%eax
    a60c:	88 10                	mov    %dl,(%eax)
    a60e:	8b 45 10             	mov    0x10(%ebp),%eax
    a611:	0f b6 10             	movzbl (%eax),%edx
    a614:	8b 45 0c             	mov    0xc(%ebp),%eax
    a617:	88 10                	mov    %dl,(%eax)
    a619:	8b 45 0c             	mov    0xc(%ebp),%eax
    a61c:	0f b6 10             	movzbl (%eax),%edx
    a61f:	8b 45 08             	mov    0x8(%ebp),%eax
    a622:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a624:	8b 45 20             	mov    0x20(%ebp),%eax
    a627:	8b 40 10             	mov    0x10(%eax),%eax
    a62a:	85 c0                	test   %eax,%eax
    a62c:	74 41                	je     a66f <getPixelColorRGBA8+0xfb>
    a62e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a631:	01 c0                	add    %eax,%eax
    a633:	89 c2                	mov    %eax,%edx
    a635:	8b 45 18             	mov    0x18(%ebp),%eax
    a638:	01 d0                	add    %edx,%eax
    a63a:	0f b6 00             	movzbl (%eax),%eax
    a63d:	0f b6 c0             	movzbl %al,%eax
    a640:	c1 e0 08             	shl    $0x8,%eax
    a643:	89 c2                	mov    %eax,%edx
    a645:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a648:	01 c0                	add    %eax,%eax
    a64a:	8d 48 01             	lea    0x1(%eax),%ecx
    a64d:	8b 45 18             	mov    0x18(%ebp),%eax
    a650:	01 c8                	add    %ecx,%eax
    a652:	0f b6 00             	movzbl (%eax),%eax
    a655:	0f b6 c0             	movzbl %al,%eax
    a658:	01 c2                	add    %eax,%edx
    a65a:	8b 45 20             	mov    0x20(%ebp),%eax
    a65d:	8b 40 14             	mov    0x14(%eax),%eax
    a660:	39 c2                	cmp    %eax,%edx
    a662:	75 0b                	jne    a66f <getPixelColorRGBA8+0xfb>
    a664:	8b 45 14             	mov    0x14(%ebp),%eax
    a667:	c6 00 00             	movb   $0x0,(%eax)
    a66a:	e9 cf 04 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a66f:	8b 45 14             	mov    0x14(%ebp),%eax
    a672:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a675:	e9 c4 04 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a67a:	8b 45 20             	mov    0x20(%ebp),%eax
    a67d:	8b 40 04             	mov    0x4(%eax),%eax
    a680:	ba 01 00 00 00       	mov    $0x1,%edx
    a685:	89 c1                	mov    %eax,%ecx
    a687:	d3 e2                	shl    %cl,%edx
    a689:	89 d0                	mov    %edx,%eax
    a68b:	83 e8 01             	sub    $0x1,%eax
    a68e:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a691:	8b 45 20             	mov    0x20(%ebp),%eax
    a694:	8b 50 04             	mov    0x4(%eax),%edx
    a697:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a69a:	0f af c2             	imul   %edx,%eax
    a69d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a6a0:	8b 45 20             	mov    0x20(%ebp),%eax
    a6a3:	8b 40 04             	mov    0x4(%eax),%eax
    a6a6:	50                   	push   %eax
    a6a7:	ff 75 18             	pushl  0x18(%ebp)
    a6aa:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a6ad:	50                   	push   %eax
    a6ae:	e8 06 db ff ff       	call   81b9 <readBitsFromReversedStream>
    a6b3:	83 c4 0c             	add    $0xc,%esp
    a6b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a6b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a6bc:	89 d0                	mov    %edx,%eax
    a6be:	c1 e0 08             	shl    $0x8,%eax
    a6c1:	29 d0                	sub    %edx,%eax
    a6c3:	ba 00 00 00 00       	mov    $0x0,%edx
    a6c8:	f7 75 f8             	divl   -0x8(%ebp)
    a6cb:	89 c2                	mov    %eax,%edx
    a6cd:	8b 45 10             	mov    0x10(%ebp),%eax
    a6d0:	88 10                	mov    %dl,(%eax)
    a6d2:	8b 45 10             	mov    0x10(%ebp),%eax
    a6d5:	0f b6 10             	movzbl (%eax),%edx
    a6d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6db:	88 10                	mov    %dl,(%eax)
    a6dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6e0:	0f b6 10             	movzbl (%eax),%edx
    a6e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a6e6:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a6e8:	8b 45 20             	mov    0x20(%ebp),%eax
    a6eb:	8b 40 10             	mov    0x10(%eax),%eax
    a6ee:	85 c0                	test   %eax,%eax
    a6f0:	74 16                	je     a708 <getPixelColorRGBA8+0x194>
    a6f2:	8b 45 20             	mov    0x20(%ebp),%eax
    a6f5:	8b 40 14             	mov    0x14(%eax),%eax
    a6f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a6fb:	75 0b                	jne    a708 <getPixelColorRGBA8+0x194>
    a6fd:	8b 45 14             	mov    0x14(%ebp),%eax
    a700:	c6 00 00             	movb   $0x0,(%eax)
    a703:	e9 36 04 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a708:	8b 45 14             	mov    0x14(%ebp),%eax
    a70b:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a70e:	e9 2b 04 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a713:	8b 45 20             	mov    0x20(%ebp),%eax
    a716:	8b 00                	mov    (%eax),%eax
    a718:	83 f8 02             	cmp    $0x2,%eax
    a71b:	0f 85 f5 01 00 00    	jne    a916 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a721:	8b 45 20             	mov    0x20(%ebp),%eax
    a724:	8b 40 04             	mov    0x4(%eax),%eax
    a727:	83 f8 08             	cmp    $0x8,%eax
    a72a:	0f 85 a3 00 00 00    	jne    a7d3 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a730:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a733:	89 d0                	mov    %edx,%eax
    a735:	01 c0                	add    %eax,%eax
    a737:	01 d0                	add    %edx,%eax
    a739:	89 c2                	mov    %eax,%edx
    a73b:	8b 45 18             	mov    0x18(%ebp),%eax
    a73e:	01 d0                	add    %edx,%eax
    a740:	0f b6 10             	movzbl (%eax),%edx
    a743:	8b 45 08             	mov    0x8(%ebp),%eax
    a746:	88 10                	mov    %dl,(%eax)
    a748:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a74b:	89 d0                	mov    %edx,%eax
    a74d:	01 c0                	add    %eax,%eax
    a74f:	01 d0                	add    %edx,%eax
    a751:	8d 50 01             	lea    0x1(%eax),%edx
    a754:	8b 45 18             	mov    0x18(%ebp),%eax
    a757:	01 d0                	add    %edx,%eax
    a759:	0f b6 10             	movzbl (%eax),%edx
    a75c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a75f:	88 10                	mov    %dl,(%eax)
    a761:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a764:	89 d0                	mov    %edx,%eax
    a766:	01 c0                	add    %eax,%eax
    a768:	01 d0                	add    %edx,%eax
    a76a:	8d 50 02             	lea    0x2(%eax),%edx
    a76d:	8b 45 18             	mov    0x18(%ebp),%eax
    a770:	01 d0                	add    %edx,%eax
    a772:	0f b6 10             	movzbl (%eax),%edx
    a775:	8b 45 10             	mov    0x10(%ebp),%eax
    a778:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a77a:	8b 45 20             	mov    0x20(%ebp),%eax
    a77d:	8b 40 10             	mov    0x10(%eax),%eax
    a780:	85 c0                	test   %eax,%eax
    a782:	74 44                	je     a7c8 <getPixelColorRGBA8+0x254>
    a784:	8b 45 08             	mov    0x8(%ebp),%eax
    a787:	0f b6 00             	movzbl (%eax),%eax
    a78a:	0f b6 d0             	movzbl %al,%edx
    a78d:	8b 45 20             	mov    0x20(%ebp),%eax
    a790:	8b 40 14             	mov    0x14(%eax),%eax
    a793:	39 c2                	cmp    %eax,%edx
    a795:	75 31                	jne    a7c8 <getPixelColorRGBA8+0x254>
    a797:	8b 45 0c             	mov    0xc(%ebp),%eax
    a79a:	0f b6 00             	movzbl (%eax),%eax
    a79d:	0f b6 d0             	movzbl %al,%edx
    a7a0:	8b 45 20             	mov    0x20(%ebp),%eax
    a7a3:	8b 40 18             	mov    0x18(%eax),%eax
    a7a6:	39 c2                	cmp    %eax,%edx
    a7a8:	75 1e                	jne    a7c8 <getPixelColorRGBA8+0x254>
    a7aa:	8b 45 10             	mov    0x10(%ebp),%eax
    a7ad:	0f b6 00             	movzbl (%eax),%eax
    a7b0:	0f b6 d0             	movzbl %al,%edx
    a7b3:	8b 45 20             	mov    0x20(%ebp),%eax
    a7b6:	8b 40 1c             	mov    0x1c(%eax),%eax
    a7b9:	39 c2                	cmp    %eax,%edx
    a7bb:	75 0b                	jne    a7c8 <getPixelColorRGBA8+0x254>
    a7bd:	8b 45 14             	mov    0x14(%ebp),%eax
    a7c0:	c6 00 00             	movb   $0x0,(%eax)
    a7c3:	e9 76 03 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7c8:	8b 45 14             	mov    0x14(%ebp),%eax
    a7cb:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7ce:	e9 6b 03 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a7d3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7d6:	89 d0                	mov    %edx,%eax
    a7d8:	01 c0                	add    %eax,%eax
    a7da:	01 d0                	add    %edx,%eax
    a7dc:	01 c0                	add    %eax,%eax
    a7de:	89 c2                	mov    %eax,%edx
    a7e0:	8b 45 18             	mov    0x18(%ebp),%eax
    a7e3:	01 d0                	add    %edx,%eax
    a7e5:	0f b6 10             	movzbl (%eax),%edx
    a7e8:	8b 45 08             	mov    0x8(%ebp),%eax
    a7eb:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a7ed:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7f0:	89 d0                	mov    %edx,%eax
    a7f2:	01 c0                	add    %eax,%eax
    a7f4:	01 d0                	add    %edx,%eax
    a7f6:	01 c0                	add    %eax,%eax
    a7f8:	8d 50 02             	lea    0x2(%eax),%edx
    a7fb:	8b 45 18             	mov    0x18(%ebp),%eax
    a7fe:	01 d0                	add    %edx,%eax
    a800:	0f b6 10             	movzbl (%eax),%edx
    a803:	8b 45 0c             	mov    0xc(%ebp),%eax
    a806:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a808:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a80b:	89 d0                	mov    %edx,%eax
    a80d:	01 c0                	add    %eax,%eax
    a80f:	01 d0                	add    %edx,%eax
    a811:	01 c0                	add    %eax,%eax
    a813:	8d 50 04             	lea    0x4(%eax),%edx
    a816:	8b 45 18             	mov    0x18(%ebp),%eax
    a819:	01 d0                	add    %edx,%eax
    a81b:	0f b6 10             	movzbl (%eax),%edx
    a81e:	8b 45 10             	mov    0x10(%ebp),%eax
    a821:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a823:	8b 45 20             	mov    0x20(%ebp),%eax
    a826:	8b 40 10             	mov    0x10(%eax),%eax
    a829:	85 c0                	test   %eax,%eax
    a82b:	0f 84 da 00 00 00    	je     a90b <getPixelColorRGBA8+0x397>
    a831:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a834:	89 d0                	mov    %edx,%eax
    a836:	01 c0                	add    %eax,%eax
    a838:	01 d0                	add    %edx,%eax
    a83a:	01 c0                	add    %eax,%eax
    a83c:	89 c2                	mov    %eax,%edx
    a83e:	8b 45 18             	mov    0x18(%ebp),%eax
    a841:	01 d0                	add    %edx,%eax
    a843:	0f b6 00             	movzbl (%eax),%eax
    a846:	0f b6 c0             	movzbl %al,%eax
    a849:	c1 e0 08             	shl    $0x8,%eax
    a84c:	89 c1                	mov    %eax,%ecx
    a84e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a851:	89 d0                	mov    %edx,%eax
    a853:	01 c0                	add    %eax,%eax
    a855:	01 d0                	add    %edx,%eax
    a857:	01 c0                	add    %eax,%eax
    a859:	8d 50 01             	lea    0x1(%eax),%edx
    a85c:	8b 45 18             	mov    0x18(%ebp),%eax
    a85f:	01 d0                	add    %edx,%eax
    a861:	0f b6 00             	movzbl (%eax),%eax
    a864:	0f b6 c0             	movzbl %al,%eax
    a867:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a86a:	8b 45 20             	mov    0x20(%ebp),%eax
    a86d:	8b 40 14             	mov    0x14(%eax),%eax
    a870:	39 c2                	cmp    %eax,%edx
    a872:	0f 85 93 00 00 00    	jne    a90b <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a878:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a87b:	89 d0                	mov    %edx,%eax
    a87d:	01 c0                	add    %eax,%eax
    a87f:	01 d0                	add    %edx,%eax
    a881:	01 c0                	add    %eax,%eax
    a883:	8d 50 02             	lea    0x2(%eax),%edx
    a886:	8b 45 18             	mov    0x18(%ebp),%eax
    a889:	01 d0                	add    %edx,%eax
    a88b:	0f b6 00             	movzbl (%eax),%eax
    a88e:	0f b6 c0             	movzbl %al,%eax
    a891:	c1 e0 08             	shl    $0x8,%eax
    a894:	89 c1                	mov    %eax,%ecx
    a896:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a899:	89 d0                	mov    %edx,%eax
    a89b:	01 c0                	add    %eax,%eax
    a89d:	01 d0                	add    %edx,%eax
    a89f:	01 c0                	add    %eax,%eax
    a8a1:	8d 50 03             	lea    0x3(%eax),%edx
    a8a4:	8b 45 18             	mov    0x18(%ebp),%eax
    a8a7:	01 d0                	add    %edx,%eax
    a8a9:	0f b6 00             	movzbl (%eax),%eax
    a8ac:	0f b6 c0             	movzbl %al,%eax
    a8af:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a8b2:	8b 45 20             	mov    0x20(%ebp),%eax
    a8b5:	8b 40 18             	mov    0x18(%eax),%eax
    a8b8:	39 c2                	cmp    %eax,%edx
    a8ba:	75 4f                	jne    a90b <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a8bc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8bf:	89 d0                	mov    %edx,%eax
    a8c1:	01 c0                	add    %eax,%eax
    a8c3:	01 d0                	add    %edx,%eax
    a8c5:	01 c0                	add    %eax,%eax
    a8c7:	8d 50 04             	lea    0x4(%eax),%edx
    a8ca:	8b 45 18             	mov    0x18(%ebp),%eax
    a8cd:	01 d0                	add    %edx,%eax
    a8cf:	0f b6 00             	movzbl (%eax),%eax
    a8d2:	0f b6 c0             	movzbl %al,%eax
    a8d5:	c1 e0 08             	shl    $0x8,%eax
    a8d8:	89 c1                	mov    %eax,%ecx
    a8da:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8dd:	89 d0                	mov    %edx,%eax
    a8df:	01 c0                	add    %eax,%eax
    a8e1:	01 d0                	add    %edx,%eax
    a8e3:	01 c0                	add    %eax,%eax
    a8e5:	8d 50 05             	lea    0x5(%eax),%edx
    a8e8:	8b 45 18             	mov    0x18(%ebp),%eax
    a8eb:	01 d0                	add    %edx,%eax
    a8ed:	0f b6 00             	movzbl (%eax),%eax
    a8f0:	0f b6 c0             	movzbl %al,%eax
    a8f3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a8f6:	8b 45 20             	mov    0x20(%ebp),%eax
    a8f9:	8b 40 1c             	mov    0x1c(%eax),%eax
    a8fc:	39 c2                	cmp    %eax,%edx
    a8fe:	75 0b                	jne    a90b <getPixelColorRGBA8+0x397>
    a900:	8b 45 14             	mov    0x14(%ebp),%eax
    a903:	c6 00 00             	movb   $0x0,(%eax)
    a906:	e9 33 02 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a90b:	8b 45 14             	mov    0x14(%ebp),%eax
    a90e:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a911:	e9 28 02 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a916:	8b 45 20             	mov    0x20(%ebp),%eax
    a919:	8b 00                	mov    (%eax),%eax
    a91b:	83 f8 03             	cmp    $0x3,%eax
    a91e:	0f 85 ac 00 00 00    	jne    a9d0 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    a924:	8b 45 20             	mov    0x20(%ebp),%eax
    a927:	8b 40 04             	mov    0x4(%eax),%eax
    a92a:	83 f8 08             	cmp    $0x8,%eax
    a92d:	75 13                	jne    a942 <getPixelColorRGBA8+0x3ce>
    a92f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a932:	8b 45 18             	mov    0x18(%ebp),%eax
    a935:	01 d0                	add    %edx,%eax
    a937:	0f b6 00             	movzbl (%eax),%eax
    a93a:	0f b6 c0             	movzbl %al,%eax
    a93d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a940:	eb 28                	jmp    a96a <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    a942:	8b 45 20             	mov    0x20(%ebp),%eax
    a945:	8b 50 04             	mov    0x4(%eax),%edx
    a948:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a94b:	0f af c2             	imul   %edx,%eax
    a94e:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a951:	8b 45 20             	mov    0x20(%ebp),%eax
    a954:	8b 40 04             	mov    0x4(%eax),%eax
    a957:	50                   	push   %eax
    a958:	ff 75 18             	pushl  0x18(%ebp)
    a95b:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a95e:	50                   	push   %eax
    a95f:	e8 55 d8 ff ff       	call   81b9 <readBitsFromReversedStream>
    a964:	83 c4 0c             	add    $0xc,%esp
    a967:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    a96a:	8b 45 20             	mov    0x20(%ebp),%eax
    a96d:	8b 40 08             	mov    0x8(%eax),%eax
    a970:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a973:	c1 e2 02             	shl    $0x2,%edx
    a976:	01 d0                	add    %edx,%eax
    a978:	0f b6 10             	movzbl (%eax),%edx
    a97b:	8b 45 08             	mov    0x8(%ebp),%eax
    a97e:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    a980:	8b 45 20             	mov    0x20(%ebp),%eax
    a983:	8b 40 08             	mov    0x8(%eax),%eax
    a986:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a989:	c1 e2 02             	shl    $0x2,%edx
    a98c:	83 c2 01             	add    $0x1,%edx
    a98f:	01 d0                	add    %edx,%eax
    a991:	0f b6 10             	movzbl (%eax),%edx
    a994:	8b 45 0c             	mov    0xc(%ebp),%eax
    a997:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    a999:	8b 45 20             	mov    0x20(%ebp),%eax
    a99c:	8b 40 08             	mov    0x8(%eax),%eax
    a99f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9a2:	c1 e2 02             	shl    $0x2,%edx
    a9a5:	83 c2 02             	add    $0x2,%edx
    a9a8:	01 d0                	add    %edx,%eax
    a9aa:	0f b6 10             	movzbl (%eax),%edx
    a9ad:	8b 45 10             	mov    0x10(%ebp),%eax
    a9b0:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    a9b2:	8b 45 20             	mov    0x20(%ebp),%eax
    a9b5:	8b 40 08             	mov    0x8(%eax),%eax
    a9b8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9bb:	c1 e2 02             	shl    $0x2,%edx
    a9be:	83 c2 03             	add    $0x3,%edx
    a9c1:	01 d0                	add    %edx,%eax
    a9c3:	0f b6 10             	movzbl (%eax),%edx
    a9c6:	8b 45 14             	mov    0x14(%ebp),%eax
    a9c9:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9cb:	e9 6e 01 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a9d0:	8b 45 20             	mov    0x20(%ebp),%eax
    a9d3:	8b 00                	mov    (%eax),%eax
    a9d5:	83 f8 04             	cmp    $0x4,%eax
    a9d8:	0f 85 95 00 00 00    	jne    aa73 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    a9de:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e1:	8b 40 04             	mov    0x4(%eax),%eax
    a9e4:	83 f8 08             	cmp    $0x8,%eax
    a9e7:	75 44                	jne    aa2d <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    a9e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9ec:	01 c0                	add    %eax,%eax
    a9ee:	89 c2                	mov    %eax,%edx
    a9f0:	8b 45 18             	mov    0x18(%ebp),%eax
    a9f3:	01 d0                	add    %edx,%eax
    a9f5:	0f b6 10             	movzbl (%eax),%edx
    a9f8:	8b 45 10             	mov    0x10(%ebp),%eax
    a9fb:	88 10                	mov    %dl,(%eax)
    a9fd:	8b 45 10             	mov    0x10(%ebp),%eax
    aa00:	0f b6 10             	movzbl (%eax),%edx
    aa03:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa06:	88 10                	mov    %dl,(%eax)
    aa08:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa0b:	0f b6 10             	movzbl (%eax),%edx
    aa0e:	8b 45 08             	mov    0x8(%ebp),%eax
    aa11:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    aa13:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa16:	01 c0                	add    %eax,%eax
    aa18:	8d 50 01             	lea    0x1(%eax),%edx
    aa1b:	8b 45 18             	mov    0x18(%ebp),%eax
    aa1e:	01 d0                	add    %edx,%eax
    aa20:	0f b6 10             	movzbl (%eax),%edx
    aa23:	8b 45 14             	mov    0x14(%ebp),%eax
    aa26:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa28:	e9 11 01 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    aa2d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa30:	c1 e0 02             	shl    $0x2,%eax
    aa33:	89 c2                	mov    %eax,%edx
    aa35:	8b 45 18             	mov    0x18(%ebp),%eax
    aa38:	01 d0                	add    %edx,%eax
    aa3a:	0f b6 10             	movzbl (%eax),%edx
    aa3d:	8b 45 10             	mov    0x10(%ebp),%eax
    aa40:	88 10                	mov    %dl,(%eax)
    aa42:	8b 45 10             	mov    0x10(%ebp),%eax
    aa45:	0f b6 10             	movzbl (%eax),%edx
    aa48:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa4b:	88 10                	mov    %dl,(%eax)
    aa4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa50:	0f b6 10             	movzbl (%eax),%edx
    aa53:	8b 45 08             	mov    0x8(%ebp),%eax
    aa56:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    aa58:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa5b:	c1 e0 02             	shl    $0x2,%eax
    aa5e:	8d 50 02             	lea    0x2(%eax),%edx
    aa61:	8b 45 18             	mov    0x18(%ebp),%eax
    aa64:	01 d0                	add    %edx,%eax
    aa66:	0f b6 10             	movzbl (%eax),%edx
    aa69:	8b 45 14             	mov    0x14(%ebp),%eax
    aa6c:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa6e:	e9 cb 00 00 00       	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    aa73:	8b 45 20             	mov    0x20(%ebp),%eax
    aa76:	8b 00                	mov    (%eax),%eax
    aa78:	83 f8 06             	cmp    $0x6,%eax
    aa7b:	0f 85 bd 00 00 00    	jne    ab3e <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    aa81:	8b 45 20             	mov    0x20(%ebp),%eax
    aa84:	8b 40 04             	mov    0x4(%eax),%eax
    aa87:	83 f8 08             	cmp    $0x8,%eax
    aa8a:	75 59                	jne    aae5 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    aa8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa8f:	c1 e0 02             	shl    $0x2,%eax
    aa92:	89 c2                	mov    %eax,%edx
    aa94:	8b 45 18             	mov    0x18(%ebp),%eax
    aa97:	01 d0                	add    %edx,%eax
    aa99:	0f b6 10             	movzbl (%eax),%edx
    aa9c:	8b 45 08             	mov    0x8(%ebp),%eax
    aa9f:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    aaa1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaa4:	c1 e0 02             	shl    $0x2,%eax
    aaa7:	8d 50 01             	lea    0x1(%eax),%edx
    aaaa:	8b 45 18             	mov    0x18(%ebp),%eax
    aaad:	01 d0                	add    %edx,%eax
    aaaf:	0f b6 10             	movzbl (%eax),%edx
    aab2:	8b 45 0c             	mov    0xc(%ebp),%eax
    aab5:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    aab7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaba:	c1 e0 02             	shl    $0x2,%eax
    aabd:	8d 50 02             	lea    0x2(%eax),%edx
    aac0:	8b 45 18             	mov    0x18(%ebp),%eax
    aac3:	01 d0                	add    %edx,%eax
    aac5:	0f b6 10             	movzbl (%eax),%edx
    aac8:	8b 45 10             	mov    0x10(%ebp),%eax
    aacb:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    aacd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aad0:	c1 e0 02             	shl    $0x2,%eax
    aad3:	8d 50 03             	lea    0x3(%eax),%edx
    aad6:	8b 45 18             	mov    0x18(%ebp),%eax
    aad9:	01 d0                	add    %edx,%eax
    aadb:	0f b6 10             	movzbl (%eax),%edx
    aade:	8b 45 14             	mov    0x14(%ebp),%eax
    aae1:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aae3:	eb 59                	jmp    ab3e <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    aae5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aae8:	c1 e0 03             	shl    $0x3,%eax
    aaeb:	89 c2                	mov    %eax,%edx
    aaed:	8b 45 18             	mov    0x18(%ebp),%eax
    aaf0:	01 d0                	add    %edx,%eax
    aaf2:	0f b6 10             	movzbl (%eax),%edx
    aaf5:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf8:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    aafa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aafd:	c1 e0 03             	shl    $0x3,%eax
    ab00:	8d 50 02             	lea    0x2(%eax),%edx
    ab03:	8b 45 18             	mov    0x18(%ebp),%eax
    ab06:	01 d0                	add    %edx,%eax
    ab08:	0f b6 10             	movzbl (%eax),%edx
    ab0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab0e:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    ab10:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab13:	c1 e0 03             	shl    $0x3,%eax
    ab16:	8d 50 04             	lea    0x4(%eax),%edx
    ab19:	8b 45 18             	mov    0x18(%ebp),%eax
    ab1c:	01 d0                	add    %edx,%eax
    ab1e:	0f b6 10             	movzbl (%eax),%edx
    ab21:	8b 45 10             	mov    0x10(%ebp),%eax
    ab24:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    ab26:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab29:	c1 e0 03             	shl    $0x3,%eax
    ab2c:	8d 50 06             	lea    0x6(%eax),%edx
    ab2f:	8b 45 18             	mov    0x18(%ebp),%eax
    ab32:	01 d0                	add    %edx,%eax
    ab34:	0f b6 10             	movzbl (%eax),%edx
    ab37:	8b 45 14             	mov    0x14(%ebp),%eax
    ab3a:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ab3c:	eb 00                	jmp    ab3e <getPixelColorRGBA8+0x5ca>
    ab3e:	90                   	nop
    ab3f:	c9                   	leave  
    ab40:	c3                   	ret    

0000ab41 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ab41:	55                   	push   %ebp
    ab42:	89 e5                	mov    %esp,%ebp
    ab44:	53                   	push   %ebx
    ab45:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ab48:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ab4f:	8b 45 14             	mov    0x14(%ebp),%eax
    ab52:	8b 00                	mov    (%eax),%eax
    ab54:	85 c0                	test   %eax,%eax
    ab56:	0f 85 14 02 00 00    	jne    ad70 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ab5c:	8b 45 14             	mov    0x14(%ebp),%eax
    ab5f:	8b 40 04             	mov    0x4(%eax),%eax
    ab62:	83 f8 08             	cmp    $0x8,%eax
    ab65:	0f 85 a0 00 00 00    	jne    ac0b <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ab6b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ab72:	eb 39                	jmp    abad <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ab74:	8b 45 08             	mov    0x8(%ebp),%eax
    ab77:	83 c0 01             	add    $0x1,%eax
    ab7a:	8b 55 08             	mov    0x8(%ebp),%edx
    ab7d:	83 c2 02             	add    $0x2,%edx
    ab80:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ab83:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ab86:	01 d9                	add    %ebx,%ecx
    ab88:	0f b6 09             	movzbl (%ecx),%ecx
    ab8b:	88 0a                	mov    %cl,(%edx)
    ab8d:	0f b6 12             	movzbl (%edx),%edx
    ab90:	88 10                	mov    %dl,(%eax)
    ab92:	0f b6 10             	movzbl (%eax),%edx
    ab95:	8b 45 08             	mov    0x8(%ebp),%eax
    ab98:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    ab9a:	8b 45 08             	mov    0x8(%ebp),%eax
    ab9d:	83 c0 03             	add    $0x3,%eax
    aba0:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aba3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    abaa:	01 45 08             	add    %eax,0x8(%ebp)
    abad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    abb0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    abb3:	75 bf                	jne    ab74 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    abb5:	8b 45 14             	mov    0x14(%ebp),%eax
    abb8:	8b 40 10             	mov    0x10(%eax),%eax
    abbb:	85 c0                	test   %eax,%eax
    abbd:	0f 84 48 06 00 00    	je     b20b <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    abc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    abc6:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    abca:	f7 d8                	neg    %eax
    abcc:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abcf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    abd6:	eb 26                	jmp    abfe <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    abd8:	8b 45 08             	mov    0x8(%ebp),%eax
    abdb:	0f b6 00             	movzbl (%eax),%eax
    abde:	0f b6 d0             	movzbl %al,%edx
    abe1:	8b 45 14             	mov    0x14(%ebp),%eax
    abe4:	8b 40 14             	mov    0x14(%eax),%eax
    abe7:	39 c2                	cmp    %eax,%edx
    abe9:	75 09                	jne    abf4 <getPixelColorsRGBA8+0xb3>
    abeb:	8b 45 08             	mov    0x8(%ebp),%eax
    abee:	83 c0 03             	add    $0x3,%eax
    abf1:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abf4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    abf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    abfb:	01 45 08             	add    %eax,0x8(%ebp)
    abfe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac01:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ac04:	75 d2                	jne    abd8 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ac06:	e9 00 06 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    ac0b:	8b 45 14             	mov    0x14(%ebp),%eax
    ac0e:	8b 40 04             	mov    0x4(%eax),%eax
    ac11:	83 f8 10             	cmp    $0x10,%eax
    ac14:	0f 85 a5 00 00 00    	jne    acbf <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac1a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac21:	e9 88 00 00 00       	jmp    acae <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    ac26:	8b 45 08             	mov    0x8(%ebp),%eax
    ac29:	83 c0 01             	add    $0x1,%eax
    ac2c:	8b 55 08             	mov    0x8(%ebp),%edx
    ac2f:	83 c2 02             	add    $0x2,%edx
    ac32:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ac35:	01 c9                	add    %ecx,%ecx
    ac37:	89 cb                	mov    %ecx,%ebx
    ac39:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac3c:	01 d9                	add    %ebx,%ecx
    ac3e:	0f b6 09             	movzbl (%ecx),%ecx
    ac41:	88 0a                	mov    %cl,(%edx)
    ac43:	0f b6 12             	movzbl (%edx),%edx
    ac46:	88 10                	mov    %dl,(%eax)
    ac48:	0f b6 10             	movzbl (%eax),%edx
    ac4b:	8b 45 08             	mov    0x8(%ebp),%eax
    ac4e:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    ac50:	8b 45 08             	mov    0x8(%ebp),%eax
    ac53:	8d 50 03             	lea    0x3(%eax),%edx
    ac56:	8b 45 14             	mov    0x14(%ebp),%eax
    ac59:	8b 40 10             	mov    0x10(%eax),%eax
    ac5c:	85 c0                	test   %eax,%eax
    ac5e:	74 3d                	je     ac9d <getPixelColorsRGBA8+0x15c>
    ac60:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac63:	01 c0                	add    %eax,%eax
    ac65:	89 c1                	mov    %eax,%ecx
    ac67:	8b 45 10             	mov    0x10(%ebp),%eax
    ac6a:	01 c8                	add    %ecx,%eax
    ac6c:	0f b6 00             	movzbl (%eax),%eax
    ac6f:	0f b6 c0             	movzbl %al,%eax
    ac72:	c1 e0 08             	shl    $0x8,%eax
    ac75:	89 c1                	mov    %eax,%ecx
    ac77:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac7a:	01 c0                	add    %eax,%eax
    ac7c:	8d 58 01             	lea    0x1(%eax),%ebx
    ac7f:	8b 45 10             	mov    0x10(%ebp),%eax
    ac82:	01 d8                	add    %ebx,%eax
    ac84:	0f b6 00             	movzbl (%eax),%eax
    ac87:	0f b6 c0             	movzbl %al,%eax
    ac8a:	01 c1                	add    %eax,%ecx
    ac8c:	8b 45 14             	mov    0x14(%ebp),%eax
    ac8f:	8b 40 14             	mov    0x14(%eax),%eax
    ac92:	39 c1                	cmp    %eax,%ecx
    ac94:	75 07                	jne    ac9d <getPixelColorsRGBA8+0x15c>
    ac96:	b8 00 00 00 00       	mov    $0x0,%eax
    ac9b:	eb 05                	jmp    aca2 <getPixelColorsRGBA8+0x161>
    ac9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    aca2:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aca4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aca8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    acab:	01 45 08             	add    %eax,0x8(%ebp)
    acae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    acb1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    acb4:	0f 85 6c ff ff ff    	jne    ac26 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    acba:	e9 4c 05 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    acbf:	8b 45 14             	mov    0x14(%ebp),%eax
    acc2:	8b 40 04             	mov    0x4(%eax),%eax
    acc5:	ba 01 00 00 00       	mov    $0x1,%edx
    acca:	89 c1                	mov    %eax,%ecx
    accc:	d3 e2                	shl    %cl,%edx
    acce:	89 d0                	mov    %edx,%eax
    acd0:	83 e8 01             	sub    $0x1,%eax
    acd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    acd6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acdd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ace4:	eb 79                	jmp    ad5f <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ace6:	8b 45 14             	mov    0x14(%ebp),%eax
    ace9:	8b 40 04             	mov    0x4(%eax),%eax
    acec:	50                   	push   %eax
    aced:	ff 75 10             	pushl  0x10(%ebp)
    acf0:	8d 45 e0             	lea    -0x20(%ebp),%eax
    acf3:	50                   	push   %eax
    acf4:	e8 c0 d4 ff ff       	call   81b9 <readBitsFromReversedStream>
    acf9:	83 c4 0c             	add    $0xc,%esp
    acfc:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    acff:	8b 45 08             	mov    0x8(%ebp),%eax
    ad02:	8d 48 01             	lea    0x1(%eax),%ecx
    ad05:	8b 45 08             	mov    0x8(%ebp),%eax
    ad08:	8d 58 02             	lea    0x2(%eax),%ebx
    ad0b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ad0e:	89 d0                	mov    %edx,%eax
    ad10:	c1 e0 08             	shl    $0x8,%eax
    ad13:	29 d0                	sub    %edx,%eax
    ad15:	ba 00 00 00 00       	mov    $0x0,%edx
    ad1a:	f7 75 f0             	divl   -0x10(%ebp)
    ad1d:	88 03                	mov    %al,(%ebx)
    ad1f:	0f b6 03             	movzbl (%ebx),%eax
    ad22:	88 01                	mov    %al,(%ecx)
    ad24:	0f b6 11             	movzbl (%ecx),%edx
    ad27:	8b 45 08             	mov    0x8(%ebp),%eax
    ad2a:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    ad2c:	8b 45 08             	mov    0x8(%ebp),%eax
    ad2f:	8d 50 03             	lea    0x3(%eax),%edx
    ad32:	8b 45 14             	mov    0x14(%ebp),%eax
    ad35:	8b 40 10             	mov    0x10(%eax),%eax
    ad38:	85 c0                	test   %eax,%eax
    ad3a:	74 12                	je     ad4e <getPixelColorsRGBA8+0x20d>
    ad3c:	8b 45 14             	mov    0x14(%ebp),%eax
    ad3f:	8b 40 14             	mov    0x14(%eax),%eax
    ad42:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ad45:	75 07                	jne    ad4e <getPixelColorsRGBA8+0x20d>
    ad47:	b8 00 00 00 00       	mov    $0x0,%eax
    ad4c:	eb 05                	jmp    ad53 <getPixelColorsRGBA8+0x212>
    ad4e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad53:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad55:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad5c:	01 45 08             	add    %eax,0x8(%ebp)
    ad5f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad62:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad65:	0f 85 7b ff ff ff    	jne    ace6 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad6b:	e9 9b 04 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ad70:	8b 45 14             	mov    0x14(%ebp),%eax
    ad73:	8b 00                	mov    (%eax),%eax
    ad75:	83 f8 02             	cmp    $0x2,%eax
    ad78:	0f 85 41 02 00 00    	jne    afbf <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ad7e:	8b 45 14             	mov    0x14(%ebp),%eax
    ad81:	8b 40 04             	mov    0x4(%eax),%eax
    ad84:	83 f8 08             	cmp    $0x8,%eax
    ad87:	0f 85 c4 00 00 00    	jne    ae51 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad8d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad94:	eb 31                	jmp    adc7 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    ad96:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ad99:	89 d0                	mov    %edx,%eax
    ad9b:	01 c0                	add    %eax,%eax
    ad9d:	01 d0                	add    %edx,%eax
    ad9f:	89 c2                	mov    %eax,%edx
    ada1:	8b 45 10             	mov    0x10(%ebp),%eax
    ada4:	01 d0                	add    %edx,%eax
    ada6:	6a 03                	push   $0x3
    ada8:	50                   	push   %eax
    ada9:	ff 75 08             	pushl  0x8(%ebp)
    adac:	e8 a3 85 ff ff       	call   3354 <lodepng_memcpy>
    adb1:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    adb4:	8b 45 08             	mov    0x8(%ebp),%eax
    adb7:	83 c0 03             	add    $0x3,%eax
    adba:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adbd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    adc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    adc4:	01 45 08             	add    %eax,0x8(%ebp)
    adc7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    adca:	3b 45 0c             	cmp    0xc(%ebp),%eax
    adcd:	75 c7                	jne    ad96 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    adcf:	8b 45 14             	mov    0x14(%ebp),%eax
    add2:	8b 40 10             	mov    0x10(%eax),%eax
    add5:	85 c0                	test   %eax,%eax
    add7:	0f 84 2e 04 00 00    	je     b20b <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    addd:	8b 45 0c             	mov    0xc(%ebp),%eax
    ade0:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ade4:	f7 d8                	neg    %eax
    ade6:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ade9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    adf0:	eb 52                	jmp    ae44 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    adf2:	8b 45 08             	mov    0x8(%ebp),%eax
    adf5:	0f b6 00             	movzbl (%eax),%eax
    adf8:	0f b6 d0             	movzbl %al,%edx
    adfb:	8b 45 14             	mov    0x14(%ebp),%eax
    adfe:	8b 40 14             	mov    0x14(%eax),%eax
    ae01:	39 c2                	cmp    %eax,%edx
    ae03:	75 35                	jne    ae3a <getPixelColorsRGBA8+0x2f9>
    ae05:	8b 45 08             	mov    0x8(%ebp),%eax
    ae08:	83 c0 01             	add    $0x1,%eax
    ae0b:	0f b6 00             	movzbl (%eax),%eax
    ae0e:	0f b6 d0             	movzbl %al,%edx
    ae11:	8b 45 14             	mov    0x14(%ebp),%eax
    ae14:	8b 40 18             	mov    0x18(%eax),%eax
    ae17:	39 c2                	cmp    %eax,%edx
    ae19:	75 1f                	jne    ae3a <getPixelColorsRGBA8+0x2f9>
    ae1b:	8b 45 08             	mov    0x8(%ebp),%eax
    ae1e:	83 c0 02             	add    $0x2,%eax
    ae21:	0f b6 00             	movzbl (%eax),%eax
    ae24:	0f b6 d0             	movzbl %al,%edx
    ae27:	8b 45 14             	mov    0x14(%ebp),%eax
    ae2a:	8b 40 1c             	mov    0x1c(%eax),%eax
    ae2d:	39 c2                	cmp    %eax,%edx
    ae2f:	75 09                	jne    ae3a <getPixelColorsRGBA8+0x2f9>
    ae31:	8b 45 08             	mov    0x8(%ebp),%eax
    ae34:	83 c0 03             	add    $0x3,%eax
    ae37:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae3a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae41:	01 45 08             	add    %eax,0x8(%ebp)
    ae44:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae47:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae4a:	75 a6                	jne    adf2 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae4c:	e9 ba 03 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae51:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae58:	e9 51 01 00 00       	jmp    afae <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    ae5d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae60:	89 d0                	mov    %edx,%eax
    ae62:	01 c0                	add    %eax,%eax
    ae64:	01 d0                	add    %edx,%eax
    ae66:	01 c0                	add    %eax,%eax
    ae68:	89 c2                	mov    %eax,%edx
    ae6a:	8b 45 10             	mov    0x10(%ebp),%eax
    ae6d:	01 d0                	add    %edx,%eax
    ae6f:	0f b6 10             	movzbl (%eax),%edx
    ae72:	8b 45 08             	mov    0x8(%ebp),%eax
    ae75:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    ae77:	8b 45 08             	mov    0x8(%ebp),%eax
    ae7a:	8d 48 01             	lea    0x1(%eax),%ecx
    ae7d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae80:	89 d0                	mov    %edx,%eax
    ae82:	01 c0                	add    %eax,%eax
    ae84:	01 d0                	add    %edx,%eax
    ae86:	01 c0                	add    %eax,%eax
    ae88:	8d 50 02             	lea    0x2(%eax),%edx
    ae8b:	8b 45 10             	mov    0x10(%ebp),%eax
    ae8e:	01 d0                	add    %edx,%eax
    ae90:	0f b6 00             	movzbl (%eax),%eax
    ae93:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    ae95:	8b 45 08             	mov    0x8(%ebp),%eax
    ae98:	8d 48 02             	lea    0x2(%eax),%ecx
    ae9b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae9e:	89 d0                	mov    %edx,%eax
    aea0:	01 c0                	add    %eax,%eax
    aea2:	01 d0                	add    %edx,%eax
    aea4:	01 c0                	add    %eax,%eax
    aea6:	8d 50 04             	lea    0x4(%eax),%edx
    aea9:	8b 45 10             	mov    0x10(%ebp),%eax
    aeac:	01 d0                	add    %edx,%eax
    aeae:	0f b6 00             	movzbl (%eax),%eax
    aeb1:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    aeb3:	8b 45 08             	mov    0x8(%ebp),%eax
    aeb6:	8d 48 03             	lea    0x3(%eax),%ecx
    aeb9:	8b 45 14             	mov    0x14(%ebp),%eax
    aebc:	8b 40 10             	mov    0x10(%eax),%eax
    aebf:	85 c0                	test   %eax,%eax
    aec1:	0f 84 d6 00 00 00    	je     af9d <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    aec7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aeca:	89 d0                	mov    %edx,%eax
    aecc:	01 c0                	add    %eax,%eax
    aece:	01 d0                	add    %edx,%eax
    aed0:	01 c0                	add    %eax,%eax
    aed2:	89 c2                	mov    %eax,%edx
    aed4:	8b 45 10             	mov    0x10(%ebp),%eax
    aed7:	01 d0                	add    %edx,%eax
    aed9:	0f b6 00             	movzbl (%eax),%eax
    aedc:	0f b6 c0             	movzbl %al,%eax
    aedf:	c1 e0 08             	shl    $0x8,%eax
    aee2:	89 c3                	mov    %eax,%ebx
    aee4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aee7:	89 d0                	mov    %edx,%eax
    aee9:	01 c0                	add    %eax,%eax
    aeeb:	01 d0                	add    %edx,%eax
    aeed:	01 c0                	add    %eax,%eax
    aeef:	8d 50 01             	lea    0x1(%eax),%edx
    aef2:	8b 45 10             	mov    0x10(%ebp),%eax
    aef5:	01 d0                	add    %edx,%eax
    aef7:	0f b6 00             	movzbl (%eax),%eax
    aefa:	0f b6 c0             	movzbl %al,%eax
    aefd:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af00:	8b 45 14             	mov    0x14(%ebp),%eax
    af03:	8b 40 14             	mov    0x14(%eax),%eax
    af06:	39 c2                	cmp    %eax,%edx
    af08:	0f 85 8f 00 00 00    	jne    af9d <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    af0e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af11:	89 d0                	mov    %edx,%eax
    af13:	01 c0                	add    %eax,%eax
    af15:	01 d0                	add    %edx,%eax
    af17:	01 c0                	add    %eax,%eax
    af19:	8d 50 02             	lea    0x2(%eax),%edx
    af1c:	8b 45 10             	mov    0x10(%ebp),%eax
    af1f:	01 d0                	add    %edx,%eax
    af21:	0f b6 00             	movzbl (%eax),%eax
    af24:	0f b6 c0             	movzbl %al,%eax
    af27:	c1 e0 08             	shl    $0x8,%eax
    af2a:	89 c3                	mov    %eax,%ebx
    af2c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af2f:	89 d0                	mov    %edx,%eax
    af31:	01 c0                	add    %eax,%eax
    af33:	01 d0                	add    %edx,%eax
    af35:	01 c0                	add    %eax,%eax
    af37:	8d 50 03             	lea    0x3(%eax),%edx
    af3a:	8b 45 10             	mov    0x10(%ebp),%eax
    af3d:	01 d0                	add    %edx,%eax
    af3f:	0f b6 00             	movzbl (%eax),%eax
    af42:	0f b6 c0             	movzbl %al,%eax
    af45:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af48:	8b 45 14             	mov    0x14(%ebp),%eax
    af4b:	8b 40 18             	mov    0x18(%eax),%eax
    af4e:	39 c2                	cmp    %eax,%edx
    af50:	75 4b                	jne    af9d <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    af52:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af55:	89 d0                	mov    %edx,%eax
    af57:	01 c0                	add    %eax,%eax
    af59:	01 d0                	add    %edx,%eax
    af5b:	01 c0                	add    %eax,%eax
    af5d:	8d 50 04             	lea    0x4(%eax),%edx
    af60:	8b 45 10             	mov    0x10(%ebp),%eax
    af63:	01 d0                	add    %edx,%eax
    af65:	0f b6 00             	movzbl (%eax),%eax
    af68:	0f b6 c0             	movzbl %al,%eax
    af6b:	c1 e0 08             	shl    $0x8,%eax
    af6e:	89 c3                	mov    %eax,%ebx
    af70:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af73:	89 d0                	mov    %edx,%eax
    af75:	01 c0                	add    %eax,%eax
    af77:	01 d0                	add    %edx,%eax
    af79:	01 c0                	add    %eax,%eax
    af7b:	8d 50 05             	lea    0x5(%eax),%edx
    af7e:	8b 45 10             	mov    0x10(%ebp),%eax
    af81:	01 d0                	add    %edx,%eax
    af83:	0f b6 00             	movzbl (%eax),%eax
    af86:	0f b6 c0             	movzbl %al,%eax
    af89:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af8c:	8b 45 14             	mov    0x14(%ebp),%eax
    af8f:	8b 40 1c             	mov    0x1c(%eax),%eax
    af92:	39 c2                	cmp    %eax,%edx
    af94:	75 07                	jne    af9d <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    af96:	b8 00 00 00 00       	mov    $0x0,%eax
    af9b:	eb 05                	jmp    afa2 <getPixelColorsRGBA8+0x461>
    af9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    afa2:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afa4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    afa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    afab:	01 45 08             	add    %eax,0x8(%ebp)
    afae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    afb1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    afb4:	0f 85 a3 fe ff ff    	jne    ae5d <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    afba:	e9 4c 02 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    afbf:	8b 45 14             	mov    0x14(%ebp),%eax
    afc2:	8b 00                	mov    (%eax),%eax
    afc4:	83 f8 03             	cmp    $0x3,%eax
    afc7:	0f 85 b4 00 00 00    	jne    b081 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    afcd:	8b 45 14             	mov    0x14(%ebp),%eax
    afd0:	8b 40 04             	mov    0x4(%eax),%eax
    afd3:	83 f8 08             	cmp    $0x8,%eax
    afd6:	75 4d                	jne    b025 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afd8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afdf:	eb 37                	jmp    b018 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    afe1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afe4:	8b 45 10             	mov    0x10(%ebp),%eax
    afe7:	01 d0                	add    %edx,%eax
    afe9:	0f b6 00             	movzbl (%eax),%eax
    afec:	0f b6 c0             	movzbl %al,%eax
    afef:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    aff2:	8b 45 14             	mov    0x14(%ebp),%eax
    aff5:	8b 40 08             	mov    0x8(%eax),%eax
    aff8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    affb:	c1 e2 02             	shl    $0x2,%edx
    affe:	01 d0                	add    %edx,%eax
    b000:	6a 04                	push   $0x4
    b002:	50                   	push   %eax
    b003:	ff 75 08             	pushl  0x8(%ebp)
    b006:	e8 49 83 ff ff       	call   3354 <lodepng_memcpy>
    b00b:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b00e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b012:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b015:	01 45 08             	add    %eax,0x8(%ebp)
    b018:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b01b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b01e:	75 c1                	jne    afe1 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b020:	e9 e6 01 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b025:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b02c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b033:	eb 3f                	jmp    b074 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b035:	8b 45 14             	mov    0x14(%ebp),%eax
    b038:	8b 40 04             	mov    0x4(%eax),%eax
    b03b:	50                   	push   %eax
    b03c:	ff 75 10             	pushl  0x10(%ebp)
    b03f:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b042:	50                   	push   %eax
    b043:	e8 71 d1 ff ff       	call   81b9 <readBitsFromReversedStream>
    b048:	83 c4 0c             	add    $0xc,%esp
    b04b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b04e:	8b 45 14             	mov    0x14(%ebp),%eax
    b051:	8b 40 08             	mov    0x8(%eax),%eax
    b054:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b057:	c1 e2 02             	shl    $0x2,%edx
    b05a:	01 d0                	add    %edx,%eax
    b05c:	6a 04                	push   $0x4
    b05e:	50                   	push   %eax
    b05f:	ff 75 08             	pushl  0x8(%ebp)
    b062:	e8 ed 82 ff ff       	call   3354 <lodepng_memcpy>
    b067:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b06a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b06e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b071:	01 45 08             	add    %eax,0x8(%ebp)
    b074:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b077:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b07a:	75 b9                	jne    b035 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b07c:	e9 8a 01 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b081:	8b 45 14             	mov    0x14(%ebp),%eax
    b084:	8b 00                	mov    (%eax),%eax
    b086:	83 f8 04             	cmp    $0x4,%eax
    b089:	0f 85 d1 00 00 00    	jne    b160 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b08f:	8b 45 14             	mov    0x14(%ebp),%eax
    b092:	8b 40 04             	mov    0x4(%eax),%eax
    b095:	83 f8 08             	cmp    $0x8,%eax
    b098:	75 62                	jne    b0fc <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b09a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0a1:	eb 4c                	jmp    b0ef <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b0a3:	8b 45 08             	mov    0x8(%ebp),%eax
    b0a6:	83 c0 01             	add    $0x1,%eax
    b0a9:	8b 55 08             	mov    0x8(%ebp),%edx
    b0ac:	83 c2 02             	add    $0x2,%edx
    b0af:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b0b2:	01 c9                	add    %ecx,%ecx
    b0b4:	89 cb                	mov    %ecx,%ebx
    b0b6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b0b9:	01 d9                	add    %ebx,%ecx
    b0bb:	0f b6 09             	movzbl (%ecx),%ecx
    b0be:	88 0a                	mov    %cl,(%edx)
    b0c0:	0f b6 12             	movzbl (%edx),%edx
    b0c3:	88 10                	mov    %dl,(%eax)
    b0c5:	0f b6 10             	movzbl (%eax),%edx
    b0c8:	8b 45 08             	mov    0x8(%ebp),%eax
    b0cb:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b0cd:	8b 45 08             	mov    0x8(%ebp),%eax
    b0d0:	8d 50 03             	lea    0x3(%eax),%edx
    b0d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0d6:	01 c0                	add    %eax,%eax
    b0d8:	8d 48 01             	lea    0x1(%eax),%ecx
    b0db:	8b 45 10             	mov    0x10(%ebp),%eax
    b0de:	01 c8                	add    %ecx,%eax
    b0e0:	0f b6 00             	movzbl (%eax),%eax
    b0e3:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0e5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b0ec:	01 45 08             	add    %eax,0x8(%ebp)
    b0ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0f2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b0f5:	75 ac                	jne    b0a3 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b0f7:	e9 0f 01 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b103:	eb 4e                	jmp    b153 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b105:	8b 45 08             	mov    0x8(%ebp),%eax
    b108:	83 c0 01             	add    $0x1,%eax
    b10b:	8b 55 08             	mov    0x8(%ebp),%edx
    b10e:	83 c2 02             	add    $0x2,%edx
    b111:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b114:	c1 e1 02             	shl    $0x2,%ecx
    b117:	89 cb                	mov    %ecx,%ebx
    b119:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b11c:	01 d9                	add    %ebx,%ecx
    b11e:	0f b6 09             	movzbl (%ecx),%ecx
    b121:	88 0a                	mov    %cl,(%edx)
    b123:	0f b6 12             	movzbl (%edx),%edx
    b126:	88 10                	mov    %dl,(%eax)
    b128:	0f b6 10             	movzbl (%eax),%edx
    b12b:	8b 45 08             	mov    0x8(%ebp),%eax
    b12e:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b130:	8b 45 08             	mov    0x8(%ebp),%eax
    b133:	8d 50 03             	lea    0x3(%eax),%edx
    b136:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b139:	c1 e0 02             	shl    $0x2,%eax
    b13c:	8d 48 02             	lea    0x2(%eax),%ecx
    b13f:	8b 45 10             	mov    0x10(%ebp),%eax
    b142:	01 c8                	add    %ecx,%eax
    b144:	0f b6 00             	movzbl (%eax),%eax
    b147:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b149:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b14d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b150:	01 45 08             	add    %eax,0x8(%ebp)
    b153:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b156:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b159:	75 aa                	jne    b105 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b15b:	e9 ab 00 00 00       	jmp    b20b <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b160:	8b 45 14             	mov    0x14(%ebp),%eax
    b163:	8b 00                	mov    (%eax),%eax
    b165:	83 f8 06             	cmp    $0x6,%eax
    b168:	0f 85 9d 00 00 00    	jne    b20b <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b16e:	8b 45 14             	mov    0x14(%ebp),%eax
    b171:	8b 40 04             	mov    0x4(%eax),%eax
    b174:	83 f8 08             	cmp    $0x8,%eax
    b177:	75 17                	jne    b190 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b179:	8b 45 0c             	mov    0xc(%ebp),%eax
    b17c:	c1 e0 02             	shl    $0x2,%eax
    b17f:	50                   	push   %eax
    b180:	ff 75 10             	pushl  0x10(%ebp)
    b183:	ff 75 08             	pushl  0x8(%ebp)
    b186:	e8 c9 81 ff ff       	call   3354 <lodepng_memcpy>
    b18b:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b18e:	eb 7b                	jmp    b20b <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b190:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b197:	eb 6a                	jmp    b203 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b199:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b19c:	c1 e0 03             	shl    $0x3,%eax
    b19f:	89 c2                	mov    %eax,%edx
    b1a1:	8b 45 10             	mov    0x10(%ebp),%eax
    b1a4:	01 d0                	add    %edx,%eax
    b1a6:	0f b6 10             	movzbl (%eax),%edx
    b1a9:	8b 45 08             	mov    0x8(%ebp),%eax
    b1ac:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b1ae:	8b 45 08             	mov    0x8(%ebp),%eax
    b1b1:	8d 50 01             	lea    0x1(%eax),%edx
    b1b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1b7:	c1 e0 03             	shl    $0x3,%eax
    b1ba:	8d 48 02             	lea    0x2(%eax),%ecx
    b1bd:	8b 45 10             	mov    0x10(%ebp),%eax
    b1c0:	01 c8                	add    %ecx,%eax
    b1c2:	0f b6 00             	movzbl (%eax),%eax
    b1c5:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b1c7:	8b 45 08             	mov    0x8(%ebp),%eax
    b1ca:	8d 50 02             	lea    0x2(%eax),%edx
    b1cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1d0:	c1 e0 03             	shl    $0x3,%eax
    b1d3:	8d 48 04             	lea    0x4(%eax),%ecx
    b1d6:	8b 45 10             	mov    0x10(%ebp),%eax
    b1d9:	01 c8                	add    %ecx,%eax
    b1db:	0f b6 00             	movzbl (%eax),%eax
    b1de:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b1e0:	8b 45 08             	mov    0x8(%ebp),%eax
    b1e3:	8d 50 03             	lea    0x3(%eax),%edx
    b1e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1e9:	c1 e0 03             	shl    $0x3,%eax
    b1ec:	8d 48 06             	lea    0x6(%eax),%ecx
    b1ef:	8b 45 10             	mov    0x10(%ebp),%eax
    b1f2:	01 c8                	add    %ecx,%eax
    b1f4:	0f b6 00             	movzbl (%eax),%eax
    b1f7:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1f9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b1fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b200:	01 45 08             	add    %eax,0x8(%ebp)
    b203:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b206:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b209:	75 8e                	jne    b199 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b20b:	90                   	nop
    b20c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b20f:	c9                   	leave  
    b210:	c3                   	ret    

0000b211 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b211:	55                   	push   %ebp
    b212:	89 e5                	mov    %esp,%ebp
    b214:	53                   	push   %ebx
    b215:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b218:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b21f:	8b 45 14             	mov    0x14(%ebp),%eax
    b222:	8b 00                	mov    (%eax),%eax
    b224:	85 c0                	test   %eax,%eax
    b226:	0f 85 2a 01 00 00    	jne    b356 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b22c:	8b 45 14             	mov    0x14(%ebp),%eax
    b22f:	8b 40 04             	mov    0x4(%eax),%eax
    b232:	83 f8 08             	cmp    $0x8,%eax
    b235:	75 46                	jne    b27d <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b237:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b23e:	eb 30                	jmp    b270 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b240:	8b 45 08             	mov    0x8(%ebp),%eax
    b243:	83 c0 01             	add    $0x1,%eax
    b246:	8b 55 08             	mov    0x8(%ebp),%edx
    b249:	83 c2 02             	add    $0x2,%edx
    b24c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b24f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b252:	01 d9                	add    %ebx,%ecx
    b254:	0f b6 09             	movzbl (%ecx),%ecx
    b257:	88 0a                	mov    %cl,(%edx)
    b259:	0f b6 12             	movzbl (%edx),%edx
    b25c:	88 10                	mov    %dl,(%eax)
    b25e:	0f b6 10             	movzbl (%eax),%edx
    b261:	8b 45 08             	mov    0x8(%ebp),%eax
    b264:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b266:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b26a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b26d:	01 45 08             	add    %eax,0x8(%ebp)
    b270:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b273:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b276:	75 c8                	jne    b240 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b278:	e9 a8 03 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b27d:	8b 45 14             	mov    0x14(%ebp),%eax
    b280:	8b 40 04             	mov    0x4(%eax),%eax
    b283:	83 f8 10             	cmp    $0x10,%eax
    b286:	75 4a                	jne    b2d2 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b288:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b28f:	eb 34                	jmp    b2c5 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b291:	8b 45 08             	mov    0x8(%ebp),%eax
    b294:	83 c0 01             	add    $0x1,%eax
    b297:	8b 55 08             	mov    0x8(%ebp),%edx
    b29a:	83 c2 02             	add    $0x2,%edx
    b29d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b2a0:	01 c9                	add    %ecx,%ecx
    b2a2:	89 cb                	mov    %ecx,%ebx
    b2a4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b2a7:	01 d9                	add    %ebx,%ecx
    b2a9:	0f b6 09             	movzbl (%ecx),%ecx
    b2ac:	88 0a                	mov    %cl,(%edx)
    b2ae:	0f b6 12             	movzbl (%edx),%edx
    b2b1:	88 10                	mov    %dl,(%eax)
    b2b3:	0f b6 10             	movzbl (%eax),%edx
    b2b6:	8b 45 08             	mov    0x8(%ebp),%eax
    b2b9:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2bb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2c2:	01 45 08             	add    %eax,0x8(%ebp)
    b2c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2c8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2cb:	75 c4                	jne    b291 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b2cd:	e9 53 03 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b2d2:	8b 45 14             	mov    0x14(%ebp),%eax
    b2d5:	8b 40 04             	mov    0x4(%eax),%eax
    b2d8:	ba 01 00 00 00       	mov    $0x1,%edx
    b2dd:	89 c1                	mov    %eax,%ecx
    b2df:	d3 e2                	shl    %cl,%edx
    b2e1:	89 d0                	mov    %edx,%eax
    b2e3:	83 e8 01             	sub    $0x1,%eax
    b2e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b2e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2f0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2f7:	eb 50                	jmp    b349 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b2f9:	8b 45 14             	mov    0x14(%ebp),%eax
    b2fc:	8b 40 04             	mov    0x4(%eax),%eax
    b2ff:	50                   	push   %eax
    b300:	ff 75 10             	pushl  0x10(%ebp)
    b303:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b306:	50                   	push   %eax
    b307:	e8 ad ce ff ff       	call   81b9 <readBitsFromReversedStream>
    b30c:	83 c4 0c             	add    $0xc,%esp
    b30f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b312:	8b 45 08             	mov    0x8(%ebp),%eax
    b315:	8d 48 01             	lea    0x1(%eax),%ecx
    b318:	8b 45 08             	mov    0x8(%ebp),%eax
    b31b:	8d 58 02             	lea    0x2(%eax),%ebx
    b31e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b321:	89 d0                	mov    %edx,%eax
    b323:	c1 e0 08             	shl    $0x8,%eax
    b326:	29 d0                	sub    %edx,%eax
    b328:	ba 00 00 00 00       	mov    $0x0,%edx
    b32d:	f7 75 f0             	divl   -0x10(%ebp)
    b330:	88 03                	mov    %al,(%ebx)
    b332:	0f b6 03             	movzbl (%ebx),%eax
    b335:	88 01                	mov    %al,(%ecx)
    b337:	0f b6 11             	movzbl (%ecx),%edx
    b33a:	8b 45 08             	mov    0x8(%ebp),%eax
    b33d:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b33f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b343:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b346:	01 45 08             	add    %eax,0x8(%ebp)
    b349:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b34c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b34f:	75 a8                	jne    b2f9 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b351:	e9 cf 02 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b356:	8b 45 14             	mov    0x14(%ebp),%eax
    b359:	8b 00                	mov    (%eax),%eax
    b35b:	83 f8 02             	cmp    $0x2,%eax
    b35e:	0f 85 9e 00 00 00    	jne    b402 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b364:	8b 45 14             	mov    0x14(%ebp),%eax
    b367:	8b 40 04             	mov    0x4(%eax),%eax
    b36a:	83 f8 08             	cmp    $0x8,%eax
    b36d:	75 1d                	jne    b38c <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b36f:	8b 55 0c             	mov    0xc(%ebp),%edx
    b372:	89 d0                	mov    %edx,%eax
    b374:	01 c0                	add    %eax,%eax
    b376:	01 d0                	add    %edx,%eax
    b378:	50                   	push   %eax
    b379:	ff 75 10             	pushl  0x10(%ebp)
    b37c:	ff 75 08             	pushl  0x8(%ebp)
    b37f:	e8 d0 7f ff ff       	call   3354 <lodepng_memcpy>
    b384:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b387:	e9 99 02 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b38c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b393:	eb 60                	jmp    b3f5 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b395:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b398:	89 d0                	mov    %edx,%eax
    b39a:	01 c0                	add    %eax,%eax
    b39c:	01 d0                	add    %edx,%eax
    b39e:	01 c0                	add    %eax,%eax
    b3a0:	89 c2                	mov    %eax,%edx
    b3a2:	8b 45 10             	mov    0x10(%ebp),%eax
    b3a5:	01 d0                	add    %edx,%eax
    b3a7:	0f b6 10             	movzbl (%eax),%edx
    b3aa:	8b 45 08             	mov    0x8(%ebp),%eax
    b3ad:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b3af:	8b 45 08             	mov    0x8(%ebp),%eax
    b3b2:	8d 48 01             	lea    0x1(%eax),%ecx
    b3b5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3b8:	89 d0                	mov    %edx,%eax
    b3ba:	01 c0                	add    %eax,%eax
    b3bc:	01 d0                	add    %edx,%eax
    b3be:	01 c0                	add    %eax,%eax
    b3c0:	8d 50 02             	lea    0x2(%eax),%edx
    b3c3:	8b 45 10             	mov    0x10(%ebp),%eax
    b3c6:	01 d0                	add    %edx,%eax
    b3c8:	0f b6 00             	movzbl (%eax),%eax
    b3cb:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b3cd:	8b 45 08             	mov    0x8(%ebp),%eax
    b3d0:	8d 48 02             	lea    0x2(%eax),%ecx
    b3d3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3d6:	89 d0                	mov    %edx,%eax
    b3d8:	01 c0                	add    %eax,%eax
    b3da:	01 d0                	add    %edx,%eax
    b3dc:	01 c0                	add    %eax,%eax
    b3de:	8d 50 04             	lea    0x4(%eax),%edx
    b3e1:	8b 45 10             	mov    0x10(%ebp),%eax
    b3e4:	01 d0                	add    %edx,%eax
    b3e6:	0f b6 00             	movzbl (%eax),%eax
    b3e9:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3eb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3f2:	01 45 08             	add    %eax,0x8(%ebp)
    b3f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3f8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3fb:	75 98                	jne    b395 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b3fd:	e9 23 02 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b402:	8b 45 14             	mov    0x14(%ebp),%eax
    b405:	8b 00                	mov    (%eax),%eax
    b407:	83 f8 03             	cmp    $0x3,%eax
    b40a:	0f 85 b4 00 00 00    	jne    b4c4 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b410:	8b 45 14             	mov    0x14(%ebp),%eax
    b413:	8b 40 04             	mov    0x4(%eax),%eax
    b416:	83 f8 08             	cmp    $0x8,%eax
    b419:	75 4d                	jne    b468 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b41b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b422:	eb 37                	jmp    b45b <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b424:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b427:	8b 45 10             	mov    0x10(%ebp),%eax
    b42a:	01 d0                	add    %edx,%eax
    b42c:	0f b6 00             	movzbl (%eax),%eax
    b42f:	0f b6 c0             	movzbl %al,%eax
    b432:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b435:	8b 45 14             	mov    0x14(%ebp),%eax
    b438:	8b 40 08             	mov    0x8(%eax),%eax
    b43b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b43e:	c1 e2 02             	shl    $0x2,%edx
    b441:	01 d0                	add    %edx,%eax
    b443:	6a 03                	push   $0x3
    b445:	50                   	push   %eax
    b446:	ff 75 08             	pushl  0x8(%ebp)
    b449:	e8 06 7f ff ff       	call   3354 <lodepng_memcpy>
    b44e:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b451:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b455:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b458:	01 45 08             	add    %eax,0x8(%ebp)
    b45b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b45e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b461:	75 c1                	jne    b424 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b463:	e9 bd 01 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b468:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b46f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b476:	eb 3f                	jmp    b4b7 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b478:	8b 45 14             	mov    0x14(%ebp),%eax
    b47b:	8b 40 04             	mov    0x4(%eax),%eax
    b47e:	50                   	push   %eax
    b47f:	ff 75 10             	pushl  0x10(%ebp)
    b482:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b485:	50                   	push   %eax
    b486:	e8 2e cd ff ff       	call   81b9 <readBitsFromReversedStream>
    b48b:	83 c4 0c             	add    $0xc,%esp
    b48e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b491:	8b 45 14             	mov    0x14(%ebp),%eax
    b494:	8b 40 08             	mov    0x8(%eax),%eax
    b497:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b49a:	c1 e2 02             	shl    $0x2,%edx
    b49d:	01 d0                	add    %edx,%eax
    b49f:	6a 03                	push   $0x3
    b4a1:	50                   	push   %eax
    b4a2:	ff 75 08             	pushl  0x8(%ebp)
    b4a5:	e8 aa 7e ff ff       	call   3354 <lodepng_memcpy>
    b4aa:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4ad:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4b4:	01 45 08             	add    %eax,0x8(%ebp)
    b4b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4ba:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4bd:	75 b9                	jne    b478 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4bf:	e9 61 01 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b4c4:	8b 45 14             	mov    0x14(%ebp),%eax
    b4c7:	8b 00                	mov    (%eax),%eax
    b4c9:	83 f8 04             	cmp    $0x4,%eax
    b4cc:	0f 85 a0 00 00 00    	jne    b572 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b4d2:	8b 45 14             	mov    0x14(%ebp),%eax
    b4d5:	8b 40 04             	mov    0x4(%eax),%eax
    b4d8:	83 f8 08             	cmp    $0x8,%eax
    b4db:	75 4a                	jne    b527 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4e4:	eb 34                	jmp    b51a <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b4e6:	8b 45 08             	mov    0x8(%ebp),%eax
    b4e9:	83 c0 01             	add    $0x1,%eax
    b4ec:	8b 55 08             	mov    0x8(%ebp),%edx
    b4ef:	83 c2 02             	add    $0x2,%edx
    b4f2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b4f5:	01 c9                	add    %ecx,%ecx
    b4f7:	89 cb                	mov    %ecx,%ebx
    b4f9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b4fc:	01 d9                	add    %ebx,%ecx
    b4fe:	0f b6 09             	movzbl (%ecx),%ecx
    b501:	88 0a                	mov    %cl,(%edx)
    b503:	0f b6 12             	movzbl (%edx),%edx
    b506:	88 10                	mov    %dl,(%eax)
    b508:	0f b6 10             	movzbl (%eax),%edx
    b50b:	8b 45 08             	mov    0x8(%ebp),%eax
    b50e:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b510:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b514:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b517:	01 45 08             	add    %eax,0x8(%ebp)
    b51a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b51d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b520:	75 c4                	jne    b4e6 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b522:	e9 fe 00 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b527:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b52e:	eb 35                	jmp    b565 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b530:	8b 45 08             	mov    0x8(%ebp),%eax
    b533:	83 c0 01             	add    $0x1,%eax
    b536:	8b 55 08             	mov    0x8(%ebp),%edx
    b539:	83 c2 02             	add    $0x2,%edx
    b53c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b53f:	c1 e1 02             	shl    $0x2,%ecx
    b542:	89 cb                	mov    %ecx,%ebx
    b544:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b547:	01 d9                	add    %ebx,%ecx
    b549:	0f b6 09             	movzbl (%ecx),%ecx
    b54c:	88 0a                	mov    %cl,(%edx)
    b54e:	0f b6 12             	movzbl (%edx),%edx
    b551:	88 10                	mov    %dl,(%eax)
    b553:	0f b6 10             	movzbl (%eax),%edx
    b556:	8b 45 08             	mov    0x8(%ebp),%eax
    b559:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b55b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b55f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b562:	01 45 08             	add    %eax,0x8(%ebp)
    b565:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b568:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b56b:	75 c3                	jne    b530 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b56d:	e9 b3 00 00 00       	jmp    b625 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b572:	8b 45 14             	mov    0x14(%ebp),%eax
    b575:	8b 00                	mov    (%eax),%eax
    b577:	83 f8 06             	cmp    $0x6,%eax
    b57a:	0f 85 a5 00 00 00    	jne    b625 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b580:	8b 45 14             	mov    0x14(%ebp),%eax
    b583:	8b 40 04             	mov    0x4(%eax),%eax
    b586:	83 f8 08             	cmp    $0x8,%eax
    b589:	75 38                	jne    b5c3 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b58b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b592:	eb 25                	jmp    b5b9 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b594:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b597:	c1 e0 02             	shl    $0x2,%eax
    b59a:	89 c2                	mov    %eax,%edx
    b59c:	8b 45 10             	mov    0x10(%ebp),%eax
    b59f:	01 d0                	add    %edx,%eax
    b5a1:	6a 03                	push   $0x3
    b5a3:	50                   	push   %eax
    b5a4:	ff 75 08             	pushl  0x8(%ebp)
    b5a7:	e8 a8 7d ff ff       	call   3354 <lodepng_memcpy>
    b5ac:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5af:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5b6:	01 45 08             	add    %eax,0x8(%ebp)
    b5b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5bc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5bf:	75 d3                	jne    b594 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5c1:	eb 62                	jmp    b625 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5ca:	eb 51                	jmp    b61d <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b5cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5cf:	c1 e0 03             	shl    $0x3,%eax
    b5d2:	89 c2                	mov    %eax,%edx
    b5d4:	8b 45 10             	mov    0x10(%ebp),%eax
    b5d7:	01 d0                	add    %edx,%eax
    b5d9:	0f b6 10             	movzbl (%eax),%edx
    b5dc:	8b 45 08             	mov    0x8(%ebp),%eax
    b5df:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b5e1:	8b 45 08             	mov    0x8(%ebp),%eax
    b5e4:	8d 50 01             	lea    0x1(%eax),%edx
    b5e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5ea:	c1 e0 03             	shl    $0x3,%eax
    b5ed:	8d 48 02             	lea    0x2(%eax),%ecx
    b5f0:	8b 45 10             	mov    0x10(%ebp),%eax
    b5f3:	01 c8                	add    %ecx,%eax
    b5f5:	0f b6 00             	movzbl (%eax),%eax
    b5f8:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b5fa:	8b 45 08             	mov    0x8(%ebp),%eax
    b5fd:	8d 50 02             	lea    0x2(%eax),%edx
    b600:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b603:	c1 e0 03             	shl    $0x3,%eax
    b606:	8d 48 04             	lea    0x4(%eax),%ecx
    b609:	8b 45 10             	mov    0x10(%ebp),%eax
    b60c:	01 c8                	add    %ecx,%eax
    b60e:	0f b6 00             	movzbl (%eax),%eax
    b611:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b613:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b617:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b61a:	01 45 08             	add    %eax,0x8(%ebp)
    b61d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b620:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b623:	75 a7                	jne    b5cc <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b625:	90                   	nop
    b626:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b629:	c9                   	leave  
    b62a:	c3                   	ret    

0000b62b <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b62b:	55                   	push   %ebp
    b62c:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b62e:	8b 45 20             	mov    0x20(%ebp),%eax
    b631:	8b 00                	mov    (%eax),%eax
    b633:	85 c0                	test   %eax,%eax
    b635:	0f 85 a4 00 00 00    	jne    b6df <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b63b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b63e:	01 c0                	add    %eax,%eax
    b640:	89 c2                	mov    %eax,%edx
    b642:	8b 45 18             	mov    0x18(%ebp),%eax
    b645:	01 d0                	add    %edx,%eax
    b647:	0f b6 00             	movzbl (%eax),%eax
    b64a:	0f b6 c0             	movzbl %al,%eax
    b64d:	c1 e0 08             	shl    $0x8,%eax
    b650:	89 c2                	mov    %eax,%edx
    b652:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b655:	01 c0                	add    %eax,%eax
    b657:	8d 48 01             	lea    0x1(%eax),%ecx
    b65a:	8b 45 18             	mov    0x18(%ebp),%eax
    b65d:	01 c8                	add    %ecx,%eax
    b65f:	0f b6 00             	movzbl (%eax),%eax
    b662:	0f b6 c0             	movzbl %al,%eax
    b665:	01 c2                	add    %eax,%edx
    b667:	8b 45 10             	mov    0x10(%ebp),%eax
    b66a:	66 89 10             	mov    %dx,(%eax)
    b66d:	8b 45 10             	mov    0x10(%ebp),%eax
    b670:	0f b7 10             	movzwl (%eax),%edx
    b673:	8b 45 0c             	mov    0xc(%ebp),%eax
    b676:	66 89 10             	mov    %dx,(%eax)
    b679:	8b 45 0c             	mov    0xc(%ebp),%eax
    b67c:	0f b7 10             	movzwl (%eax),%edx
    b67f:	8b 45 08             	mov    0x8(%ebp),%eax
    b682:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b685:	8b 45 20             	mov    0x20(%ebp),%eax
    b688:	8b 40 10             	mov    0x10(%eax),%eax
    b68b:	85 c0                	test   %eax,%eax
    b68d:	74 43                	je     b6d2 <getPixelColorRGBA16+0xa7>
    b68f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b692:	01 c0                	add    %eax,%eax
    b694:	89 c2                	mov    %eax,%edx
    b696:	8b 45 18             	mov    0x18(%ebp),%eax
    b699:	01 d0                	add    %edx,%eax
    b69b:	0f b6 00             	movzbl (%eax),%eax
    b69e:	0f b6 c0             	movzbl %al,%eax
    b6a1:	c1 e0 08             	shl    $0x8,%eax
    b6a4:	89 c2                	mov    %eax,%edx
    b6a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6a9:	01 c0                	add    %eax,%eax
    b6ab:	8d 48 01             	lea    0x1(%eax),%ecx
    b6ae:	8b 45 18             	mov    0x18(%ebp),%eax
    b6b1:	01 c8                	add    %ecx,%eax
    b6b3:	0f b6 00             	movzbl (%eax),%eax
    b6b6:	0f b6 c0             	movzbl %al,%eax
    b6b9:	01 c2                	add    %eax,%edx
    b6bb:	8b 45 20             	mov    0x20(%ebp),%eax
    b6be:	8b 40 14             	mov    0x14(%eax),%eax
    b6c1:	39 c2                	cmp    %eax,%edx
    b6c3:	75 0d                	jne    b6d2 <getPixelColorRGBA16+0xa7>
    b6c5:	8b 45 14             	mov    0x14(%ebp),%eax
    b6c8:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b6cd:	e9 48 03 00 00       	jmp    ba1a <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b6d2:	8b 45 14             	mov    0x14(%ebp),%eax
    b6d5:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b6da:	e9 3b 03 00 00       	jmp    ba1a <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b6df:	8b 45 20             	mov    0x20(%ebp),%eax
    b6e2:	8b 00                	mov    (%eax),%eax
    b6e4:	83 f8 02             	cmp    $0x2,%eax
    b6e7:	0f 85 b6 01 00 00    	jne    b8a3 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b6ed:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b6f0:	89 d0                	mov    %edx,%eax
    b6f2:	01 c0                	add    %eax,%eax
    b6f4:	01 d0                	add    %edx,%eax
    b6f6:	01 c0                	add    %eax,%eax
    b6f8:	89 c2                	mov    %eax,%edx
    b6fa:	8b 45 18             	mov    0x18(%ebp),%eax
    b6fd:	01 d0                	add    %edx,%eax
    b6ff:	0f b6 00             	movzbl (%eax),%eax
    b702:	0f b6 c0             	movzbl %al,%eax
    b705:	c1 e0 08             	shl    $0x8,%eax
    b708:	89 c1                	mov    %eax,%ecx
    b70a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b70d:	89 d0                	mov    %edx,%eax
    b70f:	01 c0                	add    %eax,%eax
    b711:	01 d0                	add    %edx,%eax
    b713:	01 c0                	add    %eax,%eax
    b715:	8d 50 01             	lea    0x1(%eax),%edx
    b718:	8b 45 18             	mov    0x18(%ebp),%eax
    b71b:	01 d0                	add    %edx,%eax
    b71d:	0f b6 00             	movzbl (%eax),%eax
    b720:	0f b6 c0             	movzbl %al,%eax
    b723:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b726:	8b 45 08             	mov    0x8(%ebp),%eax
    b729:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b72c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b72f:	89 d0                	mov    %edx,%eax
    b731:	01 c0                	add    %eax,%eax
    b733:	01 d0                	add    %edx,%eax
    b735:	01 c0                	add    %eax,%eax
    b737:	8d 50 02             	lea    0x2(%eax),%edx
    b73a:	8b 45 18             	mov    0x18(%ebp),%eax
    b73d:	01 d0                	add    %edx,%eax
    b73f:	0f b6 00             	movzbl (%eax),%eax
    b742:	0f b6 c0             	movzbl %al,%eax
    b745:	c1 e0 08             	shl    $0x8,%eax
    b748:	89 c1                	mov    %eax,%ecx
    b74a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b74d:	89 d0                	mov    %edx,%eax
    b74f:	01 c0                	add    %eax,%eax
    b751:	01 d0                	add    %edx,%eax
    b753:	01 c0                	add    %eax,%eax
    b755:	8d 50 03             	lea    0x3(%eax),%edx
    b758:	8b 45 18             	mov    0x18(%ebp),%eax
    b75b:	01 d0                	add    %edx,%eax
    b75d:	0f b6 00             	movzbl (%eax),%eax
    b760:	0f b6 c0             	movzbl %al,%eax
    b763:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b766:	8b 45 0c             	mov    0xc(%ebp),%eax
    b769:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b76c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b76f:	89 d0                	mov    %edx,%eax
    b771:	01 c0                	add    %eax,%eax
    b773:	01 d0                	add    %edx,%eax
    b775:	01 c0                	add    %eax,%eax
    b777:	8d 50 04             	lea    0x4(%eax),%edx
    b77a:	8b 45 18             	mov    0x18(%ebp),%eax
    b77d:	01 d0                	add    %edx,%eax
    b77f:	0f b6 00             	movzbl (%eax),%eax
    b782:	0f b6 c0             	movzbl %al,%eax
    b785:	c1 e0 08             	shl    $0x8,%eax
    b788:	89 c1                	mov    %eax,%ecx
    b78a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b78d:	89 d0                	mov    %edx,%eax
    b78f:	01 c0                	add    %eax,%eax
    b791:	01 d0                	add    %edx,%eax
    b793:	01 c0                	add    %eax,%eax
    b795:	8d 50 05             	lea    0x5(%eax),%edx
    b798:	8b 45 18             	mov    0x18(%ebp),%eax
    b79b:	01 d0                	add    %edx,%eax
    b79d:	0f b6 00             	movzbl (%eax),%eax
    b7a0:	0f b6 c0             	movzbl %al,%eax
    b7a3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7a6:	8b 45 10             	mov    0x10(%ebp),%eax
    b7a9:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b7ac:	8b 45 20             	mov    0x20(%ebp),%eax
    b7af:	8b 40 10             	mov    0x10(%eax),%eax
    b7b2:	85 c0                	test   %eax,%eax
    b7b4:	0f 84 dc 00 00 00    	je     b896 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b7ba:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7bd:	89 d0                	mov    %edx,%eax
    b7bf:	01 c0                	add    %eax,%eax
    b7c1:	01 d0                	add    %edx,%eax
    b7c3:	01 c0                	add    %eax,%eax
    b7c5:	89 c2                	mov    %eax,%edx
    b7c7:	8b 45 18             	mov    0x18(%ebp),%eax
    b7ca:	01 d0                	add    %edx,%eax
    b7cc:	0f b6 00             	movzbl (%eax),%eax
    b7cf:	0f b6 c0             	movzbl %al,%eax
    b7d2:	c1 e0 08             	shl    $0x8,%eax
    b7d5:	89 c1                	mov    %eax,%ecx
    b7d7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7da:	89 d0                	mov    %edx,%eax
    b7dc:	01 c0                	add    %eax,%eax
    b7de:	01 d0                	add    %edx,%eax
    b7e0:	01 c0                	add    %eax,%eax
    b7e2:	8d 50 01             	lea    0x1(%eax),%edx
    b7e5:	8b 45 18             	mov    0x18(%ebp),%eax
    b7e8:	01 d0                	add    %edx,%eax
    b7ea:	0f b6 00             	movzbl (%eax),%eax
    b7ed:	0f b6 c0             	movzbl %al,%eax
    b7f0:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7f3:	8b 45 20             	mov    0x20(%ebp),%eax
    b7f6:	8b 40 14             	mov    0x14(%eax),%eax
    b7f9:	39 c2                	cmp    %eax,%edx
    b7fb:	0f 85 95 00 00 00    	jne    b896 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b801:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b804:	89 d0                	mov    %edx,%eax
    b806:	01 c0                	add    %eax,%eax
    b808:	01 d0                	add    %edx,%eax
    b80a:	01 c0                	add    %eax,%eax
    b80c:	8d 50 02             	lea    0x2(%eax),%edx
    b80f:	8b 45 18             	mov    0x18(%ebp),%eax
    b812:	01 d0                	add    %edx,%eax
    b814:	0f b6 00             	movzbl (%eax),%eax
    b817:	0f b6 c0             	movzbl %al,%eax
    b81a:	c1 e0 08             	shl    $0x8,%eax
    b81d:	89 c1                	mov    %eax,%ecx
    b81f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b822:	89 d0                	mov    %edx,%eax
    b824:	01 c0                	add    %eax,%eax
    b826:	01 d0                	add    %edx,%eax
    b828:	01 c0                	add    %eax,%eax
    b82a:	8d 50 03             	lea    0x3(%eax),%edx
    b82d:	8b 45 18             	mov    0x18(%ebp),%eax
    b830:	01 d0                	add    %edx,%eax
    b832:	0f b6 00             	movzbl (%eax),%eax
    b835:	0f b6 c0             	movzbl %al,%eax
    b838:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b83b:	8b 45 20             	mov    0x20(%ebp),%eax
    b83e:	8b 40 18             	mov    0x18(%eax),%eax
    b841:	39 c2                	cmp    %eax,%edx
    b843:	75 51                	jne    b896 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b845:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b848:	89 d0                	mov    %edx,%eax
    b84a:	01 c0                	add    %eax,%eax
    b84c:	01 d0                	add    %edx,%eax
    b84e:	01 c0                	add    %eax,%eax
    b850:	8d 50 04             	lea    0x4(%eax),%edx
    b853:	8b 45 18             	mov    0x18(%ebp),%eax
    b856:	01 d0                	add    %edx,%eax
    b858:	0f b6 00             	movzbl (%eax),%eax
    b85b:	0f b6 c0             	movzbl %al,%eax
    b85e:	c1 e0 08             	shl    $0x8,%eax
    b861:	89 c1                	mov    %eax,%ecx
    b863:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b866:	89 d0                	mov    %edx,%eax
    b868:	01 c0                	add    %eax,%eax
    b86a:	01 d0                	add    %edx,%eax
    b86c:	01 c0                	add    %eax,%eax
    b86e:	8d 50 05             	lea    0x5(%eax),%edx
    b871:	8b 45 18             	mov    0x18(%ebp),%eax
    b874:	01 d0                	add    %edx,%eax
    b876:	0f b6 00             	movzbl (%eax),%eax
    b879:	0f b6 c0             	movzbl %al,%eax
    b87c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b87f:	8b 45 20             	mov    0x20(%ebp),%eax
    b882:	8b 40 1c             	mov    0x1c(%eax),%eax
    b885:	39 c2                	cmp    %eax,%edx
    b887:	75 0d                	jne    b896 <getPixelColorRGBA16+0x26b>
    b889:	8b 45 14             	mov    0x14(%ebp),%eax
    b88c:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b891:	e9 84 01 00 00       	jmp    ba1a <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b896:	8b 45 14             	mov    0x14(%ebp),%eax
    b899:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b89e:	e9 77 01 00 00       	jmp    ba1a <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b8a3:	8b 45 20             	mov    0x20(%ebp),%eax
    b8a6:	8b 00                	mov    (%eax),%eax
    b8a8:	83 f8 04             	cmp    $0x4,%eax
    b8ab:	0f 85 86 00 00 00    	jne    b937 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b8b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8b4:	c1 e0 02             	shl    $0x2,%eax
    b8b7:	89 c2                	mov    %eax,%edx
    b8b9:	8b 45 18             	mov    0x18(%ebp),%eax
    b8bc:	01 d0                	add    %edx,%eax
    b8be:	0f b6 00             	movzbl (%eax),%eax
    b8c1:	0f b6 c0             	movzbl %al,%eax
    b8c4:	c1 e0 08             	shl    $0x8,%eax
    b8c7:	89 c2                	mov    %eax,%edx
    b8c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8cc:	c1 e0 02             	shl    $0x2,%eax
    b8cf:	8d 48 01             	lea    0x1(%eax),%ecx
    b8d2:	8b 45 18             	mov    0x18(%ebp),%eax
    b8d5:	01 c8                	add    %ecx,%eax
    b8d7:	0f b6 00             	movzbl (%eax),%eax
    b8da:	0f b6 c0             	movzbl %al,%eax
    b8dd:	01 c2                	add    %eax,%edx
    b8df:	8b 45 10             	mov    0x10(%ebp),%eax
    b8e2:	66 89 10             	mov    %dx,(%eax)
    b8e5:	8b 45 10             	mov    0x10(%ebp),%eax
    b8e8:	0f b7 10             	movzwl (%eax),%edx
    b8eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8ee:	66 89 10             	mov    %dx,(%eax)
    b8f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8f4:	0f b7 10             	movzwl (%eax),%edx
    b8f7:	8b 45 08             	mov    0x8(%ebp),%eax
    b8fa:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b8fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b900:	c1 e0 02             	shl    $0x2,%eax
    b903:	8d 50 02             	lea    0x2(%eax),%edx
    b906:	8b 45 18             	mov    0x18(%ebp),%eax
    b909:	01 d0                	add    %edx,%eax
    b90b:	0f b6 00             	movzbl (%eax),%eax
    b90e:	0f b6 c0             	movzbl %al,%eax
    b911:	c1 e0 08             	shl    $0x8,%eax
    b914:	89 c2                	mov    %eax,%edx
    b916:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b919:	c1 e0 02             	shl    $0x2,%eax
    b91c:	8d 48 03             	lea    0x3(%eax),%ecx
    b91f:	8b 45 18             	mov    0x18(%ebp),%eax
    b922:	01 c8                	add    %ecx,%eax
    b924:	0f b6 00             	movzbl (%eax),%eax
    b927:	0f b6 c0             	movzbl %al,%eax
    b92a:	01 c2                	add    %eax,%edx
    b92c:	8b 45 14             	mov    0x14(%ebp),%eax
    b92f:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b932:	e9 e3 00 00 00       	jmp    ba1a <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    b937:	8b 45 20             	mov    0x20(%ebp),%eax
    b93a:	8b 00                	mov    (%eax),%eax
    b93c:	83 f8 06             	cmp    $0x6,%eax
    b93f:	0f 85 d5 00 00 00    	jne    ba1a <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    b945:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b948:	c1 e0 03             	shl    $0x3,%eax
    b94b:	89 c2                	mov    %eax,%edx
    b94d:	8b 45 18             	mov    0x18(%ebp),%eax
    b950:	01 d0                	add    %edx,%eax
    b952:	0f b6 00             	movzbl (%eax),%eax
    b955:	0f b6 c0             	movzbl %al,%eax
    b958:	c1 e0 08             	shl    $0x8,%eax
    b95b:	89 c2                	mov    %eax,%edx
    b95d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b960:	c1 e0 03             	shl    $0x3,%eax
    b963:	8d 48 01             	lea    0x1(%eax),%ecx
    b966:	8b 45 18             	mov    0x18(%ebp),%eax
    b969:	01 c8                	add    %ecx,%eax
    b96b:	0f b6 00             	movzbl (%eax),%eax
    b96e:	0f b6 c0             	movzbl %al,%eax
    b971:	01 c2                	add    %eax,%edx
    b973:	8b 45 08             	mov    0x8(%ebp),%eax
    b976:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    b979:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b97c:	c1 e0 03             	shl    $0x3,%eax
    b97f:	8d 50 02             	lea    0x2(%eax),%edx
    b982:	8b 45 18             	mov    0x18(%ebp),%eax
    b985:	01 d0                	add    %edx,%eax
    b987:	0f b6 00             	movzbl (%eax),%eax
    b98a:	0f b6 c0             	movzbl %al,%eax
    b98d:	c1 e0 08             	shl    $0x8,%eax
    b990:	89 c2                	mov    %eax,%edx
    b992:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b995:	c1 e0 03             	shl    $0x3,%eax
    b998:	8d 48 03             	lea    0x3(%eax),%ecx
    b99b:	8b 45 18             	mov    0x18(%ebp),%eax
    b99e:	01 c8                	add    %ecx,%eax
    b9a0:	0f b6 00             	movzbl (%eax),%eax
    b9a3:	0f b6 c0             	movzbl %al,%eax
    b9a6:	01 c2                	add    %eax,%edx
    b9a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9ab:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    b9ae:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9b1:	c1 e0 03             	shl    $0x3,%eax
    b9b4:	8d 50 04             	lea    0x4(%eax),%edx
    b9b7:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ba:	01 d0                	add    %edx,%eax
    b9bc:	0f b6 00             	movzbl (%eax),%eax
    b9bf:	0f b6 c0             	movzbl %al,%eax
    b9c2:	c1 e0 08             	shl    $0x8,%eax
    b9c5:	89 c2                	mov    %eax,%edx
    b9c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9ca:	c1 e0 03             	shl    $0x3,%eax
    b9cd:	8d 48 05             	lea    0x5(%eax),%ecx
    b9d0:	8b 45 18             	mov    0x18(%ebp),%eax
    b9d3:	01 c8                	add    %ecx,%eax
    b9d5:	0f b6 00             	movzbl (%eax),%eax
    b9d8:	0f b6 c0             	movzbl %al,%eax
    b9db:	01 c2                	add    %eax,%edx
    b9dd:	8b 45 10             	mov    0x10(%ebp),%eax
    b9e0:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    b9e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9e6:	c1 e0 03             	shl    $0x3,%eax
    b9e9:	8d 50 06             	lea    0x6(%eax),%edx
    b9ec:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ef:	01 d0                	add    %edx,%eax
    b9f1:	0f b6 00             	movzbl (%eax),%eax
    b9f4:	0f b6 c0             	movzbl %al,%eax
    b9f7:	c1 e0 08             	shl    $0x8,%eax
    b9fa:	89 c2                	mov    %eax,%edx
    b9fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9ff:	c1 e0 03             	shl    $0x3,%eax
    ba02:	8d 48 07             	lea    0x7(%eax),%ecx
    ba05:	8b 45 18             	mov    0x18(%ebp),%eax
    ba08:	01 c8                	add    %ecx,%eax
    ba0a:	0f b6 00             	movzbl (%eax),%eax
    ba0d:	0f b6 c0             	movzbl %al,%eax
    ba10:	01 c2                	add    %eax,%edx
    ba12:	8b 45 14             	mov    0x14(%ebp),%eax
    ba15:	66 89 10             	mov    %dx,(%eax)
  }
}
    ba18:	eb 00                	jmp    ba1a <getPixelColorRGBA16+0x3ef>
    ba1a:	90                   	nop
    ba1b:	5d                   	pop    %ebp
    ba1c:	c3                   	ret    

0000ba1d <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    ba1d:	55                   	push   %ebp
    ba1e:	89 e5                	mov    %esp,%ebp
    ba20:	56                   	push   %esi
    ba21:	53                   	push   %ebx
    ba22:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    ba25:	8b 55 18             	mov    0x18(%ebp),%edx
    ba28:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba2b:	0f af c2             	imul   %edx,%eax
    ba2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    ba31:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    ba38:	8b 45 14             	mov    0x14(%ebp),%eax
    ba3b:	8b 00                	mov    (%eax),%eax
    ba3d:	83 f8 03             	cmp    $0x3,%eax
    ba40:	75 14                	jne    ba56 <lodepng_convert+0x39>
    ba42:	8b 45 14             	mov    0x14(%ebp),%eax
    ba45:	8b 40 08             	mov    0x8(%eax),%eax
    ba48:	85 c0                	test   %eax,%eax
    ba4a:	75 0a                	jne    ba56 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    ba4c:	b8 6b 00 00 00       	mov    $0x6b,%eax
    ba51:	e9 19 03 00 00       	jmp    bd6f <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    ba56:	ff 75 14             	pushl  0x14(%ebp)
    ba59:	ff 75 10             	pushl  0x10(%ebp)
    ba5c:	e8 b7 d1 ff ff       	call   8c18 <lodepng_color_mode_equal>
    ba61:	83 c4 08             	add    $0x8,%esp
    ba64:	85 c0                	test   %eax,%eax
    ba66:	74 2f                	je     ba97 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    ba68:	ff 75 14             	pushl  0x14(%ebp)
    ba6b:	ff 75 1c             	pushl  0x1c(%ebp)
    ba6e:	ff 75 18             	pushl  0x18(%ebp)
    ba71:	e8 fb d4 ff ff       	call   8f71 <lodepng_get_raw_size>
    ba76:	83 c4 0c             	add    $0xc,%esp
    ba79:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    ba7c:	ff 75 dc             	pushl  -0x24(%ebp)
    ba7f:	ff 75 0c             	pushl  0xc(%ebp)
    ba82:	ff 75 08             	pushl  0x8(%ebp)
    ba85:	e8 ca 78 ff ff       	call   3354 <lodepng_memcpy>
    ba8a:	83 c4 0c             	add    $0xc,%esp
    return 0;
    ba8d:	b8 00 00 00 00       	mov    $0x0,%eax
    ba92:	e9 d8 02 00 00       	jmp    bd6f <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    ba97:	8b 45 10             	mov    0x10(%ebp),%eax
    ba9a:	8b 00                	mov    (%eax),%eax
    ba9c:	83 f8 03             	cmp    $0x3,%eax
    ba9f:	0f 85 16 01 00 00    	jne    bbbb <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    baa5:	8b 45 10             	mov    0x10(%ebp),%eax
    baa8:	8b 40 0c             	mov    0xc(%eax),%eax
    baab:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    baae:	8b 45 10             	mov    0x10(%ebp),%eax
    bab1:	8b 40 08             	mov    0x8(%eax),%eax
    bab4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bab7:	8b 45 10             	mov    0x10(%ebp),%eax
    baba:	8b 40 04             	mov    0x4(%eax),%eax
    babd:	ba 01 00 00 00       	mov    $0x1,%edx
    bac2:	89 c1                	mov    %eax,%ecx
    bac4:	d3 e2                	shl    %cl,%edx
    bac6:	89 d0                	mov    %edx,%eax
    bac8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bacb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bacf:	75 5b                	jne    bb2c <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bad1:	8b 45 14             	mov    0x14(%ebp),%eax
    bad4:	8b 40 0c             	mov    0xc(%eax),%eax
    bad7:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bada:	8b 45 14             	mov    0x14(%ebp),%eax
    badd:	8b 40 08             	mov    0x8(%eax),%eax
    bae0:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bae3:	8b 45 14             	mov    0x14(%ebp),%eax
    bae6:	8b 00                	mov    (%eax),%eax
    bae8:	83 f8 03             	cmp    $0x3,%eax
    baeb:	75 3f                	jne    bb2c <lodepng_convert+0x10f>
    baed:	8b 45 14             	mov    0x14(%ebp),%eax
    baf0:	8b 50 04             	mov    0x4(%eax),%edx
    baf3:	8b 45 10             	mov    0x10(%ebp),%eax
    baf6:	8b 40 04             	mov    0x4(%eax),%eax
    baf9:	39 c2                	cmp    %eax,%edx
    bafb:	75 2f                	jne    bb2c <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bafd:	ff 75 14             	pushl  0x14(%ebp)
    bb00:	ff 75 1c             	pushl  0x1c(%ebp)
    bb03:	ff 75 18             	pushl  0x18(%ebp)
    bb06:	e8 66 d4 ff ff       	call   8f71 <lodepng_get_raw_size>
    bb0b:	83 c4 0c             	add    $0xc,%esp
    bb0e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bb11:	ff 75 d8             	pushl  -0x28(%ebp)
    bb14:	ff 75 0c             	pushl  0xc(%ebp)
    bb17:	ff 75 08             	pushl  0x8(%ebp)
    bb1a:	e8 35 78 ff ff       	call   3354 <lodepng_memcpy>
    bb1f:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bb22:	b8 00 00 00 00       	mov    $0x0,%eax
    bb27:	e9 43 02 00 00       	jmp    bd6f <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bb2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb2f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bb32:	7d 06                	jge    bb3a <lodepng_convert+0x11d>
    bb34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bb3a:	8d 45 90             	lea    -0x70(%ebp),%eax
    bb3d:	50                   	push   %eax
    bb3e:	e8 5f e1 ff ff       	call   9ca2 <color_tree_init>
    bb43:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bb46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bb4d:	eb 61                	jmp    bbb0 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bb4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb52:	c1 e0 02             	shl    $0x2,%eax
    bb55:	89 c2                	mov    %eax,%edx
    bb57:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb5a:	01 d0                	add    %edx,%eax
    bb5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bb5f:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bb62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb65:	83 c0 03             	add    $0x3,%eax
    bb68:	0f b6 00             	movzbl (%eax),%eax
    bb6b:	0f b6 d8             	movzbl %al,%ebx
    bb6e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb71:	83 c0 02             	add    $0x2,%eax
    bb74:	0f b6 00             	movzbl (%eax),%eax
    bb77:	0f b6 c8             	movzbl %al,%ecx
    bb7a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb7d:	83 c0 01             	add    $0x1,%eax
    bb80:	0f b6 00             	movzbl (%eax),%eax
    bb83:	0f b6 d0             	movzbl %al,%edx
    bb86:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb89:	0f b6 00             	movzbl (%eax),%eax
    bb8c:	0f b6 c0             	movzbl %al,%eax
    bb8f:	83 ec 08             	sub    $0x8,%esp
    bb92:	56                   	push   %esi
    bb93:	53                   	push   %ebx
    bb94:	51                   	push   %ecx
    bb95:	52                   	push   %edx
    bb96:	50                   	push   %eax
    bb97:	8d 45 90             	lea    -0x70(%ebp),%eax
    bb9a:	50                   	push   %eax
    bb9b:	e8 85 e2 ff ff       	call   9e25 <color_tree_add>
    bba0:	83 c4 20             	add    $0x20,%esp
    bba3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bba6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbaa:	75 0e                	jne    bbba <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bbac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bbb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbb3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bbb6:	75 97                	jne    bb4f <lodepng_convert+0x132>
    bbb8:	eb 01                	jmp    bbbb <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bbba:	90                   	nop
    }
  }

  if(!error) {
    bbbb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbbf:	0f 85 8e 01 00 00    	jne    bd53 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bbc5:	8b 45 14             	mov    0x14(%ebp),%eax
    bbc8:	8b 40 04             	mov    0x4(%eax),%eax
    bbcb:	83 f8 10             	cmp    $0x10,%eax
    bbce:	0f 85 99 00 00 00    	jne    bc6d <lodepng_convert+0x250>
    bbd4:	8b 45 10             	mov    0x10(%ebp),%eax
    bbd7:	8b 40 04             	mov    0x4(%eax),%eax
    bbda:	83 f8 10             	cmp    $0x10,%eax
    bbdd:	0f 85 8a 00 00 00    	jne    bc6d <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bbe3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bbea:	eb 74                	jmp    bc60 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bbec:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bbf2:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bbf8:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bbfe:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bc04:	83 ec 04             	sub    $0x4,%esp
    bc07:	ff 75 14             	pushl  0x14(%ebp)
    bc0a:	ff 75 f4             	pushl  -0xc(%ebp)
    bc0d:	ff 75 0c             	pushl  0xc(%ebp)
    bc10:	8d 45 88             	lea    -0x78(%ebp),%eax
    bc13:	50                   	push   %eax
    bc14:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bc17:	50                   	push   %eax
    bc18:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bc1b:	50                   	push   %eax
    bc1c:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bc1f:	50                   	push   %eax
    bc20:	e8 06 fa ff ff       	call   b62b <getPixelColorRGBA16>
    bc25:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bc28:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bc2c:	0f b7 d8             	movzwl %ax,%ebx
    bc2f:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bc33:	0f b7 c8             	movzwl %ax,%ecx
    bc36:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bc3a:	0f b7 d0             	movzwl %ax,%edx
    bc3d:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bc41:	0f b7 c0             	movzwl %ax,%eax
    bc44:	83 ec 04             	sub    $0x4,%esp
    bc47:	53                   	push   %ebx
    bc48:	51                   	push   %ecx
    bc49:	52                   	push   %edx
    bc4a:	50                   	push   %eax
    bc4b:	ff 75 10             	pushl  0x10(%ebp)
    bc4e:	ff 75 f4             	pushl  -0xc(%ebp)
    bc51:	ff 75 08             	pushl  0x8(%ebp)
    bc54:	e8 d3 e6 ff ff       	call   a32c <rgba16ToPixel>
    bc59:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bc5c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc60:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc63:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bc66:	75 84                	jne    bbec <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bc68:	e9 e6 00 00 00       	jmp    bd53 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bc6d:	8b 45 10             	mov    0x10(%ebp),%eax
    bc70:	8b 40 04             	mov    0x4(%eax),%eax
    bc73:	83 f8 08             	cmp    $0x8,%eax
    bc76:	75 23                	jne    bc9b <lodepng_convert+0x27e>
    bc78:	8b 45 10             	mov    0x10(%ebp),%eax
    bc7b:	8b 00                	mov    (%eax),%eax
    bc7d:	83 f8 06             	cmp    $0x6,%eax
    bc80:	75 19                	jne    bc9b <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bc82:	ff 75 14             	pushl  0x14(%ebp)
    bc85:	ff 75 0c             	pushl  0xc(%ebp)
    bc88:	ff 75 e0             	pushl  -0x20(%ebp)
    bc8b:	ff 75 08             	pushl  0x8(%ebp)
    bc8e:	e8 ae ee ff ff       	call   ab41 <getPixelColorsRGBA8>
    bc93:	83 c4 10             	add    $0x10,%esp
    bc96:	e9 b8 00 00 00       	jmp    bd53 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bc9b:	8b 45 10             	mov    0x10(%ebp),%eax
    bc9e:	8b 40 04             	mov    0x4(%eax),%eax
    bca1:	83 f8 08             	cmp    $0x8,%eax
    bca4:	75 23                	jne    bcc9 <lodepng_convert+0x2ac>
    bca6:	8b 45 10             	mov    0x10(%ebp),%eax
    bca9:	8b 00                	mov    (%eax),%eax
    bcab:	83 f8 02             	cmp    $0x2,%eax
    bcae:	75 19                	jne    bcc9 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bcb0:	ff 75 14             	pushl  0x14(%ebp)
    bcb3:	ff 75 0c             	pushl  0xc(%ebp)
    bcb6:	ff 75 e0             	pushl  -0x20(%ebp)
    bcb9:	ff 75 08             	pushl  0x8(%ebp)
    bcbc:	e8 50 f5 ff ff       	call   b211 <getPixelColorsRGB8>
    bcc1:	83 c4 10             	add    $0x10,%esp
    bcc4:	e9 8a 00 00 00       	jmp    bd53 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bcc9:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bccd:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bcd1:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bcd5:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bcd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bce0:	eb 66                	jmp    bd48 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bce2:	83 ec 04             	sub    $0x4,%esp
    bce5:	ff 75 14             	pushl  0x14(%ebp)
    bce8:	ff 75 f4             	pushl  -0xc(%ebp)
    bceb:	ff 75 0c             	pushl  0xc(%ebp)
    bcee:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bcf1:	50                   	push   %eax
    bcf2:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bcf5:	50                   	push   %eax
    bcf6:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bcf9:	50                   	push   %eax
    bcfa:	8d 45 87             	lea    -0x79(%ebp),%eax
    bcfd:	50                   	push   %eax
    bcfe:	e8 71 e8 ff ff       	call   a574 <getPixelColorRGBA8>
    bd03:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bd06:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bd0a:	0f b6 d8             	movzbl %al,%ebx
    bd0d:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bd11:	0f b6 c8             	movzbl %al,%ecx
    bd14:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bd18:	0f b6 d0             	movzbl %al,%edx
    bd1b:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bd1f:	0f b6 c0             	movzbl %al,%eax
    bd22:	53                   	push   %ebx
    bd23:	51                   	push   %ecx
    bd24:	52                   	push   %edx
    bd25:	50                   	push   %eax
    bd26:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd29:	50                   	push   %eax
    bd2a:	ff 75 10             	pushl  0x10(%ebp)
    bd2d:	ff 75 f4             	pushl  -0xc(%ebp)
    bd30:	ff 75 08             	pushl  0x8(%ebp)
    bd33:	e8 e5 e1 ff ff       	call   9f1d <rgba8ToPixel>
    bd38:	83 c4 20             	add    $0x20,%esp
    bd3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    bd3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bd42:	75 0e                	jne    bd52 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    bd44:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd48:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd4b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd4e:	75 92                	jne    bce2 <lodepng_convert+0x2c5>
    bd50:	eb 01                	jmp    bd53 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    bd52:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bd53:	8b 45 10             	mov    0x10(%ebp),%eax
    bd56:	8b 00                	mov    (%eax),%eax
    bd58:	83 f8 03             	cmp    $0x3,%eax
    bd5b:	75 0f                	jne    bd6c <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    bd5d:	83 ec 0c             	sub    $0xc,%esp
    bd60:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd63:	50                   	push   %eax
    bd64:	e8 59 df ff ff       	call   9cc2 <color_tree_cleanup>
    bd69:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    bd6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bd6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    bd72:	5b                   	pop    %ebx
    bd73:	5e                   	pop    %esi
    bd74:	5d                   	pop    %ebp
    bd75:	c3                   	ret    

0000bd76 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    bd76:	55                   	push   %ebp
    bd77:	89 e5                	mov    %esp,%ebp
    bd79:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    bd7c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    bd83:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bd8a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    bd91:	8b 45 24             	mov    0x24(%ebp),%eax
    bd94:	8b 40 04             	mov    0x4(%eax),%eax
    bd97:	ba 01 00 00 00       	mov    $0x1,%edx
    bd9c:	89 c1                	mov    %eax,%ecx
    bd9e:	d3 e2                	shl    %cl,%edx
    bda0:	89 d0                	mov    %edx,%eax
    bda2:	8d 48 ff             	lea    -0x1(%eax),%ecx
    bda5:	b8 ff ff 00 00       	mov    $0xffff,%eax
    bdaa:	ba 00 00 00 00       	mov    $0x0,%edx
    bdaf:	f7 f1                	div    %ecx
    bdb1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    bdb4:	8b 45 20             	mov    0x20(%ebp),%eax
    bdb7:	8b 40 04             	mov    0x4(%eax),%eax
    bdba:	ba 10 00 00 00       	mov    $0x10,%edx
    bdbf:	29 c2                	sub    %eax,%edx
    bdc1:	89 d0                	mov    %edx,%eax
    bdc3:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    bdc6:	8b 45 24             	mov    0x24(%ebp),%eax
    bdc9:	8b 00                	mov    (%eax),%eax
    bdcb:	85 c0                	test   %eax,%eax
    bdcd:	74 0a                	je     bdd9 <lodepng_convert_rgb+0x63>
    bdcf:	8b 45 24             	mov    0x24(%ebp),%eax
    bdd2:	8b 00                	mov    (%eax),%eax
    bdd4:	83 f8 04             	cmp    $0x4,%eax
    bdd7:	75 1b                	jne    bdf4 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    bdd9:	8b 45 14             	mov    0x14(%ebp),%eax
    bddc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bde0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bde3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bde6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    bde9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bdec:	89 45 fc             	mov    %eax,-0x4(%ebp)
    bdef:	e9 c2 00 00 00       	jmp    beb6 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    bdf4:	8b 45 24             	mov    0x24(%ebp),%eax
    bdf7:	8b 00                	mov    (%eax),%eax
    bdf9:	83 f8 02             	cmp    $0x2,%eax
    bdfc:	74 0a                	je     be08 <lodepng_convert_rgb+0x92>
    bdfe:	8b 45 24             	mov    0x24(%ebp),%eax
    be01:	8b 00                	mov    (%eax),%eax
    be03:	83 f8 06             	cmp    $0x6,%eax
    be06:	75 23                	jne    be2b <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    be08:	8b 45 14             	mov    0x14(%ebp),%eax
    be0b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    be12:	8b 45 18             	mov    0x18(%ebp),%eax
    be15:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be19:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    be1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    be1f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be23:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be26:	e9 8b 00 00 00       	jmp    beb6 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    be2b:	8b 45 24             	mov    0x24(%ebp),%eax
    be2e:	8b 00                	mov    (%eax),%eax
    be30:	83 f8 03             	cmp    $0x3,%eax
    be33:	75 77                	jne    beac <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    be35:	8b 45 24             	mov    0x24(%ebp),%eax
    be38:	8b 40 0c             	mov    0xc(%eax),%eax
    be3b:	3b 45 14             	cmp    0x14(%ebp),%eax
    be3e:	77 0a                	ja     be4a <lodepng_convert_rgb+0xd4>
    be40:	b8 52 00 00 00       	mov    $0x52,%eax
    be45:	e9 cb 01 00 00       	jmp    c015 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    be4a:	8b 45 24             	mov    0x24(%ebp),%eax
    be4d:	8b 40 08             	mov    0x8(%eax),%eax
    be50:	8b 55 14             	mov    0x14(%ebp),%edx
    be53:	c1 e2 02             	shl    $0x2,%edx
    be56:	01 d0                	add    %edx,%eax
    be58:	0f b6 00             	movzbl (%eax),%eax
    be5b:	0f b6 d0             	movzbl %al,%edx
    be5e:	89 d0                	mov    %edx,%eax
    be60:	c1 e0 08             	shl    $0x8,%eax
    be63:	01 d0                	add    %edx,%eax
    be65:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    be68:	8b 45 24             	mov    0x24(%ebp),%eax
    be6b:	8b 40 08             	mov    0x8(%eax),%eax
    be6e:	8b 55 14             	mov    0x14(%ebp),%edx
    be71:	c1 e2 02             	shl    $0x2,%edx
    be74:	83 c2 01             	add    $0x1,%edx
    be77:	01 d0                	add    %edx,%eax
    be79:	0f b6 00             	movzbl (%eax),%eax
    be7c:	0f b6 d0             	movzbl %al,%edx
    be7f:	89 d0                	mov    %edx,%eax
    be81:	c1 e0 08             	shl    $0x8,%eax
    be84:	01 d0                	add    %edx,%eax
    be86:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    be89:	8b 45 24             	mov    0x24(%ebp),%eax
    be8c:	8b 40 08             	mov    0x8(%eax),%eax
    be8f:	8b 55 14             	mov    0x14(%ebp),%edx
    be92:	c1 e2 02             	shl    $0x2,%edx
    be95:	83 c2 02             	add    $0x2,%edx
    be98:	01 d0                	add    %edx,%eax
    be9a:	0f b6 00             	movzbl (%eax),%eax
    be9d:	0f b6 d0             	movzbl %al,%edx
    bea0:	89 d0                	mov    %edx,%eax
    bea2:	c1 e0 08             	shl    $0x8,%eax
    bea5:	01 d0                	add    %edx,%eax
    bea7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    beaa:	eb 0a                	jmp    beb6 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    beac:	b8 1f 00 00 00       	mov    $0x1f,%eax
    beb1:	e9 5f 01 00 00       	jmp    c015 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    beb6:	8b 45 20             	mov    0x20(%ebp),%eax
    beb9:	8b 00                	mov    (%eax),%eax
    bebb:	85 c0                	test   %eax,%eax
    bebd:	74 0a                	je     bec9 <lodepng_convert_rgb+0x153>
    bebf:	8b 45 20             	mov    0x20(%ebp),%eax
    bec2:	8b 00                	mov    (%eax),%eax
    bec4:	83 f8 04             	cmp    $0x4,%eax
    bec7:	75 14                	jne    bedd <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    bec9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    becc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    becf:	89 c1                	mov    %eax,%ecx
    bed1:	d3 ea                	shr    %cl,%edx
    bed3:	8b 45 08             	mov    0x8(%ebp),%eax
    bed6:	89 10                	mov    %edx,(%eax)
    bed8:	e9 33 01 00 00       	jmp    c010 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    bedd:	8b 45 20             	mov    0x20(%ebp),%eax
    bee0:	8b 00                	mov    (%eax),%eax
    bee2:	83 f8 02             	cmp    $0x2,%eax
    bee5:	74 0a                	je     bef1 <lodepng_convert_rgb+0x17b>
    bee7:	8b 45 20             	mov    0x20(%ebp),%eax
    beea:	8b 00                	mov    (%eax),%eax
    beec:	83 f8 06             	cmp    $0x6,%eax
    beef:	75 32                	jne    bf23 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    bef1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bef4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bef7:	89 c1                	mov    %eax,%ecx
    bef9:	d3 ea                	shr    %cl,%edx
    befb:	8b 45 08             	mov    0x8(%ebp),%eax
    befe:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bf00:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf03:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf06:	89 c1                	mov    %eax,%ecx
    bf08:	d3 ea                	shr    %cl,%edx
    bf0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf0d:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bf0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf12:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bf15:	89 c1                	mov    %eax,%ecx
    bf17:	d3 ea                	shr    %cl,%edx
    bf19:	8b 45 10             	mov    0x10(%ebp),%eax
    bf1c:	89 10                	mov    %edx,(%eax)
    bf1e:	e9 ed 00 00 00       	jmp    c010 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    bf23:	8b 45 20             	mov    0x20(%ebp),%eax
    bf26:	8b 00                	mov    (%eax),%eax
    bf28:	83 f8 03             	cmp    $0x3,%eax
    bf2b:	0f 85 d8 00 00 00    	jne    c009 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    bf31:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf34:	c1 e8 08             	shr    $0x8,%eax
    bf37:	89 c2                	mov    %eax,%edx
    bf39:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf3c:	0f b6 c0             	movzbl %al,%eax
    bf3f:	39 c2                	cmp    %eax,%edx
    bf41:	75 24                	jne    bf67 <lodepng_convert_rgb+0x1f1>
    bf43:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf46:	c1 e8 08             	shr    $0x8,%eax
    bf49:	89 c2                	mov    %eax,%edx
    bf4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf4e:	0f b6 c0             	movzbl %al,%eax
    bf51:	39 c2                	cmp    %eax,%edx
    bf53:	75 12                	jne    bf67 <lodepng_convert_rgb+0x1f1>
    bf55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf58:	c1 e8 08             	shr    $0x8,%eax
    bf5b:	89 c2                	mov    %eax,%edx
    bf5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf60:	0f b6 c0             	movzbl %al,%eax
    bf63:	39 c2                	cmp    %eax,%edx
    bf65:	74 0a                	je     bf71 <lodepng_convert_rgb+0x1fb>
    bf67:	b8 52 00 00 00       	mov    $0x52,%eax
    bf6c:	e9 a4 00 00 00       	jmp    c015 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    bf71:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    bf78:	eb 79                	jmp    bff3 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    bf7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    bf7d:	c1 e0 02             	shl    $0x2,%eax
    bf80:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bf83:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf86:	c1 e8 08             	shr    $0x8,%eax
    bf89:	89 c1                	mov    %eax,%ecx
    bf8b:	8b 45 20             	mov    0x20(%ebp),%eax
    bf8e:	8b 50 08             	mov    0x8(%eax),%edx
    bf91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bf94:	01 d0                	add    %edx,%eax
    bf96:	0f b6 00             	movzbl (%eax),%eax
    bf99:	0f b6 c0             	movzbl %al,%eax
    bf9c:	39 c1                	cmp    %eax,%ecx
    bf9e:	75 4f                	jne    bfef <lodepng_convert_rgb+0x279>
    bfa0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bfa3:	c1 e8 08             	shr    $0x8,%eax
    bfa6:	89 c1                	mov    %eax,%ecx
    bfa8:	8b 45 20             	mov    0x20(%ebp),%eax
    bfab:	8b 40 08             	mov    0x8(%eax),%eax
    bfae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bfb1:	83 c2 01             	add    $0x1,%edx
    bfb4:	01 d0                	add    %edx,%eax
    bfb6:	0f b6 00             	movzbl (%eax),%eax
    bfb9:	0f b6 c0             	movzbl %al,%eax
    bfbc:	39 c1                	cmp    %eax,%ecx
    bfbe:	75 2f                	jne    bfef <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    bfc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bfc3:	c1 e8 08             	shr    $0x8,%eax
    bfc6:	89 c1                	mov    %eax,%ecx
    bfc8:	8b 45 20             	mov    0x20(%ebp),%eax
    bfcb:	8b 40 08             	mov    0x8(%eax),%eax
    bfce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bfd1:	83 c2 02             	add    $0x2,%edx
    bfd4:	01 d0                	add    %edx,%eax
    bfd6:	0f b6 00             	movzbl (%eax),%eax
    bfd9:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bfdc:	39 c1                	cmp    %eax,%ecx
    bfde:	75 0f                	jne    bfef <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    bfe0:	8b 45 08             	mov    0x8(%ebp),%eax
    bfe3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bfe6:	89 10                	mov    %edx,(%eax)
        return 0;
    bfe8:	b8 00 00 00 00       	mov    $0x0,%eax
    bfed:	eb 26                	jmp    c015 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    bfef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    bff3:	8b 45 20             	mov    0x20(%ebp),%eax
    bff6:	8b 40 0c             	mov    0xc(%eax),%eax
    bff9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    bffc:	0f 87 78 ff ff ff    	ja     bf7a <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c002:	b8 52 00 00 00       	mov    $0x52,%eax
    c007:	eb 0c                	jmp    c015 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c009:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c00e:	eb 05                	jmp    c015 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c010:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c015:	c9                   	leave  
    c016:	c3                   	ret    

0000c017 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c017:	55                   	push   %ebp
    c018:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c01a:	8b 45 08             	mov    0x8(%ebp),%eax
    c01d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c023:	8b 45 08             	mov    0x8(%ebp),%eax
    c026:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c02d:	8b 45 08             	mov    0x8(%ebp),%eax
    c030:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c036:	8b 45 08             	mov    0x8(%ebp),%eax
    c039:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c03d:	8b 45 08             	mov    0x8(%ebp),%eax
    c040:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c044:	8b 45 08             	mov    0x8(%ebp),%eax
    c047:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c04b:	8b 45 08             	mov    0x8(%ebp),%eax
    c04e:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c052:	8b 45 08             	mov    0x8(%ebp),%eax
    c055:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c05c:	8b 45 08             	mov    0x8(%ebp),%eax
    c05f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c066:	8b 45 08             	mov    0x8(%ebp),%eax
    c069:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c070:	00 00 00 
  stats->numpixels = 0;
    c073:	8b 45 08             	mov    0x8(%ebp),%eax
    c076:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c07d:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c080:	8b 45 08             	mov    0x8(%ebp),%eax
    c083:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c08a:	00 00 00 
  stats->allow_greyscale = 1;
    c08d:	8b 45 08             	mov    0x8(%ebp),%eax
    c090:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c097:	00 00 00 
}
    c09a:	90                   	nop
    c09b:	5d                   	pop    %ebp
    c09c:	c3                   	ret    

0000c09d <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c09d:	55                   	push   %ebp
    c09e:	89 e5                	mov    %esp,%ebp
    c0a0:	53                   	push   %ebx
    c0a1:	83 ec 04             	sub    $0x4,%esp
    c0a4:	8b 45 08             	mov    0x8(%ebp),%eax
    c0a7:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c0aa:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c0ae:	74 06                	je     c0b6 <getValueRequiredBits+0x19>
    c0b0:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c0b4:	75 07                	jne    c0bd <getValueRequiredBits+0x20>
    c0b6:	b8 01 00 00 00       	mov    $0x1,%eax
    c0bb:	eb 6b                	jmp    c128 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c0bd:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0c1:	0f b6 d9             	movzbl %cl,%ebx
    c0c4:	89 da                	mov    %ebx,%edx
    c0c6:	89 d0                	mov    %edx,%eax
    c0c8:	c1 e0 04             	shl    $0x4,%eax
    c0cb:	89 c2                	mov    %eax,%edx
    c0cd:	89 d0                	mov    %edx,%eax
    c0cf:	c1 e0 04             	shl    $0x4,%eax
    c0d2:	29 d0                	sub    %edx,%eax
    c0d4:	01 d8                	add    %ebx,%eax
    c0d6:	66 c1 e8 08          	shr    $0x8,%ax
    c0da:	c0 e8 04             	shr    $0x4,%al
    c0dd:	89 c2                	mov    %eax,%edx
    c0df:	c1 e2 04             	shl    $0x4,%edx
    c0e2:	01 c2                	add    %eax,%edx
    c0e4:	89 c8                	mov    %ecx,%eax
    c0e6:	29 d0                	sub    %edx,%eax
    c0e8:	84 c0                	test   %al,%al
    c0ea:	75 37                	jne    c123 <getValueRequiredBits+0x86>
    c0ec:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0f0:	0f b6 d1             	movzbl %cl,%edx
    c0f3:	89 d0                	mov    %edx,%eax
    c0f5:	01 c0                	add    %eax,%eax
    c0f7:	01 d0                	add    %edx,%eax
    c0f9:	c1 e0 06             	shl    $0x6,%eax
    c0fc:	01 d0                	add    %edx,%eax
    c0fe:	66 c1 e8 08          	shr    $0x8,%ax
    c102:	c0 e8 06             	shr    $0x6,%al
    c105:	ba 55 00 00 00       	mov    $0x55,%edx
    c10a:	0f af c2             	imul   %edx,%eax
    c10d:	29 c1                	sub    %eax,%ecx
    c10f:	89 c8                	mov    %ecx,%eax
    c111:	84 c0                	test   %al,%al
    c113:	75 07                	jne    c11c <getValueRequiredBits+0x7f>
    c115:	b8 02 00 00 00       	mov    $0x2,%eax
    c11a:	eb 0c                	jmp    c128 <getValueRequiredBits+0x8b>
    c11c:	b8 04 00 00 00       	mov    $0x4,%eax
    c121:	eb 05                	jmp    c128 <getValueRequiredBits+0x8b>
  return 8;
    c123:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c128:	83 c4 04             	add    $0x4,%esp
    c12b:	5b                   	pop    %ebx
    c12c:	5d                   	pop    %ebp
    c12d:	c3                   	ret    

0000c12e <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c12e:	55                   	push   %ebp
    c12f:	89 e5                	mov    %esp,%ebp
    c131:	56                   	push   %esi
    c132:	53                   	push   %ebx
    c133:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c139:	8b 55 10             	mov    0x10(%ebp),%edx
    c13c:	8b 45 14             	mov    0x14(%ebp),%eax
    c13f:	0f af c2             	imul   %edx,%eax
    c142:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c145:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c14c:	ff 75 18             	pushl  0x18(%ebp)
    c14f:	e8 0b cd ff ff       	call   8e5f <lodepng_is_greyscale_type>
    c154:	83 c4 04             	add    $0x4,%esp
    c157:	85 c0                	test   %eax,%eax
    c159:	0f 95 c0             	setne  %al
    c15c:	0f b6 c0             	movzbl %al,%eax
    c15f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c162:	ff 75 18             	pushl  0x18(%ebp)
    c165:	e8 85 cd ff ff       	call   8eef <lodepng_can_have_alpha>
    c16a:	83 c4 04             	add    $0x4,%esp
    c16d:	85 c0                	test   %eax,%eax
    c16f:	0f 94 c0             	sete   %al
    c172:	0f b6 c0             	movzbl %al,%eax
    c175:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c178:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c17f:	ff 75 18             	pushl  0x18(%ebp)
    c182:	e8 ab cc ff ff       	call   8e32 <lodepng_get_bpp>
    c187:	83 c4 04             	add    $0x4,%esp
    c18a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c18d:	8b 45 08             	mov    0x8(%ebp),%eax
    c190:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c196:	83 f8 01             	cmp    $0x1,%eax
    c199:	75 0d                	jne    c1a8 <lodepng_compute_color_stats+0x7a>
    c19b:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c19f:	75 07                	jne    c1a8 <lodepng_compute_color_stats+0x7a>
    c1a1:	b8 01 00 00 00       	mov    $0x1,%eax
    c1a6:	eb 05                	jmp    c1ad <lodepng_compute_color_stats+0x7f>
    c1a8:	b8 00 00 00 00       	mov    $0x0,%eax
    c1ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c1b0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c1b7:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c1be:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c1c2:	77 26                	ja     c1ea <lodepng_compute_color_stats+0xbc>
    c1c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c1c7:	8b 50 14             	mov    0x14(%eax),%edx
    c1ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c1cd:	bb 01 00 00 00       	mov    $0x1,%ebx
    c1d2:	89 c1                	mov    %eax,%ecx
    c1d4:	d3 e3                	shl    %cl,%ebx
    c1d6:	89 d8                	mov    %ebx,%eax
    c1d8:	01 d0                	add    %edx,%eax
    c1da:	ba 01 01 00 00       	mov    $0x101,%edx
    c1df:	3d 01 01 00 00       	cmp    $0x101,%eax
    c1e4:	0f 47 c2             	cmova  %edx,%eax
    c1e7:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c1ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c1ed:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c1f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c1f6:	01 c2                	add    %eax,%edx
    c1f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c1fb:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c201:	8b 45 08             	mov    0x8(%ebp),%eax
    c204:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c20a:	85 c0                	test   %eax,%eax
    c20c:	75 07                	jne    c215 <lodepng_compute_color_stats+0xe7>
    c20e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c215:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c21b:	50                   	push   %eax
    c21c:	e8 81 da ff ff       	call   9ca2 <color_tree_init>
    c221:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c224:	8b 45 08             	mov    0x8(%ebp),%eax
    c227:	8b 40 10             	mov    0x10(%eax),%eax
    c22a:	85 c0                	test   %eax,%eax
    c22c:	74 07                	je     c235 <lodepng_compute_color_stats+0x107>
    c22e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c235:	8b 45 08             	mov    0x8(%ebp),%eax
    c238:	8b 00                	mov    (%eax),%eax
    c23a:	85 c0                	test   %eax,%eax
    c23c:	74 07                	je     c245 <lodepng_compute_color_stats+0x117>
    c23e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c245:	8b 45 08             	mov    0x8(%ebp),%eax
    c248:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c24e:	83 f8 10             	cmp    $0x10,%eax
    c251:	75 07                	jne    c25a <lodepng_compute_color_stats+0x12c>
    c253:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c25a:	8b 45 08             	mov    0x8(%ebp),%eax
    c25d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c263:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c266:	72 07                	jb     c26f <lodepng_compute_color_stats+0x141>
    c268:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c26f:	8b 45 08             	mov    0x8(%ebp),%eax
    c272:	8b 40 14             	mov    0x14(%eax),%eax
    c275:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c278:	72 07                	jb     c281 <lodepng_compute_color_stats+0x153>
    c27a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c281:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c285:	0f 85 82 00 00 00    	jne    c30d <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c28b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c292:	eb 6c                	jmp    c300 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c294:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c297:	c1 e0 02             	shl    $0x2,%eax
    c29a:	8d 50 10             	lea    0x10(%eax),%edx
    c29d:	8b 45 08             	mov    0x8(%ebp),%eax
    c2a0:	01 d0                	add    %edx,%eax
    c2a2:	83 c0 08             	add    $0x8,%eax
    c2a5:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c2a8:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c2ab:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2ae:	83 c0 03             	add    $0x3,%eax
    c2b1:	0f b6 00             	movzbl (%eax),%eax
    c2b4:	0f b6 d8             	movzbl %al,%ebx
    c2b7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2ba:	83 c0 02             	add    $0x2,%eax
    c2bd:	0f b6 00             	movzbl (%eax),%eax
    c2c0:	0f b6 c8             	movzbl %al,%ecx
    c2c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2c6:	83 c0 01             	add    $0x1,%eax
    c2c9:	0f b6 00             	movzbl (%eax),%eax
    c2cc:	0f b6 d0             	movzbl %al,%edx
    c2cf:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2d2:	0f b6 00             	movzbl (%eax),%eax
    c2d5:	0f b6 c0             	movzbl %al,%eax
    c2d8:	83 ec 08             	sub    $0x8,%esp
    c2db:	56                   	push   %esi
    c2dc:	53                   	push   %ebx
    c2dd:	51                   	push   %ecx
    c2de:	52                   	push   %edx
    c2df:	50                   	push   %eax
    c2e0:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c2e6:	50                   	push   %eax
    c2e7:	e8 39 db ff ff       	call   9e25 <color_tree_add>
    c2ec:	83 c4 20             	add    $0x20,%esp
    c2ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c2f2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c2f6:	0f 85 22 09 00 00    	jne    cc1e <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c2fc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c300:	8b 45 08             	mov    0x8(%ebp),%eax
    c303:	8b 50 14             	mov    0x14(%eax),%edx
    c306:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c309:	39 c2                	cmp    %eax,%edx
    c30b:	77 87                	ja     c294 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c30d:	8b 45 18             	mov    0x18(%ebp),%eax
    c310:	8b 40 04             	mov    0x4(%eax),%eax
    c313:	83 f8 10             	cmp    $0x10,%eax
    c316:	0f 85 1e 01 00 00    	jne    c43a <lodepng_compute_color_stats+0x30c>
    c31c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c320:	0f 85 14 01 00 00    	jne    c43a <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c326:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c32d:	00 00 
    c32f:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c336:	00 00 
    c338:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c33f:	00 00 
    c341:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c348:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c34a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c351:	e9 d8 00 00 00       	jmp    c42e <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c356:	83 ec 04             	sub    $0x4,%esp
    c359:	ff 75 18             	pushl  0x18(%ebp)
    c35c:	ff 75 f4             	pushl  -0xc(%ebp)
    c35f:	ff 75 0c             	pushl  0xc(%ebp)
    c362:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c368:	50                   	push   %eax
    c369:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c36f:	50                   	push   %eax
    c370:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c376:	50                   	push   %eax
    c377:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c37d:	50                   	push   %eax
    c37e:	e8 a8 f2 ff ff       	call   b62b <getPixelColorRGBA16>
    c383:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c386:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c38d:	66 c1 e8 08          	shr    $0x8,%ax
    c391:	89 c2                	mov    %eax,%edx
    c393:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c39a:	31 d0                	xor    %edx,%eax
    c39c:	0f b7 c0             	movzwl %ax,%eax
    c39f:	0f b6 c0             	movzbl %al,%eax
    c3a2:	85 c0                	test   %eax,%eax
    c3a4:	75 60                	jne    c406 <lodepng_compute_color_stats+0x2d8>
    c3a6:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3ad:	66 c1 e8 08          	shr    $0x8,%ax
    c3b1:	89 c2                	mov    %eax,%edx
    c3b3:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3ba:	31 d0                	xor    %edx,%eax
    c3bc:	0f b7 c0             	movzwl %ax,%eax
    c3bf:	0f b6 c0             	movzbl %al,%eax
    c3c2:	85 c0                	test   %eax,%eax
    c3c4:	75 40                	jne    c406 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3c6:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3cd:	66 c1 e8 08          	shr    $0x8,%ax
    c3d1:	89 c2                	mov    %eax,%edx
    c3d3:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3da:	31 d0                	xor    %edx,%eax
    c3dc:	0f b7 c0             	movzwl %ax,%eax
    c3df:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c3e2:	85 c0                	test   %eax,%eax
    c3e4:	75 20                	jne    c406 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3e6:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c3ed:	66 c1 e8 08          	shr    $0x8,%ax
    c3f1:	89 c2                	mov    %eax,%edx
    c3f3:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c3fa:	31 d0                	xor    %edx,%eax
    c3fc:	0f b7 c0             	movzwl %ax,%eax
    c3ff:	0f b6 c0             	movzbl %al,%eax
    c402:	85 c0                	test   %eax,%eax
    c404:	74 24                	je     c42a <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c406:	8b 45 08             	mov    0x8(%ebp),%eax
    c409:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c410:	00 00 00 
        sixteen = 1;
    c413:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c41a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c421:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c428:	eb 10                	jmp    c43a <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c42a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c42e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c431:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c434:	0f 85 1c ff ff ff    	jne    c356 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c43a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c43e:	0f 84 bd 02 00 00    	je     c701 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c444:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c44b:	00 00 
    c44d:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c454:	00 00 
    c456:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c45d:	00 00 
    c45f:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c466:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c468:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c46f:	e9 b1 01 00 00       	jmp    c625 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c474:	83 ec 04             	sub    $0x4,%esp
    c477:	ff 75 18             	pushl  0x18(%ebp)
    c47a:	ff 75 f4             	pushl  -0xc(%ebp)
    c47d:	ff 75 0c             	pushl  0xc(%ebp)
    c480:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c486:	50                   	push   %eax
    c487:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c48d:	50                   	push   %eax
    c48e:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c494:	50                   	push   %eax
    c495:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c49b:	50                   	push   %eax
    c49c:	e8 8a f1 ff ff       	call   b62b <getPixelColorRGBA16>
    c4a1:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c4a4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c4a8:	75 36                	jne    c4e0 <lodepng_compute_color_stats+0x3b2>
    c4aa:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4b1:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c4b8:	66 39 c2             	cmp    %ax,%dx
    c4bb:	75 13                	jne    c4d0 <lodepng_compute_color_stats+0x3a2>
    c4bd:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4c4:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c4cb:	66 39 c2             	cmp    %ax,%dx
    c4ce:	74 10                	je     c4e0 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c4d0:	8b 45 08             	mov    0x8(%ebp),%eax
    c4d3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c4d9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c4e0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c4e4:	0f 85 1f 01 00 00    	jne    c609 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c4ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c4ed:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c4f1:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c4f8:	66 39 c2             	cmp    %ax,%dx
    c4fb:	75 2d                	jne    c52a <lodepng_compute_color_stats+0x3fc>
    c4fd:	8b 45 08             	mov    0x8(%ebp),%eax
    c500:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c504:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c50b:	66 39 c2             	cmp    %ax,%dx
    c50e:	75 1a                	jne    c52a <lodepng_compute_color_stats+0x3fc>
    c510:	8b 45 08             	mov    0x8(%ebp),%eax
    c513:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c517:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c51e:	66 39 c2             	cmp    %ax,%dx
    c521:	75 07                	jne    c52a <lodepng_compute_color_stats+0x3fc>
    c523:	b8 01 00 00 00       	mov    $0x1,%eax
    c528:	eb 05                	jmp    c52f <lodepng_compute_color_stats+0x401>
    c52a:	b8 00 00 00 00       	mov    $0x0,%eax
    c52f:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c532:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c539:	66 83 f8 ff          	cmp    $0xffff,%ax
    c53d:	74 3c                	je     c57b <lodepng_compute_color_stats+0x44d>
    c53f:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c546:	66 85 c0             	test   %ax,%ax
    c549:	75 10                	jne    c55b <lodepng_compute_color_stats+0x42d>
    c54b:	8b 45 08             	mov    0x8(%ebp),%eax
    c54e:	8b 40 04             	mov    0x4(%eax),%eax
    c551:	85 c0                	test   %eax,%eax
    c553:	74 26                	je     c57b <lodepng_compute_color_stats+0x44d>
    c555:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c559:	75 20                	jne    c57b <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c55b:	8b 45 08             	mov    0x8(%ebp),%eax
    c55e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c565:	8b 45 08             	mov    0x8(%ebp),%eax
    c568:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c56f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c576:	e9 8e 00 00 00       	jmp    c609 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c57b:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c582:	66 85 c0             	test   %ax,%ax
    c585:	75 4a                	jne    c5d1 <lodepng_compute_color_stats+0x4a3>
    c587:	8b 45 08             	mov    0x8(%ebp),%eax
    c58a:	8b 40 10             	mov    0x10(%eax),%eax
    c58d:	85 c0                	test   %eax,%eax
    c58f:	75 40                	jne    c5d1 <lodepng_compute_color_stats+0x4a3>
    c591:	8b 45 08             	mov    0x8(%ebp),%eax
    c594:	8b 40 04             	mov    0x4(%eax),%eax
    c597:	85 c0                	test   %eax,%eax
    c599:	75 36                	jne    c5d1 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c59b:	8b 45 08             	mov    0x8(%ebp),%eax
    c59e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c5a5:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c5ac:	8b 45 08             	mov    0x8(%ebp),%eax
    c5af:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c5b3:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c5ba:	8b 45 08             	mov    0x8(%ebp),%eax
    c5bd:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c5c1:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c5c8:	8b 45 08             	mov    0x8(%ebp),%eax
    c5cb:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c5cf:	eb 38                	jmp    c609 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c5d1:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5d8:	66 83 f8 ff          	cmp    $0xffff,%ax
    c5dc:	75 2b                	jne    c609 <lodepng_compute_color_stats+0x4db>
    c5de:	8b 45 08             	mov    0x8(%ebp),%eax
    c5e1:	8b 40 04             	mov    0x4(%eax),%eax
    c5e4:	85 c0                	test   %eax,%eax
    c5e6:	74 21                	je     c609 <lodepng_compute_color_stats+0x4db>
    c5e8:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c5ec:	74 1b                	je     c609 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c5ee:	8b 45 08             	mov    0x8(%ebp),%eax
    c5f1:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c5f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c5fb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c602:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c609:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c60d:	74 12                	je     c621 <lodepng_compute_color_stats+0x4f3>
    c60f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c613:	74 0c                	je     c621 <lodepng_compute_color_stats+0x4f3>
    c615:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c619:	74 06                	je     c621 <lodepng_compute_color_stats+0x4f3>
    c61b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c61f:	75 12                	jne    c633 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c621:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c625:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c628:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c62b:	0f 85 43 fe ff ff    	jne    c474 <lodepng_compute_color_stats+0x346>
    c631:	eb 01                	jmp    c634 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c633:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c634:	8b 45 08             	mov    0x8(%ebp),%eax
    c637:	8b 40 04             	mov    0x4(%eax),%eax
    c63a:	85 c0                	test   %eax,%eax
    c63c:	0f 84 e0 05 00 00    	je     cc22 <lodepng_compute_color_stats+0xaf4>
    c642:	8b 45 08             	mov    0x8(%ebp),%eax
    c645:	8b 40 10             	mov    0x10(%eax),%eax
    c648:	85 c0                	test   %eax,%eax
    c64a:	0f 85 d2 05 00 00    	jne    cc22 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c650:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c657:	e9 94 00 00 00       	jmp    c6f0 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c65c:	83 ec 04             	sub    $0x4,%esp
    c65f:	ff 75 18             	pushl  0x18(%ebp)
    c662:	ff 75 f4             	pushl  -0xc(%ebp)
    c665:	ff 75 0c             	pushl  0xc(%ebp)
    c668:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c66e:	50                   	push   %eax
    c66f:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c675:	50                   	push   %eax
    c676:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c67c:	50                   	push   %eax
    c67d:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c683:	50                   	push   %eax
    c684:	e8 a2 ef ff ff       	call   b62b <getPixelColorRGBA16>
    c689:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c68c:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c693:	66 85 c0             	test   %ax,%ax
    c696:	74 54                	je     c6ec <lodepng_compute_color_stats+0x5be>
    c698:	8b 45 08             	mov    0x8(%ebp),%eax
    c69b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c69f:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c6a6:	66 39 c2             	cmp    %ax,%dx
    c6a9:	75 41                	jne    c6ec <lodepng_compute_color_stats+0x5be>
    c6ab:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ae:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c6b2:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c6b9:	66 39 c2             	cmp    %ax,%dx
    c6bc:	75 2e                	jne    c6ec <lodepng_compute_color_stats+0x5be>
    c6be:	8b 45 08             	mov    0x8(%ebp),%eax
    c6c1:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c6c5:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c6cc:	66 39 c2             	cmp    %ax,%dx
    c6cf:	75 1b                	jne    c6ec <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c6d1:	8b 45 08             	mov    0x8(%ebp),%eax
    c6d4:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c6db:	8b 45 08             	mov    0x8(%ebp),%eax
    c6de:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c6e5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c6ec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6f3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c6f6:	0f 85 60 ff ff ff    	jne    c65c <lodepng_compute_color_stats+0x52e>
    c6fc:	e9 21 05 00 00       	jmp    cc22 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c701:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c708:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c70f:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c716:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c71d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c724:	e9 ab 03 00 00       	jmp    cad4 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c729:	83 ec 04             	sub    $0x4,%esp
    c72c:	ff 75 18             	pushl  0x18(%ebp)
    c72f:	ff 75 f4             	pushl  -0xc(%ebp)
    c732:	ff 75 0c             	pushl  0xc(%ebp)
    c735:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c73b:	50                   	push   %eax
    c73c:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c742:	50                   	push   %eax
    c743:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c749:	50                   	push   %eax
    c74a:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c750:	50                   	push   %eax
    c751:	e8 1e de ff ff       	call   a574 <getPixelColorRGBA8>
    c756:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c759:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c75d:	75 41                	jne    c7a0 <lodepng_compute_color_stats+0x672>
    c75f:	8b 45 08             	mov    0x8(%ebp),%eax
    c762:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c768:	83 f8 07             	cmp    $0x7,%eax
    c76b:	77 33                	ja     c7a0 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c76d:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c774:	0f b6 c0             	movzbl %al,%eax
    c777:	83 ec 0c             	sub    $0xc,%esp
    c77a:	50                   	push   %eax
    c77b:	e8 1d f9 ff ff       	call   c09d <getValueRequiredBits>
    c780:	83 c4 10             	add    $0x10,%esp
    c783:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c786:	8b 45 08             	mov    0x8(%ebp),%eax
    c789:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c78f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c792:	73 0c                	jae    c7a0 <lodepng_compute_color_stats+0x672>
    c794:	8b 45 08             	mov    0x8(%ebp),%eax
    c797:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c79a:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c7a0:	8b 45 08             	mov    0x8(%ebp),%eax
    c7a3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7a9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c7ac:	0f 93 c0             	setae  %al
    c7af:	0f b6 c0             	movzbl %al,%eax
    c7b2:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c7b5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c7b9:	75 4f                	jne    c80a <lodepng_compute_color_stats+0x6dc>
    c7bb:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7c2:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c7c9:	38 c2                	cmp    %al,%dl
    c7cb:	75 12                	jne    c7df <lodepng_compute_color_stats+0x6b1>
    c7cd:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7d4:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c7db:	38 c2                	cmp    %al,%dl
    c7dd:	74 2b                	je     c80a <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c7df:	8b 45 08             	mov    0x8(%ebp),%eax
    c7e2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c7e8:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c7ef:	8b 45 08             	mov    0x8(%ebp),%eax
    c7f2:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7f8:	83 f8 07             	cmp    $0x7,%eax
    c7fb:	77 0d                	ja     c80a <lodepng_compute_color_stats+0x6dc>
    c7fd:	8b 45 08             	mov    0x8(%ebp),%eax
    c800:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c807:	00 00 00 
      }

      if(!alpha_done) {
    c80a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c80e:	0f 85 65 01 00 00    	jne    c979 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c814:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c81b:	0f b6 d0             	movzbl %al,%edx
    c81e:	8b 45 08             	mov    0x8(%ebp),%eax
    c821:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c825:	66 39 c2             	cmp    %ax,%dx
    c828:	75 33                	jne    c85d <lodepng_compute_color_stats+0x72f>
    c82a:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c831:	0f b6 d0             	movzbl %al,%edx
    c834:	8b 45 08             	mov    0x8(%ebp),%eax
    c837:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c83b:	66 39 c2             	cmp    %ax,%dx
    c83e:	75 1d                	jne    c85d <lodepng_compute_color_stats+0x72f>
    c840:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c847:	0f b6 d0             	movzbl %al,%edx
    c84a:	8b 45 08             	mov    0x8(%ebp),%eax
    c84d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c851:	66 39 c2             	cmp    %ax,%dx
    c854:	75 07                	jne    c85d <lodepng_compute_color_stats+0x72f>
    c856:	b8 01 00 00 00       	mov    $0x1,%eax
    c85b:	eb 05                	jmp    c862 <lodepng_compute_color_stats+0x734>
    c85d:	b8 00 00 00 00       	mov    $0x0,%eax
    c862:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c865:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c86c:	3c ff                	cmp    $0xff,%al
    c86e:	74 5a                	je     c8ca <lodepng_compute_color_stats+0x79c>
    c870:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c877:	84 c0                	test   %al,%al
    c879:	75 10                	jne    c88b <lodepng_compute_color_stats+0x75d>
    c87b:	8b 45 08             	mov    0x8(%ebp),%eax
    c87e:	8b 40 04             	mov    0x4(%eax),%eax
    c881:	85 c0                	test   %eax,%eax
    c883:	74 45                	je     c8ca <lodepng_compute_color_stats+0x79c>
    c885:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c889:	75 3f                	jne    c8ca <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c88b:	8b 45 08             	mov    0x8(%ebp),%eax
    c88e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c895:	8b 45 08             	mov    0x8(%ebp),%eax
    c898:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c89f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c8a6:	8b 45 08             	mov    0x8(%ebp),%eax
    c8a9:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8af:	83 f8 07             	cmp    $0x7,%eax
    c8b2:	0f 87 c1 00 00 00    	ja     c979 <lodepng_compute_color_stats+0x84b>
    c8b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c8bb:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c8c2:	00 00 00 
    c8c5:	e9 af 00 00 00       	jmp    c979 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c8ca:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c8d1:	84 c0                	test   %al,%al
    c8d3:	75 53                	jne    c928 <lodepng_compute_color_stats+0x7fa>
    c8d5:	8b 45 08             	mov    0x8(%ebp),%eax
    c8d8:	8b 40 10             	mov    0x10(%eax),%eax
    c8db:	85 c0                	test   %eax,%eax
    c8dd:	75 49                	jne    c928 <lodepng_compute_color_stats+0x7fa>
    c8df:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e2:	8b 40 04             	mov    0x4(%eax),%eax
    c8e5:	85 c0                	test   %eax,%eax
    c8e7:	75 3f                	jne    c928 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c8e9:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ec:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c8f3:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c8fa:	0f b6 d0             	movzbl %al,%edx
    c8fd:	8b 45 08             	mov    0x8(%ebp),%eax
    c900:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c904:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c90b:	0f b6 d0             	movzbl %al,%edx
    c90e:	8b 45 08             	mov    0x8(%ebp),%eax
    c911:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c915:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c91c:	0f b6 d0             	movzbl %al,%edx
    c91f:	8b 45 08             	mov    0x8(%ebp),%eax
    c922:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c926:	eb 51                	jmp    c979 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    c928:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c92f:	3c ff                	cmp    $0xff,%al
    c931:	75 46                	jne    c979 <lodepng_compute_color_stats+0x84b>
    c933:	8b 45 08             	mov    0x8(%ebp),%eax
    c936:	8b 40 04             	mov    0x4(%eax),%eax
    c939:	85 c0                	test   %eax,%eax
    c93b:	74 3c                	je     c979 <lodepng_compute_color_stats+0x84b>
    c93d:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c941:	74 36                	je     c979 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c943:	8b 45 08             	mov    0x8(%ebp),%eax
    c946:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c94d:	8b 45 08             	mov    0x8(%ebp),%eax
    c950:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c957:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c95e:	8b 45 08             	mov    0x8(%ebp),%eax
    c961:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c967:	83 f8 07             	cmp    $0x7,%eax
    c96a:	77 0d                	ja     c979 <lodepng_compute_color_stats+0x84b>
    c96c:	8b 45 08             	mov    0x8(%ebp),%eax
    c96f:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c976:	00 00 00 
        }
      }

      if(!numcolors_done) {
    c979:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c97d:	0f 85 35 01 00 00    	jne    cab8 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    c983:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c98a:	0f b6 d8             	movzbl %al,%ebx
    c98d:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c994:	0f b6 c8             	movzbl %al,%ecx
    c997:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c99e:	0f b6 d0             	movzbl %al,%edx
    c9a1:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9a8:	0f b6 c0             	movzbl %al,%eax
    c9ab:	83 ec 0c             	sub    $0xc,%esp
    c9ae:	53                   	push   %ebx
    c9af:	51                   	push   %ecx
    c9b0:	52                   	push   %edx
    c9b1:	50                   	push   %eax
    c9b2:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c9b8:	50                   	push   %eax
    c9b9:	e8 1c d4 ff ff       	call   9dda <color_tree_has>
    c9be:	83 c4 20             	add    $0x20,%esp
    c9c1:	85 c0                	test   %eax,%eax
    c9c3:	0f 85 ef 00 00 00    	jne    cab8 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    c9c9:	8b 45 08             	mov    0x8(%ebp),%eax
    c9cc:	8b 70 14             	mov    0x14(%eax),%esi
    c9cf:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9d6:	0f b6 d8             	movzbl %al,%ebx
    c9d9:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9e0:	0f b6 c8             	movzbl %al,%ecx
    c9e3:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9ea:	0f b6 d0             	movzbl %al,%edx
    c9ed:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9f4:	0f b6 c0             	movzbl %al,%eax
    c9f7:	83 ec 08             	sub    $0x8,%esp
    c9fa:	56                   	push   %esi
    c9fb:	53                   	push   %ebx
    c9fc:	51                   	push   %ecx
    c9fd:	52                   	push   %edx
    c9fe:	50                   	push   %eax
    c9ff:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ca05:	50                   	push   %eax
    ca06:	e8 1a d4 ff ff       	call   9e25 <color_tree_add>
    ca0b:	83 c4 20             	add    $0x20,%esp
    ca0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    ca11:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ca15:	0f 85 06 02 00 00    	jne    cc21 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    ca1b:	8b 45 08             	mov    0x8(%ebp),%eax
    ca1e:	8b 40 14             	mov    0x14(%eax),%eax
    ca21:	3d ff 00 00 00       	cmp    $0xff,%eax
    ca26:	77 6f                	ja     ca97 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    ca28:	8b 45 08             	mov    0x8(%ebp),%eax
    ca2b:	83 c0 18             	add    $0x18,%eax
    ca2e:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    ca31:	8b 45 08             	mov    0x8(%ebp),%eax
    ca34:	8b 40 14             	mov    0x14(%eax),%eax
    ca37:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    ca3a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca3d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ca44:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca47:	01 c2                	add    %eax,%edx
    ca49:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca50:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    ca52:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca55:	c1 e0 02             	shl    $0x2,%eax
    ca58:	8d 50 01             	lea    0x1(%eax),%edx
    ca5b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca5e:	01 c2                	add    %eax,%edx
    ca60:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca67:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    ca69:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca6c:	c1 e0 02             	shl    $0x2,%eax
    ca6f:	8d 50 02             	lea    0x2(%eax),%edx
    ca72:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca75:	01 c2                	add    %eax,%edx
    ca77:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca7e:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    ca80:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca83:	c1 e0 02             	shl    $0x2,%eax
    ca86:	8d 50 03             	lea    0x3(%eax),%edx
    ca89:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca8c:	01 c2                	add    %eax,%edx
    ca8e:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca95:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    ca97:	8b 45 08             	mov    0x8(%ebp),%eax
    ca9a:	8b 40 14             	mov    0x14(%eax),%eax
    ca9d:	8d 50 01             	lea    0x1(%eax),%edx
    caa0:	8b 45 08             	mov    0x8(%ebp),%eax
    caa3:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    caa6:	8b 45 08             	mov    0x8(%ebp),%eax
    caa9:	8b 40 14             	mov    0x14(%eax),%eax
    caac:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    caaf:	0f 93 c0             	setae  %al
    cab2:	0f b6 c0             	movzbl %al,%eax
    cab5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cab8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cabc:	74 12                	je     cad0 <lodepng_compute_color_stats+0x9a2>
    cabe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cac2:	74 0c                	je     cad0 <lodepng_compute_color_stats+0x9a2>
    cac4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cac8:	74 06                	je     cad0 <lodepng_compute_color_stats+0x9a2>
    caca:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cace:	75 12                	jne    cae2 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cad0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cad4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cad7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cada:	0f 85 49 fc ff ff    	jne    c729 <lodepng_compute_color_stats+0x5fb>
    cae0:	eb 01                	jmp    cae3 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cae2:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cae3:	8b 45 08             	mov    0x8(%ebp),%eax
    cae6:	8b 40 04             	mov    0x4(%eax),%eax
    cae9:	85 c0                	test   %eax,%eax
    caeb:	0f 84 dd 00 00 00    	je     cbce <lodepng_compute_color_stats+0xaa0>
    caf1:	8b 45 08             	mov    0x8(%ebp),%eax
    caf4:	8b 40 10             	mov    0x10(%eax),%eax
    caf7:	85 c0                	test   %eax,%eax
    caf9:	0f 85 cf 00 00 00    	jne    cbce <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    caff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cb06:	e9 b7 00 00 00       	jmp    cbc2 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cb0b:	83 ec 04             	sub    $0x4,%esp
    cb0e:	ff 75 18             	pushl  0x18(%ebp)
    cb11:	ff 75 f4             	pushl  -0xc(%ebp)
    cb14:	ff 75 0c             	pushl  0xc(%ebp)
    cb17:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cb1d:	50                   	push   %eax
    cb1e:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cb24:	50                   	push   %eax
    cb25:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cb2b:	50                   	push   %eax
    cb2c:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cb32:	50                   	push   %eax
    cb33:	e8 3c da ff ff       	call   a574 <getPixelColorRGBA8>
    cb38:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cb3b:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb42:	84 c0                	test   %al,%al
    cb44:	74 78                	je     cbbe <lodepng_compute_color_stats+0xa90>
    cb46:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb4d:	0f b6 d0             	movzbl %al,%edx
    cb50:	8b 45 08             	mov    0x8(%ebp),%eax
    cb53:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb57:	66 39 c2             	cmp    %ax,%dx
    cb5a:	75 62                	jne    cbbe <lodepng_compute_color_stats+0xa90>
    cb5c:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb63:	0f b6 d0             	movzbl %al,%edx
    cb66:	8b 45 08             	mov    0x8(%ebp),%eax
    cb69:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cb6d:	66 39 c2             	cmp    %ax,%dx
    cb70:	75 4c                	jne    cbbe <lodepng_compute_color_stats+0xa90>
    cb72:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb79:	0f b6 d0             	movzbl %al,%edx
    cb7c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb7f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cb83:	66 39 c2             	cmp    %ax,%dx
    cb86:	75 36                	jne    cbbe <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cb88:	8b 45 08             	mov    0x8(%ebp),%eax
    cb8b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cb92:	8b 45 08             	mov    0x8(%ebp),%eax
    cb95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cb9c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cba3:	8b 45 08             	mov    0x8(%ebp),%eax
    cba6:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cbac:	83 f8 07             	cmp    $0x7,%eax
    cbaf:	77 0d                	ja     cbbe <lodepng_compute_color_stats+0xa90>
    cbb1:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb4:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cbbb:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cbbe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cbc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cbc5:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cbc8:	0f 85 3d ff ff ff    	jne    cb0b <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cbce:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd1:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cbd5:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cbdc:	c1 e0 08             	shl    $0x8,%eax
    cbdf:	01 c2                	add    %eax,%edx
    cbe1:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe4:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cbe8:	8b 45 08             	mov    0x8(%ebp),%eax
    cbeb:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cbef:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cbf6:	c1 e0 08             	shl    $0x8,%eax
    cbf9:	01 c2                	add    %eax,%edx
    cbfb:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfe:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cc02:	8b 45 08             	mov    0x8(%ebp),%eax
    cc05:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cc09:	8b 45 08             	mov    0x8(%ebp),%eax
    cc0c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc10:	c1 e0 08             	shl    $0x8,%eax
    cc13:	01 c2                	add    %eax,%edx
    cc15:	8b 45 08             	mov    0x8(%ebp),%eax
    cc18:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cc1c:	eb 04                	jmp    cc22 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cc1e:	90                   	nop
    cc1f:	eb 01                	jmp    cc22 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cc21:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cc22:	83 ec 0c             	sub    $0xc,%esp
    cc25:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cc2b:	50                   	push   %eax
    cc2c:	e8 91 d0 ff ff       	call   9cc2 <color_tree_cleanup>
    cc31:	83 c4 10             	add    $0x10,%esp
  return error;
    cc34:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cc37:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cc3a:	5b                   	pop    %ebx
    cc3b:	5e                   	pop    %esi
    cc3c:	5d                   	pop    %ebp
    cc3d:	c3                   	ret    

0000cc3e <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cc3e:	55                   	push   %ebp
    cc3f:	89 e5                	mov    %esp,%ebp
    cc41:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cc44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cc4b:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cc4e:	50                   	push   %eax
    cc4f:	e8 d1 bd ff ff       	call   8a25 <lodepng_color_mode_init>
    cc54:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cc57:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc5a:	c1 e8 08             	shr    $0x8,%eax
    cc5d:	88 45 ec             	mov    %al,-0x14(%ebp)
    cc60:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc63:	88 45 ed             	mov    %al,-0x13(%ebp)
    cc66:	8b 45 10             	mov    0x10(%ebp),%eax
    cc69:	c1 e8 08             	shr    $0x8,%eax
    cc6c:	88 45 ee             	mov    %al,-0x12(%ebp)
    cc6f:	8b 45 10             	mov    0x10(%ebp),%eax
    cc72:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cc75:	8b 45 14             	mov    0x14(%ebp),%eax
    cc78:	c1 e8 08             	shr    $0x8,%eax
    cc7b:	88 45 f0             	mov    %al,-0x10(%ebp)
    cc7e:	8b 45 14             	mov    0x14(%ebp),%eax
    cc81:	88 45 f1             	mov    %al,-0xf(%ebp)
    cc84:	8b 45 18             	mov    0x18(%ebp),%eax
    cc87:	c1 e8 08             	shr    $0x8,%eax
    cc8a:	88 45 f2             	mov    %al,-0xe(%ebp)
    cc8d:	8b 45 18             	mov    0x18(%ebp),%eax
    cc90:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cc93:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cc9a:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cca1:	83 ec 0c             	sub    $0xc,%esp
    cca4:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cca7:	50                   	push   %eax
    cca8:	6a 01                	push   $0x1
    ccaa:	6a 01                	push   $0x1
    ccac:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ccaf:	50                   	push   %eax
    ccb0:	ff 75 08             	pushl  0x8(%ebp)
    ccb3:	e8 76 f4 ff ff       	call   c12e <lodepng_compute_color_stats>
    ccb8:	83 c4 20             	add    $0x20,%esp
    ccbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    ccbe:	83 ec 0c             	sub    $0xc,%esp
    ccc1:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccc4:	50                   	push   %eax
    ccc5:	e8 4e be ff ff       	call   8b18 <lodepng_color_mode_cleanup>
    ccca:	83 c4 10             	add    $0x10,%esp
  return error;
    cccd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ccd0:	c9                   	leave  
    ccd1:	c3                   	ret    

0000ccd2 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    ccd2:	55                   	push   %ebp
    ccd3:	89 e5                	mov    %esp,%ebp
    ccd5:	56                   	push   %esi
    ccd6:	53                   	push   %ebx
    ccd7:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    ccda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cce1:	8b 45 10             	mov    0x10(%ebp),%eax
    cce4:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    ccea:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    cced:	8b 45 10             	mov    0x10(%ebp),%eax
    ccf0:	8b 40 10             	mov    0x10(%eax),%eax
    ccf3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    ccf6:	8b 45 10             	mov    0x10(%ebp),%eax
    ccf9:	8b 40 04             	mov    0x4(%eax),%eax
    ccfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    ccff:	8b 45 10             	mov    0x10(%ebp),%eax
    cd02:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd08:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cd0b:	8b 45 08             	mov    0x8(%ebp),%eax
    cd0e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cd15:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cd19:	74 21                	je     cd3c <auto_choose_color+0x6a>
    cd1b:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cd1f:	7f 1b                	jg     cd3c <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cd21:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    cd28:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cd2f:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd33:	77 07                	ja     cd3c <auto_choose_color+0x6a>
    cd35:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    cd3c:	8b 45 10             	mov    0x10(%ebp),%eax
    cd3f:	8b 00                	mov    (%eax),%eax
    cd41:	85 c0                	test   %eax,%eax
    cd43:	0f 94 c0             	sete   %al
    cd46:	0f b6 c0             	movzbl %al,%eax
    cd49:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cd4c:	8b 45 10             	mov    0x10(%ebp),%eax
    cd4f:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cd55:	85 c0                	test   %eax,%eax
    cd57:	75 07                	jne    cd60 <auto_choose_color+0x8e>
    cd59:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    cd60:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd64:	75 0d                	jne    cd73 <auto_choose_color+0xa1>
    cd66:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd6a:	77 07                	ja     cd73 <auto_choose_color+0xa1>
    cd6c:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    cd73:	8b 45 10             	mov    0x10(%ebp),%eax
    cd76:	8b 40 14             	mov    0x14(%eax),%eax
    cd79:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    cd7c:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    cd80:	7e 21                	jle    cda3 <auto_choose_color+0xd1>
    cd82:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    cd86:	7e 14                	jle    cd9c <auto_choose_color+0xca>
    cd88:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    cd8c:	7f 07                	jg     cd95 <auto_choose_color+0xc3>
    cd8e:	b8 04 00 00 00       	mov    $0x4,%eax
    cd93:	eb 13                	jmp    cda8 <auto_choose_color+0xd6>
    cd95:	b8 08 00 00 00       	mov    $0x8,%eax
    cd9a:	eb 0c                	jmp    cda8 <auto_choose_color+0xd6>
    cd9c:	b8 02 00 00 00       	mov    $0x2,%eax
    cda1:	eb 05                	jmp    cda8 <auto_choose_color+0xd6>
    cda3:	b8 01 00 00 00       	mov    $0x1,%eax
    cda8:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    cdab:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    cdb2:	7f 13                	jg     cdc7 <auto_choose_color+0xf5>
    cdb4:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    cdb8:	77 0d                	ja     cdc7 <auto_choose_color+0xf5>
    cdba:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    cdbe:	74 07                	je     cdc7 <auto_choose_color+0xf5>
    cdc0:	b8 01 00 00 00       	mov    $0x1,%eax
    cdc5:	eb 05                	jmp    cdcc <auto_choose_color+0xfa>
    cdc7:	b8 00 00 00 00       	mov    $0x0,%eax
    cdcc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    cdcf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cdd2:	01 c0                	add    %eax,%eax
    cdd4:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cdd7:	7e 07                	jle    cde0 <auto_choose_color+0x10e>
    cdd9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    cde0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cde4:	74 15                	je     cdfb <auto_choose_color+0x129>
    cde6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cdea:	75 0f                	jne    cdfb <auto_choose_color+0x129>
    cdec:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cdef:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cdf2:	77 07                	ja     cdfb <auto_choose_color+0x129>
    cdf4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    cdfb:	8b 45 10             	mov    0x10(%ebp),%eax
    cdfe:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    ce04:	85 c0                	test   %eax,%eax
    ce06:	75 07                	jne    ce0f <auto_choose_color+0x13d>
    ce08:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    ce0f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ce13:	0f 84 0a 01 00 00    	je     cf23 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    ce19:	8b 45 10             	mov    0x10(%ebp),%eax
    ce1c:	83 c0 18             	add    $0x18,%eax
    ce1f:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    ce22:	83 ec 0c             	sub    $0xc,%esp
    ce25:	ff 75 08             	pushl  0x8(%ebp)
    ce28:	e8 ef be ff ff       	call   8d1c <lodepng_palette_clear>
    ce2d:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    ce30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ce37:	eb 6e                	jmp    cea7 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    ce39:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce3c:	c1 e0 02             	shl    $0x2,%eax
    ce3f:	8d 50 03             	lea    0x3(%eax),%edx
    ce42:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce45:	01 d0                	add    %edx,%eax
    ce47:	0f b6 00             	movzbl (%eax),%eax
    ce4a:	0f b6 d8             	movzbl %al,%ebx
    ce4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce50:	c1 e0 02             	shl    $0x2,%eax
    ce53:	8d 50 02             	lea    0x2(%eax),%edx
    ce56:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce59:	01 d0                	add    %edx,%eax
    ce5b:	0f b6 00             	movzbl (%eax),%eax
    ce5e:	0f b6 c8             	movzbl %al,%ecx
    ce61:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce64:	c1 e0 02             	shl    $0x2,%eax
    ce67:	8d 50 01             	lea    0x1(%eax),%edx
    ce6a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce6d:	01 d0                	add    %edx,%eax
    ce6f:	0f b6 00             	movzbl (%eax),%eax
    ce72:	0f b6 d0             	movzbl %al,%edx
    ce75:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce78:	c1 e0 02             	shl    $0x2,%eax
    ce7b:	89 c6                	mov    %eax,%esi
    ce7d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce80:	01 f0                	add    %esi,%eax
    ce82:	0f b6 00             	movzbl (%eax),%eax
    ce85:	0f b6 c0             	movzbl %al,%eax
    ce88:	83 ec 0c             	sub    $0xc,%esp
    ce8b:	53                   	push   %ebx
    ce8c:	51                   	push   %ecx
    ce8d:	52                   	push   %edx
    ce8e:	50                   	push   %eax
    ce8f:	ff 75 08             	pushl  0x8(%ebp)
    ce92:	e8 be be ff ff       	call   8d55 <lodepng_palette_add>
    ce97:	83 c4 20             	add    $0x20,%esp
    ce9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    ce9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cea1:	75 13                	jne    ceb6 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    cea3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    cea7:	8b 45 10             	mov    0x10(%ebp),%eax
    ceaa:	8b 50 14             	mov    0x14(%eax),%edx
    cead:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ceb0:	39 c2                	cmp    %eax,%edx
    ceb2:	75 85                	jne    ce39 <auto_choose_color+0x167>
    ceb4:	eb 01                	jmp    ceb7 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    ceb6:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    ceb7:	8b 45 08             	mov    0x8(%ebp),%eax
    ceba:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    cec0:	8b 45 08             	mov    0x8(%ebp),%eax
    cec3:	8b 55 d0             	mov    -0x30(%ebp),%edx
    cec6:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    cec9:	8b 45 0c             	mov    0xc(%ebp),%eax
    cecc:	8b 00                	mov    (%eax),%eax
    cece:	83 f8 03             	cmp    $0x3,%eax
    ced1:	0f 85 ec 00 00 00    	jne    cfc3 <auto_choose_color+0x2f1>
    ced7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ceda:	8b 50 0c             	mov    0xc(%eax),%edx
    cedd:	8b 45 08             	mov    0x8(%ebp),%eax
    cee0:	8b 40 0c             	mov    0xc(%eax),%eax
    cee3:	39 c2                	cmp    %eax,%edx
    cee5:	0f 8c d8 00 00 00    	jl     cfc3 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    ceeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    ceee:	8b 50 04             	mov    0x4(%eax),%edx
    cef1:	8b 45 08             	mov    0x8(%ebp),%eax
    cef4:	8b 40 04             	mov    0x4(%eax),%eax
    cef7:	39 c2                	cmp    %eax,%edx
    cef9:	0f 85 c4 00 00 00    	jne    cfc3 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    ceff:	83 ec 0c             	sub    $0xc,%esp
    cf02:	ff 75 08             	pushl  0x8(%ebp)
    cf05:	e8 0e bc ff ff       	call   8b18 <lodepng_color_mode_cleanup>
    cf0a:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    cf0d:	83 ec 08             	sub    $0x8,%esp
    cf10:	ff 75 0c             	pushl  0xc(%ebp)
    cf13:	ff 75 08             	pushl  0x8(%ebp)
    cf16:	e8 14 bc ff ff       	call   8b2f <lodepng_color_mode_copy>
    cf1b:	83 c4 10             	add    $0x10,%esp
    cf1e:	e9 a0 00 00 00       	jmp    cfc3 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    cf23:	8b 45 08             	mov    0x8(%ebp),%eax
    cf26:	8b 55 dc             	mov    -0x24(%ebp),%edx
    cf29:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    cf2c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cf30:	74 14                	je     cf46 <auto_choose_color+0x274>
    cf32:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf36:	74 07                	je     cf3f <auto_choose_color+0x26d>
    cf38:	b8 04 00 00 00       	mov    $0x4,%eax
    cf3d:	eb 19                	jmp    cf58 <auto_choose_color+0x286>
    cf3f:	b8 06 00 00 00       	mov    $0x6,%eax
    cf44:	eb 12                	jmp    cf58 <auto_choose_color+0x286>
    cf46:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf4a:	74 07                	je     cf53 <auto_choose_color+0x281>
    cf4c:	b8 00 00 00 00       	mov    $0x0,%eax
    cf51:	eb 05                	jmp    cf58 <auto_choose_color+0x286>
    cf53:	b8 02 00 00 00       	mov    $0x2,%eax
    cf58:	8b 55 08             	mov    0x8(%ebp),%edx
    cf5b:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    cf5d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cf61:	74 60                	je     cfc3 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    cf63:	8b 45 08             	mov    0x8(%ebp),%eax
    cf66:	8b 40 04             	mov    0x4(%eax),%eax
    cf69:	ba 01 00 00 00       	mov    $0x1,%edx
    cf6e:	89 c1                	mov    %eax,%ecx
    cf70:	d3 e2                	shl    %cl,%edx
    cf72:	89 d0                	mov    %edx,%eax
    cf74:	83 e8 01             	sub    $0x1,%eax
    cf77:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    cf7a:	8b 45 10             	mov    0x10(%ebp),%eax
    cf7d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cf81:	0f b7 c0             	movzwl %ax,%eax
    cf84:	23 45 c8             	and    -0x38(%ebp),%eax
    cf87:	89 c2                	mov    %eax,%edx
    cf89:	8b 45 08             	mov    0x8(%ebp),%eax
    cf8c:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    cf8f:	8b 45 10             	mov    0x10(%ebp),%eax
    cf92:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cf96:	0f b7 c0             	movzwl %ax,%eax
    cf99:	23 45 c8             	and    -0x38(%ebp),%eax
    cf9c:	89 c2                	mov    %eax,%edx
    cf9e:	8b 45 08             	mov    0x8(%ebp),%eax
    cfa1:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    cfa4:	8b 45 10             	mov    0x10(%ebp),%eax
    cfa7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cfab:	0f b7 c0             	movzwl %ax,%eax
    cfae:	23 45 c8             	and    -0x38(%ebp),%eax
    cfb1:	89 c2                	mov    %eax,%edx
    cfb3:	8b 45 08             	mov    0x8(%ebp),%eax
    cfb6:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    cfb9:	8b 45 08             	mov    0x8(%ebp),%eax
    cfbc:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    cfc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cfc6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cfc9:	5b                   	pop    %ebx
    cfca:	5e                   	pop    %esi
    cfcb:	5d                   	pop    %ebp
    cfcc:	c3                   	ret    

0000cfcd <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    cfcd:	55                   	push   %ebp
    cfce:	89 e5                	mov    %esp,%ebp
    cfd0:	83 ec 1c             	sub    $0x1c,%esp
    cfd3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    cfd6:	8b 55 0c             	mov    0xc(%ebp),%edx
    cfd9:	8b 45 10             	mov    0x10(%ebp),%eax
    cfdc:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    cfe0:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    cfe4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    cfe8:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    cfec:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    cff0:	29 c2                	sub    %eax,%edx
    cff2:	89 d0                	mov    %edx,%eax
    cff4:	99                   	cltd   
    cff5:	31 d0                	xor    %edx,%eax
    cff7:	29 d0                	sub    %edx,%eax
    cff9:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    cffd:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d001:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d005:	29 c2                	sub    %eax,%edx
    d007:	89 d0                	mov    %edx,%eax
    d009:	99                   	cltd   
    d00a:	31 d0                	xor    %edx,%eax
    d00c:	29 d0                	sub    %edx,%eax
    d00e:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d012:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d016:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d01a:	01 c2                	add    %eax,%edx
    d01c:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d020:	29 c2                	sub    %eax,%edx
    d022:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d026:	29 c2                	sub    %eax,%edx
    d028:	89 d0                	mov    %edx,%eax
    d02a:	99                   	cltd   
    d02b:	31 d0                	xor    %edx,%eax
    d02d:	29 d0                	sub    %edx,%eax
    d02f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d033:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d037:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d03b:	7d 10                	jge    d04d <paethPredictor+0x80>
    d03d:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d041:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d045:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d049:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d04d:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d051:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d055:	7d 06                	jge    d05d <paethPredictor+0x90>
    d057:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d05b:	eb 04                	jmp    d061 <paethPredictor+0x94>
    d05d:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d061:	c9                   	leave  
    d062:	c3                   	ret    

0000d063 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d063:	55                   	push   %ebp
    d064:	89 e5                	mov    %esp,%ebp
    d066:	56                   	push   %esi
    d067:	53                   	push   %ebx
    d068:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d06b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d072:	e9 e2 00 00 00       	jmp    d159 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d077:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d07a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d081:	8b 45 08             	mov    0x8(%ebp),%eax
    d084:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d087:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d08a:	8b 14 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%edx
    d091:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d094:	01 c2                	add    %eax,%edx
    d096:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d099:	8b 04 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%eax
    d0a0:	29 c2                	sub    %eax,%edx
    d0a2:	89 d0                	mov    %edx,%eax
    d0a4:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0aa:	8b 34 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%esi
    d0b1:	89 d8                	mov    %ebx,%eax
    d0b3:	ba 00 00 00 00       	mov    $0x0,%edx
    d0b8:	f7 f6                	div    %esi
    d0ba:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d0bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0c9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d0cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0cf:	8b 14 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%edx
    d0d6:	8b 45 20             	mov    0x20(%ebp),%eax
    d0d9:	01 c2                	add    %eax,%edx
    d0db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0de:	8b 04 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%eax
    d0e5:	29 c2                	sub    %eax,%edx
    d0e7:	89 d0                	mov    %edx,%eax
    d0e9:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0ef:	8b 34 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%esi
    d0f6:	89 d8                	mov    %ebx,%eax
    d0f8:	ba 00 00 00 00       	mov    $0x0,%edx
    d0fd:	f7 f6                	div    %esi
    d0ff:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d101:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d104:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d10b:	8b 45 08             	mov    0x8(%ebp),%eax
    d10e:	01 d0                	add    %edx,%eax
    d110:	8b 00                	mov    (%eax),%eax
    d112:	85 c0                	test   %eax,%eax
    d114:	75 15                	jne    d12b <Adam7_getpassvalues+0xc8>
    d116:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d119:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d120:	8b 45 0c             	mov    0xc(%ebp),%eax
    d123:	01 d0                	add    %edx,%eax
    d125:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d12b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d12e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d135:	8b 45 0c             	mov    0xc(%ebp),%eax
    d138:	01 d0                	add    %edx,%eax
    d13a:	8b 00                	mov    (%eax),%eax
    d13c:	85 c0                	test   %eax,%eax
    d13e:	75 15                	jne    d155 <Adam7_getpassvalues+0xf2>
    d140:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d143:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d14a:	8b 45 08             	mov    0x8(%ebp),%eax
    d14d:	01 d0                	add    %edx,%eax
    d14f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d155:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d159:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d15d:	0f 85 14 ff ff ff    	jne    d077 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d163:	8b 45 18             	mov    0x18(%ebp),%eax
    d166:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d16c:	8b 45 18             	mov    0x18(%ebp),%eax
    d16f:	8b 10                	mov    (%eax),%edx
    d171:	8b 45 14             	mov    0x14(%ebp),%eax
    d174:	89 10                	mov    %edx,(%eax)
    d176:	8b 45 14             	mov    0x14(%ebp),%eax
    d179:	8b 10                	mov    (%eax),%edx
    d17b:	8b 45 10             	mov    0x10(%ebp),%eax
    d17e:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d180:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d187:	e9 40 01 00 00       	jmp    d2cc <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d18c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d18f:	83 c0 01             	add    $0x1,%eax
    d192:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d199:	8b 45 10             	mov    0x10(%ebp),%eax
    d19c:	01 c2                	add    %eax,%edx
    d19e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1a1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1a8:	8b 45 10             	mov    0x10(%ebp),%eax
    d1ab:	01 c8                	add    %ecx,%eax
    d1ad:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d1af:	89 c6                	mov    %eax,%esi
    d1b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1b4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1bb:	8b 45 08             	mov    0x8(%ebp),%eax
    d1be:	01 c8                	add    %ecx,%eax
    d1c0:	8b 00                	mov    (%eax),%eax
    d1c2:	85 c0                	test   %eax,%eax
    d1c4:	74 49                	je     d20f <Adam7_getpassvalues+0x1ac>
    d1c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1c9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1d3:	01 c8                	add    %ecx,%eax
    d1d5:	8b 00                	mov    (%eax),%eax
    d1d7:	85 c0                	test   %eax,%eax
    d1d9:	74 34                	je     d20f <Adam7_getpassvalues+0x1ac>
    d1db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1de:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1e8:	01 c8                	add    %ecx,%eax
    d1ea:	8b 08                	mov    (%eax),%ecx
    d1ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ef:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d1f6:	8b 45 08             	mov    0x8(%ebp),%eax
    d1f9:	01 d8                	add    %ebx,%eax
    d1fb:	8b 00                	mov    (%eax),%eax
    d1fd:	0f af 45 24          	imul   0x24(%ebp),%eax
    d201:	83 c0 07             	add    $0x7,%eax
    d204:	c1 e8 03             	shr    $0x3,%eax
    d207:	83 c0 01             	add    $0x1,%eax
    d20a:	0f af c1             	imul   %ecx,%eax
    d20d:	eb 05                	jmp    d214 <Adam7_getpassvalues+0x1b1>
    d20f:	b8 00 00 00 00       	mov    $0x0,%eax
    d214:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d216:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d218:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d21b:	83 c0 01             	add    $0x1,%eax
    d21e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d225:	8b 45 14             	mov    0x14(%ebp),%eax
    d228:	01 c2                	add    %eax,%edx
    d22a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d22d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d234:	8b 45 14             	mov    0x14(%ebp),%eax
    d237:	01 c8                	add    %ecx,%eax
    d239:	8b 00                	mov    (%eax),%eax
    d23b:	89 c6                	mov    %eax,%esi
    d23d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d240:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d247:	8b 45 0c             	mov    0xc(%ebp),%eax
    d24a:	01 c8                	add    %ecx,%eax
    d24c:	8b 08                	mov    (%eax),%ecx
    d24e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d251:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d258:	8b 45 08             	mov    0x8(%ebp),%eax
    d25b:	01 d8                	add    %ebx,%eax
    d25d:	8b 00                	mov    (%eax),%eax
    d25f:	0f af 45 24          	imul   0x24(%ebp),%eax
    d263:	83 c0 07             	add    $0x7,%eax
    d266:	c1 e8 03             	shr    $0x3,%eax
    d269:	0f af c1             	imul   %ecx,%eax
    d26c:	01 f0                	add    %esi,%eax
    d26e:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d270:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d273:	83 c0 01             	add    $0x1,%eax
    d276:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d27d:	8b 45 18             	mov    0x18(%ebp),%eax
    d280:	01 c2                	add    %eax,%edx
    d282:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d285:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d28c:	8b 45 18             	mov    0x18(%ebp),%eax
    d28f:	01 c8                	add    %ecx,%eax
    d291:	8b 00                	mov    (%eax),%eax
    d293:	89 c6                	mov    %eax,%esi
    d295:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d298:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d29f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2a2:	01 c8                	add    %ecx,%eax
    d2a4:	8b 08                	mov    (%eax),%ecx
    d2a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2a9:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d2b0:	8b 45 08             	mov    0x8(%ebp),%eax
    d2b3:	01 d8                	add    %ebx,%eax
    d2b5:	8b 00                	mov    (%eax),%eax
    d2b7:	0f af c1             	imul   %ecx,%eax
    d2ba:	0f af 45 24          	imul   0x24(%ebp),%eax
    d2be:	83 c0 07             	add    $0x7,%eax
    d2c1:	c1 e8 03             	shr    $0x3,%eax
    d2c4:	01 f0                	add    %esi,%eax
    d2c6:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d2c8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d2cc:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d2d0:	0f 85 b6 fe ff ff    	jne    d18c <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d2d6:	90                   	nop
    d2d7:	83 c4 10             	add    $0x10,%esp
    d2da:	5b                   	pop    %ebx
    d2db:	5e                   	pop    %esi
    d2dc:	5d                   	pop    %ebp
    d2dd:	c3                   	ret    

0000d2de <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d2de:	55                   	push   %ebp
    d2df:	89 e5                	mov    %esp,%ebp
    d2e1:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d2e4:	8b 45 10             	mov    0x10(%ebp),%eax
    d2e7:	05 98 00 00 00       	add    $0x98,%eax
    d2ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d2ef:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d2f3:	74 06                	je     d2fb <lodepng_inspect+0x1d>
    d2f5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d2f9:	75 17                	jne    d312 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d2fb:	8b 45 10             	mov    0x10(%ebp),%eax
    d2fe:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d305:	00 00 00 
    d308:	b8 30 00 00 00       	mov    $0x30,%eax
    d30d:	e9 ce 02 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d312:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d316:	7f 17                	jg     d32f <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d318:	8b 45 10             	mov    0x10(%ebp),%eax
    d31b:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d322:	00 00 00 
    d325:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d32a:	e9 b1 02 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d32f:	83 ec 0c             	sub    $0xc,%esp
    d332:	ff 75 f4             	pushl  -0xc(%ebp)
    d335:	e8 63 c7 ff ff       	call   9a9d <lodepng_info_cleanup>
    d33a:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d33d:	83 ec 0c             	sub    $0xc,%esp
    d340:	ff 75 f4             	pushl  -0xc(%ebp)
    d343:	e8 74 c6 ff ff       	call   99bc <lodepng_info_init>
    d348:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d34b:	8b 45 14             	mov    0x14(%ebp),%eax
    d34e:	0f b6 00             	movzbl (%eax),%eax
    d351:	3c 89                	cmp    $0x89,%al
    d353:	75 5b                	jne    d3b0 <lodepng_inspect+0xd2>
    d355:	8b 45 14             	mov    0x14(%ebp),%eax
    d358:	83 c0 01             	add    $0x1,%eax
    d35b:	0f b6 00             	movzbl (%eax),%eax
    d35e:	3c 50                	cmp    $0x50,%al
    d360:	75 4e                	jne    d3b0 <lodepng_inspect+0xd2>
    d362:	8b 45 14             	mov    0x14(%ebp),%eax
    d365:	83 c0 02             	add    $0x2,%eax
    d368:	0f b6 00             	movzbl (%eax),%eax
    d36b:	3c 4e                	cmp    $0x4e,%al
    d36d:	75 41                	jne    d3b0 <lodepng_inspect+0xd2>
    d36f:	8b 45 14             	mov    0x14(%ebp),%eax
    d372:	83 c0 03             	add    $0x3,%eax
    d375:	0f b6 00             	movzbl (%eax),%eax
    d378:	3c 47                	cmp    $0x47,%al
    d37a:	75 34                	jne    d3b0 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d37c:	8b 45 14             	mov    0x14(%ebp),%eax
    d37f:	83 c0 04             	add    $0x4,%eax
    d382:	0f b6 00             	movzbl (%eax),%eax
    d385:	3c 0d                	cmp    $0xd,%al
    d387:	75 27                	jne    d3b0 <lodepng_inspect+0xd2>
    d389:	8b 45 14             	mov    0x14(%ebp),%eax
    d38c:	83 c0 05             	add    $0x5,%eax
    d38f:	0f b6 00             	movzbl (%eax),%eax
    d392:	3c 0a                	cmp    $0xa,%al
    d394:	75 1a                	jne    d3b0 <lodepng_inspect+0xd2>
    d396:	8b 45 14             	mov    0x14(%ebp),%eax
    d399:	83 c0 06             	add    $0x6,%eax
    d39c:	0f b6 00             	movzbl (%eax),%eax
    d39f:	3c 1a                	cmp    $0x1a,%al
    d3a1:	75 0d                	jne    d3b0 <lodepng_inspect+0xd2>
    d3a3:	8b 45 14             	mov    0x14(%ebp),%eax
    d3a6:	83 c0 07             	add    $0x7,%eax
    d3a9:	0f b6 00             	movzbl (%eax),%eax
    d3ac:	3c 0a                	cmp    $0xa,%al
    d3ae:	74 17                	je     d3c7 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d3b0:	8b 45 10             	mov    0x10(%ebp),%eax
    d3b3:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d3ba:	00 00 00 
    d3bd:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d3c2:	e9 19 02 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d3c7:	8b 45 14             	mov    0x14(%ebp),%eax
    d3ca:	83 c0 08             	add    $0x8,%eax
    d3cd:	83 ec 0c             	sub    $0xc,%esp
    d3d0:	50                   	push   %eax
    d3d1:	e8 c2 ae ff ff       	call   8298 <lodepng_chunk_length>
    d3d6:	83 c4 10             	add    $0x10,%esp
    d3d9:	83 f8 0d             	cmp    $0xd,%eax
    d3dc:	74 17                	je     d3f5 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d3de:	8b 45 10             	mov    0x10(%ebp),%eax
    d3e1:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d3e8:	00 00 00 
    d3eb:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d3f0:	e9 eb 01 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d3f5:	8b 45 14             	mov    0x14(%ebp),%eax
    d3f8:	83 c0 08             	add    $0x8,%eax
    d3fb:	83 ec 08             	sub    $0x8,%esp
    d3fe:	68 2c a0 01 00       	push   $0x1a02c
    d403:	50                   	push   %eax
    d404:	e8 dc ae ff ff       	call   82e5 <lodepng_chunk_type_equals>
    d409:	83 c4 10             	add    $0x10,%esp
    d40c:	84 c0                	test   %al,%al
    d40e:	75 17                	jne    d427 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d410:	8b 45 10             	mov    0x10(%ebp),%eax
    d413:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d41a:	00 00 00 
    d41d:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d422:	e9 b9 01 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d427:	8b 45 14             	mov    0x14(%ebp),%eax
    d42a:	83 c0 10             	add    $0x10,%eax
    d42d:	83 ec 0c             	sub    $0xc,%esp
    d430:	50                   	push   %eax
    d431:	e8 5e 62 ff ff       	call   3694 <lodepng_read32bitInt>
    d436:	83 c4 10             	add    $0x10,%esp
    d439:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d43c:	8b 45 14             	mov    0x14(%ebp),%eax
    d43f:	83 c0 14             	add    $0x14,%eax
    d442:	83 ec 0c             	sub    $0xc,%esp
    d445:	50                   	push   %eax
    d446:	e8 49 62 ff ff       	call   3694 <lodepng_read32bitInt>
    d44b:	83 c4 10             	add    $0x10,%esp
    d44e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d451:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d455:	74 08                	je     d45f <lodepng_inspect+0x181>
    d457:	8b 45 08             	mov    0x8(%ebp),%eax
    d45a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d45d:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d45f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d463:	74 08                	je     d46d <lodepng_inspect+0x18f>
    d465:	8b 45 0c             	mov    0xc(%ebp),%eax
    d468:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d46b:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d46d:	8b 45 14             	mov    0x14(%ebp),%eax
    d470:	83 c0 18             	add    $0x18,%eax
    d473:	0f b6 00             	movzbl (%eax),%eax
    d476:	0f b6 d0             	movzbl %al,%edx
    d479:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d47c:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d47f:	8b 45 14             	mov    0x14(%ebp),%eax
    d482:	83 c0 19             	add    $0x19,%eax
    d485:	0f b6 00             	movzbl (%eax),%eax
    d488:	0f b6 d0             	movzbl %al,%edx
    d48b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d48e:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d491:	8b 45 14             	mov    0x14(%ebp),%eax
    d494:	83 c0 1a             	add    $0x1a,%eax
    d497:	0f b6 00             	movzbl (%eax),%eax
    d49a:	0f b6 d0             	movzbl %al,%edx
    d49d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4a0:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d4a2:	8b 45 14             	mov    0x14(%ebp),%eax
    d4a5:	83 c0 1b             	add    $0x1b,%eax
    d4a8:	0f b6 00             	movzbl (%eax),%eax
    d4ab:	0f b6 d0             	movzbl %al,%edx
    d4ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4b1:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d4b4:	8b 45 14             	mov    0x14(%ebp),%eax
    d4b7:	83 c0 1c             	add    $0x1c,%eax
    d4ba:	0f b6 00             	movzbl (%eax),%eax
    d4bd:	0f b6 d0             	movzbl %al,%edx
    d4c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4c3:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d4c6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d4ca:	74 06                	je     d4d2 <lodepng_inspect+0x1f4>
    d4cc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d4d0:	75 17                	jne    d4e9 <lodepng_inspect+0x20b>
    d4d2:	8b 45 10             	mov    0x10(%ebp),%eax
    d4d5:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d4dc:	00 00 00 
    d4df:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d4e4:	e9 f7 00 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d4e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4ec:	8b 50 10             	mov    0x10(%eax),%edx
    d4ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4f2:	8b 40 0c             	mov    0xc(%eax),%eax
    d4f5:	83 ec 08             	sub    $0x8,%esp
    d4f8:	52                   	push   %edx
    d4f9:	50                   	push   %eax
    d4fa:	e8 d4 b3 ff ff       	call   88d3 <checkColorValidity>
    d4ff:	83 c4 10             	add    $0x10,%esp
    d502:	89 c2                	mov    %eax,%edx
    d504:	8b 45 10             	mov    0x10(%ebp),%eax
    d507:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d50d:	8b 45 10             	mov    0x10(%ebp),%eax
    d510:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d516:	85 c0                	test   %eax,%eax
    d518:	74 0e                	je     d528 <lodepng_inspect+0x24a>
    d51a:	8b 45 10             	mov    0x10(%ebp),%eax
    d51d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d523:	e9 b8 00 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d528:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d52b:	8b 00                	mov    (%eax),%eax
    d52d:	85 c0                	test   %eax,%eax
    d52f:	74 17                	je     d548 <lodepng_inspect+0x26a>
    d531:	8b 45 10             	mov    0x10(%ebp),%eax
    d534:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d53b:	00 00 00 
    d53e:	b8 20 00 00 00       	mov    $0x20,%eax
    d543:	e9 98 00 00 00       	jmp    d5e0 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d548:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d54b:	8b 40 04             	mov    0x4(%eax),%eax
    d54e:	85 c0                	test   %eax,%eax
    d550:	74 14                	je     d566 <lodepng_inspect+0x288>
    d552:	8b 45 10             	mov    0x10(%ebp),%eax
    d555:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d55c:	00 00 00 
    d55f:	b8 21 00 00 00       	mov    $0x21,%eax
    d564:	eb 7a                	jmp    d5e0 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d566:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d569:	8b 40 08             	mov    0x8(%eax),%eax
    d56c:	83 f8 01             	cmp    $0x1,%eax
    d56f:	76 14                	jbe    d585 <lodepng_inspect+0x2a7>
    d571:	8b 45 10             	mov    0x10(%ebp),%eax
    d574:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d57b:	00 00 00 
    d57e:	b8 22 00 00 00       	mov    $0x22,%eax
    d583:	eb 5b                	jmp    d5e0 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d585:	8b 45 10             	mov    0x10(%ebp),%eax
    d588:	8b 40 18             	mov    0x18(%eax),%eax
    d58b:	85 c0                	test   %eax,%eax
    d58d:	75 48                	jne    d5d7 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d58f:	8b 45 14             	mov    0x14(%ebp),%eax
    d592:	83 c0 1d             	add    $0x1d,%eax
    d595:	83 ec 0c             	sub    $0xc,%esp
    d598:	50                   	push   %eax
    d599:	e8 f6 60 ff ff       	call   3694 <lodepng_read32bitInt>
    d59e:	83 c4 10             	add    $0x10,%esp
    d5a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d5a4:	8b 45 14             	mov    0x14(%ebp),%eax
    d5a7:	83 c0 0c             	add    $0xc,%eax
    d5aa:	83 ec 08             	sub    $0x8,%esp
    d5ad:	6a 11                	push   $0x11
    d5af:	50                   	push   %eax
    d5b0:	e8 71 ab ff ff       	call   8126 <lodepng_crc32>
    d5b5:	83 c4 10             	add    $0x10,%esp
    d5b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d5bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d5be:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d5c1:	74 14                	je     d5d7 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d5c3:	8b 45 10             	mov    0x10(%ebp),%eax
    d5c6:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d5cd:	00 00 00 
    d5d0:	b8 39 00 00 00       	mov    $0x39,%eax
    d5d5:	eb 09                	jmp    d5e0 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d5d7:	8b 45 10             	mov    0x10(%ebp),%eax
    d5da:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d5e0:	c9                   	leave  
    d5e1:	c3                   	ret    

0000d5e2 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d5e2:	55                   	push   %ebp
    d5e3:	89 e5                	mov    %esp,%ebp
    d5e5:	56                   	push   %esi
    d5e6:	53                   	push   %ebx
    d5e7:	83 ec 44             	sub    $0x44,%esp
    d5ea:	8b 45 18             	mov    0x18(%ebp),%eax
    d5ed:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d5f0:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d5f4:	83 f8 04             	cmp    $0x4,%eax
    d5f7:	0f 87 81 07 00 00    	ja     dd7e <unfilterScanline+0x79c>
    d5fd:	8b 04 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%eax
    d604:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d606:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d60d:	eb 19                	jmp    d628 <unfilterScanline+0x46>
    d60f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d612:	8b 45 08             	mov    0x8(%ebp),%eax
    d615:	01 c2                	add    %eax,%edx
    d617:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d61a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d61d:	01 c8                	add    %ecx,%eax
    d61f:	0f b6 00             	movzbl (%eax),%eax
    d622:	88 02                	mov    %al,(%edx)
    d624:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d628:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d62b:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d62e:	75 df                	jne    d60f <unfilterScanline+0x2d>
      break;
    d630:	e9 50 07 00 00       	jmp    dd85 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d635:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d63c:	eb 19                	jmp    d657 <unfilterScanline+0x75>
    d63e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d641:	8b 45 08             	mov    0x8(%ebp),%eax
    d644:	01 c2                	add    %eax,%edx
    d646:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d649:	8b 45 0c             	mov    0xc(%ebp),%eax
    d64c:	01 c8                	add    %ecx,%eax
    d64e:	0f b6 00             	movzbl (%eax),%eax
    d651:	88 02                	mov    %al,(%edx)
    d653:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d657:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d65a:	3b 45 14             	cmp    0x14(%ebp),%eax
    d65d:	75 df                	jne    d63e <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d65f:	8b 45 14             	mov    0x14(%ebp),%eax
    d662:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d665:	eb 2b                	jmp    d692 <unfilterScanline+0xb0>
    d667:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d66a:	8b 45 08             	mov    0x8(%ebp),%eax
    d66d:	01 c2                	add    %eax,%edx
    d66f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d672:	8b 45 0c             	mov    0xc(%ebp),%eax
    d675:	01 c8                	add    %ecx,%eax
    d677:	0f b6 08             	movzbl (%eax),%ecx
    d67a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d67d:	2b 45 14             	sub    0x14(%ebp),%eax
    d680:	89 c3                	mov    %eax,%ebx
    d682:	8b 45 08             	mov    0x8(%ebp),%eax
    d685:	01 d8                	add    %ebx,%eax
    d687:	0f b6 00             	movzbl (%eax),%eax
    d68a:	01 c8                	add    %ecx,%eax
    d68c:	88 02                	mov    %al,(%edx)
    d68e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d692:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d695:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d698:	7c cd                	jl     d667 <unfilterScanline+0x85>
      break;
    d69a:	e9 e6 06 00 00       	jmp    dd85 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d69f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d6a3:	74 3c                	je     d6e1 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d6a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6ac:	eb 26                	jmp    d6d4 <unfilterScanline+0xf2>
    d6ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6b1:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b4:	01 d0                	add    %edx,%eax
    d6b6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6b9:	8b 55 0c             	mov    0xc(%ebp),%edx
    d6bc:	01 ca                	add    %ecx,%edx
    d6be:	0f b6 0a             	movzbl (%edx),%ecx
    d6c1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d6c4:	8b 55 10             	mov    0x10(%ebp),%edx
    d6c7:	01 da                	add    %ebx,%edx
    d6c9:	0f b6 12             	movzbl (%edx),%edx
    d6cc:	01 ca                	add    %ecx,%edx
    d6ce:	88 10                	mov    %dl,(%eax)
    d6d0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6d7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6da:	75 d2                	jne    d6ae <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d6dc:	e9 a4 06 00 00       	jmp    dd85 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d6e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6e8:	eb 19                	jmp    d703 <unfilterScanline+0x121>
    d6ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6ed:	8b 45 08             	mov    0x8(%ebp),%eax
    d6f0:	01 c2                	add    %eax,%edx
    d6f2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6f8:	01 c8                	add    %ecx,%eax
    d6fa:	0f b6 00             	movzbl (%eax),%eax
    d6fd:	88 02                	mov    %al,(%edx)
    d6ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d703:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d706:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d709:	75 df                	jne    d6ea <unfilterScanline+0x108>
      }
      break;
    d70b:	e9 75 06 00 00       	jmp    dd85 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d710:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d714:	0f 84 8e 00 00 00    	je     d7a8 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d71a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d721:	eb 28                	jmp    d74b <unfilterScanline+0x169>
    d723:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d726:	8b 45 08             	mov    0x8(%ebp),%eax
    d729:	01 d0                	add    %edx,%eax
    d72b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d72e:	8b 55 0c             	mov    0xc(%ebp),%edx
    d731:	01 ca                	add    %ecx,%edx
    d733:	0f b6 12             	movzbl (%edx),%edx
    d736:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d739:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d73c:	01 d9                	add    %ebx,%ecx
    d73e:	0f b6 09             	movzbl (%ecx),%ecx
    d741:	d0 e9                	shr    %cl
    d743:	01 ca                	add    %ecx,%edx
    d745:	88 10                	mov    %dl,(%eax)
    d747:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d74b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d74e:	3b 45 14             	cmp    0x14(%ebp),%eax
    d751:	75 d0                	jne    d723 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d753:	8b 45 14             	mov    0x14(%ebp),%eax
    d756:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d759:	eb 40                	jmp    d79b <unfilterScanline+0x1b9>
    d75b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d75e:	8b 45 08             	mov    0x8(%ebp),%eax
    d761:	01 c2                	add    %eax,%edx
    d763:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d766:	8b 45 0c             	mov    0xc(%ebp),%eax
    d769:	01 c8                	add    %ecx,%eax
    d76b:	0f b6 08             	movzbl (%eax),%ecx
    d76e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d771:	2b 45 14             	sub    0x14(%ebp),%eax
    d774:	89 c3                	mov    %eax,%ebx
    d776:	8b 45 08             	mov    0x8(%ebp),%eax
    d779:	01 d8                	add    %ebx,%eax
    d77b:	0f b6 00             	movzbl (%eax),%eax
    d77e:	0f b6 d8             	movzbl %al,%ebx
    d781:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d784:	8b 45 10             	mov    0x10(%ebp),%eax
    d787:	01 f0                	add    %esi,%eax
    d789:	0f b6 00             	movzbl (%eax),%eax
    d78c:	0f b6 c0             	movzbl %al,%eax
    d78f:	01 d8                	add    %ebx,%eax
    d791:	d1 f8                	sar    %eax
    d793:	01 c8                	add    %ecx,%eax
    d795:	88 02                	mov    %al,(%edx)
    d797:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d79b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d79e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7a1:	7c b8                	jl     d75b <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d7a3:	e9 dd 05 00 00       	jmp    dd85 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d7a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7af:	eb 19                	jmp    d7ca <unfilterScanline+0x1e8>
    d7b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7b4:	8b 45 08             	mov    0x8(%ebp),%eax
    d7b7:	01 c2                	add    %eax,%edx
    d7b9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7bf:	01 c8                	add    %ecx,%eax
    d7c1:	0f b6 00             	movzbl (%eax),%eax
    d7c4:	88 02                	mov    %al,(%edx)
    d7c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7cd:	3b 45 14             	cmp    0x14(%ebp),%eax
    d7d0:	75 df                	jne    d7b1 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d7d2:	8b 45 14             	mov    0x14(%ebp),%eax
    d7d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d7d8:	eb 2d                	jmp    d807 <unfilterScanline+0x225>
    d7da:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7dd:	8b 45 08             	mov    0x8(%ebp),%eax
    d7e0:	01 c2                	add    %eax,%edx
    d7e2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7e8:	01 c8                	add    %ecx,%eax
    d7ea:	0f b6 08             	movzbl (%eax),%ecx
    d7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7f0:	2b 45 14             	sub    0x14(%ebp),%eax
    d7f3:	89 c3                	mov    %eax,%ebx
    d7f5:	8b 45 08             	mov    0x8(%ebp),%eax
    d7f8:	01 d8                	add    %ebx,%eax
    d7fa:	0f b6 00             	movzbl (%eax),%eax
    d7fd:	d0 e8                	shr    %al
    d7ff:	01 c8                	add    %ecx,%eax
    d801:	88 02                	mov    %al,(%edx)
    d803:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d807:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d80a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d80d:	7c cb                	jl     d7da <unfilterScanline+0x1f8>
      }
      break;
    d80f:	e9 71 05 00 00       	jmp    dd85 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d814:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d818:	0f 84 f9 04 00 00    	je     dd17 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d81e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d825:	eb 26                	jmp    d84d <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d827:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d82a:	8b 45 08             	mov    0x8(%ebp),%eax
    d82d:	01 d0                	add    %edx,%eax
    d82f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d832:	8b 55 0c             	mov    0xc(%ebp),%edx
    d835:	01 ca                	add    %ecx,%edx
    d837:	0f b6 0a             	movzbl (%edx),%ecx
    d83a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d83d:	8b 55 10             	mov    0x10(%ebp),%edx
    d840:	01 da                	add    %ebx,%edx
    d842:	0f b6 12             	movzbl (%edx),%edx
    d845:	01 ca                	add    %ecx,%edx
    d847:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d849:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d850:	3b 45 14             	cmp    0x14(%ebp),%eax
    d853:	75 d2                	jne    d827 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d855:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d859:	0f 8e db 01 00 00    	jle    da3a <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d85f:	e9 c2 01 00 00       	jmp    da26 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d864:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d867:	2b 45 14             	sub    0x14(%ebp),%eax
    d86a:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d86d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d870:	8b 45 0c             	mov    0xc(%ebp),%eax
    d873:	01 d0                	add    %edx,%eax
    d875:	0f b6 00             	movzbl (%eax),%eax
    d878:	88 45 ef             	mov    %al,-0x11(%ebp)
    d87b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d87e:	8d 50 01             	lea    0x1(%eax),%edx
    d881:	8b 45 0c             	mov    0xc(%ebp),%eax
    d884:	01 d0                	add    %edx,%eax
    d886:	0f b6 00             	movzbl (%eax),%eax
    d889:	88 45 ee             	mov    %al,-0x12(%ebp)
    d88c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d88f:	8d 50 02             	lea    0x2(%eax),%edx
    d892:	8b 45 0c             	mov    0xc(%ebp),%eax
    d895:	01 d0                	add    %edx,%eax
    d897:	0f b6 00             	movzbl (%eax),%eax
    d89a:	88 45 ed             	mov    %al,-0x13(%ebp)
    d89d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8a0:	8d 50 03             	lea    0x3(%eax),%edx
    d8a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8a6:	01 d0                	add    %edx,%eax
    d8a8:	0f b6 00             	movzbl (%eax),%eax
    d8ab:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d8ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d8b1:	8b 45 08             	mov    0x8(%ebp),%eax
    d8b4:	01 d0                	add    %edx,%eax
    d8b6:	0f b6 00             	movzbl (%eax),%eax
    d8b9:	88 45 eb             	mov    %al,-0x15(%ebp)
    d8bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8bf:	8d 50 01             	lea    0x1(%eax),%edx
    d8c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d8c5:	01 d0                	add    %edx,%eax
    d8c7:	0f b6 00             	movzbl (%eax),%eax
    d8ca:	88 45 ea             	mov    %al,-0x16(%ebp)
    d8cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8d0:	8d 50 02             	lea    0x2(%eax),%edx
    d8d3:	8b 45 08             	mov    0x8(%ebp),%eax
    d8d6:	01 d0                	add    %edx,%eax
    d8d8:	0f b6 00             	movzbl (%eax),%eax
    d8db:	88 45 e9             	mov    %al,-0x17(%ebp)
    d8de:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8e1:	8d 50 03             	lea    0x3(%eax),%edx
    d8e4:	8b 45 08             	mov    0x8(%ebp),%eax
    d8e7:	01 d0                	add    %edx,%eax
    d8e9:	0f b6 00             	movzbl (%eax),%eax
    d8ec:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d8ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8f2:	8b 45 10             	mov    0x10(%ebp),%eax
    d8f5:	01 d0                	add    %edx,%eax
    d8f7:	0f b6 00             	movzbl (%eax),%eax
    d8fa:	88 45 e7             	mov    %al,-0x19(%ebp)
    d8fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d900:	8d 50 01             	lea    0x1(%eax),%edx
    d903:	8b 45 10             	mov    0x10(%ebp),%eax
    d906:	01 d0                	add    %edx,%eax
    d908:	0f b6 00             	movzbl (%eax),%eax
    d90b:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d90e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d911:	8d 50 02             	lea    0x2(%eax),%edx
    d914:	8b 45 10             	mov    0x10(%ebp),%eax
    d917:	01 d0                	add    %edx,%eax
    d919:	0f b6 00             	movzbl (%eax),%eax
    d91c:	88 45 e5             	mov    %al,-0x1b(%ebp)
    d91f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d922:	8d 50 03             	lea    0x3(%eax),%edx
    d925:	8b 45 10             	mov    0x10(%ebp),%eax
    d928:	01 d0                	add    %edx,%eax
    d92a:	0f b6 00             	movzbl (%eax),%eax
    d92d:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    d930:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d933:	8b 45 10             	mov    0x10(%ebp),%eax
    d936:	01 d0                	add    %edx,%eax
    d938:	0f b6 00             	movzbl (%eax),%eax
    d93b:	88 45 e3             	mov    %al,-0x1d(%ebp)
    d93e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d941:	8d 50 01             	lea    0x1(%eax),%edx
    d944:	8b 45 10             	mov    0x10(%ebp),%eax
    d947:	01 d0                	add    %edx,%eax
    d949:	0f b6 00             	movzbl (%eax),%eax
    d94c:	88 45 e2             	mov    %al,-0x1e(%ebp)
    d94f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d952:	8d 50 02             	lea    0x2(%eax),%edx
    d955:	8b 45 10             	mov    0x10(%ebp),%eax
    d958:	01 d0                	add    %edx,%eax
    d95a:	0f b6 00             	movzbl (%eax),%eax
    d95d:	88 45 e1             	mov    %al,-0x1f(%ebp)
    d960:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d963:	8d 50 03             	lea    0x3(%eax),%edx
    d966:	8b 45 10             	mov    0x10(%ebp),%eax
    d969:	01 d0                	add    %edx,%eax
    d96b:	0f b6 00             	movzbl (%eax),%eax
    d96e:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    d971:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d974:	8b 45 08             	mov    0x8(%ebp),%eax
    d977:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d97a:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    d97e:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    d982:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    d986:	51                   	push   %ecx
    d987:	52                   	push   %edx
    d988:	50                   	push   %eax
    d989:	e8 3f f6 ff ff       	call   cfcd <paethPredictor>
    d98e:	83 c4 0c             	add    $0xc,%esp
    d991:	89 c2                	mov    %eax,%edx
    d993:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    d997:	01 d0                	add    %edx,%eax
    d999:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    d99b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d99e:	8d 50 01             	lea    0x1(%eax),%edx
    d9a1:	8b 45 08             	mov    0x8(%ebp),%eax
    d9a4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9a7:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    d9ab:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    d9af:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    d9b3:	51                   	push   %ecx
    d9b4:	52                   	push   %edx
    d9b5:	50                   	push   %eax
    d9b6:	e8 12 f6 ff ff       	call   cfcd <paethPredictor>
    d9bb:	83 c4 0c             	add    $0xc,%esp
    d9be:	89 c2                	mov    %eax,%edx
    d9c0:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    d9c4:	01 d0                	add    %edx,%eax
    d9c6:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    d9c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9cb:	8d 50 02             	lea    0x2(%eax),%edx
    d9ce:	8b 45 08             	mov    0x8(%ebp),%eax
    d9d1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9d4:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    d9d8:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    d9dc:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    d9e0:	51                   	push   %ecx
    d9e1:	52                   	push   %edx
    d9e2:	50                   	push   %eax
    d9e3:	e8 e5 f5 ff ff       	call   cfcd <paethPredictor>
    d9e8:	83 c4 0c             	add    $0xc,%esp
    d9eb:	89 c2                	mov    %eax,%edx
    d9ed:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    d9f1:	01 d0                	add    %edx,%eax
    d9f3:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    d9f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9f8:	8d 50 03             	lea    0x3(%eax),%edx
    d9fb:	8b 45 08             	mov    0x8(%ebp),%eax
    d9fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da01:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    da05:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    da09:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    da0d:	51                   	push   %ecx
    da0e:	52                   	push   %edx
    da0f:	50                   	push   %eax
    da10:	e8 b8 f5 ff ff       	call   cfcd <paethPredictor>
    da15:	83 c4 0c             	add    $0xc,%esp
    da18:	89 c2                	mov    %eax,%edx
    da1a:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    da1e:	01 d0                	add    %edx,%eax
    da20:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    da22:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    da26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da29:	83 c0 03             	add    $0x3,%eax
    da2c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da2f:	0f 8c 2f fe ff ff    	jl     d864 <unfilterScanline+0x282>
    da35:	e9 d3 02 00 00       	jmp    dd0d <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    da3a:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    da3e:	0f 8e 6a 01 00 00    	jle    dbae <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    da44:	e9 51 01 00 00       	jmp    db9a <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    da49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da4c:	2b 45 14             	sub    0x14(%ebp),%eax
    da4f:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    da52:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da55:	8b 45 0c             	mov    0xc(%ebp),%eax
    da58:	01 d0                	add    %edx,%eax
    da5a:	0f b6 00             	movzbl (%eax),%eax
    da5d:	88 45 db             	mov    %al,-0x25(%ebp)
    da60:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da63:	8d 50 01             	lea    0x1(%eax),%edx
    da66:	8b 45 0c             	mov    0xc(%ebp),%eax
    da69:	01 d0                	add    %edx,%eax
    da6b:	0f b6 00             	movzbl (%eax),%eax
    da6e:	88 45 da             	mov    %al,-0x26(%ebp)
    da71:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da74:	8d 50 02             	lea    0x2(%eax),%edx
    da77:	8b 45 0c             	mov    0xc(%ebp),%eax
    da7a:	01 d0                	add    %edx,%eax
    da7c:	0f b6 00             	movzbl (%eax),%eax
    da7f:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    da82:	8b 55 dc             	mov    -0x24(%ebp),%edx
    da85:	8b 45 08             	mov    0x8(%ebp),%eax
    da88:	01 d0                	add    %edx,%eax
    da8a:	0f b6 00             	movzbl (%eax),%eax
    da8d:	88 45 d8             	mov    %al,-0x28(%ebp)
    da90:	8b 45 dc             	mov    -0x24(%ebp),%eax
    da93:	8d 50 01             	lea    0x1(%eax),%edx
    da96:	8b 45 08             	mov    0x8(%ebp),%eax
    da99:	01 d0                	add    %edx,%eax
    da9b:	0f b6 00             	movzbl (%eax),%eax
    da9e:	88 45 d7             	mov    %al,-0x29(%ebp)
    daa1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    daa4:	8d 50 02             	lea    0x2(%eax),%edx
    daa7:	8b 45 08             	mov    0x8(%ebp),%eax
    daaa:	01 d0                	add    %edx,%eax
    daac:	0f b6 00             	movzbl (%eax),%eax
    daaf:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    dab2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dab5:	8b 45 10             	mov    0x10(%ebp),%eax
    dab8:	01 d0                	add    %edx,%eax
    daba:	0f b6 00             	movzbl (%eax),%eax
    dabd:	88 45 d5             	mov    %al,-0x2b(%ebp)
    dac0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dac3:	8d 50 01             	lea    0x1(%eax),%edx
    dac6:	8b 45 10             	mov    0x10(%ebp),%eax
    dac9:	01 d0                	add    %edx,%eax
    dacb:	0f b6 00             	movzbl (%eax),%eax
    dace:	88 45 d4             	mov    %al,-0x2c(%ebp)
    dad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dad4:	8d 50 02             	lea    0x2(%eax),%edx
    dad7:	8b 45 10             	mov    0x10(%ebp),%eax
    dada:	01 d0                	add    %edx,%eax
    dadc:	0f b6 00             	movzbl (%eax),%eax
    dadf:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    dae2:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dae5:	8b 45 10             	mov    0x10(%ebp),%eax
    dae8:	01 d0                	add    %edx,%eax
    daea:	0f b6 00             	movzbl (%eax),%eax
    daed:	88 45 d2             	mov    %al,-0x2e(%ebp)
    daf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    daf3:	8d 50 01             	lea    0x1(%eax),%edx
    daf6:	8b 45 10             	mov    0x10(%ebp),%eax
    daf9:	01 d0                	add    %edx,%eax
    dafb:	0f b6 00             	movzbl (%eax),%eax
    dafe:	88 45 d1             	mov    %al,-0x2f(%ebp)
    db01:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db04:	8d 50 02             	lea    0x2(%eax),%edx
    db07:	8b 45 10             	mov    0x10(%ebp),%eax
    db0a:	01 d0                	add    %edx,%eax
    db0c:	0f b6 00             	movzbl (%eax),%eax
    db0f:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    db12:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db15:	8b 45 08             	mov    0x8(%ebp),%eax
    db18:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db1b:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    db1f:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    db23:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    db27:	51                   	push   %ecx
    db28:	52                   	push   %edx
    db29:	50                   	push   %eax
    db2a:	e8 9e f4 ff ff       	call   cfcd <paethPredictor>
    db2f:	83 c4 0c             	add    $0xc,%esp
    db32:	89 c2                	mov    %eax,%edx
    db34:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    db38:	01 d0                	add    %edx,%eax
    db3a:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    db3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db3f:	8d 50 01             	lea    0x1(%eax),%edx
    db42:	8b 45 08             	mov    0x8(%ebp),%eax
    db45:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db48:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    db4c:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    db50:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    db54:	51                   	push   %ecx
    db55:	52                   	push   %edx
    db56:	50                   	push   %eax
    db57:	e8 71 f4 ff ff       	call   cfcd <paethPredictor>
    db5c:	83 c4 0c             	add    $0xc,%esp
    db5f:	89 c2                	mov    %eax,%edx
    db61:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    db65:	01 d0                	add    %edx,%eax
    db67:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    db69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db6c:	8d 50 02             	lea    0x2(%eax),%edx
    db6f:	8b 45 08             	mov    0x8(%ebp),%eax
    db72:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db75:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    db79:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    db7d:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    db81:	51                   	push   %ecx
    db82:	52                   	push   %edx
    db83:	50                   	push   %eax
    db84:	e8 44 f4 ff ff       	call   cfcd <paethPredictor>
    db89:	83 c4 0c             	add    $0xc,%esp
    db8c:	89 c2                	mov    %eax,%edx
    db8e:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    db92:	01 d0                	add    %edx,%eax
    db94:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    db96:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    db9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db9d:	83 c0 02             	add    $0x2,%eax
    dba0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dba3:	0f 8c a0 fe ff ff    	jl     da49 <unfilterScanline+0x467>
    dba9:	e9 5f 01 00 00       	jmp    dd0d <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dbae:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dbb2:	0f 8e 55 01 00 00    	jle    dd0d <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dbb8:	e9 e0 00 00 00       	jmp    dc9d <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dbbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbc0:	2b 45 14             	sub    0x14(%ebp),%eax
    dbc3:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dbc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbc9:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbcc:	01 d0                	add    %edx,%eax
    dbce:	0f b6 00             	movzbl (%eax),%eax
    dbd1:	88 45 cb             	mov    %al,-0x35(%ebp)
    dbd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbd7:	8d 50 01             	lea    0x1(%eax),%edx
    dbda:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbdd:	01 d0                	add    %edx,%eax
    dbdf:	0f b6 00             	movzbl (%eax),%eax
    dbe2:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dbe5:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dbe8:	8b 45 08             	mov    0x8(%ebp),%eax
    dbeb:	01 d0                	add    %edx,%eax
    dbed:	0f b6 00             	movzbl (%eax),%eax
    dbf0:	88 45 c9             	mov    %al,-0x37(%ebp)
    dbf3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dbf6:	8d 50 01             	lea    0x1(%eax),%edx
    dbf9:	8b 45 08             	mov    0x8(%ebp),%eax
    dbfc:	01 d0                	add    %edx,%eax
    dbfe:	0f b6 00             	movzbl (%eax),%eax
    dc01:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dc04:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc07:	8b 45 10             	mov    0x10(%ebp),%eax
    dc0a:	01 d0                	add    %edx,%eax
    dc0c:	0f b6 00             	movzbl (%eax),%eax
    dc0f:	88 45 c7             	mov    %al,-0x39(%ebp)
    dc12:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc15:	8d 50 01             	lea    0x1(%eax),%edx
    dc18:	8b 45 10             	mov    0x10(%ebp),%eax
    dc1b:	01 d0                	add    %edx,%eax
    dc1d:	0f b6 00             	movzbl (%eax),%eax
    dc20:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dc23:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dc26:	8b 45 10             	mov    0x10(%ebp),%eax
    dc29:	01 d0                	add    %edx,%eax
    dc2b:	0f b6 00             	movzbl (%eax),%eax
    dc2e:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dc31:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc34:	8d 50 01             	lea    0x1(%eax),%edx
    dc37:	8b 45 10             	mov    0x10(%ebp),%eax
    dc3a:	01 d0                	add    %edx,%eax
    dc3c:	0f b6 00             	movzbl (%eax),%eax
    dc3f:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc42:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc45:	8b 45 08             	mov    0x8(%ebp),%eax
    dc48:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc4b:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dc4f:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dc53:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dc57:	51                   	push   %ecx
    dc58:	52                   	push   %edx
    dc59:	50                   	push   %eax
    dc5a:	e8 6e f3 ff ff       	call   cfcd <paethPredictor>
    dc5f:	83 c4 0c             	add    $0xc,%esp
    dc62:	89 c2                	mov    %eax,%edx
    dc64:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dc68:	01 d0                	add    %edx,%eax
    dc6a:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc6f:	8d 50 01             	lea    0x1(%eax),%edx
    dc72:	8b 45 08             	mov    0x8(%ebp),%eax
    dc75:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc78:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dc7c:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dc80:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dc84:	51                   	push   %ecx
    dc85:	52                   	push   %edx
    dc86:	50                   	push   %eax
    dc87:	e8 41 f3 ff ff       	call   cfcd <paethPredictor>
    dc8c:	83 c4 0c             	add    $0xc,%esp
    dc8f:	89 c2                	mov    %eax,%edx
    dc91:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dc95:	01 d0                	add    %edx,%eax
    dc97:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dc99:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dc9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dca0:	83 c0 01             	add    $0x1,%eax
    dca3:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dca6:	0f 8c 11 ff ff ff    	jl     dbbd <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dcac:	eb 5f                	jmp    dd0d <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dcae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcb1:	8b 45 08             	mov    0x8(%ebp),%eax
    dcb4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dcb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcba:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcbd:	01 d0                	add    %edx,%eax
    dcbf:	0f b6 00             	movzbl (%eax),%eax
    dcc2:	88 45 b7             	mov    %al,-0x49(%ebp)
    dcc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcc8:	2b 45 14             	sub    0x14(%ebp),%eax
    dccb:	89 c2                	mov    %eax,%edx
    dccd:	8b 45 10             	mov    0x10(%ebp),%eax
    dcd0:	01 d0                	add    %edx,%eax
    dcd2:	0f b6 00             	movzbl (%eax),%eax
    dcd5:	0f b6 c8             	movzbl %al,%ecx
    dcd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcdb:	8b 45 10             	mov    0x10(%ebp),%eax
    dcde:	01 d0                	add    %edx,%eax
    dce0:	0f b6 00             	movzbl (%eax),%eax
    dce3:	0f b6 d0             	movzbl %al,%edx
    dce6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dce9:	2b 45 14             	sub    0x14(%ebp),%eax
    dcec:	89 c6                	mov    %eax,%esi
    dcee:	8b 45 08             	mov    0x8(%ebp),%eax
    dcf1:	01 f0                	add    %esi,%eax
    dcf3:	0f b6 00             	movzbl (%eax),%eax
    dcf6:	0f b6 c0             	movzbl %al,%eax
    dcf9:	51                   	push   %ecx
    dcfa:	52                   	push   %edx
    dcfb:	50                   	push   %eax
    dcfc:	e8 cc f2 ff ff       	call   cfcd <paethPredictor>
    dd01:	83 c4 0c             	add    $0xc,%esp
    dd04:	02 45 b7             	add    -0x49(%ebp),%al
    dd07:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dd09:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd10:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd13:	75 99                	jne    dcae <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd15:	eb 6e                	jmp    dd85 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd1e:	eb 19                	jmp    dd39 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    dd20:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd23:	8b 45 08             	mov    0x8(%ebp),%eax
    dd26:	01 c2                	add    %eax,%edx
    dd28:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd2e:	01 c8                	add    %ecx,%eax
    dd30:	0f b6 00             	movzbl (%eax),%eax
    dd33:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd35:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd39:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd3c:	3b 45 14             	cmp    0x14(%ebp),%eax
    dd3f:	75 df                	jne    dd20 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd41:	8b 45 14             	mov    0x14(%ebp),%eax
    dd44:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dd47:	eb 2b                	jmp    dd74 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    dd49:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd4c:	8b 45 08             	mov    0x8(%ebp),%eax
    dd4f:	01 c2                	add    %eax,%edx
    dd51:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd54:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd57:	01 c8                	add    %ecx,%eax
    dd59:	0f b6 08             	movzbl (%eax),%ecx
    dd5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd5f:	2b 45 14             	sub    0x14(%ebp),%eax
    dd62:	89 c3                	mov    %eax,%ebx
    dd64:	8b 45 08             	mov    0x8(%ebp),%eax
    dd67:	01 d8                	add    %ebx,%eax
    dd69:	0f b6 00             	movzbl (%eax),%eax
    dd6c:	01 c8                	add    %ecx,%eax
    dd6e:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd70:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd77:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd7a:	7c cd                	jl     dd49 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd7c:	eb 07                	jmp    dd85 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    dd7e:	b8 24 00 00 00       	mov    $0x24,%eax
    dd83:	eb 05                	jmp    dd8a <unfilterScanline+0x7a8>
  }
  return 0;
    dd85:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dd8a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    dd8d:	5b                   	pop    %ebx
    dd8e:	5e                   	pop    %esi
    dd8f:	5d                   	pop    %ebp
    dd90:	c3                   	ret    

0000dd91 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    dd91:	55                   	push   %ebp
    dd92:	89 e5                	mov    %esp,%ebp
    dd94:	53                   	push   %ebx
    dd95:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    dd98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    dd9f:	8b 45 18             	mov    0x18(%ebp),%eax
    dda2:	83 c0 07             	add    $0x7,%eax
    dda5:	c1 e8 03             	shr    $0x3,%eax
    dda8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    ddab:	ff 75 18             	pushl  0x18(%ebp)
    ddae:	6a 01                	push   $0x1
    ddb0:	ff 75 10             	pushl  0x10(%ebp)
    ddb3:	e8 d9 b1 ff ff       	call   8f91 <lodepng_get_raw_size_idat>
    ddb8:	83 c4 0c             	add    $0xc,%esp
    ddbb:	83 e8 01             	sub    $0x1,%eax
    ddbe:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    ddc1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ddc8:	eb 6d                	jmp    de37 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    ddca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ddcd:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    ddd1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    ddd4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ddd7:	83 c0 01             	add    $0x1,%eax
    ddda:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    ddde:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    dde1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    dde4:	8b 45 0c             	mov    0xc(%ebp),%eax
    dde7:	01 d0                	add    %edx,%eax
    dde9:	0f b6 00             	movzbl (%eax),%eax
    ddec:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    ddef:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    ddf3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ddf6:	8d 4a 01             	lea    0x1(%edx),%ecx
    ddf9:	8b 55 0c             	mov    0xc(%ebp),%edx
    ddfc:	01 d1                	add    %edx,%ecx
    ddfe:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    de01:	8b 55 08             	mov    0x8(%ebp),%edx
    de04:	01 da                	add    %ebx,%edx
    de06:	ff 75 ec             	pushl  -0x14(%ebp)
    de09:	50                   	push   %eax
    de0a:	ff 75 f0             	pushl  -0x10(%ebp)
    de0d:	ff 75 f4             	pushl  -0xc(%ebp)
    de10:	51                   	push   %ecx
    de11:	52                   	push   %edx
    de12:	e8 cb f7 ff ff       	call   d5e2 <unfilterScanline>
    de17:	83 c4 18             	add    $0x18,%esp
    de1a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    de1d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    de21:	74 05                	je     de28 <unfilter+0x97>
    de23:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de26:	eb 1c                	jmp    de44 <unfilter+0xb3>

    prevline = &out[outindex];
    de28:	8b 55 e8             	mov    -0x18(%ebp),%edx
    de2b:	8b 45 08             	mov    0x8(%ebp),%eax
    de2e:	01 d0                	add    %edx,%eax
    de30:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    de33:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    de37:	8b 45 f8             	mov    -0x8(%ebp),%eax
    de3a:	3b 45 14             	cmp    0x14(%ebp),%eax
    de3d:	72 8b                	jb     ddca <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    de3f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    de47:	c9                   	leave  
    de48:	c3                   	ret    

0000de49 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de49:	55                   	push   %ebp
    de4a:	89 e5                	mov    %esp,%ebp
    de4c:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    de52:	ff 75 18             	pushl  0x18(%ebp)
    de55:	ff 75 14             	pushl  0x14(%ebp)
    de58:	ff 75 10             	pushl  0x10(%ebp)
    de5b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    de61:	50                   	push   %eax
    de62:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    de68:	50                   	push   %eax
    de69:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    de6f:	50                   	push   %eax
    de70:	8d 45 94             	lea    -0x6c(%ebp),%eax
    de73:	50                   	push   %eax
    de74:	8d 45 b0             	lea    -0x50(%ebp),%eax
    de77:	50                   	push   %eax
    de78:	e8 e6 f1 ff ff       	call   d063 <Adam7_getpassvalues>
    de7d:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    de80:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    de84:	0f 86 0a 01 00 00    	jbe    df94 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    de8a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    de91:	e9 ef 00 00 00       	jmp    df85 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    de96:	8b 45 18             	mov    0x18(%ebp),%eax
    de99:	c1 e8 03             	shr    $0x3,%eax
    de9c:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    de9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dea6:	e9 c6 00 00 00       	jmp    df71 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    deab:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    deb2:	e9 a6 00 00 00       	jmp    df5d <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    deb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    deba:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    dec1:	89 c1                	mov    %eax,%ecx
    dec3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dec6:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    deca:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    dece:	89 c2                	mov    %eax,%edx
    ded0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ded3:	01 c2                	add    %eax,%edx
    ded5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ded8:	0f af c2             	imul   %edx,%eax
    dedb:	01 c8                	add    %ecx,%eax
    dedd:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    dee0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dee3:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
    deea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    deed:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
    def4:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    def8:	01 d0                	add    %edx,%eax
    defa:	0f af 45 10          	imul   0x10(%ebp),%eax
    defe:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    df00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df03:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
    df0a:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    df0e:	01 c2                	add    %eax,%edx
    df10:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df13:	8b 04 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%eax
    df1a:	01 c2                	add    %eax,%edx
    df1c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df1f:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    df22:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    df2c:	eb 23                	jmp    df51 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    df2e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    df31:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df34:	01 c2                	add    %eax,%edx
    df36:	8b 45 08             	mov    0x8(%ebp),%eax
    df39:	01 c2                	add    %eax,%edx
    df3b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    df3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df41:	01 c1                	add    %eax,%ecx
    df43:	8b 45 0c             	mov    0xc(%ebp),%eax
    df46:	01 c8                	add    %ecx,%eax
    df48:	0f b6 00             	movzbl (%eax),%eax
    df4b:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df4d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    df51:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df54:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    df57:	72 d5                	jb     df2e <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    df59:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    df5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df60:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df64:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    df67:	0f 87 4a ff ff ff    	ja     deb7 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    df6d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    df71:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df74:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    df78:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    df7b:	0f 87 2a ff ff ff    	ja     deab <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    df81:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    df85:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    df89:	0f 85 07 ff ff ff    	jne    de96 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    df8f:	e9 22 01 00 00       	jmp    e0b6 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    df94:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    df9b:	e9 0c 01 00 00       	jmp    e0ac <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    dfa0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfa3:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    dfa7:	0f af 45 18          	imul   0x18(%ebp),%eax
    dfab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    dfae:	8b 45 18             	mov    0x18(%ebp),%eax
    dfb1:	0f af 45 10          	imul   0x10(%ebp),%eax
    dfb5:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    dfb8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dfbf:	e9 d4 00 00 00       	jmp    e098 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    dfc4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    dfcb:	e9 b4 00 00 00       	jmp    e084 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    dfd0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfd3:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    dfda:	c1 e0 03             	shl    $0x3,%eax
    dfdd:	89 c1                	mov    %eax,%ecx
    dfdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dfe2:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    dfe6:	89 c2                	mov    %eax,%edx
    dfe8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dfeb:	0f af 45 18          	imul   0x18(%ebp),%eax
    dfef:	01 d0                	add    %edx,%eax
    dff1:	01 c8                	add    %ecx,%eax
    dff3:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    dff9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dffc:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
    e003:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e006:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
    e00d:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e011:	01 d0                	add    %edx,%eax
    e013:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e017:	89 c2                	mov    %eax,%edx
    e019:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e01c:	8b 0c 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%ecx
    e023:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e026:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
    e02d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e031:	01 c8                	add    %ecx,%eax
    e033:	0f af 45 18          	imul   0x18(%ebp),%eax
    e037:	01 d0                	add    %edx,%eax
    e039:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e03f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e046:	eb 30                	jmp    e078 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e048:	ff 75 0c             	pushl  0xc(%ebp)
    e04b:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e051:	50                   	push   %eax
    e052:	e8 1e a1 ff ff       	call   8175 <readBitFromReversedStream>
    e057:	83 c4 08             	add    $0x8,%esp
    e05a:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e05d:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e061:	50                   	push   %eax
    e062:	ff 75 08             	pushl  0x8(%ebp)
    e065:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e06b:	50                   	push   %eax
    e06c:	e8 86 a1 ff ff       	call   81f7 <setBitOfReversedStream>
    e071:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e074:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e078:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e07b:	3b 45 18             	cmp    0x18(%ebp),%eax
    e07e:	72 c8                	jb     e048 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e080:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e084:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e087:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e08b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e08e:	0f 87 3c ff ff ff    	ja     dfd0 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e094:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e098:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e09b:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e09f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e0a2:	0f 87 1c ff ff ff    	ja     dfc4 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e0a8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e0ac:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e0b0:	0f 85 ea fe ff ff    	jne    dfa0 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e0b6:	90                   	nop
    e0b7:	c9                   	leave  
    e0b8:	c3                   	ret    

0000e0b9 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e0b9:	55                   	push   %ebp
    e0ba:	89 e5                	mov    %esp,%ebp
    e0bc:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e0bf:	8b 45 14             	mov    0x14(%ebp),%eax
    e0c2:	2b 45 10             	sub    0x10(%ebp),%eax
    e0c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e0c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e0cf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e0d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e0dd:	eb 4a                	jmp    e129 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e0df:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e0e6:	eb 2a                	jmp    e112 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e0e8:	ff 75 0c             	pushl  0xc(%ebp)
    e0eb:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e0ee:	50                   	push   %eax
    e0ef:	e8 81 a0 ff ff       	call   8175 <readBitFromReversedStream>
    e0f4:	83 c4 08             	add    $0x8,%esp
    e0f7:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e0fa:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e0fe:	50                   	push   %eax
    e0ff:	ff 75 08             	pushl  0x8(%ebp)
    e102:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e105:	50                   	push   %eax
    e106:	e8 ec a0 ff ff       	call   81f7 <setBitOfReversedStream>
    e10b:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e10e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e112:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e115:	3b 45 10             	cmp    0x10(%ebp),%eax
    e118:	7c ce                	jl     e0e8 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e11a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e11d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e120:	01 d0                	add    %edx,%eax
    e122:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e125:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e129:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e12c:	3b 45 18             	cmp    0x18(%ebp),%eax
    e12f:	72 ae                	jb     e0df <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e131:	90                   	nop
    e132:	c9                   	leave  
    e133:	c3                   	ret    

0000e134 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e134:	55                   	push   %ebp
    e135:	89 e5                	mov    %esp,%ebp
    e137:	57                   	push   %edi
    e138:	56                   	push   %esi
    e139:	53                   	push   %ebx
    e13a:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e140:	8b 45 18             	mov    0x18(%ebp),%eax
    e143:	83 c0 0c             	add    $0xc,%eax
    e146:	50                   	push   %eax
    e147:	e8 e6 ac ff ff       	call   8e32 <lodepng_get_bpp>
    e14c:	83 c4 04             	add    $0x4,%esp
    e14f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e152:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e156:	75 0a                	jne    e162 <postProcessScanlines+0x2e>
    e158:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e15d:	e9 c3 01 00 00       	jmp    e325 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e162:	8b 45 18             	mov    0x18(%ebp),%eax
    e165:	8b 40 08             	mov    0x8(%eax),%eax
    e168:	85 c0                	test   %eax,%eax
    e16a:	0f 85 a8 00 00 00    	jne    e218 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e170:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e174:	77 76                	ja     e1ec <postProcessScanlines+0xb8>
    e176:	8b 45 10             	mov    0x10(%ebp),%eax
    e179:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e17d:	89 c2                	mov    %eax,%edx
    e17f:	8b 45 10             	mov    0x10(%ebp),%eax
    e182:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e186:	83 c0 07             	add    $0x7,%eax
    e189:	c1 e8 03             	shr    $0x3,%eax
    e18c:	c1 e0 03             	shl    $0x3,%eax
    e18f:	39 c2                	cmp    %eax,%edx
    e191:	74 59                	je     e1ec <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e193:	ff 75 ec             	pushl  -0x14(%ebp)
    e196:	ff 75 14             	pushl  0x14(%ebp)
    e199:	ff 75 10             	pushl  0x10(%ebp)
    e19c:	ff 75 0c             	pushl  0xc(%ebp)
    e19f:	ff 75 0c             	pushl  0xc(%ebp)
    e1a2:	e8 ea fb ff ff       	call   dd91 <unfilter>
    e1a7:	83 c4 14             	add    $0x14,%esp
    e1aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e1ad:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e1b1:	74 08                	je     e1bb <postProcessScanlines+0x87>
    e1b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e1b6:	e9 6a 01 00 00       	jmp    e325 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e1bb:	8b 45 10             	mov    0x10(%ebp),%eax
    e1be:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1c2:	83 c0 07             	add    $0x7,%eax
    e1c5:	c1 e8 03             	shr    $0x3,%eax
    e1c8:	c1 e0 03             	shl    $0x3,%eax
    e1cb:	89 c2                	mov    %eax,%edx
    e1cd:	8b 45 10             	mov    0x10(%ebp),%eax
    e1d0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1d4:	ff 75 14             	pushl  0x14(%ebp)
    e1d7:	52                   	push   %edx
    e1d8:	50                   	push   %eax
    e1d9:	ff 75 0c             	pushl  0xc(%ebp)
    e1dc:	ff 75 08             	pushl  0x8(%ebp)
    e1df:	e8 d5 fe ff ff       	call   e0b9 <removePaddingBits>
    e1e4:	83 c4 14             	add    $0x14,%esp
    e1e7:	e9 34 01 00 00       	jmp    e320 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e1ec:	ff 75 ec             	pushl  -0x14(%ebp)
    e1ef:	ff 75 14             	pushl  0x14(%ebp)
    e1f2:	ff 75 10             	pushl  0x10(%ebp)
    e1f5:	ff 75 0c             	pushl  0xc(%ebp)
    e1f8:	ff 75 08             	pushl  0x8(%ebp)
    e1fb:	e8 91 fb ff ff       	call   dd91 <unfilter>
    e200:	83 c4 14             	add    $0x14,%esp
    e203:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e206:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e20a:	0f 84 10 01 00 00    	je     e320 <postProcessScanlines+0x1ec>
    e210:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e213:	e9 0d 01 00 00       	jmp    e325 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e218:	ff 75 ec             	pushl  -0x14(%ebp)
    e21b:	ff 75 14             	pushl  0x14(%ebp)
    e21e:	ff 75 10             	pushl  0x10(%ebp)
    e221:	8d 45 88             	lea    -0x78(%ebp),%eax
    e224:	50                   	push   %eax
    e225:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e22b:	50                   	push   %eax
    e22c:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e232:	50                   	push   %eax
    e233:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e236:	50                   	push   %eax
    e237:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e23a:	50                   	push   %eax
    e23b:	e8 23 ee ff ff       	call   d063 <Adam7_getpassvalues>
    e240:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e243:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e24a:	e9 b0 00 00 00       	jmp    e2ff <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e24f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e252:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e256:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e259:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e25d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e260:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e267:	89 cb                	mov    %ecx,%ebx
    e269:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e26c:	01 cb                	add    %ecx,%ebx
    e26e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e271:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e278:	89 ce                	mov    %ecx,%esi
    e27a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e27d:	01 f1                	add    %esi,%ecx
    e27f:	ff 75 ec             	pushl  -0x14(%ebp)
    e282:	52                   	push   %edx
    e283:	50                   	push   %eax
    e284:	53                   	push   %ebx
    e285:	51                   	push   %ecx
    e286:	e8 06 fb ff ff       	call   dd91 <unfilter>
    e28b:	83 c4 14             	add    $0x14,%esp
    e28e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e291:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e295:	74 08                	je     e29f <postProcessScanlines+0x16b>
    e297:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e29a:	e9 86 00 00 00       	jmp    e325 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e29f:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e2a3:	77 56                	ja     e2fb <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2a8:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e2ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2af:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2b3:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2b7:	83 c2 07             	add    $0x7,%edx
    e2ba:	c1 ea 03             	shr    $0x3,%edx
    e2bd:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2c0:	89 d6                	mov    %edx,%esi
    e2c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2c5:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2c9:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2cd:	89 d3                	mov    %edx,%ebx
    e2cf:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2d2:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e2d9:	89 d1                	mov    %edx,%ecx
    e2db:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2de:	01 d1                	add    %edx,%ecx
    e2e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2e3:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e2e7:	89 d7                	mov    %edx,%edi
    e2e9:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2ec:	01 fa                	add    %edi,%edx
    e2ee:	50                   	push   %eax
    e2ef:	56                   	push   %esi
    e2f0:	53                   	push   %ebx
    e2f1:	51                   	push   %ecx
    e2f2:	52                   	push   %edx
    e2f3:	e8 c1 fd ff ff       	call   e0b9 <removePaddingBits>
    e2f8:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e2fb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e2ff:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e303:	0f 85 46 ff ff ff    	jne    e24f <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e309:	ff 75 ec             	pushl  -0x14(%ebp)
    e30c:	ff 75 14             	pushl  0x14(%ebp)
    e30f:	ff 75 10             	pushl  0x10(%ebp)
    e312:	ff 75 0c             	pushl  0xc(%ebp)
    e315:	ff 75 08             	pushl  0x8(%ebp)
    e318:	e8 2c fb ff ff       	call   de49 <Adam7_deinterlace>
    e31d:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e320:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e325:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e328:	5b                   	pop    %ebx
    e329:	5e                   	pop    %esi
    e32a:	5f                   	pop    %edi
    e32b:	5d                   	pop    %ebp
    e32c:	c3                   	ret    

0000e32d <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e32d:	55                   	push   %ebp
    e32e:	89 e5                	mov    %esp,%ebp
    e330:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e333:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e33a:	8b 45 10             	mov    0x10(%ebp),%eax
    e33d:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e342:	f7 e2                	mul    %edx
    e344:	89 d0                	mov    %edx,%eax
    e346:	d1 e8                	shr    %eax
    e348:	89 c2                	mov    %eax,%edx
    e34a:	8b 45 08             	mov    0x8(%ebp),%eax
    e34d:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e350:	8b 45 08             	mov    0x8(%ebp),%eax
    e353:	8b 40 0c             	mov    0xc(%eax),%eax
    e356:	85 c0                	test   %eax,%eax
    e358:	74 0d                	je     e367 <readChunk_PLTE+0x3a>
    e35a:	8b 45 08             	mov    0x8(%ebp),%eax
    e35d:	8b 40 0c             	mov    0xc(%eax),%eax
    e360:	3d 00 01 00 00       	cmp    $0x100,%eax
    e365:	7e 0a                	jle    e371 <readChunk_PLTE+0x44>
    e367:	b8 26 00 00 00       	mov    $0x26,%eax
    e36c:	e9 da 00 00 00       	jmp    e44b <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e371:	83 ec 0c             	sub    $0xc,%esp
    e374:	ff 75 08             	pushl  0x8(%ebp)
    e377:	e8 02 a7 ff ff       	call   8a7e <lodepng_color_mode_alloc_palette>
    e37c:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e37f:	8b 45 08             	mov    0x8(%ebp),%eax
    e382:	8b 40 08             	mov    0x8(%eax),%eax
    e385:	85 c0                	test   %eax,%eax
    e387:	75 1e                	jne    e3a7 <readChunk_PLTE+0x7a>
    e389:	8b 45 08             	mov    0x8(%ebp),%eax
    e38c:	8b 40 0c             	mov    0xc(%eax),%eax
    e38f:	85 c0                	test   %eax,%eax
    e391:	74 14                	je     e3a7 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e393:	8b 45 08             	mov    0x8(%ebp),%eax
    e396:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e39d:	b8 53 00 00 00       	mov    $0x53,%eax
    e3a2:	e9 a4 00 00 00       	jmp    e44b <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e3a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e3ae:	e9 84 00 00 00       	jmp    e437 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e3b3:	8b 45 08             	mov    0x8(%ebp),%eax
    e3b6:	8b 40 08             	mov    0x8(%eax),%eax
    e3b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3bc:	c1 e2 02             	shl    $0x2,%edx
    e3bf:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3c5:	8d 50 01             	lea    0x1(%eax),%edx
    e3c8:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3cb:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3ce:	01 d0                	add    %edx,%eax
    e3d0:	0f b6 00             	movzbl (%eax),%eax
    e3d3:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e3d5:	8b 45 08             	mov    0x8(%ebp),%eax
    e3d8:	8b 40 08             	mov    0x8(%eax),%eax
    e3db:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3de:	c1 e2 02             	shl    $0x2,%edx
    e3e1:	83 c2 01             	add    $0x1,%edx
    e3e4:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3ea:	8d 50 01             	lea    0x1(%eax),%edx
    e3ed:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3f0:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3f3:	01 d0                	add    %edx,%eax
    e3f5:	0f b6 00             	movzbl (%eax),%eax
    e3f8:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e3fa:	8b 45 08             	mov    0x8(%ebp),%eax
    e3fd:	8b 40 08             	mov    0x8(%eax),%eax
    e400:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e403:	c1 e2 02             	shl    $0x2,%edx
    e406:	83 c2 02             	add    $0x2,%edx
    e409:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e40c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e40f:	8d 50 01             	lea    0x1(%eax),%edx
    e412:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e415:	8b 55 0c             	mov    0xc(%ebp),%edx
    e418:	01 d0                	add    %edx,%eax
    e41a:	0f b6 00             	movzbl (%eax),%eax
    e41d:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e41f:	8b 45 08             	mov    0x8(%ebp),%eax
    e422:	8b 40 08             	mov    0x8(%eax),%eax
    e425:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e428:	c1 e2 02             	shl    $0x2,%edx
    e42b:	83 c2 03             	add    $0x3,%edx
    e42e:	01 d0                	add    %edx,%eax
    e430:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e433:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e437:	8b 45 08             	mov    0x8(%ebp),%eax
    e43a:	8b 40 0c             	mov    0xc(%eax),%eax
    e43d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e440:	0f 85 6d ff ff ff    	jne    e3b3 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e446:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e44b:	c9                   	leave  
    e44c:	c3                   	ret    

0000e44d <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e44d:	55                   	push   %ebp
    e44e:	89 e5                	mov    %esp,%ebp
    e450:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e453:	8b 45 08             	mov    0x8(%ebp),%eax
    e456:	8b 00                	mov    (%eax),%eax
    e458:	83 f8 03             	cmp    $0x3,%eax
    e45b:	75 4d                	jne    e4aa <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e45d:	8b 45 08             	mov    0x8(%ebp),%eax
    e460:	8b 40 0c             	mov    0xc(%eax),%eax
    e463:	3b 45 10             	cmp    0x10(%ebp),%eax
    e466:	7d 0a                	jge    e472 <readChunk_tRNS+0x25>
    e468:	b8 27 00 00 00       	mov    $0x27,%eax
    e46d:	e9 3c 01 00 00       	jmp    e5ae <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e472:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e479:	eb 22                	jmp    e49d <readChunk_tRNS+0x50>
    e47b:	8b 45 08             	mov    0x8(%ebp),%eax
    e47e:	8b 40 08             	mov    0x8(%eax),%eax
    e481:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e484:	c1 e2 02             	shl    $0x2,%edx
    e487:	83 c2 03             	add    $0x3,%edx
    e48a:	01 c2                	add    %eax,%edx
    e48c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e48f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e492:	01 c8                	add    %ecx,%eax
    e494:	0f b6 00             	movzbl (%eax),%eax
    e497:	88 02                	mov    %al,(%edx)
    e499:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e49d:	8b 45 10             	mov    0x10(%ebp),%eax
    e4a0:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e4a3:	75 d6                	jne    e47b <readChunk_tRNS+0x2e>
    e4a5:	e9 ff 00 00 00       	jmp    e5a9 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e4aa:	8b 45 08             	mov    0x8(%ebp),%eax
    e4ad:	8b 00                	mov    (%eax),%eax
    e4af:	85 c0                	test   %eax,%eax
    e4b1:	75 59                	jne    e50c <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e4b3:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e4b7:	74 0a                	je     e4c3 <readChunk_tRNS+0x76>
    e4b9:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e4be:	e9 eb 00 00 00       	jmp    e5ae <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e4c3:	8b 45 08             	mov    0x8(%ebp),%eax
    e4c6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e4cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4d0:	0f b6 00             	movzbl (%eax),%eax
    e4d3:	0f b6 c0             	movzbl %al,%eax
    e4d6:	c1 e0 08             	shl    $0x8,%eax
    e4d9:	89 c2                	mov    %eax,%edx
    e4db:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4de:	83 c0 01             	add    $0x1,%eax
    e4e1:	0f b6 00             	movzbl (%eax),%eax
    e4e4:	0f b6 c0             	movzbl %al,%eax
    e4e7:	01 c2                	add    %eax,%edx
    e4e9:	8b 45 08             	mov    0x8(%ebp),%eax
    e4ec:	89 50 1c             	mov    %edx,0x1c(%eax)
    e4ef:	8b 45 08             	mov    0x8(%ebp),%eax
    e4f2:	8b 50 1c             	mov    0x1c(%eax),%edx
    e4f5:	8b 45 08             	mov    0x8(%ebp),%eax
    e4f8:	89 50 18             	mov    %edx,0x18(%eax)
    e4fb:	8b 45 08             	mov    0x8(%ebp),%eax
    e4fe:	8b 50 18             	mov    0x18(%eax),%edx
    e501:	8b 45 08             	mov    0x8(%ebp),%eax
    e504:	89 50 14             	mov    %edx,0x14(%eax)
    e507:	e9 9d 00 00 00       	jmp    e5a9 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e50c:	8b 45 08             	mov    0x8(%ebp),%eax
    e50f:	8b 00                	mov    (%eax),%eax
    e511:	83 f8 02             	cmp    $0x2,%eax
    e514:	0f 85 88 00 00 00    	jne    e5a2 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e51a:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e51e:	74 0a                	je     e52a <readChunk_tRNS+0xdd>
    e520:	b8 29 00 00 00       	mov    $0x29,%eax
    e525:	e9 84 00 00 00       	jmp    e5ae <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e52a:	8b 45 08             	mov    0x8(%ebp),%eax
    e52d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e534:	8b 45 0c             	mov    0xc(%ebp),%eax
    e537:	0f b6 00             	movzbl (%eax),%eax
    e53a:	0f b6 c0             	movzbl %al,%eax
    e53d:	c1 e0 08             	shl    $0x8,%eax
    e540:	89 c2                	mov    %eax,%edx
    e542:	8b 45 0c             	mov    0xc(%ebp),%eax
    e545:	83 c0 01             	add    $0x1,%eax
    e548:	0f b6 00             	movzbl (%eax),%eax
    e54b:	0f b6 c0             	movzbl %al,%eax
    e54e:	01 c2                	add    %eax,%edx
    e550:	8b 45 08             	mov    0x8(%ebp),%eax
    e553:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e556:	8b 45 0c             	mov    0xc(%ebp),%eax
    e559:	83 c0 02             	add    $0x2,%eax
    e55c:	0f b6 00             	movzbl (%eax),%eax
    e55f:	0f b6 c0             	movzbl %al,%eax
    e562:	c1 e0 08             	shl    $0x8,%eax
    e565:	89 c2                	mov    %eax,%edx
    e567:	8b 45 0c             	mov    0xc(%ebp),%eax
    e56a:	83 c0 03             	add    $0x3,%eax
    e56d:	0f b6 00             	movzbl (%eax),%eax
    e570:	0f b6 c0             	movzbl %al,%eax
    e573:	01 c2                	add    %eax,%edx
    e575:	8b 45 08             	mov    0x8(%ebp),%eax
    e578:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e57b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e57e:	83 c0 04             	add    $0x4,%eax
    e581:	0f b6 00             	movzbl (%eax),%eax
    e584:	0f b6 c0             	movzbl %al,%eax
    e587:	c1 e0 08             	shl    $0x8,%eax
    e58a:	89 c2                	mov    %eax,%edx
    e58c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e58f:	83 c0 05             	add    $0x5,%eax
    e592:	0f b6 00             	movzbl (%eax),%eax
    e595:	0f b6 c0             	movzbl %al,%eax
    e598:	01 c2                	add    %eax,%edx
    e59a:	8b 45 08             	mov    0x8(%ebp),%eax
    e59d:	89 50 1c             	mov    %edx,0x1c(%eax)
    e5a0:	eb 07                	jmp    e5a9 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e5a2:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e5a7:	eb 05                	jmp    e5ae <readChunk_tRNS+0x161>

  return 0; /* OK */
    e5a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e5ae:	c9                   	leave  
    e5af:	c3                   	ret    

0000e5b0 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e5b0:	55                   	push   %ebp
    e5b1:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e5b3:	8b 45 08             	mov    0x8(%ebp),%eax
    e5b6:	8b 40 0c             	mov    0xc(%eax),%eax
    e5b9:	83 f8 03             	cmp    $0x3,%eax
    e5bc:	75 63                	jne    e621 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e5be:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e5c2:	74 0a                	je     e5ce <readChunk_bKGD+0x1e>
    e5c4:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e5c9:	e9 63 01 00 00       	jmp    e731 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e5ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5d1:	0f b6 00             	movzbl (%eax),%eax
    e5d4:	0f b6 d0             	movzbl %al,%edx
    e5d7:	8b 45 08             	mov    0x8(%ebp),%eax
    e5da:	8b 40 18             	mov    0x18(%eax),%eax
    e5dd:	39 c2                	cmp    %eax,%edx
    e5df:	7c 0a                	jl     e5eb <readChunk_bKGD+0x3b>
    e5e1:	b8 67 00 00 00       	mov    $0x67,%eax
    e5e6:	e9 46 01 00 00       	jmp    e731 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e5eb:	8b 45 08             	mov    0x8(%ebp),%eax
    e5ee:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e5f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5f8:	0f b6 00             	movzbl (%eax),%eax
    e5fb:	0f b6 d0             	movzbl %al,%edx
    e5fe:	8b 45 08             	mov    0x8(%ebp),%eax
    e601:	89 50 38             	mov    %edx,0x38(%eax)
    e604:	8b 45 08             	mov    0x8(%ebp),%eax
    e607:	8b 50 38             	mov    0x38(%eax),%edx
    e60a:	8b 45 08             	mov    0x8(%ebp),%eax
    e60d:	89 50 34             	mov    %edx,0x34(%eax)
    e610:	8b 45 08             	mov    0x8(%ebp),%eax
    e613:	8b 50 34             	mov    0x34(%eax),%edx
    e616:	8b 45 08             	mov    0x8(%ebp),%eax
    e619:	89 50 30             	mov    %edx,0x30(%eax)
    e61c:	e9 0b 01 00 00       	jmp    e72c <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e621:	8b 45 08             	mov    0x8(%ebp),%eax
    e624:	8b 40 0c             	mov    0xc(%eax),%eax
    e627:	85 c0                	test   %eax,%eax
    e629:	74 0b                	je     e636 <readChunk_bKGD+0x86>
    e62b:	8b 45 08             	mov    0x8(%ebp),%eax
    e62e:	8b 40 0c             	mov    0xc(%eax),%eax
    e631:	83 f8 04             	cmp    $0x4,%eax
    e634:	75 59                	jne    e68f <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e636:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e63a:	74 0a                	je     e646 <readChunk_bKGD+0x96>
    e63c:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e641:	e9 eb 00 00 00       	jmp    e731 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e646:	8b 45 08             	mov    0x8(%ebp),%eax
    e649:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e650:	8b 45 0c             	mov    0xc(%ebp),%eax
    e653:	0f b6 00             	movzbl (%eax),%eax
    e656:	0f b6 c0             	movzbl %al,%eax
    e659:	c1 e0 08             	shl    $0x8,%eax
    e65c:	89 c2                	mov    %eax,%edx
    e65e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e661:	83 c0 01             	add    $0x1,%eax
    e664:	0f b6 00             	movzbl (%eax),%eax
    e667:	0f b6 c0             	movzbl %al,%eax
    e66a:	01 c2                	add    %eax,%edx
    e66c:	8b 45 08             	mov    0x8(%ebp),%eax
    e66f:	89 50 38             	mov    %edx,0x38(%eax)
    e672:	8b 45 08             	mov    0x8(%ebp),%eax
    e675:	8b 50 38             	mov    0x38(%eax),%edx
    e678:	8b 45 08             	mov    0x8(%ebp),%eax
    e67b:	89 50 34             	mov    %edx,0x34(%eax)
    e67e:	8b 45 08             	mov    0x8(%ebp),%eax
    e681:	8b 50 34             	mov    0x34(%eax),%edx
    e684:	8b 45 08             	mov    0x8(%ebp),%eax
    e687:	89 50 30             	mov    %edx,0x30(%eax)
    e68a:	e9 9d 00 00 00       	jmp    e72c <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e68f:	8b 45 08             	mov    0x8(%ebp),%eax
    e692:	8b 40 0c             	mov    0xc(%eax),%eax
    e695:	83 f8 02             	cmp    $0x2,%eax
    e698:	74 0f                	je     e6a9 <readChunk_bKGD+0xf9>
    e69a:	8b 45 08             	mov    0x8(%ebp),%eax
    e69d:	8b 40 0c             	mov    0xc(%eax),%eax
    e6a0:	83 f8 06             	cmp    $0x6,%eax
    e6a3:	0f 85 83 00 00 00    	jne    e72c <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e6a9:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e6ad:	74 07                	je     e6b6 <readChunk_bKGD+0x106>
    e6af:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e6b4:	eb 7b                	jmp    e731 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e6b6:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b9:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e6c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6c3:	0f b6 00             	movzbl (%eax),%eax
    e6c6:	0f b6 c0             	movzbl %al,%eax
    e6c9:	c1 e0 08             	shl    $0x8,%eax
    e6cc:	89 c2                	mov    %eax,%edx
    e6ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6d1:	83 c0 01             	add    $0x1,%eax
    e6d4:	0f b6 00             	movzbl (%eax),%eax
    e6d7:	0f b6 c0             	movzbl %al,%eax
    e6da:	01 c2                	add    %eax,%edx
    e6dc:	8b 45 08             	mov    0x8(%ebp),%eax
    e6df:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e6e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6e5:	83 c0 02             	add    $0x2,%eax
    e6e8:	0f b6 00             	movzbl (%eax),%eax
    e6eb:	0f b6 c0             	movzbl %al,%eax
    e6ee:	c1 e0 08             	shl    $0x8,%eax
    e6f1:	89 c2                	mov    %eax,%edx
    e6f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6f6:	83 c0 03             	add    $0x3,%eax
    e6f9:	0f b6 00             	movzbl (%eax),%eax
    e6fc:	0f b6 c0             	movzbl %al,%eax
    e6ff:	01 c2                	add    %eax,%edx
    e701:	8b 45 08             	mov    0x8(%ebp),%eax
    e704:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e707:	8b 45 0c             	mov    0xc(%ebp),%eax
    e70a:	83 c0 04             	add    $0x4,%eax
    e70d:	0f b6 00             	movzbl (%eax),%eax
    e710:	0f b6 c0             	movzbl %al,%eax
    e713:	c1 e0 08             	shl    $0x8,%eax
    e716:	89 c2                	mov    %eax,%edx
    e718:	8b 45 0c             	mov    0xc(%ebp),%eax
    e71b:	83 c0 05             	add    $0x5,%eax
    e71e:	0f b6 00             	movzbl (%eax),%eax
    e721:	0f b6 c0             	movzbl %al,%eax
    e724:	01 c2                	add    %eax,%edx
    e726:	8b 45 08             	mov    0x8(%ebp),%eax
    e729:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e72c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e731:	5d                   	pop    %ebp
    e732:	c3                   	ret    

0000e733 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e733:	55                   	push   %ebp
    e734:	89 e5                	mov    %esp,%ebp
    e736:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e739:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e740:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e747:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e74e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e752:	0f 85 06 01 00 00    	jne    e85e <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e758:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e75f:	eb 04                	jmp    e765 <readChunk_tEXt+0x32>
    e761:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e765:	8b 45 10             	mov    0x10(%ebp),%eax
    e768:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e76b:	73 0f                	jae    e77c <readChunk_tEXt+0x49>
    e76d:	8b 55 0c             	mov    0xc(%ebp),%edx
    e770:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e773:	01 d0                	add    %edx,%eax
    e775:	0f b6 00             	movzbl (%eax),%eax
    e778:	84 c0                	test   %al,%al
    e77a:	75 e5                	jne    e761 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e77c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e780:	74 06                	je     e788 <readChunk_tEXt+0x55>
    e782:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e786:	76 0c                	jbe    e794 <readChunk_tEXt+0x61>
    e788:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e78f:	e9 ca 00 00 00       	jmp    e85e <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e794:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e797:	83 c0 01             	add    $0x1,%eax
    e79a:	83 ec 0c             	sub    $0xc,%esp
    e79d:	50                   	push   %eax
    e79e:	e8 73 4b ff ff       	call   3316 <lodepng_malloc>
    e7a3:	83 c4 10             	add    $0x10,%esp
    e7a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e7a9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e7ad:	75 0c                	jne    e7bb <readChunk_tEXt+0x88>
    e7af:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e7b6:	e9 a3 00 00 00       	jmp    e85e <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e7bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7be:	83 ec 04             	sub    $0x4,%esp
    e7c1:	50                   	push   %eax
    e7c2:	ff 75 0c             	pushl  0xc(%ebp)
    e7c5:	ff 75 f0             	pushl  -0x10(%ebp)
    e7c8:	e8 87 4b ff ff       	call   3354 <lodepng_memcpy>
    e7cd:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e7d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e7d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7d6:	01 d0                	add    %edx,%eax
    e7d8:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e7db:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7de:	83 c0 01             	add    $0x1,%eax
    e7e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e7e4:	8b 45 10             	mov    0x10(%ebp),%eax
    e7e7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e7ea:	72 08                	jb     e7f4 <readChunk_tEXt+0xc1>
    e7ec:	8b 45 10             	mov    0x10(%ebp),%eax
    e7ef:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e7f2:	eb 05                	jmp    e7f9 <readChunk_tEXt+0xc6>
    e7f4:	b8 00 00 00 00       	mov    $0x0,%eax
    e7f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e7fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7ff:	83 c0 01             	add    $0x1,%eax
    e802:	83 ec 0c             	sub    $0xc,%esp
    e805:	50                   	push   %eax
    e806:	e8 0b 4b ff ff       	call   3316 <lodepng_malloc>
    e80b:	83 c4 10             	add    $0x10,%esp
    e80e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e811:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e815:	75 09                	jne    e820 <readChunk_tEXt+0xed>
    e817:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e81e:	eb 3e                	jmp    e85e <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e820:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e823:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e826:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e829:	01 ca                	add    %ecx,%edx
    e82b:	83 ec 04             	sub    $0x4,%esp
    e82e:	50                   	push   %eax
    e82f:	52                   	push   %edx
    e830:	ff 75 ec             	pushl  -0x14(%ebp)
    e833:	e8 1c 4b ff ff       	call   3354 <lodepng_memcpy>
    e838:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e83b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e83e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e841:	01 d0                	add    %edx,%eax
    e843:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e846:	83 ec 04             	sub    $0x4,%esp
    e849:	ff 75 ec             	pushl  -0x14(%ebp)
    e84c:	ff 75 f0             	pushl  -0x10(%ebp)
    e84f:	ff 75 08             	pushl  0x8(%ebp)
    e852:	e8 3f ac ff ff       	call   9496 <lodepng_add_text>
    e857:	83 c4 10             	add    $0x10,%esp
    e85a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e85d:	90                   	nop
  }

  lodepng_free(key);
    e85e:	83 ec 0c             	sub    $0xc,%esp
    e861:	ff 75 f0             	pushl  -0x10(%ebp)
    e864:	e8 ce 4a ff ff       	call   3337 <lodepng_free>
    e869:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e86c:	83 ec 0c             	sub    $0xc,%esp
    e86f:	ff 75 ec             	pushl  -0x14(%ebp)
    e872:	e8 c0 4a ff ff       	call   3337 <lodepng_free>
    e877:	83 c4 10             	add    $0x10,%esp

  return error;
    e87a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e87d:	c9                   	leave  
    e87e:	c3                   	ret    

0000e87f <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e87f:	55                   	push   %ebp
    e880:	89 e5                	mov    %esp,%ebp
    e882:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e885:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e88c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e88f:	8b 10                	mov    (%eax),%edx
    e891:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e894:	8b 50 04             	mov    0x4(%eax),%edx
    e897:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e89a:	8b 50 08             	mov    0x8(%eax),%edx
    e89d:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e8a0:	8b 50 0c             	mov    0xc(%eax),%edx
    e8a3:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e8a6:	8b 50 10             	mov    0x10(%eax),%edx
    e8a9:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e8ac:	8b 40 14             	mov    0x14(%eax),%eax
    e8af:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e8b2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e8b9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e8c0:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e8c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e8cb:	0f 85 48 01 00 00    	jne    ea19 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e8d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e8d8:	eb 04                	jmp    e8de <readChunk_zTXt+0x5f>
    e8da:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e8de:	8b 45 14             	mov    0x14(%ebp),%eax
    e8e1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e8e4:	73 0f                	jae    e8f5 <readChunk_zTXt+0x76>
    e8e6:	8b 55 10             	mov    0x10(%ebp),%edx
    e8e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e8ec:	01 d0                	add    %edx,%eax
    e8ee:	0f b6 00             	movzbl (%eax),%eax
    e8f1:	84 c0                	test   %al,%al
    e8f3:	75 e5                	jne    e8da <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e8f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e8f8:	8d 50 02             	lea    0x2(%eax),%edx
    e8fb:	8b 45 14             	mov    0x14(%ebp),%eax
    e8fe:	39 c2                	cmp    %eax,%edx
    e900:	72 0c                	jb     e90e <readChunk_zTXt+0x8f>
    e902:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e909:	e9 0b 01 00 00       	jmp    ea19 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e90e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e912:	74 06                	je     e91a <readChunk_zTXt+0x9b>
    e914:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    e918:	76 0c                	jbe    e926 <readChunk_zTXt+0xa7>
    e91a:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e921:	e9 f3 00 00 00       	jmp    ea19 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    e926:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e929:	83 c0 01             	add    $0x1,%eax
    e92c:	83 ec 0c             	sub    $0xc,%esp
    e92f:	50                   	push   %eax
    e930:	e8 e1 49 ff ff       	call   3316 <lodepng_malloc>
    e935:	83 c4 10             	add    $0x10,%esp
    e938:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e93b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e93f:	75 0c                	jne    e94d <readChunk_zTXt+0xce>
    e941:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e948:	e9 cc 00 00 00       	jmp    ea19 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    e94d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e950:	83 ec 04             	sub    $0x4,%esp
    e953:	50                   	push   %eax
    e954:	ff 75 10             	pushl  0x10(%ebp)
    e957:	ff 75 ec             	pushl  -0x14(%ebp)
    e95a:	e8 f5 49 ff ff       	call   3354 <lodepng_memcpy>
    e95f:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e962:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e965:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e968:	01 d0                	add    %edx,%eax
    e96a:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    e96d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e970:	8d 50 01             	lea    0x1(%eax),%edx
    e973:	8b 45 10             	mov    0x10(%ebp),%eax
    e976:	01 d0                	add    %edx,%eax
    e978:	0f b6 00             	movzbl (%eax),%eax
    e97b:	84 c0                	test   %al,%al
    e97d:	74 0c                	je     e98b <readChunk_zTXt+0x10c>
    e97f:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    e986:	e9 8e 00 00 00       	jmp    ea19 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    e98b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e98e:	83 c0 02             	add    $0x2,%eax
    e991:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e994:	8b 45 14             	mov    0x14(%ebp),%eax
    e997:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e99a:	76 09                	jbe    e9a5 <readChunk_zTXt+0x126>
    e99c:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e9a3:	eb 74                	jmp    ea19 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    e9a5:	8b 45 14             	mov    0x14(%ebp),%eax
    e9a8:	2b 45 e8             	sub    -0x18(%ebp),%eax
    e9ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    e9ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9b1:	8b 40 30             	mov    0x30(%eax),%eax
    e9b4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    e9b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9ba:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e9bd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e9c0:	01 d1                	add    %edx,%ecx
    e9c2:	83 ec 08             	sub    $0x8,%esp
    e9c5:	8d 55 d0             	lea    -0x30(%ebp),%edx
    e9c8:	52                   	push   %edx
    e9c9:	50                   	push   %eax
    e9ca:	51                   	push   %ecx
    e9cb:	6a 00                	push   $0x0
    e9cd:	8d 45 c8             	lea    -0x38(%ebp),%eax
    e9d0:	50                   	push   %eax
    e9d1:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e9d4:	50                   	push   %eax
    e9d5:	e8 f7 93 ff ff       	call   7dd1 <zlib_decompress>
    e9da:	83 c4 20             	add    $0x20,%esp
    e9dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    e9e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9e4:	74 11                	je     e9f7 <readChunk_zTXt+0x178>
    e9e6:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e9e9:	8b 45 c8             	mov    -0x38(%ebp),%eax
    e9ec:	39 c2                	cmp    %eax,%edx
    e9ee:	7d 07                	jge    e9f7 <readChunk_zTXt+0x178>
    e9f0:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    e9f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9fb:	75 1b                	jne    ea18 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    e9fd:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ea00:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea03:	52                   	push   %edx
    ea04:	50                   	push   %eax
    ea05:	ff 75 ec             	pushl  -0x14(%ebp)
    ea08:	ff 75 08             	pushl  0x8(%ebp)
    ea0b:	e8 60 a9 ff ff       	call   9370 <lodepng_add_text_sized>
    ea10:	83 c4 10             	add    $0x10,%esp
    ea13:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    ea16:	eb 01                	jmp    ea19 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    ea18:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    ea19:	83 ec 0c             	sub    $0xc,%esp
    ea1c:	ff 75 ec             	pushl  -0x14(%ebp)
    ea1f:	e8 13 49 ff ff       	call   3337 <lodepng_free>
    ea24:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ea27:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea2a:	83 ec 0c             	sub    $0xc,%esp
    ea2d:	50                   	push   %eax
    ea2e:	e8 04 49 ff ff       	call   3337 <lodepng_free>
    ea33:	83 c4 10             	add    $0x10,%esp

  return error;
    ea36:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ea39:	c9                   	leave  
    ea3a:	c3                   	ret    

0000ea3b <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ea3b:	55                   	push   %ebp
    ea3c:	89 e5                	mov    %esp,%ebp
    ea3e:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ea41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ea48:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea4b:	8b 10                	mov    (%eax),%edx
    ea4d:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ea50:	8b 50 04             	mov    0x4(%eax),%edx
    ea53:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ea56:	8b 50 08             	mov    0x8(%eax),%edx
    ea59:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ea5c:	8b 50 0c             	mov    0xc(%eax),%edx
    ea5f:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ea62:	8b 50 10             	mov    0x10(%eax),%edx
    ea65:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ea68:	8b 40 14             	mov    0x14(%eax),%eax
    ea6b:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ea6e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ea75:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ea7c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ea83:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea87:	0f 85 d5 02 00 00    	jne    ed62 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ea8d:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    ea91:	7f 0c                	jg     ea9f <readChunk_iTXt+0x64>
    ea93:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    ea9a:	e9 c3 02 00 00       	jmp    ed62 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ea9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    eaa6:	eb 04                	jmp    eaac <readChunk_iTXt+0x71>
    eaa8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eaac:	8b 45 14             	mov    0x14(%ebp),%eax
    eaaf:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    eab2:	73 0f                	jae    eac3 <readChunk_iTXt+0x88>
    eab4:	8b 55 10             	mov    0x10(%ebp),%edx
    eab7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eaba:	01 d0                	add    %edx,%eax
    eabc:	0f b6 00             	movzbl (%eax),%eax
    eabf:	84 c0                	test   %al,%al
    eac1:	75 e5                	jne    eaa8 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    eac3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eac6:	8d 50 03             	lea    0x3(%eax),%edx
    eac9:	8b 45 14             	mov    0x14(%ebp),%eax
    eacc:	39 c2                	cmp    %eax,%edx
    eace:	72 0c                	jb     eadc <readChunk_iTXt+0xa1>
    ead0:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ead7:	e9 86 02 00 00       	jmp    ed62 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eadc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eae0:	74 06                	je     eae8 <readChunk_iTXt+0xad>
    eae2:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eae6:	76 0c                	jbe    eaf4 <readChunk_iTXt+0xb9>
    eae8:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eaef:	e9 6e 02 00 00       	jmp    ed62 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eaf4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eaf7:	83 c0 01             	add    $0x1,%eax
    eafa:	83 ec 0c             	sub    $0xc,%esp
    eafd:	50                   	push   %eax
    eafe:	e8 13 48 ff ff       	call   3316 <lodepng_malloc>
    eb03:	83 c4 10             	add    $0x10,%esp
    eb06:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eb09:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eb0d:	75 0c                	jne    eb1b <readChunk_iTXt+0xe0>
    eb0f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eb16:	e9 47 02 00 00       	jmp    ed62 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    eb1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb1e:	83 ec 04             	sub    $0x4,%esp
    eb21:	50                   	push   %eax
    eb22:	ff 75 10             	pushl  0x10(%ebp)
    eb25:	ff 75 e8             	pushl  -0x18(%ebp)
    eb28:	e8 27 48 ff ff       	call   3354 <lodepng_memcpy>
    eb2d:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eb30:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eb33:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb36:	01 d0                	add    %edx,%eax
    eb38:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    eb3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb3e:	8d 50 01             	lea    0x1(%eax),%edx
    eb41:	8b 45 10             	mov    0x10(%ebp),%eax
    eb44:	01 d0                	add    %edx,%eax
    eb46:	0f b6 00             	movzbl (%eax),%eax
    eb49:	0f b6 c0             	movzbl %al,%eax
    eb4c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eb4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb52:	8d 50 02             	lea    0x2(%eax),%edx
    eb55:	8b 45 10             	mov    0x10(%ebp),%eax
    eb58:	01 d0                	add    %edx,%eax
    eb5a:	0f b6 00             	movzbl (%eax),%eax
    eb5d:	84 c0                	test   %al,%al
    eb5f:	74 0c                	je     eb6d <readChunk_iTXt+0x132>
    eb61:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    eb68:	e9 f5 01 00 00       	jmp    ed62 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    eb6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb70:	83 c0 03             	add    $0x3,%eax
    eb73:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eb76:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eb7d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eb80:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eb83:	eb 08                	jmp    eb8d <readChunk_iTXt+0x152>
    eb85:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eb89:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eb8d:	8b 45 14             	mov    0x14(%ebp),%eax
    eb90:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eb93:	73 0f                	jae    eba4 <readChunk_iTXt+0x169>
    eb95:	8b 55 10             	mov    0x10(%ebp),%edx
    eb98:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eb9b:	01 d0                	add    %edx,%eax
    eb9d:	0f b6 00             	movzbl (%eax),%eax
    eba0:	84 c0                	test   %al,%al
    eba2:	75 e1                	jne    eb85 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    eba4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eba7:	83 c0 01             	add    $0x1,%eax
    ebaa:	83 ec 0c             	sub    $0xc,%esp
    ebad:	50                   	push   %eax
    ebae:	e8 63 47 ff ff       	call   3316 <lodepng_malloc>
    ebb3:	83 c4 10             	add    $0x10,%esp
    ebb6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ebb9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ebbd:	75 0c                	jne    ebcb <readChunk_iTXt+0x190>
    ebbf:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ebc6:	e9 97 01 00 00       	jmp    ed62 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ebcb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebce:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ebd1:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ebd4:	01 ca                	add    %ecx,%edx
    ebd6:	83 ec 04             	sub    $0x4,%esp
    ebd9:	50                   	push   %eax
    ebda:	52                   	push   %edx
    ebdb:	ff 75 e4             	pushl  -0x1c(%ebp)
    ebde:	e8 71 47 ff ff       	call   3354 <lodepng_memcpy>
    ebe3:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ebe6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ebe9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebec:	01 d0                	add    %edx,%eax
    ebee:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ebf1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ebf4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ebf7:	01 d0                	add    %edx,%eax
    ebf9:	83 c0 01             	add    $0x1,%eax
    ebfc:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ebff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ec06:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec09:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ec0c:	eb 08                	jmp    ec16 <readChunk_iTXt+0x1db>
    ec0e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec12:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ec16:	8b 45 14             	mov    0x14(%ebp),%eax
    ec19:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ec1c:	73 0f                	jae    ec2d <readChunk_iTXt+0x1f2>
    ec1e:	8b 55 10             	mov    0x10(%ebp),%edx
    ec21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec24:	01 d0                	add    %edx,%eax
    ec26:	0f b6 00             	movzbl (%eax),%eax
    ec29:	84 c0                	test   %al,%al
    ec2b:	75 e1                	jne    ec0e <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ec2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec30:	83 c0 01             	add    $0x1,%eax
    ec33:	83 ec 0c             	sub    $0xc,%esp
    ec36:	50                   	push   %eax
    ec37:	e8 da 46 ff ff       	call   3316 <lodepng_malloc>
    ec3c:	83 c4 10             	add    $0x10,%esp
    ec3f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ec42:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ec46:	75 0c                	jne    ec54 <readChunk_iTXt+0x219>
    ec48:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec4f:	e9 0e 01 00 00       	jmp    ed62 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ec54:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec57:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec5a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec5d:	01 ca                	add    %ecx,%edx
    ec5f:	83 ec 04             	sub    $0x4,%esp
    ec62:	50                   	push   %eax
    ec63:	52                   	push   %edx
    ec64:	ff 75 e0             	pushl  -0x20(%ebp)
    ec67:	e8 e8 46 ff ff       	call   3354 <lodepng_memcpy>
    ec6c:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ec6f:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ec72:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec75:	01 d0                	add    %edx,%eax
    ec77:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ec7a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec7d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec80:	01 d0                	add    %edx,%eax
    ec82:	83 c0 01             	add    $0x1,%eax
    ec85:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ec88:	8b 45 14             	mov    0x14(%ebp),%eax
    ec8b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ec8e:	72 08                	jb     ec98 <readChunk_iTXt+0x25d>
    ec90:	8b 45 14             	mov    0x14(%ebp),%eax
    ec93:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ec96:	eb 05                	jmp    ec9d <readChunk_iTXt+0x262>
    ec98:	b8 00 00 00 00       	mov    $0x0,%eax
    ec9d:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    eca0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    eca4:	0f 84 90 00 00 00    	je     ed3a <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ecaa:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ecb1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ecb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecbb:	8b 40 30             	mov    0x30(%eax),%eax
    ecbe:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ecc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecc4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ecc7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecca:	01 d1                	add    %edx,%ecx
    eccc:	83 ec 08             	sub    $0x8,%esp
    eccf:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ecd2:	52                   	push   %edx
    ecd3:	50                   	push   %eax
    ecd4:	51                   	push   %ecx
    ecd5:	6a 00                	push   $0x0
    ecd7:	8d 45 b8             	lea    -0x48(%ebp),%eax
    ecda:	50                   	push   %eax
    ecdb:	8d 45 bc             	lea    -0x44(%ebp),%eax
    ecde:	50                   	push   %eax
    ecdf:	e8 ed 90 ff ff       	call   7dd1 <zlib_decompress>
    ece4:	83 c4 20             	add    $0x20,%esp
    ece7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ecea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ecee:	74 11                	je     ed01 <readChunk_iTXt+0x2c6>
    ecf0:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ecf3:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ecf6:	39 c2                	cmp    %eax,%edx
    ecf8:	7d 07                	jge    ed01 <readChunk_iTXt+0x2c6>
    ecfa:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    ed01:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed05:	75 22                	jne    ed29 <readChunk_iTXt+0x2ee>
    ed07:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ed0a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed0d:	83 ec 08             	sub    $0x8,%esp
    ed10:	52                   	push   %edx
    ed11:	50                   	push   %eax
    ed12:	ff 75 e0             	pushl  -0x20(%ebp)
    ed15:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed18:	ff 75 e8             	pushl  -0x18(%ebp)
    ed1b:	ff 75 08             	pushl  0x8(%ebp)
    ed1e:	e8 94 a9 ff ff       	call   96b7 <lodepng_add_itext_sized>
    ed23:	83 c4 20             	add    $0x20,%esp
    ed26:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    ed29:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed2c:	83 ec 0c             	sub    $0xc,%esp
    ed2f:	50                   	push   %eax
    ed30:	e8 02 46 ff ff       	call   3337 <lodepng_free>
    ed35:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ed38:	eb 27                	jmp    ed61 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ed3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed3d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed40:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed43:	01 ca                	add    %ecx,%edx
    ed45:	83 ec 08             	sub    $0x8,%esp
    ed48:	50                   	push   %eax
    ed49:	52                   	push   %edx
    ed4a:	ff 75 e0             	pushl  -0x20(%ebp)
    ed4d:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed50:	ff 75 e8             	pushl  -0x18(%ebp)
    ed53:	ff 75 08             	pushl  0x8(%ebp)
    ed56:	e8 5c a9 ff ff       	call   96b7 <lodepng_add_itext_sized>
    ed5b:	83 c4 20             	add    $0x20,%esp
    ed5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    ed61:	90                   	nop
  }

  lodepng_free(key);
    ed62:	83 ec 0c             	sub    $0xc,%esp
    ed65:	ff 75 e8             	pushl  -0x18(%ebp)
    ed68:	e8 ca 45 ff ff       	call   3337 <lodepng_free>
    ed6d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ed70:	83 ec 0c             	sub    $0xc,%esp
    ed73:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed76:	e8 bc 45 ff ff       	call   3337 <lodepng_free>
    ed7b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    ed7e:	83 ec 0c             	sub    $0xc,%esp
    ed81:	ff 75 e0             	pushl  -0x20(%ebp)
    ed84:	e8 ae 45 ff ff       	call   3337 <lodepng_free>
    ed89:	83 c4 10             	add    $0x10,%esp

  return error;
    ed8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ed8f:	c9                   	leave  
    ed90:	c3                   	ret    

0000ed91 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ed91:	55                   	push   %ebp
    ed92:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    ed94:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    ed98:	74 0a                	je     eda4 <readChunk_tIME+0x13>
    ed9a:	b8 49 00 00 00       	mov    $0x49,%eax
    ed9f:	e9 8b 00 00 00       	jmp    ee2f <readChunk_tIME+0x9e>

  info->time_defined = 1;
    eda4:	8b 45 08             	mov    0x8(%ebp),%eax
    eda7:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    edae:	8b 45 0c             	mov    0xc(%ebp),%eax
    edb1:	0f b6 00             	movzbl (%eax),%eax
    edb4:	0f b6 c0             	movzbl %al,%eax
    edb7:	c1 e0 08             	shl    $0x8,%eax
    edba:	89 c2                	mov    %eax,%edx
    edbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    edbf:	83 c0 01             	add    $0x1,%eax
    edc2:	0f b6 00             	movzbl (%eax),%eax
    edc5:	0f b6 c0             	movzbl %al,%eax
    edc8:	01 c2                	add    %eax,%edx
    edca:	8b 45 08             	mov    0x8(%ebp),%eax
    edcd:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    edd0:	8b 45 0c             	mov    0xc(%ebp),%eax
    edd3:	83 c0 02             	add    $0x2,%eax
    edd6:	0f b6 00             	movzbl (%eax),%eax
    edd9:	0f b6 d0             	movzbl %al,%edx
    eddc:	8b 45 08             	mov    0x8(%ebp),%eax
    eddf:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    ede2:	8b 45 0c             	mov    0xc(%ebp),%eax
    ede5:	83 c0 03             	add    $0x3,%eax
    ede8:	0f b6 00             	movzbl (%eax),%eax
    edeb:	0f b6 d0             	movzbl %al,%edx
    edee:	8b 45 08             	mov    0x8(%ebp),%eax
    edf1:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    edf4:	8b 45 0c             	mov    0xc(%ebp),%eax
    edf7:	83 c0 04             	add    $0x4,%eax
    edfa:	0f b6 00             	movzbl (%eax),%eax
    edfd:	0f b6 d0             	movzbl %al,%edx
    ee00:	8b 45 08             	mov    0x8(%ebp),%eax
    ee03:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    ee06:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee09:	83 c0 05             	add    $0x5,%eax
    ee0c:	0f b6 00             	movzbl (%eax),%eax
    ee0f:	0f b6 d0             	movzbl %al,%edx
    ee12:	8b 45 08             	mov    0x8(%ebp),%eax
    ee15:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    ee18:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee1b:	83 c0 06             	add    $0x6,%eax
    ee1e:	0f b6 00             	movzbl (%eax),%eax
    ee21:	0f b6 d0             	movzbl %al,%edx
    ee24:	8b 45 08             	mov    0x8(%ebp),%eax
    ee27:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    ee2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ee2f:	5d                   	pop    %ebp
    ee30:	c3                   	ret    

0000ee31 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee31:	55                   	push   %ebp
    ee32:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    ee34:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    ee38:	74 0a                	je     ee44 <readChunk_pHYs+0x13>
    ee3a:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ee3f:	e9 ba 00 00 00       	jmp    eefe <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ee44:	8b 45 08             	mov    0x8(%ebp),%eax
    ee47:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ee4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee51:	0f b6 00             	movzbl (%eax),%eax
    ee54:	0f b6 c0             	movzbl %al,%eax
    ee57:	c1 e0 08             	shl    $0x8,%eax
    ee5a:	89 c2                	mov    %eax,%edx
    ee5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee5f:	83 c0 01             	add    $0x1,%eax
    ee62:	0f b6 00             	movzbl (%eax),%eax
    ee65:	0f b6 c0             	movzbl %al,%eax
    ee68:	01 d0                	add    %edx,%eax
    ee6a:	c1 e0 08             	shl    $0x8,%eax
    ee6d:	89 c2                	mov    %eax,%edx
    ee6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee72:	83 c0 02             	add    $0x2,%eax
    ee75:	0f b6 00             	movzbl (%eax),%eax
    ee78:	0f b6 c0             	movzbl %al,%eax
    ee7b:	01 d0                	add    %edx,%eax
    ee7d:	c1 e0 08             	shl    $0x8,%eax
    ee80:	89 c2                	mov    %eax,%edx
    ee82:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee85:	83 c0 03             	add    $0x3,%eax
    ee88:	0f b6 00             	movzbl (%eax),%eax
    ee8b:	0f b6 c0             	movzbl %al,%eax
    ee8e:	01 c2                	add    %eax,%edx
    ee90:	8b 45 08             	mov    0x8(%ebp),%eax
    ee93:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    ee96:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee99:	83 c0 04             	add    $0x4,%eax
    ee9c:	0f b6 00             	movzbl (%eax),%eax
    ee9f:	0f b6 c0             	movzbl %al,%eax
    eea2:	c1 e0 08             	shl    $0x8,%eax
    eea5:	89 c2                	mov    %eax,%edx
    eea7:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeaa:	83 c0 05             	add    $0x5,%eax
    eead:	0f b6 00             	movzbl (%eax),%eax
    eeb0:	0f b6 c0             	movzbl %al,%eax
    eeb3:	01 d0                	add    %edx,%eax
    eeb5:	c1 e0 08             	shl    $0x8,%eax
    eeb8:	89 c2                	mov    %eax,%edx
    eeba:	8b 45 0c             	mov    0xc(%ebp),%eax
    eebd:	83 c0 06             	add    $0x6,%eax
    eec0:	0f b6 00             	movzbl (%eax),%eax
    eec3:	0f b6 c0             	movzbl %al,%eax
    eec6:	01 d0                	add    %edx,%eax
    eec8:	c1 e0 08             	shl    $0x8,%eax
    eecb:	89 c2                	mov    %eax,%edx
    eecd:	8b 45 0c             	mov    0xc(%ebp),%eax
    eed0:	83 c0 07             	add    $0x7,%eax
    eed3:	0f b6 00             	movzbl (%eax),%eax
    eed6:	0f b6 c0             	movzbl %al,%eax
    eed9:	01 c2                	add    %eax,%edx
    eedb:	8b 45 08             	mov    0x8(%ebp),%eax
    eede:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    eee4:	8b 45 0c             	mov    0xc(%ebp),%eax
    eee7:	83 c0 08             	add    $0x8,%eax
    eeea:	0f b6 00             	movzbl (%eax),%eax
    eeed:	0f b6 d0             	movzbl %al,%edx
    eef0:	8b 45 08             	mov    0x8(%ebp),%eax
    eef3:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    eef9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eefe:	5d                   	pop    %ebp
    eeff:	c3                   	ret    

0000ef00 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef00:	55                   	push   %ebp
    ef01:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    ef03:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    ef07:	74 07                	je     ef10 <readChunk_gAMA+0x10>
    ef09:	b8 60 00 00 00       	mov    $0x60,%eax
    ef0e:	eb 5d                	jmp    ef6d <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    ef10:	8b 45 08             	mov    0x8(%ebp),%eax
    ef13:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    ef1a:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ef1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef20:	0f b6 00             	movzbl (%eax),%eax
    ef23:	0f b6 c0             	movzbl %al,%eax
    ef26:	c1 e0 08             	shl    $0x8,%eax
    ef29:	89 c2                	mov    %eax,%edx
    ef2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef2e:	83 c0 01             	add    $0x1,%eax
    ef31:	0f b6 00             	movzbl (%eax),%eax
    ef34:	0f b6 c0             	movzbl %al,%eax
    ef37:	01 d0                	add    %edx,%eax
    ef39:	c1 e0 08             	shl    $0x8,%eax
    ef3c:	89 c2                	mov    %eax,%edx
    ef3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef41:	83 c0 02             	add    $0x2,%eax
    ef44:	0f b6 00             	movzbl (%eax),%eax
    ef47:	0f b6 c0             	movzbl %al,%eax
    ef4a:	01 d0                	add    %edx,%eax
    ef4c:	c1 e0 08             	shl    $0x8,%eax
    ef4f:	89 c2                	mov    %eax,%edx
    ef51:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef54:	83 c0 03             	add    $0x3,%eax
    ef57:	0f b6 00             	movzbl (%eax),%eax
    ef5a:	0f b6 c0             	movzbl %al,%eax
    ef5d:	01 c2                	add    %eax,%edx
    ef5f:	8b 45 08             	mov    0x8(%ebp),%eax
    ef62:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    ef68:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef6d:	5d                   	pop    %ebp
    ef6e:	c3                   	ret    

0000ef6f <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef6f:	55                   	push   %ebp
    ef70:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    ef72:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    ef76:	74 0a                	je     ef82 <readChunk_cHRM+0x13>
    ef78:	b8 61 00 00 00       	mov    $0x61,%eax
    ef7d:	e9 7f 02 00 00       	jmp    f201 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    ef82:	8b 45 08             	mov    0x8(%ebp),%eax
    ef85:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    ef8c:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    ef8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef92:	0f b6 00             	movzbl (%eax),%eax
    ef95:	0f b6 c0             	movzbl %al,%eax
    ef98:	c1 e0 08             	shl    $0x8,%eax
    ef9b:	89 c2                	mov    %eax,%edx
    ef9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    efa0:	83 c0 01             	add    $0x1,%eax
    efa3:	0f b6 00             	movzbl (%eax),%eax
    efa6:	0f b6 c0             	movzbl %al,%eax
    efa9:	01 d0                	add    %edx,%eax
    efab:	c1 e0 08             	shl    $0x8,%eax
    efae:	89 c2                	mov    %eax,%edx
    efb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    efb3:	83 c0 02             	add    $0x2,%eax
    efb6:	0f b6 00             	movzbl (%eax),%eax
    efb9:	0f b6 c0             	movzbl %al,%eax
    efbc:	01 d0                	add    %edx,%eax
    efbe:	c1 e0 08             	shl    $0x8,%eax
    efc1:	89 c2                	mov    %eax,%edx
    efc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    efc6:	83 c0 03             	add    $0x3,%eax
    efc9:	0f b6 00             	movzbl (%eax),%eax
    efcc:	0f b6 c0             	movzbl %al,%eax
    efcf:	01 c2                	add    %eax,%edx
    efd1:	8b 45 08             	mov    0x8(%ebp),%eax
    efd4:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    efda:	8b 45 0c             	mov    0xc(%ebp),%eax
    efdd:	83 c0 04             	add    $0x4,%eax
    efe0:	0f b6 00             	movzbl (%eax),%eax
    efe3:	0f b6 c0             	movzbl %al,%eax
    efe6:	c1 e0 08             	shl    $0x8,%eax
    efe9:	89 c2                	mov    %eax,%edx
    efeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    efee:	83 c0 05             	add    $0x5,%eax
    eff1:	0f b6 00             	movzbl (%eax),%eax
    eff4:	0f b6 c0             	movzbl %al,%eax
    eff7:	01 d0                	add    %edx,%eax
    eff9:	c1 e0 08             	shl    $0x8,%eax
    effc:	89 c2                	mov    %eax,%edx
    effe:	8b 45 0c             	mov    0xc(%ebp),%eax
    f001:	83 c0 06             	add    $0x6,%eax
    f004:	0f b6 00             	movzbl (%eax),%eax
    f007:	0f b6 c0             	movzbl %al,%eax
    f00a:	01 d0                	add    %edx,%eax
    f00c:	c1 e0 08             	shl    $0x8,%eax
    f00f:	89 c2                	mov    %eax,%edx
    f011:	8b 45 0c             	mov    0xc(%ebp),%eax
    f014:	83 c0 07             	add    $0x7,%eax
    f017:	0f b6 00             	movzbl (%eax),%eax
    f01a:	0f b6 c0             	movzbl %al,%eax
    f01d:	01 c2                	add    %eax,%edx
    f01f:	8b 45 08             	mov    0x8(%ebp),%eax
    f022:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f028:	8b 45 0c             	mov    0xc(%ebp),%eax
    f02b:	83 c0 08             	add    $0x8,%eax
    f02e:	0f b6 00             	movzbl (%eax),%eax
    f031:	0f b6 c0             	movzbl %al,%eax
    f034:	c1 e0 08             	shl    $0x8,%eax
    f037:	89 c2                	mov    %eax,%edx
    f039:	8b 45 0c             	mov    0xc(%ebp),%eax
    f03c:	83 c0 09             	add    $0x9,%eax
    f03f:	0f b6 00             	movzbl (%eax),%eax
    f042:	0f b6 c0             	movzbl %al,%eax
    f045:	01 d0                	add    %edx,%eax
    f047:	c1 e0 08             	shl    $0x8,%eax
    f04a:	89 c2                	mov    %eax,%edx
    f04c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f04f:	83 c0 0a             	add    $0xa,%eax
    f052:	0f b6 00             	movzbl (%eax),%eax
    f055:	0f b6 c0             	movzbl %al,%eax
    f058:	01 d0                	add    %edx,%eax
    f05a:	c1 e0 08             	shl    $0x8,%eax
    f05d:	89 c2                	mov    %eax,%edx
    f05f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f062:	83 c0 0b             	add    $0xb,%eax
    f065:	0f b6 00             	movzbl (%eax),%eax
    f068:	0f b6 c0             	movzbl %al,%eax
    f06b:	01 c2                	add    %eax,%edx
    f06d:	8b 45 08             	mov    0x8(%ebp),%eax
    f070:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f076:	8b 45 0c             	mov    0xc(%ebp),%eax
    f079:	83 c0 0c             	add    $0xc,%eax
    f07c:	0f b6 00             	movzbl (%eax),%eax
    f07f:	0f b6 c0             	movzbl %al,%eax
    f082:	c1 e0 08             	shl    $0x8,%eax
    f085:	89 c2                	mov    %eax,%edx
    f087:	8b 45 0c             	mov    0xc(%ebp),%eax
    f08a:	83 c0 0d             	add    $0xd,%eax
    f08d:	0f b6 00             	movzbl (%eax),%eax
    f090:	0f b6 c0             	movzbl %al,%eax
    f093:	01 d0                	add    %edx,%eax
    f095:	c1 e0 08             	shl    $0x8,%eax
    f098:	89 c2                	mov    %eax,%edx
    f09a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f09d:	83 c0 0e             	add    $0xe,%eax
    f0a0:	0f b6 00             	movzbl (%eax),%eax
    f0a3:	0f b6 c0             	movzbl %al,%eax
    f0a6:	01 d0                	add    %edx,%eax
    f0a8:	c1 e0 08             	shl    $0x8,%eax
    f0ab:	89 c2                	mov    %eax,%edx
    f0ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0b0:	83 c0 0f             	add    $0xf,%eax
    f0b3:	0f b6 00             	movzbl (%eax),%eax
    f0b6:	0f b6 c0             	movzbl %al,%eax
    f0b9:	01 c2                	add    %eax,%edx
    f0bb:	8b 45 08             	mov    0x8(%ebp),%eax
    f0be:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f0c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0c7:	83 c0 10             	add    $0x10,%eax
    f0ca:	0f b6 00             	movzbl (%eax),%eax
    f0cd:	0f b6 c0             	movzbl %al,%eax
    f0d0:	c1 e0 08             	shl    $0x8,%eax
    f0d3:	89 c2                	mov    %eax,%edx
    f0d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d8:	83 c0 11             	add    $0x11,%eax
    f0db:	0f b6 00             	movzbl (%eax),%eax
    f0de:	0f b6 c0             	movzbl %al,%eax
    f0e1:	01 d0                	add    %edx,%eax
    f0e3:	c1 e0 08             	shl    $0x8,%eax
    f0e6:	89 c2                	mov    %eax,%edx
    f0e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0eb:	83 c0 12             	add    $0x12,%eax
    f0ee:	0f b6 00             	movzbl (%eax),%eax
    f0f1:	0f b6 c0             	movzbl %al,%eax
    f0f4:	01 d0                	add    %edx,%eax
    f0f6:	c1 e0 08             	shl    $0x8,%eax
    f0f9:	89 c2                	mov    %eax,%edx
    f0fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0fe:	83 c0 13             	add    $0x13,%eax
    f101:	0f b6 00             	movzbl (%eax),%eax
    f104:	0f b6 c0             	movzbl %al,%eax
    f107:	01 c2                	add    %eax,%edx
    f109:	8b 45 08             	mov    0x8(%ebp),%eax
    f10c:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f112:	8b 45 0c             	mov    0xc(%ebp),%eax
    f115:	83 c0 14             	add    $0x14,%eax
    f118:	0f b6 00             	movzbl (%eax),%eax
    f11b:	0f b6 c0             	movzbl %al,%eax
    f11e:	c1 e0 08             	shl    $0x8,%eax
    f121:	89 c2                	mov    %eax,%edx
    f123:	8b 45 0c             	mov    0xc(%ebp),%eax
    f126:	83 c0 15             	add    $0x15,%eax
    f129:	0f b6 00             	movzbl (%eax),%eax
    f12c:	0f b6 c0             	movzbl %al,%eax
    f12f:	01 d0                	add    %edx,%eax
    f131:	c1 e0 08             	shl    $0x8,%eax
    f134:	89 c2                	mov    %eax,%edx
    f136:	8b 45 0c             	mov    0xc(%ebp),%eax
    f139:	83 c0 16             	add    $0x16,%eax
    f13c:	0f b6 00             	movzbl (%eax),%eax
    f13f:	0f b6 c0             	movzbl %al,%eax
    f142:	01 d0                	add    %edx,%eax
    f144:	c1 e0 08             	shl    $0x8,%eax
    f147:	89 c2                	mov    %eax,%edx
    f149:	8b 45 0c             	mov    0xc(%ebp),%eax
    f14c:	83 c0 17             	add    $0x17,%eax
    f14f:	0f b6 00             	movzbl (%eax),%eax
    f152:	0f b6 c0             	movzbl %al,%eax
    f155:	01 c2                	add    %eax,%edx
    f157:	8b 45 08             	mov    0x8(%ebp),%eax
    f15a:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f160:	8b 45 0c             	mov    0xc(%ebp),%eax
    f163:	83 c0 18             	add    $0x18,%eax
    f166:	0f b6 00             	movzbl (%eax),%eax
    f169:	0f b6 c0             	movzbl %al,%eax
    f16c:	c1 e0 08             	shl    $0x8,%eax
    f16f:	89 c2                	mov    %eax,%edx
    f171:	8b 45 0c             	mov    0xc(%ebp),%eax
    f174:	83 c0 19             	add    $0x19,%eax
    f177:	0f b6 00             	movzbl (%eax),%eax
    f17a:	0f b6 c0             	movzbl %al,%eax
    f17d:	01 d0                	add    %edx,%eax
    f17f:	c1 e0 08             	shl    $0x8,%eax
    f182:	89 c2                	mov    %eax,%edx
    f184:	8b 45 0c             	mov    0xc(%ebp),%eax
    f187:	83 c0 1a             	add    $0x1a,%eax
    f18a:	0f b6 00             	movzbl (%eax),%eax
    f18d:	0f b6 c0             	movzbl %al,%eax
    f190:	01 d0                	add    %edx,%eax
    f192:	c1 e0 08             	shl    $0x8,%eax
    f195:	89 c2                	mov    %eax,%edx
    f197:	8b 45 0c             	mov    0xc(%ebp),%eax
    f19a:	83 c0 1b             	add    $0x1b,%eax
    f19d:	0f b6 00             	movzbl (%eax),%eax
    f1a0:	0f b6 c0             	movzbl %al,%eax
    f1a3:	01 c2                	add    %eax,%edx
    f1a5:	8b 45 08             	mov    0x8(%ebp),%eax
    f1a8:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1b1:	83 c0 1c             	add    $0x1c,%eax
    f1b4:	0f b6 00             	movzbl (%eax),%eax
    f1b7:	0f b6 c0             	movzbl %al,%eax
    f1ba:	c1 e0 08             	shl    $0x8,%eax
    f1bd:	89 c2                	mov    %eax,%edx
    f1bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1c2:	83 c0 1d             	add    $0x1d,%eax
    f1c5:	0f b6 00             	movzbl (%eax),%eax
    f1c8:	0f b6 c0             	movzbl %al,%eax
    f1cb:	01 d0                	add    %edx,%eax
    f1cd:	c1 e0 08             	shl    $0x8,%eax
    f1d0:	89 c2                	mov    %eax,%edx
    f1d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1d5:	83 c0 1e             	add    $0x1e,%eax
    f1d8:	0f b6 00             	movzbl (%eax),%eax
    f1db:	0f b6 c0             	movzbl %al,%eax
    f1de:	01 d0                	add    %edx,%eax
    f1e0:	c1 e0 08             	shl    $0x8,%eax
    f1e3:	89 c2                	mov    %eax,%edx
    f1e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e8:	83 c0 1f             	add    $0x1f,%eax
    f1eb:	0f b6 00             	movzbl (%eax),%eax
    f1ee:	0f b6 c0             	movzbl %al,%eax
    f1f1:	01 c2                	add    %eax,%edx
    f1f3:	8b 45 08             	mov    0x8(%ebp),%eax
    f1f6:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f1fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f201:	5d                   	pop    %ebp
    f202:	c3                   	ret    

0000f203 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f203:	55                   	push   %ebp
    f204:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f206:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f20a:	74 07                	je     f213 <readChunk_sRGB+0x10>
    f20c:	b8 62 00 00 00       	mov    $0x62,%eax
    f211:	eb 24                	jmp    f237 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f213:	8b 45 08             	mov    0x8(%ebp),%eax
    f216:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f21d:	00 00 00 
  info->srgb_intent = data[0];
    f220:	8b 45 0c             	mov    0xc(%ebp),%eax
    f223:	0f b6 00             	movzbl (%eax),%eax
    f226:	0f b6 d0             	movzbl %al,%edx
    f229:	8b 45 08             	mov    0x8(%ebp),%eax
    f22c:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f232:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f237:	5d                   	pop    %ebp
    f238:	c3                   	ret    

0000f239 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f239:	55                   	push   %ebp
    f23a:	89 e5                	mov    %esp,%ebp
    f23c:	53                   	push   %ebx
    f23d:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f240:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f247:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f24e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f251:	8b 10                	mov    (%eax),%edx
    f253:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f256:	8b 50 04             	mov    0x4(%eax),%edx
    f259:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f25c:	8b 50 08             	mov    0x8(%eax),%edx
    f25f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f262:	8b 50 0c             	mov    0xc(%eax),%edx
    f265:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f268:	8b 50 10             	mov    0x10(%eax),%edx
    f26b:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f26e:	8b 40 14             	mov    0x14(%eax),%eax
    f271:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f274:	8b 45 08             	mov    0x8(%ebp),%eax
    f277:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f27e:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f281:	8b 45 08             	mov    0x8(%ebp),%eax
    f284:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f28a:	85 c0                	test   %eax,%eax
    f28c:	74 0e                	je     f29c <readChunk_iCCP+0x63>
    f28e:	83 ec 0c             	sub    $0xc,%esp
    f291:	ff 75 08             	pushl  0x8(%ebp)
    f294:	e8 ca a6 ff ff       	call   9963 <lodepng_clear_icc>
    f299:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f29c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f2a3:	eb 04                	jmp    f2a9 <readChunk_iCCP+0x70>
    f2a5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f2a9:	8b 45 14             	mov    0x14(%ebp),%eax
    f2ac:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f2af:	73 0f                	jae    f2c0 <readChunk_iCCP+0x87>
    f2b1:	8b 55 10             	mov    0x10(%ebp),%edx
    f2b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2b7:	01 d0                	add    %edx,%eax
    f2b9:	0f b6 00             	movzbl (%eax),%eax
    f2bc:	84 c0                	test   %al,%al
    f2be:	75 e5                	jne    f2a5 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f2c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2c3:	8d 50 02             	lea    0x2(%eax),%edx
    f2c6:	8b 45 14             	mov    0x14(%ebp),%eax
    f2c9:	39 c2                	cmp    %eax,%edx
    f2cb:	72 0a                	jb     f2d7 <readChunk_iCCP+0x9e>
    f2cd:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f2d2:	e9 46 01 00 00       	jmp    f41d <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f2d7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f2db:	74 06                	je     f2e3 <readChunk_iCCP+0xaa>
    f2dd:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f2e1:	76 0a                	jbe    f2ed <readChunk_iCCP+0xb4>
    f2e3:	b8 59 00 00 00       	mov    $0x59,%eax
    f2e8:	e9 30 01 00 00       	jmp    f41d <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f2ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2f0:	83 c0 01             	add    $0x1,%eax
    f2f3:	83 ec 0c             	sub    $0xc,%esp
    f2f6:	50                   	push   %eax
    f2f7:	e8 1a 40 ff ff       	call   3316 <lodepng_malloc>
    f2fc:	83 c4 10             	add    $0x10,%esp
    f2ff:	89 c2                	mov    %eax,%edx
    f301:	8b 45 08             	mov    0x8(%ebp),%eax
    f304:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f30a:	8b 45 08             	mov    0x8(%ebp),%eax
    f30d:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f313:	85 c0                	test   %eax,%eax
    f315:	75 0a                	jne    f321 <readChunk_iCCP+0xe8>
    f317:	b8 53 00 00 00       	mov    $0x53,%eax
    f31c:	e9 fc 00 00 00       	jmp    f41d <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f321:	8b 45 08             	mov    0x8(%ebp),%eax
    f324:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f32a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f32d:	01 d0                	add    %edx,%eax
    f32f:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f332:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f339:	eb 1f                	jmp    f35a <readChunk_iCCP+0x121>
    f33b:	8b 45 08             	mov    0x8(%ebp),%eax
    f33e:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f344:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f347:	01 d0                	add    %edx,%eax
    f349:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f34c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f34f:	01 ca                	add    %ecx,%edx
    f351:	0f b6 12             	movzbl (%edx),%edx
    f354:	88 10                	mov    %dl,(%eax)
    f356:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f35a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f35d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f360:	75 d9                	jne    f33b <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f362:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f365:	8d 50 01             	lea    0x1(%eax),%edx
    f368:	8b 45 10             	mov    0x10(%ebp),%eax
    f36b:	01 d0                	add    %edx,%eax
    f36d:	0f b6 00             	movzbl (%eax),%eax
    f370:	84 c0                	test   %al,%al
    f372:	74 0a                	je     f37e <readChunk_iCCP+0x145>
    f374:	b8 48 00 00 00       	mov    $0x48,%eax
    f379:	e9 9f 00 00 00       	jmp    f41d <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f37e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f381:	83 c0 02             	add    $0x2,%eax
    f384:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f387:	8b 45 14             	mov    0x14(%ebp),%eax
    f38a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f38d:	76 0a                	jbe    f399 <readChunk_iCCP+0x160>
    f38f:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f394:	e9 84 00 00 00       	jmp    f41d <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f399:	8b 45 14             	mov    0x14(%ebp),%eax
    f39c:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f39f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f3a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3a5:	8b 40 34             	mov    0x34(%eax),%eax
    f3a8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f3ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3ae:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f3b1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f3b4:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f3b7:	8b 55 08             	mov    0x8(%ebp),%edx
    f3ba:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f3c0:	83 ec 08             	sub    $0x8,%esp
    f3c3:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f3c6:	52                   	push   %edx
    f3c7:	50                   	push   %eax
    f3c8:	53                   	push   %ebx
    f3c9:	6a 00                	push   $0x0
    f3cb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f3ce:	50                   	push   %eax
    f3cf:	51                   	push   %ecx
    f3d0:	e8 fc 89 ff ff       	call   7dd1 <zlib_decompress>
    f3d5:	83 c4 20             	add    $0x20,%esp
    f3d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f3db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f3df:	74 11                	je     f3f2 <readChunk_iCCP+0x1b9>
    f3e1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f3e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f3e7:	39 c2                	cmp    %eax,%edx
    f3e9:	7d 07                	jge    f3f2 <readChunk_iCCP+0x1b9>
    f3eb:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f3f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f3f5:	89 c2                	mov    %eax,%edx
    f3f7:	8b 45 08             	mov    0x8(%ebp),%eax
    f3fa:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f400:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f404:	75 14                	jne    f41a <readChunk_iCCP+0x1e1>
    f406:	8b 45 08             	mov    0x8(%ebp),%eax
    f409:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f40f:	85 c0                	test   %eax,%eax
    f411:	75 07                	jne    f41a <readChunk_iCCP+0x1e1>
    f413:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f41a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f41d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f420:	c9                   	leave  
    f421:	c3                   	ret    

0000f422 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f422:	55                   	push   %ebp
    f423:	89 e5                	mov    %esp,%ebp
    f425:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f428:	8b 55 0c             	mov    0xc(%ebp),%edx
    f42b:	8b 45 10             	mov    0x10(%ebp),%eax
    f42e:	01 d0                	add    %edx,%eax
    f430:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f433:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f43a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f441:	8b 45 0c             	mov    0xc(%ebp),%eax
    f444:	83 c0 04             	add    $0x4,%eax
    f447:	3b 45 14             	cmp    0x14(%ebp),%eax
    f44a:	7e 0a                	jle    f456 <lodepng_inspect_chunk+0x34>
    f44c:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f451:	e9 43 03 00 00       	jmp    f799 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f456:	ff 75 ec             	pushl  -0x14(%ebp)
    f459:	e8 3a 8e ff ff       	call   8298 <lodepng_chunk_length>
    f45e:	83 c4 04             	add    $0x4,%esp
    f461:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f464:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f467:	85 c0                	test   %eax,%eax
    f469:	79 0a                	jns    f475 <lodepng_inspect_chunk+0x53>
    f46b:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f470:	e9 24 03 00 00       	jmp    f799 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f475:	ff 75 ec             	pushl  -0x14(%ebp)
    f478:	e8 53 8f ff ff       	call   83d0 <lodepng_chunk_data_const>
    f47d:	83 c4 04             	add    $0x4,%esp
    f480:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f483:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f486:	8d 50 04             	lea    0x4(%eax),%edx
    f489:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f48c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f48f:	8b 55 14             	mov    0x14(%ebp),%edx
    f492:	8b 45 10             	mov    0x10(%ebp),%eax
    f495:	01 d0                	add    %edx,%eax
    f497:	39 c1                	cmp    %eax,%ecx
    f499:	76 0a                	jbe    f4a5 <lodepng_inspect_chunk+0x83>
    f49b:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f4a0:	e9 f4 02 00 00       	jmp    f799 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f4a5:	68 48 a0 01 00       	push   $0x1a048
    f4aa:	ff 75 ec             	pushl  -0x14(%ebp)
    f4ad:	e8 33 8e ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f4b2:	83 c4 08             	add    $0x8,%esp
    f4b5:	84 c0                	test   %al,%al
    f4b7:	74 24                	je     f4dd <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f4b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4bc:	8b 55 08             	mov    0x8(%ebp),%edx
    f4bf:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f4c5:	83 ec 04             	sub    $0x4,%esp
    f4c8:	50                   	push   %eax
    f4c9:	ff 75 e4             	pushl  -0x1c(%ebp)
    f4cc:	52                   	push   %edx
    f4cd:	e8 5b ee ff ff       	call   e32d <readChunk_PLTE>
    f4d2:	83 c4 10             	add    $0x10,%esp
    f4d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f4d8:	e9 8a 02 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f4dd:	83 ec 08             	sub    $0x8,%esp
    f4e0:	68 4d a0 01 00       	push   $0x1a04d
    f4e5:	ff 75 ec             	pushl  -0x14(%ebp)
    f4e8:	e8 f8 8d ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f4ed:	83 c4 10             	add    $0x10,%esp
    f4f0:	84 c0                	test   %al,%al
    f4f2:	74 24                	je     f518 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f4f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4f7:	8b 55 08             	mov    0x8(%ebp),%edx
    f4fa:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f500:	83 ec 04             	sub    $0x4,%esp
    f503:	50                   	push   %eax
    f504:	ff 75 e4             	pushl  -0x1c(%ebp)
    f507:	52                   	push   %edx
    f508:	e8 40 ef ff ff       	call   e44d <readChunk_tRNS>
    f50d:	83 c4 10             	add    $0x10,%esp
    f510:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f513:	e9 4f 02 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f518:	83 ec 08             	sub    $0x8,%esp
    f51b:	68 52 a0 01 00       	push   $0x1a052
    f520:	ff 75 ec             	pushl  -0x14(%ebp)
    f523:	e8 bd 8d ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f528:	83 c4 10             	add    $0x10,%esp
    f52b:	84 c0                	test   %al,%al
    f52d:	74 24                	je     f553 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f52f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f532:	8b 55 08             	mov    0x8(%ebp),%edx
    f535:	81 c2 98 00 00 00    	add    $0x98,%edx
    f53b:	83 ec 04             	sub    $0x4,%esp
    f53e:	50                   	push   %eax
    f53f:	ff 75 e4             	pushl  -0x1c(%ebp)
    f542:	52                   	push   %edx
    f543:	e8 68 f0 ff ff       	call   e5b0 <readChunk_bKGD>
    f548:	83 c4 10             	add    $0x10,%esp
    f54b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f54e:	e9 14 02 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f553:	83 ec 08             	sub    $0x8,%esp
    f556:	68 57 a0 01 00       	push   $0x1a057
    f55b:	ff 75 ec             	pushl  -0x14(%ebp)
    f55e:	e8 82 8d ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f563:	83 c4 10             	add    $0x10,%esp
    f566:	84 c0                	test   %al,%al
    f568:	74 24                	je     f58e <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f56a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f56d:	8b 55 08             	mov    0x8(%ebp),%edx
    f570:	81 c2 98 00 00 00    	add    $0x98,%edx
    f576:	83 ec 04             	sub    $0x4,%esp
    f579:	50                   	push   %eax
    f57a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f57d:	52                   	push   %edx
    f57e:	e8 b0 f1 ff ff       	call   e733 <readChunk_tEXt>
    f583:	83 c4 10             	add    $0x10,%esp
    f586:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f589:	e9 d9 01 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f58e:	83 ec 08             	sub    $0x8,%esp
    f591:	68 5c a0 01 00       	push   $0x1a05c
    f596:	ff 75 ec             	pushl  -0x14(%ebp)
    f599:	e8 47 8d ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f59e:	83 c4 10             	add    $0x10,%esp
    f5a1:	84 c0                	test   %al,%al
    f5a3:	74 25                	je     f5ca <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5a5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5a8:	8b 45 08             	mov    0x8(%ebp),%eax
    f5ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5ae:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5b4:	52                   	push   %edx
    f5b5:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5b8:	50                   	push   %eax
    f5b9:	51                   	push   %ecx
    f5ba:	e8 c0 f2 ff ff       	call   e87f <readChunk_zTXt>
    f5bf:	83 c4 10             	add    $0x10,%esp
    f5c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5c5:	e9 9d 01 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f5ca:	83 ec 08             	sub    $0x8,%esp
    f5cd:	68 61 a0 01 00       	push   $0x1a061
    f5d2:	ff 75 ec             	pushl  -0x14(%ebp)
    f5d5:	e8 0b 8d ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f5da:	83 c4 10             	add    $0x10,%esp
    f5dd:	84 c0                	test   %al,%al
    f5df:	74 25                	je     f606 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5e1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5e4:	8b 45 08             	mov    0x8(%ebp),%eax
    f5e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5ea:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5f0:	52                   	push   %edx
    f5f1:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5f4:	50                   	push   %eax
    f5f5:	51                   	push   %ecx
    f5f6:	e8 40 f4 ff ff       	call   ea3b <readChunk_iTXt>
    f5fb:	83 c4 10             	add    $0x10,%esp
    f5fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f601:	e9 61 01 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f606:	83 ec 08             	sub    $0x8,%esp
    f609:	68 66 a0 01 00       	push   $0x1a066
    f60e:	ff 75 ec             	pushl  -0x14(%ebp)
    f611:	e8 cf 8c ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f616:	83 c4 10             	add    $0x10,%esp
    f619:	84 c0                	test   %al,%al
    f61b:	74 24                	je     f641 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f61d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f620:	8b 55 08             	mov    0x8(%ebp),%edx
    f623:	81 c2 98 00 00 00    	add    $0x98,%edx
    f629:	83 ec 04             	sub    $0x4,%esp
    f62c:	50                   	push   %eax
    f62d:	ff 75 e4             	pushl  -0x1c(%ebp)
    f630:	52                   	push   %edx
    f631:	e8 5b f7 ff ff       	call   ed91 <readChunk_tIME>
    f636:	83 c4 10             	add    $0x10,%esp
    f639:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f63c:	e9 26 01 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f641:	83 ec 08             	sub    $0x8,%esp
    f644:	68 6b a0 01 00       	push   $0x1a06b
    f649:	ff 75 ec             	pushl  -0x14(%ebp)
    f64c:	e8 94 8c ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f651:	83 c4 10             	add    $0x10,%esp
    f654:	84 c0                	test   %al,%al
    f656:	74 24                	je     f67c <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f658:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f65b:	8b 55 08             	mov    0x8(%ebp),%edx
    f65e:	81 c2 98 00 00 00    	add    $0x98,%edx
    f664:	83 ec 04             	sub    $0x4,%esp
    f667:	50                   	push   %eax
    f668:	ff 75 e4             	pushl  -0x1c(%ebp)
    f66b:	52                   	push   %edx
    f66c:	e8 c0 f7 ff ff       	call   ee31 <readChunk_pHYs>
    f671:	83 c4 10             	add    $0x10,%esp
    f674:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f677:	e9 eb 00 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f67c:	83 ec 08             	sub    $0x8,%esp
    f67f:	68 70 a0 01 00       	push   $0x1a070
    f684:	ff 75 ec             	pushl  -0x14(%ebp)
    f687:	e8 59 8c ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f68c:	83 c4 10             	add    $0x10,%esp
    f68f:	84 c0                	test   %al,%al
    f691:	74 24                	je     f6b7 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f693:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f696:	8b 55 08             	mov    0x8(%ebp),%edx
    f699:	81 c2 98 00 00 00    	add    $0x98,%edx
    f69f:	83 ec 04             	sub    $0x4,%esp
    f6a2:	50                   	push   %eax
    f6a3:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6a6:	52                   	push   %edx
    f6a7:	e8 54 f8 ff ff       	call   ef00 <readChunk_gAMA>
    f6ac:	83 c4 10             	add    $0x10,%esp
    f6af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6b2:	e9 b0 00 00 00       	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f6b7:	83 ec 08             	sub    $0x8,%esp
    f6ba:	68 75 a0 01 00       	push   $0x1a075
    f6bf:	ff 75 ec             	pushl  -0x14(%ebp)
    f6c2:	e8 1e 8c ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f6c7:	83 c4 10             	add    $0x10,%esp
    f6ca:	84 c0                	test   %al,%al
    f6cc:	74 21                	je     f6ef <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f6ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6d1:	8b 55 08             	mov    0x8(%ebp),%edx
    f6d4:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6da:	83 ec 04             	sub    $0x4,%esp
    f6dd:	50                   	push   %eax
    f6de:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6e1:	52                   	push   %edx
    f6e2:	e8 88 f8 ff ff       	call   ef6f <readChunk_cHRM>
    f6e7:	83 c4 10             	add    $0x10,%esp
    f6ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6ed:	eb 78                	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f6ef:	83 ec 08             	sub    $0x8,%esp
    f6f2:	68 7a a0 01 00       	push   $0x1a07a
    f6f7:	ff 75 ec             	pushl  -0x14(%ebp)
    f6fa:	e8 e6 8b ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f6ff:	83 c4 10             	add    $0x10,%esp
    f702:	84 c0                	test   %al,%al
    f704:	74 21                	je     f727 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f706:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f709:	8b 55 08             	mov    0x8(%ebp),%edx
    f70c:	81 c2 98 00 00 00    	add    $0x98,%edx
    f712:	83 ec 04             	sub    $0x4,%esp
    f715:	50                   	push   %eax
    f716:	ff 75 e4             	pushl  -0x1c(%ebp)
    f719:	52                   	push   %edx
    f71a:	e8 e4 fa ff ff       	call   f203 <readChunk_sRGB>
    f71f:	83 c4 10             	add    $0x10,%esp
    f722:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f725:	eb 40                	jmp    f767 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f727:	83 ec 08             	sub    $0x8,%esp
    f72a:	68 7f a0 01 00       	push   $0x1a07f
    f72f:	ff 75 ec             	pushl  -0x14(%ebp)
    f732:	e8 ae 8b ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f737:	83 c4 10             	add    $0x10,%esp
    f73a:	84 c0                	test   %al,%al
    f73c:	74 22                	je     f760 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f73e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f741:	8b 45 08             	mov    0x8(%ebp),%eax
    f744:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f747:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f74d:	52                   	push   %edx
    f74e:	ff 75 e4             	pushl  -0x1c(%ebp)
    f751:	50                   	push   %eax
    f752:	51                   	push   %ecx
    f753:	e8 e1 fa ff ff       	call   f239 <readChunk_iCCP>
    f758:	83 c4 10             	add    $0x10,%esp
    f75b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f75e:	eb 07                	jmp    f767 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f760:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f767:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f76b:	75 29                	jne    f796 <lodepng_inspect_chunk+0x374>
    f76d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f771:	75 23                	jne    f796 <lodepng_inspect_chunk+0x374>
    f773:	8b 45 08             	mov    0x8(%ebp),%eax
    f776:	8b 40 18             	mov    0x18(%eax),%eax
    f779:	85 c0                	test   %eax,%eax
    f77b:	75 19                	jne    f796 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f77d:	83 ec 0c             	sub    $0xc,%esp
    f780:	ff 75 ec             	pushl  -0x14(%ebp)
    f783:	e8 53 8c ff ff       	call   83db <lodepng_chunk_check_crc>
    f788:	83 c4 10             	add    $0x10,%esp
    f78b:	85 c0                	test   %eax,%eax
    f78d:	74 07                	je     f796 <lodepng_inspect_chunk+0x374>
    f78f:	b8 39 00 00 00       	mov    $0x39,%eax
    f794:	eb 03                	jmp    f799 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f796:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f799:	c9                   	leave  
    f79a:	c3                   	ret    

0000f79b <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f79b:	55                   	push   %ebp
    f79c:	89 e5                	mov    %esp,%ebp
    f79e:	56                   	push   %esi
    f79f:	53                   	push   %ebx
    f7a0:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f7a3:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f7a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f7ae:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f7b5:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f7bc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f7c3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f7ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f7d1:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f7d8:	8b 45 08             	mov    0x8(%ebp),%eax
    f7db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f7e1:	8b 45 10             	mov    0x10(%ebp),%eax
    f7e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f7ea:	8b 45 10             	mov    0x10(%ebp),%eax
    f7ed:	8b 10                	mov    (%eax),%edx
    f7ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7f2:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f7f4:	83 ec 0c             	sub    $0xc,%esp
    f7f7:	ff 75 1c             	pushl  0x1c(%ebp)
    f7fa:	ff 75 18             	pushl  0x18(%ebp)
    f7fd:	ff 75 14             	pushl  0x14(%ebp)
    f800:	ff 75 10             	pushl  0x10(%ebp)
    f803:	ff 75 0c             	pushl  0xc(%ebp)
    f806:	e8 d3 da ff ff       	call   d2de <lodepng_inspect>
    f80b:	83 c4 20             	add    $0x20,%esp
    f80e:	89 c2                	mov    %eax,%edx
    f810:	8b 45 14             	mov    0x14(%ebp),%eax
    f813:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f819:	8b 45 14             	mov    0x14(%ebp),%eax
    f81c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f822:	85 c0                	test   %eax,%eax
    f824:	0f 85 24 0a 00 00    	jne    1024e <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f82a:	8b 45 14             	mov    0x14(%ebp),%eax
    f82d:	8d 58 78             	lea    0x78(%eax),%ebx
    f830:	8b 45 14             	mov    0x14(%ebp),%eax
    f833:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f839:	8b 45 10             	mov    0x10(%ebp),%eax
    f83c:	8b 10                	mov    (%eax),%edx
    f83e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f841:	8b 00                	mov    (%eax),%eax
    f843:	53                   	push   %ebx
    f844:	51                   	push   %ecx
    f845:	52                   	push   %edx
    f846:	50                   	push   %eax
    f847:	e8 76 97 ff ff       	call   8fc2 <lodepng_pixel_overflow>
    f84c:	83 c4 10             	add    $0x10,%esp
    f84f:	85 c0                	test   %eax,%eax
    f851:	74 12                	je     f865 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f853:	8b 45 14             	mov    0x14(%ebp),%eax
    f856:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f85d:	00 00 00 
    f860:	e9 ea 09 00 00       	jmp    1024f <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f865:	83 ec 0c             	sub    $0xc,%esp
    f868:	ff 75 1c             	pushl  0x1c(%ebp)
    f86b:	e8 a6 3a ff ff       	call   3316 <lodepng_malloc>
    f870:	83 c4 10             	add    $0x10,%esp
    f873:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f876:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f87a:	75 12                	jne    f88e <decodeGeneric+0xf3>
    f87c:	8b 45 14             	mov    0x14(%ebp),%eax
    f87f:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f886:	00 00 00 
    f889:	e9 c1 09 00 00       	jmp    1024f <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f88e:	8b 45 18             	mov    0x18(%ebp),%eax
    f891:	83 c0 21             	add    $0x21,%eax
    f894:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f897:	e9 81 06 00 00       	jmp    ff1d <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f89c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f89f:	8b 45 18             	mov    0x18(%ebp),%eax
    f8a2:	29 c2                	sub    %eax,%edx
    f8a4:	89 d0                	mov    %edx,%eax
    f8a6:	83 c0 0c             	add    $0xc,%eax
    f8a9:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f8ac:	7f 08                	jg     f8b6 <decodeGeneric+0x11b>
    f8ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f8b1:	3b 45 18             	cmp    0x18(%ebp),%eax
    f8b4:	73 20                	jae    f8d6 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8b6:	8b 45 14             	mov    0x14(%ebp),%eax
    f8b9:	8b 40 20             	mov    0x20(%eax),%eax
    f8bc:	85 c0                	test   %eax,%eax
    f8be:	0f 85 72 06 00 00    	jne    ff36 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f8c4:	8b 45 14             	mov    0x14(%ebp),%eax
    f8c7:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f8ce:	00 00 00 
    f8d1:	e9 6a 06 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f8d6:	83 ec 0c             	sub    $0xc,%esp
    f8d9:	ff 75 f0             	pushl  -0x10(%ebp)
    f8dc:	e8 b7 89 ff ff       	call   8298 <lodepng_chunk_length>
    f8e1:	83 c4 10             	add    $0x10,%esp
    f8e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f8e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f8ea:	85 c0                	test   %eax,%eax
    f8ec:	79 20                	jns    f90e <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8ee:	8b 45 14             	mov    0x14(%ebp),%eax
    f8f1:	8b 40 20             	mov    0x20(%eax),%eax
    f8f4:	85 c0                	test   %eax,%eax
    f8f6:	0f 85 3d 06 00 00    	jne    ff39 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f8fc:	8b 45 14             	mov    0x14(%ebp),%eax
    f8ff:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f906:	00 00 00 
    f909:	e9 32 06 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f90e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f911:	8b 45 18             	mov    0x18(%ebp),%eax
    f914:	29 c2                	sub    %eax,%edx
    f916:	89 d0                	mov    %edx,%eax
    f918:	89 c2                	mov    %eax,%edx
    f91a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f91d:	01 d0                	add    %edx,%eax
    f91f:	83 c0 0c             	add    $0xc,%eax
    f922:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f925:	7f 10                	jg     f937 <decodeGeneric+0x19c>
    f927:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f92a:	8d 50 0c             	lea    0xc(%eax),%edx
    f92d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f930:	01 d0                	add    %edx,%eax
    f932:	3b 45 18             	cmp    0x18(%ebp),%eax
    f935:	73 12                	jae    f949 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    f937:	8b 45 14             	mov    0x14(%ebp),%eax
    f93a:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    f941:	00 00 00 
    f944:	e9 f7 05 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    f949:	83 ec 0c             	sub    $0xc,%esp
    f94c:	ff 75 f0             	pushl  -0x10(%ebp)
    f94f:	e8 7c 8a ff ff       	call   83d0 <lodepng_chunk_data_const>
    f954:	83 c4 10             	add    $0x10,%esp
    f957:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    f95a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    f961:	83 ec 08             	sub    $0x8,%esp
    f964:	68 84 a0 01 00       	push   $0x1a084
    f969:	ff 75 f0             	pushl  -0x10(%ebp)
    f96c:	e8 74 89 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    f971:	83 c4 10             	add    $0x10,%esp
    f974:	84 c0                	test   %al,%al
    f976:	74 79                	je     f9f1 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    f978:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f97b:	83 ec 04             	sub    $0x4,%esp
    f97e:	8d 55 bc             	lea    -0x44(%ebp),%edx
    f981:	52                   	push   %edx
    f982:	50                   	push   %eax
    f983:	ff 75 ec             	pushl  -0x14(%ebp)
    f986:	e8 4f 3a ff ff       	call   33da <lodepng_addofl>
    f98b:	83 c4 10             	add    $0x10,%esp
    f98e:	85 c0                	test   %eax,%eax
    f990:	74 12                	je     f9a4 <decodeGeneric+0x209>
    f992:	8b 45 14             	mov    0x14(%ebp),%eax
    f995:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f99c:	00 00 00 
    f99f:	e9 9c 05 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    f9a4:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f9a7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f9aa:	7e 13                	jle    f9bf <decodeGeneric+0x224>
    f9ac:	8b 45 14             	mov    0x14(%ebp),%eax
    f9af:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f9b6:	00 00 00 
    f9b9:	90                   	nop
    f9ba:	e9 81 05 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    f9bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9c2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    f9c5:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f9c8:	01 ca                	add    %ecx,%edx
    f9ca:	83 ec 04             	sub    $0x4,%esp
    f9cd:	50                   	push   %eax
    f9ce:	ff 75 d0             	pushl  -0x30(%ebp)
    f9d1:	52                   	push   %edx
    f9d2:	e8 7d 39 ff ff       	call   3354 <lodepng_memcpy>
    f9d7:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    f9da:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f9dd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9e0:	01 d0                	add    %edx,%eax
    f9e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    f9e5:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    f9ec:	e9 db 04 00 00       	jmp    fecc <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    f9f1:	83 ec 08             	sub    $0x8,%esp
    f9f4:	68 89 a0 01 00       	push   $0x1a089
    f9f9:	ff 75 f0             	pushl  -0x10(%ebp)
    f9fc:	e8 e4 88 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fa01:	83 c4 10             	add    $0x10,%esp
    fa04:	84 c0                	test   %al,%al
    fa06:	74 09                	je     fa11 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fa08:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fa0c:	e9 bb 04 00 00       	jmp    fecc <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fa11:	83 ec 08             	sub    $0x8,%esp
    fa14:	68 48 a0 01 00       	push   $0x1a048
    fa19:	ff 75 f0             	pushl  -0x10(%ebp)
    fa1c:	e8 c4 88 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fa21:	83 c4 10             	add    $0x10,%esp
    fa24:	84 c0                	test   %al,%al
    fa26:	74 44                	je     fa6c <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fa28:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa2b:	8b 55 14             	mov    0x14(%ebp),%edx
    fa2e:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa34:	83 ec 04             	sub    $0x4,%esp
    fa37:	50                   	push   %eax
    fa38:	ff 75 d0             	pushl  -0x30(%ebp)
    fa3b:	52                   	push   %edx
    fa3c:	e8 ec e8 ff ff       	call   e32d <readChunk_PLTE>
    fa41:	83 c4 10             	add    $0x10,%esp
    fa44:	89 c2                	mov    %eax,%edx
    fa46:	8b 45 14             	mov    0x14(%ebp),%eax
    fa49:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fa4f:	8b 45 14             	mov    0x14(%ebp),%eax
    fa52:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fa58:	85 c0                	test   %eax,%eax
    fa5a:	0f 85 dc 04 00 00    	jne    ff3c <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fa60:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fa67:	e9 60 04 00 00       	jmp    fecc <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fa6c:	83 ec 08             	sub    $0x8,%esp
    fa6f:	68 4d a0 01 00       	push   $0x1a04d
    fa74:	ff 75 f0             	pushl  -0x10(%ebp)
    fa77:	e8 69 88 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fa7c:	83 c4 10             	add    $0x10,%esp
    fa7f:	84 c0                	test   %al,%al
    fa81:	74 3d                	je     fac0 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fa83:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa86:	8b 55 14             	mov    0x14(%ebp),%edx
    fa89:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa8f:	83 ec 04             	sub    $0x4,%esp
    fa92:	50                   	push   %eax
    fa93:	ff 75 d0             	pushl  -0x30(%ebp)
    fa96:	52                   	push   %edx
    fa97:	e8 b1 e9 ff ff       	call   e44d <readChunk_tRNS>
    fa9c:	83 c4 10             	add    $0x10,%esp
    fa9f:	89 c2                	mov    %eax,%edx
    faa1:	8b 45 14             	mov    0x14(%ebp),%eax
    faa4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    faaa:	8b 45 14             	mov    0x14(%ebp),%eax
    faad:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fab3:	85 c0                	test   %eax,%eax
    fab5:	0f 84 11 04 00 00    	je     fecc <decodeGeneric+0x731>
    fabb:	e9 80 04 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fac0:	83 ec 08             	sub    $0x8,%esp
    fac3:	68 52 a0 01 00       	push   $0x1a052
    fac8:	ff 75 f0             	pushl  -0x10(%ebp)
    facb:	e8 15 88 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fad0:	83 c4 10             	add    $0x10,%esp
    fad3:	84 c0                	test   %al,%al
    fad5:	74 3d                	je     fb14 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fad7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fada:	8b 55 14             	mov    0x14(%ebp),%edx
    fadd:	81 c2 98 00 00 00    	add    $0x98,%edx
    fae3:	83 ec 04             	sub    $0x4,%esp
    fae6:	50                   	push   %eax
    fae7:	ff 75 d0             	pushl  -0x30(%ebp)
    faea:	52                   	push   %edx
    faeb:	e8 c0 ea ff ff       	call   e5b0 <readChunk_bKGD>
    faf0:	83 c4 10             	add    $0x10,%esp
    faf3:	89 c2                	mov    %eax,%edx
    faf5:	8b 45 14             	mov    0x14(%ebp),%eax
    faf8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fafe:	8b 45 14             	mov    0x14(%ebp),%eax
    fb01:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb07:	85 c0                	test   %eax,%eax
    fb09:	0f 84 bd 03 00 00    	je     fecc <decodeGeneric+0x731>
    fb0f:	e9 2c 04 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fb14:	83 ec 08             	sub    $0x8,%esp
    fb17:	68 57 a0 01 00       	push   $0x1a057
    fb1c:	ff 75 f0             	pushl  -0x10(%ebp)
    fb1f:	e8 c1 87 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fb24:	83 c4 10             	add    $0x10,%esp
    fb27:	84 c0                	test   %al,%al
    fb29:	74 4b                	je     fb76 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fb2b:	8b 45 14             	mov    0x14(%ebp),%eax
    fb2e:	8b 40 28             	mov    0x28(%eax),%eax
    fb31:	85 c0                	test   %eax,%eax
    fb33:	0f 84 93 03 00 00    	je     fecc <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fb39:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb3c:	8b 55 14             	mov    0x14(%ebp),%edx
    fb3f:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb45:	83 ec 04             	sub    $0x4,%esp
    fb48:	50                   	push   %eax
    fb49:	ff 75 d0             	pushl  -0x30(%ebp)
    fb4c:	52                   	push   %edx
    fb4d:	e8 e1 eb ff ff       	call   e733 <readChunk_tEXt>
    fb52:	83 c4 10             	add    $0x10,%esp
    fb55:	89 c2                	mov    %eax,%edx
    fb57:	8b 45 14             	mov    0x14(%ebp),%eax
    fb5a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fb60:	8b 45 14             	mov    0x14(%ebp),%eax
    fb63:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb69:	85 c0                	test   %eax,%eax
    fb6b:	0f 84 5b 03 00 00    	je     fecc <decodeGeneric+0x731>
    fb71:	e9 ca 03 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fb76:	83 ec 08             	sub    $0x8,%esp
    fb79:	68 5c a0 01 00       	push   $0x1a05c
    fb7e:	ff 75 f0             	pushl  -0x10(%ebp)
    fb81:	e8 5f 87 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fb86:	83 c4 10             	add    $0x10,%esp
    fb89:	84 c0                	test   %al,%al
    fb8b:	74 4c                	je     fbd9 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fb8d:	8b 45 14             	mov    0x14(%ebp),%eax
    fb90:	8b 40 28             	mov    0x28(%eax),%eax
    fb93:	85 c0                	test   %eax,%eax
    fb95:	0f 84 31 03 00 00    	je     fecc <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fb9b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fb9e:	8b 45 14             	mov    0x14(%ebp),%eax
    fba1:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fba4:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fbaa:	52                   	push   %edx
    fbab:	ff 75 d0             	pushl  -0x30(%ebp)
    fbae:	50                   	push   %eax
    fbaf:	51                   	push   %ecx
    fbb0:	e8 ca ec ff ff       	call   e87f <readChunk_zTXt>
    fbb5:	83 c4 10             	add    $0x10,%esp
    fbb8:	89 c2                	mov    %eax,%edx
    fbba:	8b 45 14             	mov    0x14(%ebp),%eax
    fbbd:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fbc3:	8b 45 14             	mov    0x14(%ebp),%eax
    fbc6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbcc:	85 c0                	test   %eax,%eax
    fbce:	0f 84 f8 02 00 00    	je     fecc <decodeGeneric+0x731>
    fbd4:	e9 67 03 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fbd9:	83 ec 08             	sub    $0x8,%esp
    fbdc:	68 61 a0 01 00       	push   $0x1a061
    fbe1:	ff 75 f0             	pushl  -0x10(%ebp)
    fbe4:	e8 fc 86 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fbe9:	83 c4 10             	add    $0x10,%esp
    fbec:	84 c0                	test   %al,%al
    fbee:	74 4c                	je     fc3c <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fbf0:	8b 45 14             	mov    0x14(%ebp),%eax
    fbf3:	8b 40 28             	mov    0x28(%eax),%eax
    fbf6:	85 c0                	test   %eax,%eax
    fbf8:	0f 84 ce 02 00 00    	je     fecc <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fbfe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc01:	8b 45 14             	mov    0x14(%ebp),%eax
    fc04:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fc07:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fc0d:	52                   	push   %edx
    fc0e:	ff 75 d0             	pushl  -0x30(%ebp)
    fc11:	50                   	push   %eax
    fc12:	51                   	push   %ecx
    fc13:	e8 23 ee ff ff       	call   ea3b <readChunk_iTXt>
    fc18:	83 c4 10             	add    $0x10,%esp
    fc1b:	89 c2                	mov    %eax,%edx
    fc1d:	8b 45 14             	mov    0x14(%ebp),%eax
    fc20:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc26:	8b 45 14             	mov    0x14(%ebp),%eax
    fc29:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc2f:	85 c0                	test   %eax,%eax
    fc31:	0f 84 95 02 00 00    	je     fecc <decodeGeneric+0x731>
    fc37:	e9 04 03 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fc3c:	83 ec 08             	sub    $0x8,%esp
    fc3f:	68 66 a0 01 00       	push   $0x1a066
    fc44:	ff 75 f0             	pushl  -0x10(%ebp)
    fc47:	e8 99 86 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fc4c:	83 c4 10             	add    $0x10,%esp
    fc4f:	84 c0                	test   %al,%al
    fc51:	74 3d                	je     fc90 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fc53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc56:	8b 55 14             	mov    0x14(%ebp),%edx
    fc59:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc5f:	83 ec 04             	sub    $0x4,%esp
    fc62:	50                   	push   %eax
    fc63:	ff 75 d0             	pushl  -0x30(%ebp)
    fc66:	52                   	push   %edx
    fc67:	e8 25 f1 ff ff       	call   ed91 <readChunk_tIME>
    fc6c:	83 c4 10             	add    $0x10,%esp
    fc6f:	89 c2                	mov    %eax,%edx
    fc71:	8b 45 14             	mov    0x14(%ebp),%eax
    fc74:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fc7a:	8b 45 14             	mov    0x14(%ebp),%eax
    fc7d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc83:	85 c0                	test   %eax,%eax
    fc85:	0f 84 41 02 00 00    	je     fecc <decodeGeneric+0x731>
    fc8b:	e9 b0 02 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fc90:	83 ec 08             	sub    $0x8,%esp
    fc93:	68 6b a0 01 00       	push   $0x1a06b
    fc98:	ff 75 f0             	pushl  -0x10(%ebp)
    fc9b:	e8 45 86 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fca0:	83 c4 10             	add    $0x10,%esp
    fca3:	84 c0                	test   %al,%al
    fca5:	74 3d                	je     fce4 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fca7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcaa:	8b 55 14             	mov    0x14(%ebp),%edx
    fcad:	81 c2 98 00 00 00    	add    $0x98,%edx
    fcb3:	83 ec 04             	sub    $0x4,%esp
    fcb6:	50                   	push   %eax
    fcb7:	ff 75 d0             	pushl  -0x30(%ebp)
    fcba:	52                   	push   %edx
    fcbb:	e8 71 f1 ff ff       	call   ee31 <readChunk_pHYs>
    fcc0:	83 c4 10             	add    $0x10,%esp
    fcc3:	89 c2                	mov    %eax,%edx
    fcc5:	8b 45 14             	mov    0x14(%ebp),%eax
    fcc8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fcce:	8b 45 14             	mov    0x14(%ebp),%eax
    fcd1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fcd7:	85 c0                	test   %eax,%eax
    fcd9:	0f 84 ed 01 00 00    	je     fecc <decodeGeneric+0x731>
    fcdf:	e9 5c 02 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fce4:	83 ec 08             	sub    $0x8,%esp
    fce7:	68 70 a0 01 00       	push   $0x1a070
    fcec:	ff 75 f0             	pushl  -0x10(%ebp)
    fcef:	e8 f1 85 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fcf4:	83 c4 10             	add    $0x10,%esp
    fcf7:	84 c0                	test   %al,%al
    fcf9:	74 3d                	je     fd38 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fcfb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcfe:	8b 55 14             	mov    0x14(%ebp),%edx
    fd01:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd07:	83 ec 04             	sub    $0x4,%esp
    fd0a:	50                   	push   %eax
    fd0b:	ff 75 d0             	pushl  -0x30(%ebp)
    fd0e:	52                   	push   %edx
    fd0f:	e8 ec f1 ff ff       	call   ef00 <readChunk_gAMA>
    fd14:	83 c4 10             	add    $0x10,%esp
    fd17:	89 c2                	mov    %eax,%edx
    fd19:	8b 45 14             	mov    0x14(%ebp),%eax
    fd1c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd22:	8b 45 14             	mov    0x14(%ebp),%eax
    fd25:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd2b:	85 c0                	test   %eax,%eax
    fd2d:	0f 84 99 01 00 00    	je     fecc <decodeGeneric+0x731>
    fd33:	e9 08 02 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fd38:	83 ec 08             	sub    $0x8,%esp
    fd3b:	68 75 a0 01 00       	push   $0x1a075
    fd40:	ff 75 f0             	pushl  -0x10(%ebp)
    fd43:	e8 9d 85 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fd48:	83 c4 10             	add    $0x10,%esp
    fd4b:	84 c0                	test   %al,%al
    fd4d:	74 3d                	je     fd8c <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fd4f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd52:	8b 55 14             	mov    0x14(%ebp),%edx
    fd55:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd5b:	83 ec 04             	sub    $0x4,%esp
    fd5e:	50                   	push   %eax
    fd5f:	ff 75 d0             	pushl  -0x30(%ebp)
    fd62:	52                   	push   %edx
    fd63:	e8 07 f2 ff ff       	call   ef6f <readChunk_cHRM>
    fd68:	83 c4 10             	add    $0x10,%esp
    fd6b:	89 c2                	mov    %eax,%edx
    fd6d:	8b 45 14             	mov    0x14(%ebp),%eax
    fd70:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd76:	8b 45 14             	mov    0x14(%ebp),%eax
    fd79:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd7f:	85 c0                	test   %eax,%eax
    fd81:	0f 84 45 01 00 00    	je     fecc <decodeGeneric+0x731>
    fd87:	e9 b4 01 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fd8c:	83 ec 08             	sub    $0x8,%esp
    fd8f:	68 7a a0 01 00       	push   $0x1a07a
    fd94:	ff 75 f0             	pushl  -0x10(%ebp)
    fd97:	e8 49 85 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fd9c:	83 c4 10             	add    $0x10,%esp
    fd9f:	84 c0                	test   %al,%al
    fda1:	74 3d                	je     fde0 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fda3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fda6:	8b 55 14             	mov    0x14(%ebp),%edx
    fda9:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdaf:	83 ec 04             	sub    $0x4,%esp
    fdb2:	50                   	push   %eax
    fdb3:	ff 75 d0             	pushl  -0x30(%ebp)
    fdb6:	52                   	push   %edx
    fdb7:	e8 47 f4 ff ff       	call   f203 <readChunk_sRGB>
    fdbc:	83 c4 10             	add    $0x10,%esp
    fdbf:	89 c2                	mov    %eax,%edx
    fdc1:	8b 45 14             	mov    0x14(%ebp),%eax
    fdc4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdca:	8b 45 14             	mov    0x14(%ebp),%eax
    fdcd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdd3:	85 c0                	test   %eax,%eax
    fdd5:	0f 84 f1 00 00 00    	je     fecc <decodeGeneric+0x731>
    fddb:	e9 60 01 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fde0:	83 ec 08             	sub    $0x8,%esp
    fde3:	68 7f a0 01 00       	push   $0x1a07f
    fde8:	ff 75 f0             	pushl  -0x10(%ebp)
    fdeb:	e8 f5 84 ff ff       	call   82e5 <lodepng_chunk_type_equals>
    fdf0:	83 c4 10             	add    $0x10,%esp
    fdf3:	84 c0                	test   %al,%al
    fdf5:	74 3e                	je     fe35 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fdf7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fdfa:	8b 45 14             	mov    0x14(%ebp),%eax
    fdfd:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fe00:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fe06:	52                   	push   %edx
    fe07:	ff 75 d0             	pushl  -0x30(%ebp)
    fe0a:	50                   	push   %eax
    fe0b:	51                   	push   %ecx
    fe0c:	e8 28 f4 ff ff       	call   f239 <readChunk_iCCP>
    fe11:	83 c4 10             	add    $0x10,%esp
    fe14:	89 c2                	mov    %eax,%edx
    fe16:	8b 45 14             	mov    0x14(%ebp),%eax
    fe19:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe1f:	8b 45 14             	mov    0x14(%ebp),%eax
    fe22:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe28:	85 c0                	test   %eax,%eax
    fe2a:	0f 84 9c 00 00 00    	je     fecc <decodeGeneric+0x731>
    fe30:	e9 0b 01 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    fe35:	8b 45 14             	mov    0x14(%ebp),%eax
    fe38:	8b 40 1c             	mov    0x1c(%eax),%eax
    fe3b:	85 c0                	test   %eax,%eax
    fe3d:	75 24                	jne    fe63 <decodeGeneric+0x6c8>
    fe3f:	83 ec 0c             	sub    $0xc,%esp
    fe42:	ff 75 f0             	pushl  -0x10(%ebp)
    fe45:	e8 30 85 ff ff       	call   837a <lodepng_chunk_ancillary>
    fe4a:	83 c4 10             	add    $0x10,%esp
    fe4d:	84 c0                	test   %al,%al
    fe4f:	75 12                	jne    fe63 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    fe51:	8b 45 14             	mov    0x14(%ebp),%eax
    fe54:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    fe5b:	00 00 00 
    fe5e:	e9 dd 00 00 00       	jmp    ff40 <decodeGeneric+0x7a5>
      }

      unknown = 1;
    fe63:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    fe6a:	8b 45 14             	mov    0x14(%ebp),%eax
    fe6d:	8b 40 2c             	mov    0x2c(%eax),%eax
    fe70:	85 c0                	test   %eax,%eax
    fe72:	74 58                	je     fecc <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    fe74:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe77:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    fe7a:	83 c0 58             	add    $0x58,%eax
    fe7d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    fe84:	8b 45 14             	mov    0x14(%ebp),%eax
    fe87:	01 d0                	add    %edx,%eax
    fe89:	8d 50 10             	lea    0x10(%eax),%edx
    fe8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe8f:	83 e8 01             	sub    $0x1,%eax
    fe92:	83 c0 54             	add    $0x54,%eax
    fe95:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    fe9c:	8b 45 14             	mov    0x14(%ebp),%eax
    fe9f:	01 c8                	add    %ecx,%eax
    fea1:	83 c0 14             	add    $0x14,%eax
    fea4:	83 ec 04             	sub    $0x4,%esp
    fea7:	ff 75 f0             	pushl  -0x10(%ebp)
    feaa:	52                   	push   %edx
    feab:	50                   	push   %eax
    feac:	e8 15 88 ff ff       	call   86c6 <lodepng_chunk_append>
    feb1:	83 c4 10             	add    $0x10,%esp
    feb4:	89 c2                	mov    %eax,%edx
    feb6:	8b 45 14             	mov    0x14(%ebp),%eax
    feb9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    febf:	8b 45 14             	mov    0x14(%ebp),%eax
    fec2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fec8:	85 c0                	test   %eax,%eax
    feca:	75 73                	jne    ff3f <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    fecc:	8b 45 14             	mov    0x14(%ebp),%eax
    fecf:	8b 40 18             	mov    0x18(%eax),%eax
    fed2:	85 c0                	test   %eax,%eax
    fed4:	75 27                	jne    fefd <decodeGeneric+0x762>
    fed6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    feda:	75 21                	jne    fefd <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    fedc:	83 ec 0c             	sub    $0xc,%esp
    fedf:	ff 75 f0             	pushl  -0x10(%ebp)
    fee2:	e8 f4 84 ff ff       	call   83db <lodepng_chunk_check_crc>
    fee7:	83 c4 10             	add    $0x10,%esp
    feea:	85 c0                	test   %eax,%eax
    feec:	74 0f                	je     fefd <decodeGeneric+0x762>
    feee:	8b 45 14             	mov    0x14(%ebp),%eax
    fef1:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    fef8:	00 00 00 
    fefb:	eb 43                	jmp    ff40 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    fefd:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff01:	75 1a                	jne    ff1d <decodeGeneric+0x782>
    ff03:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ff06:	8b 45 18             	mov    0x18(%ebp),%eax
    ff09:	01 d0                	add    %edx,%eax
    ff0b:	83 ec 08             	sub    $0x8,%esp
    ff0e:	50                   	push   %eax
    ff0f:	ff 75 f0             	pushl  -0x10(%ebp)
    ff12:	e8 3f 86 ff ff       	call   8556 <lodepng_chunk_next_const>
    ff17:	83 c4 10             	add    $0x10,%esp
    ff1a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    ff1d:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff21:	75 1d                	jne    ff40 <decodeGeneric+0x7a5>
    ff23:	8b 45 14             	mov    0x14(%ebp),%eax
    ff26:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff2c:	85 c0                	test   %eax,%eax
    ff2e:	0f 84 68 f9 ff ff    	je     f89c <decodeGeneric+0x101>
    ff34:	eb 0a                	jmp    ff40 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff36:	90                   	nop
    ff37:	eb 07                	jmp    ff40 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff39:	90                   	nop
    ff3a:	eb 04                	jmp    ff40 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    ff3c:	90                   	nop
    ff3d:	eb 01                	jmp    ff40 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ff3f:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
    ff40:	8b 45 14             	mov    0x14(%ebp),%eax
    ff43:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff49:	85 c0                	test   %eax,%eax
    ff4b:	75 28                	jne    ff75 <decodeGeneric+0x7da>
    ff4d:	8b 45 14             	mov    0x14(%ebp),%eax
    ff50:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
    ff56:	83 f8 03             	cmp    $0x3,%eax
    ff59:	75 1a                	jne    ff75 <decodeGeneric+0x7da>
    ff5b:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ff64:	85 c0                	test   %eax,%eax
    ff66:	75 0d                	jne    ff75 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
    ff68:	8b 45 14             	mov    0x14(%ebp),%eax
    ff6b:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
    ff72:	00 00 00 
  }

  if(!state->error) {
    ff75:	8b 45 14             	mov    0x14(%ebp),%eax
    ff78:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff7e:	85 c0                	test   %eax,%eax
    ff80:	0f 85 d2 01 00 00    	jne    10158 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
    ff86:	8b 45 14             	mov    0x14(%ebp),%eax
    ff89:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ff8f:	85 c0                	test   %eax,%eax
    ff91:	75 3a                	jne    ffcd <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ff93:	8b 45 14             	mov    0x14(%ebp),%eax
    ff96:	05 a4 00 00 00       	add    $0xa4,%eax
    ff9b:	83 ec 0c             	sub    $0xc,%esp
    ff9e:	50                   	push   %eax
    ff9f:	e8 8e 8e ff ff       	call   8e32 <lodepng_get_bpp>
    ffa4:	83 c4 10             	add    $0x10,%esp
    ffa7:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
    ffaa:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    ffad:	8b 45 10             	mov    0x10(%ebp),%eax
    ffb0:	8b 10                	mov    (%eax),%edx
    ffb2:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffb5:	8b 00                	mov    (%eax),%eax
    ffb7:	83 ec 04             	sub    $0x4,%esp
    ffba:	51                   	push   %ecx
    ffbb:	52                   	push   %edx
    ffbc:	50                   	push   %eax
    ffbd:	e8 cf 8f ff ff       	call   8f91 <lodepng_get_raw_size_idat>
    ffc2:	83 c4 10             	add    $0x10,%esp
    ffc5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ffc8:	e9 60 01 00 00       	jmp    1012d <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ffcd:	8b 45 14             	mov    0x14(%ebp),%eax
    ffd0:	05 a4 00 00 00       	add    $0xa4,%eax
    ffd5:	83 ec 0c             	sub    $0xc,%esp
    ffd8:	50                   	push   %eax
    ffd9:	e8 54 8e ff ff       	call   8e32 <lodepng_get_bpp>
    ffde:	83 c4 10             	add    $0x10,%esp
    ffe1:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
    ffe4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
    ffeb:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ffee:	8b 55 10             	mov    0x10(%ebp),%edx
    fff1:	8b 12                	mov    (%edx),%edx
    fff3:	83 c2 07             	add    $0x7,%edx
    fff6:	89 d1                	mov    %edx,%ecx
    fff8:	c1 e9 03             	shr    $0x3,%ecx
    fffb:	8b 55 0c             	mov    0xc(%ebp),%edx
    fffe:	8b 12                	mov    (%edx),%edx
   10000:	83 c2 07             	add    $0x7,%edx
   10003:	c1 ea 03             	shr    $0x3,%edx
   10006:	83 ec 04             	sub    $0x4,%esp
   10009:	50                   	push   %eax
   1000a:	51                   	push   %ecx
   1000b:	52                   	push   %edx
   1000c:	e8 80 8f ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   10011:	83 c4 10             	add    $0x10,%esp
   10014:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   10017:	8b 45 0c             	mov    0xc(%ebp),%eax
   1001a:	8b 00                	mov    (%eax),%eax
   1001c:	83 f8 04             	cmp    $0x4,%eax
   1001f:	76 2c                	jbe    1004d <decodeGeneric+0x8b2>
   10021:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10024:	8b 55 10             	mov    0x10(%ebp),%edx
   10027:	8b 12                	mov    (%edx),%edx
   10029:	83 c2 07             	add    $0x7,%edx
   1002c:	89 d1                	mov    %edx,%ecx
   1002e:	c1 e9 03             	shr    $0x3,%ecx
   10031:	8b 55 0c             	mov    0xc(%ebp),%edx
   10034:	8b 12                	mov    (%edx),%edx
   10036:	83 c2 03             	add    $0x3,%edx
   10039:	c1 ea 03             	shr    $0x3,%edx
   1003c:	83 ec 04             	sub    $0x4,%esp
   1003f:	50                   	push   %eax
   10040:	51                   	push   %ecx
   10041:	52                   	push   %edx
   10042:	e8 4a 8f ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   10047:	83 c4 10             	add    $0x10,%esp
   1004a:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1004d:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10050:	8b 55 10             	mov    0x10(%ebp),%edx
   10053:	8b 12                	mov    (%edx),%edx
   10055:	83 c2 03             	add    $0x3,%edx
   10058:	89 d1                	mov    %edx,%ecx
   1005a:	c1 e9 03             	shr    $0x3,%ecx
   1005d:	8b 55 0c             	mov    0xc(%ebp),%edx
   10060:	8b 12                	mov    (%edx),%edx
   10062:	83 c2 03             	add    $0x3,%edx
   10065:	c1 ea 02             	shr    $0x2,%edx
   10068:	83 ec 04             	sub    $0x4,%esp
   1006b:	50                   	push   %eax
   1006c:	51                   	push   %ecx
   1006d:	52                   	push   %edx
   1006e:	e8 1e 8f ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   10073:	83 c4 10             	add    $0x10,%esp
   10076:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10079:	8b 45 0c             	mov    0xc(%ebp),%eax
   1007c:	8b 00                	mov    (%eax),%eax
   1007e:	83 f8 02             	cmp    $0x2,%eax
   10081:	76 2c                	jbe    100af <decodeGeneric+0x914>
   10083:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10086:	8b 55 10             	mov    0x10(%ebp),%edx
   10089:	8b 12                	mov    (%edx),%edx
   1008b:	83 c2 03             	add    $0x3,%edx
   1008e:	89 d1                	mov    %edx,%ecx
   10090:	c1 e9 02             	shr    $0x2,%ecx
   10093:	8b 55 0c             	mov    0xc(%ebp),%edx
   10096:	8b 12                	mov    (%edx),%edx
   10098:	83 c2 01             	add    $0x1,%edx
   1009b:	c1 ea 02             	shr    $0x2,%edx
   1009e:	83 ec 04             	sub    $0x4,%esp
   100a1:	50                   	push   %eax
   100a2:	51                   	push   %ecx
   100a3:	52                   	push   %edx
   100a4:	e8 e8 8e ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   100a9:	83 c4 10             	add    $0x10,%esp
   100ac:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   100af:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100b2:	8b 55 10             	mov    0x10(%ebp),%edx
   100b5:	8b 12                	mov    (%edx),%edx
   100b7:	83 c2 01             	add    $0x1,%edx
   100ba:	89 d1                	mov    %edx,%ecx
   100bc:	c1 e9 02             	shr    $0x2,%ecx
   100bf:	8b 55 0c             	mov    0xc(%ebp),%edx
   100c2:	8b 12                	mov    (%edx),%edx
   100c4:	83 c2 01             	add    $0x1,%edx
   100c7:	d1 ea                	shr    %edx
   100c9:	83 ec 04             	sub    $0x4,%esp
   100cc:	50                   	push   %eax
   100cd:	51                   	push   %ecx
   100ce:	52                   	push   %edx
   100cf:	e8 bd 8e ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   100d4:	83 c4 10             	add    $0x10,%esp
   100d7:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   100da:	8b 45 0c             	mov    0xc(%ebp),%eax
   100dd:	8b 00                	mov    (%eax),%eax
   100df:	83 f8 01             	cmp    $0x1,%eax
   100e2:	76 27                	jbe    1010b <decodeGeneric+0x970>
   100e4:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100e7:	8b 55 10             	mov    0x10(%ebp),%edx
   100ea:	8b 12                	mov    (%edx),%edx
   100ec:	83 c2 01             	add    $0x1,%edx
   100ef:	89 d1                	mov    %edx,%ecx
   100f1:	d1 e9                	shr    %ecx
   100f3:	8b 55 0c             	mov    0xc(%ebp),%edx
   100f6:	8b 12                	mov    (%edx),%edx
   100f8:	d1 ea                	shr    %edx
   100fa:	83 ec 04             	sub    $0x4,%esp
   100fd:	50                   	push   %eax
   100fe:	51                   	push   %ecx
   100ff:	52                   	push   %edx
   10100:	e8 8c 8e ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   10105:	83 c4 10             	add    $0x10,%esp
   10108:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   1010b:	8b 55 c8             	mov    -0x38(%ebp),%edx
   1010e:	8b 45 10             	mov    0x10(%ebp),%eax
   10111:	8b 00                	mov    (%eax),%eax
   10113:	d1 e8                	shr    %eax
   10115:	89 c1                	mov    %eax,%ecx
   10117:	8b 45 0c             	mov    0xc(%ebp),%eax
   1011a:	8b 00                	mov    (%eax),%eax
   1011c:	83 ec 04             	sub    $0x4,%esp
   1011f:	52                   	push   %edx
   10120:	51                   	push   %ecx
   10121:	50                   	push   %eax
   10122:	e8 6a 8e ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   10127:	83 c4 10             	add    $0x10,%esp
   1012a:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   1012d:	8b 45 14             	mov    0x14(%ebp),%eax
   10130:	83 ec 08             	sub    $0x8,%esp
   10133:	50                   	push   %eax
   10134:	ff 75 ec             	pushl  -0x14(%ebp)
   10137:	ff 75 d8             	pushl  -0x28(%ebp)
   1013a:	ff 75 e8             	pushl  -0x18(%ebp)
   1013d:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10140:	50                   	push   %eax
   10141:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10144:	50                   	push   %eax
   10145:	e8 87 7c ff ff       	call   7dd1 <zlib_decompress>
   1014a:	83 c4 20             	add    $0x20,%esp
   1014d:	89 c2                	mov    %eax,%edx
   1014f:	8b 45 14             	mov    0x14(%ebp),%eax
   10152:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10158:	8b 45 14             	mov    0x14(%ebp),%eax
   1015b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10161:	85 c0                	test   %eax,%eax
   10163:	75 15                	jne    1017a <decodeGeneric+0x9df>
   10165:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10168:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1016b:	74 0d                	je     1017a <decodeGeneric+0x9df>
   1016d:	8b 45 14             	mov    0x14(%ebp),%eax
   10170:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10177:	00 00 00 
  lodepng_free(idat);
   1017a:	83 ec 0c             	sub    $0xc,%esp
   1017d:	ff 75 d8             	pushl  -0x28(%ebp)
   10180:	e8 b2 31 ff ff       	call   3337 <lodepng_free>
   10185:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10188:	8b 45 14             	mov    0x14(%ebp),%eax
   1018b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10191:	85 c0                	test   %eax,%eax
   10193:	75 4f                	jne    101e4 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10195:	8b 45 14             	mov    0x14(%ebp),%eax
   10198:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   1019e:	8b 45 10             	mov    0x10(%ebp),%eax
   101a1:	8b 10                	mov    (%eax),%edx
   101a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   101a6:	8b 00                	mov    (%eax),%eax
   101a8:	83 ec 04             	sub    $0x4,%esp
   101ab:	51                   	push   %ecx
   101ac:	52                   	push   %edx
   101ad:	50                   	push   %eax
   101ae:	e8 be 8d ff ff       	call   8f71 <lodepng_get_raw_size>
   101b3:	83 c4 10             	add    $0x10,%esp
   101b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   101b9:	83 ec 0c             	sub    $0xc,%esp
   101bc:	ff 75 e4             	pushl  -0x1c(%ebp)
   101bf:	e8 52 31 ff ff       	call   3316 <lodepng_malloc>
   101c4:	83 c4 10             	add    $0x10,%esp
   101c7:	89 c2                	mov    %eax,%edx
   101c9:	8b 45 08             	mov    0x8(%ebp),%eax
   101cc:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   101ce:	8b 45 08             	mov    0x8(%ebp),%eax
   101d1:	8b 00                	mov    (%eax),%eax
   101d3:	85 c0                	test   %eax,%eax
   101d5:	75 0d                	jne    101e4 <decodeGeneric+0xa49>
   101d7:	8b 45 14             	mov    0x14(%ebp),%eax
   101da:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   101e1:	00 00 00 
  }
  if(!state->error) {
   101e4:	8b 45 14             	mov    0x14(%ebp),%eax
   101e7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101ed:	85 c0                	test   %eax,%eax
   101ef:	75 4c                	jne    1023d <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   101f1:	8b 45 08             	mov    0x8(%ebp),%eax
   101f4:	8b 00                	mov    (%eax),%eax
   101f6:	83 ec 04             	sub    $0x4,%esp
   101f9:	ff 75 e4             	pushl  -0x1c(%ebp)
   101fc:	6a 00                	push   $0x0
   101fe:	50                   	push   %eax
   101ff:	e8 83 31 ff ff       	call   3387 <lodepng_memset>
   10204:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   10207:	8b 45 14             	mov    0x14(%ebp),%eax
   1020a:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   10210:	8b 45 10             	mov    0x10(%ebp),%eax
   10213:	8b 18                	mov    (%eax),%ebx
   10215:	8b 45 0c             	mov    0xc(%ebp),%eax
   10218:	8b 08                	mov    (%eax),%ecx
   1021a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1021d:	8b 45 08             	mov    0x8(%ebp),%eax
   10220:	8b 00                	mov    (%eax),%eax
   10222:	83 ec 0c             	sub    $0xc,%esp
   10225:	56                   	push   %esi
   10226:	53                   	push   %ebx
   10227:	51                   	push   %ecx
   10228:	52                   	push   %edx
   10229:	50                   	push   %eax
   1022a:	e8 05 df ff ff       	call   e134 <postProcessScanlines>
   1022f:	83 c4 20             	add    $0x20,%esp
   10232:	89 c2                	mov    %eax,%edx
   10234:	8b 45 14             	mov    0x14(%ebp),%eax
   10237:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   1023d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10240:	83 ec 0c             	sub    $0xc,%esp
   10243:	50                   	push   %eax
   10244:	e8 ee 30 ff ff       	call   3337 <lodepng_free>
   10249:	83 c4 10             	add    $0x10,%esp
   1024c:	eb 01                	jmp    1024f <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   1024e:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   1024f:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10252:	5b                   	pop    %ebx
   10253:	5e                   	pop    %esi
   10254:	5d                   	pop    %ebp
   10255:	c3                   	ret    

00010256 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10256:	55                   	push   %ebp
   10257:	89 e5                	mov    %esp,%ebp
   10259:	56                   	push   %esi
   1025a:	53                   	push   %ebx
   1025b:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   1025e:	8b 45 08             	mov    0x8(%ebp),%eax
   10261:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10267:	83 ec 08             	sub    $0x8,%esp
   1026a:	ff 75 1c             	pushl  0x1c(%ebp)
   1026d:	ff 75 18             	pushl  0x18(%ebp)
   10270:	ff 75 14             	pushl  0x14(%ebp)
   10273:	ff 75 10             	pushl  0x10(%ebp)
   10276:	ff 75 0c             	pushl  0xc(%ebp)
   10279:	ff 75 08             	pushl  0x8(%ebp)
   1027c:	e8 1a f5 ff ff       	call   f79b <decodeGeneric>
   10281:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10284:	8b 45 14             	mov    0x14(%ebp),%eax
   10287:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1028d:	85 c0                	test   %eax,%eax
   1028f:	74 0e                	je     1029f <lodepng_decode+0x49>
   10291:	8b 45 14             	mov    0x14(%ebp),%eax
   10294:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1029a:	e9 55 01 00 00       	jmp    103f4 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   1029f:	8b 45 14             	mov    0x14(%ebp),%eax
   102a2:	8b 40 24             	mov    0x24(%eax),%eax
   102a5:	85 c0                	test   %eax,%eax
   102a7:	74 20                	je     102c9 <lodepng_decode+0x73>
   102a9:	8b 45 14             	mov    0x14(%ebp),%eax
   102ac:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102b2:	8b 45 14             	mov    0x14(%ebp),%eax
   102b5:	83 c0 78             	add    $0x78,%eax
   102b8:	83 ec 08             	sub    $0x8,%esp
   102bb:	52                   	push   %edx
   102bc:	50                   	push   %eax
   102bd:	e8 56 89 ff ff       	call   8c18 <lodepng_color_mode_equal>
   102c2:	83 c4 10             	add    $0x10,%esp
   102c5:	85 c0                	test   %eax,%eax
   102c7:	74 54                	je     1031d <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   102c9:	8b 45 14             	mov    0x14(%ebp),%eax
   102cc:	8b 40 24             	mov    0x24(%eax),%eax
   102cf:	85 c0                	test   %eax,%eax
   102d1:	0f 85 13 01 00 00    	jne    103ea <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   102d7:	8b 45 14             	mov    0x14(%ebp),%eax
   102da:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102e0:	8b 45 14             	mov    0x14(%ebp),%eax
   102e3:	83 c0 78             	add    $0x78,%eax
   102e6:	83 ec 08             	sub    $0x8,%esp
   102e9:	52                   	push   %edx
   102ea:	50                   	push   %eax
   102eb:	e8 3f 88 ff ff       	call   8b2f <lodepng_color_mode_copy>
   102f0:	83 c4 10             	add    $0x10,%esp
   102f3:	89 c2                	mov    %eax,%edx
   102f5:	8b 45 14             	mov    0x14(%ebp),%eax
   102f8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   102fe:	8b 45 14             	mov    0x14(%ebp),%eax
   10301:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10307:	85 c0                	test   %eax,%eax
   10309:	0f 84 db 00 00 00    	je     103ea <lodepng_decode+0x194>
   1030f:	8b 45 14             	mov    0x14(%ebp),%eax
   10312:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10318:	e9 d7 00 00 00       	jmp    103f4 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   1031d:	8b 45 08             	mov    0x8(%ebp),%eax
   10320:	8b 00                	mov    (%eax),%eax
   10322:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10325:	8b 45 14             	mov    0x14(%ebp),%eax
   10328:	8b 40 78             	mov    0x78(%eax),%eax
   1032b:	83 f8 02             	cmp    $0x2,%eax
   1032e:	74 20                	je     10350 <lodepng_decode+0xfa>
   10330:	8b 45 14             	mov    0x14(%ebp),%eax
   10333:	8b 40 78             	mov    0x78(%eax),%eax
   10336:	83 f8 06             	cmp    $0x6,%eax
   10339:	74 15                	je     10350 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   1033b:	8b 45 14             	mov    0x14(%ebp),%eax
   1033e:	8b 40 7c             	mov    0x7c(%eax),%eax
   10341:	83 f8 08             	cmp    $0x8,%eax
   10344:	74 0a                	je     10350 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10346:	b8 38 00 00 00       	mov    $0x38,%eax
   1034b:	e9 a4 00 00 00       	jmp    103f4 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   10350:	8b 45 14             	mov    0x14(%ebp),%eax
   10353:	8d 48 78             	lea    0x78(%eax),%ecx
   10356:	8b 45 10             	mov    0x10(%ebp),%eax
   10359:	8b 10                	mov    (%eax),%edx
   1035b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1035e:	8b 00                	mov    (%eax),%eax
   10360:	83 ec 04             	sub    $0x4,%esp
   10363:	51                   	push   %ecx
   10364:	52                   	push   %edx
   10365:	50                   	push   %eax
   10366:	e8 06 8c ff ff       	call   8f71 <lodepng_get_raw_size>
   1036b:	83 c4 10             	add    $0x10,%esp
   1036e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10371:	83 ec 0c             	sub    $0xc,%esp
   10374:	ff 75 f0             	pushl  -0x10(%ebp)
   10377:	e8 9a 2f ff ff       	call   3316 <lodepng_malloc>
   1037c:	83 c4 10             	add    $0x10,%esp
   1037f:	89 c2                	mov    %eax,%edx
   10381:	8b 45 08             	mov    0x8(%ebp),%eax
   10384:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10386:	8b 45 08             	mov    0x8(%ebp),%eax
   10389:	8b 00                	mov    (%eax),%eax
   1038b:	85 c0                	test   %eax,%eax
   1038d:	75 0f                	jne    1039e <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   1038f:	8b 45 14             	mov    0x14(%ebp),%eax
   10392:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10399:	00 00 00 
   1039c:	eb 3c                	jmp    103da <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1039e:	8b 45 10             	mov    0x10(%ebp),%eax
   103a1:	8b 08                	mov    (%eax),%ecx
   103a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   103a6:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   103a8:	8b 45 14             	mov    0x14(%ebp),%eax
   103ab:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   103b1:	8b 45 14             	mov    0x14(%ebp),%eax
   103b4:	8d 58 78             	lea    0x78(%eax),%ebx
   103b7:	8b 45 08             	mov    0x8(%ebp),%eax
   103ba:	8b 00                	mov    (%eax),%eax
   103bc:	83 ec 08             	sub    $0x8,%esp
   103bf:	51                   	push   %ecx
   103c0:	52                   	push   %edx
   103c1:	56                   	push   %esi
   103c2:	53                   	push   %ebx
   103c3:	ff 75 f4             	pushl  -0xc(%ebp)
   103c6:	50                   	push   %eax
   103c7:	e8 51 b6 ff ff       	call   ba1d <lodepng_convert>
   103cc:	83 c4 20             	add    $0x20,%esp
   103cf:	89 c2                	mov    %eax,%edx
   103d1:	8b 45 14             	mov    0x14(%ebp),%eax
   103d4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   103da:	83 ec 0c             	sub    $0xc,%esp
   103dd:	ff 75 f4             	pushl  -0xc(%ebp)
   103e0:	e8 52 2f ff ff       	call   3337 <lodepng_free>
   103e5:	83 c4 10             	add    $0x10,%esp
   103e8:	eb 01                	jmp    103eb <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   103ea:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   103eb:	8b 45 14             	mov    0x14(%ebp),%eax
   103ee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   103f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
   103f7:	5b                   	pop    %ebx
   103f8:	5e                   	pop    %esi
   103f9:	5d                   	pop    %ebp
   103fa:	c3                   	ret    

000103fb <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   103fb:	55                   	push   %ebp
   103fc:	89 e5                	mov    %esp,%ebp
   103fe:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   10404:	83 ec 0c             	sub    $0xc,%esp
   10407:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1040d:	50                   	push   %eax
   1040e:	e8 d9 01 00 00       	call   105ec <lodepng_state_init>
   10413:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   10416:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10419:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   1041f:	8b 45 20             	mov    0x20(%ebp),%eax
   10422:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10428:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   1042f:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   10432:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10439:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   1043c:	83 ec 08             	sub    $0x8,%esp
   1043f:	ff 75 18             	pushl  0x18(%ebp)
   10442:	ff 75 14             	pushl  0x14(%ebp)
   10445:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1044b:	50                   	push   %eax
   1044c:	ff 75 10             	pushl  0x10(%ebp)
   1044f:	ff 75 0c             	pushl  0xc(%ebp)
   10452:	ff 75 08             	pushl  0x8(%ebp)
   10455:	e8 fc fd ff ff       	call   10256 <lodepng_decode>
   1045a:	83 c4 20             	add    $0x20,%esp
   1045d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   10460:	83 ec 0c             	sub    $0xc,%esp
   10463:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10469:	50                   	push   %eax
   1046a:	e8 d7 01 00 00       	call   10646 <lodepng_state_cleanup>
   1046f:	83 c4 10             	add    $0x10,%esp
  return error;
   10472:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10475:	c9                   	leave  
   10476:	c3                   	ret    

00010477 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10477:	55                   	push   %ebp
   10478:	89 e5                	mov    %esp,%ebp
   1047a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   1047d:	83 ec 04             	sub    $0x4,%esp
   10480:	6a 08                	push   $0x8
   10482:	6a 06                	push   $0x6
   10484:	ff 75 18             	pushl  0x18(%ebp)
   10487:	ff 75 14             	pushl  0x14(%ebp)
   1048a:	ff 75 10             	pushl  0x10(%ebp)
   1048d:	ff 75 0c             	pushl  0xc(%ebp)
   10490:	ff 75 08             	pushl  0x8(%ebp)
   10493:	e8 63 ff ff ff       	call   103fb <lodepng_decode_memory>
   10498:	83 c4 20             	add    $0x20,%esp
}
   1049b:	c9                   	leave  
   1049c:	c3                   	ret    

0001049d <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1049d:	55                   	push   %ebp
   1049e:	89 e5                	mov    %esp,%ebp
   104a0:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   104a3:	83 ec 04             	sub    $0x4,%esp
   104a6:	6a 08                	push   $0x8
   104a8:	6a 02                	push   $0x2
   104aa:	ff 75 18             	pushl  0x18(%ebp)
   104ad:	ff 75 14             	pushl  0x14(%ebp)
   104b0:	ff 75 10             	pushl  0x10(%ebp)
   104b3:	ff 75 0c             	pushl  0xc(%ebp)
   104b6:	ff 75 08             	pushl  0x8(%ebp)
   104b9:	e8 3d ff ff ff       	call   103fb <lodepng_decode_memory>
   104be:	83 c4 20             	add    $0x20,%esp
}
   104c1:	c9                   	leave  
   104c2:	c3                   	ret    

000104c3 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   104c3:	55                   	push   %ebp
   104c4:	89 e5                	mov    %esp,%ebp
   104c6:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   104c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   104d0:	8b 45 08             	mov    0x8(%ebp),%eax
   104d3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   104d9:	8b 45 10             	mov    0x10(%ebp),%eax
   104dc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   104e2:	8b 45 10             	mov    0x10(%ebp),%eax
   104e5:	8b 10                	mov    (%eax),%edx
   104e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   104ea:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   104ec:	83 ec 04             	sub    $0x4,%esp
   104ef:	ff 75 14             	pushl  0x14(%ebp)
   104f2:	8d 45 ec             	lea    -0x14(%ebp),%eax
   104f5:	50                   	push   %eax
   104f6:	8d 45 f0             	lea    -0x10(%ebp),%eax
   104f9:	50                   	push   %eax
   104fa:	e8 70 32 ff ff       	call   376f <lodepng_load_file>
   104ff:	83 c4 10             	add    $0x10,%esp
   10502:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   10505:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10509:	75 25                	jne    10530 <lodepng_decode_file+0x6d>
   1050b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1050e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10511:	83 ec 04             	sub    $0x4,%esp
   10514:	ff 75 1c             	pushl  0x1c(%ebp)
   10517:	ff 75 18             	pushl  0x18(%ebp)
   1051a:	52                   	push   %edx
   1051b:	50                   	push   %eax
   1051c:	ff 75 10             	pushl  0x10(%ebp)
   1051f:	ff 75 0c             	pushl  0xc(%ebp)
   10522:	ff 75 08             	pushl  0x8(%ebp)
   10525:	e8 d1 fe ff ff       	call   103fb <lodepng_decode_memory>
   1052a:	83 c4 20             	add    $0x20,%esp
   1052d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   10530:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10533:	83 ec 0c             	sub    $0xc,%esp
   10536:	50                   	push   %eax
   10537:	e8 fb 2d ff ff       	call   3337 <lodepng_free>
   1053c:	83 c4 10             	add    $0x10,%esp
  return error;
   1053f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10542:	c9                   	leave  
   10543:	c3                   	ret    

00010544 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10544:	55                   	push   %ebp
   10545:	89 e5                	mov    %esp,%ebp
   10547:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   1054a:	83 ec 08             	sub    $0x8,%esp
   1054d:	6a 08                	push   $0x8
   1054f:	6a 06                	push   $0x6
   10551:	ff 75 14             	pushl  0x14(%ebp)
   10554:	ff 75 10             	pushl  0x10(%ebp)
   10557:	ff 75 0c             	pushl  0xc(%ebp)
   1055a:	ff 75 08             	pushl  0x8(%ebp)
   1055d:	e8 61 ff ff ff       	call   104c3 <lodepng_decode_file>
   10562:	83 c4 20             	add    $0x20,%esp
}
   10565:	c9                   	leave  
   10566:	c3                   	ret    

00010567 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10567:	55                   	push   %ebp
   10568:	89 e5                	mov    %esp,%ebp
   1056a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   1056d:	83 ec 08             	sub    $0x8,%esp
   10570:	6a 08                	push   $0x8
   10572:	6a 02                	push   $0x2
   10574:	ff 75 14             	pushl  0x14(%ebp)
   10577:	ff 75 10             	pushl  0x10(%ebp)
   1057a:	ff 75 0c             	pushl  0xc(%ebp)
   1057d:	ff 75 08             	pushl  0x8(%ebp)
   10580:	e8 3e ff ff ff       	call   104c3 <lodepng_decode_file>
   10585:	83 c4 20             	add    $0x20,%esp
}
   10588:	c9                   	leave  
   10589:	c3                   	ret    

0001058a <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   1058a:	55                   	push   %ebp
   1058b:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   1058d:	8b 45 08             	mov    0x8(%ebp),%eax
   10590:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10597:	8b 45 08             	mov    0x8(%ebp),%eax
   1059a:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   105a1:	8b 45 08             	mov    0x8(%ebp),%eax
   105a4:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   105ab:	8b 45 08             	mov    0x8(%ebp),%eax
   105ae:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   105b5:	8b 45 08             	mov    0x8(%ebp),%eax
   105b8:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   105bf:	8b 45 08             	mov    0x8(%ebp),%eax
   105c2:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   105c9:	8b 45 08             	mov    0x8(%ebp),%eax
   105cc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   105d3:	8b 45 08             	mov    0x8(%ebp),%eax
   105d6:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   105dd:	8b 45 08             	mov    0x8(%ebp),%eax
   105e0:	50                   	push   %eax
   105e1:	e8 ff 7a ff ff       	call   80e5 <lodepng_decompress_settings_init>
   105e6:	83 c4 04             	add    $0x4,%esp
}
   105e9:	90                   	nop
   105ea:	c9                   	leave  
   105eb:	c3                   	ret    

000105ec <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   105ec:	55                   	push   %ebp
   105ed:	89 e5                	mov    %esp,%ebp
   105ef:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   105f2:	8b 45 08             	mov    0x8(%ebp),%eax
   105f5:	50                   	push   %eax
   105f6:	e8 8f ff ff ff       	call   1058a <lodepng_decoder_settings_init>
   105fb:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   105fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10601:	83 c0 38             	add    $0x38,%eax
   10604:	83 ec 0c             	sub    $0xc,%esp
   10607:	50                   	push   %eax
   10608:	e8 fc 30 00 00       	call   13709 <lodepng_encoder_settings_init>
   1060d:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   10610:	8b 45 08             	mov    0x8(%ebp),%eax
   10613:	83 c0 78             	add    $0x78,%eax
   10616:	83 ec 0c             	sub    $0xc,%esp
   10619:	50                   	push   %eax
   1061a:	e8 06 84 ff ff       	call   8a25 <lodepng_color_mode_init>
   1061f:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   10622:	8b 45 08             	mov    0x8(%ebp),%eax
   10625:	05 98 00 00 00       	add    $0x98,%eax
   1062a:	83 ec 0c             	sub    $0xc,%esp
   1062d:	50                   	push   %eax
   1062e:	e8 89 93 ff ff       	call   99bc <lodepng_info_init>
   10633:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10636:	8b 45 08             	mov    0x8(%ebp),%eax
   10639:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10640:	00 00 00 
}
   10643:	90                   	nop
   10644:	c9                   	leave  
   10645:	c3                   	ret    

00010646 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10646:	55                   	push   %ebp
   10647:	89 e5                	mov    %esp,%ebp
   10649:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   1064c:	8b 45 08             	mov    0x8(%ebp),%eax
   1064f:	83 c0 78             	add    $0x78,%eax
   10652:	83 ec 0c             	sub    $0xc,%esp
   10655:	50                   	push   %eax
   10656:	e8 bd 84 ff ff       	call   8b18 <lodepng_color_mode_cleanup>
   1065b:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   1065e:	8b 45 08             	mov    0x8(%ebp),%eax
   10661:	05 98 00 00 00       	add    $0x98,%eax
   10666:	83 ec 0c             	sub    $0xc,%esp
   10669:	50                   	push   %eax
   1066a:	e8 2e 94 ff ff       	call   9a9d <lodepng_info_cleanup>
   1066f:	83 c4 10             	add    $0x10,%esp
}
   10672:	90                   	nop
   10673:	c9                   	leave  
   10674:	c3                   	ret    

00010675 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10675:	55                   	push   %ebp
   10676:	89 e5                	mov    %esp,%ebp
   10678:	57                   	push   %edi
   10679:	56                   	push   %esi
   1067a:	53                   	push   %ebx
   1067b:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   1067e:	83 ec 0c             	sub    $0xc,%esp
   10681:	ff 75 08             	pushl  0x8(%ebp)
   10684:	e8 bd ff ff ff       	call   10646 <lodepng_state_cleanup>
   10689:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   1068c:	8b 55 08             	mov    0x8(%ebp),%edx
   1068f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10692:	89 c3                	mov    %eax,%ebx
   10694:	b8 60 00 00 00       	mov    $0x60,%eax
   10699:	89 d7                	mov    %edx,%edi
   1069b:	89 de                	mov    %ebx,%esi
   1069d:	89 c1                	mov    %eax,%ecx
   1069f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   106a1:	8b 45 08             	mov    0x8(%ebp),%eax
   106a4:	83 c0 78             	add    $0x78,%eax
   106a7:	83 ec 0c             	sub    $0xc,%esp
   106aa:	50                   	push   %eax
   106ab:	e8 75 83 ff ff       	call   8a25 <lodepng_color_mode_init>
   106b0:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   106b3:	8b 45 08             	mov    0x8(%ebp),%eax
   106b6:	05 98 00 00 00       	add    $0x98,%eax
   106bb:	83 ec 0c             	sub    $0xc,%esp
   106be:	50                   	push   %eax
   106bf:	e8 f8 92 ff ff       	call   99bc <lodepng_info_init>
   106c4:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   106c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   106ca:	8d 50 78             	lea    0x78(%eax),%edx
   106cd:	8b 45 08             	mov    0x8(%ebp),%eax
   106d0:	83 c0 78             	add    $0x78,%eax
   106d3:	83 ec 08             	sub    $0x8,%esp
   106d6:	52                   	push   %edx
   106d7:	50                   	push   %eax
   106d8:	e8 52 84 ff ff       	call   8b2f <lodepng_color_mode_copy>
   106dd:	83 c4 10             	add    $0x10,%esp
   106e0:	89 c2                	mov    %eax,%edx
   106e2:	8b 45 08             	mov    0x8(%ebp),%eax
   106e5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   106eb:	8b 45 08             	mov    0x8(%ebp),%eax
   106ee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106f4:	85 c0                	test   %eax,%eax
   106f6:	75 36                	jne    1072e <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   106f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   106fb:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   10701:	8b 45 08             	mov    0x8(%ebp),%eax
   10704:	05 98 00 00 00       	add    $0x98,%eax
   10709:	83 ec 08             	sub    $0x8,%esp
   1070c:	52                   	push   %edx
   1070d:	50                   	push   %eax
   1070e:	e8 dd 93 ff ff       	call   9af0 <lodepng_info_copy>
   10713:	83 c4 10             	add    $0x10,%esp
   10716:	89 c2                	mov    %eax,%edx
   10718:	8b 45 08             	mov    0x8(%ebp),%eax
   1071b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10721:	8b 45 08             	mov    0x8(%ebp),%eax
   10724:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1072a:	85 c0                	test   %eax,%eax
   1072c:	eb 01                	jmp    1072f <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1072e:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   1072f:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10732:	5b                   	pop    %ebx
   10733:	5e                   	pop    %esi
   10734:	5f                   	pop    %edi
   10735:	5d                   	pop    %ebp
   10736:	c3                   	ret    

00010737 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10737:	55                   	push   %ebp
   10738:	89 e5                	mov    %esp,%ebp
   1073a:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   1073d:	8b 45 08             	mov    0x8(%ebp),%eax
   10740:	8b 40 04             	mov    0x4(%eax),%eax
   10743:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10746:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   1074a:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   1074e:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10752:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10756:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   1075a:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   1075e:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10762:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10766:	8b 45 08             	mov    0x8(%ebp),%eax
   10769:	8b 40 04             	mov    0x4(%eax),%eax
   1076c:	83 c0 08             	add    $0x8,%eax
   1076f:	50                   	push   %eax
   10770:	ff 75 08             	pushl  0x8(%ebp)
   10773:	e8 f8 2d ff ff       	call   3570 <ucvector_resize>
   10778:	83 c4 08             	add    $0x8,%esp
   1077b:	85 c0                	test   %eax,%eax
   1077d:	75 07                	jne    10786 <writeSignature+0x4f>
   1077f:	b8 53 00 00 00       	mov    $0x53,%eax
   10784:	eb 1e                	jmp    107a4 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10786:	8b 45 08             	mov    0x8(%ebp),%eax
   10789:	8b 10                	mov    (%eax),%edx
   1078b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1078e:	01 c2                	add    %eax,%edx
   10790:	6a 08                	push   $0x8
   10792:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10795:	50                   	push   %eax
   10796:	52                   	push   %edx
   10797:	e8 b8 2b ff ff       	call   3354 <lodepng_memcpy>
   1079c:	83 c4 0c             	add    $0xc,%esp
  return 0;
   1079f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   107a4:	c9                   	leave  
   107a5:	c3                   	ret    

000107a6 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   107a6:	55                   	push   %ebp
   107a7:	89 e5                	mov    %esp,%ebp
   107a9:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   107ac:	68 2c a0 01 00       	push   $0x1a02c
   107b1:	6a 0d                	push   $0xd
   107b3:	ff 75 08             	pushl  0x8(%ebp)
   107b6:	8d 45 f4             	lea    -0xc(%ebp),%eax
   107b9:	50                   	push   %eax
   107ba:	e8 cf 7f ff ff       	call   878e <lodepng_chunk_init>
   107bf:	83 c4 10             	add    $0x10,%esp
   107c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
   107c5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   107c9:	74 05                	je     107d0 <addChunk_IHDR+0x2a>
   107cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   107ce:	eb 6d                	jmp    1083d <addChunk_IHDR+0x97>
  data = chunk + 8;
   107d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107d3:	83 c0 08             	add    $0x8,%eax
   107d6:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   107d9:	ff 75 0c             	pushl  0xc(%ebp)
   107dc:	ff 75 f8             	pushl  -0x8(%ebp)
   107df:	e8 f3 2e ff ff       	call   36d7 <lodepng_set32bitInt>
   107e4:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   107e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107ea:	83 c0 04             	add    $0x4,%eax
   107ed:	ff 75 10             	pushl  0x10(%ebp)
   107f0:	50                   	push   %eax
   107f1:	e8 e1 2e ff ff       	call   36d7 <lodepng_set32bitInt>
   107f6:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   107f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107fc:	83 c0 08             	add    $0x8,%eax
   107ff:	8b 55 18             	mov    0x18(%ebp),%edx
   10802:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10804:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10807:	83 c0 09             	add    $0x9,%eax
   1080a:	8b 55 14             	mov    0x14(%ebp),%edx
   1080d:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   1080f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10812:	83 c0 0a             	add    $0xa,%eax
   10815:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10818:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1081b:	83 c0 0b             	add    $0xb,%eax
   1081e:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10821:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10824:	83 c0 0c             	add    $0xc,%eax
   10827:	8b 55 1c             	mov    0x1c(%ebp),%edx
   1082a:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   1082c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1082f:	50                   	push   %eax
   10830:	e8 02 7c ff ff       	call   8437 <lodepng_chunk_generate_crc>
   10835:	83 c4 04             	add    $0x4,%esp
  return 0;
   10838:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1083d:	c9                   	leave  
   1083e:	c3                   	ret    

0001083f <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   1083f:	55                   	push   %ebp
   10840:	89 e5                	mov    %esp,%ebp
   10842:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10845:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   1084c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1084f:	8b 50 0c             	mov    0xc(%eax),%edx
   10852:	89 d0                	mov    %edx,%eax
   10854:	01 c0                	add    %eax,%eax
   10856:	01 d0                	add    %edx,%eax
   10858:	68 48 a0 01 00       	push   $0x1a048
   1085d:	50                   	push   %eax
   1085e:	ff 75 08             	pushl  0x8(%ebp)
   10861:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10864:	50                   	push   %eax
   10865:	e8 24 7f ff ff       	call   878e <lodepng_chunk_init>
   1086a:	83 c4 10             	add    $0x10,%esp
   1086d:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10870:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10874:	74 08                	je     1087e <addChunk_PLTE+0x3f>
   10876:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10879:	e9 95 00 00 00       	jmp    10913 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   1087e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10885:	eb 70                	jmp    108f7 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10887:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   1088a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1088d:	8d 50 01             	lea    0x1(%eax),%edx
   10890:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10893:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10896:	8b 45 0c             	mov    0xc(%ebp),%eax
   10899:	8b 40 08             	mov    0x8(%eax),%eax
   1089c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1089f:	c1 e1 02             	shl    $0x2,%ecx
   108a2:	01 c8                	add    %ecx,%eax
   108a4:	0f b6 00             	movzbl (%eax),%eax
   108a7:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   108a9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108af:	8d 50 01             	lea    0x1(%eax),%edx
   108b2:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108b5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   108bb:	8b 40 08             	mov    0x8(%eax),%eax
   108be:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108c1:	c1 e1 02             	shl    $0x2,%ecx
   108c4:	83 c1 01             	add    $0x1,%ecx
   108c7:	01 c8                	add    %ecx,%eax
   108c9:	0f b6 00             	movzbl (%eax),%eax
   108cc:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   108ce:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108d4:	8d 50 01             	lea    0x1(%eax),%edx
   108d7:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108da:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   108e0:	8b 40 08             	mov    0x8(%eax),%eax
   108e3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108e6:	c1 e1 02             	shl    $0x2,%ecx
   108e9:	83 c1 02             	add    $0x2,%ecx
   108ec:	01 c8                	add    %ecx,%eax
   108ee:	0f b6 00             	movzbl (%eax),%eax
   108f1:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   108f3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   108f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   108fa:	8b 40 0c             	mov    0xc(%eax),%eax
   108fd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   10900:	75 85                	jne    10887 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   10902:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10905:	50                   	push   %eax
   10906:	e8 2c 7b ff ff       	call   8437 <lodepng_chunk_generate_crc>
   1090b:	83 c4 04             	add    $0x4,%esp
  return 0;
   1090e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10913:	c9                   	leave  
   10914:	c3                   	ret    

00010915 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10915:	55                   	push   %ebp
   10916:	89 e5                	mov    %esp,%ebp
   10918:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   1091b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10922:	8b 45 0c             	mov    0xc(%ebp),%eax
   10925:	8b 00                	mov    (%eax),%eax
   10927:	83 f8 03             	cmp    $0x3,%eax
   1092a:	0f 85 ae 00 00 00    	jne    109de <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   10930:	8b 45 0c             	mov    0xc(%ebp),%eax
   10933:	8b 40 0c             	mov    0xc(%eax),%eax
   10936:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10939:	8b 45 0c             	mov    0xc(%ebp),%eax
   1093c:	8b 40 0c             	mov    0xc(%eax),%eax
   1093f:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10942:	eb 23                	jmp    10967 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10944:	8b 45 0c             	mov    0xc(%ebp),%eax
   10947:	8b 40 08             	mov    0x8(%eax),%eax
   1094a:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1094d:	83 ea 01             	sub    $0x1,%edx
   10950:	c1 e2 02             	shl    $0x2,%edx
   10953:	83 c2 03             	add    $0x3,%edx
   10956:	01 d0                	add    %edx,%eax
   10958:	0f b6 00             	movzbl (%eax),%eax
   1095b:	3c ff                	cmp    $0xff,%al
   1095d:	75 10                	jne    1096f <addChunk_tRNS+0x5a>
      --amount;
   1095f:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10963:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10967:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1096b:	75 d7                	jne    10944 <addChunk_tRNS+0x2f>
   1096d:	eb 01                	jmp    10970 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   1096f:	90                   	nop
      --amount;
    }
    if(amount) {
   10970:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10974:	0f 84 63 01 00 00    	je     10add <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   1097a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1097d:	68 4d a0 01 00       	push   $0x1a04d
   10982:	50                   	push   %eax
   10983:	ff 75 08             	pushl  0x8(%ebp)
   10986:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10989:	50                   	push   %eax
   1098a:	e8 ff 7d ff ff       	call   878e <lodepng_chunk_init>
   1098f:	83 c4 10             	add    $0x10,%esp
   10992:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10995:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10999:	74 08                	je     109a3 <addChunk_tRNS+0x8e>
   1099b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1099e:	e9 52 01 00 00       	jmp    10af5 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   109a3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   109aa:	eb 25                	jmp    109d1 <addChunk_tRNS+0xbc>
   109ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109af:	8b 55 fc             	mov    -0x4(%ebp),%edx
   109b2:	83 c2 08             	add    $0x8,%edx
   109b5:	01 c2                	add    %eax,%edx
   109b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   109ba:	8b 40 08             	mov    0x8(%eax),%eax
   109bd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   109c0:	c1 e1 02             	shl    $0x2,%ecx
   109c3:	83 c1 03             	add    $0x3,%ecx
   109c6:	01 c8                	add    %ecx,%eax
   109c8:	0f b6 00             	movzbl (%eax),%eax
   109cb:	88 02                	mov    %al,(%edx)
   109cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   109d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   109d4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   109d7:	75 d3                	jne    109ac <addChunk_tRNS+0x97>
   109d9:	e9 ff 00 00 00       	jmp    10add <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   109de:	8b 45 0c             	mov    0xc(%ebp),%eax
   109e1:	8b 00                	mov    (%eax),%eax
   109e3:	85 c0                	test   %eax,%eax
   109e5:	75 59                	jne    10a40 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   109e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   109ea:	8b 40 10             	mov    0x10(%eax),%eax
   109ed:	85 c0                	test   %eax,%eax
   109ef:	0f 84 e8 00 00 00    	je     10add <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   109f5:	68 4d a0 01 00       	push   $0x1a04d
   109fa:	6a 02                	push   $0x2
   109fc:	ff 75 08             	pushl  0x8(%ebp)
   109ff:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a02:	50                   	push   %eax
   10a03:	e8 86 7d ff ff       	call   878e <lodepng_chunk_init>
   10a08:	83 c4 10             	add    $0x10,%esp
   10a0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a0e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10a12:	74 08                	je     10a1c <addChunk_tRNS+0x107>
   10a14:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a17:	e9 d9 00 00 00       	jmp    10af5 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a1f:	8d 50 08             	lea    0x8(%eax),%edx
   10a22:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a25:	8b 40 14             	mov    0x14(%eax),%eax
   10a28:	c1 e8 08             	shr    $0x8,%eax
   10a2b:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10a2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a30:	8d 50 09             	lea    0x9(%eax),%edx
   10a33:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a36:	8b 40 14             	mov    0x14(%eax),%eax
   10a39:	88 02                	mov    %al,(%edx)
   10a3b:	e9 9d 00 00 00       	jmp    10add <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10a40:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a43:	8b 00                	mov    (%eax),%eax
   10a45:	83 f8 02             	cmp    $0x2,%eax
   10a48:	0f 85 8f 00 00 00    	jne    10add <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a51:	8b 40 10             	mov    0x10(%eax),%eax
   10a54:	85 c0                	test   %eax,%eax
   10a56:	0f 84 81 00 00 00    	je     10add <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10a5c:	68 4d a0 01 00       	push   $0x1a04d
   10a61:	6a 06                	push   $0x6
   10a63:	ff 75 08             	pushl  0x8(%ebp)
   10a66:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a69:	50                   	push   %eax
   10a6a:	e8 1f 7d ff ff       	call   878e <lodepng_chunk_init>
   10a6f:	83 c4 10             	add    $0x10,%esp
   10a72:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10a75:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10a79:	74 05                	je     10a80 <addChunk_tRNS+0x16b>
   10a7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a7e:	eb 75                	jmp    10af5 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a80:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a83:	8d 50 08             	lea    0x8(%eax),%edx
   10a86:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a89:	8b 40 14             	mov    0x14(%eax),%eax
   10a8c:	c1 e8 08             	shr    $0x8,%eax
   10a8f:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10a91:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a94:	8d 50 09             	lea    0x9(%eax),%edx
   10a97:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a9a:	8b 40 14             	mov    0x14(%eax),%eax
   10a9d:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10a9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aa2:	8d 50 0a             	lea    0xa(%eax),%edx
   10aa5:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aa8:	8b 40 18             	mov    0x18(%eax),%eax
   10aab:	c1 e8 08             	shr    $0x8,%eax
   10aae:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10ab0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ab3:	8d 50 0b             	lea    0xb(%eax),%edx
   10ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ab9:	8b 40 18             	mov    0x18(%eax),%eax
   10abc:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10abe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ac1:	8d 50 0c             	lea    0xc(%eax),%edx
   10ac4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ac7:	8b 40 1c             	mov    0x1c(%eax),%eax
   10aca:	c1 e8 08             	shr    $0x8,%eax
   10acd:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10acf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ad2:	8d 50 0d             	lea    0xd(%eax),%edx
   10ad5:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ad8:	8b 40 1c             	mov    0x1c(%eax),%eax
   10adb:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10add:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ae0:	85 c0                	test   %eax,%eax
   10ae2:	74 0c                	je     10af0 <addChunk_tRNS+0x1db>
   10ae4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ae7:	50                   	push   %eax
   10ae8:	e8 4a 79 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   10aed:	83 c4 04             	add    $0x4,%esp
  return 0;
   10af0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10af5:	c9                   	leave  
   10af6:	c3                   	ret    

00010af7 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10af7:	55                   	push   %ebp
   10af8:	89 e5                	mov    %esp,%ebp
   10afa:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10afd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10b04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10b0b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10b12:	83 ec 0c             	sub    $0xc,%esp
   10b15:	ff 75 14             	pushl  0x14(%ebp)
   10b18:	ff 75 10             	pushl  0x10(%ebp)
   10b1b:	ff 75 0c             	pushl  0xc(%ebp)
   10b1e:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10b21:	50                   	push   %eax
   10b22:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10b25:	50                   	push   %eax
   10b26:	e8 fb 74 ff ff       	call   8026 <zlib_compress>
   10b2b:	83 c4 20             	add    $0x20,%esp
   10b2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10b31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b35:	75 1b                	jne    10b52 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10b37:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b3a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10b3d:	50                   	push   %eax
   10b3e:	68 84 a0 01 00       	push   $0x1a084
   10b43:	52                   	push   %edx
   10b44:	ff 75 08             	pushl  0x8(%ebp)
   10b47:	e8 ea 7c ff ff       	call   8836 <lodepng_chunk_createv>
   10b4c:	83 c4 10             	add    $0x10,%esp
   10b4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10b52:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b55:	83 ec 0c             	sub    $0xc,%esp
   10b58:	50                   	push   %eax
   10b59:	e8 d9 27 ff ff       	call   3337 <lodepng_free>
   10b5e:	83 c4 10             	add    $0x10,%esp
  return error;
   10b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b64:	c9                   	leave  
   10b65:	c3                   	ret    

00010b66 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10b66:	55                   	push   %ebp
   10b67:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10b69:	6a 00                	push   $0x0
   10b6b:	68 89 a0 01 00       	push   $0x1a089
   10b70:	6a 00                	push   $0x0
   10b72:	ff 75 08             	pushl  0x8(%ebp)
   10b75:	e8 bc 7c ff ff       	call   8836 <lodepng_chunk_createv>
   10b7a:	83 c4 10             	add    $0x10,%esp
}
   10b7d:	c9                   	leave  
   10b7e:	c3                   	ret    

00010b7f <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10b7f:	55                   	push   %ebp
   10b80:	89 e5                	mov    %esp,%ebp
   10b82:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10b85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10b8c:	ff 75 0c             	pushl  0xc(%ebp)
   10b8f:	e8 1e 28 ff ff       	call   33b2 <lodepng_strlen>
   10b94:	83 c4 04             	add    $0x4,%esp
   10b97:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10b9a:	ff 75 10             	pushl  0x10(%ebp)
   10b9d:	e8 10 28 ff ff       	call   33b2 <lodepng_strlen>
   10ba2:	83 c4 04             	add    $0x4,%esp
   10ba5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10ba8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10bab:	8d 50 01             	lea    0x1(%eax),%edx
   10bae:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bb1:	01 d0                	add    %edx,%eax
   10bb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10bb6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10bba:	7e 06                	jle    10bc2 <addChunk_tEXt+0x43>
   10bbc:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10bc0:	7e 07                	jle    10bc9 <addChunk_tEXt+0x4a>
   10bc2:	b8 59 00 00 00       	mov    $0x59,%eax
   10bc7:	eb 74                	jmp    10c3d <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10bc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10bcc:	68 57 a0 01 00       	push   $0x1a057
   10bd1:	50                   	push   %eax
   10bd2:	ff 75 08             	pushl  0x8(%ebp)
   10bd5:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10bd8:	50                   	push   %eax
   10bd9:	e8 b0 7b ff ff       	call   878e <lodepng_chunk_init>
   10bde:	83 c4 10             	add    $0x10,%esp
   10be1:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10be4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10be8:	74 05                	je     10bef <addChunk_tEXt+0x70>
   10bea:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bed:	eb 4e                	jmp    10c3d <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10bef:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10bf2:	83 c0 08             	add    $0x8,%eax
   10bf5:	ff 75 fc             	pushl  -0x4(%ebp)
   10bf8:	ff 75 0c             	pushl  0xc(%ebp)
   10bfb:	50                   	push   %eax
   10bfc:	e8 53 27 ff ff       	call   3354 <lodepng_memcpy>
   10c01:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10c04:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c07:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c0a:	83 c2 08             	add    $0x8,%edx
   10c0d:	01 d0                	add    %edx,%eax
   10c0f:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10c12:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c15:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c18:	83 c2 09             	add    $0x9,%edx
   10c1b:	01 d0                	add    %edx,%eax
   10c1d:	ff 75 f8             	pushl  -0x8(%ebp)
   10c20:	ff 75 10             	pushl  0x10(%ebp)
   10c23:	50                   	push   %eax
   10c24:	e8 2b 27 ff ff       	call   3354 <lodepng_memcpy>
   10c29:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10c2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c2f:	50                   	push   %eax
   10c30:	e8 02 78 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   10c35:	83 c4 04             	add    $0x4,%esp
  return 0;
   10c38:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c3d:	c9                   	leave  
   10c3e:	c3                   	ret    

00010c3f <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10c3f:	55                   	push   %ebp
   10c40:	89 e5                	mov    %esp,%ebp
   10c42:	53                   	push   %ebx
   10c43:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10c46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10c4d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10c54:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10c5b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10c62:	ff 75 10             	pushl  0x10(%ebp)
   10c65:	e8 48 27 ff ff       	call   33b2 <lodepng_strlen>
   10c6a:	83 c4 04             	add    $0x4,%esp
   10c6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10c70:	ff 75 0c             	pushl  0xc(%ebp)
   10c73:	e8 3a 27 ff ff       	call   33b2 <lodepng_strlen>
   10c78:	83 c4 04             	add    $0x4,%esp
   10c7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10c7e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10c82:	7e 06                	jle    10c8a <addChunk_zTXt+0x4b>
   10c84:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10c88:	7e 0a                	jle    10c94 <addChunk_zTXt+0x55>
   10c8a:	b8 59 00 00 00       	mov    $0x59,%eax
   10c8f:	e9 c8 00 00 00       	jmp    10d5c <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10c94:	83 ec 0c             	sub    $0xc,%esp
   10c97:	ff 75 14             	pushl  0x14(%ebp)
   10c9a:	ff 75 f0             	pushl  -0x10(%ebp)
   10c9d:	ff 75 10             	pushl  0x10(%ebp)
   10ca0:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10ca3:	50                   	push   %eax
   10ca4:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10ca7:	50                   	push   %eax
   10ca8:	e8 79 73 ff ff       	call   8026 <zlib_compress>
   10cad:	83 c4 20             	add    $0x20,%esp
   10cb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10cb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10cb7:	75 29                	jne    10ce2 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10cb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cbc:	8d 50 02             	lea    0x2(%eax),%edx
   10cbf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10cc2:	01 d0                	add    %edx,%eax
   10cc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10cc7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10cca:	68 5c a0 01 00       	push   $0x1a05c
   10ccf:	50                   	push   %eax
   10cd0:	ff 75 08             	pushl  0x8(%ebp)
   10cd3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10cd6:	50                   	push   %eax
   10cd7:	e8 b2 7a ff ff       	call   878e <lodepng_chunk_init>
   10cdc:	83 c4 10             	add    $0x10,%esp
   10cdf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10ce2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ce6:	75 62                	jne    10d4a <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10ce8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ceb:	83 c0 08             	add    $0x8,%eax
   10cee:	83 ec 04             	sub    $0x4,%esp
   10cf1:	ff 75 ec             	pushl  -0x14(%ebp)
   10cf4:	ff 75 0c             	pushl  0xc(%ebp)
   10cf7:	50                   	push   %eax
   10cf8:	e8 57 26 ff ff       	call   3354 <lodepng_memcpy>
   10cfd:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10d00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d03:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d06:	83 c2 08             	add    $0x8,%edx
   10d09:	01 d0                	add    %edx,%eax
   10d0b:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10d0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d11:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d14:	83 c2 09             	add    $0x9,%edx
   10d17:	01 d0                	add    %edx,%eax
   10d19:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10d1c:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10d1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d22:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10d25:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10d28:	83 c3 0a             	add    $0xa,%ebx
   10d2b:	01 d9                	add    %ebx,%ecx
   10d2d:	83 ec 04             	sub    $0x4,%esp
   10d30:	52                   	push   %edx
   10d31:	50                   	push   %eax
   10d32:	51                   	push   %ecx
   10d33:	e8 1c 26 ff ff       	call   3354 <lodepng_memcpy>
   10d38:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10d3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d3e:	83 ec 0c             	sub    $0xc,%esp
   10d41:	50                   	push   %eax
   10d42:	e8 f0 76 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   10d47:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10d4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d4d:	83 ec 0c             	sub    $0xc,%esp
   10d50:	50                   	push   %eax
   10d51:	e8 e1 25 ff ff       	call   3337 <lodepng_free>
   10d56:	83 c4 10             	add    $0x10,%esp
  return error;
   10d59:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10d5c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10d5f:	c9                   	leave  
   10d60:	c3                   	ret    

00010d61 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10d61:	55                   	push   %ebp
   10d62:	89 e5                	mov    %esp,%ebp
   10d64:	53                   	push   %ebx
   10d65:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10d68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10d6f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10d76:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10d7d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10d84:	ff 75 1c             	pushl  0x1c(%ebp)
   10d87:	e8 26 26 ff ff       	call   33b2 <lodepng_strlen>
   10d8c:	83 c4 04             	add    $0x4,%esp
   10d8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10d92:	ff 75 10             	pushl  0x10(%ebp)
   10d95:	e8 18 26 ff ff       	call   33b2 <lodepng_strlen>
   10d9a:	83 c4 04             	add    $0x4,%esp
   10d9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10da0:	ff 75 14             	pushl  0x14(%ebp)
   10da3:	e8 0a 26 ff ff       	call   33b2 <lodepng_strlen>
   10da8:	83 c4 04             	add    $0x4,%esp
   10dab:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10dae:	ff 75 18             	pushl  0x18(%ebp)
   10db1:	e8 fc 25 ff ff       	call   33b2 <lodepng_strlen>
   10db6:	83 c4 04             	add    $0x4,%esp
   10db9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10dbc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10dc0:	7e 06                	jle    10dc8 <addChunk_iTXt+0x67>
   10dc2:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10dc6:	7e 0a                	jle    10dd2 <addChunk_iTXt+0x71>
   10dc8:	b8 59 00 00 00       	mov    $0x59,%eax
   10dcd:	e9 9a 01 00 00       	jmp    10f6c <addChunk_iTXt+0x20b>

  if(compress) {
   10dd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10dd6:	74 1f                	je     10df7 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10dd8:	83 ec 0c             	sub    $0xc,%esp
   10ddb:	ff 75 20             	pushl  0x20(%ebp)
   10dde:	ff 75 f0             	pushl  -0x10(%ebp)
   10de1:	ff 75 1c             	pushl  0x1c(%ebp)
   10de4:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10de7:	50                   	push   %eax
   10de8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10deb:	50                   	push   %eax
   10dec:	e8 35 72 ff ff       	call   8026 <zlib_compress>
   10df1:	83 c4 20             	add    $0x20,%esp
   10df4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10df7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10dfb:	75 44                	jne    10e41 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10dfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e00:	8d 50 03             	lea    0x3(%eax),%edx
   10e03:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e06:	01 d0                	add    %edx,%eax
   10e08:	8d 50 01             	lea    0x1(%eax),%edx
   10e0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e0e:	01 d0                	add    %edx,%eax
   10e10:	8d 50 01             	lea    0x1(%eax),%edx
   10e13:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e17:	74 05                	je     10e1e <addChunk_iTXt+0xbd>
   10e19:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10e1c:	eb 03                	jmp    10e21 <addChunk_iTXt+0xc0>
   10e1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e21:	01 d0                	add    %edx,%eax
   10e23:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10e26:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10e29:	68 61 a0 01 00       	push   $0x1a061
   10e2e:	50                   	push   %eax
   10e2f:	ff 75 08             	pushl  0x8(%ebp)
   10e32:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10e35:	50                   	push   %eax
   10e36:	e8 53 79 ff ff       	call   878e <lodepng_chunk_init>
   10e3b:	83 c4 10             	add    $0x10,%esp
   10e3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10e41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e45:	0f 85 0f 01 00 00    	jne    10f5a <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10e4b:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10e52:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10e55:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e58:	01 d0                	add    %edx,%eax
   10e5a:	83 ec 04             	sub    $0x4,%esp
   10e5d:	ff 75 ec             	pushl  -0x14(%ebp)
   10e60:	ff 75 10             	pushl  0x10(%ebp)
   10e63:	50                   	push   %eax
   10e64:	e8 eb 24 ff ff       	call   3354 <lodepng_memcpy>
   10e69:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10e6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e6f:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10e72:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e75:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e78:	8d 50 01             	lea    0x1(%eax),%edx
   10e7b:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e7e:	01 c8                	add    %ecx,%eax
   10e80:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10e83:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e86:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e89:	8d 50 01             	lea    0x1(%eax),%edx
   10e8c:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e8f:	01 c8                	add    %ecx,%eax
   10e91:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e95:	0f 95 c2             	setne  %dl
   10e98:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10e9a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ea0:	8d 50 01             	lea    0x1(%eax),%edx
   10ea3:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ea6:	01 c8                	add    %ecx,%eax
   10ea8:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10eab:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10eae:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10eb1:	01 d0                	add    %edx,%eax
   10eb3:	83 ec 04             	sub    $0x4,%esp
   10eb6:	ff 75 e8             	pushl  -0x18(%ebp)
   10eb9:	ff 75 14             	pushl  0x14(%ebp)
   10ebc:	50                   	push   %eax
   10ebd:	e8 92 24 ff ff       	call   3354 <lodepng_memcpy>
   10ec2:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10ec5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ec8:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10ecb:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10ece:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ed1:	8d 50 01             	lea    0x1(%eax),%edx
   10ed4:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ed7:	01 c8                	add    %ecx,%eax
   10ed9:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10edc:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10edf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ee2:	01 d0                	add    %edx,%eax
   10ee4:	83 ec 04             	sub    $0x4,%esp
   10ee7:	ff 75 e4             	pushl  -0x1c(%ebp)
   10eea:	ff 75 18             	pushl  0x18(%ebp)
   10eed:	50                   	push   %eax
   10eee:	e8 61 24 ff ff       	call   3354 <lodepng_memcpy>
   10ef3:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10ef6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ef9:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10efc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10eff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f02:	8d 50 01             	lea    0x1(%eax),%edx
   10f05:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f08:	01 c8                	add    %ecx,%eax
   10f0a:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10f0d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f11:	74 1e                	je     10f31 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   10f13:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10f16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f19:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   10f1c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10f1f:	01 d9                	add    %ebx,%ecx
   10f21:	83 ec 04             	sub    $0x4,%esp
   10f24:	52                   	push   %edx
   10f25:	50                   	push   %eax
   10f26:	51                   	push   %ecx
   10f27:	e8 28 24 ff ff       	call   3354 <lodepng_memcpy>
   10f2c:	83 c4 10             	add    $0x10,%esp
   10f2f:	eb 1a                	jmp    10f4b <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   10f31:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f34:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f37:	01 d0                	add    %edx,%eax
   10f39:	83 ec 04             	sub    $0x4,%esp
   10f3c:	ff 75 f0             	pushl  -0x10(%ebp)
   10f3f:	ff 75 1c             	pushl  0x1c(%ebp)
   10f42:	50                   	push   %eax
   10f43:	e8 0c 24 ff ff       	call   3354 <lodepng_memcpy>
   10f48:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   10f4b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10f4e:	83 ec 0c             	sub    $0xc,%esp
   10f51:	50                   	push   %eax
   10f52:	e8 e0 74 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   10f57:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10f5a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f5d:	83 ec 0c             	sub    $0xc,%esp
   10f60:	50                   	push   %eax
   10f61:	e8 d1 23 ff ff       	call   3337 <lodepng_free>
   10f66:	83 c4 10             	add    $0x10,%esp
  return error;
   10f69:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10f6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10f6f:	c9                   	leave  
   10f70:	c3                   	ret    

00010f71 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   10f71:	55                   	push   %ebp
   10f72:	89 e5                	mov    %esp,%ebp
   10f74:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   10f77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   10f7e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f81:	8b 40 0c             	mov    0xc(%eax),%eax
   10f84:	85 c0                	test   %eax,%eax
   10f86:	74 0b                	je     10f93 <addChunk_bKGD+0x22>
   10f88:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f8b:	8b 40 0c             	mov    0xc(%eax),%eax
   10f8e:	83 f8 04             	cmp    $0x4,%eax
   10f91:	75 4b                	jne    10fde <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   10f93:	68 52 a0 01 00       	push   $0x1a052
   10f98:	6a 02                	push   $0x2
   10f9a:	ff 75 08             	pushl  0x8(%ebp)
   10f9d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10fa0:	50                   	push   %eax
   10fa1:	e8 e8 77 ff ff       	call   878e <lodepng_chunk_init>
   10fa6:	83 c4 10             	add    $0x10,%esp
   10fa9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10fac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10fb0:	74 08                	je     10fba <addChunk_bKGD+0x49>
   10fb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fb5:	e9 19 01 00 00       	jmp    110d3 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   10fba:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fbd:	8d 50 08             	lea    0x8(%eax),%edx
   10fc0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fc3:	8b 40 30             	mov    0x30(%eax),%eax
   10fc6:	c1 e8 08             	shr    $0x8,%eax
   10fc9:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   10fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fce:	8d 50 09             	lea    0x9(%eax),%edx
   10fd1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fd4:	8b 40 30             	mov    0x30(%eax),%eax
   10fd7:	88 02                	mov    %al,(%edx)
   10fd9:	e9 dd 00 00 00       	jmp    110bb <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   10fde:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fe1:	8b 40 0c             	mov    0xc(%eax),%eax
   10fe4:	83 f8 02             	cmp    $0x2,%eax
   10fe7:	74 0f                	je     10ff8 <addChunk_bKGD+0x87>
   10fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fec:	8b 40 0c             	mov    0xc(%eax),%eax
   10fef:	83 f8 06             	cmp    $0x6,%eax
   10ff2:	0f 85 86 00 00 00    	jne    1107e <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   10ff8:	68 52 a0 01 00       	push   $0x1a052
   10ffd:	6a 06                	push   $0x6
   10fff:	ff 75 08             	pushl  0x8(%ebp)
   11002:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11005:	50                   	push   %eax
   11006:	e8 83 77 ff ff       	call   878e <lodepng_chunk_init>
   1100b:	83 c4 10             	add    $0x10,%esp
   1100e:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11011:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11015:	74 08                	je     1101f <addChunk_bKGD+0xae>
   11017:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1101a:	e9 b4 00 00 00       	jmp    110d3 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1101f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11022:	8d 50 08             	lea    0x8(%eax),%edx
   11025:	8b 45 0c             	mov    0xc(%ebp),%eax
   11028:	8b 40 30             	mov    0x30(%eax),%eax
   1102b:	c1 e8 08             	shr    $0x8,%eax
   1102e:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11030:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11033:	8d 50 09             	lea    0x9(%eax),%edx
   11036:	8b 45 0c             	mov    0xc(%ebp),%eax
   11039:	8b 40 30             	mov    0x30(%eax),%eax
   1103c:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   1103e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11041:	8d 50 0a             	lea    0xa(%eax),%edx
   11044:	8b 45 0c             	mov    0xc(%ebp),%eax
   11047:	8b 40 34             	mov    0x34(%eax),%eax
   1104a:	c1 e8 08             	shr    $0x8,%eax
   1104d:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   1104f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11052:	8d 50 0b             	lea    0xb(%eax),%edx
   11055:	8b 45 0c             	mov    0xc(%ebp),%eax
   11058:	8b 40 34             	mov    0x34(%eax),%eax
   1105b:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1105d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11060:	8d 50 0c             	lea    0xc(%eax),%edx
   11063:	8b 45 0c             	mov    0xc(%ebp),%eax
   11066:	8b 40 38             	mov    0x38(%eax),%eax
   11069:	c1 e8 08             	shr    $0x8,%eax
   1106c:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   1106e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11071:	8d 50 0d             	lea    0xd(%eax),%edx
   11074:	8b 45 0c             	mov    0xc(%ebp),%eax
   11077:	8b 40 38             	mov    0x38(%eax),%eax
   1107a:	88 02                	mov    %al,(%edx)
   1107c:	eb 3d                	jmp    110bb <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1107e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11081:	8b 40 0c             	mov    0xc(%eax),%eax
   11084:	83 f8 03             	cmp    $0x3,%eax
   11087:	75 32                	jne    110bb <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11089:	68 52 a0 01 00       	push   $0x1a052
   1108e:	6a 01                	push   $0x1
   11090:	ff 75 08             	pushl  0x8(%ebp)
   11093:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11096:	50                   	push   %eax
   11097:	e8 f2 76 ff ff       	call   878e <lodepng_chunk_init>
   1109c:	83 c4 10             	add    $0x10,%esp
   1109f:	89 45 fc             	mov    %eax,-0x4(%ebp)
   110a2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   110a6:	74 05                	je     110ad <addChunk_bKGD+0x13c>
   110a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   110ab:	eb 26                	jmp    110d3 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   110ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110b0:	8d 50 08             	lea    0x8(%eax),%edx
   110b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   110b6:	8b 40 30             	mov    0x30(%eax),%eax
   110b9:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   110bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110be:	85 c0                	test   %eax,%eax
   110c0:	74 0c                	je     110ce <addChunk_bKGD+0x15d>
   110c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110c5:	50                   	push   %eax
   110c6:	e8 6c 73 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   110cb:	83 c4 04             	add    $0x4,%esp
  return 0;
   110ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
   110d3:	c9                   	leave  
   110d4:	c3                   	ret    

000110d5 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   110d5:	55                   	push   %ebp
   110d6:	89 e5                	mov    %esp,%ebp
   110d8:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   110db:	68 66 a0 01 00       	push   $0x1a066
   110e0:	6a 07                	push   $0x7
   110e2:	ff 75 08             	pushl  0x8(%ebp)
   110e5:	8d 45 f8             	lea    -0x8(%ebp),%eax
   110e8:	50                   	push   %eax
   110e9:	e8 a0 76 ff ff       	call   878e <lodepng_chunk_init>
   110ee:	83 c4 10             	add    $0x10,%esp
   110f1:	89 45 fc             	mov    %eax,-0x4(%ebp)
   110f4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   110f8:	74 05                	je     110ff <addChunk_tIME+0x2a>
   110fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   110fd:	eb 74                	jmp    11173 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   110ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11102:	8d 50 08             	lea    0x8(%eax),%edx
   11105:	8b 45 0c             	mov    0xc(%ebp),%eax
   11108:	8b 00                	mov    (%eax),%eax
   1110a:	c1 e8 08             	shr    $0x8,%eax
   1110d:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   1110f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11112:	8d 50 09             	lea    0x9(%eax),%edx
   11115:	8b 45 0c             	mov    0xc(%ebp),%eax
   11118:	8b 00                	mov    (%eax),%eax
   1111a:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   1111c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1111f:	8d 50 0a             	lea    0xa(%eax),%edx
   11122:	8b 45 0c             	mov    0xc(%ebp),%eax
   11125:	8b 40 04             	mov    0x4(%eax),%eax
   11128:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   1112a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1112d:	8d 50 0b             	lea    0xb(%eax),%edx
   11130:	8b 45 0c             	mov    0xc(%ebp),%eax
   11133:	8b 40 08             	mov    0x8(%eax),%eax
   11136:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11138:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1113b:	8d 50 0c             	lea    0xc(%eax),%edx
   1113e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11141:	8b 40 0c             	mov    0xc(%eax),%eax
   11144:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11146:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11149:	8d 50 0d             	lea    0xd(%eax),%edx
   1114c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1114f:	8b 40 10             	mov    0x10(%eax),%eax
   11152:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11154:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11157:	8d 50 0e             	lea    0xe(%eax),%edx
   1115a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1115d:	8b 40 14             	mov    0x14(%eax),%eax
   11160:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11162:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11165:	50                   	push   %eax
   11166:	e8 cc 72 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   1116b:	83 c4 04             	add    $0x4,%esp
  return 0;
   1116e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11173:	c9                   	leave  
   11174:	c3                   	ret    

00011175 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11175:	55                   	push   %ebp
   11176:	89 e5                	mov    %esp,%ebp
   11178:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   1117b:	68 6b a0 01 00       	push   $0x1a06b
   11180:	6a 09                	push   $0x9
   11182:	ff 75 08             	pushl  0x8(%ebp)
   11185:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11188:	50                   	push   %eax
   11189:	e8 00 76 ff ff       	call   878e <lodepng_chunk_init>
   1118e:	83 c4 10             	add    $0x10,%esp
   11191:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11194:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11198:	74 05                	je     1119f <addChunk_pHYs+0x2a>
   1119a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1119d:	eb 51                	jmp    111f0 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   1119f:	8b 45 0c             	mov    0xc(%ebp),%eax
   111a2:	8b 40 7c             	mov    0x7c(%eax),%eax
   111a5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111a8:	83 c2 08             	add    $0x8,%edx
   111ab:	50                   	push   %eax
   111ac:	52                   	push   %edx
   111ad:	e8 25 25 ff ff       	call   36d7 <lodepng_set32bitInt>
   111b2:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   111b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   111b8:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   111be:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111c1:	83 c2 0c             	add    $0xc,%edx
   111c4:	50                   	push   %eax
   111c5:	52                   	push   %edx
   111c6:	e8 0c 25 ff ff       	call   36d7 <lodepng_set32bitInt>
   111cb:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   111ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111d1:	8d 50 10             	lea    0x10(%eax),%edx
   111d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   111d7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   111dd:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   111df:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111e2:	50                   	push   %eax
   111e3:	e8 4f 72 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   111e8:	83 c4 04             	add    $0x4,%esp
  return 0;
   111eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   111f0:	c9                   	leave  
   111f1:	c3                   	ret    

000111f2 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   111f2:	55                   	push   %ebp
   111f3:	89 e5                	mov    %esp,%ebp
   111f5:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   111f8:	68 70 a0 01 00       	push   $0x1a070
   111fd:	6a 04                	push   $0x4
   111ff:	ff 75 08             	pushl  0x8(%ebp)
   11202:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11205:	50                   	push   %eax
   11206:	e8 83 75 ff ff       	call   878e <lodepng_chunk_init>
   1120b:	83 c4 10             	add    $0x10,%esp
   1120e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11211:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11215:	74 05                	je     1121c <addChunk_gAMA+0x2a>
   11217:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1121a:	eb 2a                	jmp    11246 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   1121c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1121f:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11225:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11228:	83 c2 08             	add    $0x8,%edx
   1122b:	50                   	push   %eax
   1122c:	52                   	push   %edx
   1122d:	e8 a5 24 ff ff       	call   36d7 <lodepng_set32bitInt>
   11232:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11235:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11238:	50                   	push   %eax
   11239:	e8 f9 71 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   1123e:	83 c4 04             	add    $0x4,%esp
  return 0;
   11241:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11246:	c9                   	leave  
   11247:	c3                   	ret    

00011248 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11248:	55                   	push   %ebp
   11249:	89 e5                	mov    %esp,%ebp
   1124b:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   1124e:	68 75 a0 01 00       	push   $0x1a075
   11253:	6a 20                	push   $0x20
   11255:	ff 75 08             	pushl  0x8(%ebp)
   11258:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1125b:	50                   	push   %eax
   1125c:	e8 2d 75 ff ff       	call   878e <lodepng_chunk_init>
   11261:	83 c4 10             	add    $0x10,%esp
   11264:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11267:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1126b:	74 08                	je     11275 <addChunk_cHRM+0x2d>
   1126d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11270:	e9 d9 00 00 00       	jmp    1134e <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11275:	8b 45 0c             	mov    0xc(%ebp),%eax
   11278:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1127e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11281:	83 c2 08             	add    $0x8,%edx
   11284:	50                   	push   %eax
   11285:	52                   	push   %edx
   11286:	e8 4c 24 ff ff       	call   36d7 <lodepng_set32bitInt>
   1128b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1128e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11291:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11297:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1129a:	83 c2 0c             	add    $0xc,%edx
   1129d:	50                   	push   %eax
   1129e:	52                   	push   %edx
   1129f:	e8 33 24 ff ff       	call   36d7 <lodepng_set32bitInt>
   112a4:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   112a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   112aa:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   112b0:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112b3:	83 c2 10             	add    $0x10,%edx
   112b6:	50                   	push   %eax
   112b7:	52                   	push   %edx
   112b8:	e8 1a 24 ff ff       	call   36d7 <lodepng_set32bitInt>
   112bd:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   112c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   112c3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   112c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112cc:	83 c2 14             	add    $0x14,%edx
   112cf:	50                   	push   %eax
   112d0:	52                   	push   %edx
   112d1:	e8 01 24 ff ff       	call   36d7 <lodepng_set32bitInt>
   112d6:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   112d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   112dc:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   112e2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112e5:	83 c2 18             	add    $0x18,%edx
   112e8:	50                   	push   %eax
   112e9:	52                   	push   %edx
   112ea:	e8 e8 23 ff ff       	call   36d7 <lodepng_set32bitInt>
   112ef:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   112f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   112f5:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   112fb:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112fe:	83 c2 1c             	add    $0x1c,%edx
   11301:	50                   	push   %eax
   11302:	52                   	push   %edx
   11303:	e8 cf 23 ff ff       	call   36d7 <lodepng_set32bitInt>
   11308:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   1130b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1130e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11314:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11317:	83 c2 20             	add    $0x20,%edx
   1131a:	50                   	push   %eax
   1131b:	52                   	push   %edx
   1131c:	e8 b6 23 ff ff       	call   36d7 <lodepng_set32bitInt>
   11321:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   11324:	8b 45 0c             	mov    0xc(%ebp),%eax
   11327:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   1132d:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11330:	83 c2 24             	add    $0x24,%edx
   11333:	50                   	push   %eax
   11334:	52                   	push   %edx
   11335:	e8 9d 23 ff ff       	call   36d7 <lodepng_set32bitInt>
   1133a:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1133d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11340:	50                   	push   %eax
   11341:	e8 f1 70 ff ff       	call   8437 <lodepng_chunk_generate_crc>
   11346:	83 c4 04             	add    $0x4,%esp
  return 0;
   11349:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1134e:	c9                   	leave  
   1134f:	c3                   	ret    

00011350 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   11350:	55                   	push   %ebp
   11351:	89 e5                	mov    %esp,%ebp
   11353:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11356:	8b 45 0c             	mov    0xc(%ebp),%eax
   11359:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1135f:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11362:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11365:	50                   	push   %eax
   11366:	68 7a a0 01 00       	push   $0x1a07a
   1136b:	6a 01                	push   $0x1
   1136d:	ff 75 08             	pushl  0x8(%ebp)
   11370:	e8 c1 74 ff ff       	call   8836 <lodepng_chunk_createv>
   11375:	83 c4 10             	add    $0x10,%esp
}
   11378:	c9                   	leave  
   11379:	c3                   	ret    

0001137a <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   1137a:	55                   	push   %ebp
   1137b:	89 e5                	mov    %esp,%ebp
   1137d:	53                   	push   %ebx
   1137e:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11381:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11388:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   1138f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11396:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   1139d:	8b 45 0c             	mov    0xc(%ebp),%eax
   113a0:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   113a6:	50                   	push   %eax
   113a7:	e8 06 20 ff ff       	call   33b2 <lodepng_strlen>
   113ac:	83 c4 04             	add    $0x4,%esp
   113af:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   113b2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   113b6:	7e 06                	jle    113be <addChunk_iCCP+0x44>
   113b8:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   113bc:	7e 0a                	jle    113c8 <addChunk_iCCP+0x4e>
   113be:	b8 59 00 00 00       	mov    $0x59,%eax
   113c3:	e9 df 00 00 00       	jmp    114a7 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   113cb:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113d1:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d6:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113dc:	83 ec 0c             	sub    $0xc,%esp
   113df:	ff 75 10             	pushl  0x10(%ebp)
   113e2:	52                   	push   %edx
   113e3:	50                   	push   %eax
   113e4:	8d 45 e0             	lea    -0x20(%ebp),%eax
   113e7:	50                   	push   %eax
   113e8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   113eb:	50                   	push   %eax
   113ec:	e8 35 6c ff ff       	call   8026 <zlib_compress>
   113f1:	83 c4 20             	add    $0x20,%esp
   113f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   113f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   113fb:	75 29                	jne    11426 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   113fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11400:	8d 50 02             	lea    0x2(%eax),%edx
   11403:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11406:	01 d0                	add    %edx,%eax
   11408:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   1140b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1140e:	68 7f a0 01 00       	push   $0x1a07f
   11413:	50                   	push   %eax
   11414:	ff 75 08             	pushl  0x8(%ebp)
   11417:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1141a:	50                   	push   %eax
   1141b:	e8 6e 73 ff ff       	call   878e <lodepng_chunk_init>
   11420:	83 c4 10             	add    $0x10,%esp
   11423:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11426:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1142a:	75 69                	jne    11495 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   1142c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1142f:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11435:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11438:	83 c2 08             	add    $0x8,%edx
   1143b:	83 ec 04             	sub    $0x4,%esp
   1143e:	ff 75 f0             	pushl  -0x10(%ebp)
   11441:	50                   	push   %eax
   11442:	52                   	push   %edx
   11443:	e8 0c 1f ff ff       	call   3354 <lodepng_memcpy>
   11448:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   1144b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1144e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11451:	83 c2 08             	add    $0x8,%edx
   11454:	01 d0                	add    %edx,%eax
   11456:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11459:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1145c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1145f:	83 c2 09             	add    $0x9,%edx
   11462:	01 d0                	add    %edx,%eax
   11464:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11467:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1146a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1146d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   11470:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11473:	83 c3 0a             	add    $0xa,%ebx
   11476:	01 d9                	add    %ebx,%ecx
   11478:	83 ec 04             	sub    $0x4,%esp
   1147b:	52                   	push   %edx
   1147c:	50                   	push   %eax
   1147d:	51                   	push   %ecx
   1147e:	e8 d1 1e ff ff       	call   3354 <lodepng_memcpy>
   11483:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11486:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11489:	83 ec 0c             	sub    $0xc,%esp
   1148c:	50                   	push   %eax
   1148d:	e8 a5 6f ff ff       	call   8437 <lodepng_chunk_generate_crc>
   11492:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11495:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11498:	83 ec 0c             	sub    $0xc,%esp
   1149b:	50                   	push   %eax
   1149c:	e8 96 1e ff ff       	call   3337 <lodepng_free>
   114a1:	83 c4 10             	add    $0x10,%esp
  return error;
   114a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   114a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   114aa:	c9                   	leave  
   114ab:	c3                   	ret    

000114ac <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   114ac:	55                   	push   %ebp
   114ad:	89 e5                	mov    %esp,%ebp
   114af:	56                   	push   %esi
   114b0:	53                   	push   %ebx
   114b1:	83 ec 14             	sub    $0x14,%esp
   114b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   114b7:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   114ba:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   114be:	83 f8 04             	cmp    $0x4,%eax
   114c1:	0f 87 41 03 00 00    	ja     11808 <filterScanline+0x35c>
   114c7:	8b 04 85 90 a0 01 00 	mov    0x1a090(,%eax,4),%eax
   114ce:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   114d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   114d7:	eb 19                	jmp    114f2 <filterScanline+0x46>
   114d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   114dc:	8b 45 08             	mov    0x8(%ebp),%eax
   114df:	01 c2                	add    %eax,%edx
   114e1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   114e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   114e7:	01 c8                	add    %ecx,%eax
   114e9:	0f b6 00             	movzbl (%eax),%eax
   114ec:	88 02                	mov    %al,(%edx)
   114ee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   114f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114f5:	3b 45 14             	cmp    0x14(%ebp),%eax
   114f8:	75 df                	jne    114d9 <filterScanline+0x2d>
      break;
   114fa:	e9 0a 03 00 00       	jmp    11809 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   114ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11506:	eb 19                	jmp    11521 <filterScanline+0x75>
   11508:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1150b:	8b 45 08             	mov    0x8(%ebp),%eax
   1150e:	01 c2                	add    %eax,%edx
   11510:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11513:	8b 45 0c             	mov    0xc(%ebp),%eax
   11516:	01 c8                	add    %ecx,%eax
   11518:	0f b6 00             	movzbl (%eax),%eax
   1151b:	88 02                	mov    %al,(%edx)
   1151d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11521:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11524:	3b 45 18             	cmp    0x18(%ebp),%eax
   11527:	75 df                	jne    11508 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11529:	8b 45 18             	mov    0x18(%ebp),%eax
   1152c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1152f:	eb 2d                	jmp    1155e <filterScanline+0xb2>
   11531:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11534:	8b 45 08             	mov    0x8(%ebp),%eax
   11537:	01 c2                	add    %eax,%edx
   11539:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1153c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1153f:	01 c8                	add    %ecx,%eax
   11541:	0f b6 08             	movzbl (%eax),%ecx
   11544:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11547:	2b 45 18             	sub    0x18(%ebp),%eax
   1154a:	89 c3                	mov    %eax,%ebx
   1154c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1154f:	01 d8                	add    %ebx,%eax
   11551:	0f b6 00             	movzbl (%eax),%eax
   11554:	29 c1                	sub    %eax,%ecx
   11556:	89 c8                	mov    %ecx,%eax
   11558:	88 02                	mov    %al,(%edx)
   1155a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1155e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11561:	3b 45 14             	cmp    0x14(%ebp),%eax
   11564:	7c cb                	jl     11531 <filterScanline+0x85>
      break;
   11566:	e9 9e 02 00 00       	jmp    11809 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   1156b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1156f:	74 3e                	je     115af <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11571:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11578:	eb 28                	jmp    115a2 <filterScanline+0xf6>
   1157a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1157d:	8b 45 08             	mov    0x8(%ebp),%eax
   11580:	01 d0                	add    %edx,%eax
   11582:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11585:	8b 55 0c             	mov    0xc(%ebp),%edx
   11588:	01 ca                	add    %ecx,%edx
   1158a:	0f b6 0a             	movzbl (%edx),%ecx
   1158d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11590:	8b 55 10             	mov    0x10(%ebp),%edx
   11593:	01 da                	add    %ebx,%edx
   11595:	0f b6 12             	movzbl (%edx),%edx
   11598:	29 d1                	sub    %edx,%ecx
   1159a:	89 ca                	mov    %ecx,%edx
   1159c:	88 10                	mov    %dl,(%eax)
   1159e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115a5:	3b 45 14             	cmp    0x14(%ebp),%eax
   115a8:	75 d0                	jne    1157a <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   115aa:	e9 5a 02 00 00       	jmp    11809 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   115af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115b6:	eb 19                	jmp    115d1 <filterScanline+0x125>
   115b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115bb:	8b 45 08             	mov    0x8(%ebp),%eax
   115be:	01 c2                	add    %eax,%edx
   115c0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115c3:	8b 45 0c             	mov    0xc(%ebp),%eax
   115c6:	01 c8                	add    %ecx,%eax
   115c8:	0f b6 00             	movzbl (%eax),%eax
   115cb:	88 02                	mov    %al,(%edx)
   115cd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115d4:	3b 45 14             	cmp    0x14(%ebp),%eax
   115d7:	75 df                	jne    115b8 <filterScanline+0x10c>
      }
      break;
   115d9:	e9 2b 02 00 00       	jmp    11809 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   115de:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   115e2:	0f 84 90 00 00 00    	je     11678 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   115e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115ef:	eb 28                	jmp    11619 <filterScanline+0x16d>
   115f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115f4:	8b 45 08             	mov    0x8(%ebp),%eax
   115f7:	01 d0                	add    %edx,%eax
   115f9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115fc:	8b 55 0c             	mov    0xc(%ebp),%edx
   115ff:	01 ca                	add    %ecx,%edx
   11601:	0f b6 12             	movzbl (%edx),%edx
   11604:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11607:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1160a:	01 d9                	add    %ebx,%ecx
   1160c:	0f b6 09             	movzbl (%ecx),%ecx
   1160f:	d0 e9                	shr    %cl
   11611:	29 ca                	sub    %ecx,%edx
   11613:	88 10                	mov    %dl,(%eax)
   11615:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11619:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1161c:	3b 45 18             	cmp    0x18(%ebp),%eax
   1161f:	75 d0                	jne    115f1 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   11621:	8b 45 18             	mov    0x18(%ebp),%eax
   11624:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11627:	eb 42                	jmp    1166b <filterScanline+0x1bf>
   11629:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1162c:	8b 45 08             	mov    0x8(%ebp),%eax
   1162f:	01 c2                	add    %eax,%edx
   11631:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11634:	8b 45 0c             	mov    0xc(%ebp),%eax
   11637:	01 c8                	add    %ecx,%eax
   11639:	0f b6 08             	movzbl (%eax),%ecx
   1163c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1163f:	2b 45 18             	sub    0x18(%ebp),%eax
   11642:	89 c3                	mov    %eax,%ebx
   11644:	8b 45 0c             	mov    0xc(%ebp),%eax
   11647:	01 d8                	add    %ebx,%eax
   11649:	0f b6 00             	movzbl (%eax),%eax
   1164c:	0f b6 d8             	movzbl %al,%ebx
   1164f:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11652:	8b 45 10             	mov    0x10(%ebp),%eax
   11655:	01 f0                	add    %esi,%eax
   11657:	0f b6 00             	movzbl (%eax),%eax
   1165a:	0f b6 c0             	movzbl %al,%eax
   1165d:	01 d8                	add    %ebx,%eax
   1165f:	d1 f8                	sar    %eax
   11661:	29 c1                	sub    %eax,%ecx
   11663:	89 c8                	mov    %ecx,%eax
   11665:	88 02                	mov    %al,(%edx)
   11667:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1166b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1166e:	3b 45 14             	cmp    0x14(%ebp),%eax
   11671:	7c b6                	jl     11629 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11673:	e9 91 01 00 00       	jmp    11809 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11678:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1167f:	eb 19                	jmp    1169a <filterScanline+0x1ee>
   11681:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11684:	8b 45 08             	mov    0x8(%ebp),%eax
   11687:	01 c2                	add    %eax,%edx
   11689:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1168c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1168f:	01 c8                	add    %ecx,%eax
   11691:	0f b6 00             	movzbl (%eax),%eax
   11694:	88 02                	mov    %al,(%edx)
   11696:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1169a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1169d:	3b 45 18             	cmp    0x18(%ebp),%eax
   116a0:	75 df                	jne    11681 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   116a2:	8b 45 18             	mov    0x18(%ebp),%eax
   116a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116a8:	eb 2f                	jmp    116d9 <filterScanline+0x22d>
   116aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116ad:	8b 45 08             	mov    0x8(%ebp),%eax
   116b0:	01 c2                	add    %eax,%edx
   116b2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   116b8:	01 c8                	add    %ecx,%eax
   116ba:	0f b6 08             	movzbl (%eax),%ecx
   116bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116c0:	2b 45 18             	sub    0x18(%ebp),%eax
   116c3:	89 c3                	mov    %eax,%ebx
   116c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   116c8:	01 d8                	add    %ebx,%eax
   116ca:	0f b6 00             	movzbl (%eax),%eax
   116cd:	d0 e8                	shr    %al
   116cf:	29 c1                	sub    %eax,%ecx
   116d1:	89 c8                	mov    %ecx,%eax
   116d3:	88 02                	mov    %al,(%edx)
   116d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116dc:	3b 45 14             	cmp    0x14(%ebp),%eax
   116df:	7c c9                	jl     116aa <filterScanline+0x1fe>
      }
      break;
   116e1:	e9 23 01 00 00       	jmp    11809 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   116e6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   116ea:	0f 84 af 00 00 00    	je     1179f <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   116f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   116f7:	eb 28                	jmp    11721 <filterScanline+0x275>
   116f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116fc:	8b 45 08             	mov    0x8(%ebp),%eax
   116ff:	01 d0                	add    %edx,%eax
   11701:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11704:	8b 55 0c             	mov    0xc(%ebp),%edx
   11707:	01 ca                	add    %ecx,%edx
   11709:	0f b6 0a             	movzbl (%edx),%ecx
   1170c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1170f:	8b 55 10             	mov    0x10(%ebp),%edx
   11712:	01 da                	add    %ebx,%edx
   11714:	0f b6 12             	movzbl (%edx),%edx
   11717:	29 d1                	sub    %edx,%ecx
   11719:	89 ca                	mov    %ecx,%edx
   1171b:	88 10                	mov    %dl,(%eax)
   1171d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11721:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11724:	3b 45 18             	cmp    0x18(%ebp),%eax
   11727:	75 d0                	jne    116f9 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11729:	8b 45 18             	mov    0x18(%ebp),%eax
   1172c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1172f:	eb 64                	jmp    11795 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11731:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11734:	8b 45 08             	mov    0x8(%ebp),%eax
   11737:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1173a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1173d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11740:	01 d0                	add    %edx,%eax
   11742:	0f b6 00             	movzbl (%eax),%eax
   11745:	88 45 e7             	mov    %al,-0x19(%ebp)
   11748:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1174b:	2b 45 18             	sub    0x18(%ebp),%eax
   1174e:	89 c2                	mov    %eax,%edx
   11750:	8b 45 10             	mov    0x10(%ebp),%eax
   11753:	01 d0                	add    %edx,%eax
   11755:	0f b6 00             	movzbl (%eax),%eax
   11758:	0f b6 c8             	movzbl %al,%ecx
   1175b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1175e:	8b 45 10             	mov    0x10(%ebp),%eax
   11761:	01 d0                	add    %edx,%eax
   11763:	0f b6 00             	movzbl (%eax),%eax
   11766:	0f b6 d0             	movzbl %al,%edx
   11769:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1176c:	2b 45 18             	sub    0x18(%ebp),%eax
   1176f:	89 c6                	mov    %eax,%esi
   11771:	8b 45 0c             	mov    0xc(%ebp),%eax
   11774:	01 f0                	add    %esi,%eax
   11776:	0f b6 00             	movzbl (%eax),%eax
   11779:	0f b6 c0             	movzbl %al,%eax
   1177c:	51                   	push   %ecx
   1177d:	52                   	push   %edx
   1177e:	50                   	push   %eax
   1177f:	e8 49 b8 ff ff       	call   cfcd <paethPredictor>
   11784:	83 c4 0c             	add    $0xc,%esp
   11787:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   1178b:	29 c1                	sub    %eax,%ecx
   1178d:	89 c8                	mov    %ecx,%eax
   1178f:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   11791:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11795:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11798:	3b 45 14             	cmp    0x14(%ebp),%eax
   1179b:	7c 94                	jl     11731 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   1179d:	eb 6a                	jmp    11809 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1179f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117a6:	eb 19                	jmp    117c1 <filterScanline+0x315>
   117a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117ab:	8b 45 08             	mov    0x8(%ebp),%eax
   117ae:	01 c2                	add    %eax,%edx
   117b0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   117b6:	01 c8                	add    %ecx,%eax
   117b8:	0f b6 00             	movzbl (%eax),%eax
   117bb:	88 02                	mov    %al,(%edx)
   117bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c4:	3b 45 18             	cmp    0x18(%ebp),%eax
   117c7:	75 df                	jne    117a8 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   117c9:	8b 45 18             	mov    0x18(%ebp),%eax
   117cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
   117cf:	eb 2d                	jmp    117fe <filterScanline+0x352>
   117d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117d4:	8b 45 08             	mov    0x8(%ebp),%eax
   117d7:	01 c2                	add    %eax,%edx
   117d9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   117df:	01 c8                	add    %ecx,%eax
   117e1:	0f b6 08             	movzbl (%eax),%ecx
   117e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117e7:	2b 45 18             	sub    0x18(%ebp),%eax
   117ea:	89 c3                	mov    %eax,%ebx
   117ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   117ef:	01 d8                	add    %ebx,%eax
   117f1:	0f b6 00             	movzbl (%eax),%eax
   117f4:	29 c1                	sub    %eax,%ecx
   117f6:	89 c8                	mov    %ecx,%eax
   117f8:	88 02                	mov    %al,(%edx)
   117fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11801:	3b 45 14             	cmp    0x14(%ebp),%eax
   11804:	7c cb                	jl     117d1 <filterScanline+0x325>
      }
      break;
   11806:	eb 01                	jmp    11809 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11808:	90                   	nop
  }
}
   11809:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1180c:	5b                   	pop    %ebx
   1180d:	5e                   	pop    %esi
   1180e:	5d                   	pop    %ebp
   1180f:	c3                   	ret    

00011810 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   11810:	55                   	push   %ebp
   11811:	89 e5                	mov    %esp,%ebp
   11813:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11816:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   1181d:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11824:	7e 08                	jle    1182e <ilog2+0x1e>
   11826:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   1182a:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   1182e:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11835:	7e 08                	jle    1183f <ilog2+0x2f>
   11837:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   1183b:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   1183f:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11843:	7e 08                	jle    1184d <ilog2+0x3d>
   11845:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11849:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   1184d:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11851:	7e 08                	jle    1185b <ilog2+0x4b>
   11853:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11857:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   1185b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   1185f:	7e 04                	jle    11865 <ilog2+0x55>
   11861:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11865:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11868:	c9                   	leave  
   11869:	c3                   	ret    

0001186a <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   1186a:	55                   	push   %ebp
   1186b:	89 e5                	mov    %esp,%ebp
   1186d:	56                   	push   %esi
   1186e:	53                   	push   %ebx
   1186f:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11872:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11876:	75 07                	jne    1187f <ilog2i+0x15>
   11878:	b8 00 00 00 00       	mov    $0x0,%eax
   1187d:	eb 30                	jmp    118af <ilog2i+0x45>
  l = ilog2(i);
   1187f:	ff 75 08             	pushl  0x8(%ebp)
   11882:	e8 89 ff ff ff       	call   11810 <ilog2>
   11887:	83 c4 04             	add    $0x4,%esp
   1188a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   1188d:	8b 45 08             	mov    0x8(%ebp),%eax
   11890:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11894:	89 c3                	mov    %eax,%ebx
   11896:	8b 55 08             	mov    0x8(%ebp),%edx
   11899:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1189c:	be 01 00 00 00       	mov    $0x1,%esi
   118a1:	89 c1                	mov    %eax,%ecx
   118a3:	d3 e6                	shl    %cl,%esi
   118a5:	89 f0                	mov    %esi,%eax
   118a7:	29 c2                	sub    %eax,%edx
   118a9:	89 d0                	mov    %edx,%eax
   118ab:	01 c0                	add    %eax,%eax
   118ad:	01 d8                	add    %ebx,%eax
}
   118af:	8d 65 f8             	lea    -0x8(%ebp),%esp
   118b2:	5b                   	pop    %ebx
   118b3:	5e                   	pop    %esi
   118b4:	5d                   	pop    %ebp
   118b5:	c3                   	ret    

000118b6 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   118b6:	55                   	push   %ebp
   118b7:	89 e5                	mov    %esp,%ebp
   118b9:	53                   	push   %ebx
   118ba:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   118c0:	ff 75 18             	pushl  0x18(%ebp)
   118c3:	e8 6a 75 ff ff       	call   8e32 <lodepng_get_bpp>
   118c8:	83 c4 04             	add    $0x4,%esp
   118cb:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   118ce:	ff 75 b8             	pushl  -0x48(%ebp)
   118d1:	6a 01                	push   $0x1
   118d3:	ff 75 10             	pushl  0x10(%ebp)
   118d6:	e8 b6 76 ff ff       	call   8f91 <lodepng_get_raw_size_idat>
   118db:	83 c4 0c             	add    $0xc,%esp
   118de:	83 e8 01             	sub    $0x1,%eax
   118e1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   118e4:	8b 45 b8             	mov    -0x48(%ebp),%eax
   118e7:	83 c0 07             	add    $0x7,%eax
   118ea:	c1 e8 03             	shr    $0x3,%eax
   118ed:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   118f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   118f7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   118fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11901:	8b 40 2c             	mov    0x2c(%eax),%eax
   11904:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11907:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1190a:	8b 40 28             	mov    0x28(%eax),%eax
   1190d:	85 c0                	test   %eax,%eax
   1190f:	74 1c                	je     1192d <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11911:	8b 45 18             	mov    0x18(%ebp),%eax
   11914:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11916:	83 f8 03             	cmp    $0x3,%eax
   11919:	74 0b                	je     11926 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   1191b:	8b 45 18             	mov    0x18(%ebp),%eax
   1191e:	8b 40 04             	mov    0x4(%eax),%eax
   11921:	83 f8 07             	cmp    $0x7,%eax
   11924:	77 07                	ja     1192d <filter+0x77>
   11926:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   1192d:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11931:	75 0a                	jne    1193d <filter+0x87>
   11933:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11938:	e9 5b 07 00 00       	jmp    12098 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   1193d:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11941:	77 7b                	ja     119be <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11943:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11946:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11949:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11950:	eb 5f                	jmp    119b1 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11952:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11955:	83 c0 01             	add    $0x1,%eax
   11958:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1195c:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   1195f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11962:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11966:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11969:	8b 55 9c             	mov    -0x64(%ebp),%edx
   1196c:	8b 45 08             	mov    0x8(%ebp),%eax
   1196f:	01 c2                	add    %eax,%edx
   11971:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11975:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11977:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   1197b:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   1197e:	8b 55 0c             	mov    0xc(%ebp),%edx
   11981:	01 d1                	add    %edx,%ecx
   11983:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11986:	8d 5a 01             	lea    0x1(%edx),%ebx
   11989:	8b 55 08             	mov    0x8(%ebp),%edx
   1198c:	01 da                	add    %ebx,%edx
   1198e:	50                   	push   %eax
   1198f:	ff 75 b0             	pushl  -0x50(%ebp)
   11992:	ff 75 b4             	pushl  -0x4c(%ebp)
   11995:	ff 75 f4             	pushl  -0xc(%ebp)
   11998:	51                   	push   %ecx
   11999:	52                   	push   %edx
   1199a:	e8 0d fb ff ff       	call   114ac <filterScanline>
   1199f:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   119a2:	8b 55 98             	mov    -0x68(%ebp),%edx
   119a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   119a8:	01 d0                	add    %edx,%eax
   119aa:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   119ad:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   119b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119b4:	3b 45 14             	cmp    0x14(%ebp),%eax
   119b7:	75 99                	jne    11952 <filter+0x9c>
   119b9:	e9 d7 06 00 00       	jmp    12095 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   119be:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   119c2:	0f 85 e3 01 00 00    	jne    11bab <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   119c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   119cf:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   119d3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   119d7:	eb 2d                	jmp    11a06 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   119d9:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   119dd:	83 ec 0c             	sub    $0xc,%esp
   119e0:	ff 75 b4             	pushl  -0x4c(%ebp)
   119e3:	e8 2e 19 ff ff       	call   3316 <lodepng_malloc>
   119e8:	83 c4 10             	add    $0x10,%esp
   119eb:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   119ef:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   119f3:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   119f7:	85 c0                	test   %eax,%eax
   119f9:	75 07                	jne    11a02 <filter+0x14c>
   119fb:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11a02:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11a06:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11a0a:	75 cd                	jne    119d9 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11a0c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11a10:	0f 85 6c 01 00 00    	jne    11b82 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11a16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11a1d:	e9 54 01 00 00       	jmp    11b76 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11a22:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11a26:	e9 d5 00 00 00       	jmp    11b00 <filter+0x24a>
          size_t sum = 0;
   11a2b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11a32:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11a36:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a39:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a3d:	89 c1                	mov    %eax,%ecx
   11a3f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a42:	01 c1                	add    %eax,%ecx
   11a44:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a48:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a4c:	83 ec 08             	sub    $0x8,%esp
   11a4f:	52                   	push   %edx
   11a50:	ff 75 b0             	pushl  -0x50(%ebp)
   11a53:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a56:	ff 75 f4             	pushl  -0xc(%ebp)
   11a59:	51                   	push   %ecx
   11a5a:	50                   	push   %eax
   11a5b:	e8 4c fa ff ff       	call   114ac <filterScanline>
   11a60:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11a63:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11a67:	75 2d                	jne    11a96 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11a69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11a70:	eb 1a                	jmp    11a8c <filter+0x1d6>
   11a72:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a76:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11a7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a7d:	01 d0                	add    %edx,%eax
   11a7f:	0f b6 00             	movzbl (%eax),%eax
   11a82:	0f b6 c0             	movzbl %al,%eax
   11a85:	01 45 d8             	add    %eax,-0x28(%ebp)
   11a88:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11a8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a8f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11a92:	75 de                	jne    11a72 <filter+0x1bc>
   11a94:	eb 4b                	jmp    11ae1 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11a96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11a9d:	eb 3a                	jmp    11ad9 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11a9f:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11aa3:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11aa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11aaa:	01 d0                	add    %edx,%eax
   11aac:	0f b6 00             	movzbl (%eax),%eax
   11aaf:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11ab2:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ab6:	84 c0                	test   %al,%al
   11ab8:	78 06                	js     11ac0 <filter+0x20a>
   11aba:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11abe:	eb 0d                	jmp    11acd <filter+0x217>
   11ac0:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ac4:	ba ff 00 00 00       	mov    $0xff,%edx
   11ac9:	29 c2                	sub    %eax,%edx
   11acb:	89 d0                	mov    %edx,%eax
   11acd:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11ad0:	01 d0                	add    %edx,%eax
   11ad2:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11ad5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11ad9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11adc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11adf:	75 be                	jne    11a9f <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11ae1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11ae5:	74 08                	je     11aef <filter+0x239>
   11ae7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11aea:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11aed:	7d 0d                	jge    11afc <filter+0x246>
            bestType = type;
   11aef:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11af3:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11af6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11af9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11afc:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11b00:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11b04:	0f 85 21 ff ff ff    	jne    11a2b <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11b0a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b0d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b11:	89 c2                	mov    %eax,%edx
   11b13:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b16:	01 d0                	add    %edx,%eax
   11b18:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11b1b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b1e:	83 c0 01             	add    $0x1,%eax
   11b21:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b25:	89 c2                	mov    %eax,%edx
   11b27:	8b 45 08             	mov    0x8(%ebp),%eax
   11b2a:	01 c2                	add    %eax,%edx
   11b2c:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b30:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11b32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b39:	eb 2f                	jmp    11b6a <filter+0x2b4>
   11b3b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b3e:	83 c0 01             	add    $0x1,%eax
   11b41:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b45:	89 c2                	mov    %eax,%edx
   11b47:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b4a:	01 d0                	add    %edx,%eax
   11b4c:	8d 50 01             	lea    0x1(%eax),%edx
   11b4f:	8b 45 08             	mov    0x8(%ebp),%eax
   11b52:	01 c2                	add    %eax,%edx
   11b54:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b58:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11b5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b5f:	01 c8                	add    %ecx,%eax
   11b61:	0f b6 00             	movzbl (%eax),%eax
   11b64:	88 02                	mov    %al,(%edx)
   11b66:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b6a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b6d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b70:	75 c9                	jne    11b3b <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11b72:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11b76:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b79:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b7c:	0f 85 a0 fe ff ff    	jne    11a22 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11b82:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11b86:	eb 18                	jmp    11ba0 <filter+0x2ea>
   11b88:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b8c:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11b90:	83 ec 0c             	sub    $0xc,%esp
   11b93:	50                   	push   %eax
   11b94:	e8 9e 17 ff ff       	call   3337 <lodepng_free>
   11b99:	83 c4 10             	add    $0x10,%esp
   11b9c:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11ba0:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11ba4:	75 e2                	jne    11b88 <filter+0x2d2>
   11ba6:	e9 ea 04 00 00       	jmp    12095 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11bab:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11baf:	0f 85 17 02 00 00    	jne    11dcc <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11bb5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11bbc:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11bc3:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11bca:	eb 33                	jmp    11bff <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11bcc:	83 ec 0c             	sub    $0xc,%esp
   11bcf:	ff 75 b4             	pushl  -0x4c(%ebp)
   11bd2:	e8 3f 17 ff ff       	call   3316 <lodepng_malloc>
   11bd7:	83 c4 10             	add    $0x10,%esp
   11bda:	89 c2                	mov    %eax,%edx
   11bdc:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11bdf:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11be6:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11be9:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11bf0:	85 c0                	test   %eax,%eax
   11bf2:	75 07                	jne    11bfb <filter+0x345>
   11bf4:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11bfb:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11bff:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11c03:	75 c7                	jne    11bcc <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11c05:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11c09:	0f 85 8f 01 00 00    	jne    11d9e <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11c0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11c16:	e9 77 01 00 00       	jmp    11d92 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11c1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11c22:	e9 f4 00 00 00       	jmp    11d1b <filter+0x465>
          size_t sum = 0;
   11c27:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11c2e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c31:	0f b6 d0             	movzbl %al,%edx
   11c34:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c37:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c3b:	89 c1                	mov    %eax,%ecx
   11c3d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c40:	01 c1                	add    %eax,%ecx
   11c42:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c45:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c4c:	83 ec 08             	sub    $0x8,%esp
   11c4f:	52                   	push   %edx
   11c50:	ff 75 b0             	pushl  -0x50(%ebp)
   11c53:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c56:	ff 75 f4             	pushl  -0xc(%ebp)
   11c59:	51                   	push   %ecx
   11c5a:	50                   	push   %eax
   11c5b:	e8 4c f8 ff ff       	call   114ac <filterScanline>
   11c60:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11c63:	83 ec 04             	sub    $0x4,%esp
   11c66:	68 00 04 00 00       	push   $0x400
   11c6b:	6a 00                	push   $0x0
   11c6d:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11c73:	50                   	push   %eax
   11c74:	e8 0e 17 ff ff       	call   3387 <lodepng_memset>
   11c79:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11c7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c83:	eb 2a                	jmp    11caf <filter+0x3f9>
   11c85:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c88:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11c8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c92:	01 d0                	add    %edx,%eax
   11c94:	0f b6 00             	movzbl (%eax),%eax
   11c97:	0f b6 c0             	movzbl %al,%eax
   11c9a:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11ca1:	83 c2 01             	add    $0x1,%edx
   11ca4:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11cab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11caf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11cb2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11cb5:	75 ce                	jne    11c85 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11cb7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cba:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11cc1:	8d 50 01             	lea    0x1(%eax),%edx
   11cc4:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cc7:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11cce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11cd5:	eb 1d                	jmp    11cf4 <filter+0x43e>
            sum += ilog2i(count[x]);
   11cd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11cda:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11ce1:	83 ec 0c             	sub    $0xc,%esp
   11ce4:	50                   	push   %eax
   11ce5:	e8 80 fb ff ff       	call   1186a <ilog2i>
   11cea:	83 c4 10             	add    $0x10,%esp
   11ced:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11cf0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cf4:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11cfb:	75 da                	jne    11cd7 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11cfd:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11d01:	74 08                	je     11d0b <filter+0x455>
   11d03:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d06:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11d09:	7e 0c                	jle    11d17 <filter+0x461>
            bestType = type;
   11d0b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d0e:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11d11:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d14:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11d17:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11d1b:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11d1f:	0f 85 02 ff ff ff    	jne    11c27 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11d25:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d28:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d2c:	89 c2                	mov    %eax,%edx
   11d2e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d31:	01 d0                	add    %edx,%eax
   11d33:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11d36:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d39:	83 c0 01             	add    $0x1,%eax
   11d3c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d40:	89 c2                	mov    %eax,%edx
   11d42:	8b 45 08             	mov    0x8(%ebp),%eax
   11d45:	01 d0                	add    %edx,%eax
   11d47:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11d4a:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11d4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d53:	eb 31                	jmp    11d86 <filter+0x4d0>
   11d55:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d58:	83 c0 01             	add    $0x1,%eax
   11d5b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d5f:	89 c2                	mov    %eax,%edx
   11d61:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d64:	01 d0                	add    %edx,%eax
   11d66:	8d 50 01             	lea    0x1(%eax),%edx
   11d69:	8b 45 08             	mov    0x8(%ebp),%eax
   11d6c:	01 c2                	add    %eax,%edx
   11d6e:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11d71:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11d78:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d7b:	01 c8                	add    %ecx,%eax
   11d7d:	0f b6 00             	movzbl (%eax),%eax
   11d80:	88 02                	mov    %al,(%edx)
   11d82:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d86:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d89:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d8c:	75 c7                	jne    11d55 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11d8e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11d92:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d95:	3b 45 14             	cmp    0x14(%ebp),%eax
   11d98:	0f 85 7d fe ff ff    	jne    11c1b <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11d9e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11da5:	eb 1a                	jmp    11dc1 <filter+0x50b>
   11da7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11daa:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11db1:	83 ec 0c             	sub    $0xc,%esp
   11db4:	50                   	push   %eax
   11db5:	e8 7d 15 ff ff       	call   3337 <lodepng_free>
   11dba:	83 c4 10             	add    $0x10,%esp
   11dbd:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11dc1:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11dc5:	75 e0                	jne    11da7 <filter+0x4f1>
   11dc7:	e9 c9 02 00 00       	jmp    12095 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11dcc:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11dd0:	0f 85 89 00 00 00    	jne    11e5f <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11dd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ddd:	eb 73                	jmp    11e52 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11ddf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11de2:	83 c0 01             	add    $0x1,%eax
   11de5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11de9:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11dec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11def:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11df3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11df6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11df9:	8b 50 30             	mov    0x30(%eax),%edx
   11dfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11dff:	01 d0                	add    %edx,%eax
   11e01:	0f b6 00             	movzbl (%eax),%eax
   11e04:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11e07:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e0a:	8b 45 08             	mov    0x8(%ebp),%eax
   11e0d:	01 c2                	add    %eax,%edx
   11e0f:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e13:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11e15:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e19:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11e1c:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e1f:	01 d1                	add    %edx,%ecx
   11e21:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e24:	8d 5a 01             	lea    0x1(%edx),%ebx
   11e27:	8b 55 08             	mov    0x8(%ebp),%edx
   11e2a:	01 da                	add    %ebx,%edx
   11e2c:	83 ec 08             	sub    $0x8,%esp
   11e2f:	50                   	push   %eax
   11e30:	ff 75 b0             	pushl  -0x50(%ebp)
   11e33:	ff 75 b4             	pushl  -0x4c(%ebp)
   11e36:	ff 75 f4             	pushl  -0xc(%ebp)
   11e39:	51                   	push   %ecx
   11e3a:	52                   	push   %edx
   11e3b:	e8 6c f6 ff ff       	call   114ac <filterScanline>
   11e40:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11e43:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11e46:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e49:	01 d0                	add    %edx,%eax
   11e4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11e4e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e52:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e55:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e58:	75 85                	jne    11ddf <filter+0x529>
   11e5a:	e9 36 02 00 00       	jmp    12095 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11e5f:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11e63:	0f 85 25 02 00 00    	jne    1208e <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11e69:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11e70:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11e77:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11e7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e81:	83 ec 04             	sub    $0x4,%esp
   11e84:	6a 24                	push   $0x24
   11e86:	50                   	push   %eax
   11e87:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11e8d:	50                   	push   %eax
   11e8e:	e8 c1 14 ff ff       	call   3354 <lodepng_memcpy>
   11e93:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11e96:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11e9d:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11ea0:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11ea7:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11eaa:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11eb1:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11eb4:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11ebb:	eb 33                	jmp    11ef0 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11ebd:	83 ec 0c             	sub    $0xc,%esp
   11ec0:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ec3:	e8 4e 14 ff ff       	call   3316 <lodepng_malloc>
   11ec8:	83 c4 10             	add    $0x10,%esp
   11ecb:	89 c2                	mov    %eax,%edx
   11ecd:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ed0:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11ed7:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11eda:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11ee1:	85 c0                	test   %eax,%eax
   11ee3:	75 07                	jne    11eec <filter+0x636>
   11ee5:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11eec:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11ef0:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11ef4:	75 c7                	jne    11ebd <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11ef6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11efa:	0f 85 63 01 00 00    	jne    12063 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11f00:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11f07:	e9 4b 01 00 00       	jmp    12057 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11f0c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f13:	e9 c8 00 00 00       	jmp    11fe0 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   11f18:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f1b:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11f1e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f21:	0f b6 d0             	movzbl %al,%edx
   11f24:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f27:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f2b:	89 c1                	mov    %eax,%ecx
   11f2d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f30:	01 c1                	add    %eax,%ecx
   11f32:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f35:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f3c:	83 ec 08             	sub    $0x8,%esp
   11f3f:	52                   	push   %edx
   11f40:	ff 75 b0             	pushl  -0x50(%ebp)
   11f43:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f46:	ff 75 f4             	pushl  -0xc(%ebp)
   11f49:	51                   	push   %ecx
   11f4a:	50                   	push   %eax
   11f4b:	e8 5c f5 ff ff       	call   114ac <filterScanline>
   11f50:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   11f53:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f56:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   11f5d:	00 00 00 00 
          dummy = 0;
   11f61:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   11f68:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   11f6b:	8b 55 ac             	mov    -0x54(%ebp),%edx
   11f6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f71:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f78:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   11f7e:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   11f81:	c1 e3 02             	shl    $0x2,%ebx
   11f84:	01 cb                	add    %ecx,%ebx
   11f86:	83 ec 0c             	sub    $0xc,%esp
   11f89:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   11f8f:	51                   	push   %ecx
   11f90:	52                   	push   %edx
   11f91:	50                   	push   %eax
   11f92:	53                   	push   %ebx
   11f93:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   11f99:	50                   	push   %eax
   11f9a:	e8 87 60 ff ff       	call   8026 <zlib_compress>
   11f9f:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   11fa2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   11fa8:	83 ec 0c             	sub    $0xc,%esp
   11fab:	50                   	push   %eax
   11fac:	e8 86 13 ff ff       	call   3337 <lodepng_free>
   11fb1:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   11fb4:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   11fb8:	74 0f                	je     11fc9 <filter+0x713>
   11fba:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fbd:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fc4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   11fc7:	7d 13                	jge    11fdc <filter+0x726>
            bestType = type;
   11fc9:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fcc:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   11fcf:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fd2:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fd9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   11fdc:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11fe0:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11fe4:	0f 85 2e ff ff ff    	jne    11f18 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   11fea:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fed:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ff1:	89 c2                	mov    %eax,%edx
   11ff3:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ff6:	01 d0                	add    %edx,%eax
   11ff8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11ffb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ffe:	83 c0 01             	add    $0x1,%eax
   12001:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12005:	89 c2                	mov    %eax,%edx
   12007:	8b 45 08             	mov    0x8(%ebp),%eax
   1200a:	01 d0                	add    %edx,%eax
   1200c:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1200f:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12011:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12018:	eb 31                	jmp    1204b <filter+0x795>
   1201a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1201d:	83 c0 01             	add    $0x1,%eax
   12020:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12024:	89 c2                	mov    %eax,%edx
   12026:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12029:	01 d0                	add    %edx,%eax
   1202b:	8d 50 01             	lea    0x1(%eax),%edx
   1202e:	8b 45 08             	mov    0x8(%ebp),%eax
   12031:	01 c2                	add    %eax,%edx
   12033:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12036:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   1203d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12040:	01 c8                	add    %ecx,%eax
   12042:	0f b6 00             	movzbl (%eax),%eax
   12045:	88 02                	mov    %al,(%edx)
   12047:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1204b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1204e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12051:	75 c7                	jne    1201a <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12053:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12057:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1205a:	3b 45 14             	cmp    0x14(%ebp),%eax
   1205d:	0f 85 a9 fe ff ff    	jne    11f0c <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12063:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1206a:	eb 1a                	jmp    12086 <filter+0x7d0>
   1206c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1206f:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12076:	83 ec 0c             	sub    $0xc,%esp
   12079:	50                   	push   %eax
   1207a:	e8 b8 12 ff ff       	call   3337 <lodepng_free>
   1207f:	83 c4 10             	add    $0x10,%esp
   12082:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12086:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1208a:	75 e0                	jne    1206c <filter+0x7b6>
   1208c:	eb 07                	jmp    12095 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1208e:	b8 58 00 00 00       	mov    $0x58,%eax
   12093:	eb 03                	jmp    12098 <filter+0x7e2>

  return error;
   12095:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12098:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1209b:	c9                   	leave  
   1209c:	c3                   	ret    

0001209d <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   1209d:	55                   	push   %ebp
   1209e:	89 e5                	mov    %esp,%ebp
   120a0:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   120a3:	8b 45 10             	mov    0x10(%ebp),%eax
   120a6:	2b 45 14             	sub    0x14(%ebp),%eax
   120a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   120ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   120b3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   120ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   120c1:	eb 65                	jmp    12128 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   120c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   120ca:	eb 2a                	jmp    120f6 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   120cc:	ff 75 0c             	pushl  0xc(%ebp)
   120cf:	8d 45 e8             	lea    -0x18(%ebp),%eax
   120d2:	50                   	push   %eax
   120d3:	e8 9d 60 ff ff       	call   8175 <readBitFromReversedStream>
   120d8:	83 c4 08             	add    $0x8,%esp
   120db:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   120de:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   120e2:	50                   	push   %eax
   120e3:	ff 75 08             	pushl  0x8(%ebp)
   120e6:	8d 45 ec             	lea    -0x14(%ebp),%eax
   120e9:	50                   	push   %eax
   120ea:	e8 08 61 ff ff       	call   81f7 <setBitOfReversedStream>
   120ef:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   120f2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   120f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   120f9:	3b 45 14             	cmp    0x14(%ebp),%eax
   120fc:	7c ce                	jl     120cc <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   120fe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12105:	eb 15                	jmp    1211c <addPaddingBits+0x7f>
   12107:	6a 00                	push   $0x0
   12109:	ff 75 08             	pushl  0x8(%ebp)
   1210c:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1210f:	50                   	push   %eax
   12110:	e8 e2 60 ff ff       	call   81f7 <setBitOfReversedStream>
   12115:	83 c4 0c             	add    $0xc,%esp
   12118:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1211c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1211f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12122:	75 e3                	jne    12107 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   12124:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12128:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1212b:	3b 45 18             	cmp    0x18(%ebp),%eax
   1212e:	75 93                	jne    120c3 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   12130:	90                   	nop
   12131:	c9                   	leave  
   12132:	c3                   	ret    

00012133 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   12133:	55                   	push   %ebp
   12134:	89 e5                	mov    %esp,%ebp
   12136:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1213c:	ff 75 18             	pushl  0x18(%ebp)
   1213f:	ff 75 14             	pushl  0x14(%ebp)
   12142:	ff 75 10             	pushl  0x10(%ebp)
   12145:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   1214b:	50                   	push   %eax
   1214c:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12152:	50                   	push   %eax
   12153:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12159:	50                   	push   %eax
   1215a:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1215d:	50                   	push   %eax
   1215e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12161:	50                   	push   %eax
   12162:	e8 fc ae ff ff       	call   d063 <Adam7_getpassvalues>
   12167:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   1216a:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1216e:	0f 86 0a 01 00 00    	jbe    1227e <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12174:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1217b:	e9 ef 00 00 00       	jmp    1226f <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   12180:	8b 45 18             	mov    0x18(%ebp),%eax
   12183:	c1 e8 03             	shr    $0x3,%eax
   12186:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12189:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12190:	e9 c6 00 00 00       	jmp    1225b <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12195:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1219c:	e9 a6 00 00 00       	jmp    12247 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   121a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121a4:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
   121ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121ae:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
   121b5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   121b9:	01 d0                	add    %edx,%eax
   121bb:	0f af 45 10          	imul   0x10(%ebp),%eax
   121bf:	89 c2                	mov    %eax,%edx
   121c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121c4:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
   121cb:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   121cf:	01 c2                	add    %eax,%edx
   121d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121d4:	8b 04 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%eax
   121db:	01 c2                	add    %eax,%edx
   121dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   121e0:	0f af c2             	imul   %edx,%eax
   121e3:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   121e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121e9:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   121f0:	89 c1                	mov    %eax,%ecx
   121f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121f5:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   121f9:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   121fd:	89 c2                	mov    %eax,%edx
   121ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12202:	01 c2                	add    %eax,%edx
   12204:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12207:	0f af c2             	imul   %edx,%eax
   1220a:	01 c8                	add    %ecx,%eax
   1220c:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   1220f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12216:	eb 23                	jmp    1223b <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   12218:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1221b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1221e:	01 c2                	add    %eax,%edx
   12220:	8b 45 08             	mov    0x8(%ebp),%eax
   12223:	01 c2                	add    %eax,%edx
   12225:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12228:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1222b:	01 c1                	add    %eax,%ecx
   1222d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12230:	01 c8                	add    %ecx,%eax
   12232:	0f b6 00             	movzbl (%eax),%eax
   12235:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12237:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1223b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1223e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12241:	72 d5                	jb     12218 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12243:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12247:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1224a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1224e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12251:	0f 87 4a ff ff ff    	ja     121a1 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12257:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1225b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1225e:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12262:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12265:	0f 87 2a ff ff ff    	ja     12195 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   1226b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1226f:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12273:	0f 85 07 ff ff ff    	jne    12180 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12279:	e9 22 01 00 00       	jmp    123a0 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1227e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12285:	e9 0c 01 00 00       	jmp    12396 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   1228a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1228d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12291:	0f af 45 18          	imul   0x18(%ebp),%eax
   12295:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12298:	8b 45 18             	mov    0x18(%ebp),%eax
   1229b:	0f af 45 10          	imul   0x10(%ebp),%eax
   1229f:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   122a2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   122a9:	e9 d4 00 00 00       	jmp    12382 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   122ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   122b5:	e9 b4 00 00 00       	jmp    1236e <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   122ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122bd:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
   122c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122c7:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
   122ce:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   122d2:	01 d0                	add    %edx,%eax
   122d4:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   122d8:	89 c2                	mov    %eax,%edx
   122da:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122dd:	8b 0c 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%ecx
   122e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122e7:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
   122ee:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122f2:	01 c8                	add    %ecx,%eax
   122f4:	0f af 45 18          	imul   0x18(%ebp),%eax
   122f8:	01 d0                	add    %edx,%eax
   122fa:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   12300:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12303:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   1230a:	c1 e0 03             	shl    $0x3,%eax
   1230d:	89 c1                	mov    %eax,%ecx
   1230f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12312:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   12316:	89 c2                	mov    %eax,%edx
   12318:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1231b:	0f af 45 18          	imul   0x18(%ebp),%eax
   1231f:	01 d0                	add    %edx,%eax
   12321:	01 c8                	add    %ecx,%eax
   12323:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12329:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   12330:	eb 30                	jmp    12362 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   12332:	ff 75 0c             	pushl  0xc(%ebp)
   12335:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   1233b:	50                   	push   %eax
   1233c:	e8 34 5e ff ff       	call   8175 <readBitFromReversedStream>
   12341:	83 c4 08             	add    $0x8,%esp
   12344:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12347:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   1234b:	50                   	push   %eax
   1234c:	ff 75 08             	pushl  0x8(%ebp)
   1234f:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12355:	50                   	push   %eax
   12356:	e8 9c 5e ff ff       	call   81f7 <setBitOfReversedStream>
   1235b:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   1235e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12362:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12365:	3b 45 18             	cmp    0x18(%ebp),%eax
   12368:	72 c8                	jb     12332 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1236a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1236e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12371:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12375:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12378:	0f 87 3c ff ff ff    	ja     122ba <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1237e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12382:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12385:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12389:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1238c:	0f 87 1c ff ff ff    	ja     122ae <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12392:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12396:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1239a:	0f 85 ea fe ff ff    	jne    1228a <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   123a0:	90                   	nop
   123a1:	c9                   	leave  
   123a2:	c3                   	ret    

000123a3 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   123a3:	55                   	push   %ebp
   123a4:	89 e5                	mov    %esp,%ebp
   123a6:	57                   	push   %edi
   123a7:	56                   	push   %esi
   123a8:	53                   	push   %ebx
   123a9:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   123af:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123b2:	83 c0 0c             	add    $0xc,%eax
   123b5:	50                   	push   %eax
   123b6:	e8 77 6a ff ff       	call   8e32 <lodepng_get_bpp>
   123bb:	83 c4 04             	add    $0x4,%esp
   123be:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   123c1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   123c8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123cb:	8b 40 08             	mov    0x8(%eax),%eax
   123ce:	85 c0                	test   %eax,%eax
   123d0:	0f 85 49 01 00 00    	jne    1251f <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   123d6:	8b 45 14             	mov    0x14(%ebp),%eax
   123d9:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   123dd:	83 c0 07             	add    $0x7,%eax
   123e0:	c1 e8 03             	shr    $0x3,%eax
   123e3:	83 c0 01             	add    $0x1,%eax
   123e6:	0f af 45 18          	imul   0x18(%ebp),%eax
   123ea:	89 c2                	mov    %eax,%edx
   123ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   123ef:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   123f1:	8b 45 0c             	mov    0xc(%ebp),%eax
   123f4:	8b 00                	mov    (%eax),%eax
   123f6:	83 ec 0c             	sub    $0xc,%esp
   123f9:	50                   	push   %eax
   123fa:	e8 17 0f ff ff       	call   3316 <lodepng_malloc>
   123ff:	83 c4 10             	add    $0x10,%esp
   12402:	89 c2                	mov    %eax,%edx
   12404:	8b 45 08             	mov    0x8(%ebp),%eax
   12407:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12409:	8b 45 08             	mov    0x8(%ebp),%eax
   1240c:	8b 00                	mov    (%eax),%eax
   1240e:	85 c0                	test   %eax,%eax
   12410:	75 10                	jne    12422 <preProcessScanlines+0x7f>
   12412:	8b 45 0c             	mov    0xc(%ebp),%eax
   12415:	8b 00                	mov    (%eax),%eax
   12417:	85 c0                	test   %eax,%eax
   12419:	74 07                	je     12422 <preProcessScanlines+0x7f>
   1241b:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12422:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12426:	0f 85 fb 02 00 00    	jne    12727 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   1242c:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12430:	0f 87 bd 00 00 00    	ja     124f3 <preProcessScanlines+0x150>
   12436:	8b 45 14             	mov    0x14(%ebp),%eax
   12439:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1243d:	89 c2                	mov    %eax,%edx
   1243f:	8b 45 14             	mov    0x14(%ebp),%eax
   12442:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12446:	83 c0 07             	add    $0x7,%eax
   12449:	c1 e8 03             	shr    $0x3,%eax
   1244c:	c1 e0 03             	shl    $0x3,%eax
   1244f:	39 c2                	cmp    %eax,%edx
   12451:	0f 84 9c 00 00 00    	je     124f3 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12457:	8b 45 14             	mov    0x14(%ebp),%eax
   1245a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1245e:	83 c0 07             	add    $0x7,%eax
   12461:	c1 e8 03             	shr    $0x3,%eax
   12464:	0f af 45 18          	imul   0x18(%ebp),%eax
   12468:	83 ec 0c             	sub    $0xc,%esp
   1246b:	50                   	push   %eax
   1246c:	e8 a5 0e ff ff       	call   3316 <lodepng_malloc>
   12471:	83 c4 10             	add    $0x10,%esp
   12474:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12477:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1247b:	75 07                	jne    12484 <preProcessScanlines+0xe1>
   1247d:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12484:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12488:	75 56                	jne    124e0 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   1248a:	8b 45 14             	mov    0x14(%ebp),%eax
   1248d:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12491:	89 c2                	mov    %eax,%edx
   12493:	8b 45 14             	mov    0x14(%ebp),%eax
   12496:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1249a:	83 c0 07             	add    $0x7,%eax
   1249d:	c1 e8 03             	shr    $0x3,%eax
   124a0:	c1 e0 03             	shl    $0x3,%eax
   124a3:	83 ec 0c             	sub    $0xc,%esp
   124a6:	ff 75 18             	pushl  0x18(%ebp)
   124a9:	52                   	push   %edx
   124aa:	50                   	push   %eax
   124ab:	ff 75 10             	pushl  0x10(%ebp)
   124ae:	ff 75 d8             	pushl  -0x28(%ebp)
   124b1:	e8 e7 fb ff ff       	call   1209d <addPaddingBits>
   124b6:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   124b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   124bc:	8d 50 0c             	lea    0xc(%eax),%edx
   124bf:	8b 45 08             	mov    0x8(%ebp),%eax
   124c2:	8b 00                	mov    (%eax),%eax
   124c4:	83 ec 08             	sub    $0x8,%esp
   124c7:	ff 75 20             	pushl  0x20(%ebp)
   124ca:	52                   	push   %edx
   124cb:	ff 75 18             	pushl  0x18(%ebp)
   124ce:	ff 75 14             	pushl  0x14(%ebp)
   124d1:	ff 75 d8             	pushl  -0x28(%ebp)
   124d4:	50                   	push   %eax
   124d5:	e8 dc f3 ff ff       	call   118b6 <filter>
   124da:	83 c4 20             	add    $0x20,%esp
   124dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   124e0:	83 ec 0c             	sub    $0xc,%esp
   124e3:	ff 75 d8             	pushl  -0x28(%ebp)
   124e6:	e8 4c 0e ff ff       	call   3337 <lodepng_free>
   124eb:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   124ee:	e9 34 02 00 00       	jmp    12727 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   124f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   124f6:	8d 50 0c             	lea    0xc(%eax),%edx
   124f9:	8b 45 08             	mov    0x8(%ebp),%eax
   124fc:	8b 00                	mov    (%eax),%eax
   124fe:	83 ec 08             	sub    $0x8,%esp
   12501:	ff 75 20             	pushl  0x20(%ebp)
   12504:	52                   	push   %edx
   12505:	ff 75 18             	pushl  0x18(%ebp)
   12508:	ff 75 14             	pushl  0x14(%ebp)
   1250b:	ff 75 10             	pushl  0x10(%ebp)
   1250e:	50                   	push   %eax
   1250f:	e8 a2 f3 ff ff       	call   118b6 <filter>
   12514:	83 c4 20             	add    $0x20,%esp
   12517:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   1251a:	e9 08 02 00 00       	jmp    12727 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1251f:	ff 75 dc             	pushl  -0x24(%ebp)
   12522:	ff 75 18             	pushl  0x18(%ebp)
   12525:	ff 75 14             	pushl  0x14(%ebp)
   12528:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1252e:	50                   	push   %eax
   1252f:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12535:	50                   	push   %eax
   12536:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   1253c:	50                   	push   %eax
   1253d:	8d 45 98             	lea    -0x68(%ebp),%eax
   12540:	50                   	push   %eax
   12541:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12544:	50                   	push   %eax
   12545:	e8 19 ab ff ff       	call   d063 <Adam7_getpassvalues>
   1254a:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   1254d:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12553:	8b 45 0c             	mov    0xc(%ebp),%eax
   12556:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12558:	8b 45 0c             	mov    0xc(%ebp),%eax
   1255b:	8b 00                	mov    (%eax),%eax
   1255d:	83 ec 0c             	sub    $0xc,%esp
   12560:	50                   	push   %eax
   12561:	e8 b0 0d ff ff       	call   3316 <lodepng_malloc>
   12566:	83 c4 10             	add    $0x10,%esp
   12569:	89 c2                	mov    %eax,%edx
   1256b:	8b 45 08             	mov    0x8(%ebp),%eax
   1256e:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   12570:	8b 45 08             	mov    0x8(%ebp),%eax
   12573:	8b 00                	mov    (%eax),%eax
   12575:	85 c0                	test   %eax,%eax
   12577:	75 07                	jne    12580 <preProcessScanlines+0x1dd>
   12579:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   12580:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12583:	83 ec 0c             	sub    $0xc,%esp
   12586:	50                   	push   %eax
   12587:	e8 8a 0d ff ff       	call   3316 <lodepng_malloc>
   1258c:	83 c4 10             	add    $0x10,%esp
   1258f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   12592:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12596:	75 0e                	jne    125a6 <preProcessScanlines+0x203>
   12598:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1259b:	85 c0                	test   %eax,%eax
   1259d:	74 07                	je     125a6 <preProcessScanlines+0x203>
   1259f:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   125a6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   125aa:	0f 85 69 01 00 00    	jne    12719 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   125b0:	83 ec 0c             	sub    $0xc,%esp
   125b3:	ff 75 dc             	pushl  -0x24(%ebp)
   125b6:	ff 75 18             	pushl  0x18(%ebp)
   125b9:	ff 75 14             	pushl  0x14(%ebp)
   125bc:	ff 75 10             	pushl  0x10(%ebp)
   125bf:	ff 75 d4             	pushl  -0x2c(%ebp)
   125c2:	e8 6c fb ff ff       	call   12133 <Adam7_interlace>
   125c7:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   125ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   125d1:	e9 36 01 00 00       	jmp    1270c <preProcessScanlines+0x369>
        if(bpp < 8) {
   125d6:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   125da:	0f 87 d6 00 00 00    	ja     126b6 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   125e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125e3:	83 c0 01             	add    $0x1,%eax
   125e6:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   125ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125f0:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   125f7:	29 c2                	sub    %eax,%edx
   125f9:	89 d0                	mov    %edx,%eax
   125fb:	83 ec 0c             	sub    $0xc,%esp
   125fe:	50                   	push   %eax
   125ff:	e8 12 0d ff ff       	call   3316 <lodepng_malloc>
   12604:	83 c4 10             	add    $0x10,%esp
   12607:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   1260a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   1260e:	75 0c                	jne    1261c <preProcessScanlines+0x279>
   12610:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   12617:	e9 fd 00 00 00       	jmp    12719 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   1261c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1261f:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12623:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12626:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   1262a:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1262e:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12630:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12633:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12637:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   1263b:	83 c2 07             	add    $0x7,%edx
   1263e:	c1 ea 03             	shr    $0x3,%edx
   12641:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12644:	89 d1                	mov    %edx,%ecx
   12646:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12649:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   12650:	89 d6                	mov    %edx,%esi
   12652:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12655:	01 f2                	add    %esi,%edx
   12657:	83 ec 0c             	sub    $0xc,%esp
   1265a:	50                   	push   %eax
   1265b:	53                   	push   %ebx
   1265c:	51                   	push   %ecx
   1265d:	52                   	push   %edx
   1265e:	ff 75 d0             	pushl  -0x30(%ebp)
   12661:	e8 37 fa ff ff       	call   1209d <addPaddingBits>
   12666:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12669:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1266c:	8d 58 0c             	lea    0xc(%eax),%ebx
   1266f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12672:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12676:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12679:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1267d:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12680:	8b 31                	mov    (%ecx),%esi
   12682:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12685:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   1268c:	01 f1                	add    %esi,%ecx
   1268e:	83 ec 08             	sub    $0x8,%esp
   12691:	ff 75 20             	pushl  0x20(%ebp)
   12694:	53                   	push   %ebx
   12695:	52                   	push   %edx
   12696:	50                   	push   %eax
   12697:	ff 75 d0             	pushl  -0x30(%ebp)
   1269a:	51                   	push   %ecx
   1269b:	e8 16 f2 ff ff       	call   118b6 <filter>
   126a0:	83 c4 20             	add    $0x20,%esp
   126a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   126a6:	83 ec 0c             	sub    $0xc,%esp
   126a9:	ff 75 d0             	pushl  -0x30(%ebp)
   126ac:	e8 86 0c ff ff       	call   3337 <lodepng_free>
   126b1:	83 c4 10             	add    $0x10,%esp
   126b4:	eb 4c                	jmp    12702 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   126b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   126b9:	8d 70 0c             	lea    0xc(%eax),%esi
   126bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126bf:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   126c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126c6:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   126ca:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126cd:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   126d4:	89 cb                	mov    %ecx,%ebx
   126d6:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   126d9:	01 cb                	add    %ecx,%ebx
   126db:	8b 4d 08             	mov    0x8(%ebp),%ecx
   126de:	8b 39                	mov    (%ecx),%edi
   126e0:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126e3:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   126ea:	01 f9                	add    %edi,%ecx
   126ec:	83 ec 08             	sub    $0x8,%esp
   126ef:	ff 75 20             	pushl  0x20(%ebp)
   126f2:	56                   	push   %esi
   126f3:	52                   	push   %edx
   126f4:	50                   	push   %eax
   126f5:	53                   	push   %ebx
   126f6:	51                   	push   %ecx
   126f7:	e8 ba f1 ff ff       	call   118b6 <filter>
   126fc:	83 c4 20             	add    $0x20,%esp
   126ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12702:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12706:	75 10                	jne    12718 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12708:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   1270c:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   12710:	0f 85 c0 fe ff ff    	jne    125d6 <preProcessScanlines+0x233>
   12716:	eb 01                	jmp    12719 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12718:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12719:	83 ec 0c             	sub    $0xc,%esp
   1271c:	ff 75 d4             	pushl  -0x2c(%ebp)
   1271f:	e8 13 0c ff ff       	call   3337 <lodepng_free>
   12724:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12727:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   1272a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1272d:	5b                   	pop    %ebx
   1272e:	5e                   	pop    %esi
   1272f:	5f                   	pop    %edi
   12730:	5d                   	pop    %ebp
   12731:	c3                   	ret    

00012732 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   12732:	55                   	push   %ebp
   12733:	89 e5                	mov    %esp,%ebp
   12735:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12738:	8b 45 0c             	mov    0xc(%ebp),%eax
   1273b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   1273e:	eb 47                	jmp    12787 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12740:	8b 45 08             	mov    0x8(%ebp),%eax
   12743:	8d 50 04             	lea    0x4(%eax),%edx
   12746:	8b 45 08             	mov    0x8(%ebp),%eax
   12749:	ff 75 fc             	pushl  -0x4(%ebp)
   1274c:	52                   	push   %edx
   1274d:	50                   	push   %eax
   1274e:	e8 73 5f ff ff       	call   86c6 <lodepng_chunk_append>
   12753:	83 c4 0c             	add    $0xc,%esp
   12756:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12759:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1275d:	74 05                	je     12764 <addUnknownChunks+0x32>
   1275f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12762:	eb 37                	jmp    1279b <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12764:	8b 45 08             	mov    0x8(%ebp),%eax
   12767:	8b 50 04             	mov    0x4(%eax),%edx
   1276a:	8b 45 08             	mov    0x8(%ebp),%eax
   1276d:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   12770:	8b 55 10             	mov    0x10(%ebp),%edx
   12773:	8b 45 0c             	mov    0xc(%ebp),%eax
   12776:	01 d0                	add    %edx,%eax
   12778:	50                   	push   %eax
   12779:	ff 75 fc             	pushl  -0x4(%ebp)
   1277c:	e8 ff 5c ff ff       	call   8480 <lodepng_chunk_next>
   12781:	83 c4 08             	add    $0x8,%esp
   12784:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12787:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1278a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1278d:	29 c2                	sub    %eax,%edx
   1278f:	89 d0                	mov    %edx,%eax
   12791:	3b 45 10             	cmp    0x10(%ebp),%eax
   12794:	7c aa                	jl     12740 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12796:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1279b:	c9                   	leave  
   1279c:	c3                   	ret    

0001279d <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   1279d:	55                   	push   %ebp
   1279e:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   127a0:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   127a4:	77 07                	ja     127ad <isGrayICCProfile+0x10>
   127a6:	b8 00 00 00 00       	mov    $0x0,%eax
   127ab:	eb 40                	jmp    127ed <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   127ad:	8b 45 08             	mov    0x8(%ebp),%eax
   127b0:	83 c0 10             	add    $0x10,%eax
   127b3:	0f b6 00             	movzbl (%eax),%eax
   127b6:	3c 47                	cmp    $0x47,%al
   127b8:	75 2e                	jne    127e8 <isGrayICCProfile+0x4b>
   127ba:	8b 45 08             	mov    0x8(%ebp),%eax
   127bd:	83 c0 11             	add    $0x11,%eax
   127c0:	0f b6 00             	movzbl (%eax),%eax
   127c3:	3c 52                	cmp    $0x52,%al
   127c5:	75 21                	jne    127e8 <isGrayICCProfile+0x4b>
   127c7:	8b 45 08             	mov    0x8(%ebp),%eax
   127ca:	83 c0 12             	add    $0x12,%eax
   127cd:	0f b6 00             	movzbl (%eax),%eax
   127d0:	3c 41                	cmp    $0x41,%al
   127d2:	75 14                	jne    127e8 <isGrayICCProfile+0x4b>
   127d4:	8b 45 08             	mov    0x8(%ebp),%eax
   127d7:	83 c0 13             	add    $0x13,%eax
   127da:	0f b6 00             	movzbl (%eax),%eax
   127dd:	3c 59                	cmp    $0x59,%al
   127df:	75 07                	jne    127e8 <isGrayICCProfile+0x4b>
   127e1:	b8 01 00 00 00       	mov    $0x1,%eax
   127e6:	eb 05                	jmp    127ed <isGrayICCProfile+0x50>
   127e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127ed:	5d                   	pop    %ebp
   127ee:	c3                   	ret    

000127ef <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   127ef:	55                   	push   %ebp
   127f0:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   127f2:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   127f6:	77 07                	ja     127ff <isRGBICCProfile+0x10>
   127f8:	b8 00 00 00 00       	mov    $0x0,%eax
   127fd:	eb 40                	jmp    1283f <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   127ff:	8b 45 08             	mov    0x8(%ebp),%eax
   12802:	83 c0 10             	add    $0x10,%eax
   12805:	0f b6 00             	movzbl (%eax),%eax
   12808:	3c 52                	cmp    $0x52,%al
   1280a:	75 2e                	jne    1283a <isRGBICCProfile+0x4b>
   1280c:	8b 45 08             	mov    0x8(%ebp),%eax
   1280f:	83 c0 11             	add    $0x11,%eax
   12812:	0f b6 00             	movzbl (%eax),%eax
   12815:	3c 47                	cmp    $0x47,%al
   12817:	75 21                	jne    1283a <isRGBICCProfile+0x4b>
   12819:	8b 45 08             	mov    0x8(%ebp),%eax
   1281c:	83 c0 12             	add    $0x12,%eax
   1281f:	0f b6 00             	movzbl (%eax),%eax
   12822:	3c 42                	cmp    $0x42,%al
   12824:	75 14                	jne    1283a <isRGBICCProfile+0x4b>
   12826:	8b 45 08             	mov    0x8(%ebp),%eax
   12829:	83 c0 13             	add    $0x13,%eax
   1282c:	0f b6 00             	movzbl (%eax),%eax
   1282f:	3c 20                	cmp    $0x20,%al
   12831:	75 07                	jne    1283a <isRGBICCProfile+0x4b>
   12833:	b8 01 00 00 00       	mov    $0x1,%eax
   12838:	eb 05                	jmp    1283f <isRGBICCProfile+0x50>
   1283a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1283f:	5d                   	pop    %ebp
   12840:	c3                   	ret    

00012841 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12841:	55                   	push   %ebp
   12842:	89 e5                	mov    %esp,%ebp
   12844:	57                   	push   %edi
   12845:	56                   	push   %esi
   12846:	53                   	push   %ebx
   12847:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   1284d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12854:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   1285b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1285e:	6a 00                	push   $0x0
   12860:	6a 00                	push   $0x0
   12862:	50                   	push   %eax
   12863:	e8 6f 0d ff ff       	call   35d7 <ucvector_init>
   12868:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   1286b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1286e:	05 98 00 00 00       	add    $0x98,%eax
   12873:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12876:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1287c:	50                   	push   %eax
   1287d:	e8 3a 71 ff ff       	call   99bc <lodepng_info_init>
   12882:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12885:	8b 45 08             	mov    0x8(%ebp),%eax
   12888:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   1288e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12891:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12897:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1289a:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   128a1:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   128a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128a7:	8b 40 0c             	mov    0xc(%eax),%eax
   128aa:	83 f8 03             	cmp    $0x3,%eax
   128ad:	74 0a                	je     128b9 <lodepng_encode+0x78>
   128af:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128b2:	8b 40 6c             	mov    0x6c(%eax),%eax
   128b5:	85 c0                	test   %eax,%eax
   128b7:	74 29                	je     128e2 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   128b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128bc:	8b 40 18             	mov    0x18(%eax),%eax
   128bf:	85 c0                	test   %eax,%eax
   128c1:	74 0d                	je     128d0 <lodepng_encode+0x8f>
   128c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128c6:	8b 40 18             	mov    0x18(%eax),%eax
   128c9:	3d 00 01 00 00       	cmp    $0x100,%eax
   128ce:	7e 12                	jle    128e2 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   128d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128d3:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   128da:	00 00 00 
    goto cleanup;
   128dd:	e9 78 0c 00 00       	jmp    1355a <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   128e2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128e5:	8b 40 38             	mov    0x38(%eax),%eax
   128e8:	83 f8 02             	cmp    $0x2,%eax
   128eb:	76 12                	jbe    128ff <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   128ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128f0:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   128f7:	00 00 00 
    goto cleanup;
   128fa:	e9 5b 0c 00 00       	jmp    1355a <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   128ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12902:	8b 40 08             	mov    0x8(%eax),%eax
   12905:	83 f8 01             	cmp    $0x1,%eax
   12908:	76 12                	jbe    1291c <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   1290a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1290d:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12914:	00 00 00 
    goto cleanup;
   12917:	e9 3e 0c 00 00       	jmp    1355a <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   1291c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1291f:	8b 50 10             	mov    0x10(%eax),%edx
   12922:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12925:	8b 40 0c             	mov    0xc(%eax),%eax
   12928:	52                   	push   %edx
   12929:	50                   	push   %eax
   1292a:	e8 a4 5f ff ff       	call   88d3 <checkColorValidity>
   1292f:	83 c4 08             	add    $0x8,%esp
   12932:	89 c2                	mov    %eax,%edx
   12934:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12937:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1293d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12940:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12946:	85 c0                	test   %eax,%eax
   12948:	0f 85 c6 0b 00 00    	jne    13514 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   1294e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12951:	8b 50 7c             	mov    0x7c(%eax),%edx
   12954:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12957:	8b 40 78             	mov    0x78(%eax),%eax
   1295a:	52                   	push   %edx
   1295b:	50                   	push   %eax
   1295c:	e8 72 5f ff ff       	call   88d3 <checkColorValidity>
   12961:	83 c4 08             	add    $0x8,%esp
   12964:	89 c2                	mov    %eax,%edx
   12966:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12969:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1296f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12972:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12978:	85 c0                	test   %eax,%eax
   1297a:	0f 85 97 0b 00 00    	jne    13517 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12980:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12983:	05 98 00 00 00       	add    $0x98,%eax
   12988:	83 ec 08             	sub    $0x8,%esp
   1298b:	50                   	push   %eax
   1298c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12992:	50                   	push   %eax
   12993:	e8 58 71 ff ff       	call   9af0 <lodepng_info_copy>
   12998:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   1299b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1299e:	8b 40 5c             	mov    0x5c(%eax),%eax
   129a1:	85 c0                	test   %eax,%eax
   129a3:	0f 84 3c 02 00 00    	je     12be5 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   129a9:	83 ec 0c             	sub    $0xc,%esp
   129ac:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   129b2:	50                   	push   %eax
   129b3:	e8 5f 96 ff ff       	call   c017 <lodepng_color_stats_init>
   129b8:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129be:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   129c4:	85 c0                	test   %eax,%eax
   129c6:	74 2d                	je     129f5 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   129c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129cb:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   129d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129d4:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   129da:	83 ec 08             	sub    $0x8,%esp
   129dd:	52                   	push   %edx
   129de:	50                   	push   %eax
   129df:	e8 b9 fd ff ff       	call   1279d <isGrayICCProfile>
   129e4:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129e7:	85 c0                	test   %eax,%eax
   129e9:	74 0a                	je     129f5 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   129eb:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   129f2:	00 00 00 
    }
    if(info_png->iccp_defined &&
   129f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129f8:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   129fe:	85 c0                	test   %eax,%eax
   12a00:	74 2d                	je     12a2f <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12a02:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a05:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12a0b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a0e:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12a14:	83 ec 08             	sub    $0x8,%esp
   12a17:	52                   	push   %edx
   12a18:	50                   	push   %eax
   12a19:	e8 d1 fd ff ff       	call   127ef <isRGBICCProfile>
   12a1e:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12a21:	85 c0                	test   %eax,%eax
   12a23:	74 0a                	je     12a2f <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12a25:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12a2c:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12a2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a32:	83 c0 78             	add    $0x78,%eax
   12a35:	83 ec 0c             	sub    $0xc,%esp
   12a38:	50                   	push   %eax
   12a39:	ff 75 18             	pushl  0x18(%ebp)
   12a3c:	ff 75 14             	pushl  0x14(%ebp)
   12a3f:	ff 75 10             	pushl  0x10(%ebp)
   12a42:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a48:	50                   	push   %eax
   12a49:	e8 e0 96 ff ff       	call   c12e <lodepng_compute_color_stats>
   12a4e:	83 c4 20             	add    $0x20,%esp
   12a51:	89 c2                	mov    %eax,%edx
   12a53:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a56:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12a5c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a5f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a65:	85 c0                	test   %eax,%eax
   12a67:	0f 85 ad 0a 00 00    	jne    1351a <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12a6d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a70:	8b 40 2c             	mov    0x2c(%eax),%eax
   12a73:	85 c0                	test   %eax,%eax
   12a75:	0f 84 be 00 00 00    	je     12b39 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12a7b:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12a82:	00 00 00 
   12a85:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12a8c:	00 00 00 
   12a8f:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12a96:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12a99:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12a9f:	83 ec 04             	sub    $0x4,%esp
   12aa2:	6a 10                	push   $0x10
   12aa4:	6a 02                	push   $0x2
   12aa6:	50                   	push   %eax
   12aa7:	e8 15 61 ff ff       	call   8bc1 <lodepng_color_mode_make>
   12aac:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12aaf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ab2:	8d 58 0c             	lea    0xc(%eax),%ebx
   12ab5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ab8:	8b 48 38             	mov    0x38(%eax),%ecx
   12abb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12abe:	8b 50 34             	mov    0x34(%eax),%edx
   12ac1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ac4:	8b 40 30             	mov    0x30(%eax),%eax
   12ac7:	53                   	push   %ebx
   12ac8:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12ace:	53                   	push   %ebx
   12acf:	51                   	push   %ecx
   12ad0:	52                   	push   %edx
   12ad1:	50                   	push   %eax
   12ad2:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12ad8:	50                   	push   %eax
   12ad9:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12adf:	50                   	push   %eax
   12ae0:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12ae6:	50                   	push   %eax
   12ae7:	e8 8a 92 ff ff       	call   bd76 <lodepng_convert_rgb>
   12aec:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12aef:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12af5:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12afb:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12b01:	83 ec 0c             	sub    $0xc,%esp
   12b04:	68 ff ff 00 00       	push   $0xffff
   12b09:	51                   	push   %ecx
   12b0a:	52                   	push   %edx
   12b0b:	50                   	push   %eax
   12b0c:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b12:	50                   	push   %eax
   12b13:	e8 26 a1 ff ff       	call   cc3e <lodepng_color_stats_add>
   12b18:	83 c4 20             	add    $0x20,%esp
   12b1b:	89 c2                	mov    %eax,%edx
   12b1d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b20:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12b26:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b29:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b2f:	85 c0                	test   %eax,%eax
   12b31:	74 06                	je     12b39 <lodepng_encode+0x2f8>
   12b33:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12b34:	e9 e1 09 00 00       	jmp    1351a <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12b39:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b3c:	8d 50 78             	lea    0x78(%eax),%edx
   12b3f:	83 ec 04             	sub    $0x4,%esp
   12b42:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b48:	50                   	push   %eax
   12b49:	52                   	push   %edx
   12b4a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b50:	83 c0 0c             	add    $0xc,%eax
   12b53:	50                   	push   %eax
   12b54:	e8 79 a1 ff ff       	call   ccd2 <auto_choose_color>
   12b59:	83 c4 10             	add    $0x10,%esp
   12b5c:	89 c2                	mov    %eax,%edx
   12b5e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b61:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12b67:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b6a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b70:	85 c0                	test   %eax,%eax
   12b72:	0f 85 a5 09 00 00    	jne    1351d <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12b78:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b7b:	8b 40 2c             	mov    0x2c(%eax),%eax
   12b7e:	85 c0                	test   %eax,%eax
   12b80:	74 63                	je     12be5 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12b82:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b85:	8d 58 0c             	lea    0xc(%eax),%ebx
   12b88:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b8b:	8b 48 38             	mov    0x38(%eax),%ecx
   12b8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b91:	8b 50 34             	mov    0x34(%eax),%edx
   12b94:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b97:	8b 40 30             	mov    0x30(%eax),%eax
   12b9a:	53                   	push   %ebx
   12b9b:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12ba1:	83 c3 0c             	add    $0xc,%ebx
   12ba4:	53                   	push   %ebx
   12ba5:	51                   	push   %ecx
   12ba6:	52                   	push   %edx
   12ba7:	50                   	push   %eax
   12ba8:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bae:	83 c0 38             	add    $0x38,%eax
   12bb1:	50                   	push   %eax
   12bb2:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bb8:	83 c0 34             	add    $0x34,%eax
   12bbb:	50                   	push   %eax
   12bbc:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bc2:	83 c0 30             	add    $0x30,%eax
   12bc5:	50                   	push   %eax
   12bc6:	e8 ab 91 ff ff       	call   bd76 <lodepng_convert_rgb>
   12bcb:	83 c4 20             	add    $0x20,%esp
   12bce:	85 c0                	test   %eax,%eax
   12bd0:	74 13                	je     12be5 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12bd2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bd5:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12bdc:	00 00 00 
        goto cleanup;
   12bdf:	90                   	nop
   12be0:	e9 75 09 00 00       	jmp    1355a <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12be5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12be8:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12bee:	85 c0                	test   %eax,%eax
   12bf0:	0f 84 b2 00 00 00    	je     12ca8 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12bf6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bf9:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12bff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c02:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c08:	83 ec 08             	sub    $0x8,%esp
   12c0b:	52                   	push   %edx
   12c0c:	50                   	push   %eax
   12c0d:	e8 8b fb ff ff       	call   1279d <isGrayICCProfile>
   12c12:	83 c4 10             	add    $0x10,%esp
   12c15:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c18:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c1b:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c21:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c24:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c2a:	83 ec 08             	sub    $0x8,%esp
   12c2d:	52                   	push   %edx
   12c2e:	50                   	push   %eax
   12c2f:	e8 bb fb ff ff       	call   127ef <isRGBICCProfile>
   12c34:	83 c4 10             	add    $0x10,%esp
   12c37:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12c3a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c40:	85 c0                	test   %eax,%eax
   12c42:	74 0b                	je     12c4f <lodepng_encode+0x40e>
   12c44:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c4a:	83 f8 04             	cmp    $0x4,%eax
   12c4d:	75 07                	jne    12c56 <lodepng_encode+0x415>
   12c4f:	b8 01 00 00 00       	mov    $0x1,%eax
   12c54:	eb 05                	jmp    12c5b <lodepng_encode+0x41a>
   12c56:	b8 00 00 00 00       	mov    $0x0,%eax
   12c5b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12c5e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12c62:	75 18                	jne    12c7c <lodepng_encode+0x43b>
   12c64:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12c68:	75 12                	jne    12c7c <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12c6a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c6d:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12c74:	00 00 00 
      goto cleanup;
   12c77:	e9 de 08 00 00       	jmp    1355a <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12c7c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12c7f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12c82:	74 24                	je     12ca8 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12c84:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c87:	8b 40 5c             	mov    0x5c(%eax),%eax
   12c8a:	85 c0                	test   %eax,%eax
   12c8c:	74 07                	je     12c95 <lodepng_encode+0x454>
   12c8e:	ba 66 00 00 00       	mov    $0x66,%edx
   12c93:	eb 05                	jmp    12c9a <lodepng_encode+0x459>
   12c95:	ba 65 00 00 00       	mov    $0x65,%edx
   12c9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c9d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12ca3:	e9 b2 08 00 00       	jmp    1355a <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12ca8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cab:	83 c0 78             	add    $0x78,%eax
   12cae:	83 ec 08             	sub    $0x8,%esp
   12cb1:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12cb7:	83 c2 0c             	add    $0xc,%edx
   12cba:	52                   	push   %edx
   12cbb:	50                   	push   %eax
   12cbc:	e8 57 5f ff ff       	call   8c18 <lodepng_color_mode_equal>
   12cc1:	83 c4 10             	add    $0x10,%esp
   12cc4:	85 c0                	test   %eax,%eax
   12cc6:	0f 85 f8 00 00 00    	jne    12dc4 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12ccc:	8b 55 14             	mov    0x14(%ebp),%edx
   12ccf:	8b 45 18             	mov    0x18(%ebp),%eax
   12cd2:	89 d3                	mov    %edx,%ebx
   12cd4:	0f af d8             	imul   %eax,%ebx
   12cd7:	83 ec 0c             	sub    $0xc,%esp
   12cda:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ce0:	83 c0 0c             	add    $0xc,%eax
   12ce3:	50                   	push   %eax
   12ce4:	e8 49 61 ff ff       	call   8e32 <lodepng_get_bpp>
   12ce9:	83 c4 10             	add    $0x10,%esp
   12cec:	0f af c3             	imul   %ebx,%eax
   12cef:	83 c0 07             	add    $0x7,%eax
   12cf2:	c1 e8 03             	shr    $0x3,%eax
   12cf5:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12cf8:	83 ec 0c             	sub    $0xc,%esp
   12cfb:	ff 75 cc             	pushl  -0x34(%ebp)
   12cfe:	e8 13 06 ff ff       	call   3316 <lodepng_malloc>
   12d03:	83 c4 10             	add    $0x10,%esp
   12d06:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12d09:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12d0d:	75 13                	jne    12d22 <lodepng_encode+0x4e1>
   12d0f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12d13:	74 0d                	je     12d22 <lodepng_encode+0x4e1>
   12d15:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d18:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12d1f:	00 00 00 
    if(!state->error) {
   12d22:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d25:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d2b:	85 c0                	test   %eax,%eax
   12d2d:	75 33                	jne    12d62 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12d2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d32:	83 c0 78             	add    $0x78,%eax
   12d35:	83 ec 08             	sub    $0x8,%esp
   12d38:	ff 75 18             	pushl  0x18(%ebp)
   12d3b:	ff 75 14             	pushl  0x14(%ebp)
   12d3e:	50                   	push   %eax
   12d3f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d45:	83 c0 0c             	add    $0xc,%eax
   12d48:	50                   	push   %eax
   12d49:	ff 75 10             	pushl  0x10(%ebp)
   12d4c:	ff 75 c8             	pushl  -0x38(%ebp)
   12d4f:	e8 c9 8c ff ff       	call   ba1d <lodepng_convert>
   12d54:	83 c4 20             	add    $0x20,%esp
   12d57:	89 c2                	mov    %eax,%edx
   12d59:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d5c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12d62:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d65:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d6b:	85 c0                	test   %eax,%eax
   12d6d:	75 35                	jne    12da4 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12d6f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d72:	83 c0 38             	add    $0x38,%eax
   12d75:	83 ec 04             	sub    $0x4,%esp
   12d78:	50                   	push   %eax
   12d79:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d7f:	50                   	push   %eax
   12d80:	ff 75 18             	pushl  0x18(%ebp)
   12d83:	ff 75 14             	pushl  0x14(%ebp)
   12d86:	ff 75 c8             	pushl  -0x38(%ebp)
   12d89:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12d8c:	50                   	push   %eax
   12d8d:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12d90:	50                   	push   %eax
   12d91:	e8 0d f6 ff ff       	call   123a3 <preProcessScanlines>
   12d96:	83 c4 20             	add    $0x20,%esp
   12d99:	89 c2                	mov    %eax,%edx
   12d9b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d9e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12da4:	83 ec 0c             	sub    $0xc,%esp
   12da7:	ff 75 c8             	pushl  -0x38(%ebp)
   12daa:	e8 88 05 ff ff       	call   3337 <lodepng_free>
   12daf:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12db2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12db5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12dbb:	85 c0                	test   %eax,%eax
   12dbd:	74 4b                	je     12e0a <lodepng_encode+0x5c9>
   12dbf:	e9 96 07 00 00       	jmp    1355a <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12dc4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc7:	83 c0 38             	add    $0x38,%eax
   12dca:	83 ec 04             	sub    $0x4,%esp
   12dcd:	50                   	push   %eax
   12dce:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12dd4:	50                   	push   %eax
   12dd5:	ff 75 18             	pushl  0x18(%ebp)
   12dd8:	ff 75 14             	pushl  0x14(%ebp)
   12ddb:	ff 75 10             	pushl  0x10(%ebp)
   12dde:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12de1:	50                   	push   %eax
   12de2:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12de5:	50                   	push   %eax
   12de6:	e8 b8 f5 ff ff       	call   123a3 <preProcessScanlines>
   12deb:	83 c4 20             	add    $0x20,%esp
   12dee:	89 c2                	mov    %eax,%edx
   12df0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12df3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12df9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dfc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e02:	85 c0                	test   %eax,%eax
   12e04:	0f 85 16 07 00 00    	jne    13520 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12e0a:	83 ec 0c             	sub    $0xc,%esp
   12e0d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e10:	50                   	push   %eax
   12e11:	e8 21 d9 ff ff       	call   10737 <writeSignature>
   12e16:	83 c4 10             	add    $0x10,%esp
   12e19:	89 c2                	mov    %eax,%edx
   12e1b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e1e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e24:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e27:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e2d:	85 c0                	test   %eax,%eax
   12e2f:	0f 85 ee 06 00 00    	jne    13523 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12e35:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12e3b:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12e41:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12e47:	83 ec 08             	sub    $0x8,%esp
   12e4a:	51                   	push   %ecx
   12e4b:	52                   	push   %edx
   12e4c:	50                   	push   %eax
   12e4d:	ff 75 18             	pushl  0x18(%ebp)
   12e50:	ff 75 14             	pushl  0x14(%ebp)
   12e53:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e56:	50                   	push   %eax
   12e57:	e8 4a d9 ff ff       	call   107a6 <addChunk_IHDR>
   12e5c:	83 c4 20             	add    $0x20,%esp
   12e5f:	89 c2                	mov    %eax,%edx
   12e61:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e64:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e6a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e6d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e73:	85 c0                	test   %eax,%eax
   12e75:	0f 85 ab 06 00 00    	jne    13526 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12e7b:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e7e:	85 c0                	test   %eax,%eax
   12e80:	74 33                	je     12eb5 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12e82:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12e85:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e88:	83 ec 04             	sub    $0x4,%esp
   12e8b:	52                   	push   %edx
   12e8c:	50                   	push   %eax
   12e8d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e90:	50                   	push   %eax
   12e91:	e8 9c f8 ff ff       	call   12732 <addUnknownChunks>
   12e96:	83 c4 10             	add    $0x10,%esp
   12e99:	89 c2                	mov    %eax,%edx
   12e9b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e9e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ea4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ea7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ead:	85 c0                	test   %eax,%eax
   12eaf:	0f 85 74 06 00 00    	jne    13529 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12eb5:	8b 45 88             	mov    -0x78(%ebp),%eax
   12eb8:	85 c0                	test   %eax,%eax
   12eba:	74 39                	je     12ef5 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12ebc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ebf:	83 c0 38             	add    $0x38,%eax
   12ec2:	83 ec 04             	sub    $0x4,%esp
   12ec5:	50                   	push   %eax
   12ec6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ecc:	50                   	push   %eax
   12ecd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12ed0:	50                   	push   %eax
   12ed1:	e8 a4 e4 ff ff       	call   1137a <addChunk_iCCP>
   12ed6:	83 c4 10             	add    $0x10,%esp
   12ed9:	89 c2                	mov    %eax,%edx
   12edb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ede:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ee4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ee7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12eed:	85 c0                	test   %eax,%eax
   12eef:	0f 85 37 06 00 00    	jne    1352c <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12ef5:	8b 45 80             	mov    -0x80(%ebp),%eax
   12ef8:	85 c0                	test   %eax,%eax
   12efa:	74 32                	je     12f2e <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12efc:	83 ec 08             	sub    $0x8,%esp
   12eff:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f05:	50                   	push   %eax
   12f06:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f09:	50                   	push   %eax
   12f0a:	e8 41 e4 ff ff       	call   11350 <addChunk_sRGB>
   12f0f:	83 c4 10             	add    $0x10,%esp
   12f12:	89 c2                	mov    %eax,%edx
   12f14:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f17:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f1d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f20:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f26:	85 c0                	test   %eax,%eax
   12f28:	0f 85 01 06 00 00    	jne    1352f <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   12f2e:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   12f34:	85 c0                	test   %eax,%eax
   12f36:	74 32                	je     12f6a <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   12f38:	83 ec 08             	sub    $0x8,%esp
   12f3b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f41:	50                   	push   %eax
   12f42:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f45:	50                   	push   %eax
   12f46:	e8 a7 e2 ff ff       	call   111f2 <addChunk_gAMA>
   12f4b:	83 c4 10             	add    $0x10,%esp
   12f4e:	89 c2                	mov    %eax,%edx
   12f50:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f53:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f59:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f5c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f62:	85 c0                	test   %eax,%eax
   12f64:	0f 85 c8 05 00 00    	jne    13532 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   12f6a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   12f70:	85 c0                	test   %eax,%eax
   12f72:	74 32                	je     12fa6 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   12f74:	83 ec 08             	sub    $0x8,%esp
   12f77:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f7d:	50                   	push   %eax
   12f7e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f81:	50                   	push   %eax
   12f82:	e8 c1 e2 ff ff       	call   11248 <addChunk_cHRM>
   12f87:	83 c4 10             	add    $0x10,%esp
   12f8a:	89 c2                	mov    %eax,%edx
   12f8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f8f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f98:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f9e:	85 c0                	test   %eax,%eax
   12fa0:	0f 85 8f 05 00 00    	jne    13535 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   12fa6:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12fac:	83 f8 03             	cmp    $0x3,%eax
   12faf:	75 35                	jne    12fe6 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   12fb1:	83 ec 08             	sub    $0x8,%esp
   12fb4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fba:	83 c0 0c             	add    $0xc,%eax
   12fbd:	50                   	push   %eax
   12fbe:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fc1:	50                   	push   %eax
   12fc2:	e8 78 d8 ff ff       	call   1083f <addChunk_PLTE>
   12fc7:	83 c4 10             	add    $0x10,%esp
   12fca:	89 c2                	mov    %eax,%edx
   12fcc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fcf:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fd5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fd8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fde:	85 c0                	test   %eax,%eax
   12fe0:	0f 85 52 05 00 00    	jne    13538 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   12fe6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fe9:	8b 40 6c             	mov    0x6c(%eax),%eax
   12fec:	85 c0                	test   %eax,%eax
   12fee:	74 4b                	je     1303b <lodepng_encode+0x7fa>
   12ff0:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12ff6:	83 f8 02             	cmp    $0x2,%eax
   12ff9:	74 0b                	je     13006 <lodepng_encode+0x7c5>
   12ffb:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13001:	83 f8 06             	cmp    $0x6,%eax
   13004:	75 35                	jne    1303b <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   13006:	83 ec 08             	sub    $0x8,%esp
   13009:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1300f:	83 c0 0c             	add    $0xc,%eax
   13012:	50                   	push   %eax
   13013:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13016:	50                   	push   %eax
   13017:	e8 23 d8 ff ff       	call   1083f <addChunk_PLTE>
   1301c:	83 c4 10             	add    $0x10,%esp
   1301f:	89 c2                	mov    %eax,%edx
   13021:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13024:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1302a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1302d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13033:	85 c0                	test   %eax,%eax
   13035:	0f 85 00 05 00 00    	jne    1353b <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   1303b:	83 ec 08             	sub    $0x8,%esp
   1303e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13044:	83 c0 0c             	add    $0xc,%eax
   13047:	50                   	push   %eax
   13048:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1304b:	50                   	push   %eax
   1304c:	e8 c4 d8 ff ff       	call   10915 <addChunk_tRNS>
   13051:	83 c4 10             	add    $0x10,%esp
   13054:	89 c2                	mov    %eax,%edx
   13056:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13059:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1305f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13062:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13068:	85 c0                	test   %eax,%eax
   1306a:	0f 85 ce 04 00 00    	jne    1353e <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   13070:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13076:	85 c0                	test   %eax,%eax
   13078:	74 32                	je     130ac <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   1307a:	83 ec 08             	sub    $0x8,%esp
   1307d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13083:	50                   	push   %eax
   13084:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13087:	50                   	push   %eax
   13088:	e8 e4 de ff ff       	call   10f71 <addChunk_bKGD>
   1308d:	83 c4 10             	add    $0x10,%esp
   13090:	89 c2                	mov    %eax,%edx
   13092:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13095:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1309b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1309e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130a4:	85 c0                	test   %eax,%eax
   130a6:	0f 85 95 04 00 00    	jne    13541 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   130ac:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   130b2:	85 c0                	test   %eax,%eax
   130b4:	74 32                	je     130e8 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   130b6:	83 ec 08             	sub    $0x8,%esp
   130b9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130bf:	50                   	push   %eax
   130c0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130c3:	50                   	push   %eax
   130c4:	e8 ac e0 ff ff       	call   11175 <addChunk_pHYs>
   130c9:	83 c4 10             	add    $0x10,%esp
   130cc:	89 c2                	mov    %eax,%edx
   130ce:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130d1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130da:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130e0:	85 c0                	test   %eax,%eax
   130e2:	0f 85 5c 04 00 00    	jne    13544 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   130e8:	8b 45 9c             	mov    -0x64(%ebp),%eax
   130eb:	85 c0                	test   %eax,%eax
   130ed:	74 33                	je     13122 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   130ef:	8b 55 a8             	mov    -0x58(%ebp),%edx
   130f2:	8b 45 9c             	mov    -0x64(%ebp),%eax
   130f5:	83 ec 04             	sub    $0x4,%esp
   130f8:	52                   	push   %edx
   130f9:	50                   	push   %eax
   130fa:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130fd:	50                   	push   %eax
   130fe:	e8 2f f6 ff ff       	call   12732 <addUnknownChunks>
   13103:	83 c4 10             	add    $0x10,%esp
   13106:	89 c2                	mov    %eax,%edx
   13108:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1310b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13111:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13114:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1311a:	85 c0                	test   %eax,%eax
   1311c:	0f 85 25 04 00 00    	jne    13547 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   13122:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13125:	8d 48 38             	lea    0x38(%eax),%ecx
   13128:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1312b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1312e:	51                   	push   %ecx
   1312f:	52                   	push   %edx
   13130:	50                   	push   %eax
   13131:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13134:	50                   	push   %eax
   13135:	e8 bd d9 ff ff       	call   10af7 <addChunk_IDAT>
   1313a:	83 c4 10             	add    $0x10,%esp
   1313d:	89 c2                	mov    %eax,%edx
   1313f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13142:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13148:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1314b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13151:	85 c0                	test   %eax,%eax
   13153:	0f 85 f1 03 00 00    	jne    1354a <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13159:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   1315f:	85 c0                	test   %eax,%eax
   13161:	74 35                	je     13198 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13163:	83 ec 08             	sub    $0x8,%esp
   13166:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1316c:	83 c0 60             	add    $0x60,%eax
   1316f:	50                   	push   %eax
   13170:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13173:	50                   	push   %eax
   13174:	e8 5c df ff ff       	call   110d5 <addChunk_tIME>
   13179:	83 c4 10             	add    $0x10,%esp
   1317c:	89 c2                	mov    %eax,%edx
   1317e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13181:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13187:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1318a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13190:	85 c0                	test   %eax,%eax
   13192:	0f 85 b5 03 00 00    	jne    1354d <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13198:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1319f:	e9 12 01 00 00       	jmp    132b6 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   131a4:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131aa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131ad:	c1 e2 02             	shl    $0x2,%edx
   131b0:	01 d0                	add    %edx,%eax
   131b2:	8b 00                	mov    (%eax),%eax
   131b4:	83 ec 0c             	sub    $0xc,%esp
   131b7:	50                   	push   %eax
   131b8:	e8 f5 01 ff ff       	call   33b2 <lodepng_strlen>
   131bd:	83 c4 10             	add    $0x10,%esp
   131c0:	83 f8 4f             	cmp    $0x4f,%eax
   131c3:	7e 12                	jle    131d7 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   131c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131c8:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   131cf:	00 00 00 
        goto cleanup;
   131d2:	e9 83 03 00 00       	jmp    1355a <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   131d7:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131dd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131e0:	c1 e2 02             	shl    $0x2,%edx
   131e3:	01 d0                	add    %edx,%eax
   131e5:	8b 00                	mov    (%eax),%eax
   131e7:	83 ec 0c             	sub    $0xc,%esp
   131ea:	50                   	push   %eax
   131eb:	e8 c2 01 ff ff       	call   33b2 <lodepng_strlen>
   131f0:	83 c4 10             	add    $0x10,%esp
   131f3:	85 c0                	test   %eax,%eax
   131f5:	7f 12                	jg     13209 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   131f7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131fa:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13201:	00 00 00 
        goto cleanup;
   13204:	e9 51 03 00 00       	jmp    1355a <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13209:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1320c:	8b 40 74             	mov    0x74(%eax),%eax
   1320f:	85 c0                	test   %eax,%eax
   13211:	74 52                	je     13265 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   13213:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13216:	8d 48 38             	lea    0x38(%eax),%ecx
   13219:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1321f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13222:	c1 e2 02             	shl    $0x2,%edx
   13225:	01 d0                	add    %edx,%eax
   13227:	8b 10                	mov    (%eax),%edx
   13229:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1322f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   13232:	c1 e3 02             	shl    $0x2,%ebx
   13235:	01 d8                	add    %ebx,%eax
   13237:	8b 00                	mov    (%eax),%eax
   13239:	51                   	push   %ecx
   1323a:	52                   	push   %edx
   1323b:	50                   	push   %eax
   1323c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1323f:	50                   	push   %eax
   13240:	e8 fa d9 ff ff       	call   10c3f <addChunk_zTXt>
   13245:	83 c4 10             	add    $0x10,%esp
   13248:	89 c2                	mov    %eax,%edx
   1324a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1324d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13253:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13256:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1325c:	85 c0                	test   %eax,%eax
   1325e:	74 52                	je     132b2 <lodepng_encode+0xa71>
   13260:	e9 f5 02 00 00       	jmp    1355a <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13265:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1326b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1326e:	c1 e2 02             	shl    $0x2,%edx
   13271:	01 d0                	add    %edx,%eax
   13273:	8b 10                	mov    (%eax),%edx
   13275:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1327b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1327e:	c1 e1 02             	shl    $0x2,%ecx
   13281:	01 c8                	add    %ecx,%eax
   13283:	8b 00                	mov    (%eax),%eax
   13285:	83 ec 04             	sub    $0x4,%esp
   13288:	52                   	push   %edx
   13289:	50                   	push   %eax
   1328a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1328d:	50                   	push   %eax
   1328e:	e8 ec d8 ff ff       	call   10b7f <addChunk_tEXt>
   13293:	83 c4 10             	add    $0x10,%esp
   13296:	89 c2                	mov    %eax,%edx
   13298:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1329b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   132a1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132aa:	85 c0                	test   %eax,%eax
   132ac:	0f 85 9e 02 00 00    	jne    13550 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   132b2:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   132b6:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   132bc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   132bf:	0f 85 df fe ff ff    	jne    131a4 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   132c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132c8:	8b 40 70             	mov    0x70(%eax),%eax
   132cb:	85 c0                	test   %eax,%eax
   132cd:	0f 84 e3 00 00 00    	je     133b6 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   132d3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   132da:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   132e1:	e9 85 00 00 00       	jmp    1336b <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   132e6:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132ec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   132ef:	c1 e2 02             	shl    $0x2,%edx
   132f2:	01 d0                	add    %edx,%eax
   132f4:	8b 00                	mov    (%eax),%eax
   132f6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   132f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   132fc:	0f b6 00             	movzbl (%eax),%eax
   132ff:	3c 4c                	cmp    $0x4c,%al
   13301:	75 64                	jne    13367 <lodepng_encode+0xb26>
   13303:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13306:	83 c0 01             	add    $0x1,%eax
   13309:	0f b6 00             	movzbl (%eax),%eax
   1330c:	3c 6f                	cmp    $0x6f,%al
   1330e:	75 57                	jne    13367 <lodepng_encode+0xb26>
   13310:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13313:	83 c0 02             	add    $0x2,%eax
   13316:	0f b6 00             	movzbl (%eax),%eax
   13319:	3c 64                	cmp    $0x64,%al
   1331b:	75 4a                	jne    13367 <lodepng_encode+0xb26>
   1331d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13320:	83 c0 03             	add    $0x3,%eax
   13323:	0f b6 00             	movzbl (%eax),%eax
   13326:	3c 65                	cmp    $0x65,%al
   13328:	75 3d                	jne    13367 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   1332a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1332d:	83 c0 04             	add    $0x4,%eax
   13330:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13333:	3c 50                	cmp    $0x50,%al
   13335:	75 30                	jne    13367 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13337:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1333a:	83 c0 05             	add    $0x5,%eax
   1333d:	0f b6 00             	movzbl (%eax),%eax
   13340:	3c 4e                	cmp    $0x4e,%al
   13342:	75 23                	jne    13367 <lodepng_encode+0xb26>
   13344:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13347:	83 c0 06             	add    $0x6,%eax
   1334a:	0f b6 00             	movzbl (%eax),%eax
   1334d:	3c 47                	cmp    $0x47,%al
   1334f:	75 16                	jne    13367 <lodepng_encode+0xb26>
   13351:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13354:	83 c0 07             	add    $0x7,%eax
   13357:	0f b6 00             	movzbl (%eax),%eax
   1335a:	84 c0                	test   %al,%al
   1335c:	75 09                	jne    13367 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   1335e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13365:	eb 13                	jmp    1337a <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13367:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1336b:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13371:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13374:	0f 85 6c ff ff ff    	jne    132e6 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   1337a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1337e:	75 36                	jne    133b6 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   13380:	a1 e0 e0 01 00       	mov    0x1e0e0,%eax
   13385:	83 ec 04             	sub    $0x4,%esp
   13388:	50                   	push   %eax
   13389:	68 a4 a0 01 00       	push   $0x1a0a4
   1338e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13391:	50                   	push   %eax
   13392:	e8 e8 d7 ff ff       	call   10b7f <addChunk_tEXt>
   13397:	83 c4 10             	add    $0x10,%esp
   1339a:	89 c2                	mov    %eax,%edx
   1339c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1339f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   133a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133a8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133ae:	85 c0                	test   %eax,%eax
   133b0:	0f 85 9d 01 00 00    	jne    13553 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   133b6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   133bd:	e9 e6 00 00 00       	jmp    134a8 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   133c2:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   133c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133cb:	c1 e2 02             	shl    $0x2,%edx
   133ce:	01 d0                	add    %edx,%eax
   133d0:	8b 00                	mov    (%eax),%eax
   133d2:	83 ec 0c             	sub    $0xc,%esp
   133d5:	50                   	push   %eax
   133d6:	e8 d7 ff fe ff       	call   33b2 <lodepng_strlen>
   133db:	83 c4 10             	add    $0x10,%esp
   133de:	83 f8 4f             	cmp    $0x4f,%eax
   133e1:	7e 12                	jle    133f5 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   133e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133e6:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   133ed:	00 00 00 
        goto cleanup;
   133f0:	e9 65 01 00 00       	jmp    1355a <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   133f5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   133fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133fe:	c1 e2 02             	shl    $0x2,%edx
   13401:	01 d0                	add    %edx,%eax
   13403:	8b 00                	mov    (%eax),%eax
   13405:	83 ec 0c             	sub    $0xc,%esp
   13408:	50                   	push   %eax
   13409:	e8 a4 ff fe ff       	call   33b2 <lodepng_strlen>
   1340e:	83 c4 10             	add    $0x10,%esp
   13411:	85 c0                	test   %eax,%eax
   13413:	7f 12                	jg     13427 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   13415:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13418:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1341f:	00 00 00 
        goto cleanup;
   13422:	e9 33 01 00 00       	jmp    1355a <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13427:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1342a:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1342d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13433:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13436:	c1 e2 02             	shl    $0x2,%edx
   13439:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1343b:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1343d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13443:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13446:	c1 e2 02             	shl    $0x2,%edx
   13449:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1344b:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1344d:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13453:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13456:	c1 e2 02             	shl    $0x2,%edx
   13459:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1345b:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1345d:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13463:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13466:	c1 e2 02             	shl    $0x2,%edx
   13469:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1346b:	8b 10                	mov    (%eax),%edx
   1346d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13470:	8b 40 74             	mov    0x74(%eax),%eax
   13473:	83 ec 04             	sub    $0x4,%esp
   13476:	57                   	push   %edi
   13477:	56                   	push   %esi
   13478:	53                   	push   %ebx
   13479:	51                   	push   %ecx
   1347a:	52                   	push   %edx
   1347b:	50                   	push   %eax
   1347c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1347f:	50                   	push   %eax
   13480:	e8 dc d8 ff ff       	call   10d61 <addChunk_iTXt>
   13485:	83 c4 20             	add    $0x20,%esp
   13488:	89 c2                	mov    %eax,%edx
   1348a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1348d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13493:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13496:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1349c:	85 c0                	test   %eax,%eax
   1349e:	0f 85 b2 00 00 00    	jne    13556 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   134a4:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   134a8:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   134ae:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   134b1:	0f 85 0b ff ff ff    	jne    133c2 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   134b7:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134ba:	85 c0                	test   %eax,%eax
   134bc:	74 2f                	je     134ed <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   134be:	8b 55 ac             	mov    -0x54(%ebp),%edx
   134c1:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134c4:	83 ec 04             	sub    $0x4,%esp
   134c7:	52                   	push   %edx
   134c8:	50                   	push   %eax
   134c9:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134cc:	50                   	push   %eax
   134cd:	e8 60 f2 ff ff       	call   12732 <addUnknownChunks>
   134d2:	83 c4 10             	add    $0x10,%esp
   134d5:	89 c2                	mov    %eax,%edx
   134d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134da:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   134e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134e3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134e9:	85 c0                	test   %eax,%eax
   134eb:	75 6c                	jne    13559 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   134ed:	83 ec 0c             	sub    $0xc,%esp
   134f0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134f3:	50                   	push   %eax
   134f4:	e8 6d d6 ff ff       	call   10b66 <addChunk_IEND>
   134f9:	83 c4 10             	add    $0x10,%esp
   134fc:	89 c2                	mov    %eax,%edx
   134fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13501:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13507:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1350a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13510:	85 c0                	test   %eax,%eax
   13512:	eb 46                	jmp    1355a <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13514:	90                   	nop
   13515:	eb 43                	jmp    1355a <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13517:	90                   	nop
   13518:	eb 40                	jmp    1355a <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   1351a:	90                   	nop
   1351b:	eb 3d                	jmp    1355a <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   1351d:	90                   	nop
   1351e:	eb 3a                	jmp    1355a <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   13520:	90                   	nop
   13521:	eb 37                	jmp    1355a <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   13523:	90                   	nop
   13524:	eb 34                	jmp    1355a <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13526:	90                   	nop
   13527:	eb 31                	jmp    1355a <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13529:	90                   	nop
   1352a:	eb 2e                	jmp    1355a <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1352c:	90                   	nop
   1352d:	eb 2b                	jmp    1355a <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   1352f:	90                   	nop
   13530:	eb 28                	jmp    1355a <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   13532:	90                   	nop
   13533:	eb 25                	jmp    1355a <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13535:	90                   	nop
   13536:	eb 22                	jmp    1355a <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13538:	90                   	nop
   13539:	eb 1f                	jmp    1355a <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   1353b:	90                   	nop
   1353c:	eb 1c                	jmp    1355a <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   1353e:	90                   	nop
   1353f:	eb 19                	jmp    1355a <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13541:	90                   	nop
   13542:	eb 16                	jmp    1355a <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13544:	90                   	nop
   13545:	eb 13                	jmp    1355a <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13547:	90                   	nop
   13548:	eb 10                	jmp    1355a <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   1354a:	90                   	nop
   1354b:	eb 0d                	jmp    1355a <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   1354d:	90                   	nop
   1354e:	eb 0a                	jmp    1355a <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   13550:	90                   	nop
   13551:	eb 07                	jmp    1355a <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13553:	90                   	nop
   13554:	eb 04                	jmp    1355a <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13556:	90                   	nop
   13557:	eb 01                	jmp    1355a <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13559:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   1355a:	83 ec 0c             	sub    $0xc,%esp
   1355d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13563:	50                   	push   %eax
   13564:	e8 34 65 ff ff       	call   9a9d <lodepng_info_cleanup>
   13569:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   1356c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1356f:	83 ec 0c             	sub    $0xc,%esp
   13572:	50                   	push   %eax
   13573:	e8 bf fd fe ff       	call   3337 <lodepng_free>
   13578:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   1357b:	8b 55 b0             	mov    -0x50(%ebp),%edx
   1357e:	8b 45 08             	mov    0x8(%ebp),%eax
   13581:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13583:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13586:	8b 45 0c             	mov    0xc(%ebp),%eax
   13589:	89 10                	mov    %edx,(%eax)

  return state->error;
   1358b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1358e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13594:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13597:	5b                   	pop    %ebx
   13598:	5e                   	pop    %esi
   13599:	5f                   	pop    %edi
   1359a:	5d                   	pop    %ebp
   1359b:	c3                   	ret    

0001359c <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   1359c:	55                   	push   %ebp
   1359d:	89 e5                	mov    %esp,%ebp
   1359f:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   135a5:	83 ec 0c             	sub    $0xc,%esp
   135a8:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135ae:	50                   	push   %eax
   135af:	e8 38 d0 ff ff       	call   105ec <lodepng_state_init>
   135b4:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   135b7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135ba:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   135c0:	8b 45 20             	mov    0x20(%ebp),%eax
   135c3:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   135c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135cc:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   135d2:	8b 45 20             	mov    0x20(%ebp),%eax
   135d5:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   135db:	83 ec 08             	sub    $0x8,%esp
   135de:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135e4:	50                   	push   %eax
   135e5:	ff 75 18             	pushl  0x18(%ebp)
   135e8:	ff 75 14             	pushl  0x14(%ebp)
   135eb:	ff 75 10             	pushl  0x10(%ebp)
   135ee:	ff 75 0c             	pushl  0xc(%ebp)
   135f1:	ff 75 08             	pushl  0x8(%ebp)
   135f4:	e8 48 f2 ff ff       	call   12841 <lodepng_encode>
   135f9:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   135fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   135ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   13602:	83 ec 0c             	sub    $0xc,%esp
   13605:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1360b:	50                   	push   %eax
   1360c:	e8 35 d0 ff ff       	call   10646 <lodepng_state_cleanup>
   13611:	83 c4 10             	add    $0x10,%esp
  return error;
   13614:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13617:	c9                   	leave  
   13618:	c3                   	ret    

00013619 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13619:	55                   	push   %ebp
   1361a:	89 e5                	mov    %esp,%ebp
   1361c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   1361f:	83 ec 04             	sub    $0x4,%esp
   13622:	6a 08                	push   $0x8
   13624:	6a 06                	push   $0x6
   13626:	ff 75 18             	pushl  0x18(%ebp)
   13629:	ff 75 14             	pushl  0x14(%ebp)
   1362c:	ff 75 10             	pushl  0x10(%ebp)
   1362f:	ff 75 0c             	pushl  0xc(%ebp)
   13632:	ff 75 08             	pushl  0x8(%ebp)
   13635:	e8 62 ff ff ff       	call   1359c <lodepng_encode_memory>
   1363a:	83 c4 20             	add    $0x20,%esp
}
   1363d:	c9                   	leave  
   1363e:	c3                   	ret    

0001363f <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   1363f:	55                   	push   %ebp
   13640:	89 e5                	mov    %esp,%ebp
   13642:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13645:	83 ec 04             	sub    $0x4,%esp
   13648:	6a 08                	push   $0x8
   1364a:	6a 02                	push   $0x2
   1364c:	ff 75 18             	pushl  0x18(%ebp)
   1364f:	ff 75 14             	pushl  0x14(%ebp)
   13652:	ff 75 10             	pushl  0x10(%ebp)
   13655:	ff 75 0c             	pushl  0xc(%ebp)
   13658:	ff 75 08             	pushl  0x8(%ebp)
   1365b:	e8 3c ff ff ff       	call   1359c <lodepng_encode_memory>
   13660:	83 c4 20             	add    $0x20,%esp
}
   13663:	c9                   	leave  
   13664:	c3                   	ret    

00013665 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13665:	55                   	push   %ebp
   13666:	89 e5                	mov    %esp,%ebp
   13668:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   1366b:	83 ec 04             	sub    $0x4,%esp
   1366e:	ff 75 1c             	pushl  0x1c(%ebp)
   13671:	ff 75 18             	pushl  0x18(%ebp)
   13674:	ff 75 14             	pushl  0x14(%ebp)
   13677:	ff 75 10             	pushl  0x10(%ebp)
   1367a:	ff 75 0c             	pushl  0xc(%ebp)
   1367d:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13680:	50                   	push   %eax
   13681:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13684:	50                   	push   %eax
   13685:	e8 12 ff ff ff       	call   1359c <lodepng_encode_memory>
   1368a:	83 c4 20             	add    $0x20,%esp
   1368d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   13690:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13694:	75 19                	jne    136af <lodepng_encode_file+0x4a>
   13696:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13699:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1369c:	83 ec 04             	sub    $0x4,%esp
   1369f:	ff 75 08             	pushl  0x8(%ebp)
   136a2:	52                   	push   %edx
   136a3:	50                   	push   %eax
   136a4:	e8 36 01 ff ff       	call   37df <lodepng_save_file>
   136a9:	83 c4 10             	add    $0x10,%esp
   136ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   136af:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136b2:	83 ec 0c             	sub    $0xc,%esp
   136b5:	50                   	push   %eax
   136b6:	e8 7c fc fe ff       	call   3337 <lodepng_free>
   136bb:	83 c4 10             	add    $0x10,%esp
  return error;
   136be:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   136c1:	c9                   	leave  
   136c2:	c3                   	ret    

000136c3 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136c3:	55                   	push   %ebp
   136c4:	89 e5                	mov    %esp,%ebp
   136c6:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   136c9:	83 ec 08             	sub    $0x8,%esp
   136cc:	6a 08                	push   $0x8
   136ce:	6a 06                	push   $0x6
   136d0:	ff 75 14             	pushl  0x14(%ebp)
   136d3:	ff 75 10             	pushl  0x10(%ebp)
   136d6:	ff 75 0c             	pushl  0xc(%ebp)
   136d9:	ff 75 08             	pushl  0x8(%ebp)
   136dc:	e8 84 ff ff ff       	call   13665 <lodepng_encode_file>
   136e1:	83 c4 20             	add    $0x20,%esp
}
   136e4:	c9                   	leave  
   136e5:	c3                   	ret    

000136e6 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136e6:	55                   	push   %ebp
   136e7:	89 e5                	mov    %esp,%ebp
   136e9:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   136ec:	83 ec 08             	sub    $0x8,%esp
   136ef:	6a 08                	push   $0x8
   136f1:	6a 02                	push   $0x2
   136f3:	ff 75 14             	pushl  0x14(%ebp)
   136f6:	ff 75 10             	pushl  0x10(%ebp)
   136f9:	ff 75 0c             	pushl  0xc(%ebp)
   136fc:	ff 75 08             	pushl  0x8(%ebp)
   136ff:	e8 61 ff ff ff       	call   13665 <lodepng_encode_file>
   13704:	83 c4 20             	add    $0x20,%esp
}
   13707:	c9                   	leave  
   13708:	c3                   	ret    

00013709 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13709:	55                   	push   %ebp
   1370a:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   1370c:	8b 45 08             	mov    0x8(%ebp),%eax
   1370f:	50                   	push   %eax
   13710:	e8 71 49 ff ff       	call   8086 <lodepng_compress_settings_init>
   13715:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13718:	8b 45 08             	mov    0x8(%ebp),%eax
   1371b:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   13722:	8b 45 08             	mov    0x8(%ebp),%eax
   13725:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   1372c:	8b 45 08             	mov    0x8(%ebp),%eax
   1372f:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13736:	8b 45 08             	mov    0x8(%ebp),%eax
   13739:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13740:	8b 45 08             	mov    0x8(%ebp),%eax
   13743:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   1374a:	8b 45 08             	mov    0x8(%ebp),%eax
   1374d:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13754:	8b 45 08             	mov    0x8(%ebp),%eax
   13757:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   1375e:	90                   	nop
   1375f:	c9                   	leave  
   13760:	c3                   	ret    

00013761 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13761:	55                   	push   %ebp
   13762:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13764:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13768:	0f 87 c1 03 00 00    	ja     13b2f <lodepng_error_text+0x3ce>
   1376e:	8b 45 08             	mov    0x8(%ebp),%eax
   13771:	c1 e0 02             	shl    $0x2,%eax
   13774:	05 e0 b3 01 00       	add    $0x1b3e0,%eax
   13779:	8b 00                	mov    (%eax),%eax
   1377b:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   1377d:	b8 ac a0 01 00       	mov    $0x1a0ac,%eax
   13782:	e9 ad 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13787:	b8 c9 a0 01 00       	mov    $0x1a0c9,%eax
   1378c:	e9 a3 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   13791:	b8 dc a0 01 00       	mov    $0x1a0dc,%eax
   13796:	e9 99 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   1379b:	b8 14 a1 01 00       	mov    $0x1a114,%eax
   137a0:	e9 8f 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   137a5:	b8 4c a1 01 00       	mov    $0x1a14c,%eax
   137aa:	e9 85 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   137af:	b8 4c a1 01 00       	mov    $0x1a14c,%eax
   137b4:	e9 7b 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   137b9:	b8 4c a1 01 00       	mov    $0x1a14c,%eax
   137be:	e9 71 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   137c3:	b8 7c a1 01 00       	mov    $0x1a17c,%eax
   137c8:	e9 67 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   137cd:	b8 b0 a1 01 00       	mov    $0x1a1b0,%eax
   137d2:	e9 5d 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   137d7:	b8 e4 a1 01 00       	mov    $0x1a1e4,%eax
   137dc:	e9 53 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   137e1:	b8 b0 a1 01 00       	mov    $0x1a1b0,%eax
   137e6:	e9 49 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   137eb:	b8 0c a2 01 00       	mov    $0x1a20c,%eax
   137f0:	e9 3f 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   137f5:	b8 44 a2 01 00       	mov    $0x1a244,%eax
   137fa:	e9 35 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   137ff:	b8 b0 a1 01 00       	mov    $0x1a1b0,%eax
   13804:	e9 2b 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13809:	b8 7c a2 01 00       	mov    $0x1a27c,%eax
   1380e:	e9 21 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13813:	b8 ac a2 01 00       	mov    $0x1a2ac,%eax
   13818:	e9 17 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   1381d:	b8 cc a2 01 00       	mov    $0x1a2cc,%eax
   13822:	e9 0d 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13827:	b8 f8 a2 01 00       	mov    $0x1a2f8,%eax
   1382c:	e9 03 03 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13831:	b8 38 a3 01 00       	mov    $0x1a338,%eax
   13836:	e9 f9 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   1383b:	b8 60 a3 01 00       	mov    $0x1a360,%eax
   13840:	e9 ef 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13845:	b8 94 a3 01 00       	mov    $0x1a394,%eax
   1384a:	e9 e5 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   1384f:	b8 b8 a3 01 00       	mov    $0x1a3b8,%eax
   13854:	e9 db 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13859:	b8 f0 a3 01 00       	mov    $0x1a3f0,%eax
   1385e:	e9 d1 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13863:	b8 10 a4 01 00       	mov    $0x1a410,%eax
   13868:	e9 c7 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   1386d:	b8 2f a4 01 00       	mov    $0x1a42f,%eax
   13872:	e9 bd 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13877:	b8 49 a4 01 00       	mov    $0x1a449,%eax
   1387c:	e9 b3 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13881:	b8 68 a4 01 00       	mov    $0x1a468,%eax
   13886:	e9 a9 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   1388b:	b8 a4 a4 01 00       	mov    $0x1a4a4,%eax
   13890:	e9 9f 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13895:	b8 c8 a4 01 00       	mov    $0x1a4c8,%eax
   1389a:	e9 95 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   1389f:	b8 f4 a4 01 00       	mov    $0x1a4f4,%eax
   138a4:	e9 8b 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   138a9:	b8 18 a5 01 00       	mov    $0x1a518,%eax
   138ae:	e9 81 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   138b3:	b8 58 a5 01 00       	mov    $0x1a558,%eax
   138b8:	e9 77 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   138bd:	b8 88 a5 01 00       	mov    $0x1a588,%eax
   138c2:	e9 6d 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   138c7:	b8 b0 a5 01 00       	mov    $0x1a5b0,%eax
   138cc:	e9 63 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   138d1:	b8 f4 a5 01 00       	mov    $0x1a5f4,%eax
   138d6:	e9 59 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   138db:	b8 20 a6 01 00       	mov    $0x1a620,%eax
   138e0:	e9 4f 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   138e5:	b8 50 a6 01 00       	mov    $0x1a650,%eax
   138ea:	e9 45 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   138ef:	b8 78 a6 01 00       	mov    $0x1a678,%eax
   138f4:	e9 3b 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   138f9:	b8 c0 a6 01 00       	mov    $0x1a6c0,%eax
   138fe:	e9 31 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13903:	b8 c0 a6 01 00       	mov    $0x1a6c0,%eax
   13908:	e9 27 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   1390d:	b8 fc a6 01 00       	mov    $0x1a6fc,%eax
   13912:	e9 1d 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13917:	b8 30 a7 01 00       	mov    $0x1a730,%eax
   1391c:	e9 13 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13921:	b8 53 a7 01 00       	mov    $0x1a753,%eax
   13926:	e9 09 02 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   1392b:	b8 70 a7 01 00       	mov    $0x1a770,%eax
   13930:	e9 ff 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13935:	b8 ac a7 01 00       	mov    $0x1a7ac,%eax
   1393a:	e9 f5 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   1393f:	b8 dc a7 01 00       	mov    $0x1a7dc,%eax
   13944:	e9 eb 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13949:	b8 28 a8 01 00       	mov    $0x1a828,%eax
   1394e:	e9 e1 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13953:	b8 60 a8 01 00       	mov    $0x1a860,%eax
   13958:	e9 d7 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   1395d:	b8 a0 a8 01 00       	mov    $0x1a8a0,%eax
   13962:	e9 cd 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13967:	b8 cc a8 01 00       	mov    $0x1a8cc,%eax
   1396c:	e9 c3 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13971:	b8 18 a9 01 00       	mov    $0x1a918,%eax
   13976:	e9 b9 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   1397b:	b8 6c a9 01 00       	mov    $0x1a96c,%eax
   13980:	e9 af 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13985:	b8 a0 a9 01 00       	mov    $0x1a9a0,%eax
   1398a:	e9 a5 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   1398f:	b8 f0 a9 01 00       	mov    $0x1a9f0,%eax
   13994:	e9 9b 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13999:	b8 2c aa 01 00       	mov    $0x1aa2c,%eax
   1399e:	e9 91 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   139a3:	b8 8c aa 01 00       	mov    $0x1aa8c,%eax
   139a8:	e9 87 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   139ad:	b8 ec aa 01 00       	mov    $0x1aaec,%eax
   139b2:	e9 7d 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   139b7:	b8 48 ab 01 00       	mov    $0x1ab48,%eax
   139bc:	e9 73 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   139c1:	b8 8c ab 01 00       	mov    $0x1ab8c,%eax
   139c6:	e9 69 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   139cb:	b8 c8 ab 01 00       	mov    $0x1abc8,%eax
   139d0:	e9 5f 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   139d5:	b8 25 ac 01 00       	mov    $0x1ac25,%eax
   139da:	e9 55 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   139df:	b8 3d ac 01 00       	mov    $0x1ac3d,%eax
   139e4:	e9 4b 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   139e9:	b8 58 ac 01 00       	mov    $0x1ac58,%eax
   139ee:	e9 41 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   139f3:	b8 94 ac 01 00       	mov    $0x1ac94,%eax
   139f8:	e9 37 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   139fd:	b8 c4 ac 01 00       	mov    $0x1acc4,%eax
   13a02:	e9 2d 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13a07:	b8 e4 ac 01 00       	mov    $0x1ace4,%eax
   13a0c:	e9 23 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13a11:	b8 04 ad 01 00       	mov    $0x1ad04,%eax
   13a16:	e9 19 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13a1b:	b8 24 ad 01 00       	mov    $0x1ad24,%eax
   13a20:	e9 0f 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13a25:	b8 48 ad 01 00       	mov    $0x1ad48,%eax
   13a2a:	e9 05 01 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13a2f:	b8 70 ad 01 00       	mov    $0x1ad70,%eax
   13a34:	e9 fb 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13a39:	b8 cd ad 01 00       	mov    $0x1adcd,%eax
   13a3e:	e9 f1 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13a43:	b8 e8 ad 01 00       	mov    $0x1ade8,%eax
   13a48:	e9 e7 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13a4d:	b8 24 ae 01 00       	mov    $0x1ae24,%eax
   13a52:	e9 dd 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13a57:	b8 58 ae 01 00       	mov    $0x1ae58,%eax
   13a5c:	e9 d3 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13a61:	b8 ac ae 01 00       	mov    $0x1aeac,%eax
   13a66:	e9 c9 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13a6b:	b8 f8 ae 01 00       	mov    $0x1aef8,%eax
   13a70:	e9 bf 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13a75:	b8 34 af 01 00       	mov    $0x1af34,%eax
   13a7a:	e9 b5 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13a7f:	b8 58 af 01 00       	mov    $0x1af58,%eax
   13a84:	e9 ab 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13a89:	b8 78 af 01 00       	mov    $0x1af78,%eax
   13a8e:	e9 a1 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13a93:	b8 a0 af 01 00       	mov    $0x1afa0,%eax
   13a98:	e9 97 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13a9d:	b8 c0 af 01 00       	mov    $0x1afc0,%eax
   13aa2:	e9 8d 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13aa7:	b8 ec af 01 00       	mov    $0x1afec,%eax
   13aac:	e9 83 00 00 00       	jmp    13b34 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13ab1:	b8 1b b0 01 00       	mov    $0x1b01b,%eax
   13ab6:	eb 7c                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13ab8:	b8 33 b0 01 00       	mov    $0x1b033,%eax
   13abd:	eb 75                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13abf:	b8 4b b0 01 00       	mov    $0x1b04b,%eax
   13ac4:	eb 6e                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13ac6:	b8 63 b0 01 00       	mov    $0x1b063,%eax
   13acb:	eb 67                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13acd:	b8 84 b0 01 00       	mov    $0x1b084,%eax
   13ad2:	eb 60                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13ad4:	b8 d4 b0 01 00       	mov    $0x1b0d4,%eax
   13ad9:	eb 59                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13adb:	b8 28 b1 01 00       	mov    $0x1b128,%eax
   13ae0:	eb 52                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13ae2:	b8 7c b1 01 00       	mov    $0x1b17c,%eax
   13ae7:	eb 4b                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13ae9:	b8 c4 b1 01 00       	mov    $0x1b1c4,%eax
   13aee:	eb 44                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13af0:	b8 08 b2 01 00       	mov    $0x1b208,%eax
   13af5:	eb 3d                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13af7:	b8 24 b2 01 00       	mov    $0x1b224,%eax
   13afc:	eb 36                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13afe:	b8 5c b2 01 00       	mov    $0x1b25c,%eax
   13b03:	eb 2f                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13b05:	b8 b0 b2 01 00       	mov    $0x1b2b0,%eax
   13b0a:	eb 28                	jmp    13b34 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13b0c:	b8 e0 b2 01 00       	mov    $0x1b2e0,%eax
   13b11:	eb 21                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13b13:	b8 30 b3 01 00       	mov    $0x1b330,%eax
   13b18:	eb 1a                	jmp    13b34 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13b1a:	b8 5c b3 01 00       	mov    $0x1b35c,%eax
   13b1f:	eb 13                	jmp    13b34 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13b21:	b8 88 b3 01 00       	mov    $0x1b388,%eax
   13b26:	eb 0c                	jmp    13b34 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13b28:	b8 ac b3 01 00       	mov    $0x1b3ac,%eax
   13b2d:	eb 05                	jmp    13b34 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13b2f:	b8 cb b3 01 00       	mov    $0x1b3cb,%eax
}
   13b34:	5d                   	pop    %ebp
   13b35:	c3                   	ret    

00013b36 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13b36:	55                   	push   %ebp
   13b37:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13b39:	8b 45 08             	mov    0x8(%ebp),%eax
   13b3c:	8b 40 28             	mov    0x28(%eax),%eax
   13b3f:	83 f8 01             	cmp    $0x1,%eax
   13b42:	75 08                	jne    13b4c <GetImage+0x16>
   13b44:	8b 45 08             	mov    0x8(%ebp),%eax
   13b47:	8b 40 54             	mov    0x54(%eax),%eax
   13b4a:	eb 09                	jmp    13b55 <GetImage+0x1f>
   13b4c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b4f:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13b55:	5d                   	pop    %ebp
   13b56:	c3                   	ret    

00013b57 <GetWidth>:

int GetWidth(Context* ctx){
   13b57:	55                   	push   %ebp
   13b58:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13b5a:	8b 45 08             	mov    0x8(%ebp),%eax
   13b5d:	8b 40 10             	mov    0x10(%eax),%eax
}
   13b60:	5d                   	pop    %ebp
   13b61:	c3                   	ret    

00013b62 <GetHeight>:

int GetHeight(Context* ctx){
   13b62:	55                   	push   %ebp
   13b63:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13b65:	8b 45 08             	mov    0x8(%ebp),%eax
   13b68:	8b 40 14             	mov    0x14(%eax),%eax
}
   13b6b:	5d                   	pop    %ebp
   13b6c:	c3                   	ret    

00013b6d <GetImageSize>:

uint GetImageSize(Context* ctx){
   13b6d:	55                   	push   %ebp
   13b6e:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13b70:	8b 45 08             	mov    0x8(%ebp),%eax
   13b73:	8b 50 10             	mov    0x10(%eax),%edx
   13b76:	8b 45 08             	mov    0x8(%ebp),%eax
   13b79:	8b 40 14             	mov    0x14(%eax),%eax
   13b7c:	0f af d0             	imul   %eax,%edx
   13b7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13b82:	8b 40 28             	mov    0x28(%eax),%eax
   13b85:	0f af c2             	imul   %edx,%eax
}
   13b88:	5d                   	pop    %ebp
   13b89:	c3                   	ret    

00013b8a <_Clip>:

uchar _Clip(const int x){
   13b8a:	55                   	push   %ebp
   13b8b:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13b8d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13b91:	78 15                	js     13ba8 <_Clip+0x1e>
   13b93:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13b9a:	7f 05                	jg     13ba1 <_Clip+0x17>
   13b9c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b9f:	eb 0c                	jmp    13bad <_Clip+0x23>
   13ba1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13ba6:	eb 05                	jmp    13bad <_Clip+0x23>
   13ba8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13bad:	5d                   	pop    %ebp
   13bae:	c3                   	ret    

00013baf <_Skip>:

void _Skip(Context* ctx, int c){
   13baf:	55                   	push   %ebp
   13bb0:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13bb2:	8b 45 08             	mov    0x8(%ebp),%eax
   13bb5:	8b 50 04             	mov    0x4(%eax),%edx
   13bb8:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bbb:	01 c2                	add    %eax,%edx
   13bbd:	8b 45 08             	mov    0x8(%ebp),%eax
   13bc0:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13bc6:	8b 40 08             	mov    0x8(%eax),%eax
   13bc9:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bcc:	89 c2                	mov    %eax,%edx
   13bce:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd1:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13bd4:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd7:	8b 40 0c             	mov    0xc(%eax),%eax
   13bda:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bdd:	89 c2                	mov    %eax,%edx
   13bdf:	8b 45 08             	mov    0x8(%ebp),%eax
   13be2:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13be5:	8b 45 08             	mov    0x8(%ebp),%eax
   13be8:	8b 40 08             	mov    0x8(%eax),%eax
   13beb:	85 c0                	test   %eax,%eax
   13bed:	79 09                	jns    13bf8 <_Skip+0x49>
   13bef:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13bf8:	90                   	nop
   13bf9:	5d                   	pop    %ebp
   13bfa:	c3                   	ret    

00013bfb <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13bfb:	55                   	push   %ebp
   13bfc:	89 e5                	mov    %esp,%ebp
   13bfe:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13c01:	8b 45 08             	mov    0x8(%ebp),%eax
   13c04:	8b 40 08             	mov    0x8(%eax),%eax
   13c07:	83 f8 01             	cmp    $0x1,%eax
   13c0a:	7f 0b                	jg     13c17 <_DecodeLength+0x1c>
   13c0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c0f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c15:	eb 45                	jmp    13c5c <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13c17:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1a:	8b 40 04             	mov    0x4(%eax),%eax
   13c1d:	83 ec 0c             	sub    $0xc,%esp
   13c20:	50                   	push   %eax
   13c21:	e8 38 00 00 00       	call   13c5e <_Decode2Bytes>
   13c26:	83 c4 10             	add    $0x10,%esp
   13c29:	89 c2                	mov    %eax,%edx
   13c2b:	8b 45 08             	mov    0x8(%ebp),%eax
   13c2e:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13c31:	8b 45 08             	mov    0x8(%ebp),%eax
   13c34:	8b 50 0c             	mov    0xc(%eax),%edx
   13c37:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3a:	8b 40 08             	mov    0x8(%eax),%eax
   13c3d:	39 c2                	cmp    %eax,%edx
   13c3f:	7e 0b                	jle    13c4c <_DecodeLength+0x51>
   13c41:	8b 45 08             	mov    0x8(%ebp),%eax
   13c44:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c4a:	eb 10                	jmp    13c5c <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13c4c:	83 ec 08             	sub    $0x8,%esp
   13c4f:	6a 02                	push   $0x2
   13c51:	ff 75 08             	pushl  0x8(%ebp)
   13c54:	e8 56 ff ff ff       	call   13baf <_Skip>
   13c59:	83 c4 10             	add    $0x10,%esp
}
   13c5c:	c9                   	leave  
   13c5d:	c3                   	ret    

00013c5e <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13c5e:	55                   	push   %ebp
   13c5f:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13c61:	8b 45 08             	mov    0x8(%ebp),%eax
   13c64:	0f b6 00             	movzbl (%eax),%eax
   13c67:	0f b6 c0             	movzbl %al,%eax
   13c6a:	c1 e0 08             	shl    $0x8,%eax
   13c6d:	89 c2                	mov    %eax,%edx
   13c6f:	8b 45 08             	mov    0x8(%ebp),%eax
   13c72:	83 c0 01             	add    $0x1,%eax
   13c75:	0f b6 00             	movzbl (%eax),%eax
   13c78:	0f b6 c0             	movzbl %al,%eax
   13c7b:	09 d0                	or     %edx,%eax
}
   13c7d:	5d                   	pop    %ebp
   13c7e:	c3                   	ret    

00013c7f <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13c7f:	55                   	push   %ebp
   13c80:	89 e5                	mov    %esp,%ebp
   13c82:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13c85:	8b 45 08             	mov    0x8(%ebp),%eax
   13c88:	8b 55 10             	mov    0x10(%ebp),%edx
   13c8b:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13c8e:	8b 45 14             	mov    0x14(%ebp),%eax
   13c91:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13c96:	89 c2                	mov    %eax,%edx
   13c98:	8b 45 08             	mov    0x8(%ebp),%eax
   13c9b:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13c9e:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca1:	8b 40 08             	mov    0x8(%eax),%eax
   13ca4:	83 f8 01             	cmp    $0x1,%eax
   13ca7:	7e 1d                	jle    13cc6 <_DecodeJPEG+0x47>
   13ca9:	8b 45 08             	mov    0x8(%ebp),%eax
   13cac:	8b 40 04             	mov    0x4(%eax),%eax
   13caf:	0f b6 00             	movzbl (%eax),%eax
   13cb2:	3c ff                	cmp    $0xff,%al
   13cb4:	75 10                	jne    13cc6 <_DecodeJPEG+0x47>
   13cb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb9:	8b 40 04             	mov    0x4(%eax),%eax
   13cbc:	83 c0 01             	add    $0x1,%eax
   13cbf:	0f b6 00             	movzbl (%eax),%eax
   13cc2:	3c d8                	cmp    $0xd8,%al
   13cc4:	74 0a                	je     13cd0 <_DecodeJPEG+0x51>
   13cc6:	b8 01 00 00 00       	mov    $0x1,%eax
   13ccb:	e9 56 01 00 00       	jmp    13e26 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13cd0:	6a 02                	push   $0x2
   13cd2:	ff 75 08             	pushl  0x8(%ebp)
   13cd5:	e8 d5 fe ff ff       	call   13baf <_Skip>
   13cda:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13cdd:	e9 0a 01 00 00       	jmp    13dec <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13ce2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ce5:	8b 40 08             	mov    0x8(%eax),%eax
   13ce8:	85 c0                	test   %eax,%eax
   13cea:	78 0d                	js     13cf9 <_DecodeJPEG+0x7a>
   13cec:	8b 45 08             	mov    0x8(%ebp),%eax
   13cef:	8b 40 04             	mov    0x4(%eax),%eax
   13cf2:	0f b6 00             	movzbl (%eax),%eax
   13cf5:	3c ff                	cmp    $0xff,%al
   13cf7:	74 0a                	je     13d03 <_DecodeJPEG+0x84>
   13cf9:	b8 05 00 00 00       	mov    $0x5,%eax
   13cfe:	e9 23 01 00 00       	jmp    13e26 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13d03:	6a 02                	push   $0x2
   13d05:	ff 75 08             	pushl  0x8(%ebp)
   13d08:	e8 a2 fe ff ff       	call   13baf <_Skip>
   13d0d:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13d10:	8b 45 08             	mov    0x8(%ebp),%eax
   13d13:	8b 40 04             	mov    0x4(%eax),%eax
   13d16:	83 e8 01             	sub    $0x1,%eax
   13d19:	0f b6 00             	movzbl (%eax),%eax
   13d1c:	0f b6 c0             	movzbl %al,%eax
   13d1f:	3d da 00 00 00       	cmp    $0xda,%eax
   13d24:	74 71                	je     13d97 <_DecodeJPEG+0x118>
   13d26:	3d da 00 00 00       	cmp    $0xda,%eax
   13d2b:	7f 10                	jg     13d3d <_DecodeJPEG+0xbe>
   13d2d:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13d32:	74 20                	je     13d54 <_DecodeJPEG+0xd5>
   13d34:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13d39:	74 2c                	je     13d67 <_DecodeJPEG+0xe8>
   13d3b:	eb 7d                	jmp    13dba <_DecodeJPEG+0x13b>
   13d3d:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13d42:	74 43                	je     13d87 <_DecodeJPEG+0x108>
   13d44:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13d49:	74 5f                	je     13daa <_DecodeJPEG+0x12b>
   13d4b:	3d db 00 00 00       	cmp    $0xdb,%eax
   13d50:	74 25                	je     13d77 <_DecodeJPEG+0xf8>
   13d52:	eb 66                	jmp    13dba <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13d54:	83 ec 0c             	sub    $0xc,%esp
   13d57:	ff 75 08             	pushl  0x8(%ebp)
   13d5a:	e8 c9 00 00 00       	call   13e28 <_DecodeSOF>
   13d5f:	83 c4 10             	add    $0x10,%esp
   13d62:	e9 85 00 00 00       	jmp    13dec <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13d67:	83 ec 0c             	sub    $0xc,%esp
   13d6a:	ff 75 08             	pushl  0x8(%ebp)
   13d6d:	e8 28 05 00 00       	call   1429a <_DecodeDHT>
   13d72:	83 c4 10             	add    $0x10,%esp
   13d75:	eb 75                	jmp    13dec <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13d77:	83 ec 0c             	sub    $0xc,%esp
   13d7a:	ff 75 08             	pushl  0x8(%ebp)
   13d7d:	e8 05 07 00 00       	call   14487 <_DecodeDQT>
   13d82:	83 c4 10             	add    $0x10,%esp
   13d85:	eb 65                	jmp    13dec <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13d87:	83 ec 0c             	sub    $0xc,%esp
   13d8a:	ff 75 08             	pushl  0x8(%ebp)
   13d8d:	e8 ff 07 00 00       	call   14591 <_DecodeDRI>
   13d92:	83 c4 10             	add    $0x10,%esp
   13d95:	eb 55                	jmp    13dec <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13d97:	83 ec 08             	sub    $0x8,%esp
   13d9a:	ff 75 0c             	pushl  0xc(%ebp)
   13d9d:	ff 75 08             	pushl  0x8(%ebp)
   13da0:	e8 56 08 00 00       	call   145fb <_DecodeSOS>
   13da5:	83 c4 10             	add    $0x10,%esp
   13da8:	eb 42                	jmp    13dec <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13daa:	83 ec 0c             	sub    $0xc,%esp
   13dad:	ff 75 08             	pushl  0x8(%ebp)
   13db0:	e8 a8 15 00 00       	call   1535d <_SkipMarker>
   13db5:	83 c4 10             	add    $0x10,%esp
   13db8:	eb 32                	jmp    13dec <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13dba:	8b 45 08             	mov    0x8(%ebp),%eax
   13dbd:	8b 40 04             	mov    0x4(%eax),%eax
   13dc0:	83 e8 01             	sub    $0x1,%eax
   13dc3:	0f b6 00             	movzbl (%eax),%eax
   13dc6:	0f b6 c0             	movzbl %al,%eax
   13dc9:	25 f0 00 00 00       	and    $0xf0,%eax
   13dce:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13dd3:	75 10                	jne    13de5 <_DecodeJPEG+0x166>
   13dd5:	83 ec 0c             	sub    $0xc,%esp
   13dd8:	ff 75 08             	pushl  0x8(%ebp)
   13ddb:	e8 7d 15 00 00       	call   1535d <_SkipMarker>
   13de0:	83 c4 10             	add    $0x10,%esp
   13de3:	eb 07                	jmp    13dec <_DecodeJPEG+0x16d>
                else return Unsupported;
   13de5:	b8 02 00 00 00       	mov    $0x2,%eax
   13dea:	eb 3a                	jmp    13e26 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13dec:	8b 45 08             	mov    0x8(%ebp),%eax
   13def:	8b 00                	mov    (%eax),%eax
   13df1:	85 c0                	test   %eax,%eax
   13df3:	0f 84 e9 fe ff ff    	je     13ce2 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13df9:	8b 45 08             	mov    0x8(%ebp),%eax
   13dfc:	8b 00                	mov    (%eax),%eax
   13dfe:	83 f8 06             	cmp    $0x6,%eax
   13e01:	74 07                	je     13e0a <_DecodeJPEG+0x18b>
   13e03:	8b 45 08             	mov    0x8(%ebp),%eax
   13e06:	8b 00                	mov    (%eax),%eax
   13e08:	eb 1c                	jmp    13e26 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13e0a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e0d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13e13:	83 ec 0c             	sub    $0xc,%esp
   13e16:	ff 75 08             	pushl  0x8(%ebp)
   13e19:	e8 6b 15 00 00       	call   15389 <_Convert>
   13e1e:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13e21:	8b 45 08             	mov    0x8(%ebp),%eax
   13e24:	8b 00                	mov    (%eax),%eax
 }
   13e26:	c9                   	leave  
   13e27:	c3                   	ret    

00013e28 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13e28:	55                   	push   %ebp
   13e29:	89 e5                	mov    %esp,%ebp
   13e2b:	53                   	push   %ebx
   13e2c:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13e2f:	83 ec 0c             	sub    $0xc,%esp
   13e32:	ff 75 08             	pushl  0x8(%ebp)
   13e35:	e8 c1 fd ff ff       	call   13bfb <_DecodeLength>
   13e3a:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13e3d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e40:	8b 00                	mov    (%eax),%eax
   13e42:	85 c0                	test   %eax,%eax
   13e44:	0f 85 4a 04 00 00    	jne    14294 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4d:	8b 40 0c             	mov    0xc(%eax),%eax
   13e50:	83 f8 08             	cmp    $0x8,%eax
   13e53:	7f 0e                	jg     13e63 <_DecodeSOF+0x3b>
   13e55:	8b 45 08             	mov    0x8(%ebp),%eax
   13e58:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13e5e:	e9 32 04 00 00       	jmp    14295 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13e63:	8b 45 08             	mov    0x8(%ebp),%eax
   13e66:	8b 40 04             	mov    0x4(%eax),%eax
   13e69:	0f b6 00             	movzbl (%eax),%eax
   13e6c:	3c 08                	cmp    $0x8,%al
   13e6e:	74 0e                	je     13e7e <_DecodeSOF+0x56>
   13e70:	8b 45 08             	mov    0x8(%ebp),%eax
   13e73:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13e79:	e9 17 04 00 00       	jmp    14295 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13e7e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e81:	8b 40 04             	mov    0x4(%eax),%eax
   13e84:	83 c0 01             	add    $0x1,%eax
   13e87:	83 ec 0c             	sub    $0xc,%esp
   13e8a:	50                   	push   %eax
   13e8b:	e8 ce fd ff ff       	call   13c5e <_Decode2Bytes>
   13e90:	83 c4 10             	add    $0x10,%esp
   13e93:	89 c2                	mov    %eax,%edx
   13e95:	8b 45 08             	mov    0x8(%ebp),%eax
   13e98:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13e9b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e9e:	8b 40 04             	mov    0x4(%eax),%eax
   13ea1:	83 c0 03             	add    $0x3,%eax
   13ea4:	83 ec 0c             	sub    $0xc,%esp
   13ea7:	50                   	push   %eax
   13ea8:	e8 b1 fd ff ff       	call   13c5e <_Decode2Bytes>
   13ead:	83 c4 10             	add    $0x10,%esp
   13eb0:	89 c2                	mov    %eax,%edx
   13eb2:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb5:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13eb8:	8b 45 08             	mov    0x8(%ebp),%eax
   13ebb:	8b 40 04             	mov    0x4(%eax),%eax
   13ebe:	83 c0 05             	add    $0x5,%eax
   13ec1:	0f b6 00             	movzbl (%eax),%eax
   13ec4:	0f b6 d0             	movzbl %al,%edx
   13ec7:	8b 45 08             	mov    0x8(%ebp),%eax
   13eca:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13ecd:	83 ec 08             	sub    $0x8,%esp
   13ed0:	6a 06                	push   $0x6
   13ed2:	ff 75 08             	pushl  0x8(%ebp)
   13ed5:	e8 d5 fc ff ff       	call   13baf <_Skip>
   13eda:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13edd:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee0:	8b 40 28             	mov    0x28(%eax),%eax
   13ee3:	83 f8 01             	cmp    $0x1,%eax
   13ee6:	74 13                	je     13efb <_DecodeSOF+0xd3>
   13ee8:	83 f8 03             	cmp    $0x3,%eax
   13eeb:	74 0e                	je     13efb <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13eed:	8b 45 08             	mov    0x8(%ebp),%eax
   13ef0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13ef6:	e9 9a 03 00 00       	jmp    14295 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13efb:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13efc:	8b 45 08             	mov    0x8(%ebp),%eax
   13eff:	8b 48 0c             	mov    0xc(%eax),%ecx
   13f02:	8b 45 08             	mov    0x8(%ebp),%eax
   13f05:	8b 50 28             	mov    0x28(%eax),%edx
   13f08:	89 d0                	mov    %edx,%eax
   13f0a:	01 c0                	add    %eax,%eax
   13f0c:	01 d0                	add    %edx,%eax
   13f0e:	39 c1                	cmp    %eax,%ecx
   13f10:	7d 0e                	jge    13f20 <_DecodeSOF+0xf8>
   13f12:	8b 45 08             	mov    0x8(%ebp),%eax
   13f15:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f1b:	e9 75 03 00 00       	jmp    14295 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   13f20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13f27:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   13f2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13f35:	8b 45 08             	mov    0x8(%ebp),%eax
   13f38:	83 c0 2c             	add    $0x2c,%eax
   13f3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13f3e:	e9 50 01 00 00       	jmp    14093 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   13f43:	8b 45 08             	mov    0x8(%ebp),%eax
   13f46:	8b 40 04             	mov    0x4(%eax),%eax
   13f49:	0f b6 00             	movzbl (%eax),%eax
   13f4c:	0f b6 d0             	movzbl %al,%edx
   13f4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f52:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   13f54:	8b 45 08             	mov    0x8(%ebp),%eax
   13f57:	8b 40 04             	mov    0x4(%eax),%eax
   13f5a:	83 c0 01             	add    $0x1,%eax
   13f5d:	0f b6 00             	movzbl (%eax),%eax
   13f60:	c0 e8 04             	shr    $0x4,%al
   13f63:	0f b6 d0             	movzbl %al,%edx
   13f66:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f69:	89 50 04             	mov    %edx,0x4(%eax)
   13f6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f6f:	8b 40 04             	mov    0x4(%eax),%eax
   13f72:	85 c0                	test   %eax,%eax
   13f74:	75 0e                	jne    13f84 <_DecodeSOF+0x15c>
   13f76:	8b 45 08             	mov    0x8(%ebp),%eax
   13f79:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f7f:	e9 11 03 00 00       	jmp    14295 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   13f84:	8b 45 08             	mov    0x8(%ebp),%eax
   13f87:	8b 40 04             	mov    0x4(%eax),%eax
   13f8a:	83 c0 01             	add    $0x1,%eax
   13f8d:	0f b6 00             	movzbl (%eax),%eax
   13f90:	0f b6 c0             	movzbl %al,%eax
   13f93:	83 e0 0f             	and    $0xf,%eax
   13f96:	89 c2                	mov    %eax,%edx
   13f98:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f9b:	89 50 08             	mov    %edx,0x8(%eax)
   13f9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fa1:	8b 40 08             	mov    0x8(%eax),%eax
   13fa4:	85 c0                	test   %eax,%eax
   13fa6:	75 0e                	jne    13fb6 <_DecodeSOF+0x18e>
   13fa8:	8b 45 08             	mov    0x8(%ebp),%eax
   13fab:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fb1:	e9 df 02 00 00       	jmp    14295 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   13fb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fb9:	8b 50 04             	mov    0x4(%eax),%edx
   13fbc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fbf:	8b 40 04             	mov    0x4(%eax),%eax
   13fc2:	83 e8 01             	sub    $0x1,%eax
   13fc5:	21 d0                	and    %edx,%eax
   13fc7:	85 c0                	test   %eax,%eax
   13fc9:	74 0e                	je     13fd9 <_DecodeSOF+0x1b1>
   13fcb:	8b 45 08             	mov    0x8(%ebp),%eax
   13fce:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fd4:	e9 bc 02 00 00       	jmp    14295 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   13fd9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fdc:	8b 50 08             	mov    0x8(%eax),%edx
   13fdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fe2:	8b 40 08             	mov    0x8(%eax),%eax
   13fe5:	83 e8 01             	sub    $0x1,%eax
   13fe8:	21 d0                	and    %edx,%eax
   13fea:	85 c0                	test   %eax,%eax
   13fec:	74 0e                	je     13ffc <_DecodeSOF+0x1d4>
   13fee:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13ff7:	e9 99 02 00 00       	jmp    14295 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   13ffc:	8b 45 08             	mov    0x8(%ebp),%eax
   13fff:	8b 40 04             	mov    0x4(%eax),%eax
   14002:	83 c0 02             	add    $0x2,%eax
   14005:	0f b6 00             	movzbl (%eax),%eax
   14008:	0f b6 d0             	movzbl %al,%edx
   1400b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1400e:	89 50 18             	mov    %edx,0x18(%eax)
   14011:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14014:	8b 40 18             	mov    0x18(%eax),%eax
   14017:	25 fc 00 00 00       	and    $0xfc,%eax
   1401c:	85 c0                	test   %eax,%eax
   1401e:	74 0e                	je     1402e <_DecodeSOF+0x206>
   14020:	8b 45 08             	mov    0x8(%ebp),%eax
   14023:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14029:	e9 67 02 00 00       	jmp    14295 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   1402e:	83 ec 08             	sub    $0x8,%esp
   14031:	6a 03                	push   $0x3
   14033:	ff 75 08             	pushl  0x8(%ebp)
   14036:	e8 74 fb ff ff       	call   13baf <_Skip>
   1403b:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   1403e:	8b 45 08             	mov    0x8(%ebp),%eax
   14041:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14047:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1404a:	8b 40 18             	mov    0x18(%eax),%eax
   1404d:	bb 01 00 00 00       	mov    $0x1,%ebx
   14052:	89 c1                	mov    %eax,%ecx
   14054:	d3 e3                	shl    %cl,%ebx
   14056:	89 d8                	mov    %ebx,%eax
   14058:	09 c2                	or     %eax,%edx
   1405a:	8b 45 08             	mov    0x8(%ebp),%eax
   1405d:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14063:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14066:	8b 40 04             	mov    0x4(%eax),%eax
   14069:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1406c:	7e 09                	jle    14077 <_DecodeSOF+0x24f>
   1406e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14071:	8b 40 04             	mov    0x4(%eax),%eax
   14074:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14077:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1407a:	8b 40 08             	mov    0x8(%eax),%eax
   1407d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14080:	7e 09                	jle    1408b <_DecodeSOF+0x263>
   14082:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14085:	8b 40 08             	mov    0x8(%eax),%eax
   14088:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1408b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1408f:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14093:	8b 45 08             	mov    0x8(%ebp),%eax
   14096:	8b 40 28             	mov    0x28(%eax),%eax
   14099:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1409c:	0f 8f a1 fe ff ff    	jg     13f43 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   140a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   140a5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140ac:	8b 45 08             	mov    0x8(%ebp),%eax
   140af:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   140b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   140b5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140bc:	8b 45 08             	mov    0x8(%ebp),%eax
   140bf:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   140c2:	8b 45 08             	mov    0x8(%ebp),%eax
   140c5:	8b 50 10             	mov    0x10(%eax),%edx
   140c8:	8b 45 08             	mov    0x8(%ebp),%eax
   140cb:	8b 40 20             	mov    0x20(%eax),%eax
   140ce:	01 d0                	add    %edx,%eax
   140d0:	8d 48 ff             	lea    -0x1(%eax),%ecx
   140d3:	8b 45 08             	mov    0x8(%ebp),%eax
   140d6:	8b 58 20             	mov    0x20(%eax),%ebx
   140d9:	89 c8                	mov    %ecx,%eax
   140db:	99                   	cltd   
   140dc:	f7 fb                	idiv   %ebx
   140de:	89 c2                	mov    %eax,%edx
   140e0:	8b 45 08             	mov    0x8(%ebp),%eax
   140e3:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   140e6:	8b 45 08             	mov    0x8(%ebp),%eax
   140e9:	8b 50 14             	mov    0x14(%eax),%edx
   140ec:	8b 45 08             	mov    0x8(%ebp),%eax
   140ef:	8b 40 24             	mov    0x24(%eax),%eax
   140f2:	01 d0                	add    %edx,%eax
   140f4:	8d 48 ff             	lea    -0x1(%eax),%ecx
   140f7:	8b 45 08             	mov    0x8(%ebp),%eax
   140fa:	8b 58 24             	mov    0x24(%eax),%ebx
   140fd:	89 c8                	mov    %ecx,%eax
   140ff:	99                   	cltd   
   14100:	f7 fb                	idiv   %ebx
   14102:	89 c2                	mov    %eax,%edx
   14104:	8b 45 08             	mov    0x8(%ebp),%eax
   14107:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1410a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14111:	8b 45 08             	mov    0x8(%ebp),%eax
   14114:	83 c0 2c             	add    $0x2c,%eax
   14117:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1411a:	e9 fd 00 00 00       	jmp    1421c <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   1411f:	8b 45 08             	mov    0x8(%ebp),%eax
   14122:	8b 50 10             	mov    0x10(%eax),%edx
   14125:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14128:	8b 40 04             	mov    0x4(%eax),%eax
   1412b:	0f af d0             	imul   %eax,%edx
   1412e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14131:	01 d0                	add    %edx,%eax
   14133:	83 e8 01             	sub    $0x1,%eax
   14136:	99                   	cltd   
   14137:	f7 7d ec             	idivl  -0x14(%ebp)
   1413a:	89 c2                	mov    %eax,%edx
   1413c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1413f:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14142:	8b 45 08             	mov    0x8(%ebp),%eax
   14145:	8b 50 14             	mov    0x14(%eax),%edx
   14148:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1414b:	8b 40 08             	mov    0x8(%eax),%eax
   1414e:	0f af d0             	imul   %eax,%edx
   14151:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14154:	01 d0                	add    %edx,%eax
   14156:	83 e8 01             	sub    $0x1,%eax
   14159:	99                   	cltd   
   1415a:	f7 7d f0             	idivl  -0x10(%ebp)
   1415d:	89 c2                	mov    %eax,%edx
   1415f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14162:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14165:	8b 45 08             	mov    0x8(%ebp),%eax
   14168:	8b 50 18             	mov    0x18(%eax),%edx
   1416b:	8b 45 08             	mov    0x8(%ebp),%eax
   1416e:	8b 40 20             	mov    0x20(%eax),%eax
   14171:	0f af d0             	imul   %eax,%edx
   14174:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14177:	8b 40 04             	mov    0x4(%eax),%eax
   1417a:	0f af c2             	imul   %edx,%eax
   1417d:	99                   	cltd   
   1417e:	f7 7d ec             	idivl  -0x14(%ebp)
   14181:	89 c2                	mov    %eax,%edx
   14183:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14186:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14189:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1418c:	8b 40 0c             	mov    0xc(%eax),%eax
   1418f:	83 f8 02             	cmp    $0x2,%eax
   14192:	7f 0b                	jg     1419f <_DecodeSOF+0x377>
   14194:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14197:	8b 40 04             	mov    0x4(%eax),%eax
   1419a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1419d:	75 16                	jne    141b5 <_DecodeSOF+0x38d>
   1419f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141a2:	8b 40 10             	mov    0x10(%eax),%eax
   141a5:	83 f8 02             	cmp    $0x2,%eax
   141a8:	7f 19                	jg     141c3 <_DecodeSOF+0x39b>
   141aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141ad:	8b 40 08             	mov    0x8(%eax),%eax
   141b0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   141b3:	74 0e                	je     141c3 <_DecodeSOF+0x39b>
   141b5:	8b 45 08             	mov    0x8(%ebp),%eax
   141b8:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   141be:	e9 d2 00 00 00       	jmp    14295 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   141c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141c6:	8b 48 14             	mov    0x14(%eax),%ecx
   141c9:	8b 45 08             	mov    0x8(%ebp),%eax
   141cc:	8b 50 1c             	mov    0x1c(%eax),%edx
   141cf:	8b 45 08             	mov    0x8(%ebp),%eax
   141d2:	8b 40 24             	mov    0x24(%eax),%eax
   141d5:	0f af d0             	imul   %eax,%edx
   141d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141db:	8b 40 08             	mov    0x8(%eax),%eax
   141de:	0f af c2             	imul   %edx,%eax
   141e1:	99                   	cltd   
   141e2:	f7 7d f0             	idivl  -0x10(%ebp)
   141e5:	0f af c1             	imul   %ecx,%eax
   141e8:	83 ec 0c             	sub    $0xc,%esp
   141eb:	50                   	push   %eax
   141ec:	e8 45 c5 fe ff       	call   736 <malloc>
   141f1:	83 c4 10             	add    $0x10,%esp
   141f4:	89 c2                	mov    %eax,%edx
   141f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141f9:	89 50 28             	mov    %edx,0x28(%eax)
   141fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141ff:	8b 40 28             	mov    0x28(%eax),%eax
   14202:	85 c0                	test   %eax,%eax
   14204:	75 0e                	jne    14214 <_DecodeSOF+0x3ec>
   14206:	8b 45 08             	mov    0x8(%ebp),%eax
   14209:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1420f:	e9 81 00 00 00       	jmp    14295 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14214:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14218:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1421c:	8b 45 08             	mov    0x8(%ebp),%eax
   1421f:	8b 40 28             	mov    0x28(%eax),%eax
   14222:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14225:	0f 8f f4 fe ff ff    	jg     1411f <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   1422b:	8b 45 08             	mov    0x8(%ebp),%eax
   1422e:	8b 40 28             	mov    0x28(%eax),%eax
   14231:	83 f8 03             	cmp    $0x3,%eax
   14234:	75 47                	jne    1427d <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14236:	8b 45 08             	mov    0x8(%ebp),%eax
   14239:	8b 50 10             	mov    0x10(%eax),%edx
   1423c:	8b 45 08             	mov    0x8(%ebp),%eax
   1423f:	8b 40 14             	mov    0x14(%eax),%eax
   14242:	0f af d0             	imul   %eax,%edx
   14245:	8b 45 08             	mov    0x8(%ebp),%eax
   14248:	8b 40 28             	mov    0x28(%eax),%eax
   1424b:	0f af c2             	imul   %edx,%eax
   1424e:	83 ec 0c             	sub    $0xc,%esp
   14251:	50                   	push   %eax
   14252:	e8 df c4 fe ff       	call   736 <malloc>
   14257:	83 c4 10             	add    $0x10,%esp
   1425a:	89 c2                	mov    %eax,%edx
   1425c:	8b 45 08             	mov    0x8(%ebp),%eax
   1425f:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14265:	8b 45 08             	mov    0x8(%ebp),%eax
   14268:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1426e:	85 c0                	test   %eax,%eax
   14270:	75 0b                	jne    1427d <_DecodeSOF+0x455>
   14272:	8b 45 08             	mov    0x8(%ebp),%eax
   14275:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1427b:	eb 18                	jmp    14295 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1427d:	8b 45 08             	mov    0x8(%ebp),%eax
   14280:	8b 40 0c             	mov    0xc(%eax),%eax
   14283:	83 ec 08             	sub    $0x8,%esp
   14286:	50                   	push   %eax
   14287:	ff 75 08             	pushl  0x8(%ebp)
   1428a:	e8 20 f9 ff ff       	call   13baf <_Skip>
   1428f:	83 c4 10             	add    $0x10,%esp
   14292:	eb 01                	jmp    14295 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14294:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14295:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14298:	c9                   	leave  
   14299:	c3                   	ret    

0001429a <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   1429a:	55                   	push   %ebp
   1429b:	89 e5                	mov    %esp,%ebp
   1429d:	53                   	push   %ebx
   1429e:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   142a1:	83 ec 0c             	sub    $0xc,%esp
   142a4:	ff 75 08             	pushl  0x8(%ebp)
   142a7:	e8 4f f9 ff ff       	call   13bfb <_DecodeLength>
   142ac:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   142af:	8b 45 08             	mov    0x8(%ebp),%eax
   142b2:	8b 00                	mov    (%eax),%eax
   142b4:	85 c0                	test   %eax,%eax
   142b6:	0f 85 c5 01 00 00    	jne    14481 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   142bc:	e9 9c 01 00 00       	jmp    1445d <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   142c1:	8b 45 08             	mov    0x8(%ebp),%eax
   142c4:	8b 40 04             	mov    0x4(%eax),%eax
   142c7:	0f b6 00             	movzbl (%eax),%eax
   142ca:	0f b6 c0             	movzbl %al,%eax
   142cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   142d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142d3:	25 ec 00 00 00       	and    $0xec,%eax
   142d8:	85 c0                	test   %eax,%eax
   142da:	74 0e                	je     142ea <_DecodeDHT+0x50>
   142dc:	8b 45 08             	mov    0x8(%ebp),%eax
   142df:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   142e5:	e9 98 01 00 00       	jmp    14482 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   142ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142ed:	83 e0 02             	and    $0x2,%eax
   142f0:	85 c0                	test   %eax,%eax
   142f2:	74 0e                	je     14302 <_DecodeDHT+0x68>
   142f4:	8b 45 08             	mov    0x8(%ebp),%eax
   142f7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142fd:	e9 80 01 00 00       	jmp    14482 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   14302:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14305:	c1 f8 03             	sar    $0x3,%eax
   14308:	0b 45 f4             	or     -0xc(%ebp),%eax
   1430b:	83 e0 03             	and    $0x3,%eax
   1430e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14311:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14318:	eb 1c                	jmp    14336 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   1431a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1431d:	8d 50 ff             	lea    -0x1(%eax),%edx
   14320:	8b 45 08             	mov    0x8(%ebp),%eax
   14323:	8b 48 04             	mov    0x4(%eax),%ecx
   14326:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14329:	01 c8                	add    %ecx,%eax
   1432b:	0f b6 00             	movzbl (%eax),%eax
   1432e:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   14332:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14336:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1433a:	7e de                	jle    1431a <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   1433c:	83 ec 08             	sub    $0x8,%esp
   1433f:	6a 11                	push   $0x11
   14341:	ff 75 08             	pushl  0x8(%ebp)
   14344:	e8 66 f8 ff ff       	call   13baf <_Skip>
   14349:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   1434c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1434f:	c1 e0 11             	shl    $0x11,%eax
   14352:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14358:	8b 45 08             	mov    0x8(%ebp),%eax
   1435b:	01 d0                	add    %edx,%eax
   1435d:	83 c0 08             	add    $0x8,%eax
   14360:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14363:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   1436a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1436d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14370:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14377:	e9 be 00 00 00       	jmp    1443a <_DecodeDHT+0x1a0>
            spread >>= 1;
   1437c:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   1437f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14382:	83 e8 01             	sub    $0x1,%eax
   14385:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   1438a:	0f b6 c0             	movzbl %al,%eax
   1438d:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   14390:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14394:	0f 84 9b 00 00 00    	je     14435 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   1439a:	8b 45 08             	mov    0x8(%ebp),%eax
   1439d:	8b 40 0c             	mov    0xc(%eax),%eax
   143a0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   143a3:	7d 0e                	jge    143b3 <_DecodeDHT+0x119>
   143a5:	8b 45 08             	mov    0x8(%ebp),%eax
   143a8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143ae:	e9 cf 00 00 00       	jmp    14482 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   143b3:	b8 10 00 00 00       	mov    $0x10,%eax
   143b8:	2b 45 f0             	sub    -0x10(%ebp),%eax
   143bb:	8b 55 e0             	mov    -0x20(%ebp),%edx
   143be:	89 c1                	mov    %eax,%ecx
   143c0:	d3 e2                	shl    %cl,%edx
   143c2:	89 d0                	mov    %edx,%eax
   143c4:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   143c7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   143cb:	79 0e                	jns    143db <_DecodeDHT+0x141>
   143cd:	8b 45 08             	mov    0x8(%ebp),%eax
   143d0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143d6:	e9 a7 00 00 00       	jmp    14482 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   143db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   143e2:	eb 36                	jmp    1441a <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   143e4:	8b 45 08             	mov    0x8(%ebp),%eax
   143e7:	8b 50 04             	mov    0x4(%eax),%edx
   143ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143ed:	01 d0                	add    %edx,%eax
   143ef:	0f b6 00             	movzbl (%eax),%eax
   143f2:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   143f4:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   143f7:	eb 14                	jmp    1440d <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   143f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143fc:	89 c2                	mov    %eax,%edx
   143fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14401:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   14403:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14406:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14409:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   1440d:	89 d8                	mov    %ebx,%eax
   1440f:	8d 58 ff             	lea    -0x1(%eax),%ebx
   14412:	85 c0                	test   %eax,%eax
   14414:	75 e3                	jne    143f9 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   14416:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1441a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1441d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14420:	7c c2                	jl     143e4 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   14422:	83 ec 08             	sub    $0x8,%esp
   14425:	ff 75 e0             	pushl  -0x20(%ebp)
   14428:	ff 75 08             	pushl  0x8(%ebp)
   1442b:	e8 7f f7 ff ff       	call   13baf <_Skip>
   14430:	83 c4 10             	add    $0x10,%esp
   14433:	eb 01                	jmp    14436 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14435:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14436:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1443a:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1443e:	0f 8e 38 ff ff ff    	jle    1437c <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14444:	eb 0a                	jmp    14450 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14446:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14449:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   1444c:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14450:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14453:	8d 50 ff             	lea    -0x1(%eax),%edx
   14456:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14459:	85 c0                	test   %eax,%eax
   1445b:	75 e9                	jne    14446 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1445d:	8b 45 08             	mov    0x8(%ebp),%eax
   14460:	8b 40 0c             	mov    0xc(%eax),%eax
   14463:	83 f8 10             	cmp    $0x10,%eax
   14466:	0f 8f 55 fe ff ff    	jg     142c1 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1446c:	8b 45 08             	mov    0x8(%ebp),%eax
   1446f:	8b 40 0c             	mov    0xc(%eax),%eax
   14472:	85 c0                	test   %eax,%eax
   14474:	74 0c                	je     14482 <_DecodeDHT+0x1e8>
   14476:	8b 45 08             	mov    0x8(%ebp),%eax
   14479:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1447f:	eb 01                	jmp    14482 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14481:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14482:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14485:	c9                   	leave  
   14486:	c3                   	ret    

00014487 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14487:	55                   	push   %ebp
   14488:	89 e5                	mov    %esp,%ebp
   1448a:	53                   	push   %ebx
   1448b:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1448e:	83 ec 0c             	sub    $0xc,%esp
   14491:	ff 75 08             	pushl  0x8(%ebp)
   14494:	e8 62 f7 ff ff       	call   13bfb <_DecodeLength>
   14499:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1449c:	8b 45 08             	mov    0x8(%ebp),%eax
   1449f:	8b 00                	mov    (%eax),%eax
   144a1:	85 c0                	test   %eax,%eax
   144a3:	0f 85 e2 00 00 00    	jne    1458b <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   144a9:	e9 b8 00 00 00       	jmp    14566 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   144ae:	8b 45 08             	mov    0x8(%ebp),%eax
   144b1:	8b 40 04             	mov    0x4(%eax),%eax
   144b4:	0f b6 00             	movzbl (%eax),%eax
   144b7:	0f b6 c0             	movzbl %al,%eax
   144ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   144bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144c0:	25 ec 00 00 00       	and    $0xec,%eax
   144c5:	85 c0                	test   %eax,%eax
   144c7:	74 0e                	je     144d7 <_DecodeDQT+0x50>
   144c9:	8b 45 08             	mov    0x8(%ebp),%eax
   144cc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   144d2:	e9 b5 00 00 00       	jmp    1458c <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   144d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144da:	83 e0 10             	and    $0x10,%eax
   144dd:	85 c0                	test   %eax,%eax
   144df:	74 0e                	je     144ef <_DecodeDQT+0x68>
   144e1:	8b 45 08             	mov    0x8(%ebp),%eax
   144e4:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   144ea:	e9 9d 00 00 00       	jmp    1458c <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   144ef:	8b 45 08             	mov    0x8(%ebp),%eax
   144f2:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   144f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144fb:	bb 01 00 00 00       	mov    $0x1,%ebx
   14500:	89 c1                	mov    %eax,%ecx
   14502:	d3 e3                	shl    %cl,%ebx
   14504:	89 d8                	mov    %ebx,%eax
   14506:	09 c2                	or     %eax,%edx
   14508:	8b 45 08             	mov    0x8(%ebp),%eax
   1450b:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   14511:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14514:	c1 e0 06             	shl    $0x6,%eax
   14517:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   1451d:	8b 45 08             	mov    0x8(%ebp),%eax
   14520:	01 d0                	add    %edx,%eax
   14522:	83 c0 08             	add    $0x8,%eax
   14525:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14528:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1452f:	eb 1f                	jmp    14550 <_DecodeDQT+0xc9>
   14531:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14534:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14537:	01 c2                	add    %eax,%edx
   14539:	8b 45 08             	mov    0x8(%ebp),%eax
   1453c:	8b 40 04             	mov    0x4(%eax),%eax
   1453f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14542:	83 c1 01             	add    $0x1,%ecx
   14545:	01 c8                	add    %ecx,%eax
   14547:	0f b6 00             	movzbl (%eax),%eax
   1454a:	88 02                	mov    %al,(%edx)
   1454c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14550:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14554:	7e db                	jle    14531 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14556:	83 ec 08             	sub    $0x8,%esp
   14559:	6a 41                	push   $0x41
   1455b:	ff 75 08             	pushl  0x8(%ebp)
   1455e:	e8 4c f6 ff ff       	call   13baf <_Skip>
   14563:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14566:	8b 45 08             	mov    0x8(%ebp),%eax
   14569:	8b 40 0c             	mov    0xc(%eax),%eax
   1456c:	83 f8 40             	cmp    $0x40,%eax
   1456f:	0f 8f 39 ff ff ff    	jg     144ae <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14575:	8b 45 08             	mov    0x8(%ebp),%eax
   14578:	8b 40 0c             	mov    0xc(%eax),%eax
   1457b:	85 c0                	test   %eax,%eax
   1457d:	74 0d                	je     1458c <_DecodeDQT+0x105>
   1457f:	8b 45 08             	mov    0x8(%ebp),%eax
   14582:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14588:	90                   	nop
   14589:	eb 01                	jmp    1458c <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1458b:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1458c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1458f:	c9                   	leave  
   14590:	c3                   	ret    

00014591 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   14591:	55                   	push   %ebp
   14592:	89 e5                	mov    %esp,%ebp
   14594:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14597:	83 ec 0c             	sub    $0xc,%esp
   1459a:	ff 75 08             	pushl  0x8(%ebp)
   1459d:	e8 59 f6 ff ff       	call   13bfb <_DecodeLength>
   145a2:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   145a5:	8b 45 08             	mov    0x8(%ebp),%eax
   145a8:	8b 00                	mov    (%eax),%eax
   145aa:	85 c0                	test   %eax,%eax
   145ac:	75 4a                	jne    145f8 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   145ae:	8b 45 08             	mov    0x8(%ebp),%eax
   145b1:	8b 40 0c             	mov    0xc(%eax),%eax
   145b4:	83 f8 01             	cmp    $0x1,%eax
   145b7:	7f 0b                	jg     145c4 <_DecodeDRI+0x33>
   145b9:	8b 45 08             	mov    0x8(%ebp),%eax
   145bc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145c2:	eb 35                	jmp    145f9 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   145c4:	8b 45 08             	mov    0x8(%ebp),%eax
   145c7:	8b 40 04             	mov    0x4(%eax),%eax
   145ca:	83 ec 0c             	sub    $0xc,%esp
   145cd:	50                   	push   %eax
   145ce:	e8 8b f6 ff ff       	call   13c5e <_Decode2Bytes>
   145d3:	83 c4 10             	add    $0x10,%esp
   145d6:	89 c2                	mov    %eax,%edx
   145d8:	8b 45 08             	mov    0x8(%ebp),%eax
   145db:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   145e1:	8b 45 08             	mov    0x8(%ebp),%eax
   145e4:	8b 40 0c             	mov    0xc(%eax),%eax
   145e7:	83 ec 08             	sub    $0x8,%esp
   145ea:	50                   	push   %eax
   145eb:	ff 75 08             	pushl  0x8(%ebp)
   145ee:	e8 bc f5 ff ff       	call   13baf <_Skip>
   145f3:	83 c4 10             	add    $0x10,%esp
   145f6:	eb 01                	jmp    145f9 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   145f8:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   145f9:	c9                   	leave  
   145fa:	c3                   	ret    

000145fb <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   145fb:	55                   	push   %ebp
   145fc:	89 e5                	mov    %esp,%ebp
   145fe:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   14601:	8b 45 08             	mov    0x8(%ebp),%eax
   14604:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   1460a:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1460d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   14614:	83 ec 0c             	sub    $0xc,%esp
   14617:	ff 75 08             	pushl  0x8(%ebp)
   1461a:	e8 dc f5 ff ff       	call   13bfb <_DecodeLength>
   1461f:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14622:	8b 45 08             	mov    0x8(%ebp),%eax
   14625:	8b 00                	mov    (%eax),%eax
   14627:	85 c0                	test   %eax,%eax
   14629:	0f 85 c2 02 00 00    	jne    148f1 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   1462f:	8b 45 08             	mov    0x8(%ebp),%eax
   14632:	8b 50 0c             	mov    0xc(%eax),%edx
   14635:	8b 45 08             	mov    0x8(%ebp),%eax
   14638:	8b 40 28             	mov    0x28(%eax),%eax
   1463b:	83 c0 02             	add    $0x2,%eax
   1463e:	01 c0                	add    %eax,%eax
   14640:	39 c2                	cmp    %eax,%edx
   14642:	7c 16                	jl     1465a <_DecodeSOS+0x5f>
   14644:	8b 45 08             	mov    0x8(%ebp),%eax
   14647:	8b 40 04             	mov    0x4(%eax),%eax
   1464a:	0f b6 00             	movzbl (%eax),%eax
   1464d:	0f b6 d0             	movzbl %al,%edx
   14650:	8b 45 08             	mov    0x8(%ebp),%eax
   14653:	8b 40 28             	mov    0x28(%eax),%eax
   14656:	39 c2                	cmp    %eax,%edx
   14658:	74 0e                	je     14668 <_DecodeSOS+0x6d>
   1465a:	8b 45 08             	mov    0x8(%ebp),%eax
   1465d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14663:	e9 8d 02 00 00       	jmp    148f5 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14668:	83 ec 08             	sub    $0x8,%esp
   1466b:	6a 01                	push   $0x1
   1466d:	ff 75 08             	pushl  0x8(%ebp)
   14670:	e8 3a f5 ff ff       	call   13baf <_Skip>
   14675:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14678:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1467f:	8b 45 08             	mov    0x8(%ebp),%eax
   14682:	83 c0 2c             	add    $0x2c,%eax
   14685:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14688:	e9 ba 00 00 00       	jmp    14747 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   1468d:	8b 45 08             	mov    0x8(%ebp),%eax
   14690:	8b 40 04             	mov    0x4(%eax),%eax
   14693:	0f b6 00             	movzbl (%eax),%eax
   14696:	0f b6 d0             	movzbl %al,%edx
   14699:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1469c:	8b 00                	mov    (%eax),%eax
   1469e:	39 c2                	cmp    %eax,%edx
   146a0:	74 0e                	je     146b0 <_DecodeSOS+0xb5>
   146a2:	8b 45 08             	mov    0x8(%ebp),%eax
   146a5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146ab:	e9 45 02 00 00       	jmp    148f5 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   146b0:	8b 45 08             	mov    0x8(%ebp),%eax
   146b3:	8b 40 04             	mov    0x4(%eax),%eax
   146b6:	83 c0 01             	add    $0x1,%eax
   146b9:	0f b6 00             	movzbl (%eax),%eax
   146bc:	0f b6 c0             	movzbl %al,%eax
   146bf:	25 ec 00 00 00       	and    $0xec,%eax
   146c4:	85 c0                	test   %eax,%eax
   146c6:	74 0e                	je     146d6 <_DecodeSOS+0xdb>
   146c8:	8b 45 08             	mov    0x8(%ebp),%eax
   146cb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146d1:	e9 1f 02 00 00       	jmp    148f5 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   146d6:	8b 45 08             	mov    0x8(%ebp),%eax
   146d9:	8b 40 04             	mov    0x4(%eax),%eax
   146dc:	83 c0 01             	add    $0x1,%eax
   146df:	0f b6 00             	movzbl (%eax),%eax
   146e2:	0f b6 c0             	movzbl %al,%eax
   146e5:	83 e0 02             	and    $0x2,%eax
   146e8:	85 c0                	test   %eax,%eax
   146ea:	74 0e                	je     146fa <_DecodeSOS+0xff>
   146ec:	8b 45 08             	mov    0x8(%ebp),%eax
   146ef:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   146f5:	e9 fb 01 00 00       	jmp    148f5 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   146fa:	8b 45 08             	mov    0x8(%ebp),%eax
   146fd:	8b 40 04             	mov    0x4(%eax),%eax
   14700:	83 c0 01             	add    $0x1,%eax
   14703:	0f b6 00             	movzbl (%eax),%eax
   14706:	c0 e8 04             	shr    $0x4,%al
   14709:	0f b6 d0             	movzbl %al,%edx
   1470c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1470f:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   14712:	8b 45 08             	mov    0x8(%ebp),%eax
   14715:	8b 40 04             	mov    0x4(%eax),%eax
   14718:	83 c0 01             	add    $0x1,%eax
   1471b:	0f b6 00             	movzbl (%eax),%eax
   1471e:	0f b6 c0             	movzbl %al,%eax
   14721:	83 e0 01             	and    $0x1,%eax
   14724:	83 c8 02             	or     $0x2,%eax
   14727:	89 c2                	mov    %eax,%edx
   14729:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1472c:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   1472f:	83 ec 08             	sub    $0x8,%esp
   14732:	6a 02                	push   $0x2
   14734:	ff 75 08             	pushl  0x8(%ebp)
   14737:	e8 73 f4 ff ff       	call   13baf <_Skip>
   1473c:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1473f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14743:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14747:	8b 45 08             	mov    0x8(%ebp),%eax
   1474a:	8b 40 28             	mov    0x28(%eax),%eax
   1474d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14750:	0f 8f 37 ff ff ff    	jg     1468d <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14756:	8b 45 08             	mov    0x8(%ebp),%eax
   14759:	8b 40 04             	mov    0x4(%eax),%eax
   1475c:	0f b6 00             	movzbl (%eax),%eax
   1475f:	84 c0                	test   %al,%al
   14761:	75 10                	jne    14773 <_DecodeSOS+0x178>
   14763:	8b 45 08             	mov    0x8(%ebp),%eax
   14766:	8b 40 04             	mov    0x4(%eax),%eax
   14769:	83 c0 01             	add    $0x1,%eax
   1476c:	0f b6 00             	movzbl (%eax),%eax
   1476f:	3c 3f                	cmp    $0x3f,%al
   14771:	74 0e                	je     14781 <_DecodeSOS+0x186>
   14773:	8b 45 08             	mov    0x8(%ebp),%eax
   14776:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1477c:	e9 74 01 00 00       	jmp    148f5 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14781:	8b 45 08             	mov    0x8(%ebp),%eax
   14784:	8b 40 04             	mov    0x4(%eax),%eax
   14787:	83 c0 02             	add    $0x2,%eax
   1478a:	0f b6 00             	movzbl (%eax),%eax
   1478d:	84 c0                	test   %al,%al
   1478f:	74 0e                	je     1479f <_DecodeSOS+0x1a4>
   14791:	8b 45 08             	mov    0x8(%ebp),%eax
   14794:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1479a:	e9 56 01 00 00       	jmp    148f5 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   1479f:	8b 45 08             	mov    0x8(%ebp),%eax
   147a2:	8b 40 0c             	mov    0xc(%eax),%eax
   147a5:	83 ec 08             	sub    $0x8,%esp
   147a8:	50                   	push   %eax
   147a9:	ff 75 08             	pushl  0x8(%ebp)
   147ac:	e8 fe f3 ff ff       	call   13baf <_Skip>
   147b1:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   147b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   147bb:	e9 17 01 00 00       	jmp    148d7 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   147c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   147c7:	e9 f8 00 00 00       	jmp    148c4 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   147cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   147d3:	8b 45 08             	mov    0x8(%ebp),%eax
   147d6:	83 c0 2c             	add    $0x2c,%eax
   147d9:	89 45 dc             	mov    %eax,-0x24(%ebp)
   147dc:	e9 8d 00 00 00       	jmp    1486e <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   147e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   147e8:	eb 71                	jmp    1485b <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   147ea:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   147f1:	eb 59                	jmp    1484c <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   147f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147f6:	8b 50 28             	mov    0x28(%eax),%edx
   147f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147fc:	8b 40 08             	mov    0x8(%eax),%eax
   147ff:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14803:	89 c1                	mov    %eax,%ecx
   14805:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14808:	01 c1                	add    %eax,%ecx
   1480a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1480d:	8b 40 14             	mov    0x14(%eax),%eax
   14810:	0f af c8             	imul   %eax,%ecx
   14813:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14816:	8b 40 04             	mov    0x4(%eax),%eax
   14819:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   1481d:	01 c1                	add    %eax,%ecx
   1481f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14822:	01 c8                	add    %ecx,%eax
   14824:	c1 e0 03             	shl    $0x3,%eax
   14827:	01 d0                	add    %edx,%eax
   14829:	50                   	push   %eax
   1482a:	ff 75 dc             	pushl  -0x24(%ebp)
   1482d:	ff 75 0c             	pushl  0xc(%ebp)
   14830:	ff 75 08             	pushl  0x8(%ebp)
   14833:	e8 bf 00 00 00       	call   148f7 <_DecodeBlock>
   14838:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   1483b:	8b 45 08             	mov    0x8(%ebp),%eax
   1483e:	8b 00                	mov    (%eax),%eax
   14840:	85 c0                	test   %eax,%eax
   14842:	0f 85 ac 00 00 00    	jne    148f4 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14848:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1484c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1484f:	8b 40 04             	mov    0x4(%eax),%eax
   14852:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14855:	7f 9c                	jg     147f3 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14857:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1485b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1485e:	8b 40 08             	mov    0x8(%eax),%eax
   14861:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14864:	7f 84                	jg     147ea <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14866:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1486a:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1486e:	8b 45 08             	mov    0x8(%ebp),%eax
   14871:	8b 40 28             	mov    0x28(%eax),%eax
   14874:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14877:	0f 8f 64 ff ff ff    	jg     147e1 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   1487d:	8b 45 08             	mov    0x8(%ebp),%eax
   14880:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14886:	85 c0                	test   %eax,%eax
   14888:	74 36                	je     148c0 <_DecodeSOS+0x2c5>
   1488a:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   1488e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14892:	75 2c                	jne    148c0 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14894:	83 ec 0c             	sub    $0xc,%esp
   14897:	ff 75 08             	pushl  0x8(%ebp)
   1489a:	e8 9f 0a 00 00       	call   1533e <_ByteAlign>
   1489f:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   148a2:	83 ec 08             	sub    $0x8,%esp
   148a5:	6a 10                	push   $0x10
   148a7:	ff 75 08             	pushl  0x8(%ebp)
   148aa:	e8 ce 04 00 00       	call   14d7d <_GetBits>
   148af:	83 c4 10             	add    $0x10,%esp
   148b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   148b5:	8b 45 08             	mov    0x8(%ebp),%eax
   148b8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   148be:	eb 35                	jmp    148f5 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   148c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   148c4:	8b 45 08             	mov    0x8(%ebp),%eax
   148c7:	8b 40 18             	mov    0x18(%eax),%eax
   148ca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   148cd:	0f 8f f9 fe ff ff    	jg     147cc <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   148d3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   148d7:	8b 45 08             	mov    0x8(%ebp),%eax
   148da:	8b 40 1c             	mov    0x1c(%eax),%eax
   148dd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   148e0:	0f 8f da fe ff ff    	jg     147c0 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   148e6:	8b 45 08             	mov    0x8(%ebp),%eax
   148e9:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   148ef:	eb 04                	jmp    148f5 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   148f1:	90                   	nop
   148f2:	eb 01                	jmp    148f5 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   148f4:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   148f5:	c9                   	leave  
   148f6:	c3                   	ret    

000148f7 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   148f7:	55                   	push   %ebp
   148f8:	89 e5                	mov    %esp,%ebp
   148fa:	53                   	push   %ebx
   148fb:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   148fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14905:	8b 45 08             	mov    0x8(%ebp),%eax
   14908:	05 c0 01 08 00       	add    $0x801c0,%eax
   1490d:	83 ec 04             	sub    $0x4,%esp
   14910:	68 00 01 00 00       	push   $0x100
   14915:	6a 00                	push   $0x0
   14917:	50                   	push   %eax
   14918:	e8 04 b8 fe ff       	call   121 <memset>
   1491d:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   14920:	8b 45 10             	mov    0x10(%ebp),%eax
   14923:	8b 40 20             	mov    0x20(%eax),%eax
   14926:	c1 e0 11             	shl    $0x11,%eax
   14929:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1492f:	8b 45 08             	mov    0x8(%ebp),%eax
   14932:	01 d0                	add    %edx,%eax
   14934:	83 c0 08             	add    $0x8,%eax
   14937:	83 ec 04             	sub    $0x4,%esp
   1493a:	6a 00                	push   $0x0
   1493c:	50                   	push   %eax
   1493d:	ff 75 08             	pushl  0x8(%ebp)
   14940:	e8 86 01 00 00       	call   14acb <_GetVLC>
   14945:	83 c4 10             	add    $0x10,%esp
   14948:	89 c2                	mov    %eax,%edx
   1494a:	8b 45 10             	mov    0x10(%ebp),%eax
   1494d:	8b 40 24             	mov    0x24(%eax),%eax
   14950:	01 c2                	add    %eax,%edx
   14952:	8b 45 10             	mov    0x10(%ebp),%eax
   14955:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14958:	8b 45 10             	mov    0x10(%ebp),%eax
   1495b:	8b 50 24             	mov    0x24(%eax),%edx
   1495e:	8b 45 10             	mov    0x10(%ebp),%eax
   14961:	8b 48 18             	mov    0x18(%eax),%ecx
   14964:	8b 45 08             	mov    0x8(%ebp),%eax
   14967:	c1 e1 06             	shl    $0x6,%ecx
   1496a:	01 c8                	add    %ecx,%eax
   1496c:	05 b8 00 00 00       	add    $0xb8,%eax
   14971:	0f b6 00             	movzbl (%eax),%eax
   14974:	0f b6 c0             	movzbl %al,%eax
   14977:	0f af d0             	imul   %eax,%edx
   1497a:	8b 45 08             	mov    0x8(%ebp),%eax
   1497d:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14983:	8b 45 10             	mov    0x10(%ebp),%eax
   14986:	8b 40 1c             	mov    0x1c(%eax),%eax
   14989:	c1 e0 11             	shl    $0x11,%eax
   1498c:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14992:	8b 45 08             	mov    0x8(%ebp),%eax
   14995:	01 d0                	add    %edx,%eax
   14997:	8d 50 08             	lea    0x8(%eax),%edx
   1499a:	83 ec 04             	sub    $0x4,%esp
   1499d:	8d 45 ef             	lea    -0x11(%ebp),%eax
   149a0:	50                   	push   %eax
   149a1:	52                   	push   %edx
   149a2:	ff 75 08             	pushl  0x8(%ebp)
   149a5:	e8 21 01 00 00       	call   14acb <_GetVLC>
   149aa:	83 c4 10             	add    $0x10,%esp
   149ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   149b0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149b4:	84 c0                	test   %al,%al
   149b6:	0f 84 92 00 00 00    	je     14a4e <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   149bc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149c0:	0f b6 c0             	movzbl %al,%eax
   149c3:	83 e0 0f             	and    $0xf,%eax
   149c6:	85 c0                	test   %eax,%eax
   149c8:	75 16                	jne    149e0 <_DecodeBlock+0xe9>
   149ca:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149ce:	3c f0                	cmp    $0xf0,%al
   149d0:	74 0e                	je     149e0 <_DecodeBlock+0xe9>
   149d2:	8b 45 08             	mov    0x8(%ebp),%eax
   149d5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149db:	e9 e6 00 00 00       	jmp    14ac6 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   149e0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149e4:	c0 e8 04             	shr    $0x4,%al
   149e7:	0f b6 c0             	movzbl %al,%eax
   149ea:	83 c0 01             	add    $0x1,%eax
   149ed:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   149f0:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   149f4:	7e 0e                	jle    14a04 <_DecodeBlock+0x10d>
   149f6:	8b 45 08             	mov    0x8(%ebp),%eax
   149f9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149ff:	e9 c2 00 00 00       	jmp    14ac6 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14a04:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14a07:	8b 45 0c             	mov    0xc(%ebp),%eax
   14a0a:	01 d0                	add    %edx,%eax
   14a0c:	0f b6 00             	movzbl (%eax),%eax
   14a0f:	0f be c8             	movsbl %al,%ecx
   14a12:	8b 45 10             	mov    0x10(%ebp),%eax
   14a15:	8b 50 18             	mov    0x18(%eax),%edx
   14a18:	8b 45 08             	mov    0x8(%ebp),%eax
   14a1b:	c1 e2 06             	shl    $0x6,%edx
   14a1e:	01 c2                	add    %eax,%edx
   14a20:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a23:	01 d0                	add    %edx,%eax
   14a25:	05 b8 00 00 00       	add    $0xb8,%eax
   14a2a:	0f b6 00             	movzbl (%eax),%eax
   14a2d:	0f b6 c0             	movzbl %al,%eax
   14a30:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14a34:	89 c2                	mov    %eax,%edx
   14a36:	8b 45 08             	mov    0x8(%ebp),%eax
   14a39:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14a3f:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14a42:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14a46:	0f 8e 37 ff ff ff    	jle    14983 <_DecodeBlock+0x8c>
   14a4c:	eb 01                	jmp    14a4f <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14a4e:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14a4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a56:	eb 24                	jmp    14a7c <_DecodeBlock+0x185>
   14a58:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a5b:	05 70 00 02 00       	add    $0x20070,%eax
   14a60:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14a67:	8b 45 08             	mov    0x8(%ebp),%eax
   14a6a:	01 d0                	add    %edx,%eax
   14a6c:	83 ec 0c             	sub    $0xc,%esp
   14a6f:	50                   	push   %eax
   14a70:	e8 32 03 00 00       	call   14da7 <_RowIDCT>
   14a75:	83 c4 10             	add    $0x10,%esp
   14a78:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14a7c:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a80:	7e d6                	jle    14a58 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14a82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a89:	eb 35                	jmp    14ac0 <_DecodeBlock+0x1c9>
   14a8b:	8b 45 10             	mov    0x10(%ebp),%eax
   14a8e:	8b 40 14             	mov    0x14(%eax),%eax
   14a91:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14a94:	8b 55 14             	mov    0x14(%ebp),%edx
   14a97:	01 d1                	add    %edx,%ecx
   14a99:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14a9c:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14aa2:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14aa9:	8b 55 08             	mov    0x8(%ebp),%edx
   14aac:	01 da                	add    %ebx,%edx
   14aae:	83 ec 04             	sub    $0x4,%esp
   14ab1:	50                   	push   %eax
   14ab2:	51                   	push   %ecx
   14ab3:	52                   	push   %edx
   14ab4:	e8 7b 05 00 00       	call   15034 <_ColIDCT>
   14ab9:	83 c4 10             	add    $0x10,%esp
   14abc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14ac0:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14ac4:	7e c5                	jle    14a8b <_DecodeBlock+0x194>
}
   14ac6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14ac9:	c9                   	leave  
   14aca:	c3                   	ret    

00014acb <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14acb:	55                   	push   %ebp
   14acc:	89 e5                	mov    %esp,%ebp
   14ace:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14ad1:	83 ec 08             	sub    $0x8,%esp
   14ad4:	6a 10                	push   $0x10
   14ad6:	ff 75 08             	pushl  0x8(%ebp)
   14ad9:	e8 c2 00 00 00       	call   14ba0 <_ShowBits>
   14ade:	83 c4 10             	add    $0x10,%esp
   14ae1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14ae4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ae7:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14aea:	8b 45 0c             	mov    0xc(%ebp),%eax
   14aed:	01 d0                	add    %edx,%eax
   14aef:	0f b6 00             	movzbl (%eax),%eax
   14af2:	0f b6 c0             	movzbl %al,%eax
   14af5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14af8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14afc:	75 13                	jne    14b11 <_GetVLC+0x46>
   14afe:	8b 45 08             	mov    0x8(%ebp),%eax
   14b01:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b07:	b8 00 00 00 00       	mov    $0x0,%eax
   14b0c:	e9 8d 00 00 00       	jmp    14b9e <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14b11:	83 ec 08             	sub    $0x8,%esp
   14b14:	ff 75 f0             	pushl  -0x10(%ebp)
   14b17:	ff 75 08             	pushl  0x8(%ebp)
   14b1a:	e8 25 02 00 00       	call   14d44 <_SkipBits>
   14b1f:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b25:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14b28:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b2b:	01 d0                	add    %edx,%eax
   14b2d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14b31:	0f b6 c0             	movzbl %al,%eax
   14b34:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14b37:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14b3b:	74 0a                	je     14b47 <_GetVLC+0x7c>
   14b3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b40:	89 c2                	mov    %eax,%edx
   14b42:	8b 45 10             	mov    0x10(%ebp),%eax
   14b45:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b4a:	83 e0 0f             	and    $0xf,%eax
   14b4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14b50:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b54:	75 07                	jne    14b5d <_GetVLC+0x92>
   14b56:	b8 00 00 00 00       	mov    $0x0,%eax
   14b5b:	eb 41                	jmp    14b9e <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14b5d:	83 ec 08             	sub    $0x8,%esp
   14b60:	ff 75 f0             	pushl  -0x10(%ebp)
   14b63:	ff 75 08             	pushl  0x8(%ebp)
   14b66:	e8 12 02 00 00       	call   14d7d <_GetBits>
   14b6b:	83 c4 10             	add    $0x10,%esp
   14b6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14b71:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b74:	83 e8 01             	sub    $0x1,%eax
   14b77:	ba 01 00 00 00       	mov    $0x1,%edx
   14b7c:	89 c1                	mov    %eax,%ecx
   14b7e:	d3 e2                	shl    %cl,%edx
   14b80:	89 d0                	mov    %edx,%eax
   14b82:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14b85:	7e 14                	jle    14b9b <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b8a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14b8f:	89 c1                	mov    %eax,%ecx
   14b91:	d3 e2                	shl    %cl,%edx
   14b93:	89 d0                	mov    %edx,%eax
   14b95:	83 c0 01             	add    $0x1,%eax
   14b98:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14b9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14b9e:	c9                   	leave  
   14b9f:	c3                   	ret    

00014ba0 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14ba0:	55                   	push   %ebp
   14ba1:	89 e5                	mov    %esp,%ebp
   14ba3:	53                   	push   %ebx
   14ba4:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14ba7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14bab:	0f 85 4f 01 00 00    	jne    14d00 <_ShowBits+0x160>
   14bb1:	b8 00 00 00 00       	mov    $0x0,%eax
   14bb6:	e9 83 01 00 00       	jmp    14d3e <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14bbb:	8b 45 08             	mov    0x8(%ebp),%eax
   14bbe:	8b 40 08             	mov    0x8(%eax),%eax
   14bc1:	85 c0                	test   %eax,%eax
   14bc3:	7f 33                	jg     14bf8 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14bc5:	8b 45 08             	mov    0x8(%ebp),%eax
   14bc8:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14bce:	c1 e0 08             	shl    $0x8,%eax
   14bd1:	0c ff                	or     $0xff,%al
   14bd3:	89 c2                	mov    %eax,%edx
   14bd5:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd8:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14bde:	8b 45 08             	mov    0x8(%ebp),%eax
   14be1:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14be7:	8d 50 08             	lea    0x8(%eax),%edx
   14bea:	8b 45 08             	mov    0x8(%ebp),%eax
   14bed:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14bf3:	e9 08 01 00 00       	jmp    14d00 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14bf8:	8b 45 08             	mov    0x8(%ebp),%eax
   14bfb:	8b 40 04             	mov    0x4(%eax),%eax
   14bfe:	8d 48 01             	lea    0x1(%eax),%ecx
   14c01:	8b 55 08             	mov    0x8(%ebp),%edx
   14c04:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c07:	0f b6 00             	movzbl (%eax),%eax
   14c0a:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14c0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14c10:	8b 40 08             	mov    0x8(%eax),%eax
   14c13:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c16:	8b 45 08             	mov    0x8(%ebp),%eax
   14c19:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14c1c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c1f:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14c25:	8d 50 08             	lea    0x8(%eax),%edx
   14c28:	8b 45 08             	mov    0x8(%ebp),%eax
   14c2b:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14c31:	8b 45 08             	mov    0x8(%ebp),%eax
   14c34:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c3a:	c1 e0 08             	shl    $0x8,%eax
   14c3d:	89 c2                	mov    %eax,%edx
   14c3f:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14c43:	09 c2                	or     %eax,%edx
   14c45:	8b 45 08             	mov    0x8(%ebp),%eax
   14c48:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14c4e:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14c52:	0f 85 a8 00 00 00    	jne    14d00 <_ShowBits+0x160>
            if(ctx->size){
   14c58:	8b 45 08             	mov    0x8(%ebp),%eax
   14c5b:	8b 40 08             	mov    0x8(%eax),%eax
   14c5e:	85 c0                	test   %eax,%eax
   14c60:	0f 84 91 00 00 00    	je     14cf7 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14c66:	8b 45 08             	mov    0x8(%ebp),%eax
   14c69:	8b 40 04             	mov    0x4(%eax),%eax
   14c6c:	8d 48 01             	lea    0x1(%eax),%ecx
   14c6f:	8b 55 08             	mov    0x8(%ebp),%edx
   14c72:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c75:	0f b6 00             	movzbl (%eax),%eax
   14c78:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14c7b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7e:	8b 40 08             	mov    0x8(%eax),%eax
   14c81:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c84:	8b 45 08             	mov    0x8(%ebp),%eax
   14c87:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14c8a:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14c8e:	85 c0                	test   %eax,%eax
   14c90:	74 62                	je     14cf4 <_ShowBits+0x154>
   14c92:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14c97:	75 0c                	jne    14ca5 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14c99:	8b 45 08             	mov    0x8(%ebp),%eax
   14c9c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14ca3:	eb 5b                	jmp    14d00 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14ca5:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14ca9:	25 f8 00 00 00       	and    $0xf8,%eax
   14cae:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14cb3:	74 0b                	je     14cc0 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14cb5:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14cbe:	eb 40                	jmp    14d00 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14cc0:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc3:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14cc9:	c1 e0 08             	shl    $0x8,%eax
   14ccc:	89 c2                	mov    %eax,%edx
   14cce:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14cd2:	09 c2                	or     %eax,%edx
   14cd4:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd7:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14cdd:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce0:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ce6:	8d 50 08             	lea    0x8(%eax),%edx
   14ce9:	8b 45 08             	mov    0x8(%ebp),%eax
   14cec:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14cf2:	eb 0c                	jmp    14d00 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14cf4:	90                   	nop
   14cf5:	eb 09                	jmp    14d00 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14cf7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cfa:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14d00:	8b 45 08             	mov    0x8(%ebp),%eax
   14d03:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d09:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d0c:	0f 8c a9 fe ff ff    	jl     14bbb <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14d12:	8b 45 08             	mov    0x8(%ebp),%eax
   14d15:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14d1b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d1e:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d24:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d27:	89 c1                	mov    %eax,%ecx
   14d29:	d3 fa                	sar    %cl,%edx
   14d2b:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d2e:	bb 01 00 00 00       	mov    $0x1,%ebx
   14d33:	89 c1                	mov    %eax,%ecx
   14d35:	d3 e3                	shl    %cl,%ebx
   14d37:	89 d8                	mov    %ebx,%eax
   14d39:	83 e8 01             	sub    $0x1,%eax
   14d3c:	21 d0                	and    %edx,%eax
}
   14d3e:	83 c4 10             	add    $0x10,%esp
   14d41:	5b                   	pop    %ebx
   14d42:	5d                   	pop    %ebp
   14d43:	c3                   	ret    

00014d44 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14d44:	55                   	push   %ebp
   14d45:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14d47:	8b 45 08             	mov    0x8(%ebp),%eax
   14d4a:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d50:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d53:	7d 0e                	jge    14d63 <_SkipBits+0x1f>
   14d55:	ff 75 0c             	pushl  0xc(%ebp)
   14d58:	ff 75 08             	pushl  0x8(%ebp)
   14d5b:	e8 40 fe ff ff       	call   14ba0 <_ShowBits>
   14d60:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14d63:	8b 45 08             	mov    0x8(%ebp),%eax
   14d66:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d6c:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d6f:	89 c2                	mov    %eax,%edx
   14d71:	8b 45 08             	mov    0x8(%ebp),%eax
   14d74:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14d7a:	90                   	nop
   14d7b:	c9                   	leave  
   14d7c:	c3                   	ret    

00014d7d <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14d7d:	55                   	push   %ebp
   14d7e:	89 e5                	mov    %esp,%ebp
   14d80:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14d83:	ff 75 0c             	pushl  0xc(%ebp)
   14d86:	ff 75 08             	pushl  0x8(%ebp)
   14d89:	e8 12 fe ff ff       	call   14ba0 <_ShowBits>
   14d8e:	83 c4 08             	add    $0x8,%esp
   14d91:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14d94:	ff 75 0c             	pushl  0xc(%ebp)
   14d97:	ff 75 08             	pushl  0x8(%ebp)
   14d9a:	e8 a5 ff ff ff       	call   14d44 <_SkipBits>
   14d9f:	83 c4 08             	add    $0x8,%esp
    return res;
   14da2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14da5:	c9                   	leave  
   14da6:	c3                   	ret    

00014da7 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14da7:	55                   	push   %ebp
   14da8:	89 e5                	mov    %esp,%ebp
   14daa:	57                   	push   %edi
   14dab:	56                   	push   %esi
   14dac:	53                   	push   %ebx
   14dad:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14db0:	8b 45 08             	mov    0x8(%ebp),%eax
   14db3:	83 c0 10             	add    $0x10,%eax
   14db6:	8b 00                	mov    (%eax),%eax
   14db8:	c1 e0 0b             	shl    $0xb,%eax
   14dbb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14dbe:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc1:	8b 40 18             	mov    0x18(%eax),%eax
   14dc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14dc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14dca:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14dcd:	8b 55 08             	mov    0x8(%ebp),%edx
   14dd0:	8b 52 08             	mov    0x8(%edx),%edx
   14dd3:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14dd6:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14dd9:	8b 55 08             	mov    0x8(%ebp),%edx
   14ddc:	8b 52 04             	mov    0x4(%edx),%edx
   14ddf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14de2:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14de5:	8b 55 08             	mov    0x8(%ebp),%edx
   14de8:	8b 52 1c             	mov    0x1c(%edx),%edx
   14deb:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14dee:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14df1:	8b 55 08             	mov    0x8(%ebp),%edx
   14df4:	8b 52 14             	mov    0x14(%edx),%edx
   14df7:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14dfa:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14dfd:	8b 55 08             	mov    0x8(%ebp),%edx
   14e00:	8b 52 0c             	mov    0xc(%edx),%edx
   14e03:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14e06:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14e09:	85 c0                	test   %eax,%eax
   14e0b:	75 68                	jne    14e75 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14e0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14e10:	8d 48 04             	lea    0x4(%eax),%ecx
   14e13:	8b 45 08             	mov    0x8(%ebp),%eax
   14e16:	8d 58 08             	lea    0x8(%eax),%ebx
   14e19:	8b 45 08             	mov    0x8(%ebp),%eax
   14e1c:	8d 70 0c             	lea    0xc(%eax),%esi
   14e1f:	8b 45 08             	mov    0x8(%ebp),%eax
   14e22:	8d 78 10             	lea    0x10(%eax),%edi
   14e25:	8b 45 08             	mov    0x8(%ebp),%eax
   14e28:	83 c0 14             	add    $0x14,%eax
   14e2b:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   14e31:	83 c0 18             	add    $0x18,%eax
   14e34:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14e37:	8b 45 08             	mov    0x8(%ebp),%eax
   14e3a:	8d 50 1c             	lea    0x1c(%eax),%edx
   14e3d:	8b 45 08             	mov    0x8(%ebp),%eax
   14e40:	8b 00                	mov    (%eax),%eax
   14e42:	c1 e0 03             	shl    $0x3,%eax
   14e45:	89 02                	mov    %eax,(%edx)
   14e47:	8b 02                	mov    (%edx),%eax
   14e49:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14e4c:	89 02                	mov    %eax,(%edx)
   14e4e:	89 d0                	mov    %edx,%eax
   14e50:	8b 00                	mov    (%eax),%eax
   14e52:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14e55:	89 02                	mov    %eax,(%edx)
   14e57:	89 d0                	mov    %edx,%eax
   14e59:	8b 00                	mov    (%eax),%eax
   14e5b:	89 07                	mov    %eax,(%edi)
   14e5d:	8b 07                	mov    (%edi),%eax
   14e5f:	89 06                	mov    %eax,(%esi)
   14e61:	8b 06                	mov    (%esi),%eax
   14e63:	89 03                	mov    %eax,(%ebx)
   14e65:	8b 03                	mov    (%ebx),%eax
   14e67:	89 01                	mov    %eax,(%ecx)
   14e69:	8b 11                	mov    (%ecx),%edx
   14e6b:	8b 45 08             	mov    0x8(%ebp),%eax
   14e6e:	89 10                	mov    %edx,(%eax)
        return;
   14e70:	e9 b7 01 00 00       	jmp    1502c <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14e75:	8b 45 08             	mov    0x8(%ebp),%eax
   14e78:	8b 00                	mov    (%eax),%eax
   14e7a:	c1 e0 0b             	shl    $0xb,%eax
   14e7d:	83 e8 80             	sub    $0xffffff80,%eax
   14e80:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14e83:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14e86:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14e89:	01 d0                	add    %edx,%eax
   14e8b:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14e91:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14e94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14e97:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14e9d:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ea0:	01 d0                	add    %edx,%eax
   14ea2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14ea5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14ea8:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14eae:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14eb1:	01 d0                	add    %edx,%eax
   14eb3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14eb6:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14eb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14ebc:	01 d0                	add    %edx,%eax
   14ebe:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14ec4:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14ec7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14eca:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14ed0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ed3:	01 d0                	add    %edx,%eax
   14ed5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14ed8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14edb:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14ee1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ee4:	01 d0                	add    %edx,%eax
   14ee6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14ee9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14eec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14eef:	01 d0                	add    %edx,%eax
   14ef1:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14ef4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ef7:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14efa:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14efd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f00:	01 d0                	add    %edx,%eax
   14f02:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14f08:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14f0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f0e:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   14f14:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f17:	01 d0                	add    %edx,%eax
   14f19:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   14f1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f1f:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   14f25:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f28:	01 d0                	add    %edx,%eax
   14f2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   14f2d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f30:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f33:	01 d0                	add    %edx,%eax
   14f35:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   14f38:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f3b:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   14f3e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14f41:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f44:	01 d0                	add    %edx,%eax
   14f46:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   14f49:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f4c:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   14f4f:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14f52:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f55:	01 d0                	add    %edx,%eax
   14f57:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   14f5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f5d:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   14f60:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f63:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f66:	01 d0                	add    %edx,%eax
   14f68:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   14f6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f6e:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   14f71:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f74:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f77:	01 d0                	add    %edx,%eax
   14f79:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14f7f:	83 e8 80             	sub    $0xffffff80,%eax
   14f82:	c1 f8 08             	sar    $0x8,%eax
   14f85:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   14f88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f8b:	2b 45 e0             	sub    -0x20(%ebp),%eax
   14f8e:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14f94:	83 e8 80             	sub    $0xffffff80,%eax
   14f97:	c1 f8 08             	sar    $0x8,%eax
   14f9a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   14f9d:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14fa0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fa3:	01 d0                	add    %edx,%eax
   14fa5:	c1 f8 08             	sar    $0x8,%eax
   14fa8:	89 c2                	mov    %eax,%edx
   14faa:	8b 45 08             	mov    0x8(%ebp),%eax
   14fad:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   14faf:	8b 45 08             	mov    0x8(%ebp),%eax
   14fb2:	83 c0 04             	add    $0x4,%eax
   14fb5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   14fb8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14fbb:	01 ca                	add    %ecx,%edx
   14fbd:	c1 fa 08             	sar    $0x8,%edx
   14fc0:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   14fc2:	8b 45 08             	mov    0x8(%ebp),%eax
   14fc5:	83 c0 08             	add    $0x8,%eax
   14fc8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   14fcb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14fce:	01 ca                	add    %ecx,%edx
   14fd0:	c1 fa 08             	sar    $0x8,%edx
   14fd3:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   14fd5:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd8:	83 c0 0c             	add    $0xc,%eax
   14fdb:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   14fde:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14fe1:	01 ca                	add    %ecx,%edx
   14fe3:	c1 fa 08             	sar    $0x8,%edx
   14fe6:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   14fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   14feb:	8d 50 10             	lea    0x10(%eax),%edx
   14fee:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ff1:	2b 45 dc             	sub    -0x24(%ebp),%eax
   14ff4:	c1 f8 08             	sar    $0x8,%eax
   14ff7:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   14ff9:	8b 45 08             	mov    0x8(%ebp),%eax
   14ffc:	8d 50 14             	lea    0x14(%eax),%edx
   14fff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   15002:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15005:	c1 f8 08             	sar    $0x8,%eax
   15008:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   1500a:	8b 45 08             	mov    0x8(%ebp),%eax
   1500d:	8d 50 18             	lea    0x18(%eax),%edx
   15010:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15013:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15016:	c1 f8 08             	sar    $0x8,%eax
   15019:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   1501b:	8b 45 08             	mov    0x8(%ebp),%eax
   1501e:	8d 50 1c             	lea    0x1c(%eax),%edx
   15021:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15024:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15027:	c1 f8 08             	sar    $0x8,%eax
   1502a:	89 02                	mov    %eax,(%edx)
}
   1502c:	83 c4 38             	add    $0x38,%esp
   1502f:	5b                   	pop    %ebx
   15030:	5e                   	pop    %esi
   15031:	5f                   	pop    %edi
   15032:	5d                   	pop    %ebp
   15033:	c3                   	ret    

00015034 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   15034:	55                   	push   %ebp
   15035:	89 e5                	mov    %esp,%ebp
   15037:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1503a:	8b 45 08             	mov    0x8(%ebp),%eax
   1503d:	83 e8 80             	sub    $0xffffff80,%eax
   15040:	8b 00                	mov    (%eax),%eax
   15042:	c1 e0 08             	shl    $0x8,%eax
   15045:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15048:	8b 45 08             	mov    0x8(%ebp),%eax
   1504b:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15051:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15054:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15057:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   1505a:	8b 55 08             	mov    0x8(%ebp),%edx
   1505d:	8b 52 40             	mov    0x40(%edx),%edx
   15060:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15063:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15066:	8b 55 08             	mov    0x8(%ebp),%edx
   15069:	8b 52 20             	mov    0x20(%edx),%edx
   1506c:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1506f:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15072:	8b 55 08             	mov    0x8(%ebp),%edx
   15075:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   1507b:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1507e:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   15081:	8b 55 08             	mov    0x8(%ebp),%edx
   15084:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   1508a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1508d:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   15090:	8b 55 08             	mov    0x8(%ebp),%edx
   15093:	8b 52 60             	mov    0x60(%edx),%edx
   15096:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15099:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1509c:	85 c0                	test   %eax,%eax
   1509e:	75 45                	jne    150e5 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   150a0:	8b 45 08             	mov    0x8(%ebp),%eax
   150a3:	8b 00                	mov    (%eax),%eax
   150a5:	83 c0 20             	add    $0x20,%eax
   150a8:	c1 f8 06             	sar    $0x6,%eax
   150ab:	83 e8 80             	sub    $0xffffff80,%eax
   150ae:	50                   	push   %eax
   150af:	e8 d6 ea ff ff       	call   13b8a <_Clip>
   150b4:	83 c4 04             	add    $0x4,%esp
   150b7:	0f b6 c0             	movzbl %al,%eax
   150ba:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   150bd:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   150c4:	eb 14                	jmp    150da <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   150c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   150c9:	89 c2                	mov    %eax,%edx
   150cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   150ce:	88 10                	mov    %dl,(%eax)
            out += stride;
   150d0:	8b 45 10             	mov    0x10(%ebp),%eax
   150d3:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   150d6:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   150da:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   150de:	75 e6                	jne    150c6 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   150e0:	e9 57 02 00 00       	jmp    1533c <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   150e5:	8b 45 08             	mov    0x8(%ebp),%eax
   150e8:	8b 00                	mov    (%eax),%eax
   150ea:	c1 e0 08             	shl    $0x8,%eax
   150ed:	05 00 20 00 00       	add    $0x2000,%eax
   150f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   150f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   150f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150fb:	01 d0                	add    %edx,%eax
   150fd:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15103:	83 c0 04             	add    $0x4,%eax
   15106:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15109:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1510c:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   15112:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15115:	01 d0                	add    %edx,%eax
   15117:	c1 f8 03             	sar    $0x3,%eax
   1511a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   1511d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15120:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15126:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15129:	01 d0                	add    %edx,%eax
   1512b:	c1 f8 03             	sar    $0x3,%eax
   1512e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   15131:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15134:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15137:	01 d0                	add    %edx,%eax
   15139:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1513f:	83 c0 04             	add    $0x4,%eax
   15142:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15145:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15148:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1514e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15151:	01 d0                	add    %edx,%eax
   15153:	c1 f8 03             	sar    $0x3,%eax
   15156:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15159:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1515c:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15162:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15165:	01 d0                	add    %edx,%eax
   15167:	c1 f8 03             	sar    $0x3,%eax
   1516a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1516d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15170:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15173:	01 d0                	add    %edx,%eax
   15175:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15178:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1517b:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1517e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15181:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15184:	01 d0                	add    %edx,%eax
   15186:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1518c:	83 c0 04             	add    $0x4,%eax
   1518f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   15192:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15195:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1519b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1519e:	01 d0                	add    %edx,%eax
   151a0:	c1 f8 03             	sar    $0x3,%eax
   151a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   151a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151a9:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   151af:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151b2:	01 d0                	add    %edx,%eax
   151b4:	c1 f8 03             	sar    $0x3,%eax
   151b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   151ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151c0:	01 d0                	add    %edx,%eax
   151c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   151c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151c8:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   151cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
   151ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151d1:	01 d0                	add    %edx,%eax
   151d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   151d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151d9:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   151dc:	8b 55 dc             	mov    -0x24(%ebp),%edx
   151df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151e2:	01 d0                	add    %edx,%eax
   151e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   151e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151ea:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   151ed:	8b 55 fc             	mov    -0x4(%ebp),%edx
   151f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151f3:	01 d0                	add    %edx,%eax
   151f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   151f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151fb:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   151fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15201:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15204:	01 d0                	add    %edx,%eax
   15206:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1520c:	83 e8 80             	sub    $0xffffff80,%eax
   1520f:	c1 f8 08             	sar    $0x8,%eax
   15212:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15215:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15218:	2b 45 e8             	sub    -0x18(%ebp),%eax
   1521b:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15221:	83 e8 80             	sub    $0xffffff80,%eax
   15224:	c1 f8 08             	sar    $0x8,%eax
   15227:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   1522a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1522d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15230:	01 d0                	add    %edx,%eax
   15232:	c1 f8 0e             	sar    $0xe,%eax
   15235:	83 e8 80             	sub    $0xffffff80,%eax
   15238:	50                   	push   %eax
   15239:	e8 4c e9 ff ff       	call   13b8a <_Clip>
   1523e:	83 c4 04             	add    $0x4,%esp
   15241:	89 c2                	mov    %eax,%edx
   15243:	8b 45 0c             	mov    0xc(%ebp),%eax
   15246:	88 10                	mov    %dl,(%eax)
   15248:	8b 45 10             	mov    0x10(%ebp),%eax
   1524b:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   1524e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15251:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15254:	01 d0                	add    %edx,%eax
   15256:	c1 f8 0e             	sar    $0xe,%eax
   15259:	83 e8 80             	sub    $0xffffff80,%eax
   1525c:	50                   	push   %eax
   1525d:	e8 28 e9 ff ff       	call   13b8a <_Clip>
   15262:	83 c4 04             	add    $0x4,%esp
   15265:	89 c2                	mov    %eax,%edx
   15267:	8b 45 0c             	mov    0xc(%ebp),%eax
   1526a:	88 10                	mov    %dl,(%eax)
   1526c:	8b 45 10             	mov    0x10(%ebp),%eax
   1526f:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15272:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15275:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15278:	01 d0                	add    %edx,%eax
   1527a:	c1 f8 0e             	sar    $0xe,%eax
   1527d:	83 e8 80             	sub    $0xffffff80,%eax
   15280:	50                   	push   %eax
   15281:	e8 04 e9 ff ff       	call   13b8a <_Clip>
   15286:	83 c4 04             	add    $0x4,%esp
   15289:	89 c2                	mov    %eax,%edx
   1528b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1528e:	88 10                	mov    %dl,(%eax)
   15290:	8b 45 10             	mov    0x10(%ebp),%eax
   15293:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15296:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15299:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1529c:	01 d0                	add    %edx,%eax
   1529e:	c1 f8 0e             	sar    $0xe,%eax
   152a1:	83 e8 80             	sub    $0xffffff80,%eax
   152a4:	50                   	push   %eax
   152a5:	e8 e0 e8 ff ff       	call   13b8a <_Clip>
   152aa:	83 c4 04             	add    $0x4,%esp
   152ad:	89 c2                	mov    %eax,%edx
   152af:	8b 45 0c             	mov    0xc(%ebp),%eax
   152b2:	88 10                	mov    %dl,(%eax)
   152b4:	8b 45 10             	mov    0x10(%ebp),%eax
   152b7:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   152ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152bd:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   152c0:	c1 f8 0e             	sar    $0xe,%eax
   152c3:	83 e8 80             	sub    $0xffffff80,%eax
   152c6:	50                   	push   %eax
   152c7:	e8 be e8 ff ff       	call   13b8a <_Clip>
   152cc:	83 c4 04             	add    $0x4,%esp
   152cf:	89 c2                	mov    %eax,%edx
   152d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   152d4:	88 10                	mov    %dl,(%eax)
   152d6:	8b 45 10             	mov    0x10(%ebp),%eax
   152d9:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   152dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   152df:	2b 45 ec             	sub    -0x14(%ebp),%eax
   152e2:	c1 f8 0e             	sar    $0xe,%eax
   152e5:	83 e8 80             	sub    $0xffffff80,%eax
   152e8:	50                   	push   %eax
   152e9:	e8 9c e8 ff ff       	call   13b8a <_Clip>
   152ee:	83 c4 04             	add    $0x4,%esp
   152f1:	89 c2                	mov    %eax,%edx
   152f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   152f6:	88 10                	mov    %dl,(%eax)
   152f8:	8b 45 10             	mov    0x10(%ebp),%eax
   152fb:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   152fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15301:	2b 45 f4             	sub    -0xc(%ebp),%eax
   15304:	c1 f8 0e             	sar    $0xe,%eax
   15307:	83 e8 80             	sub    $0xffffff80,%eax
   1530a:	50                   	push   %eax
   1530b:	e8 7a e8 ff ff       	call   13b8a <_Clip>
   15310:	83 c4 04             	add    $0x4,%esp
   15313:	89 c2                	mov    %eax,%edx
   15315:	8b 45 0c             	mov    0xc(%ebp),%eax
   15318:	88 10                	mov    %dl,(%eax)
   1531a:	8b 45 10             	mov    0x10(%ebp),%eax
   1531d:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   15320:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15323:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15326:	c1 f8 0e             	sar    $0xe,%eax
   15329:	83 e8 80             	sub    $0xffffff80,%eax
   1532c:	50                   	push   %eax
   1532d:	e8 58 e8 ff ff       	call   13b8a <_Clip>
   15332:	83 c4 04             	add    $0x4,%esp
   15335:	89 c2                	mov    %eax,%edx
   15337:	8b 45 0c             	mov    0xc(%ebp),%eax
   1533a:	88 10                	mov    %dl,(%eax)
}
   1533c:	c9                   	leave  
   1533d:	c3                   	ret    

0001533e <_ByteAlign>:

void _ByteAlign(Context* ctx){
   1533e:	55                   	push   %ebp
   1533f:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15341:	8b 45 08             	mov    0x8(%ebp),%eax
   15344:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1534a:	25 f8 00 00 00       	and    $0xf8,%eax
   1534f:	89 c2                	mov    %eax,%edx
   15351:	8b 45 08             	mov    0x8(%ebp),%eax
   15354:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1535a:	90                   	nop
   1535b:	5d                   	pop    %ebp
   1535c:	c3                   	ret    

0001535d <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1535d:	55                   	push   %ebp
   1535e:	89 e5                	mov    %esp,%ebp
   15360:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15363:	83 ec 0c             	sub    $0xc,%esp
   15366:	ff 75 08             	pushl  0x8(%ebp)
   15369:	e8 8d e8 ff ff       	call   13bfb <_DecodeLength>
   1536e:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15371:	8b 45 08             	mov    0x8(%ebp),%eax
   15374:	8b 40 0c             	mov    0xc(%eax),%eax
   15377:	83 ec 08             	sub    $0x8,%esp
   1537a:	50                   	push   %eax
   1537b:	ff 75 08             	pushl  0x8(%ebp)
   1537e:	e8 2c e8 ff ff       	call   13baf <_Skip>
   15383:	83 c4 10             	add    $0x10,%esp
}
   15386:	90                   	nop
   15387:	c9                   	leave  
   15388:	c3                   	ret    

00015389 <_Convert>:

void _Convert(Context* ctx){
   15389:	55                   	push   %ebp
   1538a:	89 e5                	mov    %esp,%ebp
   1538c:	57                   	push   %edi
   1538d:	56                   	push   %esi
   1538e:	53                   	push   %ebx
   1538f:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15392:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15399:	8b 45 08             	mov    0x8(%ebp),%eax
   1539c:	83 c0 2c             	add    $0x2c,%eax
   1539f:	89 45 e0             	mov    %eax,-0x20(%ebp)
   153a2:	e9 b2 00 00 00       	jmp    15459 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   153a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153aa:	8b 50 0c             	mov    0xc(%eax),%edx
   153ad:	8b 45 08             	mov    0x8(%ebp),%eax
   153b0:	8b 40 10             	mov    0x10(%eax),%eax
   153b3:	39 c2                	cmp    %eax,%edx
   153b5:	7d 11                	jge    153c8 <_Convert+0x3f>
   153b7:	83 ec 08             	sub    $0x8,%esp
   153ba:	ff 75 e0             	pushl  -0x20(%ebp)
   153bd:	ff 75 08             	pushl  0x8(%ebp)
   153c0:	e8 79 02 00 00       	call   1563e <_UpsampleH>
   153c5:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   153c8:	8b 45 08             	mov    0x8(%ebp),%eax
   153cb:	8b 00                	mov    (%eax),%eax
   153cd:	85 c0                	test   %eax,%eax
   153cf:	0f 85 5d 02 00 00    	jne    15632 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   153d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153d8:	8b 50 10             	mov    0x10(%eax),%edx
   153db:	8b 45 08             	mov    0x8(%ebp),%eax
   153de:	8b 40 14             	mov    0x14(%eax),%eax
   153e1:	39 c2                	cmp    %eax,%edx
   153e3:	7d 11                	jge    153f6 <_Convert+0x6d>
   153e5:	83 ec 08             	sub    $0x8,%esp
   153e8:	ff 75 e0             	pushl  -0x20(%ebp)
   153eb:	ff 75 08             	pushl  0x8(%ebp)
   153ee:	e8 db 05 00 00       	call   159ce <_UpsampleV>
   153f3:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   153f6:	8b 45 08             	mov    0x8(%ebp),%eax
   153f9:	8b 00                	mov    (%eax),%eax
   153fb:	85 c0                	test   %eax,%eax
   153fd:	0f 85 32 02 00 00    	jne    15635 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   15403:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15406:	8b 50 0c             	mov    0xc(%eax),%edx
   15409:	8b 45 08             	mov    0x8(%ebp),%eax
   1540c:	8b 40 10             	mov    0x10(%eax),%eax
   1540f:	39 c2                	cmp    %eax,%edx
   15411:	7c 94                	jl     153a7 <_Convert+0x1e>
   15413:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15416:	8b 50 10             	mov    0x10(%eax),%edx
   15419:	8b 45 08             	mov    0x8(%ebp),%eax
   1541c:	8b 40 14             	mov    0x14(%eax),%eax
   1541f:	39 c2                	cmp    %eax,%edx
   15421:	7c 84                	jl     153a7 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   15423:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15426:	8b 50 0c             	mov    0xc(%eax),%edx
   15429:	8b 45 08             	mov    0x8(%ebp),%eax
   1542c:	8b 40 10             	mov    0x10(%eax),%eax
   1542f:	39 c2                	cmp    %eax,%edx
   15431:	7c 10                	jl     15443 <_Convert+0xba>
   15433:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15436:	8b 50 10             	mov    0x10(%eax),%edx
   15439:	8b 45 08             	mov    0x8(%ebp),%eax
   1543c:	8b 40 14             	mov    0x14(%eax),%eax
   1543f:	39 c2                	cmp    %eax,%edx
   15441:	7d 0e                	jge    15451 <_Convert+0xc8>
   15443:	8b 45 08             	mov    0x8(%ebp),%eax
   15446:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   1544c:	e9 e5 01 00 00       	jmp    15636 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15451:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15455:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15459:	8b 45 08             	mov    0x8(%ebp),%eax
   1545c:	8b 40 28             	mov    0x28(%eax),%eax
   1545f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15462:	7f 9f                	jg     15403 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15464:	8b 45 08             	mov    0x8(%ebp),%eax
   15467:	8b 40 28             	mov    0x28(%eax),%eax
   1546a:	83 f8 03             	cmp    $0x3,%eax
   1546d:	0f 85 3d 01 00 00    	jne    155b0 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15473:	8b 45 08             	mov    0x8(%ebp),%eax
   15476:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1547c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   1547f:	8b 45 08             	mov    0x8(%ebp),%eax
   15482:	8b 40 54             	mov    0x54(%eax),%eax
   15485:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15488:	8b 45 08             	mov    0x8(%ebp),%eax
   1548b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   15491:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15494:	8b 45 08             	mov    0x8(%ebp),%eax
   15497:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1549d:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   154a0:	8b 45 08             	mov    0x8(%ebp),%eax
   154a3:	8b 40 14             	mov    0x14(%eax),%eax
   154a6:	89 45 d8             	mov    %eax,-0x28(%ebp)
   154a9:	e9 f3 00 00 00       	jmp    155a1 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   154ae:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   154b5:	e9 b6 00 00 00       	jmp    15570 <_Convert+0x1e7>
                register int y = py[x] << 8;
   154ba:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   154c0:	01 d0                	add    %edx,%eax
   154c2:	0f b6 00             	movzbl (%eax),%eax
   154c5:	0f b6 c0             	movzbl %al,%eax
   154c8:	c1 e0 08             	shl    $0x8,%eax
   154cb:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   154cd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
   154d3:	01 d0                	add    %edx,%eax
   154d5:	0f b6 00             	movzbl (%eax),%eax
   154d8:	0f b6 c0             	movzbl %al,%eax
   154db:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   154de:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154e1:	8b 45 c8             	mov    -0x38(%ebp),%eax
   154e4:	01 d0                	add    %edx,%eax
   154e6:	0f b6 00             	movzbl (%eax),%eax
   154e9:	0f b6 c0             	movzbl %al,%eax
   154ec:	83 c0 80             	add    $0xffffff80,%eax
   154ef:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   154f1:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   154f4:	8d 46 01             	lea    0x1(%esi),%eax
   154f7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   154fa:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   154fd:	89 c8                	mov    %ecx,%eax
   154ff:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   15505:	01 d8                	add    %ebx,%eax
   15507:	83 e8 80             	sub    $0xffffff80,%eax
   1550a:	c1 f8 08             	sar    $0x8,%eax
   1550d:	83 ec 0c             	sub    $0xc,%esp
   15510:	50                   	push   %eax
   15511:	e8 74 e6 ff ff       	call   13b8a <_Clip>
   15516:	83 c4 10             	add    $0x10,%esp
   15519:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   1551b:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1551e:	8d 46 01             	lea    0x1(%esi),%eax
   15521:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15524:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15527:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   1552a:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   15531:	01 d0                	add    %edx,%eax
   15533:	83 e8 80             	sub    $0xffffff80,%eax
   15536:	c1 f8 08             	sar    $0x8,%eax
   15539:	83 ec 0c             	sub    $0xc,%esp
   1553c:	50                   	push   %eax
   1553d:	e8 48 e6 ff ff       	call   13b8a <_Clip>
   15542:	83 c4 10             	add    $0x10,%esp
   15545:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15547:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1554a:	8d 46 01             	lea    0x1(%esi),%eax
   1554d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15550:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15556:	01 d8                	add    %ebx,%eax
   15558:	83 e8 80             	sub    $0xffffff80,%eax
   1555b:	c1 f8 08             	sar    $0x8,%eax
   1555e:	83 ec 0c             	sub    $0xc,%esp
   15561:	50                   	push   %eax
   15562:	e8 23 e6 ff ff       	call   13b8a <_Clip>
   15567:	83 c4 10             	add    $0x10,%esp
   1556a:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   1556c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   15570:	8b 45 08             	mov    0x8(%ebp),%eax
   15573:	8b 40 10             	mov    0x10(%eax),%eax
   15576:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15579:	0f 8f 3b ff ff ff    	jg     154ba <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   1557f:	8b 45 08             	mov    0x8(%ebp),%eax
   15582:	8b 40 40             	mov    0x40(%eax),%eax
   15585:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15588:	8b 45 08             	mov    0x8(%ebp),%eax
   1558b:	8b 40 6c             	mov    0x6c(%eax),%eax
   1558e:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   15591:	8b 45 08             	mov    0x8(%ebp),%eax
   15594:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1559a:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   1559d:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   155a1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   155a5:	0f 85 03 ff ff ff    	jne    154ae <_Convert+0x125>
   155ab:	e9 86 00 00 00       	jmp    15636 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   155b0:	8b 45 08             	mov    0x8(%ebp),%eax
   155b3:	8b 50 38             	mov    0x38(%eax),%edx
   155b6:	8b 45 08             	mov    0x8(%ebp),%eax
   155b9:	8b 40 40             	mov    0x40(%eax),%eax
   155bc:	39 c2                	cmp    %eax,%edx
   155be:	74 76                	je     15636 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   155c0:	8b 45 08             	mov    0x8(%ebp),%eax
   155c3:	8b 50 54             	mov    0x54(%eax),%edx
   155c6:	8b 45 08             	mov    0x8(%ebp),%eax
   155c9:	8b 40 40             	mov    0x40(%eax),%eax
   155cc:	01 d0                	add    %edx,%eax
   155ce:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   155d1:	8b 45 08             	mov    0x8(%ebp),%eax
   155d4:	8b 50 54             	mov    0x54(%eax),%edx
   155d7:	8b 45 08             	mov    0x8(%ebp),%eax
   155da:	8b 40 38             	mov    0x38(%eax),%eax
   155dd:	01 d0                	add    %edx,%eax
   155df:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   155e2:	8b 45 08             	mov    0x8(%ebp),%eax
   155e5:	8b 40 3c             	mov    0x3c(%eax),%eax
   155e8:	83 e8 01             	sub    $0x1,%eax
   155eb:	89 45 bc             	mov    %eax,-0x44(%ebp)
   155ee:	eb 2e                	jmp    1561e <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   155f0:	8b 45 08             	mov    0x8(%ebp),%eax
   155f3:	8b 40 38             	mov    0x38(%eax),%eax
   155f6:	83 ec 04             	sub    $0x4,%esp
   155f9:	50                   	push   %eax
   155fa:	ff 75 c4             	pushl  -0x3c(%ebp)
   155fd:	ff 75 c0             	pushl  -0x40(%ebp)
   15600:	e8 72 ac fe ff       	call   277 <memmove>
   15605:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   15608:	8b 45 08             	mov    0x8(%ebp),%eax
   1560b:	8b 40 40             	mov    0x40(%eax),%eax
   1560e:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   15611:	8b 45 08             	mov    0x8(%ebp),%eax
   15614:	8b 40 38             	mov    0x38(%eax),%eax
   15617:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1561a:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   1561e:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   15622:	75 cc                	jne    155f0 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   15624:	8b 45 08             	mov    0x8(%ebp),%eax
   15627:	8b 50 38             	mov    0x38(%eax),%edx
   1562a:	8b 45 08             	mov    0x8(%ebp),%eax
   1562d:	89 50 40             	mov    %edx,0x40(%eax)
   15630:	eb 04                	jmp    15636 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   15632:	90                   	nop
   15633:	eb 01                	jmp    15636 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15635:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15636:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15639:	5b                   	pop    %ebx
   1563a:	5e                   	pop    %esi
   1563b:	5f                   	pop    %edi
   1563c:	5d                   	pop    %ebp
   1563d:	c3                   	ret    

0001563e <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   1563e:	55                   	push   %ebp
   1563f:	89 e5                	mov    %esp,%ebp
   15641:	53                   	push   %ebx
   15642:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15645:	8b 45 0c             	mov    0xc(%ebp),%eax
   15648:	8b 40 0c             	mov    0xc(%eax),%eax
   1564b:	83 e8 03             	sub    $0x3,%eax
   1564e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15651:	8b 45 0c             	mov    0xc(%ebp),%eax
   15654:	8b 50 0c             	mov    0xc(%eax),%edx
   15657:	8b 45 0c             	mov    0xc(%ebp),%eax
   1565a:	8b 40 10             	mov    0x10(%eax),%eax
   1565d:	0f af c2             	imul   %edx,%eax
   15660:	01 c0                	add    %eax,%eax
   15662:	83 ec 0c             	sub    $0xc,%esp
   15665:	50                   	push   %eax
   15666:	e8 cb b0 fe ff       	call   736 <malloc>
   1566b:	83 c4 10             	add    $0x10,%esp
   1566e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15671:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15675:	75 0e                	jne    15685 <_UpsampleH+0x47>
   15677:	8b 45 08             	mov    0x8(%ebp),%eax
   1567a:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15680:	e9 44 03 00 00       	jmp    159c9 <_UpsampleH+0x38b>
    lin = c->pixels;
   15685:	8b 45 0c             	mov    0xc(%ebp),%eax
   15688:	8b 40 28             	mov    0x28(%eax),%eax
   1568b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1568e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15691:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15694:	8b 45 0c             	mov    0xc(%ebp),%eax
   15697:	8b 40 10             	mov    0x10(%eax),%eax
   1569a:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   1569d:	e9 e0 02 00 00       	jmp    15982 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   156a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156a5:	0f b6 00             	movzbl (%eax),%eax
   156a8:	0f b6 c0             	movzbl %al,%eax
   156ab:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   156b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156b4:	83 c0 01             	add    $0x1,%eax
   156b7:	0f b6 00             	movzbl (%eax),%eax
   156ba:	0f b6 c0             	movzbl %al,%eax
   156bd:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   156c0:	01 d0                	add    %edx,%eax
   156c2:	83 ec 0c             	sub    $0xc,%esp
   156c5:	50                   	push   %eax
   156c6:	e8 c4 06 00 00       	call   15d8f <CF>
   156cb:	83 c4 10             	add    $0x10,%esp
   156ce:	89 c2                	mov    %eax,%edx
   156d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156d3:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   156d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156d8:	8d 58 01             	lea    0x1(%eax),%ebx
   156db:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156de:	0f b6 00             	movzbl (%eax),%eax
   156e1:	0f b6 c0             	movzbl %al,%eax
   156e4:	6b c8 68             	imul   $0x68,%eax,%ecx
   156e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156ea:	83 c0 01             	add    $0x1,%eax
   156ed:	0f b6 00             	movzbl (%eax),%eax
   156f0:	0f b6 d0             	movzbl %al,%edx
   156f3:	89 d0                	mov    %edx,%eax
   156f5:	01 c0                	add    %eax,%eax
   156f7:	01 d0                	add    %edx,%eax
   156f9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15700:	01 d0                	add    %edx,%eax
   15702:	01 c1                	add    %eax,%ecx
   15704:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15707:	83 c0 02             	add    $0x2,%eax
   1570a:	0f b6 00             	movzbl (%eax),%eax
   1570d:	0f b6 d0             	movzbl %al,%edx
   15710:	89 d0                	mov    %edx,%eax
   15712:	01 c0                	add    %eax,%eax
   15714:	01 d0                	add    %edx,%eax
   15716:	f7 d8                	neg    %eax
   15718:	01 c8                	add    %ecx,%eax
   1571a:	83 ec 0c             	sub    $0xc,%esp
   1571d:	50                   	push   %eax
   1571e:	e8 6c 06 00 00       	call   15d8f <CF>
   15723:	83 c4 10             	add    $0x10,%esp
   15726:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15728:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1572b:	8d 58 02             	lea    0x2(%eax),%ebx
   1572e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15731:	0f b6 00             	movzbl (%eax),%eax
   15734:	0f b6 c0             	movzbl %al,%eax
   15737:	c1 e0 02             	shl    $0x2,%eax
   1573a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15741:	29 c2                	sub    %eax,%edx
   15743:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15746:	83 c0 01             	add    $0x1,%eax
   15749:	0f b6 00             	movzbl (%eax),%eax
   1574c:	0f b6 c0             	movzbl %al,%eax
   1574f:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15752:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15755:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15758:	83 c0 02             	add    $0x2,%eax
   1575b:	0f b6 00             	movzbl (%eax),%eax
   1575e:	0f b6 d0             	movzbl %al,%edx
   15761:	89 d0                	mov    %edx,%eax
   15763:	c1 e0 03             	shl    $0x3,%eax
   15766:	01 d0                	add    %edx,%eax
   15768:	f7 d8                	neg    %eax
   1576a:	01 c8                	add    %ecx,%eax
   1576c:	83 ec 0c             	sub    $0xc,%esp
   1576f:	50                   	push   %eax
   15770:	e8 1a 06 00 00       	call   15d8f <CF>
   15775:	83 c4 10             	add    $0x10,%esp
   15778:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   1577a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15781:	e9 fa 00 00 00       	jmp    15880 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15786:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15789:	01 c0                	add    %eax,%eax
   1578b:	8d 50 03             	lea    0x3(%eax),%edx
   1578e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15791:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15794:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15797:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1579a:	01 d0                	add    %edx,%eax
   1579c:	0f b6 00             	movzbl (%eax),%eax
   1579f:	0f b6 d0             	movzbl %al,%edx
   157a2:	89 d0                	mov    %edx,%eax
   157a4:	c1 e0 03             	shl    $0x3,%eax
   157a7:	01 d0                	add    %edx,%eax
   157a9:	f7 d8                	neg    %eax
   157ab:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157ae:	8d 4a 01             	lea    0x1(%edx),%ecx
   157b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   157b4:	01 ca                	add    %ecx,%edx
   157b6:	0f b6 12             	movzbl (%edx),%edx
   157b9:	0f b6 d2             	movzbl %dl,%edx
   157bc:	6b d2 6f             	imul   $0x6f,%edx,%edx
   157bf:	01 c2                	add    %eax,%edx
   157c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157c4:	8d 48 02             	lea    0x2(%eax),%ecx
   157c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157ca:	01 c8                	add    %ecx,%eax
   157cc:	0f b6 00             	movzbl (%eax),%eax
   157cf:	0f b6 c0             	movzbl %al,%eax
   157d2:	6b c0 1d             	imul   $0x1d,%eax,%eax
   157d5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   157d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157db:	8d 50 03             	lea    0x3(%eax),%edx
   157de:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157e1:	01 d0                	add    %edx,%eax
   157e3:	0f b6 00             	movzbl (%eax),%eax
   157e6:	0f b6 d0             	movzbl %al,%edx
   157e9:	89 d0                	mov    %edx,%eax
   157eb:	01 c0                	add    %eax,%eax
   157ed:	01 d0                	add    %edx,%eax
   157ef:	f7 d8                	neg    %eax
   157f1:	01 c8                	add    %ecx,%eax
   157f3:	83 ec 0c             	sub    $0xc,%esp
   157f6:	50                   	push   %eax
   157f7:	e8 93 05 00 00       	call   15d8f <CF>
   157fc:	83 c4 10             	add    $0x10,%esp
   157ff:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15801:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15804:	01 c0                	add    %eax,%eax
   15806:	8d 50 04             	lea    0x4(%eax),%edx
   15809:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1580c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1580f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15812:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15815:	01 d0                	add    %edx,%eax
   15817:	0f b6 00             	movzbl (%eax),%eax
   1581a:	0f b6 d0             	movzbl %al,%edx
   1581d:	89 d0                	mov    %edx,%eax
   1581f:	01 c0                	add    %eax,%eax
   15821:	01 d0                	add    %edx,%eax
   15823:	f7 d8                	neg    %eax
   15825:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15828:	8d 4a 01             	lea    0x1(%edx),%ecx
   1582b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1582e:	01 ca                	add    %ecx,%edx
   15830:	0f b6 12             	movzbl (%edx),%edx
   15833:	0f b6 d2             	movzbl %dl,%edx
   15836:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15839:	01 c2                	add    %eax,%edx
   1583b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1583e:	8d 48 02             	lea    0x2(%eax),%ecx
   15841:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15844:	01 c8                	add    %ecx,%eax
   15846:	0f b6 00             	movzbl (%eax),%eax
   15849:	0f b6 c0             	movzbl %al,%eax
   1584c:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1584f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15852:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15855:	8d 50 03             	lea    0x3(%eax),%edx
   15858:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1585b:	01 d0                	add    %edx,%eax
   1585d:	0f b6 00             	movzbl (%eax),%eax
   15860:	0f b6 d0             	movzbl %al,%edx
   15863:	89 d0                	mov    %edx,%eax
   15865:	c1 e0 03             	shl    $0x3,%eax
   15868:	01 d0                	add    %edx,%eax
   1586a:	f7 d8                	neg    %eax
   1586c:	01 c8                	add    %ecx,%eax
   1586e:	83 ec 0c             	sub    $0xc,%esp
   15871:	50                   	push   %eax
   15872:	e8 18 05 00 00       	call   15d8f <CF>
   15877:	83 c4 10             	add    $0x10,%esp
   1587a:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   1587c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15880:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15883:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15886:	0f 8c fa fe ff ff    	jl     15786 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   1588c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1588f:	8b 40 14             	mov    0x14(%eax),%eax
   15892:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15895:	8b 45 0c             	mov    0xc(%ebp),%eax
   15898:	8b 40 0c             	mov    0xc(%eax),%eax
   1589b:	01 c0                	add    %eax,%eax
   1589d:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   158a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158a3:	8d 58 fd             	lea    -0x3(%eax),%ebx
   158a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158a9:	83 e8 01             	sub    $0x1,%eax
   158ac:	0f b6 00             	movzbl (%eax),%eax
   158af:	0f b6 c0             	movzbl %al,%eax
   158b2:	c1 e0 02             	shl    $0x2,%eax
   158b5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   158bc:	29 c2                	sub    %eax,%edx
   158be:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158c1:	83 e8 02             	sub    $0x2,%eax
   158c4:	0f b6 00             	movzbl (%eax),%eax
   158c7:	0f b6 c0             	movzbl %al,%eax
   158ca:	6b c0 6d             	imul   $0x6d,%eax,%eax
   158cd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158d3:	83 e8 03             	sub    $0x3,%eax
   158d6:	0f b6 00             	movzbl (%eax),%eax
   158d9:	0f b6 d0             	movzbl %al,%edx
   158dc:	89 d0                	mov    %edx,%eax
   158de:	c1 e0 03             	shl    $0x3,%eax
   158e1:	01 d0                	add    %edx,%eax
   158e3:	f7 d8                	neg    %eax
   158e5:	01 c8                	add    %ecx,%eax
   158e7:	83 ec 0c             	sub    $0xc,%esp
   158ea:	50                   	push   %eax
   158eb:	e8 9f 04 00 00       	call   15d8f <CF>
   158f0:	83 c4 10             	add    $0x10,%esp
   158f3:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   158f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158f8:	8d 58 fe             	lea    -0x2(%eax),%ebx
   158fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158fe:	83 e8 01             	sub    $0x1,%eax
   15901:	0f b6 00             	movzbl (%eax),%eax
   15904:	0f b6 c0             	movzbl %al,%eax
   15907:	6b c8 68             	imul   $0x68,%eax,%ecx
   1590a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1590d:	83 e8 02             	sub    $0x2,%eax
   15910:	0f b6 00             	movzbl (%eax),%eax
   15913:	0f b6 d0             	movzbl %al,%edx
   15916:	89 d0                	mov    %edx,%eax
   15918:	01 c0                	add    %eax,%eax
   1591a:	01 d0                	add    %edx,%eax
   1591c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15923:	01 d0                	add    %edx,%eax
   15925:	01 c1                	add    %eax,%ecx
   15927:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1592a:	83 e8 03             	sub    $0x3,%eax
   1592d:	0f b6 00             	movzbl (%eax),%eax
   15930:	0f b6 d0             	movzbl %al,%edx
   15933:	89 d0                	mov    %edx,%eax
   15935:	01 c0                	add    %eax,%eax
   15937:	01 d0                	add    %edx,%eax
   15939:	f7 d8                	neg    %eax
   1593b:	01 c8                	add    %ecx,%eax
   1593d:	83 ec 0c             	sub    $0xc,%esp
   15940:	50                   	push   %eax
   15941:	e8 49 04 00 00       	call   15d8f <CF>
   15946:	83 c4 10             	add    $0x10,%esp
   15949:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   1594b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1594e:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15951:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15954:	83 e8 01             	sub    $0x1,%eax
   15957:	0f b6 00             	movzbl (%eax),%eax
   1595a:	0f b6 c0             	movzbl %al,%eax
   1595d:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15963:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15966:	83 e8 02             	sub    $0x2,%eax
   15969:	0f b6 00             	movzbl (%eax),%eax
   1596c:	0f b6 c0             	movzbl %al,%eax
   1596f:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15972:	01 d0                	add    %edx,%eax
   15974:	83 ec 0c             	sub    $0xc,%esp
   15977:	50                   	push   %eax
   15978:	e8 12 04 00 00       	call   15d8f <CF>
   1597d:	83 c4 10             	add    $0x10,%esp
   15980:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15982:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15985:	8d 50 ff             	lea    -0x1(%eax),%edx
   15988:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1598b:	85 c0                	test   %eax,%eax
   1598d:	0f 85 0f fd ff ff    	jne    156a2 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15993:	8b 45 0c             	mov    0xc(%ebp),%eax
   15996:	8b 40 0c             	mov    0xc(%eax),%eax
   15999:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1599c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1599f:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   159a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   159a5:	8b 50 0c             	mov    0xc(%eax),%edx
   159a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ab:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   159ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   159b1:	8b 40 28             	mov    0x28(%eax),%eax
   159b4:	83 ec 0c             	sub    $0xc,%esp
   159b7:	50                   	push   %eax
   159b8:	e8 37 ac fe ff       	call   5f4 <free>
   159bd:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   159c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   159c3:	8b 55 e0             	mov    -0x20(%ebp),%edx
   159c6:	89 50 28             	mov    %edx,0x28(%eax)
}
   159c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   159cc:	c9                   	leave  
   159cd:	c3                   	ret    

000159ce <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   159ce:	55                   	push   %ebp
   159cf:	89 e5                	mov    %esp,%ebp
   159d1:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   159d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d7:	8b 40 0c             	mov    0xc(%eax),%eax
   159da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   159dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   159e0:	8b 40 14             	mov    0x14(%eax),%eax
   159e3:	89 45 e0             	mov    %eax,-0x20(%ebp)
   159e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   159e9:	01 c0                	add    %eax,%eax
   159eb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   159ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   159f1:	8b 50 0c             	mov    0xc(%eax),%edx
   159f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   159f7:	8b 40 10             	mov    0x10(%eax),%eax
   159fa:	0f af c2             	imul   %edx,%eax
   159fd:	01 c0                	add    %eax,%eax
   159ff:	83 ec 0c             	sub    $0xc,%esp
   15a02:	50                   	push   %eax
   15a03:	e8 2e ad fe ff       	call   736 <malloc>
   15a08:	83 c4 10             	add    $0x10,%esp
   15a0b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15a0e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15a12:	75 0e                	jne    15a22 <_UpsampleV+0x54>
   15a14:	8b 45 08             	mov    0x8(%ebp),%eax
   15a17:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15a1d:	e9 6b 03 00 00       	jmp    15d8d <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15a22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15a29:	e9 1d 03 00 00       	jmp    15d4b <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a31:	8b 50 28             	mov    0x28(%eax),%edx
   15a34:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a37:	01 d0                	add    %edx,%eax
   15a39:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15a3c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a3f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15a42:	01 d0                	add    %edx,%eax
   15a44:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15a47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a4a:	0f b6 00             	movzbl (%eax),%eax
   15a4d:	0f b6 c0             	movzbl %al,%eax
   15a50:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a56:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a5c:	01 c8                	add    %ecx,%eax
   15a5e:	0f b6 00             	movzbl (%eax),%eax
   15a61:	0f b6 c0             	movzbl %al,%eax
   15a64:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a67:	01 d0                	add    %edx,%eax
   15a69:	83 ec 0c             	sub    $0xc,%esp
   15a6c:	50                   	push   %eax
   15a6d:	e8 1d 03 00 00       	call   15d8f <CF>
   15a72:	83 c4 10             	add    $0x10,%esp
   15a75:	89 c2                	mov    %eax,%edx
   15a77:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a7a:	88 10                	mov    %dl,(%eax)
   15a7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15a7f:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15a82:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a85:	0f b6 00             	movzbl (%eax),%eax
   15a88:	0f b6 c0             	movzbl %al,%eax
   15a8b:	6b c8 68             	imul   $0x68,%eax,%ecx
   15a8e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a94:	01 d0                	add    %edx,%eax
   15a96:	0f b6 00             	movzbl (%eax),%eax
   15a99:	0f b6 d0             	movzbl %al,%edx
   15a9c:	89 d0                	mov    %edx,%eax
   15a9e:	01 c0                	add    %eax,%eax
   15aa0:	01 d0                	add    %edx,%eax
   15aa2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15aa9:	01 d0                	add    %edx,%eax
   15aab:	01 c1                	add    %eax,%ecx
   15aad:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ab0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ab3:	01 d0                	add    %edx,%eax
   15ab5:	0f b6 00             	movzbl (%eax),%eax
   15ab8:	0f b6 d0             	movzbl %al,%edx
   15abb:	89 d0                	mov    %edx,%eax
   15abd:	01 c0                	add    %eax,%eax
   15abf:	01 d0                	add    %edx,%eax
   15ac1:	f7 d8                	neg    %eax
   15ac3:	01 c8                	add    %ecx,%eax
   15ac5:	83 ec 0c             	sub    $0xc,%esp
   15ac8:	50                   	push   %eax
   15ac9:	e8 c1 02 00 00       	call   15d8f <CF>
   15ace:	83 c4 10             	add    $0x10,%esp
   15ad1:	89 c2                	mov    %eax,%edx
   15ad3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ad6:	88 10                	mov    %dl,(%eax)
   15ad8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15adb:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15ade:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ae1:	0f b6 00             	movzbl (%eax),%eax
   15ae4:	0f b6 c0             	movzbl %al,%eax
   15ae7:	c1 e0 02             	shl    $0x2,%eax
   15aea:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15af1:	89 d1                	mov    %edx,%ecx
   15af3:	29 c1                	sub    %eax,%ecx
   15af5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15afb:	01 d0                	add    %edx,%eax
   15afd:	0f b6 00             	movzbl (%eax),%eax
   15b00:	0f b6 c0             	movzbl %al,%eax
   15b03:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15b06:	01 c1                	add    %eax,%ecx
   15b08:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b0e:	01 d0                	add    %edx,%eax
   15b10:	0f b6 00             	movzbl (%eax),%eax
   15b13:	0f b6 d0             	movzbl %al,%edx
   15b16:	89 d0                	mov    %edx,%eax
   15b18:	c1 e0 03             	shl    $0x3,%eax
   15b1b:	01 d0                	add    %edx,%eax
   15b1d:	f7 d8                	neg    %eax
   15b1f:	01 c8                	add    %ecx,%eax
   15b21:	83 ec 0c             	sub    $0xc,%esp
   15b24:	50                   	push   %eax
   15b25:	e8 65 02 00 00       	call   15d8f <CF>
   15b2a:	83 c4 10             	add    $0x10,%esp
   15b2d:	89 c2                	mov    %eax,%edx
   15b2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b32:	88 10                	mov    %dl,(%eax)
   15b34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b37:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15b3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b3d:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15b40:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b43:	8b 40 10             	mov    0x10(%eax),%eax
   15b46:	83 e8 03             	sub    $0x3,%eax
   15b49:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15b4c:	e9 e6 00 00 00       	jmp    15c37 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15b51:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b54:	f7 d8                	neg    %eax
   15b56:	89 c2                	mov    %eax,%edx
   15b58:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b5b:	01 d0                	add    %edx,%eax
   15b5d:	0f b6 00             	movzbl (%eax),%eax
   15b60:	0f b6 d0             	movzbl %al,%edx
   15b63:	89 d0                	mov    %edx,%eax
   15b65:	c1 e0 03             	shl    $0x3,%eax
   15b68:	01 d0                	add    %edx,%eax
   15b6a:	f7 d8                	neg    %eax
   15b6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b6f:	0f b6 12             	movzbl (%edx),%edx
   15b72:	0f b6 d2             	movzbl %dl,%edx
   15b75:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15b78:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15b7b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b81:	01 d0                	add    %edx,%eax
   15b83:	0f b6 00             	movzbl (%eax),%eax
   15b86:	0f b6 c0             	movzbl %al,%eax
   15b89:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15b8c:	01 c1                	add    %eax,%ecx
   15b8e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b91:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b94:	01 d0                	add    %edx,%eax
   15b96:	0f b6 00             	movzbl (%eax),%eax
   15b99:	0f b6 d0             	movzbl %al,%edx
   15b9c:	89 d0                	mov    %edx,%eax
   15b9e:	01 c0                	add    %eax,%eax
   15ba0:	01 d0                	add    %edx,%eax
   15ba2:	f7 d8                	neg    %eax
   15ba4:	01 c8                	add    %ecx,%eax
   15ba6:	83 ec 0c             	sub    $0xc,%esp
   15ba9:	50                   	push   %eax
   15baa:	e8 e0 01 00 00       	call   15d8f <CF>
   15baf:	83 c4 10             	add    $0x10,%esp
   15bb2:	89 c2                	mov    %eax,%edx
   15bb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bb7:	88 10                	mov    %dl,(%eax)
   15bb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15bbc:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15bbf:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bc2:	f7 d8                	neg    %eax
   15bc4:	89 c2                	mov    %eax,%edx
   15bc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bc9:	01 d0                	add    %edx,%eax
   15bcb:	0f b6 00             	movzbl (%eax),%eax
   15bce:	0f b6 d0             	movzbl %al,%edx
   15bd1:	89 d0                	mov    %edx,%eax
   15bd3:	01 c0                	add    %eax,%eax
   15bd5:	01 d0                	add    %edx,%eax
   15bd7:	f7 d8                	neg    %eax
   15bd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15bdc:	0f b6 12             	movzbl (%edx),%edx
   15bdf:	0f b6 d2             	movzbl %dl,%edx
   15be2:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15be5:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15be8:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15beb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bee:	01 d0                	add    %edx,%eax
   15bf0:	0f b6 00             	movzbl (%eax),%eax
   15bf3:	0f b6 c0             	movzbl %al,%eax
   15bf6:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15bf9:	01 c1                	add    %eax,%ecx
   15bfb:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c01:	01 d0                	add    %edx,%eax
   15c03:	0f b6 00             	movzbl (%eax),%eax
   15c06:	0f b6 d0             	movzbl %al,%edx
   15c09:	89 d0                	mov    %edx,%eax
   15c0b:	c1 e0 03             	shl    $0x3,%eax
   15c0e:	01 d0                	add    %edx,%eax
   15c10:	f7 d8                	neg    %eax
   15c12:	01 c8                	add    %ecx,%eax
   15c14:	83 ec 0c             	sub    $0xc,%esp
   15c17:	50                   	push   %eax
   15c18:	e8 72 01 00 00       	call   15d8f <CF>
   15c1d:	83 c4 10             	add    $0x10,%esp
   15c20:	89 c2                	mov    %eax,%edx
   15c22:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c25:	88 10                	mov    %dl,(%eax)
   15c27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c2a:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15c2d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c30:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15c33:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15c37:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15c3b:	0f 85 10 ff ff ff    	jne    15b51 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15c41:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c44:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c4a:	0f b6 00             	movzbl (%eax),%eax
   15c4d:	0f b6 c0             	movzbl %al,%eax
   15c50:	c1 e0 02             	shl    $0x2,%eax
   15c53:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c5a:	29 c2                	sub    %eax,%edx
   15c5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c5f:	f7 d8                	neg    %eax
   15c61:	89 c1                	mov    %eax,%ecx
   15c63:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c66:	01 c8                	add    %ecx,%eax
   15c68:	0f b6 00             	movzbl (%eax),%eax
   15c6b:	0f b6 c0             	movzbl %al,%eax
   15c6e:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15c71:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15c74:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15c77:	f7 d8                	neg    %eax
   15c79:	89 c2                	mov    %eax,%edx
   15c7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c7e:	01 d0                	add    %edx,%eax
   15c80:	0f b6 00             	movzbl (%eax),%eax
   15c83:	0f b6 d0             	movzbl %al,%edx
   15c86:	89 d0                	mov    %edx,%eax
   15c88:	c1 e0 03             	shl    $0x3,%eax
   15c8b:	01 d0                	add    %edx,%eax
   15c8d:	f7 d8                	neg    %eax
   15c8f:	01 c8                	add    %ecx,%eax
   15c91:	83 ec 0c             	sub    $0xc,%esp
   15c94:	50                   	push   %eax
   15c95:	e8 f5 00 00 00       	call   15d8f <CF>
   15c9a:	83 c4 10             	add    $0x10,%esp
   15c9d:	89 c2                	mov    %eax,%edx
   15c9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ca2:	88 10                	mov    %dl,(%eax)
   15ca4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15ca7:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15caa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cad:	0f b6 00             	movzbl (%eax),%eax
   15cb0:	0f b6 c0             	movzbl %al,%eax
   15cb3:	6b c8 68             	imul   $0x68,%eax,%ecx
   15cb6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cb9:	f7 d8                	neg    %eax
   15cbb:	89 c2                	mov    %eax,%edx
   15cbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cc0:	01 d0                	add    %edx,%eax
   15cc2:	0f b6 00             	movzbl (%eax),%eax
   15cc5:	0f b6 d0             	movzbl %al,%edx
   15cc8:	89 d0                	mov    %edx,%eax
   15cca:	01 c0                	add    %eax,%eax
   15ccc:	01 d0                	add    %edx,%eax
   15cce:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15cd5:	01 d0                	add    %edx,%eax
   15cd7:	01 c1                	add    %eax,%ecx
   15cd9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15cdc:	f7 d8                	neg    %eax
   15cde:	89 c2                	mov    %eax,%edx
   15ce0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ce3:	01 d0                	add    %edx,%eax
   15ce5:	0f b6 00             	movzbl (%eax),%eax
   15ce8:	0f b6 d0             	movzbl %al,%edx
   15ceb:	89 d0                	mov    %edx,%eax
   15ced:	01 c0                	add    %eax,%eax
   15cef:	01 d0                	add    %edx,%eax
   15cf1:	f7 d8                	neg    %eax
   15cf3:	01 c8                	add    %ecx,%eax
   15cf5:	83 ec 0c             	sub    $0xc,%esp
   15cf8:	50                   	push   %eax
   15cf9:	e8 91 00 00 00       	call   15d8f <CF>
   15cfe:	83 c4 10             	add    $0x10,%esp
   15d01:	89 c2                	mov    %eax,%edx
   15d03:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d06:	88 10                	mov    %dl,(%eax)
   15d08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d0b:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15d0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d11:	0f b6 00             	movzbl (%eax),%eax
   15d14:	0f b6 c0             	movzbl %al,%eax
   15d17:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15d1d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d20:	f7 d8                	neg    %eax
   15d22:	89 c1                	mov    %eax,%ecx
   15d24:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d27:	01 c8                	add    %ecx,%eax
   15d29:	0f b6 00             	movzbl (%eax),%eax
   15d2c:	0f b6 c0             	movzbl %al,%eax
   15d2f:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15d32:	01 d0                	add    %edx,%eax
   15d34:	83 ec 0c             	sub    $0xc,%esp
   15d37:	50                   	push   %eax
   15d38:	e8 52 00 00 00       	call   15d8f <CF>
   15d3d:	83 c4 10             	add    $0x10,%esp
   15d40:	89 c2                	mov    %eax,%edx
   15d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d45:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15d47:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15d4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d4e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15d51:	0f 8c d7 fc ff ff    	jl     15a2e <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15d57:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d5a:	8b 40 10             	mov    0x10(%eax),%eax
   15d5d:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15d60:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d63:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15d66:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d69:	8b 50 0c             	mov    0xc(%eax),%edx
   15d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d6f:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15d72:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d75:	8b 40 28             	mov    0x28(%eax),%eax
   15d78:	83 ec 0c             	sub    $0xc,%esp
   15d7b:	50                   	push   %eax
   15d7c:	e8 73 a8 fe ff       	call   5f4 <free>
   15d81:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15d84:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d87:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15d8a:	89 50 28             	mov    %edx,0x28(%eax)
}
   15d8d:	c9                   	leave  
   15d8e:	c3                   	ret    

00015d8f <CF>:

uchar CF(const int x){
   15d8f:	55                   	push   %ebp
   15d90:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15d92:	8b 45 08             	mov    0x8(%ebp),%eax
   15d95:	83 c0 40             	add    $0x40,%eax
   15d98:	c1 f8 07             	sar    $0x7,%eax
   15d9b:	50                   	push   %eax
   15d9c:	e8 e9 dd ff ff       	call   13b8a <_Clip>
   15da1:	83 c4 04             	add    $0x4,%esp
}
   15da4:	c9                   	leave  
   15da5:	c3                   	ret    
