
_plane：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <MsgProc>:
int tmp = 0;
int enemy_status[6]={0,0,0,0,0,0};
int enemyWidth[6] = {64,46,46,45,45,45};
int enemyHeight[6] = {66,50,50,59,59,59};
void MsgProc(struct message *msg)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	81 ec 58 02 00 00    	sub    $0x258,%esp
    switch(msg->msg_type)
       9:	8b 45 08             	mov    0x8(%ebp),%eax
       c:	8b 00                	mov    (%eax),%eax
       e:	83 f8 09             	cmp    $0x9,%eax
      11:	0f 84 f4 06 00 00    	je     70b <MsgProc+0x70b>
      17:	83 f8 0a             	cmp    $0xa,%eax
      1a:	0f 84 95 10 00 00    	je     10b5 <MsgProc+0x10b5>
      20:	83 f8 02             	cmp    $0x2,%eax
      23:	74 05                	je     2a <MsgProc+0x2a>
            free(bullet1);
            api_destroywindow(&wnd);
            break;
    }
    
}
      25:	e9 02 11 00 00       	jmp    112c <MsgProc+0x112c>
void MsgProc(struct message *msg)
{
    switch(msg->msg_type)
    {
        case M_KEY_DOWN:
            if (msg->params[0]==226)
      2a:	8b 45 08             	mov    0x8(%ebp),%eax
      2d:	8b 40 04             	mov    0x4(%eax),%eax
      30:	3d e2 00 00 00       	cmp    $0xe2,%eax
      35:	75 29                	jne    60 <MsgProc+0x60>
            {
                plane_y-=5;
      37:	a1 68 fe 01 00       	mov    0x1fe68,%eax
      3c:	83 e8 05             	sub    $0x5,%eax
      3f:	a3 68 fe 01 00       	mov    %eax,0x1fe68
                if (plane_y < 0)
      44:	a1 68 fe 01 00       	mov    0x1fe68,%eax
      49:	85 c0                	test   %eax,%eax
      4b:	0f 89 a0 00 00 00    	jns    f1 <MsgProc+0xf1>
                {
                    plane_y = 0;
      51:	c7 05 68 fe 01 00 00 	movl   $0x0,0x1fe68
      58:	00 00 00 
      5b:	e9 91 00 00 00       	jmp    f1 <MsgProc+0xf1>
                }
            }
            else if (msg->params[0]==227)
      60:	8b 45 08             	mov    0x8(%ebp),%eax
      63:	8b 40 04             	mov    0x4(%eax),%eax
      66:	3d e3 00 00 00       	cmp    $0xe3,%eax
      6b:	75 25                	jne    92 <MsgProc+0x92>
            {
                plane_y+=5;
      6d:	a1 68 fe 01 00       	mov    0x1fe68,%eax
      72:	83 c0 05             	add    $0x5,%eax
      75:	a3 68 fe 01 00       	mov    %eax,0x1fe68
                if (plane_y > 500-PLANE_HEIGHT)
      7a:	a1 68 fe 01 00       	mov    0x1fe68,%eax
      7f:	3d c5 01 00 00       	cmp    $0x1c5,%eax
      84:	7e 6b                	jle    f1 <MsgProc+0xf1>
                {
                    plane_y=500 - PLANE_HEIGHT;
      86:	c7 05 68 fe 01 00 c5 	movl   $0x1c5,0x1fe68
      8d:	01 00 00 
      90:	eb 5f                	jmp    f1 <MsgProc+0xf1>
                }
            }
            else if (msg->params[0]==228)
      92:	8b 45 08             	mov    0x8(%ebp),%eax
      95:	8b 40 04             	mov    0x4(%eax),%eax
      98:	3d e4 00 00 00       	cmp    $0xe4,%eax
      9d:	75 22                	jne    c1 <MsgProc+0xc1>
            {
                plane_x-=5;
      9f:	a1 20 fd 01 00       	mov    0x1fd20,%eax
      a4:	83 e8 05             	sub    $0x5,%eax
      a7:	a3 20 fd 01 00       	mov    %eax,0x1fd20
                if (plane_x <0)
      ac:	a1 20 fd 01 00       	mov    0x1fd20,%eax
      b1:	85 c0                	test   %eax,%eax
      b3:	79 3c                	jns    f1 <MsgProc+0xf1>
                {
                    plane_x=0;
      b5:	c7 05 20 fd 01 00 00 	movl   $0x0,0x1fd20
      bc:	00 00 00 
      bf:	eb 30                	jmp    f1 <MsgProc+0xf1>
                }
            }
            else if (msg->params[0]==229)
      c1:	8b 45 08             	mov    0x8(%ebp),%eax
      c4:	8b 40 04             	mov    0x4(%eax),%eax
      c7:	3d e5 00 00 00       	cmp    $0xe5,%eax
      cc:	75 23                	jne    f1 <MsgProc+0xf1>
            {
                plane_x+=5;
      ce:	a1 20 fd 01 00       	mov    0x1fd20,%eax
      d3:	83 c0 05             	add    $0x5,%eax
      d6:	a3 20 fd 01 00       	mov    %eax,0x1fd20
                if (plane_x > 300-PLANE_WIDTH)
      db:	a1 20 fd 01 00       	mov    0x1fd20,%eax
      e0:	3d ff 00 00 00       	cmp    $0xff,%eax
      e5:	7e 0a                	jle    f1 <MsgProc+0xf1>
                {
                    plane_x = 300-PLANE_WIDTH;
      e7:	c7 05 20 fd 01 00 ff 	movl   $0xff,0x1fd20
      ee:	00 00 00 
                }
            }
            backgroundh+=10;
      f1:	a1 e0 fc 01 00       	mov    0x1fce0,%eax
      f6:	83 c0 0a             	add    $0xa,%eax
      f9:	a3 e0 fc 01 00       	mov    %eax,0x1fce0
            backgroundh%=800;
      fe:	8b 0d e0 fc 01 00    	mov    0x1fce0,%ecx
     104:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
     109:	89 c8                	mov    %ecx,%eax
     10b:	f7 ea                	imul   %edx
     10d:	c1 fa 08             	sar    $0x8,%edx
     110:	89 c8                	mov    %ecx,%eax
     112:	c1 f8 1f             	sar    $0x1f,%eax
     115:	29 c2                	sub    %eax,%edx
     117:	89 d0                	mov    %edx,%eax
     119:	69 c0 20 03 00 00    	imul   $0x320,%eax,%eax
     11f:	29 c1                	sub    %eax,%ecx
     121:	89 c8                	mov    %ecx,%eax
     123:	a3 e0 fc 01 00       	mov    %eax,0x1fce0
            api_paint24BitmapToContentTransparent(&wnd, background, (Point){0,0},(Point){0,backgroundh},(Size){1600,BACKGROUNDWIDTH},(Size){BACKGROUNDHEIGHT,BACKGROUNDWIDTH});
     128:	c7 85 ac fd ff ff f4 	movl   $0x1f4,-0x254(%ebp)
     12f:	01 00 00 
     132:	c7 85 b0 fd ff ff e0 	movl   $0x1e0,-0x250(%ebp)
     139:	01 00 00 
     13c:	c7 85 b4 fd ff ff 40 	movl   $0x640,-0x24c(%ebp)
     143:	06 00 00 
     146:	c7 85 b8 fd ff ff e0 	movl   $0x1e0,-0x248(%ebp)
     14d:	01 00 00 
     150:	c7 85 bc fd ff ff 00 	movl   $0x0,-0x244(%ebp)
     157:	00 00 00 
     15a:	a1 e0 fc 01 00       	mov    0x1fce0,%eax
     15f:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
     165:	c7 85 c4 fd ff ff 00 	movl   $0x0,-0x23c(%ebp)
     16c:	00 00 00 
     16f:	c7 85 c8 fd ff ff 00 	movl   $0x0,-0x238(%ebp)
     176:	00 00 00 
     179:	a1 28 fd 01 00       	mov    0x1fd28,%eax
     17e:	83 ec 08             	sub    $0x8,%esp
     181:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
     187:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
     18d:	ff b5 b8 fd ff ff    	pushl  -0x248(%ebp)
     193:	ff b5 b4 fd ff ff    	pushl  -0x24c(%ebp)
     199:	ff b5 c0 fd ff ff    	pushl  -0x240(%ebp)
     19f:	ff b5 bc fd ff ff    	pushl  -0x244(%ebp)
     1a5:	ff b5 c8 fd ff ff    	pushl  -0x238(%ebp)
     1ab:	ff b5 c4 fd ff ff    	pushl  -0x23c(%ebp)
     1b1:	50                   	push   %eax
     1b2:	68 40 fe 01 00       	push   $0x1fe40
     1b7:	e8 08 28 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     1bc:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, plane, (Point){plane_x,plane_y}, (Point){0,0}, (Size){273,PLANE_WIDTH},(Size){PLANE_HEIGHT,PLANE_WIDTH});
     1bf:	c7 85 cc fd ff ff 2f 	movl   $0x2f,-0x234(%ebp)
     1c6:	00 00 00 
     1c9:	c7 85 d0 fd ff ff 2d 	movl   $0x2d,-0x230(%ebp)
     1d0:	00 00 00 
     1d3:	c7 85 d4 fd ff ff 11 	movl   $0x111,-0x22c(%ebp)
     1da:	01 00 00 
     1dd:	c7 85 d8 fd ff ff 2d 	movl   $0x2d,-0x228(%ebp)
     1e4:	00 00 00 
     1e7:	c7 85 dc fd ff ff 00 	movl   $0x0,-0x224(%ebp)
     1ee:	00 00 00 
     1f1:	c7 85 e0 fd ff ff 00 	movl   $0x0,-0x220(%ebp)
     1f8:	00 00 00 
     1fb:	a1 20 fd 01 00       	mov    0x1fd20,%eax
     200:	89 85 e4 fd ff ff    	mov    %eax,-0x21c(%ebp)
     206:	a1 68 fe 01 00       	mov    0x1fe68,%eax
     20b:	89 85 e8 fd ff ff    	mov    %eax,-0x218(%ebp)
     211:	a1 30 fe 01 00       	mov    0x1fe30,%eax
     216:	83 ec 08             	sub    $0x8,%esp
     219:	ff b5 d0 fd ff ff    	pushl  -0x230(%ebp)
     21f:	ff b5 cc fd ff ff    	pushl  -0x234(%ebp)
     225:	ff b5 d8 fd ff ff    	pushl  -0x228(%ebp)
     22b:	ff b5 d4 fd ff ff    	pushl  -0x22c(%ebp)
     231:	ff b5 e0 fd ff ff    	pushl  -0x220(%ebp)
     237:	ff b5 dc fd ff ff    	pushl  -0x224(%ebp)
     23d:	ff b5 e8 fd ff ff    	pushl  -0x218(%ebp)
     243:	ff b5 e4 fd ff ff    	pushl  -0x21c(%ebp)
     249:	50                   	push   %eax
     24a:	68 40 fe 01 00       	push   $0x1fe40
     24f:	e8 70 27 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     254:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, bigEnemy, (Point){enemy[0].x,enemy[0].y}, (Point){0,enemy_status[0]*enemyHeight[0]},(Size){401,64},(Size){enemyHeight[0],enemyWidth[0]});
     257:	a1 84 f8 01 00       	mov    0x1f884,%eax
     25c:	89 85 ec fd ff ff    	mov    %eax,-0x214(%ebp)
     262:	a1 6c f8 01 00       	mov    0x1f86c,%eax
     267:	89 85 f0 fd ff ff    	mov    %eax,-0x210(%ebp)
     26d:	c7 85 f4 fd ff ff 91 	movl   $0x191,-0x20c(%ebp)
     274:	01 00 00 
     277:	c7 85 f8 fd ff ff 40 	movl   $0x40,-0x208(%ebp)
     27e:	00 00 00 
     281:	c7 85 fc fd ff ff 00 	movl   $0x0,-0x204(%ebp)
     288:	00 00 00 
     28b:	8b 15 f0 fc 01 00    	mov    0x1fcf0,%edx
     291:	a1 84 f8 01 00       	mov    0x1f884,%eax
     296:	0f af c2             	imul   %edx,%eax
     299:	89 85 00 fe ff ff    	mov    %eax,-0x200(%ebp)
     29f:	a1 e0 f7 01 00       	mov    0x1f7e0,%eax
     2a4:	89 85 04 fe ff ff    	mov    %eax,-0x1fc(%ebp)
     2aa:	a1 e4 f7 01 00       	mov    0x1f7e4,%eax
     2af:	89 85 08 fe ff ff    	mov    %eax,-0x1f8(%ebp)
     2b5:	a1 60 fe 01 00       	mov    0x1fe60,%eax
     2ba:	83 ec 08             	sub    $0x8,%esp
     2bd:	ff b5 f0 fd ff ff    	pushl  -0x210(%ebp)
     2c3:	ff b5 ec fd ff ff    	pushl  -0x214(%ebp)
     2c9:	ff b5 f8 fd ff ff    	pushl  -0x208(%ebp)
     2cf:	ff b5 f4 fd ff ff    	pushl  -0x20c(%ebp)
     2d5:	ff b5 00 fe ff ff    	pushl  -0x200(%ebp)
     2db:	ff b5 fc fd ff ff    	pushl  -0x204(%ebp)
     2e1:	ff b5 08 fe ff ff    	pushl  -0x1f8(%ebp)
     2e7:	ff b5 04 fe ff ff    	pushl  -0x1fc(%ebp)
     2ed:	50                   	push   %eax
     2ee:	68 40 fe 01 00       	push   $0x1fe40
     2f3:	e8 cc 26 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     2f8:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){enemy[1].x,enemy[1].y}, (Point){0,enemy_status[1]*enemyHeight[1]},(Size){311,46},(Size){enemyHeight[1],enemyWidth[1]});
     2fb:	a1 88 f8 01 00       	mov    0x1f888,%eax
     300:	89 85 0c fe ff ff    	mov    %eax,-0x1f4(%ebp)
     306:	a1 70 f8 01 00       	mov    0x1f870,%eax
     30b:	89 85 10 fe ff ff    	mov    %eax,-0x1f0(%ebp)
     311:	c7 85 14 fe ff ff 37 	movl   $0x137,-0x1ec(%ebp)
     318:	01 00 00 
     31b:	c7 85 18 fe ff ff 2e 	movl   $0x2e,-0x1e8(%ebp)
     322:	00 00 00 
     325:	c7 85 1c fe ff ff 00 	movl   $0x0,-0x1e4(%ebp)
     32c:	00 00 00 
     32f:	8b 15 f4 fc 01 00    	mov    0x1fcf4,%edx
     335:	a1 88 f8 01 00       	mov    0x1f888,%eax
     33a:	0f af c2             	imul   %edx,%eax
     33d:	89 85 20 fe ff ff    	mov    %eax,-0x1e0(%ebp)
     343:	a1 e8 f7 01 00       	mov    0x1f7e8,%eax
     348:	89 85 24 fe ff ff    	mov    %eax,-0x1dc(%ebp)
     34e:	a1 ec f7 01 00       	mov    0x1f7ec,%eax
     353:	89 85 28 fe ff ff    	mov    %eax,-0x1d8(%ebp)
     359:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
     35e:	83 ec 08             	sub    $0x8,%esp
     361:	ff b5 10 fe ff ff    	pushl  -0x1f0(%ebp)
     367:	ff b5 0c fe ff ff    	pushl  -0x1f4(%ebp)
     36d:	ff b5 18 fe ff ff    	pushl  -0x1e8(%ebp)
     373:	ff b5 14 fe ff ff    	pushl  -0x1ec(%ebp)
     379:	ff b5 20 fe ff ff    	pushl  -0x1e0(%ebp)
     37f:	ff b5 1c fe ff ff    	pushl  -0x1e4(%ebp)
     385:	ff b5 28 fe ff ff    	pushl  -0x1d8(%ebp)
     38b:	ff b5 24 fe ff ff    	pushl  -0x1dc(%ebp)
     391:	50                   	push   %eax
     392:	68 40 fe 01 00       	push   $0x1fe40
     397:	e8 28 26 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     39c:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){enemy[2].x,enemy[2].y}, (Point){0,enemy_status[2]*enemyHeight[2]},(Size){311,46},(Size){enemyHeight[2],enemyWidth[2]});
     39f:	a1 8c f8 01 00       	mov    0x1f88c,%eax
     3a4:	89 85 2c fe ff ff    	mov    %eax,-0x1d4(%ebp)
     3aa:	a1 74 f8 01 00       	mov    0x1f874,%eax
     3af:	89 85 30 fe ff ff    	mov    %eax,-0x1d0(%ebp)
     3b5:	c7 85 34 fe ff ff 37 	movl   $0x137,-0x1cc(%ebp)
     3bc:	01 00 00 
     3bf:	c7 85 38 fe ff ff 2e 	movl   $0x2e,-0x1c8(%ebp)
     3c6:	00 00 00 
     3c9:	c7 85 3c fe ff ff 00 	movl   $0x0,-0x1c4(%ebp)
     3d0:	00 00 00 
     3d3:	8b 15 f8 fc 01 00    	mov    0x1fcf8,%edx
     3d9:	a1 8c f8 01 00       	mov    0x1f88c,%eax
     3de:	0f af c2             	imul   %edx,%eax
     3e1:	89 85 40 fe ff ff    	mov    %eax,-0x1c0(%ebp)
     3e7:	a1 f0 f7 01 00       	mov    0x1f7f0,%eax
     3ec:	89 85 44 fe ff ff    	mov    %eax,-0x1bc(%ebp)
     3f2:	a1 f4 f7 01 00       	mov    0x1f7f4,%eax
     3f7:	89 85 48 fe ff ff    	mov    %eax,-0x1b8(%ebp)
     3fd:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
     402:	83 ec 08             	sub    $0x8,%esp
     405:	ff b5 30 fe ff ff    	pushl  -0x1d0(%ebp)
     40b:	ff b5 2c fe ff ff    	pushl  -0x1d4(%ebp)
     411:	ff b5 38 fe ff ff    	pushl  -0x1c8(%ebp)
     417:	ff b5 34 fe ff ff    	pushl  -0x1cc(%ebp)
     41d:	ff b5 40 fe ff ff    	pushl  -0x1c0(%ebp)
     423:	ff b5 3c fe ff ff    	pushl  -0x1c4(%ebp)
     429:	ff b5 48 fe ff ff    	pushl  -0x1b8(%ebp)
     42f:	ff b5 44 fe ff ff    	pushl  -0x1bc(%ebp)
     435:	50                   	push   %eax
     436:	68 40 fe 01 00       	push   $0x1fe40
     43b:	e8 84 25 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     440:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[3].x,enemy[3].y}, (Point){0,enemy_status[3]*enemyHeight[3]},(Size){340,45},(Size){enemyHeight[3],enemyWidth[3]});
     443:	a1 90 f8 01 00       	mov    0x1f890,%eax
     448:	89 85 4c fe ff ff    	mov    %eax,-0x1b4(%ebp)
     44e:	a1 78 f8 01 00       	mov    0x1f878,%eax
     453:	89 85 50 fe ff ff    	mov    %eax,-0x1b0(%ebp)
     459:	c7 85 54 fe ff ff 54 	movl   $0x154,-0x1ac(%ebp)
     460:	01 00 00 
     463:	c7 85 58 fe ff ff 2d 	movl   $0x2d,-0x1a8(%ebp)
     46a:	00 00 00 
     46d:	c7 85 5c fe ff ff 00 	movl   $0x0,-0x1a4(%ebp)
     474:	00 00 00 
     477:	8b 15 fc fc 01 00    	mov    0x1fcfc,%edx
     47d:	a1 90 f8 01 00       	mov    0x1f890,%eax
     482:	0f af c2             	imul   %edx,%eax
     485:	89 85 60 fe ff ff    	mov    %eax,-0x1a0(%ebp)
     48b:	a1 f8 f7 01 00       	mov    0x1f7f8,%eax
     490:	89 85 64 fe ff ff    	mov    %eax,-0x19c(%ebp)
     496:	a1 fc f7 01 00       	mov    0x1f7fc,%eax
     49b:	89 85 68 fe ff ff    	mov    %eax,-0x198(%ebp)
     4a1:	a1 70 fe 01 00       	mov    0x1fe70,%eax
     4a6:	83 ec 08             	sub    $0x8,%esp
     4a9:	ff b5 50 fe ff ff    	pushl  -0x1b0(%ebp)
     4af:	ff b5 4c fe ff ff    	pushl  -0x1b4(%ebp)
     4b5:	ff b5 58 fe ff ff    	pushl  -0x1a8(%ebp)
     4bb:	ff b5 54 fe ff ff    	pushl  -0x1ac(%ebp)
     4c1:	ff b5 60 fe ff ff    	pushl  -0x1a0(%ebp)
     4c7:	ff b5 5c fe ff ff    	pushl  -0x1a4(%ebp)
     4cd:	ff b5 68 fe ff ff    	pushl  -0x198(%ebp)
     4d3:	ff b5 64 fe ff ff    	pushl  -0x19c(%ebp)
     4d9:	50                   	push   %eax
     4da:	68 40 fe 01 00       	push   $0x1fe40
     4df:	e8 e0 24 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     4e4:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[4].x,enemy[4].y}, (Point){0,enemy_status[4]*enemyHeight[4]},(Size){340,45},(Size){enemyHeight[4],enemyWidth[4]});
     4e7:	a1 94 f8 01 00       	mov    0x1f894,%eax
     4ec:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
     4f2:	a1 7c f8 01 00       	mov    0x1f87c,%eax
     4f7:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
     4fd:	c7 85 74 fe ff ff 54 	movl   $0x154,-0x18c(%ebp)
     504:	01 00 00 
     507:	c7 85 78 fe ff ff 2d 	movl   $0x2d,-0x188(%ebp)
     50e:	00 00 00 
     511:	c7 85 7c fe ff ff 00 	movl   $0x0,-0x184(%ebp)
     518:	00 00 00 
     51b:	8b 15 00 fd 01 00    	mov    0x1fd00,%edx
     521:	a1 94 f8 01 00       	mov    0x1f894,%eax
     526:	0f af c2             	imul   %edx,%eax
     529:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
     52f:	a1 00 f8 01 00       	mov    0x1f800,%eax
     534:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
     53a:	a1 04 f8 01 00       	mov    0x1f804,%eax
     53f:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
     545:	a1 70 fe 01 00       	mov    0x1fe70,%eax
     54a:	83 ec 08             	sub    $0x8,%esp
     54d:	ff b5 70 fe ff ff    	pushl  -0x190(%ebp)
     553:	ff b5 6c fe ff ff    	pushl  -0x194(%ebp)
     559:	ff b5 78 fe ff ff    	pushl  -0x188(%ebp)
     55f:	ff b5 74 fe ff ff    	pushl  -0x18c(%ebp)
     565:	ff b5 80 fe ff ff    	pushl  -0x180(%ebp)
     56b:	ff b5 7c fe ff ff    	pushl  -0x184(%ebp)
     571:	ff b5 88 fe ff ff    	pushl  -0x178(%ebp)
     577:	ff b5 84 fe ff ff    	pushl  -0x17c(%ebp)
     57d:	50                   	push   %eax
     57e:	68 40 fe 01 00       	push   $0x1fe40
     583:	e8 3c 24 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     588:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[5].x,enemy[5].y}, (Point){0,enemy_status[5]*enemyHeight[5]},(Size){340,45},(Size){enemyHeight[5],enemyWidth[5]});
     58b:	a1 98 f8 01 00       	mov    0x1f898,%eax
     590:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
     596:	a1 80 f8 01 00       	mov    0x1f880,%eax
     59b:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
     5a1:	c7 85 94 fe ff ff 54 	movl   $0x154,-0x16c(%ebp)
     5a8:	01 00 00 
     5ab:	c7 85 98 fe ff ff 2d 	movl   $0x2d,-0x168(%ebp)
     5b2:	00 00 00 
     5b5:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
     5bc:	00 00 00 
     5bf:	8b 15 04 fd 01 00    	mov    0x1fd04,%edx
     5c5:	a1 98 f8 01 00       	mov    0x1f898,%eax
     5ca:	0f af c2             	imul   %edx,%eax
     5cd:	89 85 a0 fe ff ff    	mov    %eax,-0x160(%ebp)
     5d3:	a1 08 f8 01 00       	mov    0x1f808,%eax
     5d8:	89 85 a4 fe ff ff    	mov    %eax,-0x15c(%ebp)
     5de:	a1 0c f8 01 00       	mov    0x1f80c,%eax
     5e3:	89 85 a8 fe ff ff    	mov    %eax,-0x158(%ebp)
     5e9:	a1 70 fe 01 00       	mov    0x1fe70,%eax
     5ee:	83 ec 08             	sub    $0x8,%esp
     5f1:	ff b5 90 fe ff ff    	pushl  -0x170(%ebp)
     5f7:	ff b5 8c fe ff ff    	pushl  -0x174(%ebp)
     5fd:	ff b5 98 fe ff ff    	pushl  -0x168(%ebp)
     603:	ff b5 94 fe ff ff    	pushl  -0x16c(%ebp)
     609:	ff b5 a0 fe ff ff    	pushl  -0x160(%ebp)
     60f:	ff b5 9c fe ff ff    	pushl  -0x164(%ebp)
     615:	ff b5 a8 fe ff ff    	pushl  -0x158(%ebp)
     61b:	ff b5 a4 fe ff ff    	pushl  -0x15c(%ebp)
     621:	50                   	push   %eax
     622:	68 40 fe 01 00       	push   $0x1fe40
     627:	e8 98 23 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     62c:	83 c4 30             	add    $0x30,%esp
            int i = 0;
     62f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            for (i = 0; i < bulletNum;i++)
     636:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     63d:	e9 a6 00 00 00       	jmp    6e8 <MsgProc+0x6e8>
            {
                api_paint24BitmapToContentTransparent(&wnd,bullet1,(Point){bullets[i].x,bullets[i].y},(Point){0,0},(Size){22,15},(Size){22,15});
     642:	c7 85 ac fe ff ff 16 	movl   $0x16,-0x154(%ebp)
     649:	00 00 00 
     64c:	c7 85 b0 fe ff ff 0f 	movl   $0xf,-0x150(%ebp)
     653:	00 00 00 
     656:	c7 85 b4 fe ff ff 16 	movl   $0x16,-0x14c(%ebp)
     65d:	00 00 00 
     660:	c7 85 b8 fe ff ff 0f 	movl   $0xf,-0x148(%ebp)
     667:	00 00 00 
     66a:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
     671:	00 00 00 
     674:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
     67b:	00 00 00 
     67e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     681:	8b 04 c5 40 fd 01 00 	mov    0x1fd40(,%eax,8),%eax
     688:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
     68e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     691:	8b 04 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%eax
     698:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
     69e:	a1 24 fd 01 00       	mov    0x1fd24,%eax
     6a3:	83 ec 08             	sub    $0x8,%esp
     6a6:	ff b5 b0 fe ff ff    	pushl  -0x150(%ebp)
     6ac:	ff b5 ac fe ff ff    	pushl  -0x154(%ebp)
     6b2:	ff b5 b8 fe ff ff    	pushl  -0x148(%ebp)
     6b8:	ff b5 b4 fe ff ff    	pushl  -0x14c(%ebp)
     6be:	ff b5 c0 fe ff ff    	pushl  -0x140(%ebp)
     6c4:	ff b5 bc fe ff ff    	pushl  -0x144(%ebp)
     6ca:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
     6d0:	ff b5 c4 fe ff ff    	pushl  -0x13c(%ebp)
     6d6:	50                   	push   %eax
     6d7:	68 40 fe 01 00       	push   $0x1fe40
     6dc:	e8 e3 22 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     6e1:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){enemy[2].x,enemy[2].y}, (Point){0,enemy_status[2]*enemyHeight[2]},(Size){311,46},(Size){enemyHeight[2],enemyWidth[2]});
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[3].x,enemy[3].y}, (Point){0,enemy_status[3]*enemyHeight[3]},(Size){340,45},(Size){enemyHeight[3],enemyWidth[3]});
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[4].x,enemy[4].y}, (Point){0,enemy_status[4]*enemyHeight[4]},(Size){340,45},(Size){enemyHeight[4],enemyWidth[4]});
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[5].x,enemy[5].y}, (Point){0,enemy_status[5]*enemyHeight[5]},(Size){340,45},(Size){enemyHeight[5],enemyWidth[5]});
            int i = 0;
            for (i = 0; i < bulletNum;i++)
     6e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     6e8:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     6ed:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     6f0:	0f 8c 4c ff ff ff    	jl     642 <MsgProc+0x642>
            {
                api_paint24BitmapToContentTransparent(&wnd,bullet1,(Point){bullets[i].x,bullets[i].y},(Point){0,0},(Size){22,15},(Size){22,15});
            }
            api_repaint(&wnd);
     6f6:	83 ec 0c             	sub    $0xc,%esp
     6f9:	68 40 fe 01 00       	push   $0x1fe40
     6fe:	e8 01 23 00 00       	call   2a04 <api_repaint>
     703:	83 c4 10             	add    $0x10,%esp
            break;
     706:	e9 21 0a 00 00       	jmp    112c <MsgProc+0x112c>
        case M_TIMER:
            //refresh the bullets
            for (i = 0; i < bulletNum; i++)
     70b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     712:	eb 1b                	jmp    72f <MsgProc+0x72f>
            {
                bullets[i].y -= 10;
     714:	8b 45 f4             	mov    -0xc(%ebp),%eax
     717:	8b 04 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%eax
     71e:	8d 50 f6             	lea    -0xa(%eax),%edx
     721:	8b 45 f4             	mov    -0xc(%ebp),%eax
     724:	89 14 c5 44 fd 01 00 	mov    %edx,0x1fd44(,%eax,8)
            }
            api_repaint(&wnd);
            break;
        case M_TIMER:
            //refresh the bullets
            for (i = 0; i < bulletNum; i++)
     72b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     72f:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     734:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     737:	7c db                	jl     714 <MsgProc+0x714>
            {
                bullets[i].y -= 10;
            }
            for (i =0;i<bulletNum;i++)
     739:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     740:	eb 6d                	jmp    7af <MsgProc+0x7af>
            {
                if (bullets[i].y <0)
     742:	8b 45 f4             	mov    -0xc(%ebp),%eax
     745:	8b 04 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%eax
     74c:	85 c0                	test   %eax,%eax
     74e:	79 5b                	jns    7ab <MsgProc+0x7ab>
                {
                    int j = i;
     750:	8b 45 f4             	mov    -0xc(%ebp),%eax
     753:	89 45 f0             	mov    %eax,-0x10(%ebp)
                    for (j = i; j < bulletNum;j++)
     756:	8b 45 f4             	mov    -0xc(%ebp),%eax
     759:	89 45 f0             	mov    %eax,-0x10(%ebp)
     75c:	eb 32                	jmp    790 <MsgProc+0x790>
                    {
                        bullets[j].x = bullets[j+1].x;
     75e:	8b 45 f0             	mov    -0x10(%ebp),%eax
     761:	83 c0 01             	add    $0x1,%eax
     764:	8b 14 c5 40 fd 01 00 	mov    0x1fd40(,%eax,8),%edx
     76b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     76e:	89 14 c5 40 fd 01 00 	mov    %edx,0x1fd40(,%eax,8)
                        bullets[j].y = bullets[j+1].y;
     775:	8b 45 f0             	mov    -0x10(%ebp),%eax
     778:	83 c0 01             	add    $0x1,%eax
     77b:	8b 14 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%edx
     782:	8b 45 f0             	mov    -0x10(%ebp),%eax
     785:	89 14 c5 44 fd 01 00 	mov    %edx,0x1fd44(,%eax,8)
            for (i =0;i<bulletNum;i++)
            {
                if (bullets[i].y <0)
                {
                    int j = i;
                    for (j = i; j < bulletNum;j++)
     78c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     790:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     795:	39 45 f0             	cmp    %eax,-0x10(%ebp)
     798:	7c c4                	jl     75e <MsgProc+0x75e>
                    {
                        bullets[j].x = bullets[j+1].x;
                        bullets[j].y = bullets[j+1].y;
                    }
                    bulletNum-=1;
     79a:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     79f:	83 e8 01             	sub    $0x1,%eax
     7a2:	a3 e4 fc 01 00       	mov    %eax,0x1fce4
                    i--;
     7a7:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
            //refresh the bullets
            for (i = 0; i < bulletNum; i++)
            {
                bullets[i].y -= 10;
            }
            for (i =0;i<bulletNum;i++)
     7ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     7af:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     7b4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     7b7:	7c 89                	jl     742 <MsgProc+0x742>
                    }
                    bulletNum-=1;
                    i--;
                }
            }
            tmp+=1;
     7b9:	a1 ec fc 01 00       	mov    0x1fcec,%eax
     7be:	83 c0 01             	add    $0x1,%eax
     7c1:	a3 ec fc 01 00       	mov    %eax,0x1fcec
            tmp%=3;
     7c6:	8b 0d ec fc 01 00    	mov    0x1fcec,%ecx
     7cc:	ba 56 55 55 55       	mov    $0x55555556,%edx
     7d1:	89 c8                	mov    %ecx,%eax
     7d3:	f7 ea                	imul   %edx
     7d5:	89 c8                	mov    %ecx,%eax
     7d7:	c1 f8 1f             	sar    $0x1f,%eax
     7da:	29 c2                	sub    %eax,%edx
     7dc:	89 d0                	mov    %edx,%eax
     7de:	89 c2                	mov    %eax,%edx
     7e0:	01 d2                	add    %edx,%edx
     7e2:	01 c2                	add    %eax,%edx
     7e4:	89 c8                	mov    %ecx,%eax
     7e6:	29 d0                	sub    %edx,%eax
     7e8:	a3 ec fc 01 00       	mov    %eax,0x1fcec
            if (tmp == 0)
     7ed:	a1 ec fc 01 00       	mov    0x1fcec,%eax
     7f2:	85 c0                	test   %eax,%eax
     7f4:	75 37                	jne    82d <MsgProc+0x82d>
            {
                bullets[bulletNum].x = plane_x+PLANE_WIDTH/2-7;
     7f6:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     7fb:	8b 15 20 fd 01 00    	mov    0x1fd20,%edx
     801:	83 c2 0f             	add    $0xf,%edx
     804:	89 14 c5 40 fd 01 00 	mov    %edx,0x1fd40(,%eax,8)
                bullets[bulletNum].y = plane_y-7;
     80b:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     810:	8b 15 68 fe 01 00    	mov    0x1fe68,%edx
     816:	83 ea 07             	sub    $0x7,%edx
     819:	89 14 c5 44 fd 01 00 	mov    %edx,0x1fd44(,%eax,8)
                bulletNum+=1;
     820:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     825:	83 c0 01             	add    $0x1,%eax
     828:	a3 e4 fc 01 00       	mov    %eax,0x1fce4
            }
            int j;
            location+=30;
     82d:	a1 e8 fc 01 00       	mov    0x1fce8,%eax
     832:	83 c0 1e             	add    $0x1e,%eax
     835:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
            location%=250;
     83a:	8b 0d e8 fc 01 00    	mov    0x1fce8,%ecx
     840:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
     845:	89 c8                	mov    %ecx,%eax
     847:	f7 ea                	imul   %edx
     849:	c1 fa 04             	sar    $0x4,%edx
     84c:	89 c8                	mov    %ecx,%eax
     84e:	c1 f8 1f             	sar    $0x1f,%eax
     851:	29 c2                	sub    %eax,%edx
     853:	89 d0                	mov    %edx,%eax
     855:	69 c0 fa 00 00 00    	imul   $0xfa,%eax,%eax
     85b:	29 c1                	sub    %eax,%ecx
     85d:	89 c8                	mov    %ecx,%eax
     85f:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
            //refresh the enemy
            for (i=0;i<6;i++)
     864:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     86b:	e9 a1 01 00 00       	jmp    a11 <MsgProc+0xa11>
            {
                if (enemy_status[i]!=0)
     870:	8b 45 f4             	mov    -0xc(%ebp),%eax
     873:	8b 04 85 f0 fc 01 00 	mov    0x1fcf0(,%eax,4),%eax
     87a:	85 c0                	test   %eax,%eax
     87c:	74 17                	je     895 <MsgProc+0x895>
                {
                    enemy_status[i]+=1;
     87e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     881:	8b 04 85 f0 fc 01 00 	mov    0x1fcf0(,%eax,4),%eax
     888:	8d 50 01             	lea    0x1(%eax),%edx
     88b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     88e:	89 14 85 f0 fc 01 00 	mov    %edx,0x1fcf0(,%eax,4)
                }
                if (enemy_status[0]>5)
     895:	a1 f0 fc 01 00       	mov    0x1fcf0,%eax
     89a:	83 f8 05             	cmp    $0x5,%eax
     89d:	7e 57                	jle    8f6 <MsgProc+0x8f6>
                {
                    enemy_status[0]=0;
     89f:	c7 05 f0 fc 01 00 00 	movl   $0x0,0x1fcf0
     8a6:	00 00 00 
                    enemy[0].x = location;
     8a9:	a1 e8 fc 01 00       	mov    0x1fce8,%eax
     8ae:	a3 e0 f7 01 00       	mov    %eax,0x1f7e0
                    enemy[0].y = 0;
     8b3:	c7 05 e4 f7 01 00 00 	movl   $0x0,0x1f7e4
     8ba:	00 00 00 
                    location+=30;
     8bd:	a1 e8 fc 01 00       	mov    0x1fce8,%eax
     8c2:	83 c0 1e             	add    $0x1e,%eax
     8c5:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
                    location%=250;
     8ca:	8b 0d e8 fc 01 00    	mov    0x1fce8,%ecx
     8d0:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
     8d5:	89 c8                	mov    %ecx,%eax
     8d7:	f7 ea                	imul   %edx
     8d9:	c1 fa 04             	sar    $0x4,%edx
     8dc:	89 c8                	mov    %ecx,%eax
     8de:	c1 f8 1f             	sar    $0x1f,%eax
     8e1:	29 c2                	sub    %eax,%edx
     8e3:	89 d0                	mov    %edx,%eax
     8e5:	69 c0 fa 00 00 00    	imul   $0xfa,%eax,%eax
     8eb:	29 c1                	sub    %eax,%ecx
     8ed:	89 c8                	mov    %ecx,%eax
     8ef:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
     8f4:	eb 78                	jmp    96e <MsgProc+0x96e>
                }
                else if ((i!=0)&&(enemy_status[i]>4))
     8f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     8fa:	74 72                	je     96e <MsgProc+0x96e>
     8fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8ff:	8b 04 85 f0 fc 01 00 	mov    0x1fcf0(,%eax,4),%eax
     906:	83 f8 04             	cmp    $0x4,%eax
     909:	7e 63                	jle    96e <MsgProc+0x96e>
                {
                    enemy_status[i]=0;
     90b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     90e:	c7 04 85 f0 fc 01 00 	movl   $0x0,0x1fcf0(,%eax,4)
     915:	00 00 00 00 
                    enemy[i].x = location;
     919:	8b 15 e8 fc 01 00    	mov    0x1fce8,%edx
     91f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     922:	89 14 c5 e0 f7 01 00 	mov    %edx,0x1f7e0(,%eax,8)
                    enemy[i].y = 0;
     929:	8b 45 f4             	mov    -0xc(%ebp),%eax
     92c:	c7 04 c5 e4 f7 01 00 	movl   $0x0,0x1f7e4(,%eax,8)
     933:	00 00 00 00 
                    location+=30;
     937:	a1 e8 fc 01 00       	mov    0x1fce8,%eax
     93c:	83 c0 1e             	add    $0x1e,%eax
     93f:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
                    location%=250;
     944:	8b 0d e8 fc 01 00    	mov    0x1fce8,%ecx
     94a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
     94f:	89 c8                	mov    %ecx,%eax
     951:	f7 ea                	imul   %edx
     953:	c1 fa 04             	sar    $0x4,%edx
     956:	89 c8                	mov    %ecx,%eax
     958:	c1 f8 1f             	sar    $0x1f,%eax
     95b:	29 c2                	sub    %eax,%edx
     95d:	89 d0                	mov    %edx,%eax
     95f:	69 c0 fa 00 00 00    	imul   $0xfa,%eax,%eax
     965:	29 c1                	sub    %eax,%ecx
     967:	89 c8                	mov    %ecx,%eax
     969:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
                }
                if (enemy_status[i]==0)
     96e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     971:	8b 04 85 f0 fc 01 00 	mov    0x1fcf0(,%eax,4),%eax
     978:	85 c0                	test   %eax,%eax
     97a:	0f 85 8d 00 00 00    	jne    a0d <MsgProc+0xa0d>
                {
                    enemy[i].y+=10;
     980:	8b 45 f4             	mov    -0xc(%ebp),%eax
     983:	8b 04 c5 e4 f7 01 00 	mov    0x1f7e4(,%eax,8),%eax
     98a:	8d 50 0a             	lea    0xa(%eax),%edx
     98d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     990:	89 14 c5 e4 f7 01 00 	mov    %edx,0x1f7e4(,%eax,8)
                    if (enemy[i].y > (500-enemyHeight[i]))
     997:	8b 45 f4             	mov    -0xc(%ebp),%eax
     99a:	8b 14 c5 e4 f7 01 00 	mov    0x1f7e4(,%eax,8),%edx
     9a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     9a4:	8b 04 85 84 f8 01 00 	mov    0x1f884(,%eax,4),%eax
     9ab:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
     9b0:	29 c1                	sub    %eax,%ecx
     9b2:	89 c8                	mov    %ecx,%eax
     9b4:	39 c2                	cmp    %eax,%edx
     9b6:	7e 55                	jle    a0d <MsgProc+0xa0d>
                    {
                        enemy[i].y = 0;
     9b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     9bb:	c7 04 c5 e4 f7 01 00 	movl   $0x0,0x1f7e4(,%eax,8)
     9c2:	00 00 00 00 
                        enemy[i].x = location;
     9c6:	8b 15 e8 fc 01 00    	mov    0x1fce8,%edx
     9cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     9cf:	89 14 c5 e0 f7 01 00 	mov    %edx,0x1f7e0(,%eax,8)
                        location+=30;
     9d6:	a1 e8 fc 01 00       	mov    0x1fce8,%eax
     9db:	83 c0 1e             	add    $0x1e,%eax
     9de:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
                        location%=250;
     9e3:	8b 0d e8 fc 01 00    	mov    0x1fce8,%ecx
     9e9:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
     9ee:	89 c8                	mov    %ecx,%eax
     9f0:	f7 ea                	imul   %edx
     9f2:	c1 fa 04             	sar    $0x4,%edx
     9f5:	89 c8                	mov    %ecx,%eax
     9f7:	c1 f8 1f             	sar    $0x1f,%eax
     9fa:	29 c2                	sub    %eax,%edx
     9fc:	89 d0                	mov    %edx,%eax
     9fe:	69 c0 fa 00 00 00    	imul   $0xfa,%eax,%eax
     a04:	29 c1                	sub    %eax,%ecx
     a06:	89 c8                	mov    %ecx,%eax
     a08:	a3 e8 fc 01 00       	mov    %eax,0x1fce8
            }
            int j;
            location+=30;
            location%=250;
            //refresh the enemy
            for (i=0;i<6;i++)
     a0d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     a11:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
     a15:	0f 8e 55 fe ff ff    	jle    870 <MsgProc+0x870>
                        location%=250;
                    }
                }
            }
            //crash
            for (i=0; i < 6; i++)
     a1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     a22:	e9 1d 01 00 00       	jmp    b44 <MsgProc+0xb44>
            {
                if (enemy_status[i]!=0) continue;
     a27:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a2a:	8b 04 85 f0 fc 01 00 	mov    0x1fcf0(,%eax,4),%eax
     a31:	85 c0                	test   %eax,%eax
     a33:	0f 85 06 01 00 00    	jne    b3f <MsgProc+0xb3f>
                for (j = 0; j<bulletNum;j++)
     a39:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     a40:	e9 ea 00 00 00       	jmp    b2f <MsgProc+0xb2f>
                {
                    if (((bullets[j].x<enemy[i].x+enemyWidth[i])&&(bullets[j].x>(enemy[i].x-9))&&(bullets[j].y>enemy[i].y-21)&&(bullets[j].y)<enemy[i].y+enemyHeight[i]))
     a45:	8b 45 ec             	mov    -0x14(%ebp),%eax
     a48:	8b 14 c5 40 fd 01 00 	mov    0x1fd40(,%eax,8),%edx
     a4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a52:	8b 0c c5 e0 f7 01 00 	mov    0x1f7e0(,%eax,8),%ecx
     a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a5c:	8b 04 85 6c f8 01 00 	mov    0x1f86c(,%eax,4),%eax
     a63:	01 c8                	add    %ecx,%eax
     a65:	39 c2                	cmp    %eax,%edx
     a67:	0f 8d be 00 00 00    	jge    b2b <MsgProc+0xb2b>
     a6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
     a70:	8b 14 c5 40 fd 01 00 	mov    0x1fd40(,%eax,8),%edx
     a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a7a:	8b 04 c5 e0 f7 01 00 	mov    0x1f7e0(,%eax,8),%eax
     a81:	83 e8 09             	sub    $0x9,%eax
     a84:	39 c2                	cmp    %eax,%edx
     a86:	0f 8e 9f 00 00 00    	jle    b2b <MsgProc+0xb2b>
     a8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
     a8f:	8b 14 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%edx
     a96:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a99:	8b 04 c5 e4 f7 01 00 	mov    0x1f7e4(,%eax,8),%eax
     aa0:	83 e8 15             	sub    $0x15,%eax
     aa3:	39 c2                	cmp    %eax,%edx
     aa5:	0f 8e 80 00 00 00    	jle    b2b <MsgProc+0xb2b>
     aab:	8b 45 ec             	mov    -0x14(%ebp),%eax
     aae:	8b 14 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%edx
     ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ab8:	8b 0c c5 e4 f7 01 00 	mov    0x1f7e4(,%eax,8),%ecx
     abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ac2:	8b 04 85 84 f8 01 00 	mov    0x1f884(,%eax,4),%eax
     ac9:	01 c8                	add    %ecx,%eax
     acb:	39 c2                	cmp    %eax,%edx
     acd:	7d 5c                	jge    b2b <MsgProc+0xb2b>
                    {
                        enemy_status[i]=1;
     acf:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ad2:	c7 04 85 f0 fc 01 00 	movl   $0x1,0x1fcf0(,%eax,4)
     ad9:	01 00 00 00 
                        for (; j < bulletNum-1;j++)
     add:	eb 32                	jmp    b11 <MsgProc+0xb11>
                        {
                            bullets[j].x = bullets[j+1].x;
     adf:	8b 45 ec             	mov    -0x14(%ebp),%eax
     ae2:	83 c0 01             	add    $0x1,%eax
     ae5:	8b 14 c5 40 fd 01 00 	mov    0x1fd40(,%eax,8),%edx
     aec:	8b 45 ec             	mov    -0x14(%ebp),%eax
     aef:	89 14 c5 40 fd 01 00 	mov    %edx,0x1fd40(,%eax,8)
                            bullets[j].y = bullets[j+1].y;
     af6:	8b 45 ec             	mov    -0x14(%ebp),%eax
     af9:	83 c0 01             	add    $0x1,%eax
     afc:	8b 14 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%edx
     b03:	8b 45 ec             	mov    -0x14(%ebp),%eax
     b06:	89 14 c5 44 fd 01 00 	mov    %edx,0x1fd44(,%eax,8)
                for (j = 0; j<bulletNum;j++)
                {
                    if (((bullets[j].x<enemy[i].x+enemyWidth[i])&&(bullets[j].x>(enemy[i].x-9))&&(bullets[j].y>enemy[i].y-21)&&(bullets[j].y)<enemy[i].y+enemyHeight[i]))
                    {
                        enemy_status[i]=1;
                        for (; j < bulletNum-1;j++)
     b0d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
     b11:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     b16:	83 e8 01             	sub    $0x1,%eax
     b19:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     b1c:	7f c1                	jg     adf <MsgProc+0xadf>
                        {
                            bullets[j].x = bullets[j+1].x;
                            bullets[j].y = bullets[j+1].y;
                        }
                        bulletNum-=1;
     b1e:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     b23:	83 e8 01             	sub    $0x1,%eax
     b26:	a3 e4 fc 01 00       	mov    %eax,0x1fce4
            }
            //crash
            for (i=0; i < 6; i++)
            {
                if (enemy_status[i]!=0) continue;
                for (j = 0; j<bulletNum;j++)
     b2b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
     b2f:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
     b34:	39 45 ec             	cmp    %eax,-0x14(%ebp)
     b37:	0f 8c 08 ff ff ff    	jl     a45 <MsgProc+0xa45>
     b3d:	eb 01                	jmp    b40 <MsgProc+0xb40>
                }
            }
            //crash
            for (i=0; i < 6; i++)
            {
                if (enemy_status[i]!=0) continue;
     b3f:	90                   	nop
                        location%=250;
                    }
                }
            }
            //crash
            for (i=0; i < 6; i++)
     b40:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     b44:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
     b48:	0f 8e d9 fe ff ff    	jle    a27 <MsgProc+0xa27>
                        }
                        bulletNum-=1;
                    }
                }
            }
            backgroundh+=10;
     b4e:	a1 e0 fc 01 00       	mov    0x1fce0,%eax
     b53:	83 c0 0a             	add    $0xa,%eax
     b56:	a3 e0 fc 01 00       	mov    %eax,0x1fce0
            backgroundh%=800;
     b5b:	8b 0d e0 fc 01 00    	mov    0x1fce0,%ecx
     b61:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
     b66:	89 c8                	mov    %ecx,%eax
     b68:	f7 ea                	imul   %edx
     b6a:	c1 fa 08             	sar    $0x8,%edx
     b6d:	89 c8                	mov    %ecx,%eax
     b6f:	c1 f8 1f             	sar    $0x1f,%eax
     b72:	29 c2                	sub    %eax,%edx
     b74:	89 d0                	mov    %edx,%eax
     b76:	69 c0 20 03 00 00    	imul   $0x320,%eax,%eax
     b7c:	29 c1                	sub    %eax,%ecx
     b7e:	89 c8                	mov    %ecx,%eax
     b80:	a3 e0 fc 01 00       	mov    %eax,0x1fce0
            api_paint24BitmapToContentTransparent(&wnd, background, (Point){0,0},(Point){0,backgroundh},(Size){1600,480},(Size){500,480});
     b85:	c7 85 cc fe ff ff f4 	movl   $0x1f4,-0x134(%ebp)
     b8c:	01 00 00 
     b8f:	c7 85 d0 fe ff ff e0 	movl   $0x1e0,-0x130(%ebp)
     b96:	01 00 00 
     b99:	c7 85 d4 fe ff ff 40 	movl   $0x640,-0x12c(%ebp)
     ba0:	06 00 00 
     ba3:	c7 85 d8 fe ff ff e0 	movl   $0x1e0,-0x128(%ebp)
     baa:	01 00 00 
     bad:	c7 85 dc fe ff ff 00 	movl   $0x0,-0x124(%ebp)
     bb4:	00 00 00 
     bb7:	a1 e0 fc 01 00       	mov    0x1fce0,%eax
     bbc:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
     bc2:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
     bc9:	00 00 00 
     bcc:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
     bd3:	00 00 00 
     bd6:	a1 28 fd 01 00       	mov    0x1fd28,%eax
     bdb:	83 ec 08             	sub    $0x8,%esp
     bde:	ff b5 d0 fe ff ff    	pushl  -0x130(%ebp)
     be4:	ff b5 cc fe ff ff    	pushl  -0x134(%ebp)
     bea:	ff b5 d8 fe ff ff    	pushl  -0x128(%ebp)
     bf0:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
     bf6:	ff b5 e0 fe ff ff    	pushl  -0x120(%ebp)
     bfc:	ff b5 dc fe ff ff    	pushl  -0x124(%ebp)
     c02:	ff b5 e8 fe ff ff    	pushl  -0x118(%ebp)
     c08:	ff b5 e4 fe ff ff    	pushl  -0x11c(%ebp)
     c0e:	50                   	push   %eax
     c0f:	68 40 fe 01 00       	push   $0x1fe40
     c14:	e8 ab 1d 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     c19:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, plane, (Point){plane_x,plane_y}, (Point){0,0}, (Size){273,PLANE_WIDTH},(Size){PLANE_HEIGHT,PLANE_WIDTH});
     c1c:	c7 85 ec fe ff ff 2f 	movl   $0x2f,-0x114(%ebp)
     c23:	00 00 00 
     c26:	c7 85 f0 fe ff ff 2d 	movl   $0x2d,-0x110(%ebp)
     c2d:	00 00 00 
     c30:	c7 85 f4 fe ff ff 11 	movl   $0x111,-0x10c(%ebp)
     c37:	01 00 00 
     c3a:	c7 85 f8 fe ff ff 2d 	movl   $0x2d,-0x108(%ebp)
     c41:	00 00 00 
     c44:	c7 85 fc fe ff ff 00 	movl   $0x0,-0x104(%ebp)
     c4b:	00 00 00 
     c4e:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
     c55:	00 00 00 
     c58:	a1 20 fd 01 00       	mov    0x1fd20,%eax
     c5d:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
     c63:	a1 68 fe 01 00       	mov    0x1fe68,%eax
     c68:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
     c6e:	a1 30 fe 01 00       	mov    0x1fe30,%eax
     c73:	83 ec 08             	sub    $0x8,%esp
     c76:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
     c7c:	ff b5 ec fe ff ff    	pushl  -0x114(%ebp)
     c82:	ff b5 f8 fe ff ff    	pushl  -0x108(%ebp)
     c88:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
     c8e:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
     c94:	ff b5 fc fe ff ff    	pushl  -0x104(%ebp)
     c9a:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
     ca0:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
     ca6:	50                   	push   %eax
     ca7:	68 40 fe 01 00       	push   $0x1fe40
     cac:	e8 13 1d 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     cb1:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, bigEnemy, (Point){enemy[0].x,enemy[0].y}, (Point){0,enemy_status[0]*enemyHeight[0]},(Size){401,64},(Size){enemyHeight[0],enemyWidth[0]});
     cb4:	a1 84 f8 01 00       	mov    0x1f884,%eax
     cb9:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
     cbf:	a1 6c f8 01 00       	mov    0x1f86c,%eax
     cc4:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
     cca:	c7 85 14 ff ff ff 91 	movl   $0x191,-0xec(%ebp)
     cd1:	01 00 00 
     cd4:	c7 85 18 ff ff ff 40 	movl   $0x40,-0xe8(%ebp)
     cdb:	00 00 00 
     cde:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%ebp)
     ce5:	00 00 00 
     ce8:	8b 15 f0 fc 01 00    	mov    0x1fcf0,%edx
     cee:	a1 84 f8 01 00       	mov    0x1f884,%eax
     cf3:	0f af c2             	imul   %edx,%eax
     cf6:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
     cfc:	a1 e0 f7 01 00       	mov    0x1f7e0,%eax
     d01:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
     d07:	a1 e4 f7 01 00       	mov    0x1f7e4,%eax
     d0c:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
     d12:	a1 60 fe 01 00       	mov    0x1fe60,%eax
     d17:	83 ec 08             	sub    $0x8,%esp
     d1a:	ff b5 10 ff ff ff    	pushl  -0xf0(%ebp)
     d20:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
     d26:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
     d2c:	ff b5 14 ff ff ff    	pushl  -0xec(%ebp)
     d32:	ff b5 20 ff ff ff    	pushl  -0xe0(%ebp)
     d38:	ff b5 1c ff ff ff    	pushl  -0xe4(%ebp)
     d3e:	ff b5 28 ff ff ff    	pushl  -0xd8(%ebp)
     d44:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
     d4a:	50                   	push   %eax
     d4b:	68 40 fe 01 00       	push   $0x1fe40
     d50:	e8 6f 1c 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     d55:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){enemy[1].x,enemy[1].y}, (Point){0,enemy_status[1]*enemyHeight[1]},(Size){311,46},(Size){enemyHeight[1],enemyWidth[1]});
     d58:	a1 88 f8 01 00       	mov    0x1f888,%eax
     d5d:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
     d63:	a1 70 f8 01 00       	mov    0x1f870,%eax
     d68:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
     d6e:	c7 85 34 ff ff ff 37 	movl   $0x137,-0xcc(%ebp)
     d75:	01 00 00 
     d78:	c7 85 38 ff ff ff 2e 	movl   $0x2e,-0xc8(%ebp)
     d7f:	00 00 00 
     d82:	c7 85 3c ff ff ff 00 	movl   $0x0,-0xc4(%ebp)
     d89:	00 00 00 
     d8c:	8b 15 f4 fc 01 00    	mov    0x1fcf4,%edx
     d92:	a1 88 f8 01 00       	mov    0x1f888,%eax
     d97:	0f af c2             	imul   %edx,%eax
     d9a:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
     da0:	a1 e8 f7 01 00       	mov    0x1f7e8,%eax
     da5:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
     dab:	a1 ec f7 01 00       	mov    0x1f7ec,%eax
     db0:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
     db6:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
     dbb:	83 ec 08             	sub    $0x8,%esp
     dbe:	ff b5 30 ff ff ff    	pushl  -0xd0(%ebp)
     dc4:	ff b5 2c ff ff ff    	pushl  -0xd4(%ebp)
     dca:	ff b5 38 ff ff ff    	pushl  -0xc8(%ebp)
     dd0:	ff b5 34 ff ff ff    	pushl  -0xcc(%ebp)
     dd6:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
     ddc:	ff b5 3c ff ff ff    	pushl  -0xc4(%ebp)
     de2:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
     de8:	ff b5 44 ff ff ff    	pushl  -0xbc(%ebp)
     dee:	50                   	push   %eax
     def:	68 40 fe 01 00       	push   $0x1fe40
     df4:	e8 cb 1b 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     df9:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){enemy[2].x,enemy[2].y}, (Point){0,enemy_status[2]*enemyHeight[2]},(Size){311,46},(Size){enemyHeight[2],enemyWidth[2]});
     dfc:	a1 8c f8 01 00       	mov    0x1f88c,%eax
     e01:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
     e07:	a1 74 f8 01 00       	mov    0x1f874,%eax
     e0c:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
     e12:	c7 85 54 ff ff ff 37 	movl   $0x137,-0xac(%ebp)
     e19:	01 00 00 
     e1c:	c7 85 58 ff ff ff 2e 	movl   $0x2e,-0xa8(%ebp)
     e23:	00 00 00 
     e26:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
     e2d:	00 00 00 
     e30:	8b 15 f8 fc 01 00    	mov    0x1fcf8,%edx
     e36:	a1 8c f8 01 00       	mov    0x1f88c,%eax
     e3b:	0f af c2             	imul   %edx,%eax
     e3e:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
     e44:	a1 f0 f7 01 00       	mov    0x1f7f0,%eax
     e49:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
     e4f:	a1 f4 f7 01 00       	mov    0x1f7f4,%eax
     e54:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
     e5a:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
     e5f:	83 ec 08             	sub    $0x8,%esp
     e62:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
     e68:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
     e6e:	ff b5 58 ff ff ff    	pushl  -0xa8(%ebp)
     e74:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
     e7a:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
     e80:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
     e86:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
     e8c:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
     e92:	50                   	push   %eax
     e93:	68 40 fe 01 00       	push   $0x1fe40
     e98:	e8 27 1b 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     e9d:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[3].x,enemy[3].y}, (Point){0,enemy_status[3]*enemyHeight[3]},(Size){340,45},(Size){enemyHeight[3],enemyWidth[3]});
     ea0:	a1 90 f8 01 00       	mov    0x1f890,%eax
     ea5:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
     eab:	a1 78 f8 01 00       	mov    0x1f878,%eax
     eb0:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
     eb6:	c7 85 74 ff ff ff 54 	movl   $0x154,-0x8c(%ebp)
     ebd:	01 00 00 
     ec0:	c7 85 78 ff ff ff 2d 	movl   $0x2d,-0x88(%ebp)
     ec7:	00 00 00 
     eca:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
     ed1:	00 00 00 
     ed4:	8b 15 fc fc 01 00    	mov    0x1fcfc,%edx
     eda:	a1 90 f8 01 00       	mov    0x1f890,%eax
     edf:	0f af c2             	imul   %edx,%eax
     ee2:	89 45 80             	mov    %eax,-0x80(%ebp)
     ee5:	a1 f8 f7 01 00       	mov    0x1f7f8,%eax
     eea:	89 45 84             	mov    %eax,-0x7c(%ebp)
     eed:	a1 fc f7 01 00       	mov    0x1f7fc,%eax
     ef2:	89 45 88             	mov    %eax,-0x78(%ebp)
     ef5:	a1 70 fe 01 00       	mov    0x1fe70,%eax
     efa:	83 ec 08             	sub    $0x8,%esp
     efd:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
     f03:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
     f09:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
     f0f:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
     f15:	ff 75 80             	pushl  -0x80(%ebp)
     f18:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
     f1e:	ff 75 88             	pushl  -0x78(%ebp)
     f21:	ff 75 84             	pushl  -0x7c(%ebp)
     f24:	50                   	push   %eax
     f25:	68 40 fe 01 00       	push   $0x1fe40
     f2a:	e8 95 1a 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     f2f:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[4].x,enemy[4].y}, (Point){0,enemy_status[4]*enemyHeight[4]},(Size){340,45},(Size){enemyHeight[4],enemyWidth[4]});
     f32:	a1 94 f8 01 00       	mov    0x1f894,%eax
     f37:	89 45 8c             	mov    %eax,-0x74(%ebp)
     f3a:	a1 7c f8 01 00       	mov    0x1f87c,%eax
     f3f:	89 45 90             	mov    %eax,-0x70(%ebp)
     f42:	c7 45 94 54 01 00 00 	movl   $0x154,-0x6c(%ebp)
     f49:	c7 45 98 2d 00 00 00 	movl   $0x2d,-0x68(%ebp)
     f50:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
     f57:	8b 15 00 fd 01 00    	mov    0x1fd00,%edx
     f5d:	a1 94 f8 01 00       	mov    0x1f894,%eax
     f62:	0f af c2             	imul   %edx,%eax
     f65:	89 45 a0             	mov    %eax,-0x60(%ebp)
     f68:	a1 00 f8 01 00       	mov    0x1f800,%eax
     f6d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
     f70:	a1 04 f8 01 00       	mov    0x1f804,%eax
     f75:	89 45 a8             	mov    %eax,-0x58(%ebp)
     f78:	a1 70 fe 01 00       	mov    0x1fe70,%eax
     f7d:	83 ec 08             	sub    $0x8,%esp
     f80:	ff 75 90             	pushl  -0x70(%ebp)
     f83:	ff 75 8c             	pushl  -0x74(%ebp)
     f86:	ff 75 98             	pushl  -0x68(%ebp)
     f89:	ff 75 94             	pushl  -0x6c(%ebp)
     f8c:	ff 75 a0             	pushl  -0x60(%ebp)
     f8f:	ff 75 9c             	pushl  -0x64(%ebp)
     f92:	ff 75 a8             	pushl  -0x58(%ebp)
     f95:	ff 75 a4             	pushl  -0x5c(%ebp)
     f98:	50                   	push   %eax
     f99:	68 40 fe 01 00       	push   $0x1fe40
     f9e:	e8 21 1a 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
     fa3:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[5].x,enemy[5].y}, (Point){0,enemy_status[5]*enemyHeight[5]},(Size){340,45},(Size){enemyHeight[5],enemyWidth[5]});
     fa6:	a1 98 f8 01 00       	mov    0x1f898,%eax
     fab:	89 45 ac             	mov    %eax,-0x54(%ebp)
     fae:	a1 80 f8 01 00       	mov    0x1f880,%eax
     fb3:	89 45 b0             	mov    %eax,-0x50(%ebp)
     fb6:	c7 45 b4 54 01 00 00 	movl   $0x154,-0x4c(%ebp)
     fbd:	c7 45 b8 2d 00 00 00 	movl   $0x2d,-0x48(%ebp)
     fc4:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
     fcb:	8b 15 04 fd 01 00    	mov    0x1fd04,%edx
     fd1:	a1 98 f8 01 00       	mov    0x1f898,%eax
     fd6:	0f af c2             	imul   %edx,%eax
     fd9:	89 45 c0             	mov    %eax,-0x40(%ebp)
     fdc:	a1 08 f8 01 00       	mov    0x1f808,%eax
     fe1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
     fe4:	a1 0c f8 01 00       	mov    0x1f80c,%eax
     fe9:	89 45 c8             	mov    %eax,-0x38(%ebp)
     fec:	a1 70 fe 01 00       	mov    0x1fe70,%eax
     ff1:	83 ec 08             	sub    $0x8,%esp
     ff4:	ff 75 b0             	pushl  -0x50(%ebp)
     ff7:	ff 75 ac             	pushl  -0x54(%ebp)
     ffa:	ff 75 b8             	pushl  -0x48(%ebp)
     ffd:	ff 75 b4             	pushl  -0x4c(%ebp)
    1000:	ff 75 c0             	pushl  -0x40(%ebp)
    1003:	ff 75 bc             	pushl  -0x44(%ebp)
    1006:	ff 75 c8             	pushl  -0x38(%ebp)
    1009:	ff 75 c4             	pushl  -0x3c(%ebp)
    100c:	50                   	push   %eax
    100d:	68 40 fe 01 00       	push   $0x1fe40
    1012:	e8 ad 19 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    1017:	83 c4 30             	add    $0x30,%esp
            for (i = 0; i < bulletNum;i++)
    101a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1021:	eb 76                	jmp    1099 <MsgProc+0x1099>
            {
                api_paint24BitmapToContentTransparent(&wnd,bullet1,(Point){bullets[i].x,bullets[i].y},(Point){0,0},(Size){22,15},(Size){22,15});
    1023:	c7 45 cc 16 00 00 00 	movl   $0x16,-0x34(%ebp)
    102a:	c7 45 d0 0f 00 00 00 	movl   $0xf,-0x30(%ebp)
    1031:	c7 45 d4 16 00 00 00 	movl   $0x16,-0x2c(%ebp)
    1038:	c7 45 d8 0f 00 00 00 	movl   $0xf,-0x28(%ebp)
    103f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    1046:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    104d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1050:	8b 04 c5 40 fd 01 00 	mov    0x1fd40(,%eax,8),%eax
    1057:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    105a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    105d:	8b 04 c5 44 fd 01 00 	mov    0x1fd44(,%eax,8),%eax
    1064:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1067:	a1 24 fd 01 00       	mov    0x1fd24,%eax
    106c:	83 ec 08             	sub    $0x8,%esp
    106f:	ff 75 d0             	pushl  -0x30(%ebp)
    1072:	ff 75 cc             	pushl  -0x34(%ebp)
    1075:	ff 75 d8             	pushl  -0x28(%ebp)
    1078:	ff 75 d4             	pushl  -0x2c(%ebp)
    107b:	ff 75 e0             	pushl  -0x20(%ebp)
    107e:	ff 75 dc             	pushl  -0x24(%ebp)
    1081:	ff 75 e8             	pushl  -0x18(%ebp)
    1084:	ff 75 e4             	pushl  -0x1c(%ebp)
    1087:	50                   	push   %eax
    1088:	68 40 fe 01 00       	push   $0x1fe40
    108d:	e8 32 19 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    1092:	83 c4 30             	add    $0x30,%esp
            api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){enemy[1].x,enemy[1].y}, (Point){0,enemy_status[1]*enemyHeight[1]},(Size){311,46},(Size){enemyHeight[1],enemyWidth[1]});
            api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){enemy[2].x,enemy[2].y}, (Point){0,enemy_status[2]*enemyHeight[2]},(Size){311,46},(Size){enemyHeight[2],enemyWidth[2]});
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[3].x,enemy[3].y}, (Point){0,enemy_status[3]*enemyHeight[3]},(Size){340,45},(Size){enemyHeight[3],enemyWidth[3]});
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[4].x,enemy[4].y}, (Point){0,enemy_status[4]*enemyHeight[4]},(Size){340,45},(Size){enemyHeight[4],enemyWidth[4]});
            api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){enemy[5].x,enemy[5].y}, (Point){0,enemy_status[5]*enemyHeight[5]},(Size){340,45},(Size){enemyHeight[5],enemyWidth[5]});
            for (i = 0; i < bulletNum;i++)
    1095:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1099:	a1 e4 fc 01 00       	mov    0x1fce4,%eax
    109e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    10a1:	7c 80                	jl     1023 <MsgProc+0x1023>
            {
                api_paint24BitmapToContentTransparent(&wnd,bullet1,(Point){bullets[i].x,bullets[i].y},(Point){0,0},(Size){22,15},(Size){22,15});
            }
            api_repaint(&wnd);
    10a3:	83 ec 0c             	sub    $0xc,%esp
    10a6:	68 40 fe 01 00       	push   $0x1fe40
    10ab:	e8 54 19 00 00       	call   2a04 <api_repaint>
    10b0:	83 c4 10             	add    $0x10,%esp
            break;
    10b3:	eb 77                	jmp    112c <MsgProc+0x112c>
        case M_CLOSE_WINDOW:
            free(background);
    10b5:	a1 28 fd 01 00       	mov    0x1fd28,%eax
    10ba:	83 ec 0c             	sub    $0xc,%esp
    10bd:	50                   	push   %eax
    10be:	e8 33 0c 00 00       	call   1cf6 <free>
    10c3:	83 c4 10             	add    $0x10,%esp
            free(plane);
    10c6:	a1 30 fe 01 00       	mov    0x1fe30,%eax
    10cb:	83 ec 0c             	sub    $0xc,%esp
    10ce:	50                   	push   %eax
    10cf:	e8 22 0c 00 00       	call   1cf6 <free>
    10d4:	83 c4 10             	add    $0x10,%esp
            free(bigEnemy);
    10d7:	a1 60 fe 01 00       	mov    0x1fe60,%eax
    10dc:	83 ec 0c             	sub    $0xc,%esp
    10df:	50                   	push   %eax
    10e0:	e8 11 0c 00 00       	call   1cf6 <free>
    10e5:	83 c4 10             	add    $0x10,%esp
            free(middleEnemy);
    10e8:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
    10ed:	83 ec 0c             	sub    $0xc,%esp
    10f0:	50                   	push   %eax
    10f1:	e8 00 0c 00 00       	call   1cf6 <free>
    10f6:	83 c4 10             	add    $0x10,%esp
            free(smallEnemy);
    10f9:	a1 70 fe 01 00       	mov    0x1fe70,%eax
    10fe:	83 ec 0c             	sub    $0xc,%esp
    1101:	50                   	push   %eax
    1102:	e8 ef 0b 00 00       	call   1cf6 <free>
    1107:	83 c4 10             	add    $0x10,%esp
            free(bullet1);
    110a:	a1 24 fd 01 00       	mov    0x1fd24,%eax
    110f:	83 ec 0c             	sub    $0xc,%esp
    1112:	50                   	push   %eax
    1113:	e8 de 0b 00 00       	call   1cf6 <free>
    1118:	83 c4 10             	add    $0x10,%esp
            api_destroywindow(&wnd);
    111b:	83 ec 0c             	sub    $0xc,%esp
    111e:	68 40 fe 01 00       	push   $0x1fe40
    1123:	e8 7f 1b 00 00       	call   2ca7 <api_destroywindow>
    1128:	83 c4 10             	add    $0x10,%esp
            break;
    112b:	90                   	nop
    }
    
}
    112c:	90                   	nop
    112d:	c9                   	leave  
    112e:	c3                   	ret    

0000112f <main>:

int main(void)
{
    112f:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    1133:	83 e4 f0             	and    $0xfffffff0,%esp
    1136:	ff 71 fc             	pushl  -0x4(%ecx)
    1139:	55                   	push   %ebp
    113a:	89 e5                	mov    %esp,%ebp
    113c:	51                   	push   %ecx
    113d:	81 ec 14 01 00 00    	sub    $0x114,%esp
    wnd.pos.x = 160;
    1143:	c7 05 44 fe 01 00 a0 	movl   $0xa0,0x1fe44
    114a:	00 00 00 
    wnd.pos.y = 30;
    114d:	c7 05 48 fe 01 00 1e 	movl   $0x1e,0x1fe48
    1154:	00 00 00 
    wnd.size.w = 480;
    1157:	c7 05 50 fe 01 00 e0 	movl   $0x1e0,0x1fe50
    115e:	01 00 00 
    wnd.size.h = 500;
    1161:	c7 05 4c fe 01 00 f4 	movl   $0x1f4,0x1fe4c
    1168:	01 00 00 
    wnd.title = "plane war";
    116b:	c7 05 54 fe 01 00 c0 	movl   $0x174c0,0x1fe54
    1172:	74 01 00 
    int h,w;
    plane_x=130;
    1175:	c7 05 20 fd 01 00 82 	movl   $0x82,0x1fd20
    117c:	00 00 00 
    plane_y = 440;
    117f:	c7 05 68 fe 01 00 b8 	movl   $0x1b8,0x1fe68
    1186:	01 00 00 
    background = malloc(480*1600*3);
    1189:	83 ec 0c             	sub    $0xc,%esp
    118c:	68 00 28 23 00       	push   $0x232800
    1191:	e8 a2 0c 00 00       	call   1e38 <malloc>
    1196:	83 c4 10             	add    $0x10,%esp
    1199:	a3 28 fd 01 00       	mov    %eax,0x1fd28
    plane = malloc(45*273*3);
    119e:	83 ec 0c             	sub    $0xc,%esp
    11a1:	68 f7 8f 00 00       	push   $0x8ff7
    11a6:	e8 8d 0c 00 00       	call   1e38 <malloc>
    11ab:	83 c4 10             	add    $0x10,%esp
    11ae:	a3 30 fe 01 00       	mov    %eax,0x1fe30
    bigEnemy = malloc(64*401*3);
    11b3:	83 ec 0c             	sub    $0xc,%esp
    11b6:	68 c0 2c 01 00       	push   $0x12cc0
    11bb:	e8 78 0c 00 00       	call   1e38 <malloc>
    11c0:	83 c4 10             	add    $0x10,%esp
    11c3:	a3 60 fe 01 00       	mov    %eax,0x1fe60
    middleEnemy = malloc(46*311*3);
    11c8:	83 ec 0c             	sub    $0xc,%esp
    11cb:	68 a6 a7 00 00       	push   $0xa7a6
    11d0:	e8 63 0c 00 00       	call   1e38 <malloc>
    11d5:	83 c4 10             	add    $0x10,%esp
    11d8:	a3 6c fe 01 00       	mov    %eax,0x1fe6c
    smallEnemy = malloc(45*340*3);
    11dd:	83 ec 0c             	sub    $0xc,%esp
    11e0:	68 4c b3 00 00       	push   $0xb34c
    11e5:	e8 4e 0c 00 00       	call   1e38 <malloc>
    11ea:	83 c4 10             	add    $0x10,%esp
    11ed:	a3 70 fe 01 00       	mov    %eax,0x1fe70
    bullet1 = malloc(15*22*3);
    11f2:	83 ec 0c             	sub    $0xc,%esp
    11f5:	68 de 03 00 00       	push   $0x3de
    11fa:	e8 39 0c 00 00       	call   1e38 <malloc>
    11ff:	83 c4 10             	add    $0x10,%esp
    1202:	a3 24 fd 01 00       	mov    %eax,0x1fd24
    api_createwindow(&wnd);
    1207:	83 ec 0c             	sub    $0xc,%esp
    120a:	68 40 fe 01 00       	push   $0x1fe40
    120f:	e8 5e 16 00 00       	call   2872 <api_createwindow>
    1214:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(filename, background, &h, &w);
    1217:	a1 28 fd 01 00       	mov    0x1fd28,%eax
    121c:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
    1222:	52                   	push   %edx
    1223:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
    1229:	52                   	push   %edx
    122a:	50                   	push   %eax
    122b:	68 10 f8 01 00       	push   $0x1f810
    1230:	e8 12 13 00 00       	call   2547 <read24BitmapFile>
    1235:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(heroplane, plane,&h,&w);
    1238:	a1 30 fe 01 00       	mov    0x1fe30,%eax
    123d:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
    1243:	52                   	push   %edx
    1244:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
    124a:	52                   	push   %edx
    124b:	50                   	push   %eax
    124c:	68 20 f8 01 00       	push   $0x1f820
    1251:	e8 f1 12 00 00       	call   2547 <read24BitmapFile>
    1256:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(bigplane, bigEnemy, &h, &w);
    1259:	a1 60 fe 01 00       	mov    0x1fe60,%eax
    125e:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
    1264:	52                   	push   %edx
    1265:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
    126b:	52                   	push   %edx
    126c:	50                   	push   %eax
    126d:	68 2c f8 01 00       	push   $0x1f82c
    1272:	e8 d0 12 00 00       	call   2547 <read24BitmapFile>
    1277:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(middleplane, middleEnemy, &h, &w);
    127a:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
    127f:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
    1285:	52                   	push   %edx
    1286:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
    128c:	52                   	push   %edx
    128d:	50                   	push   %eax
    128e:	68 3c f8 01 00       	push   $0x1f83c
    1293:	e8 af 12 00 00       	call   2547 <read24BitmapFile>
    1298:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(smallplane, smallEnemy, &h, &w);
    129b:	a1 70 fe 01 00       	mov    0x1fe70,%eax
    12a0:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
    12a6:	52                   	push   %edx
    12a7:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
    12ad:	52                   	push   %edx
    12ae:	50                   	push   %eax
    12af:	68 50 f8 01 00       	push   $0x1f850
    12b4:	e8 8e 12 00 00       	call   2547 <read24BitmapFile>
    12b9:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(bullet, bullet1, &h, &w);
    12bc:	a1 24 fd 01 00       	mov    0x1fd24,%eax
    12c1:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
    12c7:	52                   	push   %edx
    12c8:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
    12ce:	52                   	push   %edx
    12cf:	50                   	push   %eax
    12d0:	68 60 f8 01 00       	push   $0x1f860
    12d5:	e8 6d 12 00 00       	call   2547 <read24BitmapFile>
    12da:	83 c4 10             	add    $0x10,%esp
    api_paint24BitmapToContentTransparent(&wnd, background, (Point){0,0},(Point){0,0},(Size){1600,480},(Size){500,480});
    12dd:	c7 85 f8 fe ff ff f4 	movl   $0x1f4,-0x108(%ebp)
    12e4:	01 00 00 
    12e7:	c7 85 fc fe ff ff e0 	movl   $0x1e0,-0x104(%ebp)
    12ee:	01 00 00 
    12f1:	c7 85 00 ff ff ff 40 	movl   $0x640,-0x100(%ebp)
    12f8:	06 00 00 
    12fb:	c7 85 04 ff ff ff e0 	movl   $0x1e0,-0xfc(%ebp)
    1302:	01 00 00 
    1305:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
    130c:	00 00 00 
    130f:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
    1316:	00 00 00 
    1319:	c7 85 10 ff ff ff 00 	movl   $0x0,-0xf0(%ebp)
    1320:	00 00 00 
    1323:	c7 85 14 ff ff ff 00 	movl   $0x0,-0xec(%ebp)
    132a:	00 00 00 
    132d:	a1 28 fd 01 00       	mov    0x1fd28,%eax
    1332:	83 ec 08             	sub    $0x8,%esp
    1335:	ff b5 fc fe ff ff    	pushl  -0x104(%ebp)
    133b:	ff b5 f8 fe ff ff    	pushl  -0x108(%ebp)
    1341:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
    1347:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
    134d:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    1353:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
    1359:	ff b5 14 ff ff ff    	pushl  -0xec(%ebp)
    135f:	ff b5 10 ff ff ff    	pushl  -0xf0(%ebp)
    1365:	50                   	push   %eax
    1366:	68 40 fe 01 00       	push   $0x1fe40
    136b:	e8 54 16 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    1370:	83 c4 30             	add    $0x30,%esp
    api_paint24BitmapToContentTransparent(&wnd, plane, (Point){plane_x,plane_y}, (Point){0,0}, (Size){273,PLANE_WIDTH},(Size){PLANE_HEIGHT,PLANE_WIDTH});
    1373:	c7 85 18 ff ff ff 2f 	movl   $0x2f,-0xe8(%ebp)
    137a:	00 00 00 
    137d:	c7 85 1c ff ff ff 2d 	movl   $0x2d,-0xe4(%ebp)
    1384:	00 00 00 
    1387:	c7 85 20 ff ff ff 11 	movl   $0x111,-0xe0(%ebp)
    138e:	01 00 00 
    1391:	c7 85 24 ff ff ff 2d 	movl   $0x2d,-0xdc(%ebp)
    1398:	00 00 00 
    139b:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
    13a2:	00 00 00 
    13a5:	c7 85 2c ff ff ff 00 	movl   $0x0,-0xd4(%ebp)
    13ac:	00 00 00 
    13af:	a1 20 fd 01 00       	mov    0x1fd20,%eax
    13b4:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
    13ba:	a1 68 fe 01 00       	mov    0x1fe68,%eax
    13bf:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
    13c5:	a1 30 fe 01 00       	mov    0x1fe30,%eax
    13ca:	83 ec 08             	sub    $0x8,%esp
    13cd:	ff b5 1c ff ff ff    	pushl  -0xe4(%ebp)
    13d3:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
    13d9:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
    13df:	ff b5 20 ff ff ff    	pushl  -0xe0(%ebp)
    13e5:	ff b5 2c ff ff ff    	pushl  -0xd4(%ebp)
    13eb:	ff b5 28 ff ff ff    	pushl  -0xd8(%ebp)
    13f1:	ff b5 34 ff ff ff    	pushl  -0xcc(%ebp)
    13f7:	ff b5 30 ff ff ff    	pushl  -0xd0(%ebp)
    13fd:	50                   	push   %eax
    13fe:	68 40 fe 01 00       	push   $0x1fe40
    1403:	e8 bc 15 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    1408:	83 c4 30             	add    $0x30,%esp
    api_paint24BitmapToContentTransparent(&wnd, bigEnemy, (Point){0,0}, (Point){0,enemy_status[0]*enemyHeight[0]},(Size){401,64},(Size){enemyHeight[0],enemyWidth[0]});
    140b:	a1 84 f8 01 00       	mov    0x1f884,%eax
    1410:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
    1416:	a1 6c f8 01 00       	mov    0x1f86c,%eax
    141b:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
    1421:	c7 85 40 ff ff ff 91 	movl   $0x191,-0xc0(%ebp)
    1428:	01 00 00 
    142b:	c7 85 44 ff ff ff 40 	movl   $0x40,-0xbc(%ebp)
    1432:	00 00 00 
    1435:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%ebp)
    143c:	00 00 00 
    143f:	8b 15 f0 fc 01 00    	mov    0x1fcf0,%edx
    1445:	a1 84 f8 01 00       	mov    0x1f884,%eax
    144a:	0f af c2             	imul   %edx,%eax
    144d:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
    1453:	c7 85 50 ff ff ff 00 	movl   $0x0,-0xb0(%ebp)
    145a:	00 00 00 
    145d:	c7 85 54 ff ff ff 00 	movl   $0x0,-0xac(%ebp)
    1464:	00 00 00 
    1467:	a1 60 fe 01 00       	mov    0x1fe60,%eax
    146c:	83 ec 08             	sub    $0x8,%esp
    146f:	ff b5 3c ff ff ff    	pushl  -0xc4(%ebp)
    1475:	ff b5 38 ff ff ff    	pushl  -0xc8(%ebp)
    147b:	ff b5 44 ff ff ff    	pushl  -0xbc(%ebp)
    1481:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
    1487:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
    148d:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
    1493:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
    1499:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
    149f:	50                   	push   %eax
    14a0:	68 40 fe 01 00       	push   $0x1fe40
    14a5:	e8 1a 15 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    14aa:	83 c4 30             	add    $0x30,%esp
    api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){50,0}, (Point){0,enemy_status[1]*enemyHeight[1]},(Size){311,46},(Size){enemyHeight[1],enemyWidth[1]});
    14ad:	a1 88 f8 01 00       	mov    0x1f888,%eax
    14b2:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
    14b8:	a1 70 f8 01 00       	mov    0x1f870,%eax
    14bd:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
    14c3:	c7 85 60 ff ff ff 37 	movl   $0x137,-0xa0(%ebp)
    14ca:	01 00 00 
    14cd:	c7 85 64 ff ff ff 2e 	movl   $0x2e,-0x9c(%ebp)
    14d4:	00 00 00 
    14d7:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
    14de:	00 00 00 
    14e1:	8b 15 f4 fc 01 00    	mov    0x1fcf4,%edx
    14e7:	a1 88 f8 01 00       	mov    0x1f888,%eax
    14ec:	0f af c2             	imul   %edx,%eax
    14ef:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
    14f5:	c7 85 70 ff ff ff 32 	movl   $0x32,-0x90(%ebp)
    14fc:	00 00 00 
    14ff:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
    1506:	00 00 00 
    1509:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
    150e:	83 ec 08             	sub    $0x8,%esp
    1511:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
    1517:	ff b5 58 ff ff ff    	pushl  -0xa8(%ebp)
    151d:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
    1523:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
    1529:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    152f:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    1535:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
    153b:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
    1541:	50                   	push   %eax
    1542:	68 40 fe 01 00       	push   $0x1fe40
    1547:	e8 78 14 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    154c:	83 c4 30             	add    $0x30,%esp
    api_paint24BitmapToContentTransparent(&wnd, middleEnemy, (Point){100,20}, (Point){0,enemy_status[2]*enemyHeight[2]},(Size){311,46},(Size){enemyHeight[2],enemyWidth[2]});
    154f:	a1 8c f8 01 00       	mov    0x1f88c,%eax
    1554:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
    155a:	a1 74 f8 01 00       	mov    0x1f874,%eax
    155f:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
    1565:	c7 45 80 37 01 00 00 	movl   $0x137,-0x80(%ebp)
    156c:	c7 45 84 2e 00 00 00 	movl   $0x2e,-0x7c(%ebp)
    1573:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
    157a:	8b 15 f8 fc 01 00    	mov    0x1fcf8,%edx
    1580:	a1 8c f8 01 00       	mov    0x1f88c,%eax
    1585:	0f af c2             	imul   %edx,%eax
    1588:	89 45 8c             	mov    %eax,-0x74(%ebp)
    158b:	c7 45 90 64 00 00 00 	movl   $0x64,-0x70(%ebp)
    1592:	c7 45 94 14 00 00 00 	movl   $0x14,-0x6c(%ebp)
    1599:	a1 6c fe 01 00       	mov    0x1fe6c,%eax
    159e:	83 ec 08             	sub    $0x8,%esp
    15a1:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
    15a7:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
    15ad:	ff 75 84             	pushl  -0x7c(%ebp)
    15b0:	ff 75 80             	pushl  -0x80(%ebp)
    15b3:	ff 75 8c             	pushl  -0x74(%ebp)
    15b6:	ff 75 88             	pushl  -0x78(%ebp)
    15b9:	ff 75 94             	pushl  -0x6c(%ebp)
    15bc:	ff 75 90             	pushl  -0x70(%ebp)
    15bf:	50                   	push   %eax
    15c0:	68 40 fe 01 00       	push   $0x1fe40
    15c5:	e8 fa 13 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    15ca:	83 c4 30             	add    $0x30,%esp
    api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){150,40}, (Point){0,enemy_status[3]*enemyHeight[3]},(Size){340,45},(Size){enemyHeight[3],enemyWidth[3]});
    15cd:	a1 90 f8 01 00       	mov    0x1f890,%eax
    15d2:	89 45 98             	mov    %eax,-0x68(%ebp)
    15d5:	a1 78 f8 01 00       	mov    0x1f878,%eax
    15da:	89 45 9c             	mov    %eax,-0x64(%ebp)
    15dd:	c7 45 a0 54 01 00 00 	movl   $0x154,-0x60(%ebp)
    15e4:	c7 45 a4 2d 00 00 00 	movl   $0x2d,-0x5c(%ebp)
    15eb:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
    15f2:	8b 15 fc fc 01 00    	mov    0x1fcfc,%edx
    15f8:	a1 90 f8 01 00       	mov    0x1f890,%eax
    15fd:	0f af c2             	imul   %edx,%eax
    1600:	89 45 ac             	mov    %eax,-0x54(%ebp)
    1603:	c7 45 b0 96 00 00 00 	movl   $0x96,-0x50(%ebp)
    160a:	c7 45 b4 28 00 00 00 	movl   $0x28,-0x4c(%ebp)
    1611:	a1 70 fe 01 00       	mov    0x1fe70,%eax
    1616:	83 ec 08             	sub    $0x8,%esp
    1619:	ff 75 9c             	pushl  -0x64(%ebp)
    161c:	ff 75 98             	pushl  -0x68(%ebp)
    161f:	ff 75 a4             	pushl  -0x5c(%ebp)
    1622:	ff 75 a0             	pushl  -0x60(%ebp)
    1625:	ff 75 ac             	pushl  -0x54(%ebp)
    1628:	ff 75 a8             	pushl  -0x58(%ebp)
    162b:	ff 75 b4             	pushl  -0x4c(%ebp)
    162e:	ff 75 b0             	pushl  -0x50(%ebp)
    1631:	50                   	push   %eax
    1632:	68 40 fe 01 00       	push   $0x1fe40
    1637:	e8 88 13 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    163c:	83 c4 30             	add    $0x30,%esp
    api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){200,20}, (Point){0,enemy_status[4]*enemyHeight[4]},(Size){340,45},(Size){enemyHeight[4],enemyWidth[4]});
    163f:	a1 94 f8 01 00       	mov    0x1f894,%eax
    1644:	89 45 b8             	mov    %eax,-0x48(%ebp)
    1647:	a1 7c f8 01 00       	mov    0x1f87c,%eax
    164c:	89 45 bc             	mov    %eax,-0x44(%ebp)
    164f:	c7 45 c0 54 01 00 00 	movl   $0x154,-0x40(%ebp)
    1656:	c7 45 c4 2d 00 00 00 	movl   $0x2d,-0x3c(%ebp)
    165d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    1664:	8b 15 00 fd 01 00    	mov    0x1fd00,%edx
    166a:	a1 94 f8 01 00       	mov    0x1f894,%eax
    166f:	0f af c2             	imul   %edx,%eax
    1672:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1675:	c7 45 d0 c8 00 00 00 	movl   $0xc8,-0x30(%ebp)
    167c:	c7 45 d4 14 00 00 00 	movl   $0x14,-0x2c(%ebp)
    1683:	a1 70 fe 01 00       	mov    0x1fe70,%eax
    1688:	83 ec 08             	sub    $0x8,%esp
    168b:	ff 75 bc             	pushl  -0x44(%ebp)
    168e:	ff 75 b8             	pushl  -0x48(%ebp)
    1691:	ff 75 c4             	pushl  -0x3c(%ebp)
    1694:	ff 75 c0             	pushl  -0x40(%ebp)
    1697:	ff 75 cc             	pushl  -0x34(%ebp)
    169a:	ff 75 c8             	pushl  -0x38(%ebp)
    169d:	ff 75 d4             	pushl  -0x2c(%ebp)
    16a0:	ff 75 d0             	pushl  -0x30(%ebp)
    16a3:	50                   	push   %eax
    16a4:	68 40 fe 01 00       	push   $0x1fe40
    16a9:	e8 16 13 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    16ae:	83 c4 30             	add    $0x30,%esp
    api_paint24BitmapToContentTransparent(&wnd, smallEnemy, (Point){250,40}, (Point){0,enemy_status[5]*enemyHeight[5]},(Size){340,45},(Size){enemyHeight[5],enemyWidth[5]});
    16b1:	a1 98 f8 01 00       	mov    0x1f898,%eax
    16b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    16b9:	a1 80 f8 01 00       	mov    0x1f880,%eax
    16be:	89 45 dc             	mov    %eax,-0x24(%ebp)
    16c1:	c7 45 e0 54 01 00 00 	movl   $0x154,-0x20(%ebp)
    16c8:	c7 45 e4 2d 00 00 00 	movl   $0x2d,-0x1c(%ebp)
    16cf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    16d6:	8b 15 04 fd 01 00    	mov    0x1fd04,%edx
    16dc:	a1 98 f8 01 00       	mov    0x1f898,%eax
    16e1:	0f af c2             	imul   %edx,%eax
    16e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    16e7:	c7 45 f0 fa 00 00 00 	movl   $0xfa,-0x10(%ebp)
    16ee:	c7 45 f4 28 00 00 00 	movl   $0x28,-0xc(%ebp)
    16f5:	a1 70 fe 01 00       	mov    0x1fe70,%eax
    16fa:	83 ec 08             	sub    $0x8,%esp
    16fd:	ff 75 dc             	pushl  -0x24(%ebp)
    1700:	ff 75 d8             	pushl  -0x28(%ebp)
    1703:	ff 75 e4             	pushl  -0x1c(%ebp)
    1706:	ff 75 e0             	pushl  -0x20(%ebp)
    1709:	ff 75 ec             	pushl  -0x14(%ebp)
    170c:	ff 75 e8             	pushl  -0x18(%ebp)
    170f:	ff 75 f4             	pushl  -0xc(%ebp)
    1712:	ff 75 f0             	pushl  -0x10(%ebp)
    1715:	50                   	push   %eax
    1716:	68 40 fe 01 00       	push   $0x1fe40
    171b:	e8 a4 12 00 00       	call   29c4 <api_paint24BitmapToContentTransparent>
    1720:	83 c4 30             	add    $0x30,%esp
    api_repaint(&wnd);
    1723:	83 ec 0c             	sub    $0xc,%esp
    1726:	68 40 fe 01 00       	push   $0x1fe40
    172b:	e8 d4 12 00 00       	call   2a04 <api_repaint>
    1730:	83 c4 10             	add    $0x10,%esp
    api_settimer(&wnd, 50);
    1733:	83 ec 08             	sub    $0x8,%esp
    1736:	6a 32                	push   $0x32
    1738:	68 40 fe 01 00       	push   $0x1fe40
    173d:	e8 4e 13 00 00       	call   2a90 <api_settimer>
    1742:	83 c4 10             	add    $0x10,%esp
    api_exec(&wnd,&MsgProc);
    1745:	83 ec 08             	sub    $0x8,%esp
    1748:	68 00 00 00 00       	push   $0x0
    174d:	68 40 fe 01 00       	push   $0x1fe40
    1752:	e8 fd 12 00 00       	call   2a54 <api_exec>
    1757:	83 c4 10             	add    $0x10,%esp
    return 0;
    175a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    175f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    1762:	c9                   	leave  
    1763:	8d 61 fc             	lea    -0x4(%ecx),%esp
    1766:	c3                   	ret    

00001767 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
    1767:	55                   	push   %ebp
    1768:	89 e5                	mov    %esp,%ebp
    176a:	57                   	push   %edi
    176b:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
    176c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    176f:	8b 55 10             	mov    0x10(%ebp),%edx
    1772:	8b 45 0c             	mov    0xc(%ebp),%eax
    1775:	89 cb                	mov    %ecx,%ebx
    1777:	89 df                	mov    %ebx,%edi
    1779:	89 d1                	mov    %edx,%ecx
    177b:	fc                   	cld    
    177c:	f3 aa                	rep stos %al,%es:(%edi)
    177e:	89 ca                	mov    %ecx,%edx
    1780:	89 fb                	mov    %edi,%ebx
    1782:	89 5d 08             	mov    %ebx,0x8(%ebp)
    1785:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
    1788:	90                   	nop
    1789:	5b                   	pop    %ebx
    178a:	5f                   	pop    %edi
    178b:	5d                   	pop    %ebp
    178c:	c3                   	ret    

0000178d <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
    178d:	55                   	push   %ebp
    178e:	89 e5                	mov    %esp,%ebp
    1790:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
    1793:	8b 45 08             	mov    0x8(%ebp),%eax
    1796:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
    1799:	90                   	nop
    179a:	8b 45 08             	mov    0x8(%ebp),%eax
    179d:	8d 50 01             	lea    0x1(%eax),%edx
    17a0:	89 55 08             	mov    %edx,0x8(%ebp)
    17a3:	8b 55 0c             	mov    0xc(%ebp),%edx
    17a6:	8d 4a 01             	lea    0x1(%edx),%ecx
    17a9:	89 4d 0c             	mov    %ecx,0xc(%ebp)
    17ac:	0f b6 12             	movzbl (%edx),%edx
    17af:	88 10                	mov    %dl,(%eax)
    17b1:	0f b6 00             	movzbl (%eax),%eax
    17b4:	84 c0                	test   %al,%al
    17b6:	75 e2                	jne    179a <strcpy+0xd>
    ;
  return os;
    17b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    17bb:	c9                   	leave  
    17bc:	c3                   	ret    

000017bd <strcmp>:

int
strcmp(const char *p, const char *q)
{
    17bd:	55                   	push   %ebp
    17be:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
    17c0:	eb 08                	jmp    17ca <strcmp+0xd>
    p++, q++;
    17c2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    17c6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
    17ca:	8b 45 08             	mov    0x8(%ebp),%eax
    17cd:	0f b6 00             	movzbl (%eax),%eax
    17d0:	84 c0                	test   %al,%al
    17d2:	74 10                	je     17e4 <strcmp+0x27>
    17d4:	8b 45 08             	mov    0x8(%ebp),%eax
    17d7:	0f b6 10             	movzbl (%eax),%edx
    17da:	8b 45 0c             	mov    0xc(%ebp),%eax
    17dd:	0f b6 00             	movzbl (%eax),%eax
    17e0:	38 c2                	cmp    %al,%dl
    17e2:	74 de                	je     17c2 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
    17e4:	8b 45 08             	mov    0x8(%ebp),%eax
    17e7:	0f b6 00             	movzbl (%eax),%eax
    17ea:	0f b6 d0             	movzbl %al,%edx
    17ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    17f0:	0f b6 00             	movzbl (%eax),%eax
    17f3:	0f b6 c0             	movzbl %al,%eax
    17f6:	29 c2                	sub    %eax,%edx
    17f8:	89 d0                	mov    %edx,%eax
}
    17fa:	5d                   	pop    %ebp
    17fb:	c3                   	ret    

000017fc <strlen>:

uint
strlen(char *s)
{
    17fc:	55                   	push   %ebp
    17fd:	89 e5                	mov    %esp,%ebp
    17ff:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
    1802:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1809:	eb 04                	jmp    180f <strlen+0x13>
    180b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    180f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1812:	8b 45 08             	mov    0x8(%ebp),%eax
    1815:	01 d0                	add    %edx,%eax
    1817:	0f b6 00             	movzbl (%eax),%eax
    181a:	84 c0                	test   %al,%al
    181c:	75 ed                	jne    180b <strlen+0xf>
    ;
  return n;
    181e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    1821:	c9                   	leave  
    1822:	c3                   	ret    

00001823 <memset>:

void*
memset(void *dst, int c, uint n)
{
    1823:	55                   	push   %ebp
    1824:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
    1826:	8b 45 10             	mov    0x10(%ebp),%eax
    1829:	50                   	push   %eax
    182a:	ff 75 0c             	pushl  0xc(%ebp)
    182d:	ff 75 08             	pushl  0x8(%ebp)
    1830:	e8 32 ff ff ff       	call   1767 <stosb>
    1835:	83 c4 0c             	add    $0xc,%esp
  return dst;
    1838:	8b 45 08             	mov    0x8(%ebp),%eax
}
    183b:	c9                   	leave  
    183c:	c3                   	ret    

0000183d <strchr>:

char*
strchr(const char *s, char c)
{
    183d:	55                   	push   %ebp
    183e:	89 e5                	mov    %esp,%ebp
    1840:	83 ec 04             	sub    $0x4,%esp
    1843:	8b 45 0c             	mov    0xc(%ebp),%eax
    1846:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
    1849:	eb 14                	jmp    185f <strchr+0x22>
    if(*s == c)
    184b:	8b 45 08             	mov    0x8(%ebp),%eax
    184e:	0f b6 00             	movzbl (%eax),%eax
    1851:	3a 45 fc             	cmp    -0x4(%ebp),%al
    1854:	75 05                	jne    185b <strchr+0x1e>
      return (char*)s;
    1856:	8b 45 08             	mov    0x8(%ebp),%eax
    1859:	eb 13                	jmp    186e <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
    185b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    185f:	8b 45 08             	mov    0x8(%ebp),%eax
    1862:	0f b6 00             	movzbl (%eax),%eax
    1865:	84 c0                	test   %al,%al
    1867:	75 e2                	jne    184b <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
    1869:	b8 00 00 00 00       	mov    $0x0,%eax
}
    186e:	c9                   	leave  
    186f:	c3                   	ret    

00001870 <gets>:

char*
gets(char *buf, int max)
{
    1870:	55                   	push   %ebp
    1871:	89 e5                	mov    %esp,%ebp
    1873:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    1876:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    187d:	eb 42                	jmp    18c1 <gets+0x51>
    cc = read(0, &c, 1);
    187f:	83 ec 04             	sub    $0x4,%esp
    1882:	6a 01                	push   $0x1
    1884:	8d 45 ef             	lea    -0x11(%ebp),%eax
    1887:	50                   	push   %eax
    1888:	6a 00                	push   $0x0
    188a:	e8 47 01 00 00       	call   19d6 <read>
    188f:	83 c4 10             	add    $0x10,%esp
    1892:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
    1895:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    1899:	7e 33                	jle    18ce <gets+0x5e>
      break;
    buf[i++] = c;
    189b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    189e:	8d 50 01             	lea    0x1(%eax),%edx
    18a1:	89 55 f4             	mov    %edx,-0xc(%ebp)
    18a4:	89 c2                	mov    %eax,%edx
    18a6:	8b 45 08             	mov    0x8(%ebp),%eax
    18a9:	01 c2                	add    %eax,%edx
    18ab:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    18af:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
    18b1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    18b5:	3c 0a                	cmp    $0xa,%al
    18b7:	74 16                	je     18cf <gets+0x5f>
    18b9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    18bd:	3c 0d                	cmp    $0xd,%al
    18bf:	74 0e                	je     18cf <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    18c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18c4:	83 c0 01             	add    $0x1,%eax
    18c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    18ca:	7c b3                	jl     187f <gets+0xf>
    18cc:	eb 01                	jmp    18cf <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
    18ce:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
    18cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    18d2:	8b 45 08             	mov    0x8(%ebp),%eax
    18d5:	01 d0                	add    %edx,%eax
    18d7:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
    18da:	8b 45 08             	mov    0x8(%ebp),%eax
}
    18dd:	c9                   	leave  
    18de:	c3                   	ret    

000018df <stat>:

int
stat(char *n, struct stat *st)
{
    18df:	55                   	push   %ebp
    18e0:	89 e5                	mov    %esp,%ebp
    18e2:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
    18e5:	83 ec 08             	sub    $0x8,%esp
    18e8:	6a 00                	push   $0x0
    18ea:	ff 75 08             	pushl  0x8(%ebp)
    18ed:	e8 0c 01 00 00       	call   19fe <open>
    18f2:	83 c4 10             	add    $0x10,%esp
    18f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
    18f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    18fc:	79 07                	jns    1905 <stat+0x26>
    return -1;
    18fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1903:	eb 25                	jmp    192a <stat+0x4b>
  r = fstat(fd, st);
    1905:	83 ec 08             	sub    $0x8,%esp
    1908:	ff 75 0c             	pushl  0xc(%ebp)
    190b:	ff 75 f4             	pushl  -0xc(%ebp)
    190e:	e8 03 01 00 00       	call   1a16 <fstat>
    1913:	83 c4 10             	add    $0x10,%esp
    1916:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
    1919:	83 ec 0c             	sub    $0xc,%esp
    191c:	ff 75 f4             	pushl  -0xc(%ebp)
    191f:	e8 c2 00 00 00       	call   19e6 <close>
    1924:	83 c4 10             	add    $0x10,%esp
  return r;
    1927:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    192a:	c9                   	leave  
    192b:	c3                   	ret    

0000192c <atoi>:

int
atoi(const char *s)
{
    192c:	55                   	push   %ebp
    192d:	89 e5                	mov    %esp,%ebp
    192f:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
    1932:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
    1939:	eb 25                	jmp    1960 <atoi+0x34>
    n = n*10 + *s++ - '0';
    193b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    193e:	89 d0                	mov    %edx,%eax
    1940:	c1 e0 02             	shl    $0x2,%eax
    1943:	01 d0                	add    %edx,%eax
    1945:	01 c0                	add    %eax,%eax
    1947:	89 c1                	mov    %eax,%ecx
    1949:	8b 45 08             	mov    0x8(%ebp),%eax
    194c:	8d 50 01             	lea    0x1(%eax),%edx
    194f:	89 55 08             	mov    %edx,0x8(%ebp)
    1952:	0f b6 00             	movzbl (%eax),%eax
    1955:	0f be c0             	movsbl %al,%eax
    1958:	01 c8                	add    %ecx,%eax
    195a:	83 e8 30             	sub    $0x30,%eax
    195d:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
    1960:	8b 45 08             	mov    0x8(%ebp),%eax
    1963:	0f b6 00             	movzbl (%eax),%eax
    1966:	3c 2f                	cmp    $0x2f,%al
    1968:	7e 0a                	jle    1974 <atoi+0x48>
    196a:	8b 45 08             	mov    0x8(%ebp),%eax
    196d:	0f b6 00             	movzbl (%eax),%eax
    1970:	3c 39                	cmp    $0x39,%al
    1972:	7e c7                	jle    193b <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
    1974:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    1977:	c9                   	leave  
    1978:	c3                   	ret    

00001979 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
    1979:	55                   	push   %ebp
    197a:	89 e5                	mov    %esp,%ebp
    197c:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
    197f:	8b 45 08             	mov    0x8(%ebp),%eax
    1982:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
    1985:	8b 45 0c             	mov    0xc(%ebp),%eax
    1988:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
    198b:	eb 17                	jmp    19a4 <memmove+0x2b>
    *dst++ = *src++;
    198d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1990:	8d 50 01             	lea    0x1(%eax),%edx
    1993:	89 55 fc             	mov    %edx,-0x4(%ebp)
    1996:	8b 55 f8             	mov    -0x8(%ebp),%edx
    1999:	8d 4a 01             	lea    0x1(%edx),%ecx
    199c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
    199f:	0f b6 12             	movzbl (%edx),%edx
    19a2:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
    19a4:	8b 45 10             	mov    0x10(%ebp),%eax
    19a7:	8d 50 ff             	lea    -0x1(%eax),%edx
    19aa:	89 55 10             	mov    %edx,0x10(%ebp)
    19ad:	85 c0                	test   %eax,%eax
    19af:	7f dc                	jg     198d <memmove+0x14>
    *dst++ = *src++;
  return vdst;
    19b1:	8b 45 08             	mov    0x8(%ebp),%eax
}
    19b4:	c9                   	leave  
    19b5:	c3                   	ret    

000019b6 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
    19b6:	b8 01 00 00 00       	mov    $0x1,%eax
    19bb:	cd 40                	int    $0x40
    19bd:	c3                   	ret    

000019be <exit>:
SYSCALL(exit)
    19be:	b8 02 00 00 00       	mov    $0x2,%eax
    19c3:	cd 40                	int    $0x40
    19c5:	c3                   	ret    

000019c6 <wait>:
SYSCALL(wait)
    19c6:	b8 03 00 00 00       	mov    $0x3,%eax
    19cb:	cd 40                	int    $0x40
    19cd:	c3                   	ret    

000019ce <pipe>:
SYSCALL(pipe)
    19ce:	b8 04 00 00 00       	mov    $0x4,%eax
    19d3:	cd 40                	int    $0x40
    19d5:	c3                   	ret    

000019d6 <read>:
SYSCALL(read)
    19d6:	b8 05 00 00 00       	mov    $0x5,%eax
    19db:	cd 40                	int    $0x40
    19dd:	c3                   	ret    

000019de <write>:
SYSCALL(write)
    19de:	b8 10 00 00 00       	mov    $0x10,%eax
    19e3:	cd 40                	int    $0x40
    19e5:	c3                   	ret    

000019e6 <close>:
SYSCALL(close)
    19e6:	b8 15 00 00 00       	mov    $0x15,%eax
    19eb:	cd 40                	int    $0x40
    19ed:	c3                   	ret    

000019ee <kill>:
SYSCALL(kill)
    19ee:	b8 06 00 00 00       	mov    $0x6,%eax
    19f3:	cd 40                	int    $0x40
    19f5:	c3                   	ret    

000019f6 <exec>:
SYSCALL(exec)
    19f6:	b8 07 00 00 00       	mov    $0x7,%eax
    19fb:	cd 40                	int    $0x40
    19fd:	c3                   	ret    

000019fe <open>:
SYSCALL(open)
    19fe:	b8 0f 00 00 00       	mov    $0xf,%eax
    1a03:	cd 40                	int    $0x40
    1a05:	c3                   	ret    

00001a06 <mknod>:
SYSCALL(mknod)
    1a06:	b8 11 00 00 00       	mov    $0x11,%eax
    1a0b:	cd 40                	int    $0x40
    1a0d:	c3                   	ret    

00001a0e <unlink>:
SYSCALL(unlink)
    1a0e:	b8 12 00 00 00       	mov    $0x12,%eax
    1a13:	cd 40                	int    $0x40
    1a15:	c3                   	ret    

00001a16 <fstat>:
SYSCALL(fstat)
    1a16:	b8 08 00 00 00       	mov    $0x8,%eax
    1a1b:	cd 40                	int    $0x40
    1a1d:	c3                   	ret    

00001a1e <link>:
SYSCALL(link)
    1a1e:	b8 13 00 00 00       	mov    $0x13,%eax
    1a23:	cd 40                	int    $0x40
    1a25:	c3                   	ret    

00001a26 <mkdir>:
SYSCALL(mkdir)
    1a26:	b8 14 00 00 00       	mov    $0x14,%eax
    1a2b:	cd 40                	int    $0x40
    1a2d:	c3                   	ret    

00001a2e <chdir>:
SYSCALL(chdir)
    1a2e:	b8 09 00 00 00       	mov    $0x9,%eax
    1a33:	cd 40                	int    $0x40
    1a35:	c3                   	ret    

00001a36 <dup>:
SYSCALL(dup)
    1a36:	b8 0a 00 00 00       	mov    $0xa,%eax
    1a3b:	cd 40                	int    $0x40
    1a3d:	c3                   	ret    

00001a3e <getpid>:
SYSCALL(getpid)
    1a3e:	b8 0b 00 00 00       	mov    $0xb,%eax
    1a43:	cd 40                	int    $0x40
    1a45:	c3                   	ret    

00001a46 <sbrk>:
SYSCALL(sbrk)
    1a46:	b8 0c 00 00 00       	mov    $0xc,%eax
    1a4b:	cd 40                	int    $0x40
    1a4d:	c3                   	ret    

00001a4e <sleep>:
SYSCALL(sleep)
    1a4e:	b8 0d 00 00 00       	mov    $0xd,%eax
    1a53:	cd 40                	int    $0x40
    1a55:	c3                   	ret    

00001a56 <uptime>:
SYSCALL(uptime)
    1a56:	b8 0e 00 00 00       	mov    $0xe,%eax
    1a5b:	cd 40                	int    $0x40
    1a5d:	c3                   	ret    

00001a5e <createwindow>:
SYSCALL(createwindow)
    1a5e:	b8 16 00 00 00       	mov    $0x16,%eax
    1a63:	cd 40                	int    $0x40
    1a65:	c3                   	ret    

00001a66 <repaintwindow>:
SYSCALL(repaintwindow)
    1a66:	b8 17 00 00 00       	mov    $0x17,%eax
    1a6b:	cd 40                	int    $0x40
    1a6d:	c3                   	ret    

00001a6e <getmessage>:
SYSCALL(getmessage)
    1a6e:	b8 18 00 00 00       	mov    $0x18,%eax
    1a73:	cd 40                	int    $0x40
    1a75:	c3                   	ret    

00001a76 <settimer>:
SYSCALL(settimer)
    1a76:	b8 19 00 00 00       	mov    $0x19,%eax
    1a7b:	cd 40                	int    $0x40
    1a7d:	c3                   	ret    

00001a7e <updatewindow>:
SYSCALL(updatewindow)
    1a7e:	b8 1a 00 00 00       	mov    $0x1a,%eax
    1a83:	cd 40                	int    $0x40
    1a85:	c3                   	ret    

00001a86 <destroywindow>:
SYSCALL(destroywindow)
    1a86:	b8 1b 00 00 00       	mov    $0x1b,%eax
    1a8b:	cd 40                	int    $0x40
    1a8d:	c3                   	ret    

00001a8e <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
    1a8e:	55                   	push   %ebp
    1a8f:	89 e5                	mov    %esp,%ebp
    1a91:	83 ec 18             	sub    $0x18,%esp
    1a94:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a97:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
    1a9a:	83 ec 04             	sub    $0x4,%esp
    1a9d:	6a 01                	push   $0x1
    1a9f:	8d 45 f4             	lea    -0xc(%ebp),%eax
    1aa2:	50                   	push   %eax
    1aa3:	ff 75 08             	pushl  0x8(%ebp)
    1aa6:	e8 33 ff ff ff       	call   19de <write>
    1aab:	83 c4 10             	add    $0x10,%esp
}
    1aae:	90                   	nop
    1aaf:	c9                   	leave  
    1ab0:	c3                   	ret    

00001ab1 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
    1ab1:	55                   	push   %ebp
    1ab2:	89 e5                	mov    %esp,%ebp
    1ab4:	53                   	push   %ebx
    1ab5:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
    1ab8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
    1abf:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    1ac3:	74 17                	je     1adc <printint+0x2b>
    1ac5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1ac9:	79 11                	jns    1adc <printint+0x2b>
    neg = 1;
    1acb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
    1ad2:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ad5:	f7 d8                	neg    %eax
    1ad7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1ada:	eb 06                	jmp    1ae2 <printint+0x31>
  } else {
    x = xx;
    1adc:	8b 45 0c             	mov    0xc(%ebp),%eax
    1adf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
    1ae2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
    1ae9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1aec:	8d 41 01             	lea    0x1(%ecx),%eax
    1aef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1af2:	8b 5d 10             	mov    0x10(%ebp),%ebx
    1af5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1af8:	ba 00 00 00 00       	mov    $0x0,%edx
    1afd:	f7 f3                	div    %ebx
    1aff:	89 d0                	mov    %edx,%eax
    1b01:	0f b6 80 9c f8 01 00 	movzbl 0x1f89c(%eax),%eax
    1b08:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
    1b0c:	8b 5d 10             	mov    0x10(%ebp),%ebx
    1b0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b12:	ba 00 00 00 00       	mov    $0x0,%edx
    1b17:	f7 f3                	div    %ebx
    1b19:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1b1c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1b20:	75 c7                	jne    1ae9 <printint+0x38>
  if(neg)
    1b22:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    1b26:	74 2d                	je     1b55 <printint+0xa4>
    buf[i++] = '-';
    1b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1b2b:	8d 50 01             	lea    0x1(%eax),%edx
    1b2e:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1b31:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
    1b36:	eb 1d                	jmp    1b55 <printint+0xa4>
    putc(fd, buf[i]);
    1b38:	8d 55 dc             	lea    -0x24(%ebp),%edx
    1b3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1b3e:	01 d0                	add    %edx,%eax
    1b40:	0f b6 00             	movzbl (%eax),%eax
    1b43:	0f be c0             	movsbl %al,%eax
    1b46:	83 ec 08             	sub    $0x8,%esp
    1b49:	50                   	push   %eax
    1b4a:	ff 75 08             	pushl  0x8(%ebp)
    1b4d:	e8 3c ff ff ff       	call   1a8e <putc>
    1b52:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
    1b55:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1b59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1b5d:	79 d9                	jns    1b38 <printint+0x87>
    putc(fd, buf[i]);
}
    1b5f:	90                   	nop
    1b60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1b63:	c9                   	leave  
    1b64:	c3                   	ret    

00001b65 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
    1b65:	55                   	push   %ebp
    1b66:	89 e5                	mov    %esp,%ebp
    1b68:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
    1b6b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
    1b72:	8d 45 0c             	lea    0xc(%ebp),%eax
    1b75:	83 c0 04             	add    $0x4,%eax
    1b78:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
    1b7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1b82:	e9 59 01 00 00       	jmp    1ce0 <printf+0x17b>
    c = fmt[i] & 0xff;
    1b87:	8b 55 0c             	mov    0xc(%ebp),%edx
    1b8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1b8d:	01 d0                	add    %edx,%eax
    1b8f:	0f b6 00             	movzbl (%eax),%eax
    1b92:	0f be c0             	movsbl %al,%eax
    1b95:	25 ff 00 00 00       	and    $0xff,%eax
    1b9a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
    1b9d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1ba1:	75 2c                	jne    1bcf <printf+0x6a>
      if(c == '%'){
    1ba3:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    1ba7:	75 0c                	jne    1bb5 <printf+0x50>
        state = '%';
    1ba9:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
    1bb0:	e9 27 01 00 00       	jmp    1cdc <printf+0x177>
      } else {
        putc(fd, c);
    1bb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1bb8:	0f be c0             	movsbl %al,%eax
    1bbb:	83 ec 08             	sub    $0x8,%esp
    1bbe:	50                   	push   %eax
    1bbf:	ff 75 08             	pushl  0x8(%ebp)
    1bc2:	e8 c7 fe ff ff       	call   1a8e <putc>
    1bc7:	83 c4 10             	add    $0x10,%esp
    1bca:	e9 0d 01 00 00       	jmp    1cdc <printf+0x177>
      }
    } else if(state == '%'){
    1bcf:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
    1bd3:	0f 85 03 01 00 00    	jne    1cdc <printf+0x177>
      if(c == 'd'){
    1bd9:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
    1bdd:	75 1e                	jne    1bfd <printf+0x98>
        printint(fd, *ap, 10, 1);
    1bdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1be2:	8b 00                	mov    (%eax),%eax
    1be4:	6a 01                	push   $0x1
    1be6:	6a 0a                	push   $0xa
    1be8:	50                   	push   %eax
    1be9:	ff 75 08             	pushl  0x8(%ebp)
    1bec:	e8 c0 fe ff ff       	call   1ab1 <printint>
    1bf1:	83 c4 10             	add    $0x10,%esp
        ap++;
    1bf4:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    1bf8:	e9 d8 00 00 00       	jmp    1cd5 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
    1bfd:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
    1c01:	74 06                	je     1c09 <printf+0xa4>
    1c03:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
    1c07:	75 1e                	jne    1c27 <printf+0xc2>
        printint(fd, *ap, 16, 0);
    1c09:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c0c:	8b 00                	mov    (%eax),%eax
    1c0e:	6a 00                	push   $0x0
    1c10:	6a 10                	push   $0x10
    1c12:	50                   	push   %eax
    1c13:	ff 75 08             	pushl  0x8(%ebp)
    1c16:	e8 96 fe ff ff       	call   1ab1 <printint>
    1c1b:	83 c4 10             	add    $0x10,%esp
        ap++;
    1c1e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    1c22:	e9 ae 00 00 00       	jmp    1cd5 <printf+0x170>
      } else if(c == 's'){
    1c27:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
    1c2b:	75 43                	jne    1c70 <printf+0x10b>
        s = (char*)*ap;
    1c2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c30:	8b 00                	mov    (%eax),%eax
    1c32:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
    1c35:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
    1c39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1c3d:	75 25                	jne    1c64 <printf+0xff>
          s = "(null)";
    1c3f:	c7 45 f4 ca 74 01 00 	movl   $0x174ca,-0xc(%ebp)
        while(*s != 0){
    1c46:	eb 1c                	jmp    1c64 <printf+0xff>
          putc(fd, *s);
    1c48:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c4b:	0f b6 00             	movzbl (%eax),%eax
    1c4e:	0f be c0             	movsbl %al,%eax
    1c51:	83 ec 08             	sub    $0x8,%esp
    1c54:	50                   	push   %eax
    1c55:	ff 75 08             	pushl  0x8(%ebp)
    1c58:	e8 31 fe ff ff       	call   1a8e <putc>
    1c5d:	83 c4 10             	add    $0x10,%esp
          s++;
    1c60:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
    1c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c67:	0f b6 00             	movzbl (%eax),%eax
    1c6a:	84 c0                	test   %al,%al
    1c6c:	75 da                	jne    1c48 <printf+0xe3>
    1c6e:	eb 65                	jmp    1cd5 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
    1c70:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
    1c74:	75 1d                	jne    1c93 <printf+0x12e>
        putc(fd, *ap);
    1c76:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c79:	8b 00                	mov    (%eax),%eax
    1c7b:	0f be c0             	movsbl %al,%eax
    1c7e:	83 ec 08             	sub    $0x8,%esp
    1c81:	50                   	push   %eax
    1c82:	ff 75 08             	pushl  0x8(%ebp)
    1c85:	e8 04 fe ff ff       	call   1a8e <putc>
    1c8a:	83 c4 10             	add    $0x10,%esp
        ap++;
    1c8d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    1c91:	eb 42                	jmp    1cd5 <printf+0x170>
      } else if(c == '%'){
    1c93:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    1c97:	75 17                	jne    1cb0 <printf+0x14b>
        putc(fd, c);
    1c99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1c9c:	0f be c0             	movsbl %al,%eax
    1c9f:	83 ec 08             	sub    $0x8,%esp
    1ca2:	50                   	push   %eax
    1ca3:	ff 75 08             	pushl  0x8(%ebp)
    1ca6:	e8 e3 fd ff ff       	call   1a8e <putc>
    1cab:	83 c4 10             	add    $0x10,%esp
    1cae:	eb 25                	jmp    1cd5 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
    1cb0:	83 ec 08             	sub    $0x8,%esp
    1cb3:	6a 25                	push   $0x25
    1cb5:	ff 75 08             	pushl  0x8(%ebp)
    1cb8:	e8 d1 fd ff ff       	call   1a8e <putc>
    1cbd:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
    1cc0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1cc3:	0f be c0             	movsbl %al,%eax
    1cc6:	83 ec 08             	sub    $0x8,%esp
    1cc9:	50                   	push   %eax
    1cca:	ff 75 08             	pushl  0x8(%ebp)
    1ccd:	e8 bc fd ff ff       	call   1a8e <putc>
    1cd2:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
    1cd5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
    1cdc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1ce0:	8b 55 0c             	mov    0xc(%ebp),%edx
    1ce3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ce6:	01 d0                	add    %edx,%eax
    1ce8:	0f b6 00             	movzbl (%eax),%eax
    1ceb:	84 c0                	test   %al,%al
    1ced:	0f 85 94 fe ff ff    	jne    1b87 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
    1cf3:	90                   	nop
    1cf4:	c9                   	leave  
    1cf5:	c3                   	ret    

00001cf6 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
    1cf6:	55                   	push   %ebp
    1cf7:	89 e5                	mov    %esp,%ebp
    1cf9:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
    1cfc:	8b 45 08             	mov    0x8(%ebp),%eax
    1cff:	83 e8 08             	sub    $0x8,%eax
    1d02:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    1d05:	a1 10 fd 01 00       	mov    0x1fd10,%eax
    1d0a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1d0d:	eb 24                	jmp    1d33 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
    1d0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d12:	8b 00                	mov    (%eax),%eax
    1d14:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d17:	77 12                	ja     1d2b <free+0x35>
    1d19:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d1c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d1f:	77 24                	ja     1d45 <free+0x4f>
    1d21:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d24:	8b 00                	mov    (%eax),%eax
    1d26:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d29:	77 1a                	ja     1d45 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    1d2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d2e:	8b 00                	mov    (%eax),%eax
    1d30:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1d33:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d36:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d39:	76 d4                	jbe    1d0f <free+0x19>
    1d3b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d3e:	8b 00                	mov    (%eax),%eax
    1d40:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d43:	76 ca                	jbe    1d0f <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
    1d45:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d48:	8b 40 04             	mov    0x4(%eax),%eax
    1d4b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    1d52:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d55:	01 c2                	add    %eax,%edx
    1d57:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d5a:	8b 00                	mov    (%eax),%eax
    1d5c:	39 c2                	cmp    %eax,%edx
    1d5e:	75 24                	jne    1d84 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
    1d60:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d63:	8b 50 04             	mov    0x4(%eax),%edx
    1d66:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d69:	8b 00                	mov    (%eax),%eax
    1d6b:	8b 40 04             	mov    0x4(%eax),%eax
    1d6e:	01 c2                	add    %eax,%edx
    1d70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d73:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
    1d76:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d79:	8b 00                	mov    (%eax),%eax
    1d7b:	8b 10                	mov    (%eax),%edx
    1d7d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d80:	89 10                	mov    %edx,(%eax)
    1d82:	eb 0a                	jmp    1d8e <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
    1d84:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d87:	8b 10                	mov    (%eax),%edx
    1d89:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d8c:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
    1d8e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d91:	8b 40 04             	mov    0x4(%eax),%eax
    1d94:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    1d9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d9e:	01 d0                	add    %edx,%eax
    1da0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1da3:	75 20                	jne    1dc5 <free+0xcf>
    p->s.size += bp->s.size;
    1da5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1da8:	8b 50 04             	mov    0x4(%eax),%edx
    1dab:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1dae:	8b 40 04             	mov    0x4(%eax),%eax
    1db1:	01 c2                	add    %eax,%edx
    1db3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1db6:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
    1db9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1dbc:	8b 10                	mov    (%eax),%edx
    1dbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1dc1:	89 10                	mov    %edx,(%eax)
    1dc3:	eb 08                	jmp    1dcd <free+0xd7>
  } else
    p->s.ptr = bp;
    1dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1dc8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    1dcb:	89 10                	mov    %edx,(%eax)
  freep = p;
    1dcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1dd0:	a3 10 fd 01 00       	mov    %eax,0x1fd10
}
    1dd5:	90                   	nop
    1dd6:	c9                   	leave  
    1dd7:	c3                   	ret    

00001dd8 <morecore>:

static Header*
morecore(uint nu)
{
    1dd8:	55                   	push   %ebp
    1dd9:	89 e5                	mov    %esp,%ebp
    1ddb:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
    1dde:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
    1de5:	77 07                	ja     1dee <morecore+0x16>
    nu = 4096;
    1de7:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
    1dee:	8b 45 08             	mov    0x8(%ebp),%eax
    1df1:	c1 e0 03             	shl    $0x3,%eax
    1df4:	83 ec 0c             	sub    $0xc,%esp
    1df7:	50                   	push   %eax
    1df8:	e8 49 fc ff ff       	call   1a46 <sbrk>
    1dfd:	83 c4 10             	add    $0x10,%esp
    1e00:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
    1e03:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
    1e07:	75 07                	jne    1e10 <morecore+0x38>
    return 0;
    1e09:	b8 00 00 00 00       	mov    $0x0,%eax
    1e0e:	eb 26                	jmp    1e36 <morecore+0x5e>
  hp = (Header*)p;
    1e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e13:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
    1e16:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e19:	8b 55 08             	mov    0x8(%ebp),%edx
    1e1c:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
    1e1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e22:	83 c0 08             	add    $0x8,%eax
    1e25:	83 ec 0c             	sub    $0xc,%esp
    1e28:	50                   	push   %eax
    1e29:	e8 c8 fe ff ff       	call   1cf6 <free>
    1e2e:	83 c4 10             	add    $0x10,%esp
  return freep;
    1e31:	a1 10 fd 01 00       	mov    0x1fd10,%eax
}
    1e36:	c9                   	leave  
    1e37:	c3                   	ret    

00001e38 <malloc>:

void*
malloc(uint nbytes)
{
    1e38:	55                   	push   %ebp
    1e39:	89 e5                	mov    %esp,%ebp
    1e3b:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
    1e3e:	8b 45 08             	mov    0x8(%ebp),%eax
    1e41:	83 c0 07             	add    $0x7,%eax
    1e44:	c1 e8 03             	shr    $0x3,%eax
    1e47:	83 c0 01             	add    $0x1,%eax
    1e4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
    1e4d:	a1 10 fd 01 00       	mov    0x1fd10,%eax
    1e52:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1e55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    1e59:	75 23                	jne    1e7e <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
    1e5b:	c7 45 f0 08 fd 01 00 	movl   $0x1fd08,-0x10(%ebp)
    1e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e65:	a3 10 fd 01 00       	mov    %eax,0x1fd10
    1e6a:	a1 10 fd 01 00       	mov    0x1fd10,%eax
    1e6f:	a3 08 fd 01 00       	mov    %eax,0x1fd08
    base.s.size = 0;
    1e74:	c7 05 0c fd 01 00 00 	movl   $0x0,0x1fd0c
    1e7b:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    1e7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e81:	8b 00                	mov    (%eax),%eax
    1e83:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
    1e86:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e89:	8b 40 04             	mov    0x4(%eax),%eax
    1e8c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    1e8f:	72 4d                	jb     1ede <malloc+0xa6>
      if(p->s.size == nunits)
    1e91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e94:	8b 40 04             	mov    0x4(%eax),%eax
    1e97:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    1e9a:	75 0c                	jne    1ea8 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
    1e9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e9f:	8b 10                	mov    (%eax),%edx
    1ea1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ea4:	89 10                	mov    %edx,(%eax)
    1ea6:	eb 26                	jmp    1ece <malloc+0x96>
      else {
        p->s.size -= nunits;
    1ea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1eab:	8b 40 04             	mov    0x4(%eax),%eax
    1eae:	2b 45 ec             	sub    -0x14(%ebp),%eax
    1eb1:	89 c2                	mov    %eax,%edx
    1eb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1eb6:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
    1eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ebc:	8b 40 04             	mov    0x4(%eax),%eax
    1ebf:	c1 e0 03             	shl    $0x3,%eax
    1ec2:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
    1ec5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ec8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    1ecb:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
    1ece:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ed1:	a3 10 fd 01 00       	mov    %eax,0x1fd10
      return (void*)(p + 1);
    1ed6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ed9:	83 c0 08             	add    $0x8,%eax
    1edc:	eb 3b                	jmp    1f19 <malloc+0xe1>
    }
    if(p == freep)
    1ede:	a1 10 fd 01 00       	mov    0x1fd10,%eax
    1ee3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    1ee6:	75 1e                	jne    1f06 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
    1ee8:	83 ec 0c             	sub    $0xc,%esp
    1eeb:	ff 75 ec             	pushl  -0x14(%ebp)
    1eee:	e8 e5 fe ff ff       	call   1dd8 <morecore>
    1ef3:	83 c4 10             	add    $0x10,%esp
    1ef6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1ef9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1efd:	75 07                	jne    1f06 <malloc+0xce>
        return 0;
    1eff:	b8 00 00 00 00       	mov    $0x0,%eax
    1f04:	eb 13                	jmp    1f19 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    1f06:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1f09:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1f0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1f0f:	8b 00                	mov    (%eax),%eax
    1f11:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
    1f14:	e9 6d ff ff ff       	jmp    1e86 <malloc+0x4e>
}
    1f19:	c9                   	leave  
    1f1a:	c3                   	ret    

00001f1b <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
    1f1b:	55                   	push   %ebp
    1f1c:	89 e5                	mov    %esp,%ebp
    ++g_seed;
    1f1e:	a1 14 fd 01 00       	mov    0x1fd14,%eax
    1f23:	83 c0 01             	add    $0x1,%eax
    1f26:	a3 14 fd 01 00       	mov    %eax,0x1fd14
    g_seed = (214013*g_seed+2531011);
    1f2b:	a1 14 fd 01 00       	mov    0x1fd14,%eax
    1f30:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
    1f36:	05 c3 9e 26 00       	add    $0x269ec3,%eax
    1f3b:	a3 14 fd 01 00       	mov    %eax,0x1fd14
    return (g_seed>>16)&0x7FFF;
    1f40:	a1 14 fd 01 00       	mov    0x1fd14,%eax
    1f45:	c1 e8 10             	shr    $0x10,%eax
    1f48:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
    1f4d:	5d                   	pop    %ebp
    1f4e:	c3                   	ret    

00001f4f <abs>:

#define PI 3.1415926536

float abs(float x) 
{
    1f4f:	55                   	push   %ebp
    1f50:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
    1f52:	d9 45 08             	flds   0x8(%ebp)
    1f55:	d9 ee                	fldz   
    1f57:	d9 c9                	fxch   %st(1)
    1f59:	df e9                	fucomip %st(1),%st
    1f5b:	dd d8                	fstp   %st(0)
    1f5d:	76 05                	jbe    1f64 <abs+0x15>
    1f5f:	d9 45 08             	flds   0x8(%ebp)
    1f62:	eb 05                	jmp    1f69 <abs+0x1a>
	return -x;
    1f64:	d9 45 08             	flds   0x8(%ebp)
    1f67:	d9 e0                	fchs   
}
    1f69:	5d                   	pop    %ebp
    1f6a:	c3                   	ret    

00001f6b <pow>:

float pow(float a, int b)
{
    1f6b:	55                   	push   %ebp
    1f6c:	89 e5                	mov    %esp,%ebp
    1f6e:	83 ec 10             	sub    $0x10,%esp
	float r = a;
    1f71:	d9 45 08             	flds   0x8(%ebp)
    1f74:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
    1f77:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1f7b:	7e 17                	jle    1f94 <pow+0x29>
		while (--b)
    1f7d:	eb 09                	jmp    1f88 <pow+0x1d>
			r *= a;
    1f7f:	d9 45 fc             	flds   -0x4(%ebp)
    1f82:	d8 4d 08             	fmuls  0x8(%ebp)
    1f85:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
    1f88:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    1f8c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1f90:	75 ed                	jne    1f7f <pow+0x14>
    1f92:	eb 2a                	jmp    1fbe <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
    1f94:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1f98:	79 1f                	jns    1fb9 <pow+0x4e>
		while (++b)
    1f9a:	eb 09                	jmp    1fa5 <pow+0x3a>
			r *= a;
    1f9c:	d9 45 fc             	flds   -0x4(%ebp)
    1f9f:	d8 4d 08             	fmuls  0x8(%ebp)
    1fa2:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
    1fa5:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    1fa9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1fad:	75 ed                	jne    1f9c <pow+0x31>
			r *= a;
		r = 1.0 / r;
    1faf:	d9 e8                	fld1   
    1fb1:	d8 75 fc             	fdivs  -0x4(%ebp)
    1fb4:	d9 5d fc             	fstps  -0x4(%ebp)
    1fb7:	eb 05                	jmp    1fbe <pow+0x53>
	}
	else r = 0;
    1fb9:	d9 ee                	fldz   
    1fbb:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
    1fbe:	d9 45 fc             	flds   -0x4(%ebp)
}
    1fc1:	c9                   	leave  
    1fc2:	c3                   	ret    

00001fc3 <sqrt>:

float sqrt(float number) {
    1fc3:	55                   	push   %ebp
    1fc4:	89 e5                	mov    %esp,%ebp
    1fc6:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
    1fc9:	d9 ee                	fldz   
    1fcb:	d9 45 08             	flds   0x8(%ebp)
    1fce:	d9 c9                	fxch   %st(1)
    1fd0:	df e9                	fucomip %st(1),%st
    1fd2:	dd d8                	fstp   %st(0)
    1fd4:	76 06                	jbe    1fdc <sqrt+0x19>
		return -1;
    1fd6:	d9 e8                	fld1   
    1fd8:	d9 e0                	fchs   
    1fda:	eb 3a                	jmp    2016 <sqrt+0x53>
	}

	new_guess = 1;
    1fdc:	d9 e8                	fld1   
    1fde:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
    1fe1:	d9 45 fc             	flds   -0x4(%ebp)
    1fe4:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
    1fe7:	d9 45 08             	flds   0x8(%ebp)
    1fea:	d8 75 f8             	fdivs  -0x8(%ebp)
    1fed:	d8 45 f8             	fadds  -0x8(%ebp)
    1ff0:	d9 05 d8 74 01 00    	flds   0x174d8
    1ff6:	de f9                	fdivrp %st,%st(1)
    1ff8:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
    1ffb:	d9 45 fc             	flds   -0x4(%ebp)
    1ffe:	d9 45 f8             	flds   -0x8(%ebp)
    2001:	df e9                	fucomip %st(1),%st
    2003:	dd d8                	fstp   %st(0)
    2005:	7a da                	jp     1fe1 <sqrt+0x1e>
    2007:	d9 45 fc             	flds   -0x4(%ebp)
    200a:	d9 45 f8             	flds   -0x8(%ebp)
    200d:	df e9                	fucomip %st(1),%st
    200f:	dd d8                	fstp   %st(0)
    2011:	75 ce                	jne    1fe1 <sqrt+0x1e>

	return new_guess;
    2013:	d9 45 fc             	flds   -0x4(%ebp)
}
    2016:	c9                   	leave  
    2017:	c3                   	ret    

00002018 <cos>:

float cos(float x)
{
    2018:	55                   	push   %ebp
    2019:	89 e5                	mov    %esp,%ebp
    201b:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    201e:	d9 e8                	fld1   
    2020:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    2023:	d9 45 08             	flds   0x8(%ebp)
    2026:	dd 05 e0 74 01 00    	fldl   0x174e0
    202c:	d9 c9                	fxch   %st(1)
    202e:	df e9                	fucomip %st(1),%st
    2030:	dd d8                	fstp   %st(0)
    2032:	77 0f                	ja     2043 <cos+0x2b>
    2034:	d9 45 08             	flds   0x8(%ebp)
    2037:	dd 05 e8 74 01 00    	fldl   0x174e8
    203d:	df e9                	fucomip %st(1),%st
    203f:	dd d8                	fstp   %st(0)
    2041:	76 3c                	jbe    207f <cos+0x67>
    2043:	d9 45 08             	flds   0x8(%ebp)
    2046:	d9 45 08             	flds   0x8(%ebp)
    2049:	dd 05 e0 74 01 00    	fldl   0x174e0
    204f:	de f9                	fdivrp %st,%st(1)
    2051:	d9 7d e2             	fnstcw -0x1e(%ebp)
    2054:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    2058:	b4 0c                	mov    $0xc,%ah
    205a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    205e:	d9 6d e0             	fldcw  -0x20(%ebp)
    2061:	db 5d dc             	fistpl -0x24(%ebp)
    2064:	d9 6d e2             	fldcw  -0x1e(%ebp)
    2067:	8b 45 dc             	mov    -0x24(%ebp),%eax
    206a:	01 c0                	add    %eax,%eax
    206c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    206f:	db 45 d8             	fildl  -0x28(%ebp)
    2072:	dd 05 f0 74 01 00    	fldl   0x174f0
    2078:	de c9                	fmulp  %st,%st(1)
    207a:	de e9                	fsubrp %st,%st(1)
    207c:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    207f:	d9 45 08             	flds   0x8(%ebp)
    2082:	dd 05 f0 74 01 00    	fldl   0x174f0
    2088:	d9 c9                	fxch   %st(1)
    208a:	df e9                	fucomip %st(1),%st
    208c:	dd d8                	fstp   %st(0)
    208e:	76 0e                	jbe    209e <cos+0x86>
    2090:	d9 45 08             	flds   0x8(%ebp)
    2093:	dd 05 e0 74 01 00    	fldl   0x174e0
    2099:	de e9                	fsubrp %st,%st(1)
    209b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    209e:	d9 45 08             	flds   0x8(%ebp)
    20a1:	dd 05 f8 74 01 00    	fldl   0x174f8
    20a7:	df e9                	fucomip %st(1),%st
    20a9:	dd d8                	fstp   %st(0)
    20ab:	76 0e                	jbe    20bb <cos+0xa3>
    20ad:	d9 45 08             	flds   0x8(%ebp)
    20b0:	dd 05 e0 74 01 00    	fldl   0x174e0
    20b6:	de c1                	faddp  %st,%st(1)
    20b8:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    20bb:	d9 45 08             	flds   0x8(%ebp)
    20be:	dd 05 00 75 01 00    	fldl   0x17500
    20c4:	d9 c9                	fxch   %st(1)
    20c6:	df e9                	fucomip %st(1),%st
    20c8:	dd d8                	fstp   %st(0)
    20ca:	76 16                	jbe    20e2 <cos+0xca>
    {
        x -= PI;
    20cc:	d9 45 08             	flds   0x8(%ebp)
    20cf:	dd 05 f0 74 01 00    	fldl   0x174f0
    20d5:	de e9                	fsubrp %st,%st(1)
    20d7:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    20da:	d9 45 f4             	flds   -0xc(%ebp)
    20dd:	d9 e0                	fchs   
    20df:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    20e2:	d9 45 08             	flds   0x8(%ebp)
    20e5:	dd 05 08 75 01 00    	fldl   0x17508
    20eb:	df e9                	fucomip %st(1),%st
    20ed:	dd d8                	fstp   %st(0)
    20ef:	76 16                	jbe    2107 <cos+0xef>
    {
        x += PI;
    20f1:	d9 45 08             	flds   0x8(%ebp)
    20f4:	dd 05 f0 74 01 00    	fldl   0x174f0
    20fa:	de c1                	faddp  %st,%st(1)
    20fc:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    20ff:	d9 45 f4             	flds   -0xc(%ebp)
    2102:	d9 e0                	fchs   
    2104:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
    2107:	d9 45 08             	flds   0x8(%ebp)
    210a:	dd 05 10 75 01 00    	fldl   0x17510
    2110:	d9 c9                	fxch   %st(1)
    2112:	df e9                	fucomip %st(1),%st
    2114:	dd d8                	fstp   %st(0)
    2116:	76 28                	jbe    2140 <cos+0x128>
    2118:	d9 45 08             	flds   0x8(%ebp)
    211b:	dd 05 00 75 01 00    	fldl   0x17500
    2121:	de e1                	fsubp  %st,%st(1)
    2123:	d9 5d e4             	fstps  -0x1c(%ebp)
    2126:	d9 45 e4             	flds   -0x1c(%ebp)
    2129:	83 ec 0c             	sub    $0xc,%esp
    212c:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2130:	d9 1c 24             	fstps  (%esp)
    2133:	e8 83 00 00 00       	call   21bb <sin>
    2138:	83 c4 10             	add    $0x10,%esp
    213b:	d8 4d f4             	fmuls  -0xc(%ebp)
    213e:	eb 79                	jmp    21b9 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
    2140:	83 ec 08             	sub    $0x8,%esp
    2143:	6a 02                	push   $0x2
    2145:	ff 75 08             	pushl  0x8(%ebp)
    2148:	e8 1e fe ff ff       	call   1f6b <pow>
    214d:	83 c4 10             	add    $0x10,%esp
    2150:	d9 05 d8 74 01 00    	flds   0x174d8
    2156:	de f9                	fdivrp %st,%st(1)
    2158:	d9 e8                	fld1   
    215a:	de e1                	fsubp  %st,%st(1)
    215c:	d9 5d d8             	fstps  -0x28(%ebp)
    215f:	83 ec 08             	sub    $0x8,%esp
    2162:	6a 04                	push   $0x4
    2164:	ff 75 08             	pushl  0x8(%ebp)
    2167:	e8 ff fd ff ff       	call   1f6b <pow>
    216c:	83 c4 10             	add    $0x10,%esp
    216f:	d9 05 18 75 01 00    	flds   0x17518
    2175:	de f9                	fdivrp %st,%st(1)
    2177:	d8 45 d8             	fadds  -0x28(%ebp)
    217a:	d9 5d d8             	fstps  -0x28(%ebp)
    217d:	83 ec 08             	sub    $0x8,%esp
    2180:	6a 06                	push   $0x6
    2182:	ff 75 08             	pushl  0x8(%ebp)
    2185:	e8 e1 fd ff ff       	call   1f6b <pow>
    218a:	83 c4 10             	add    $0x10,%esp
    218d:	d9 05 1c 75 01 00    	flds   0x1751c
    2193:	de f9                	fdivrp %st,%st(1)
    2195:	d8 6d d8             	fsubrs -0x28(%ebp)
    2198:	d9 5d d8             	fstps  -0x28(%ebp)
    219b:	83 ec 08             	sub    $0x8,%esp
    219e:	6a 08                	push   $0x8
    21a0:	ff 75 08             	pushl  0x8(%ebp)
    21a3:	e8 c3 fd ff ff       	call   1f6b <pow>
    21a8:	83 c4 10             	add    $0x10,%esp
    21ab:	d9 05 20 75 01 00    	flds   0x17520
    21b1:	de f9                	fdivrp %st,%st(1)
    21b3:	d8 45 d8             	fadds  -0x28(%ebp)
    21b6:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    21b9:	c9                   	leave  
    21ba:	c3                   	ret    

000021bb <sin>:

float sin(float x)
{
    21bb:	55                   	push   %ebp
    21bc:	89 e5                	mov    %esp,%ebp
    21be:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    21c1:	d9 e8                	fld1   
    21c3:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    21c6:	d9 45 08             	flds   0x8(%ebp)
    21c9:	dd 05 e0 74 01 00    	fldl   0x174e0
    21cf:	d9 c9                	fxch   %st(1)
    21d1:	df e9                	fucomip %st(1),%st
    21d3:	dd d8                	fstp   %st(0)
    21d5:	77 0f                	ja     21e6 <sin+0x2b>
    21d7:	d9 45 08             	flds   0x8(%ebp)
    21da:	dd 05 e8 74 01 00    	fldl   0x174e8
    21e0:	df e9                	fucomip %st(1),%st
    21e2:	dd d8                	fstp   %st(0)
    21e4:	76 3c                	jbe    2222 <sin+0x67>
    21e6:	d9 45 08             	flds   0x8(%ebp)
    21e9:	d9 45 08             	flds   0x8(%ebp)
    21ec:	dd 05 e0 74 01 00    	fldl   0x174e0
    21f2:	de f9                	fdivrp %st,%st(1)
    21f4:	d9 7d e2             	fnstcw -0x1e(%ebp)
    21f7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    21fb:	b4 0c                	mov    $0xc,%ah
    21fd:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    2201:	d9 6d e0             	fldcw  -0x20(%ebp)
    2204:	db 5d dc             	fistpl -0x24(%ebp)
    2207:	d9 6d e2             	fldcw  -0x1e(%ebp)
    220a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    220d:	01 c0                	add    %eax,%eax
    220f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    2212:	db 45 d8             	fildl  -0x28(%ebp)
    2215:	dd 05 f0 74 01 00    	fldl   0x174f0
    221b:	de c9                	fmulp  %st,%st(1)
    221d:	de e9                	fsubrp %st,%st(1)
    221f:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    2222:	d9 45 08             	flds   0x8(%ebp)
    2225:	dd 05 f0 74 01 00    	fldl   0x174f0
    222b:	d9 c9                	fxch   %st(1)
    222d:	df e9                	fucomip %st(1),%st
    222f:	dd d8                	fstp   %st(0)
    2231:	76 0e                	jbe    2241 <sin+0x86>
    2233:	d9 45 08             	flds   0x8(%ebp)
    2236:	dd 05 e0 74 01 00    	fldl   0x174e0
    223c:	de e9                	fsubrp %st,%st(1)
    223e:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    2241:	d9 45 08             	flds   0x8(%ebp)
    2244:	dd 05 f8 74 01 00    	fldl   0x174f8
    224a:	df e9                	fucomip %st(1),%st
    224c:	dd d8                	fstp   %st(0)
    224e:	76 0e                	jbe    225e <sin+0xa3>
    2250:	d9 45 08             	flds   0x8(%ebp)
    2253:	dd 05 e0 74 01 00    	fldl   0x174e0
    2259:	de c1                	faddp  %st,%st(1)
    225b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    225e:	d9 45 08             	flds   0x8(%ebp)
    2261:	dd 05 00 75 01 00    	fldl   0x17500
    2267:	d9 c9                	fxch   %st(1)
    2269:	df e9                	fucomip %st(1),%st
    226b:	dd d8                	fstp   %st(0)
    226d:	76 16                	jbe    2285 <sin+0xca>
    {
        x -= PI;
    226f:	d9 45 08             	flds   0x8(%ebp)
    2272:	dd 05 f0 74 01 00    	fldl   0x174f0
    2278:	de e9                	fsubrp %st,%st(1)
    227a:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    227d:	d9 45 f4             	flds   -0xc(%ebp)
    2280:	d9 e0                	fchs   
    2282:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    2285:	d9 45 08             	flds   0x8(%ebp)
    2288:	dd 05 08 75 01 00    	fldl   0x17508
    228e:	df e9                	fucomip %st(1),%st
    2290:	dd d8                	fstp   %st(0)
    2292:	76 16                	jbe    22aa <sin+0xef>
    {
        x += PI;
    2294:	d9 45 08             	flds   0x8(%ebp)
    2297:	dd 05 f0 74 01 00    	fldl   0x174f0
    229d:	de c1                	faddp  %st,%st(1)
    229f:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    22a2:	d9 45 f4             	flds   -0xc(%ebp)
    22a5:	d9 e0                	fchs   
    22a7:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
    22aa:	d9 ee                	fldz   
    22ac:	d9 45 08             	flds   0x8(%ebp)
    22af:	d9 c9                	fxch   %st(1)
    22b1:	df e9                	fucomip %st(1),%st
    22b3:	dd d8                	fstp   %st(0)
    22b5:	76 10                	jbe    22c7 <sin+0x10c>
    {
        x *= -1;
    22b7:	d9 45 08             	flds   0x8(%ebp)
    22ba:	d9 e0                	fchs   
    22bc:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    22bf:	d9 45 f4             	flds   -0xc(%ebp)
    22c2:	d9 e0                	fchs   
    22c4:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
    22c7:	d9 45 08             	flds   0x8(%ebp)
    22ca:	dd 05 10 75 01 00    	fldl   0x17510
    22d0:	d9 c9                	fxch   %st(1)
    22d2:	df e9                	fucomip %st(1),%st
    22d4:	dd d8                	fstp   %st(0)
    22d6:	76 28                	jbe    2300 <sin+0x145>
    22d8:	d9 45 08             	flds   0x8(%ebp)
    22db:	dd 05 00 75 01 00    	fldl   0x17500
    22e1:	de e1                	fsubp  %st,%st(1)
    22e3:	d9 5d e4             	fstps  -0x1c(%ebp)
    22e6:	d9 45 e4             	flds   -0x1c(%ebp)
    22e9:	83 ec 0c             	sub    $0xc,%esp
    22ec:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    22f0:	d9 1c 24             	fstps  (%esp)
    22f3:	e8 20 fd ff ff       	call   2018 <cos>
    22f8:	83 c4 10             	add    $0x10,%esp
    22fb:	d8 4d f4             	fmuls  -0xc(%ebp)
    22fe:	eb 7a                	jmp    237a <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
    2300:	83 ec 08             	sub    $0x8,%esp
    2303:	6a 03                	push   $0x3
    2305:	ff 75 08             	pushl  0x8(%ebp)
    2308:	e8 5e fc ff ff       	call   1f6b <pow>
    230d:	83 c4 10             	add    $0x10,%esp
    2310:	d9 05 24 75 01 00    	flds   0x17524
    2316:	de f9                	fdivrp %st,%st(1)
    2318:	d9 45 08             	flds   0x8(%ebp)
    231b:	de e1                	fsubp  %st,%st(1)
    231d:	d9 5d d8             	fstps  -0x28(%ebp)
    2320:	83 ec 08             	sub    $0x8,%esp
    2323:	6a 05                	push   $0x5
    2325:	ff 75 08             	pushl  0x8(%ebp)
    2328:	e8 3e fc ff ff       	call   1f6b <pow>
    232d:	83 c4 10             	add    $0x10,%esp
    2330:	d9 05 28 75 01 00    	flds   0x17528
    2336:	de f9                	fdivrp %st,%st(1)
    2338:	d8 45 d8             	fadds  -0x28(%ebp)
    233b:	d9 5d d8             	fstps  -0x28(%ebp)
    233e:	83 ec 08             	sub    $0x8,%esp
    2341:	6a 07                	push   $0x7
    2343:	ff 75 08             	pushl  0x8(%ebp)
    2346:	e8 20 fc ff ff       	call   1f6b <pow>
    234b:	83 c4 10             	add    $0x10,%esp
    234e:	d9 05 2c 75 01 00    	flds   0x1752c
    2354:	de f9                	fdivrp %st,%st(1)
    2356:	d8 6d d8             	fsubrs -0x28(%ebp)
    2359:	d9 5d d8             	fstps  -0x28(%ebp)
    235c:	83 ec 08             	sub    $0x8,%esp
    235f:	6a 09                	push   $0x9
    2361:	ff 75 08             	pushl  0x8(%ebp)
    2364:	e8 02 fc ff ff       	call   1f6b <pow>
    2369:	83 c4 10             	add    $0x10,%esp
    236c:	d9 05 30 75 01 00    	flds   0x17530
    2372:	de f9                	fdivrp %st,%st(1)
    2374:	d8 45 d8             	fadds  -0x28(%ebp)
    2377:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    237a:	c9                   	leave  
    237b:	c3                   	ret    

0000237c <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    237c:	55                   	push   %ebp
    237d:	89 e5                	mov    %esp,%ebp
    237f:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    2382:	83 ec 04             	sub    $0x4,%esp
    2385:	6a 0e                	push   $0xe
    2387:	ff 75 0c             	pushl  0xc(%ebp)
    238a:	ff 75 08             	pushl  0x8(%ebp)
    238d:	e8 44 f6 ff ff       	call   19d6 <read>
    2392:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    2395:	83 ec 04             	sub    $0x4,%esp
    2398:	6a 28                	push   $0x28
    239a:	ff 75 10             	pushl  0x10(%ebp)
    239d:	ff 75 08             	pushl  0x8(%ebp)
    23a0:	e8 31 f6 ff ff       	call   19d6 <read>
    23a5:	83 c4 10             	add    $0x10,%esp
}
    23a8:	90                   	nop
    23a9:	c9                   	leave  
    23aa:	c3                   	ret    

000023ab <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    23ab:	55                   	push   %ebp
    23ac:	89 e5                	mov    %esp,%ebp
    23ae:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    23b4:	83 ec 08             	sub    $0x8,%esp
    23b7:	6a 00                	push   $0x0
    23b9:	ff 75 08             	pushl  0x8(%ebp)
    23bc:	e8 3d f6 ff ff       	call   19fe <open>
    23c1:	83 c4 10             	add    $0x10,%esp
    23c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    23c7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    23cb:	79 0a                	jns    23d7 <readBitmapFile+0x2c>
        return -1;
    23cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    23d2:	e9 6e 01 00 00       	jmp    2545 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    23d7:	83 ec 04             	sub    $0x4,%esp
    23da:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    23dd:	50                   	push   %eax
    23de:	8d 45 ca             	lea    -0x36(%ebp),%eax
    23e1:	50                   	push   %eax
    23e2:	ff 75 ec             	pushl  -0x14(%ebp)
    23e5:	e8 92 ff ff ff       	call   237c <readBitmapHeader>
    23ea:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    23ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    23f0:	83 e8 36             	sub    $0x36,%eax
    23f3:	83 ec 04             	sub    $0x4,%esp
    23f6:	50                   	push   %eax
    23f7:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    23fd:	50                   	push   %eax
    23fe:	ff 75 ec             	pushl  -0x14(%ebp)
    2401:	e8 d0 f5 ff ff       	call   19d6 <read>
    2406:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    2409:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    240c:	8b 45 14             	mov    0x14(%ebp),%eax
    240f:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    2411:	8b 55 aa             	mov    -0x56(%ebp),%edx
    2414:	8b 45 10             	mov    0x10(%ebp),%eax
    2417:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    2419:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    241c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    241f:	8b 45 aa             	mov    -0x56(%ebp),%eax
    2422:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    2425:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    2429:	0f b7 c0             	movzwl %ax,%eax
    242c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    242f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2432:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2436:	8d 50 07             	lea    0x7(%eax),%edx
    2439:	85 c0                	test   %eax,%eax
    243b:	0f 48 c2             	cmovs  %edx,%eax
    243e:	c1 f8 03             	sar    $0x3,%eax
    2441:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    2444:	8b 45 0c             	mov    0xc(%ebp),%eax
    2447:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    244a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    244d:	83 e8 01             	sub    $0x1,%eax
    2450:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2453:	e9 d0 00 00 00       	jmp    2528 <readBitmapFile+0x17d>
        if (bits == 32) {
    2458:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    245c:	75 22                	jne    2480 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    245e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2461:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2465:	89 c2                	mov    %eax,%edx
    2467:	8b 45 d8             	mov    -0x28(%ebp),%eax
    246a:	01 d0                	add    %edx,%eax
    246c:	83 ec 04             	sub    $0x4,%esp
    246f:	ff 75 dc             	pushl  -0x24(%ebp)
    2472:	50                   	push   %eax
    2473:	ff 75 ec             	pushl  -0x14(%ebp)
    2476:	e8 5b f5 ff ff       	call   19d6 <read>
    247b:	83 c4 10             	add    $0x10,%esp
    247e:	eb 65                	jmp    24e5 <readBitmapFile+0x13a>
        } else {
            int j = 0;
    2480:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    2487:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    248e:	eb 4d                	jmp    24dd <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    2490:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2493:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2497:	c1 e0 02             	shl    $0x2,%eax
    249a:	89 c2                	mov    %eax,%edx
    249c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    249f:	c1 e0 02             	shl    $0x2,%eax
    24a2:	01 c2                	add    %eax,%edx
    24a4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    24a7:	01 d0                	add    %edx,%eax
    24a9:	83 ec 04             	sub    $0x4,%esp
    24ac:	6a 03                	push   $0x3
    24ae:	50                   	push   %eax
    24af:	ff 75 ec             	pushl  -0x14(%ebp)
    24b2:	e8 1f f5 ff ff       	call   19d6 <read>
    24b7:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    24ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    24bd:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    24c1:	c1 e0 02             	shl    $0x2,%eax
    24c4:	89 c2                	mov    %eax,%edx
    24c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24c9:	c1 e0 02             	shl    $0x2,%eax
    24cc:	01 d0                	add    %edx,%eax
    24ce:	8d 50 03             	lea    0x3(%eax),%edx
    24d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    24d4:	01 d0                	add    %edx,%eax
    24d6:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    24d9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    24dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24e0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    24e3:	7c ab                	jl     2490 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    24e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    24e8:	99                   	cltd   
    24e9:	c1 ea 1e             	shr    $0x1e,%edx
    24ec:	01 d0                	add    %edx,%eax
    24ee:	83 e0 03             	and    $0x3,%eax
    24f1:	29 d0                	sub    %edx,%eax
    24f3:	85 c0                	test   %eax,%eax
    24f5:	7e 2d                	jle    2524 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    24f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    24fa:	99                   	cltd   
    24fb:	c1 ea 1e             	shr    $0x1e,%edx
    24fe:	01 d0                	add    %edx,%eax
    2500:	83 e0 03             	and    $0x3,%eax
    2503:	29 d0                	sub    %edx,%eax
    2505:	ba 04 00 00 00       	mov    $0x4,%edx
    250a:	29 c2                	sub    %eax,%edx
    250c:	89 d0                	mov    %edx,%eax
    250e:	83 ec 04             	sub    $0x4,%esp
    2511:	50                   	push   %eax
    2512:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    2518:	50                   	push   %eax
    2519:	ff 75 ec             	pushl  -0x14(%ebp)
    251c:	e8 b5 f4 ff ff       	call   19d6 <read>
    2521:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    2524:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    2528:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    252c:	0f 89 26 ff ff ff    	jns    2458 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    2532:	83 ec 0c             	sub    $0xc,%esp
    2535:	ff 75 ec             	pushl  -0x14(%ebp)
    2538:	e8 a9 f4 ff ff       	call   19e6 <close>
    253d:	83 c4 10             	add    $0x10,%esp
    return 0;
    2540:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2545:	c9                   	leave  
    2546:	c3                   	ret    

00002547 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    2547:	55                   	push   %ebp
    2548:	89 e5                	mov    %esp,%ebp
    254a:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    2550:	83 ec 08             	sub    $0x8,%esp
    2553:	6a 00                	push   $0x0
    2555:	ff 75 08             	pushl  0x8(%ebp)
    2558:	e8 a1 f4 ff ff       	call   19fe <open>
    255d:	83 c4 10             	add    $0x10,%esp
    2560:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    2563:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2567:	79 0a                	jns    2573 <read24BitmapFile+0x2c>
        return -1;
    2569:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    256e:	e9 66 01 00 00       	jmp    26d9 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    2573:	83 ec 04             	sub    $0x4,%esp
    2576:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    2579:	50                   	push   %eax
    257a:	8d 45 ca             	lea    -0x36(%ebp),%eax
    257d:	50                   	push   %eax
    257e:	ff 75 ec             	pushl  -0x14(%ebp)
    2581:	e8 f6 fd ff ff       	call   237c <readBitmapHeader>
    2586:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    2589:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    258c:	83 e8 36             	sub    $0x36,%eax
    258f:	83 ec 04             	sub    $0x4,%esp
    2592:	50                   	push   %eax
    2593:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    2599:	50                   	push   %eax
    259a:	ff 75 ec             	pushl  -0x14(%ebp)
    259d:	e8 34 f4 ff ff       	call   19d6 <read>
    25a2:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    25a5:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    25a8:	8b 45 14             	mov    0x14(%ebp),%eax
    25ab:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    25ad:	8b 55 aa             	mov    -0x56(%ebp),%edx
    25b0:	8b 45 10             	mov    0x10(%ebp),%eax
    25b3:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    25b5:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    25b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    25bb:	8b 45 aa             	mov    -0x56(%ebp),%eax
    25be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    25c1:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    25c5:	0f b7 c0             	movzwl %ax,%eax
    25c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    25cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    25ce:	89 d0                	mov    %edx,%eax
    25d0:	01 c0                	add    %eax,%eax
    25d2:	01 d0                	add    %edx,%eax
    25d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    25d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    25da:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    25dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25e0:	83 e8 01             	sub    $0x1,%eax
    25e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    25e6:	e9 d1 00 00 00       	jmp    26bc <read24BitmapFile+0x175>
        if (bits == 24) {
    25eb:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    25ef:	75 22                	jne    2613 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    25f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    25f4:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    25f8:	89 c2                	mov    %eax,%edx
    25fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
    25fd:	01 d0                	add    %edx,%eax
    25ff:	83 ec 04             	sub    $0x4,%esp
    2602:	ff 75 dc             	pushl  -0x24(%ebp)
    2605:	50                   	push   %eax
    2606:	ff 75 ec             	pushl  -0x14(%ebp)
    2609:	e8 c8 f3 ff ff       	call   19d6 <read>
    260e:	83 c4 10             	add    $0x10,%esp
    2611:	eb 66                	jmp    2679 <read24BitmapFile+0x132>
        } else {
            int j = 0;
    2613:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    261a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2621:	eb 4e                	jmp    2671 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    2623:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2626:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    262a:	89 c2                	mov    %eax,%edx
    262c:	89 d0                	mov    %edx,%eax
    262e:	01 c0                	add    %eax,%eax
    2630:	01 d0                	add    %edx,%eax
    2632:	89 c1                	mov    %eax,%ecx
    2634:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2637:	89 d0                	mov    %edx,%eax
    2639:	01 c0                	add    %eax,%eax
    263b:	01 d0                	add    %edx,%eax
    263d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    2640:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2643:	01 d0                	add    %edx,%eax
    2645:	83 ec 04             	sub    $0x4,%esp
    2648:	6a 03                	push   $0x3
    264a:	50                   	push   %eax
    264b:	ff 75 ec             	pushl  -0x14(%ebp)
    264e:	e8 83 f3 ff ff       	call   19d6 <read>
    2653:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    2656:	83 ec 04             	sub    $0x4,%esp
    2659:	6a 01                	push   $0x1
    265b:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    2661:	50                   	push   %eax
    2662:	ff 75 ec             	pushl  -0x14(%ebp)
    2665:	e8 6c f3 ff ff       	call   19d6 <read>
    266a:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    266d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2671:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2674:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    2677:	7c aa                	jl     2623 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    2679:	8b 45 dc             	mov    -0x24(%ebp),%eax
    267c:	99                   	cltd   
    267d:	c1 ea 1e             	shr    $0x1e,%edx
    2680:	01 d0                	add    %edx,%eax
    2682:	83 e0 03             	and    $0x3,%eax
    2685:	29 d0                	sub    %edx,%eax
    2687:	85 c0                	test   %eax,%eax
    2689:	7e 2d                	jle    26b8 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    268b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    268e:	99                   	cltd   
    268f:	c1 ea 1e             	shr    $0x1e,%edx
    2692:	01 d0                	add    %edx,%eax
    2694:	83 e0 03             	and    $0x3,%eax
    2697:	29 d0                	sub    %edx,%eax
    2699:	ba 04 00 00 00       	mov    $0x4,%edx
    269e:	29 c2                	sub    %eax,%edx
    26a0:	89 d0                	mov    %edx,%eax
    26a2:	83 ec 04             	sub    $0x4,%esp
    26a5:	50                   	push   %eax
    26a6:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    26ac:	50                   	push   %eax
    26ad:	ff 75 ec             	pushl  -0x14(%ebp)
    26b0:	e8 21 f3 ff ff       	call   19d6 <read>
    26b5:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    26b8:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    26bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    26c0:	0f 89 25 ff ff ff    	jns    25eb <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    26c6:	83 ec 0c             	sub    $0xc,%esp
    26c9:	ff 75 ec             	pushl  -0x14(%ebp)
    26cc:	e8 15 f3 ff ff       	call   19e6 <close>
    26d1:	83 c4 10             	add    $0x10,%esp
    return 0;
    26d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    26d9:	c9                   	leave  
    26da:	c3                   	ret    

000026db <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    26db:	55                   	push   %ebp
    26dc:	89 e5                	mov    %esp,%ebp
    26de:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    26e1:	8b 55 10             	mov    0x10(%ebp),%edx
    26e4:	89 d0                	mov    %edx,%eax
    26e6:	01 c0                	add    %eax,%eax
    26e8:	01 d0                	add    %edx,%eax
    26ea:	c1 e0 03             	shl    $0x3,%eax
    26ed:	83 c0 1f             	add    $0x1f,%eax
    26f0:	8d 50 1f             	lea    0x1f(%eax),%edx
    26f3:	85 c0                	test   %eax,%eax
    26f5:	0f 48 c2             	cmovs  %edx,%eax
    26f8:	c1 f8 05             	sar    $0x5,%eax
    26fb:	c1 e0 02             	shl    $0x2,%eax
    26fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    2701:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    2707:	8b 45 f4             	mov    -0xc(%ebp),%eax
    270a:	0f af 45 0c          	imul   0xc(%ebp),%eax
    270e:	83 c0 36             	add    $0x36,%eax
    2711:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    2714:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    271a:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    2720:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    2727:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    272e:	8b 45 10             	mov    0x10(%ebp),%eax
    2731:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    2734:	8b 45 0c             	mov    0xc(%ebp),%eax
    2737:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    273a:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    2740:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    2746:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    274d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2750:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2754:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    2757:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    275e:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    2765:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    276c:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    2773:	83 ec 04             	sub    $0x4,%esp
    2776:	6a 0e                	push   $0xe
    2778:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    277b:	50                   	push   %eax
    277c:	ff 75 08             	pushl  0x8(%ebp)
    277f:	e8 5a f2 ff ff       	call   19de <write>
    2784:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    2787:	83 ec 04             	sub    $0x4,%esp
    278a:	6a 28                	push   $0x28
    278c:	8d 45 be             	lea    -0x42(%ebp),%eax
    278f:	50                   	push   %eax
    2790:	ff 75 08             	pushl  0x8(%ebp)
    2793:	e8 46 f2 ff ff       	call   19de <write>
    2798:	83 c4 10             	add    $0x10,%esp
}
    279b:	90                   	nop
    279c:	c9                   	leave  
    279d:	c3                   	ret    

0000279e <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    279e:	55                   	push   %ebp
    279f:	89 e5                	mov    %esp,%ebp
    27a1:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    27a4:	83 ec 08             	sub    $0x8,%esp
    27a7:	68 02 02 00 00       	push   $0x202
    27ac:	ff 75 08             	pushl  0x8(%ebp)
    27af:	e8 4a f2 ff ff       	call   19fe <open>
    27b4:	83 c4 10             	add    $0x10,%esp
    27b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    27ba:	8b 55 14             	mov    0x14(%ebp),%edx
    27bd:	89 d0                	mov    %edx,%eax
    27bf:	01 c0                	add    %eax,%eax
    27c1:	01 d0                	add    %edx,%eax
    27c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    27c6:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    27ca:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    27ce:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    27d2:	83 ec 04             	sub    $0x4,%esp
    27d5:	ff 75 14             	pushl  0x14(%ebp)
    27d8:	ff 75 10             	pushl  0x10(%ebp)
    27db:	ff 75 f0             	pushl  -0x10(%ebp)
    27de:	e8 f8 fe ff ff       	call   26db <write24BitmapFileHeader>
    27e3:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    27e6:	8b 45 10             	mov    0x10(%ebp),%eax
    27e9:	83 e8 01             	sub    $0x1,%eax
    27ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
    27ef:	eb 66                	jmp    2857 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    27f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    27f4:	0f af 45 14          	imul   0x14(%ebp),%eax
    27f8:	89 c2                	mov    %eax,%edx
    27fa:	89 d0                	mov    %edx,%eax
    27fc:	01 c0                	add    %eax,%eax
    27fe:	01 c2                	add    %eax,%edx
    2800:	8b 45 0c             	mov    0xc(%ebp),%eax
    2803:	01 d0                	add    %edx,%eax
    2805:	83 ec 04             	sub    $0x4,%esp
    2808:	ff 75 ec             	pushl  -0x14(%ebp)
    280b:	50                   	push   %eax
    280c:	ff 75 f0             	pushl  -0x10(%ebp)
    280f:	e8 ca f1 ff ff       	call   19de <write>
    2814:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    2817:	8b 45 ec             	mov    -0x14(%ebp),%eax
    281a:	99                   	cltd   
    281b:	c1 ea 1e             	shr    $0x1e,%edx
    281e:	01 d0                	add    %edx,%eax
    2820:	83 e0 03             	and    $0x3,%eax
    2823:	29 d0                	sub    %edx,%eax
    2825:	85 c0                	test   %eax,%eax
    2827:	7e 2a                	jle    2853 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    2829:	8b 45 ec             	mov    -0x14(%ebp),%eax
    282c:	99                   	cltd   
    282d:	c1 ea 1e             	shr    $0x1e,%edx
    2830:	01 d0                	add    %edx,%eax
    2832:	83 e0 03             	and    $0x3,%eax
    2835:	29 d0                	sub    %edx,%eax
    2837:	ba 04 00 00 00       	mov    $0x4,%edx
    283c:	29 c2                	sub    %eax,%edx
    283e:	89 d0                	mov    %edx,%eax
    2840:	83 ec 04             	sub    $0x4,%esp
    2843:	50                   	push   %eax
    2844:	8d 45 e9             	lea    -0x17(%ebp),%eax
    2847:	50                   	push   %eax
    2848:	ff 75 f0             	pushl  -0x10(%ebp)
    284b:	e8 8e f1 ff ff       	call   19de <write>
    2850:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    2853:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    2857:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    285b:	79 94                	jns    27f1 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    285d:	83 ec 0c             	sub    $0xc,%esp
    2860:	ff 75 f0             	pushl  -0x10(%ebp)
    2863:	e8 7e f1 ff ff       	call   19e6 <close>
    2868:	83 c4 10             	add    $0x10,%esp
    return 0;
    286b:	b8 00 00 00 00       	mov    $0x0,%eax
    2870:	c9                   	leave  
    2871:	c3                   	ret    

00002872 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    2872:	55                   	push   %ebp
    2873:	89 e5                	mov    %esp,%ebp
    2875:	57                   	push   %edi
    2876:	56                   	push   %esi
    2877:	53                   	push   %ebx
    2878:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    287b:	8b 45 08             	mov    0x8(%ebp),%eax
    287e:	8b 50 10             	mov    0x10(%eax),%edx
    2881:	8b 40 0c             	mov    0xc(%eax),%eax
    2884:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2887:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    288a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    288d:	8b 55 e0             	mov    -0x20(%ebp),%edx
    2890:	83 c2 1e             	add    $0x1e,%edx
    2893:	0f af d0             	imul   %eax,%edx
    2896:	89 d0                	mov    %edx,%eax
    2898:	01 c0                	add    %eax,%eax
    289a:	01 d0                	add    %edx,%eax
    289c:	83 ec 0c             	sub    $0xc,%esp
    289f:	50                   	push   %eax
    28a0:	e8 93 f5 ff ff       	call   1e38 <malloc>
    28a5:	83 c4 10             	add    $0x10,%esp
    28a8:	89 c2                	mov    %eax,%edx
    28aa:	8b 45 08             	mov    0x8(%ebp),%eax
    28ad:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    28b0:	8b 45 08             	mov    0x8(%ebp),%eax
    28b3:	8b 40 1c             	mov    0x1c(%eax),%eax
    28b6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    28b9:	6b d2 5a             	imul   $0x5a,%edx,%edx
    28bc:	01 c2                	add    %eax,%edx
    28be:	8b 45 08             	mov    0x8(%ebp),%eax
    28c1:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    28c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    28c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    28ca:	0f af d0             	imul   %eax,%edx
    28cd:	89 d0                	mov    %edx,%eax
    28cf:	01 c0                	add    %eax,%eax
    28d1:	01 d0                	add    %edx,%eax
    28d3:	89 c2                	mov    %eax,%edx
    28d5:	8b 45 08             	mov    0x8(%ebp),%eax
    28d8:	8b 40 18             	mov    0x18(%eax),%eax
    28db:	83 ec 04             	sub    $0x4,%esp
    28de:	52                   	push   %edx
    28df:	68 ff 00 00 00       	push   $0xff
    28e4:	50                   	push   %eax
    28e5:	e8 39 ef ff ff       	call   1823 <memset>
    28ea:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    28ed:	8b 45 08             	mov    0x8(%ebp),%eax
    28f0:	8b 78 1c             	mov    0x1c(%eax),%edi
    28f3:	8b 45 08             	mov    0x8(%ebp),%eax
    28f6:	8b 70 14             	mov    0x14(%eax),%esi
    28f9:	8b 45 08             	mov    0x8(%ebp),%eax
    28fc:	8b 58 0c             	mov    0xc(%eax),%ebx
    28ff:	8b 45 08             	mov    0x8(%ebp),%eax
    2902:	8b 48 10             	mov    0x10(%eax),%ecx
    2905:	8b 45 08             	mov    0x8(%ebp),%eax
    2908:	8b 50 08             	mov    0x8(%eax),%edx
    290b:	8b 45 08             	mov    0x8(%ebp),%eax
    290e:	8b 40 04             	mov    0x4(%eax),%eax
    2911:	83 ec 08             	sub    $0x8,%esp
    2914:	57                   	push   %edi
    2915:	56                   	push   %esi
    2916:	53                   	push   %ebx
    2917:	51                   	push   %ecx
    2918:	52                   	push   %edx
    2919:	50                   	push   %eax
    291a:	e8 3f f1 ff ff       	call   1a5e <createwindow>
    291f:	83 c4 20             	add    $0x20,%esp
    2922:	89 c2                	mov    %eax,%edx
    2924:	8b 45 08             	mov    0x8(%ebp),%eax
    2927:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    2929:	8b 45 08             	mov    0x8(%ebp),%eax
    292c:	8b 00                	mov    (%eax),%eax
}
    292e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2931:	5b                   	pop    %ebx
    2932:	5e                   	pop    %esi
    2933:	5f                   	pop    %edi
    2934:	5d                   	pop    %ebp
    2935:	c3                   	ret    

00002936 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    2936:	55                   	push   %ebp
    2937:	89 e5                	mov    %esp,%ebp
    2939:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    293c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2943:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    294a:	8b 45 08             	mov    0x8(%ebp),%eax
    294d:	8b 40 18             	mov    0x18(%eax),%eax
    2950:	ff 75 1c             	pushl  0x1c(%ebp)
    2953:	ff 75 18             	pushl  0x18(%ebp)
    2956:	ff 75 1c             	pushl  0x1c(%ebp)
    2959:	ff 75 18             	pushl  0x18(%ebp)
    295c:	8b 55 08             	mov    0x8(%ebp),%edx
    295f:	ff 72 10             	pushl  0x10(%edx)
    2962:	ff 72 0c             	pushl  0xc(%edx)
    2965:	ff 75 f4             	pushl  -0xc(%ebp)
    2968:	ff 75 f0             	pushl  -0x10(%ebp)
    296b:	ff 75 14             	pushl  0x14(%ebp)
    296e:	ff 75 10             	pushl  0x10(%ebp)
    2971:	ff 75 0c             	pushl  0xc(%ebp)
    2974:	50                   	push   %eax
    2975:	e8 d5 07 00 00       	call   314f <drawBitmap>
    297a:	83 c4 30             	add    $0x30,%esp
    return 0;
    297d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2982:	c9                   	leave  
    2983:	c3                   	ret    

00002984 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    2984:	55                   	push   %ebp
    2985:	89 e5                	mov    %esp,%ebp
    2987:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    298a:	8b 45 08             	mov    0x8(%ebp),%eax
    298d:	8b 40 18             	mov    0x18(%eax),%eax
    2990:	ff 75 2c             	pushl  0x2c(%ebp)
    2993:	ff 75 28             	pushl  0x28(%ebp)
    2996:	ff 75 24             	pushl  0x24(%ebp)
    2999:	ff 75 20             	pushl  0x20(%ebp)
    299c:	8b 55 08             	mov    0x8(%ebp),%edx
    299f:	ff 72 10             	pushl  0x10(%edx)
    29a2:	ff 72 0c             	pushl  0xc(%edx)
    29a5:	ff 75 1c             	pushl  0x1c(%ebp)
    29a8:	ff 75 18             	pushl  0x18(%ebp)
    29ab:	ff 75 14             	pushl  0x14(%ebp)
    29ae:	ff 75 10             	pushl  0x10(%ebp)
    29b1:	ff 75 0c             	pushl  0xc(%ebp)
    29b4:	50                   	push   %eax
    29b5:	e8 95 07 00 00       	call   314f <drawBitmap>
    29ba:	83 c4 30             	add    $0x30,%esp
    return 0;
    29bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    29c2:	c9                   	leave  
    29c3:	c3                   	ret    

000029c4 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    29c4:	55                   	push   %ebp
    29c5:	89 e5                	mov    %esp,%ebp
    29c7:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    29ca:	8b 45 08             	mov    0x8(%ebp),%eax
    29cd:	8b 40 18             	mov    0x18(%eax),%eax
    29d0:	ff 75 2c             	pushl  0x2c(%ebp)
    29d3:	ff 75 28             	pushl  0x28(%ebp)
    29d6:	ff 75 24             	pushl  0x24(%ebp)
    29d9:	ff 75 20             	pushl  0x20(%ebp)
    29dc:	8b 55 08             	mov    0x8(%ebp),%edx
    29df:	ff 72 10             	pushl  0x10(%edx)
    29e2:	ff 72 0c             	pushl  0xc(%edx)
    29e5:	ff 75 1c             	pushl  0x1c(%ebp)
    29e8:	ff 75 18             	pushl  0x18(%ebp)
    29eb:	ff 75 14             	pushl  0x14(%ebp)
    29ee:	ff 75 10             	pushl  0x10(%ebp)
    29f1:	ff 75 0c             	pushl  0xc(%ebp)
    29f4:	50                   	push   %eax
    29f5:	e8 75 08 00 00       	call   326f <drawTransparentBitmap>
    29fa:	83 c4 30             	add    $0x30,%esp
    return 0;
    29fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2a02:	c9                   	leave  
    2a03:	c3                   	ret    

00002a04 <api_repaint>:

int api_repaint(Window* wnd)
{
    2a04:	55                   	push   %ebp
    2a05:	89 e5                	mov    %esp,%ebp
    2a07:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    2a0a:	8b 45 08             	mov    0x8(%ebp),%eax
    2a0d:	8b 00                	mov    (%eax),%eax
    2a0f:	83 ec 0c             	sub    $0xc,%esp
    2a12:	50                   	push   %eax
    2a13:	e8 4e f0 ff ff       	call   1a66 <repaintwindow>
    2a18:	83 c4 10             	add    $0x10,%esp
    return 0;
    2a1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2a20:	c9                   	leave  
    2a21:	c3                   	ret    

00002a22 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    2a22:	55                   	push   %ebp
    2a23:	89 e5                	mov    %esp,%ebp
    2a25:	56                   	push   %esi
    2a26:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    2a27:	8b 75 18             	mov    0x18(%ebp),%esi
    2a2a:	8b 5d 14             	mov    0x14(%ebp),%ebx
    2a2d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    2a30:	8b 55 0c             	mov    0xc(%ebp),%edx
    2a33:	8b 45 08             	mov    0x8(%ebp),%eax
    2a36:	8b 00                	mov    (%eax),%eax
    2a38:	83 ec 0c             	sub    $0xc,%esp
    2a3b:	56                   	push   %esi
    2a3c:	53                   	push   %ebx
    2a3d:	51                   	push   %ecx
    2a3e:	52                   	push   %edx
    2a3f:	50                   	push   %eax
    2a40:	e8 39 f0 ff ff       	call   1a7e <updatewindow>
    2a45:	83 c4 20             	add    $0x20,%esp
    return 0;
    2a48:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2a4d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2a50:	5b                   	pop    %ebx
    2a51:	5e                   	pop    %esi
    2a52:	5d                   	pop    %ebp
    2a53:	c3                   	ret    

00002a54 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    2a54:	55                   	push   %ebp
    2a55:	89 e5                	mov    %esp,%ebp
    2a57:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    2a5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    2a61:	8b 45 08             	mov    0x8(%ebp),%eax
    2a64:	8b 00                	mov    (%eax),%eax
    2a66:	83 ec 08             	sub    $0x8,%esp
    2a69:	8d 55 c8             	lea    -0x38(%ebp),%edx
    2a6c:	52                   	push   %edx
    2a6d:	50                   	push   %eax
    2a6e:	e8 fb ef ff ff       	call   1a6e <getmessage>
    2a73:	83 c4 10             	add    $0x10,%esp
    2a76:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    2a79:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2a7d:	74 e2                	je     2a61 <api_exec+0xd>
        {
            pf(&msg);
    2a7f:	83 ec 0c             	sub    $0xc,%esp
    2a82:	8d 45 c8             	lea    -0x38(%ebp),%eax
    2a85:	50                   	push   %eax
    2a86:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a89:	ff d0                	call   *%eax
    2a8b:	83 c4 10             	add    $0x10,%esp
        }
    }
    2a8e:	eb d1                	jmp    2a61 <api_exec+0xd>

00002a90 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    2a90:	55                   	push   %ebp
    2a91:	89 e5                	mov    %esp,%ebp
    2a93:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    2a96:	8b 45 08             	mov    0x8(%ebp),%eax
    2a99:	8b 00                	mov    (%eax),%eax
    2a9b:	83 ec 08             	sub    $0x8,%esp
    2a9e:	ff 75 0c             	pushl  0xc(%ebp)
    2aa1:	50                   	push   %eax
    2aa2:	e8 cf ef ff ff       	call   1a76 <settimer>
    2aa7:	83 c4 10             	add    $0x10,%esp
    return 0;
    2aaa:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2aaf:	c9                   	leave  
    2ab0:	c3                   	ret    

00002ab1 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    2ab1:	55                   	push   %ebp
    2ab2:	89 e5                	mov    %esp,%ebp
    2ab4:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    2ab7:	8b 45 08             	mov    0x8(%ebp),%eax
    2aba:	8b 50 18             	mov    0x18(%eax),%edx
    2abd:	ff 75 18             	pushl  0x18(%ebp)
    2ac0:	ff 75 14             	pushl  0x14(%ebp)
    2ac3:	83 ec 04             	sub    $0x4,%esp
    2ac6:	89 e0                	mov    %esp,%eax
    2ac8:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    2acc:	66 89 08             	mov    %cx,(%eax)
    2acf:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    2ad3:	88 48 02             	mov    %cl,0x2(%eax)
    2ad6:	8b 45 08             	mov    0x8(%ebp),%eax
    2ad9:	ff 70 10             	pushl  0x10(%eax)
    2adc:	ff 70 0c             	pushl  0xc(%eax)
    2adf:	ff 75 10             	pushl  0x10(%ebp)
    2ae2:	ff 75 0c             	pushl  0xc(%ebp)
    2ae5:	52                   	push   %edx
    2ae6:	e8 6f 04 00 00       	call   2f5a <drawRect>
    2aeb:	83 c4 20             	add    $0x20,%esp
    return 0;
    2aee:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2af3:	c9                   	leave  
    2af4:	c3                   	ret    

00002af5 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    2af5:	55                   	push   %ebp
    2af6:	89 e5                	mov    %esp,%ebp
    2af8:	83 ec 28             	sub    $0x28,%esp
    2afb:	8b 45 14             	mov    0x14(%ebp),%eax
    2afe:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    2b01:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    2b05:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b08:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2b0b:	8b 45 10             	mov    0x10(%ebp),%eax
    2b0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2b11:	8b 45 08             	mov    0x8(%ebp),%eax
    2b14:	8b 40 18             	mov    0x18(%eax),%eax
    2b17:	83 ec 04             	sub    $0x4,%esp
    2b1a:	ff 75 18             	pushl  0x18(%ebp)
    2b1d:	52                   	push   %edx
    2b1e:	8b 55 08             	mov    0x8(%ebp),%edx
    2b21:	ff 72 10             	pushl  0x10(%edx)
    2b24:	ff 72 0c             	pushl  0xc(%edx)
    2b27:	ff 75 f4             	pushl  -0xc(%ebp)
    2b2a:	ff 75 f0             	pushl  -0x10(%ebp)
    2b2d:	50                   	push   %eax
    2b2e:	e8 d4 02 00 00       	call   2e07 <drawCharacter>
    2b33:	83 c4 20             	add    $0x20,%esp
    return 0;
    2b36:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2b3b:	c9                   	leave  
    2b3c:	c3                   	ret    

00002b3d <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    2b3d:	55                   	push   %ebp
    2b3e:	89 e5                	mov    %esp,%ebp
    2b40:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    2b43:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b46:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2b49:	8b 45 10             	mov    0x10(%ebp),%eax
    2b4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2b4f:	8b 45 08             	mov    0x8(%ebp),%eax
    2b52:	8b 40 18             	mov    0x18(%eax),%eax
    2b55:	83 ec 04             	sub    $0x4,%esp
    2b58:	ff 75 18             	pushl  0x18(%ebp)
    2b5b:	ff 75 14             	pushl  0x14(%ebp)
    2b5e:	8b 55 08             	mov    0x8(%ebp),%edx
    2b61:	ff 72 10             	pushl  0x10(%edx)
    2b64:	ff 72 0c             	pushl  0xc(%edx)
    2b67:	ff 75 f4             	pushl  -0xc(%ebp)
    2b6a:	ff 75 f0             	pushl  -0x10(%ebp)
    2b6d:	50                   	push   %eax
    2b6e:	e8 8e 03 00 00       	call   2f01 <drawString>
    2b73:	83 c4 20             	add    $0x20,%esp
    return 0;
    2b76:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2b7b:	c9                   	leave  
    2b7c:	c3                   	ret    

00002b7d <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    2b7d:	55                   	push   %ebp
    2b7e:	89 e5                	mov    %esp,%ebp
    2b80:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    2b83:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    2b87:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    2b8b:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    2b8f:	83 ec 08             	sub    $0x8,%esp
    2b92:	83 ec 04             	sub    $0x4,%esp
    2b95:	89 e0                	mov    %esp,%eax
    2b97:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    2b9b:	66 89 10             	mov    %dx,(%eax)
    2b9e:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    2ba2:	88 50 02             	mov    %dl,0x2(%eax)
    2ba5:	ff 75 18             	pushl  0x18(%ebp)
    2ba8:	ff 75 14             	pushl  0x14(%ebp)
    2bab:	ff 75 10             	pushl  0x10(%ebp)
    2bae:	ff 75 0c             	pushl  0xc(%ebp)
    2bb1:	ff 75 08             	pushl  0x8(%ebp)
    2bb4:	e8 f8 fe ff ff       	call   2ab1 <api_drawRect>
    2bb9:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    2bbc:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    2bc0:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    2bc4:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    2bc8:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    2bcc:	8b 45 10             	mov    0x10(%ebp),%eax
    2bcf:	8d 50 0a             	lea    0xa(%eax),%edx
    2bd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    2bd5:	83 c0 0a             	add    $0xa,%eax
    2bd8:	83 ec 0c             	sub    $0xc,%esp
    2bdb:	ff 75 f4             	pushl  -0xc(%ebp)
    2bde:	ff 75 1c             	pushl  0x1c(%ebp)
    2be1:	52                   	push   %edx
    2be2:	50                   	push   %eax
    2be3:	ff 75 08             	pushl  0x8(%ebp)
    2be6:	e8 52 ff ff ff       	call   2b3d <api_drawString>
    2beb:	83 c4 20             	add    $0x20,%esp
    return 0;
    2bee:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2bf3:	c9                   	leave  
    2bf4:	c3                   	ret    

00002bf5 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    2bf5:	55                   	push   %ebp
    2bf6:	89 e5                	mov    %esp,%ebp
    2bf8:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    2bfb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2c02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2c09:	8b 45 08             	mov    0x8(%ebp),%eax
    2c0c:	8b 40 18             	mov    0x18(%eax),%eax
    2c0f:	ff 75 1c             	pushl  0x1c(%ebp)
    2c12:	ff 75 18             	pushl  0x18(%ebp)
    2c15:	ff 75 1c             	pushl  0x1c(%ebp)
    2c18:	ff 75 18             	pushl  0x18(%ebp)
    2c1b:	8b 55 08             	mov    0x8(%ebp),%edx
    2c1e:	ff 72 10             	pushl  0x10(%edx)
    2c21:	ff 72 0c             	pushl  0xc(%edx)
    2c24:	ff 75 f4             	pushl  -0xc(%ebp)
    2c27:	ff 75 f0             	pushl  -0x10(%ebp)
    2c2a:	ff 75 14             	pushl  0x14(%ebp)
    2c2d:	ff 75 10             	pushl  0x10(%ebp)
    2c30:	ff 75 0c             	pushl  0xc(%ebp)
    2c33:	50                   	push   %eax
    2c34:	e8 16 05 00 00       	call   314f <drawBitmap>
    2c39:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    2c3c:	8b 45 08             	mov    0x8(%ebp),%eax
    2c3f:	8b 40 18             	mov    0x18(%eax),%eax
    2c42:	ff 75 28             	pushl  0x28(%ebp)
    2c45:	ff 75 1c             	pushl  0x1c(%ebp)
    2c48:	ff 75 18             	pushl  0x18(%ebp)
    2c4b:	8b 55 08             	mov    0x8(%ebp),%edx
    2c4e:	ff 72 10             	pushl  0x10(%edx)
    2c51:	ff 72 0c             	pushl  0xc(%edx)
    2c54:	ff 75 14             	pushl  0x14(%ebp)
    2c57:	ff 75 10             	pushl  0x10(%ebp)
    2c5a:	50                   	push   %eax
    2c5b:	e8 99 07 00 00       	call   33f9 <colorShift>
    2c60:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    2c63:	8b 45 08             	mov    0x8(%ebp),%eax
    2c66:	8b 50 18             	mov    0x18(%eax),%edx
    2c69:	83 ec 0c             	sub    $0xc,%esp
    2c6c:	ff 75 20             	pushl  0x20(%ebp)
    2c6f:	ff 75 1c             	pushl  0x1c(%ebp)
    2c72:	ff 75 18             	pushl  0x18(%ebp)
    2c75:	83 ec 04             	sub    $0x4,%esp
    2c78:	89 e0                	mov    %esp,%eax
    2c7a:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    2c7e:	66 89 08             	mov    %cx,(%eax)
    2c81:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    2c85:	88 48 02             	mov    %cl,0x2(%eax)
    2c88:	8b 45 08             	mov    0x8(%ebp),%eax
    2c8b:	ff 70 10             	pushl  0x10(%eax)
    2c8e:	ff 70 0c             	pushl  0xc(%eax)
    2c91:	ff 75 14             	pushl  0x14(%ebp)
    2c94:	ff 75 10             	pushl  0x10(%ebp)
    2c97:	52                   	push   %edx
    2c98:	e8 6d 03 00 00       	call   300a <drawBorder>
    2c9d:	83 c4 30             	add    $0x30,%esp
    return 0;
    2ca0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2ca5:	c9                   	leave  
    2ca6:	c3                   	ret    

00002ca7 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    2ca7:	55                   	push   %ebp
    2ca8:	89 e5                	mov    %esp,%ebp
    2caa:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    2cad:	8b 45 08             	mov    0x8(%ebp),%eax
    2cb0:	8b 00                	mov    (%eax),%eax
    2cb2:	83 ec 0c             	sub    $0xc,%esp
    2cb5:	50                   	push   %eax
    2cb6:	e8 cb ed ff ff       	call   1a86 <destroywindow>
    2cbb:	83 c4 10             	add    $0x10,%esp
    return 0;
    2cbe:	b8 00 00 00 00       	mov    $0x0,%eax
    2cc3:	c9                   	leave  
    2cc4:	c3                   	ret    

00002cc5 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    2cc5:	55                   	push   %ebp
    2cc6:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    2cc8:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    2ccc:	8b 45 08             	mov    0x8(%ebp),%eax
    2ccf:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    2cd2:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    2cd6:	8b 45 08             	mov    0x8(%ebp),%eax
    2cd9:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    2cdc:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    2ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    2ce3:	88 10                	mov    %dl,(%eax)
}
    2ce5:	90                   	nop
    2ce6:	5d                   	pop    %ebp
    2ce7:	c3                   	ret    

00002ce8 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    2ce8:	55                   	push   %ebp
    2ce9:	89 e5                	mov    %esp,%ebp
    2ceb:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    2cee:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    2cf2:	3c ff                	cmp    $0xff,%al
    2cf4:	75 22                	jne    2d18 <drawPointAlpha+0x30>
        color->R = origin.R;
    2cf6:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    2cfa:	8b 45 08             	mov    0x8(%ebp),%eax
    2cfd:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    2d00:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    2d04:	8b 45 08             	mov    0x8(%ebp),%eax
    2d07:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    2d0a:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    2d0e:	8b 45 08             	mov    0x8(%ebp),%eax
    2d11:	88 10                	mov    %dl,(%eax)
        return;
    2d13:	e9 ed 00 00 00       	jmp    2e05 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    2d18:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    2d1c:	84 c0                	test   %al,%al
    2d1e:	0f 84 e0 00 00 00    	je     2e04 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    2d24:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    2d28:	0f b6 c0             	movzbl %al,%eax
    2d2b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2d2f:	df 45 e4             	fild   -0x1c(%ebp)
    2d32:	d9 05 80 b3 01 00    	flds   0x1b380
    2d38:	de f9                	fdivrp %st,%st(1)
    2d3a:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    2d3d:	8b 45 08             	mov    0x8(%ebp),%eax
    2d40:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2d44:	0f b6 c0             	movzbl %al,%eax
    2d47:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2d4a:	db 45 e4             	fildl  -0x1c(%ebp)
    2d4d:	d9 e8                	fld1   
    2d4f:	d8 65 fc             	fsubs  -0x4(%ebp)
    2d52:	de c9                	fmulp  %st,%st(1)
    2d54:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    2d58:	0f b6 c0             	movzbl %al,%eax
    2d5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2d5e:	db 45 e4             	fildl  -0x1c(%ebp)
    2d61:	d8 4d fc             	fmuls  -0x4(%ebp)
    2d64:	de c1                	faddp  %st,%st(1)
    2d66:	d9 7d ee             	fnstcw -0x12(%ebp)
    2d69:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2d6d:	b4 0c                	mov    $0xc,%ah
    2d6f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2d73:	d9 6d ec             	fldcw  -0x14(%ebp)
    2d76:	df 5d ea             	fistp  -0x16(%ebp)
    2d79:	d9 6d ee             	fldcw  -0x12(%ebp)
    2d7c:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    2d80:	89 c2                	mov    %eax,%edx
    2d82:	8b 45 08             	mov    0x8(%ebp),%eax
    2d85:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    2d88:	8b 45 08             	mov    0x8(%ebp),%eax
    2d8b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2d8f:	0f b6 c0             	movzbl %al,%eax
    2d92:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2d95:	db 45 e4             	fildl  -0x1c(%ebp)
    2d98:	d9 e8                	fld1   
    2d9a:	d8 65 fc             	fsubs  -0x4(%ebp)
    2d9d:	de c9                	fmulp  %st,%st(1)
    2d9f:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    2da3:	0f b6 c0             	movzbl %al,%eax
    2da6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2da9:	db 45 e4             	fildl  -0x1c(%ebp)
    2dac:	d8 4d fc             	fmuls  -0x4(%ebp)
    2daf:	de c1                	faddp  %st,%st(1)
    2db1:	d9 6d ec             	fldcw  -0x14(%ebp)
    2db4:	df 5d ea             	fistp  -0x16(%ebp)
    2db7:	d9 6d ee             	fldcw  -0x12(%ebp)
    2dba:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    2dbe:	89 c2                	mov    %eax,%edx
    2dc0:	8b 45 08             	mov    0x8(%ebp),%eax
    2dc3:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    2dc6:	8b 45 08             	mov    0x8(%ebp),%eax
    2dc9:	0f b6 00             	movzbl (%eax),%eax
    2dcc:	0f b6 c0             	movzbl %al,%eax
    2dcf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2dd2:	db 45 e4             	fildl  -0x1c(%ebp)
    2dd5:	d9 e8                	fld1   
    2dd7:	d8 65 fc             	fsubs  -0x4(%ebp)
    2dda:	de c9                	fmulp  %st,%st(1)
    2ddc:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    2de0:	0f b6 c0             	movzbl %al,%eax
    2de3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2de6:	db 45 e4             	fildl  -0x1c(%ebp)
    2de9:	d8 4d fc             	fmuls  -0x4(%ebp)
    2dec:	de c1                	faddp  %st,%st(1)
    2dee:	d9 6d ec             	fldcw  -0x14(%ebp)
    2df1:	df 5d ea             	fistp  -0x16(%ebp)
    2df4:	d9 6d ee             	fldcw  -0x12(%ebp)
    2df7:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    2dfb:	89 c2                	mov    %eax,%edx
    2dfd:	8b 45 08             	mov    0x8(%ebp),%eax
    2e00:	88 10                	mov    %dl,(%eax)
    2e02:	eb 01                	jmp    2e05 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    2e04:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    2e05:	c9                   	leave  
    2e06:	c3                   	ret    

00002e07 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    2e07:	55                   	push   %ebp
    2e08:	89 e5                	mov    %esp,%ebp
    2e0a:	83 ec 14             	sub    $0x14,%esp
    2e0d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2e10:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    2e13:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    2e17:	83 e8 20             	sub    $0x20,%eax
    2e1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    2e1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2e21:	0f 88 d7 00 00 00    	js     2efe <drawCharacter+0xf7>
    2e27:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    2e2b:	0f 8f cd 00 00 00    	jg     2efe <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    2e31:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2e38:	e9 b5 00 00 00       	jmp    2ef2 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    2e3d:	8b 55 10             	mov    0x10(%ebp),%edx
    2e40:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2e43:	01 c2                	add    %eax,%edx
    2e45:	8b 45 14             	mov    0x14(%ebp),%eax
    2e48:	39 c2                	cmp    %eax,%edx
    2e4a:	0f 8f af 00 00 00    	jg     2eff <drawCharacter+0xf8>
    2e50:	8b 55 10             	mov    0x10(%ebp),%edx
    2e53:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2e56:	01 d0                	add    %edx,%eax
    2e58:	85 c0                	test   %eax,%eax
    2e5a:	0f 88 9f 00 00 00    	js     2eff <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    2e60:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2e67:	eb 7b                	jmp    2ee4 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    2e69:	8b 55 fc             	mov    -0x4(%ebp),%edx
    2e6c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    2e6f:	89 d0                	mov    %edx,%eax
    2e71:	c1 e0 03             	shl    $0x3,%eax
    2e74:	01 d0                	add    %edx,%eax
    2e76:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    2e7c:	01 c2                	add    %eax,%edx
    2e7e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2e81:	01 d0                	add    %edx,%eax
    2e83:	05 60 77 01 00       	add    $0x17760,%eax
    2e88:	0f b6 00             	movzbl (%eax),%eax
    2e8b:	3c 01                	cmp    $0x1,%al
    2e8d:	75 51                	jne    2ee0 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    2e8f:	8b 55 0c             	mov    0xc(%ebp),%edx
    2e92:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2e95:	01 c2                	add    %eax,%edx
    2e97:	8b 45 18             	mov    0x18(%ebp),%eax
    2e9a:	39 c2                	cmp    %eax,%edx
    2e9c:	7f 50                	jg     2eee <drawCharacter+0xe7>
    2e9e:	8b 55 0c             	mov    0xc(%ebp),%edx
    2ea1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ea4:	01 d0                	add    %edx,%eax
    2ea6:	85 c0                	test   %eax,%eax
    2ea8:	78 44                	js     2eee <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    2eaa:	8b 55 10             	mov    0x10(%ebp),%edx
    2ead:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2eb0:	01 c2                	add    %eax,%edx
    2eb2:	8b 45 18             	mov    0x18(%ebp),%eax
    2eb5:	0f af c2             	imul   %edx,%eax
    2eb8:	89 c2                	mov    %eax,%edx
    2eba:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ebd:	01 c2                	add    %eax,%edx
    2ebf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ec2:	01 c2                	add    %eax,%edx
    2ec4:	89 d0                	mov    %edx,%eax
    2ec6:	01 c0                	add    %eax,%eax
    2ec8:	01 c2                	add    %eax,%edx
    2eca:	8b 45 08             	mov    0x8(%ebp),%eax
    2ecd:	01 d0                	add    %edx,%eax
    2ecf:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    2ed2:	ff 75 20             	pushl  0x20(%ebp)
    2ed5:	ff 75 f0             	pushl  -0x10(%ebp)
    2ed8:	e8 0b fe ff ff       	call   2ce8 <drawPointAlpha>
    2edd:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    2ee0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2ee4:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    2ee8:	0f 8e 7b ff ff ff    	jle    2e69 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    2eee:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2ef2:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    2ef6:	0f 8e 41 ff ff ff    	jle    2e3d <drawCharacter+0x36>
    2efc:	eb 01                	jmp    2eff <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    2efe:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    2eff:	c9                   	leave  
    2f00:	c3                   	ret    

00002f01 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    2f01:	55                   	push   %ebp
    2f02:	89 e5                	mov    %esp,%ebp
    2f04:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    2f07:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    2f0e:	eb 3d                	jmp    2f4d <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    2f10:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2f13:	0f b6 00             	movzbl (%eax),%eax
    2f16:	0f be c0             	movsbl %al,%eax
    2f19:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2f1c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    2f1f:	01 ca                	add    %ecx,%edx
    2f21:	89 55 f4             	mov    %edx,-0xc(%ebp)
    2f24:	8b 55 10             	mov    0x10(%ebp),%edx
    2f27:	89 55 f8             	mov    %edx,-0x8(%ebp)
    2f2a:	ff 75 20             	pushl  0x20(%ebp)
    2f2d:	50                   	push   %eax
    2f2e:	ff 75 18             	pushl  0x18(%ebp)
    2f31:	ff 75 14             	pushl  0x14(%ebp)
    2f34:	ff 75 f8             	pushl  -0x8(%ebp)
    2f37:	ff 75 f4             	pushl  -0xc(%ebp)
    2f3a:	ff 75 08             	pushl  0x8(%ebp)
    2f3d:	e8 c5 fe ff ff       	call   2e07 <drawCharacter>
    2f42:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    2f45:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    2f49:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    2f4d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2f50:	0f b6 00             	movzbl (%eax),%eax
    2f53:	84 c0                	test   %al,%al
    2f55:	75 b9                	jne    2f10 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    2f57:	90                   	nop
    2f58:	c9                   	leave  
    2f59:	c3                   	ret    

00002f5a <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    2f5a:	55                   	push   %ebp
    2f5b:	89 e5                	mov    %esp,%ebp
    2f5d:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    2f60:	8b 45 20             	mov    0x20(%ebp),%eax
    2f63:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    2f66:	8b 45 24             	mov    0x24(%ebp),%eax
    2f69:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    2f6c:	8b 55 14             	mov    0x14(%ebp),%edx
    2f6f:	8b 45 10             	mov    0x10(%ebp),%eax
    2f72:	29 c2                	sub    %eax,%edx
    2f74:	89 d0                	mov    %edx,%eax
    2f76:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2f79:	7d 0d                	jge    2f88 <drawRect+0x2e>
        draw_h = s.h - p.y;
    2f7b:	8b 55 14             	mov    0x14(%ebp),%edx
    2f7e:	8b 45 10             	mov    0x10(%ebp),%eax
    2f81:	29 c2                	sub    %eax,%edx
    2f83:	89 d0                	mov    %edx,%eax
    2f85:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    2f88:	8b 55 18             	mov    0x18(%ebp),%edx
    2f8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f8e:	29 c2                	sub    %eax,%edx
    2f90:	89 d0                	mov    %edx,%eax
    2f92:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2f95:	7d 0d                	jge    2fa4 <drawRect+0x4a>
        draw_w = s.w - p.x;
    2f97:	8b 55 18             	mov    0x18(%ebp),%edx
    2f9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f9d:	29 c2                	sub    %eax,%edx
    2f9f:	89 d0                	mov    %edx,%eax
    2fa1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2fa4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2fab:	eb 52                	jmp    2fff <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    2fad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2fb4:	eb 3d                	jmp    2ff3 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    2fb6:	8b 55 10             	mov    0x10(%ebp),%edx
    2fb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2fbc:	01 c2                	add    %eax,%edx
    2fbe:	8b 45 18             	mov    0x18(%ebp),%eax
    2fc1:	0f af c2             	imul   %edx,%eax
    2fc4:	89 c2                	mov    %eax,%edx
    2fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
    2fc9:	01 c2                	add    %eax,%edx
    2fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2fce:	01 c2                	add    %eax,%edx
    2fd0:	89 d0                	mov    %edx,%eax
    2fd2:	01 c0                	add    %eax,%eax
    2fd4:	01 c2                	add    %eax,%edx
    2fd6:	8b 45 08             	mov    0x8(%ebp),%eax
    2fd9:	01 d0                	add    %edx,%eax
    2fdb:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    2fde:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2fe1:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2fe5:	66 89 10             	mov    %dx,(%eax)
    2fe8:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2fec:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    2fef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2ff3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ff6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2ff9:	7c bb                	jl     2fb6 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2ffb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2fff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3002:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3005:	7c a6                	jl     2fad <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    3007:	90                   	nop
    3008:	c9                   	leave  
    3009:	c3                   	ret    

0000300a <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    300a:	55                   	push   %ebp
    300b:	89 e5                	mov    %esp,%ebp
    300d:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    3010:	8b 45 28             	mov    0x28(%ebp),%eax
    3013:	89 45 c8             	mov    %eax,-0x38(%ebp)
    3016:	8b 45 24             	mov    0x24(%ebp),%eax
    3019:	89 45 cc             	mov    %eax,-0x34(%ebp)
    301c:	ff 75 cc             	pushl  -0x34(%ebp)
    301f:	ff 75 c8             	pushl  -0x38(%ebp)
    3022:	83 ec 04             	sub    $0x4,%esp
    3025:	89 e0                	mov    %esp,%eax
    3027:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    302b:	66 89 10             	mov    %dx,(%eax)
    302e:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    3032:	88 50 02             	mov    %dl,0x2(%eax)
    3035:	ff 75 18             	pushl  0x18(%ebp)
    3038:	ff 75 14             	pushl  0x14(%ebp)
    303b:	ff 75 10             	pushl  0x10(%ebp)
    303e:	ff 75 0c             	pushl  0xc(%ebp)
    3041:	ff 75 08             	pushl  0x8(%ebp)
    3044:	e8 11 ff ff ff       	call   2f5a <drawRect>
    3049:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    304c:	8b 45 28             	mov    0x28(%ebp),%eax
    304f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    3052:	8b 45 24             	mov    0x24(%ebp),%eax
    3055:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    3058:	8b 45 0c             	mov    0xc(%ebp),%eax
    305b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    305e:	8b 55 10             	mov    0x10(%ebp),%edx
    3061:	8b 45 20             	mov    0x20(%ebp),%eax
    3064:	01 d0                	add    %edx,%eax
    3066:	2b 45 28             	sub    0x28(%ebp),%eax
    3069:	89 45 dc             	mov    %eax,-0x24(%ebp)
    306c:	ff 75 d4             	pushl  -0x2c(%ebp)
    306f:	ff 75 d0             	pushl  -0x30(%ebp)
    3072:	83 ec 04             	sub    $0x4,%esp
    3075:	89 e0                	mov    %esp,%eax
    3077:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    307b:	66 89 10             	mov    %dx,(%eax)
    307e:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    3082:	88 50 02             	mov    %dl,0x2(%eax)
    3085:	ff 75 18             	pushl  0x18(%ebp)
    3088:	ff 75 14             	pushl  0x14(%ebp)
    308b:	ff 75 dc             	pushl  -0x24(%ebp)
    308e:	ff 75 d8             	pushl  -0x28(%ebp)
    3091:	ff 75 08             	pushl  0x8(%ebp)
    3094:	e8 c1 fe ff ff       	call   2f5a <drawRect>
    3099:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    309c:	8b 45 20             	mov    0x20(%ebp),%eax
    309f:	8b 55 28             	mov    0x28(%ebp),%edx
    30a2:	01 d2                	add    %edx,%edx
    30a4:	29 d0                	sub    %edx,%eax
    30a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    30a9:	8b 45 28             	mov    0x28(%ebp),%eax
    30ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    30af:	8b 45 0c             	mov    0xc(%ebp),%eax
    30b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    30b5:	8b 55 10             	mov    0x10(%ebp),%edx
    30b8:	8b 45 28             	mov    0x28(%ebp),%eax
    30bb:	01 d0                	add    %edx,%eax
    30bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    30c0:	ff 75 e4             	pushl  -0x1c(%ebp)
    30c3:	ff 75 e0             	pushl  -0x20(%ebp)
    30c6:	83 ec 04             	sub    $0x4,%esp
    30c9:	89 e0                	mov    %esp,%eax
    30cb:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    30cf:	66 89 10             	mov    %dx,(%eax)
    30d2:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    30d6:	88 50 02             	mov    %dl,0x2(%eax)
    30d9:	ff 75 18             	pushl  0x18(%ebp)
    30dc:	ff 75 14             	pushl  0x14(%ebp)
    30df:	ff 75 ec             	pushl  -0x14(%ebp)
    30e2:	ff 75 e8             	pushl  -0x18(%ebp)
    30e5:	ff 75 08             	pushl  0x8(%ebp)
    30e8:	e8 6d fe ff ff       	call   2f5a <drawRect>
    30ed:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    30f0:	8b 45 20             	mov    0x20(%ebp),%eax
    30f3:	8b 55 28             	mov    0x28(%ebp),%edx
    30f6:	01 d2                	add    %edx,%edx
    30f8:	29 d0                	sub    %edx,%eax
    30fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    30fd:	8b 45 28             	mov    0x28(%ebp),%eax
    3100:	89 45 f4             	mov    %eax,-0xc(%ebp)
    3103:	8b 55 0c             	mov    0xc(%ebp),%edx
    3106:	8b 45 24             	mov    0x24(%ebp),%eax
    3109:	01 d0                	add    %edx,%eax
    310b:	2b 45 28             	sub    0x28(%ebp),%eax
    310e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3111:	8b 55 10             	mov    0x10(%ebp),%edx
    3114:	8b 45 28             	mov    0x28(%ebp),%eax
    3117:	01 d0                	add    %edx,%eax
    3119:	89 45 fc             	mov    %eax,-0x4(%ebp)
    311c:	ff 75 f4             	pushl  -0xc(%ebp)
    311f:	ff 75 f0             	pushl  -0x10(%ebp)
    3122:	83 ec 04             	sub    $0x4,%esp
    3125:	89 e0                	mov    %esp,%eax
    3127:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    312b:	66 89 10             	mov    %dx,(%eax)
    312e:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    3132:	88 50 02             	mov    %dl,0x2(%eax)
    3135:	ff 75 18             	pushl  0x18(%ebp)
    3138:	ff 75 14             	pushl  0x14(%ebp)
    313b:	ff 75 fc             	pushl  -0x4(%ebp)
    313e:	ff 75 f8             	pushl  -0x8(%ebp)
    3141:	ff 75 08             	pushl  0x8(%ebp)
    3144:	e8 11 fe ff ff       	call   2f5a <drawRect>
    3149:	83 c4 20             	add    $0x20,%esp
}
    314c:	90                   	nop
    314d:	c9                   	leave  
    314e:	c3                   	ret    

0000314f <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    314f:	55                   	push   %ebp
    3150:	89 e5                	mov    %esp,%ebp
    3152:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    3155:	8b 45 30             	mov    0x30(%ebp),%eax
    3158:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    315b:	8b 45 34             	mov    0x34(%ebp),%eax
    315e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    3161:	8b 55 20             	mov    0x20(%ebp),%edx
    3164:	8b 45 14             	mov    0x14(%ebp),%eax
    3167:	29 c2                	sub    %eax,%edx
    3169:	89 d0                	mov    %edx,%eax
    316b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    316e:	7d 0d                	jge    317d <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    3170:	8b 55 20             	mov    0x20(%ebp),%edx
    3173:	8b 45 14             	mov    0x14(%ebp),%eax
    3176:	29 c2                	sub    %eax,%edx
    3178:	89 d0                	mov    %edx,%eax
    317a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    317d:	8b 55 28             	mov    0x28(%ebp),%edx
    3180:	8b 45 1c             	mov    0x1c(%ebp),%eax
    3183:	29 c2                	sub    %eax,%edx
    3185:	89 d0                	mov    %edx,%eax
    3187:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    318a:	7d 0d                	jge    3199 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    318c:	8b 55 28             	mov    0x28(%ebp),%edx
    318f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    3192:	29 c2                	sub    %eax,%edx
    3194:	89 d0                	mov    %edx,%eax
    3196:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    3199:	8b 55 24             	mov    0x24(%ebp),%edx
    319c:	8b 45 10             	mov    0x10(%ebp),%eax
    319f:	29 c2                	sub    %eax,%edx
    31a1:	89 d0                	mov    %edx,%eax
    31a3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    31a6:	7d 0d                	jge    31b5 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    31a8:	8b 55 24             	mov    0x24(%ebp),%edx
    31ab:	8b 45 10             	mov    0x10(%ebp),%eax
    31ae:	29 c2                	sub    %eax,%edx
    31b0:	89 d0                	mov    %edx,%eax
    31b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    31b5:	8b 55 2c             	mov    0x2c(%ebp),%edx
    31b8:	8b 45 18             	mov    0x18(%ebp),%eax
    31bb:	29 c2                	sub    %eax,%edx
    31bd:	89 d0                	mov    %edx,%eax
    31bf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    31c2:	7d 0d                	jge    31d1 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    31c4:	8b 55 2c             	mov    0x2c(%ebp),%edx
    31c7:	8b 45 18             	mov    0x18(%ebp),%eax
    31ca:	29 c2                	sub    %eax,%edx
    31cc:	89 d0                	mov    %edx,%eax
    31ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    31d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    31d8:	e9 83 00 00 00       	jmp    3260 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    31dd:	8b 55 14             	mov    0x14(%ebp),%edx
    31e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    31e3:	01 d0                	add    %edx,%eax
    31e5:	85 c0                	test   %eax,%eax
    31e7:	78 72                	js     325b <drawBitmap+0x10c>
    31e9:	8b 55 14             	mov    0x14(%ebp),%edx
    31ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    31ef:	01 c2                	add    %eax,%edx
    31f1:	8b 45 20             	mov    0x20(%ebp),%eax
    31f4:	39 c2                	cmp    %eax,%edx
    31f6:	7d 63                	jge    325b <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    31f8:	8b 55 14             	mov    0x14(%ebp),%edx
    31fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    31fe:	01 c2                	add    %eax,%edx
    3200:	8b 45 24             	mov    0x24(%ebp),%eax
    3203:	0f af c2             	imul   %edx,%eax
    3206:	89 c2                	mov    %eax,%edx
    3208:	8b 45 10             	mov    0x10(%ebp),%eax
    320b:	01 c2                	add    %eax,%edx
    320d:	89 d0                	mov    %edx,%eax
    320f:	01 c0                	add    %eax,%eax
    3211:	01 c2                	add    %eax,%edx
    3213:	8b 45 08             	mov    0x8(%ebp),%eax
    3216:	01 d0                	add    %edx,%eax
    3218:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    321b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    321e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3221:	01 c2                	add    %eax,%edx
    3223:	8b 45 2c             	mov    0x2c(%ebp),%eax
    3226:	0f af c2             	imul   %edx,%eax
    3229:	89 c2                	mov    %eax,%edx
    322b:	8b 45 18             	mov    0x18(%ebp),%eax
    322e:	01 c2                	add    %eax,%edx
    3230:	89 d0                	mov    %edx,%eax
    3232:	01 c0                	add    %eax,%eax
    3234:	01 c2                	add    %eax,%edx
    3236:	8b 45 0c             	mov    0xc(%ebp),%eax
    3239:	01 d0                	add    %edx,%eax
    323b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    323e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3241:	89 d0                	mov    %edx,%eax
    3243:	01 c0                	add    %eax,%eax
    3245:	01 d0                	add    %edx,%eax
    3247:	83 ec 04             	sub    $0x4,%esp
    324a:	50                   	push   %eax
    324b:	ff 75 e4             	pushl  -0x1c(%ebp)
    324e:	ff 75 e8             	pushl  -0x18(%ebp)
    3251:	e8 23 e7 ff ff       	call   1979 <memmove>
    3256:	83 c4 10             	add    $0x10,%esp
    3259:	eb 01                	jmp    325c <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    325b:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    325c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    3260:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3263:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3266:	0f 8c 71 ff ff ff    	jl     31dd <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    326c:	90                   	nop
    326d:	c9                   	leave  
    326e:	c3                   	ret    

0000326f <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    326f:	55                   	push   %ebp
    3270:	89 e5                	mov    %esp,%ebp
    3272:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    3275:	8b 45 30             	mov    0x30(%ebp),%eax
    3278:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    327b:	8b 45 34             	mov    0x34(%ebp),%eax
    327e:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    3281:	8b 55 20             	mov    0x20(%ebp),%edx
    3284:	8b 45 14             	mov    0x14(%ebp),%eax
    3287:	29 c2                	sub    %eax,%edx
    3289:	89 d0                	mov    %edx,%eax
    328b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    328e:	7d 0d                	jge    329d <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    3290:	8b 55 20             	mov    0x20(%ebp),%edx
    3293:	8b 45 14             	mov    0x14(%ebp),%eax
    3296:	29 c2                	sub    %eax,%edx
    3298:	89 d0                	mov    %edx,%eax
    329a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    329d:	8b 55 28             	mov    0x28(%ebp),%edx
    32a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    32a3:	29 c2                	sub    %eax,%edx
    32a5:	89 d0                	mov    %edx,%eax
    32a7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    32aa:	7d 0d                	jge    32b9 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    32ac:	8b 55 28             	mov    0x28(%ebp),%edx
    32af:	8b 45 1c             	mov    0x1c(%ebp),%eax
    32b2:	29 c2                	sub    %eax,%edx
    32b4:	89 d0                	mov    %edx,%eax
    32b6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    32b9:	8b 55 24             	mov    0x24(%ebp),%edx
    32bc:	8b 45 10             	mov    0x10(%ebp),%eax
    32bf:	29 c2                	sub    %eax,%edx
    32c1:	89 d0                	mov    %edx,%eax
    32c3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    32c6:	7d 0d                	jge    32d5 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    32c8:	8b 55 24             	mov    0x24(%ebp),%edx
    32cb:	8b 45 10             	mov    0x10(%ebp),%eax
    32ce:	29 c2                	sub    %eax,%edx
    32d0:	89 d0                	mov    %edx,%eax
    32d2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    32d5:	8b 55 2c             	mov    0x2c(%ebp),%edx
    32d8:	8b 45 18             	mov    0x18(%ebp),%eax
    32db:	29 c2                	sub    %eax,%edx
    32dd:	89 d0                	mov    %edx,%eax
    32df:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    32e2:	7d 0d                	jge    32f1 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    32e4:	8b 55 2c             	mov    0x2c(%ebp),%edx
    32e7:	8b 45 18             	mov    0x18(%ebp),%eax
    32ea:	29 c2                	sub    %eax,%edx
    32ec:	89 d0                	mov    %edx,%eax
    32ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    32f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    32f8:	e9 b8 00 00 00       	jmp    33b5 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    32fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3304:	e9 9c 00 00 00       	jmp    33a5 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    3309:	8b 55 14             	mov    0x14(%ebp),%edx
    330c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    330f:	01 c2                	add    %eax,%edx
    3311:	8b 45 24             	mov    0x24(%ebp),%eax
    3314:	0f af c2             	imul   %edx,%eax
    3317:	89 c2                	mov    %eax,%edx
    3319:	8b 45 10             	mov    0x10(%ebp),%eax
    331c:	01 c2                	add    %eax,%edx
    331e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3321:	01 c2                	add    %eax,%edx
    3323:	89 d0                	mov    %edx,%eax
    3325:	01 c0                	add    %eax,%eax
    3327:	01 c2                	add    %eax,%edx
    3329:	8b 45 08             	mov    0x8(%ebp),%eax
    332c:	01 d0                	add    %edx,%eax
    332e:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    3331:	8b 55 1c             	mov    0x1c(%ebp),%edx
    3334:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3337:	01 c2                	add    %eax,%edx
    3339:	8b 45 2c             	mov    0x2c(%ebp),%eax
    333c:	0f af c2             	imul   %edx,%eax
    333f:	89 c2                	mov    %eax,%edx
    3341:	8b 45 18             	mov    0x18(%ebp),%eax
    3344:	01 c2                	add    %eax,%edx
    3346:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3349:	01 c2                	add    %eax,%edx
    334b:	89 d0                	mov    %edx,%eax
    334d:	01 c0                	add    %eax,%eax
    334f:	01 c2                	add    %eax,%edx
    3351:	8b 45 0c             	mov    0xc(%ebp),%eax
    3354:	01 d0                	add    %edx,%eax
    3356:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    3359:	8b 45 e8             	mov    -0x18(%ebp),%eax
    335c:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3360:	3c ff                	cmp    $0xff,%al
    3362:	75 15                	jne    3379 <drawTransparentBitmap+0x10a>
    3364:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3367:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    336b:	3c ff                	cmp    $0xff,%al
    336d:	75 0a                	jne    3379 <drawTransparentBitmap+0x10a>
    336f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3372:	0f b6 00             	movzbl (%eax),%eax
    3375:	3c ff                	cmp    $0xff,%al
    3377:	74 27                	je     33a0 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    3379:	8b 45 e8             	mov    -0x18(%ebp),%eax
    337c:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    3380:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3383:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    3386:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3389:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    338d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3390:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    3393:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3396:	0f b6 10             	movzbl (%eax),%edx
    3399:	8b 45 ec             	mov    -0x14(%ebp),%eax
    339c:	88 10                	mov    %dl,(%eax)
    339e:	eb 01                	jmp    33a1 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    33a0:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    33a1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    33a5:	8b 45 34             	mov    0x34(%ebp),%eax
    33a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    33ab:	0f 8f 58 ff ff ff    	jg     3309 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    33b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    33b5:	8b 45 30             	mov    0x30(%ebp),%eax
    33b8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    33bb:	0f 8f 3c ff ff ff    	jg     32fd <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    33c1:	90                   	nop
    33c2:	c9                   	leave  
    33c3:	c3                   	ret    

000033c4 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    33c4:	55                   	push   %ebp
    33c5:	89 e5                	mov    %esp,%ebp
    33c7:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    33ca:	ff 75 24             	pushl  0x24(%ebp)
    33cd:	ff 75 20             	pushl  0x20(%ebp)
    33d0:	ff 75 1c             	pushl  0x1c(%ebp)
    33d3:	ff 75 18             	pushl  0x18(%ebp)
    33d6:	ff 75 1c             	pushl  0x1c(%ebp)
    33d9:	ff 75 18             	pushl  0x18(%ebp)
    33dc:	ff 75 14             	pushl  0x14(%ebp)
    33df:	ff 75 10             	pushl  0x10(%ebp)
    33e2:	ff 75 14             	pushl  0x14(%ebp)
    33e5:	ff 75 10             	pushl  0x10(%ebp)
    33e8:	ff 75 0c             	pushl  0xc(%ebp)
    33eb:	ff 75 08             	pushl  0x8(%ebp)
    33ee:	e8 5c fd ff ff       	call   314f <drawBitmap>
    33f3:	83 c4 30             	add    $0x30,%esp
}
    33f6:	90                   	nop
    33f7:	c9                   	leave  
    33f8:	c3                   	ret    

000033f9 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    33f9:	55                   	push   %ebp
    33fa:	89 e5                	mov    %esp,%ebp
    33fc:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    33ff:	8b 45 1c             	mov    0x1c(%ebp),%eax
    3402:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    3405:	8b 45 20             	mov    0x20(%ebp),%eax
    3408:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    340b:	8b 55 14             	mov    0x14(%ebp),%edx
    340e:	8b 45 10             	mov    0x10(%ebp),%eax
    3411:	29 c2                	sub    %eax,%edx
    3413:	89 d0                	mov    %edx,%eax
    3415:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3418:	7d 0d                	jge    3427 <colorShift+0x2e>
        draw_h = s.h - p.y;
    341a:	8b 55 14             	mov    0x14(%ebp),%edx
    341d:	8b 45 10             	mov    0x10(%ebp),%eax
    3420:	29 c2                	sub    %eax,%edx
    3422:	89 d0                	mov    %edx,%eax
    3424:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    3427:	8b 55 18             	mov    0x18(%ebp),%edx
    342a:	8b 45 0c             	mov    0xc(%ebp),%eax
    342d:	29 c2                	sub    %eax,%edx
    342f:	89 d0                	mov    %edx,%eax
    3431:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    3434:	7d 0d                	jge    3443 <colorShift+0x4a>
        draw_w = s.w - p.x;
    3436:	8b 55 18             	mov    0x18(%ebp),%edx
    3439:	8b 45 0c             	mov    0xc(%ebp),%eax
    343c:	29 c2                	sub    %eax,%edx
    343e:	89 d0                	mov    %edx,%eax
    3440:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    3443:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    344a:	e9 fc 00 00 00       	jmp    354b <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    344f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3456:	e9 e0 00 00 00       	jmp    353b <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    345b:	8b 55 10             	mov    0x10(%ebp),%edx
    345e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3461:	01 c2                	add    %eax,%edx
    3463:	8b 45 18             	mov    0x18(%ebp),%eax
    3466:	0f af c2             	imul   %edx,%eax
    3469:	89 c2                	mov    %eax,%edx
    346b:	8b 45 0c             	mov    0xc(%ebp),%eax
    346e:	01 c2                	add    %eax,%edx
    3470:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3473:	01 c2                	add    %eax,%edx
    3475:	89 d0                	mov    %edx,%eax
    3477:	01 c0                	add    %eax,%eax
    3479:	01 c2                	add    %eax,%edx
    347b:	8b 45 08             	mov    0x8(%ebp),%eax
    347e:	01 d0                	add    %edx,%eax
    3480:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    3483:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3486:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    348a:	3c c8                	cmp    $0xc8,%al
    348c:	0f 86 a5 00 00 00    	jbe    3537 <colorShift+0x13e>
    3492:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3495:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3499:	3c c8                	cmp    $0xc8,%al
    349b:	0f 86 96 00 00 00    	jbe    3537 <colorShift+0x13e>
    34a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    34a4:	0f b6 00             	movzbl (%eax),%eax
    34a7:	3c c8                	cmp    $0xc8,%al
    34a9:	0f 86 88 00 00 00    	jbe    3537 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    34af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    34b2:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    34b6:	0f b6 d0             	movzbl %al,%edx
    34b9:	8b 45 24             	mov    0x24(%ebp),%eax
    34bc:	01 d0                	add    %edx,%eax
    34be:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    34c4:	89 d0                	mov    %edx,%eax
    34c6:	c1 f8 1f             	sar    $0x1f,%eax
    34c9:	c1 e8 18             	shr    $0x18,%eax
    34cc:	01 c2                	add    %eax,%edx
    34ce:	0f b6 d2             	movzbl %dl,%edx
    34d1:	29 c2                	sub    %eax,%edx
    34d3:	89 d0                	mov    %edx,%eax
    34d5:	89 c2                	mov    %eax,%edx
    34d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    34da:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    34dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    34e0:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    34e4:	0f b6 d0             	movzbl %al,%edx
    34e7:	8b 45 24             	mov    0x24(%ebp),%eax
    34ea:	01 d0                	add    %edx,%eax
    34ec:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    34f2:	89 d0                	mov    %edx,%eax
    34f4:	c1 f8 1f             	sar    $0x1f,%eax
    34f7:	c1 e8 18             	shr    $0x18,%eax
    34fa:	01 c2                	add    %eax,%edx
    34fc:	0f b6 d2             	movzbl %dl,%edx
    34ff:	29 c2                	sub    %eax,%edx
    3501:	89 d0                	mov    %edx,%eax
    3503:	89 c2                	mov    %eax,%edx
    3505:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3508:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    350b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    350e:	0f b6 00             	movzbl (%eax),%eax
    3511:	0f b6 d0             	movzbl %al,%edx
    3514:	8b 45 24             	mov    0x24(%ebp),%eax
    3517:	01 d0                	add    %edx,%eax
    3519:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    351f:	89 d0                	mov    %edx,%eax
    3521:	c1 f8 1f             	sar    $0x1f,%eax
    3524:	c1 e8 18             	shr    $0x18,%eax
    3527:	01 c2                	add    %eax,%edx
    3529:	0f b6 d2             	movzbl %dl,%edx
    352c:	29 c2                	sub    %eax,%edx
    352e:	89 d0                	mov    %edx,%eax
    3530:	89 c2                	mov    %eax,%edx
    3532:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3535:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    3537:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    353b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    353e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    3541:	0f 8c 14 ff ff ff    	jl     345b <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    3547:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    354b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    354e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3551:	0f 8c f8 fe ff ff    	jl     344f <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    3557:	90                   	nop
    3558:	c9                   	leave  
    3559:	c3                   	ret    

0000355a <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    355a:	55                   	push   %ebp
    355b:	89 e5                	mov    %esp,%ebp
    355d:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    3560:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3567:	e9 fb 00 00 00       	jmp    3667 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    356c:	8b 55 14             	mov    0x14(%ebp),%edx
    356f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3572:	01 c2                	add    %eax,%edx
    3574:	0f b7 05 34 fe 01 00 	movzwl 0x1fe34,%eax
    357b:	0f b7 c0             	movzwl %ax,%eax
    357e:	39 c2                	cmp    %eax,%edx
    3580:	0f 8f eb 00 00 00    	jg     3671 <drawMouse+0x117>
    3586:	8b 55 14             	mov    0x14(%ebp),%edx
    3589:	8b 45 fc             	mov    -0x4(%ebp),%eax
    358c:	01 d0                	add    %edx,%eax
    358e:	85 c0                	test   %eax,%eax
    3590:	0f 88 db 00 00 00    	js     3671 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    3596:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    359d:	e9 b7 00 00 00       	jmp    3659 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    35a2:	8b 55 10             	mov    0x10(%ebp),%edx
    35a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35a8:	01 c2                	add    %eax,%edx
    35aa:	0f b7 05 2c fd 01 00 	movzwl 0x1fd2c,%eax
    35b1:	0f b7 c0             	movzwl %ax,%eax
    35b4:	39 c2                	cmp    %eax,%edx
    35b6:	0f 8f a7 00 00 00    	jg     3663 <drawMouse+0x109>
    35bc:	8b 55 10             	mov    0x10(%ebp),%edx
    35bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35c2:	01 d0                	add    %edx,%eax
    35c4:	85 c0                	test   %eax,%eax
    35c6:	0f 88 97 00 00 00    	js     3663 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    35cc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    35cf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    35d2:	89 d0                	mov    %edx,%eax
    35d4:	c1 e0 04             	shl    $0x4,%eax
    35d7:	29 d0                	sub    %edx,%eax
    35d9:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    35df:	01 c2                	add    %eax,%edx
    35e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35e4:	01 d0                	add    %edx,%eax
    35e6:	05 40 75 01 00       	add    $0x17540,%eax
    35eb:	0f b6 00             	movzbl (%eax),%eax
    35ee:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    35f1:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    35f5:	74 5e                	je     3655 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    35f7:	8b 55 14             	mov    0x14(%ebp),%edx
    35fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    35fd:	01 c2                	add    %eax,%edx
    35ff:	0f b7 05 2c fd 01 00 	movzwl 0x1fd2c,%eax
    3606:	0f b7 c0             	movzwl %ax,%eax
    3609:	0f af c2             	imul   %edx,%eax
    360c:	89 c2                	mov    %eax,%edx
    360e:	8b 45 10             	mov    0x10(%ebp),%eax
    3611:	01 c2                	add    %eax,%edx
    3613:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3616:	01 c2                	add    %eax,%edx
    3618:	89 d0                	mov    %edx,%eax
    361a:	01 c0                	add    %eax,%eax
    361c:	01 c2                	add    %eax,%edx
    361e:	8b 45 08             	mov    0x8(%ebp),%eax
    3621:	01 d0                	add    %edx,%eax
    3623:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    3626:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    362a:	8d 50 ff             	lea    -0x1(%eax),%edx
    362d:	89 d0                	mov    %edx,%eax
    362f:	01 c0                	add    %eax,%eax
    3631:	01 d0                	add    %edx,%eax
    3633:	05 74 fe 01 00       	add    $0x1fe74,%eax
    3638:	83 ec 04             	sub    $0x4,%esp
    363b:	89 e2                	mov    %esp,%edx
    363d:	0f b7 08             	movzwl (%eax),%ecx
    3640:	66 89 0a             	mov    %cx,(%edx)
    3643:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3647:	88 42 02             	mov    %al,0x2(%edx)
    364a:	ff 75 f0             	pushl  -0x10(%ebp)
    364d:	e8 73 f6 ff ff       	call   2cc5 <drawPoint>
    3652:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    3655:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3659:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    365d:	0f 8e 3f ff ff ff    	jle    35a2 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    3663:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3667:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    366b:	0f 8e fb fe ff ff    	jle    356c <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    3671:	90                   	nop
    3672:	c9                   	leave  
    3673:	c3                   	ret    

00003674 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    3674:	55                   	push   %ebp
    3675:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    3677:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    367b:	78 1b                	js     3698 <getColor+0x24>
    367d:	8b 45 08             	mov    0x8(%ebp),%eax
    3680:	8b 40 04             	mov    0x4(%eax),%eax
    3683:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3686:	7c 10                	jl     3698 <getColor+0x24>
    3688:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    368c:	78 0a                	js     3698 <getColor+0x24>
    368e:	8b 45 08             	mov    0x8(%ebp),%eax
    3691:	8b 00                	mov    (%eax),%eax
    3693:	3b 45 10             	cmp    0x10(%ebp),%eax
    3696:	7d 10                	jge    36a8 <getColor+0x34>
    {
        *isInPic = 1;
    3698:	8b 45 14             	mov    0x14(%ebp),%eax
    369b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    36a1:	b8 ad f8 01 00       	mov    $0x1f8ad,%eax
    36a6:	eb 44                	jmp    36ec <getColor+0x78>
    }

    if (y == pic->height)
    36a8:	8b 45 08             	mov    0x8(%ebp),%eax
    36ab:	8b 40 04             	mov    0x4(%eax),%eax
    36ae:	3b 45 0c             	cmp    0xc(%ebp),%eax
    36b1:	75 04                	jne    36b7 <getColor+0x43>
        y--;
    36b3:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    36b7:	8b 45 08             	mov    0x8(%ebp),%eax
    36ba:	8b 00                	mov    (%eax),%eax
    36bc:	3b 45 10             	cmp    0x10(%ebp),%eax
    36bf:	75 04                	jne    36c5 <getColor+0x51>
        x--;
    36c1:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    36c5:	8b 45 14             	mov    0x14(%ebp),%eax
    36c8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    36ce:	8b 45 08             	mov    0x8(%ebp),%eax
    36d1:	8b 48 08             	mov    0x8(%eax),%ecx
    36d4:	8b 45 08             	mov    0x8(%ebp),%eax
    36d7:	8b 00                	mov    (%eax),%eax
    36d9:	0f af 45 0c          	imul   0xc(%ebp),%eax
    36dd:	89 c2                	mov    %eax,%edx
    36df:	8b 45 10             	mov    0x10(%ebp),%eax
    36e2:	01 c2                	add    %eax,%edx
    36e4:	89 d0                	mov    %edx,%eax
    36e6:	01 c0                	add    %eax,%eax
    36e8:	01 d0                	add    %edx,%eax
    36ea:	01 c8                	add    %ecx,%eax
}
    36ec:	5d                   	pop    %ebp
    36ed:	c3                   	ret    

000036ee <setColor>:

int setColor(RGB *src, RGB *dst)
{
    36ee:	55                   	push   %ebp
    36ef:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    36f1:	8b 45 08             	mov    0x8(%ebp),%eax
    36f4:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    36f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    36fb:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    36fe:	8b 45 08             	mov    0x8(%ebp),%eax
    3701:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    3705:	8b 45 0c             	mov    0xc(%ebp),%eax
    3708:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    370b:	8b 45 08             	mov    0x8(%ebp),%eax
    370e:	0f b6 10             	movzbl (%eax),%edx
    3711:	8b 45 0c             	mov    0xc(%ebp),%eax
    3714:	88 10                	mov    %dl,(%eax)

    return 1;
    3716:	b8 01 00 00 00       	mov    $0x1,%eax
}
    371b:	5d                   	pop    %ebp
    371c:	c3                   	ret    

0000371d <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    371d:	55                   	push   %ebp
    371e:	89 e5                	mov    %esp,%ebp
    3720:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    3723:	d9 45 10             	flds   0x10(%ebp)
    3726:	d9 7d be             	fnstcw -0x42(%ebp)
    3729:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    372d:	b4 0c                	mov    $0xc,%ah
    372f:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    3733:	d9 6d bc             	fldcw  -0x44(%ebp)
    3736:	db 5d fc             	fistpl -0x4(%ebp)
    3739:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    373c:	d9 45 0c             	flds   0xc(%ebp)
    373f:	d9 6d bc             	fldcw  -0x44(%ebp)
    3742:	db 5d f8             	fistpl -0x8(%ebp)
    3745:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    3748:	db 45 fc             	fildl  -0x4(%ebp)
    374b:	d9 45 10             	flds   0x10(%ebp)
    374e:	d9 c9                	fxch   %st(1)
    3750:	df e9                	fucomip %st(1),%st
    3752:	dd d8                	fstp   %st(0)
    3754:	76 04                	jbe    375a <mixColor+0x3d>
        x--;
    3756:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    375a:	db 45 f8             	fildl  -0x8(%ebp)
    375d:	d9 45 0c             	flds   0xc(%ebp)
    3760:	d9 c9                	fxch   %st(1)
    3762:	df e9                	fucomip %st(1),%st
    3764:	dd d8                	fstp   %st(0)
    3766:	76 04                	jbe    376c <mixColor+0x4f>
        y--;
    3768:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    376c:	8d 45 c0             	lea    -0x40(%ebp),%eax
    376f:	50                   	push   %eax
    3770:	ff 75 fc             	pushl  -0x4(%ebp)
    3773:	ff 75 f8             	pushl  -0x8(%ebp)
    3776:	ff 75 08             	pushl  0x8(%ebp)
    3779:	e8 f6 fe ff ff       	call   3674 <getColor>
    377e:	83 c4 10             	add    $0x10,%esp
    3781:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    3784:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3787:	83 c0 01             	add    $0x1,%eax
    378a:	8d 55 c0             	lea    -0x40(%ebp),%edx
    378d:	83 c2 04             	add    $0x4,%edx
    3790:	52                   	push   %edx
    3791:	ff 75 fc             	pushl  -0x4(%ebp)
    3794:	50                   	push   %eax
    3795:	ff 75 08             	pushl  0x8(%ebp)
    3798:	e8 d7 fe ff ff       	call   3674 <getColor>
    379d:	83 c4 10             	add    $0x10,%esp
    37a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    37a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    37a6:	83 c0 01             	add    $0x1,%eax
    37a9:	8d 55 c0             	lea    -0x40(%ebp),%edx
    37ac:	83 c2 08             	add    $0x8,%edx
    37af:	52                   	push   %edx
    37b0:	50                   	push   %eax
    37b1:	ff 75 f8             	pushl  -0x8(%ebp)
    37b4:	ff 75 08             	pushl  0x8(%ebp)
    37b7:	e8 b8 fe ff ff       	call   3674 <getColor>
    37bc:	83 c4 10             	add    $0x10,%esp
    37bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    37c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    37c5:	8d 50 01             	lea    0x1(%eax),%edx
    37c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    37cb:	83 c0 01             	add    $0x1,%eax
    37ce:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    37d1:	83 c1 0c             	add    $0xc,%ecx
    37d4:	51                   	push   %ecx
    37d5:	52                   	push   %edx
    37d6:	50                   	push   %eax
    37d7:	ff 75 08             	pushl  0x8(%ebp)
    37da:	e8 95 fe ff ff       	call   3674 <getColor>
    37df:	83 c4 10             	add    $0x10,%esp
    37e2:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    37e5:	db 45 fc             	fildl  -0x4(%ebp)
    37e8:	d9 45 10             	flds   0x10(%ebp)
    37eb:	de e1                	fsubp  %st,%st(1)
    37ed:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    37f0:	db 45 f8             	fildl  -0x8(%ebp)
    37f3:	d9 45 0c             	flds   0xc(%ebp)
    37f6:	de e1                	fsubp  %st,%st(1)
    37f8:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    37fb:	d9 45 e4             	flds   -0x1c(%ebp)
    37fe:	d8 4d e0             	fmuls  -0x20(%ebp)
    3801:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    3804:	d9 e8                	fld1   
    3806:	d8 65 e0             	fsubs  -0x20(%ebp)
    3809:	d8 4d e4             	fmuls  -0x1c(%ebp)
    380c:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    380f:	d9 e8                	fld1   
    3811:	d8 65 e4             	fsubs  -0x1c(%ebp)
    3814:	d8 4d e0             	fmuls  -0x20(%ebp)
    3817:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    381a:	d9 e8                	fld1   
    381c:	d8 65 e4             	fsubs  -0x1c(%ebp)
    381f:	d9 e8                	fld1   
    3821:	d8 65 e0             	fsubs  -0x20(%ebp)
    3824:	de c9                	fmulp  %st,%st(1)
    3826:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    3829:	8b 45 f4             	mov    -0xc(%ebp),%eax
    382c:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3830:	0f b6 c0             	movzbl %al,%eax
    3833:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3836:	db 45 b4             	fildl  -0x4c(%ebp)
    3839:	d8 4d d0             	fmuls  -0x30(%ebp)
    383c:	8b 45 c0             	mov    -0x40(%ebp),%eax
    383f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3842:	db 45 b4             	fildl  -0x4c(%ebp)
    3845:	de c9                	fmulp  %st,%st(1)
    3847:	8b 45 f0             	mov    -0x10(%ebp),%eax
    384a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    384e:	0f b6 c0             	movzbl %al,%eax
    3851:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3854:	db 45 b4             	fildl  -0x4c(%ebp)
    3857:	d8 4d d4             	fmuls  -0x2c(%ebp)
    385a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    385d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3860:	db 45 b4             	fildl  -0x4c(%ebp)
    3863:	de c9                	fmulp  %st,%st(1)
    3865:	de c1                	faddp  %st,%st(1)
    3867:	8b 45 ec             	mov    -0x14(%ebp),%eax
    386a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    386e:	0f b6 c0             	movzbl %al,%eax
    3871:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3874:	db 45 b4             	fildl  -0x4c(%ebp)
    3877:	d8 4d d8             	fmuls  -0x28(%ebp)
    387a:	8b 45 c8             	mov    -0x38(%ebp),%eax
    387d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3880:	db 45 b4             	fildl  -0x4c(%ebp)
    3883:	de c9                	fmulp  %st,%st(1)
    3885:	de c1                	faddp  %st,%st(1)
    3887:	8b 45 e8             	mov    -0x18(%ebp),%eax
    388a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    388e:	0f b6 c0             	movzbl %al,%eax
    3891:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3894:	db 45 b4             	fildl  -0x4c(%ebp)
    3897:	d8 4d dc             	fmuls  -0x24(%ebp)
    389a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    389d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    38a0:	db 45 b4             	fildl  -0x4c(%ebp)
    38a3:	de c9                	fmulp  %st,%st(1)
    38a5:	de c1                	faddp  %st,%st(1)
    38a7:	d9 7d be             	fnstcw -0x42(%ebp)
    38aa:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    38ae:	b4 0c                	mov    $0xc,%ah
    38b0:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    38b4:	d9 6d bc             	fldcw  -0x44(%ebp)
    38b7:	db 5d b8             	fistpl -0x48(%ebp)
    38ba:	d9 6d be             	fldcw  -0x42(%ebp)
    38bd:	8b 45 b8             	mov    -0x48(%ebp),%eax
    38c0:	89 c2                	mov    %eax,%edx
    38c2:	8b 45 14             	mov    0x14(%ebp),%eax
    38c5:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    38c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    38cb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    38cf:	0f b6 c0             	movzbl %al,%eax
    38d2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    38d5:	db 45 b4             	fildl  -0x4c(%ebp)
    38d8:	d8 4d d0             	fmuls  -0x30(%ebp)
    38db:	8b 45 c0             	mov    -0x40(%ebp),%eax
    38de:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    38e1:	db 45 b4             	fildl  -0x4c(%ebp)
    38e4:	de c9                	fmulp  %st,%st(1)
    38e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    38e9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    38ed:	0f b6 c0             	movzbl %al,%eax
    38f0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    38f3:	db 45 b4             	fildl  -0x4c(%ebp)
    38f6:	d8 4d d4             	fmuls  -0x2c(%ebp)
    38f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    38fc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    38ff:	db 45 b4             	fildl  -0x4c(%ebp)
    3902:	de c9                	fmulp  %st,%st(1)
    3904:	de c1                	faddp  %st,%st(1)
    3906:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3909:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    390d:	0f b6 c0             	movzbl %al,%eax
    3910:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3913:	db 45 b4             	fildl  -0x4c(%ebp)
    3916:	d8 4d d8             	fmuls  -0x28(%ebp)
    3919:	8b 45 c8             	mov    -0x38(%ebp),%eax
    391c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    391f:	db 45 b4             	fildl  -0x4c(%ebp)
    3922:	de c9                	fmulp  %st,%st(1)
    3924:	de c1                	faddp  %st,%st(1)
    3926:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3929:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    392d:	0f b6 c0             	movzbl %al,%eax
    3930:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3933:	db 45 b4             	fildl  -0x4c(%ebp)
    3936:	d8 4d dc             	fmuls  -0x24(%ebp)
    3939:	8b 45 cc             	mov    -0x34(%ebp),%eax
    393c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    393f:	db 45 b4             	fildl  -0x4c(%ebp)
    3942:	de c9                	fmulp  %st,%st(1)
    3944:	de c1                	faddp  %st,%st(1)
    3946:	d9 6d bc             	fldcw  -0x44(%ebp)
    3949:	db 5d b8             	fistpl -0x48(%ebp)
    394c:	d9 6d be             	fldcw  -0x42(%ebp)
    394f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3952:	89 c2                	mov    %eax,%edx
    3954:	8b 45 14             	mov    0x14(%ebp),%eax
    3957:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    395a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    395d:	0f b6 00             	movzbl (%eax),%eax
    3960:	0f b6 c0             	movzbl %al,%eax
    3963:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3966:	db 45 b4             	fildl  -0x4c(%ebp)
    3969:	d8 4d d0             	fmuls  -0x30(%ebp)
    396c:	8b 45 c0             	mov    -0x40(%ebp),%eax
    396f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3972:	db 45 b4             	fildl  -0x4c(%ebp)
    3975:	de c9                	fmulp  %st,%st(1)
    3977:	8b 45 f0             	mov    -0x10(%ebp),%eax
    397a:	0f b6 00             	movzbl (%eax),%eax
    397d:	0f b6 c0             	movzbl %al,%eax
    3980:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3983:	db 45 b4             	fildl  -0x4c(%ebp)
    3986:	d8 4d d4             	fmuls  -0x2c(%ebp)
    3989:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    398c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    398f:	db 45 b4             	fildl  -0x4c(%ebp)
    3992:	de c9                	fmulp  %st,%st(1)
    3994:	de c1                	faddp  %st,%st(1)
    3996:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3999:	0f b6 00             	movzbl (%eax),%eax
    399c:	0f b6 c0             	movzbl %al,%eax
    399f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    39a2:	db 45 b4             	fildl  -0x4c(%ebp)
    39a5:	d8 4d d8             	fmuls  -0x28(%ebp)
    39a8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    39ab:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    39ae:	db 45 b4             	fildl  -0x4c(%ebp)
    39b1:	de c9                	fmulp  %st,%st(1)
    39b3:	de c1                	faddp  %st,%st(1)
    39b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    39b8:	0f b6 00             	movzbl (%eax),%eax
    39bb:	0f b6 c0             	movzbl %al,%eax
    39be:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    39c1:	db 45 b4             	fildl  -0x4c(%ebp)
    39c4:	d8 4d dc             	fmuls  -0x24(%ebp)
    39c7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    39ca:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    39cd:	db 45 b4             	fildl  -0x4c(%ebp)
    39d0:	de c9                	fmulp  %st,%st(1)
    39d2:	de c1                	faddp  %st,%st(1)
    39d4:	d9 6d bc             	fldcw  -0x44(%ebp)
    39d7:	db 5d b8             	fistpl -0x48(%ebp)
    39da:	d9 6d be             	fldcw  -0x42(%ebp)
    39dd:	8b 45 b8             	mov    -0x48(%ebp),%eax
    39e0:	89 c2                	mov    %eax,%edx
    39e2:	8b 45 14             	mov    0x14(%ebp),%eax
    39e5:	88 10                	mov    %dl,(%eax)

    return 1;
    39e7:	b8 01 00 00 00       	mov    $0x1,%eax
}
    39ec:	c9                   	leave  
    39ed:	c3                   	ret    

000039ee <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    39ee:	55                   	push   %ebp
    39ef:	89 e5                	mov    %esp,%ebp
    39f1:	53                   	push   %ebx
    39f2:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    39f5:	8b 45 10             	mov    0x10(%ebp),%eax
    39f8:	c1 f8 10             	sar    $0x10,%eax
    39fb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    39fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a01:	c1 f8 10             	sar    $0x10,%eax
    3a04:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    3a07:	8d 45 bc             	lea    -0x44(%ebp),%eax
    3a0a:	50                   	push   %eax
    3a0b:	ff 75 f8             	pushl  -0x8(%ebp)
    3a0e:	ff 75 f4             	pushl  -0xc(%ebp)
    3a11:	ff 75 08             	pushl  0x8(%ebp)
    3a14:	e8 5b fc ff ff       	call   3674 <getColor>
    3a19:	83 c4 10             	add    $0x10,%esp
    3a1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    3a1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a22:	83 c0 01             	add    $0x1,%eax
    3a25:	8d 55 bc             	lea    -0x44(%ebp),%edx
    3a28:	83 c2 04             	add    $0x4,%edx
    3a2b:	52                   	push   %edx
    3a2c:	ff 75 f8             	pushl  -0x8(%ebp)
    3a2f:	50                   	push   %eax
    3a30:	ff 75 08             	pushl  0x8(%ebp)
    3a33:	e8 3c fc ff ff       	call   3674 <getColor>
    3a38:	83 c4 10             	add    $0x10,%esp
    3a3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    3a3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3a41:	83 c0 01             	add    $0x1,%eax
    3a44:	8d 55 bc             	lea    -0x44(%ebp),%edx
    3a47:	83 c2 08             	add    $0x8,%edx
    3a4a:	52                   	push   %edx
    3a4b:	50                   	push   %eax
    3a4c:	ff 75 f4             	pushl  -0xc(%ebp)
    3a4f:	ff 75 08             	pushl  0x8(%ebp)
    3a52:	e8 1d fc ff ff       	call   3674 <getColor>
    3a57:	83 c4 10             	add    $0x10,%esp
    3a5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    3a5d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3a60:	8d 50 01             	lea    0x1(%eax),%edx
    3a63:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a66:	83 c0 01             	add    $0x1,%eax
    3a69:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    3a6c:	83 c1 0c             	add    $0xc,%ecx
    3a6f:	51                   	push   %ecx
    3a70:	52                   	push   %edx
    3a71:	50                   	push   %eax
    3a72:	ff 75 08             	pushl  0x8(%ebp)
    3a75:	e8 fa fb ff ff       	call   3674 <getColor>
    3a7a:	83 c4 10             	add    $0x10,%esp
    3a7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    3a80:	8b 45 10             	mov    0x10(%ebp),%eax
    3a83:	0f b7 c0             	movzwl %ax,%eax
    3a86:	c1 f8 08             	sar    $0x8,%eax
    3a89:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    3a8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a8f:	0f b7 c0             	movzwl %ax,%eax
    3a92:	c1 f8 08             	sar    $0x8,%eax
    3a95:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    3a98:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3a9b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    3a9f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    3aa2:	b8 ff 00 00 00       	mov    $0xff,%eax
    3aa7:	2b 45 dc             	sub    -0x24(%ebp),%eax
    3aaa:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    3aae:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    3ab1:	b8 ff 00 00 00       	mov    $0xff,%eax
    3ab6:	2b 45 e0             	sub    -0x20(%ebp),%eax
    3ab9:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    3abd:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    3ac0:	b8 ff 00 00 00       	mov    $0xff,%eax
    3ac5:	2b 45 e0             	sub    -0x20(%ebp),%eax
    3ac8:	89 c2                	mov    %eax,%edx
    3aca:	b8 ff 00 00 00       	mov    $0xff,%eax
    3acf:	2b 45 dc             	sub    -0x24(%ebp),%eax
    3ad2:	0f af c2             	imul   %edx,%eax
    3ad5:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    3ad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3adb:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3adf:	0f b6 c0             	movzbl %al,%eax
    3ae2:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    3ae6:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3ae9:	0f af d0             	imul   %eax,%edx
    3aec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3aef:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3af3:	0f b6 c0             	movzbl %al,%eax
    3af6:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    3afa:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    3afd:	0f af c1             	imul   %ecx,%eax
    3b00:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    3b03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3b06:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3b0a:	0f b6 c0             	movzbl %al,%eax
    3b0d:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    3b11:	8b 55 c8             	mov    -0x38(%ebp),%edx
    3b14:	0f af d0             	imul   %eax,%edx
    3b17:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3b1a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3b1e:	0f b6 c0             	movzbl %al,%eax
    3b21:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    3b25:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    3b28:	0f af c1             	imul   %ecx,%eax
    3b2b:	01 d0                	add    %edx,%eax
    3b2d:	01 d8                	add    %ebx,%eax
    3b2f:	c1 e8 10             	shr    $0x10,%eax
    3b32:	89 c2                	mov    %eax,%edx
    3b34:	8b 45 14             	mov    0x14(%ebp),%eax
    3b37:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    3b3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3b3d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3b41:	0f b6 c0             	movzbl %al,%eax
    3b44:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    3b48:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3b4b:	0f af d0             	imul   %eax,%edx
    3b4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3b51:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3b55:	0f b6 c0             	movzbl %al,%eax
    3b58:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    3b5c:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    3b5f:	0f af c1             	imul   %ecx,%eax
    3b62:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    3b65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3b68:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3b6c:	0f b6 c0             	movzbl %al,%eax
    3b6f:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    3b73:	8b 55 c8             	mov    -0x38(%ebp),%edx
    3b76:	0f af d0             	imul   %eax,%edx
    3b79:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3b7c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3b80:	0f b6 c0             	movzbl %al,%eax
    3b83:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    3b87:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    3b8a:	0f af c1             	imul   %ecx,%eax
    3b8d:	01 d0                	add    %edx,%eax
    3b8f:	01 d8                	add    %ebx,%eax
    3b91:	c1 e8 10             	shr    $0x10,%eax
    3b94:	89 c2                	mov    %eax,%edx
    3b96:	8b 45 14             	mov    0x14(%ebp),%eax
    3b99:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    3b9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3b9f:	0f b6 00             	movzbl (%eax),%eax
    3ba2:	0f b6 c0             	movzbl %al,%eax
    3ba5:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    3ba9:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3bac:	0f af d0             	imul   %eax,%edx
    3baf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3bb2:	0f b6 00             	movzbl (%eax),%eax
    3bb5:	0f b6 c0             	movzbl %al,%eax
    3bb8:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    3bbc:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    3bbf:	0f af c1             	imul   %ecx,%eax
    3bc2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    3bc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3bc8:	0f b6 00             	movzbl (%eax),%eax
    3bcb:	0f b6 c0             	movzbl %al,%eax
    3bce:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    3bd2:	8b 55 c8             	mov    -0x38(%ebp),%edx
    3bd5:	0f af d0             	imul   %eax,%edx
    3bd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3bdb:	0f b6 00             	movzbl (%eax),%eax
    3bde:	0f b6 c0             	movzbl %al,%eax
    3be1:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    3be5:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    3be8:	0f af c1             	imul   %ecx,%eax
    3beb:	01 d0                	add    %edx,%eax
    3bed:	01 d8                	add    %ebx,%eax
    3bef:	c1 e8 10             	shr    $0x10,%eax
    3bf2:	89 c2                	mov    %eax,%edx
    3bf4:	8b 45 14             	mov    0x14(%ebp),%eax
    3bf7:	88 10                	mov    %dl,(%eax)
}
    3bf9:	90                   	nop
    3bfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3bfd:	c9                   	leave  
    3bfe:	c3                   	ret    

00003bff <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    3bff:	55                   	push   %ebp
    3c00:	89 e5                	mov    %esp,%ebp
    3c02:	53                   	push   %ebx
    3c03:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    3c06:	8b 45 08             	mov    0x8(%ebp),%eax
    3c09:	8b 00                	mov    (%eax),%eax
    3c0b:	c1 e0 10             	shl    $0x10,%eax
    3c0e:	89 c1                	mov    %eax,%ecx
    3c10:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c13:	8b 18                	mov    (%eax),%ebx
    3c15:	89 c8                	mov    %ecx,%eax
    3c17:	99                   	cltd   
    3c18:	f7 fb                	idiv   %ebx
    3c1a:	83 c0 01             	add    $0x1,%eax
    3c1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    3c20:	8b 45 08             	mov    0x8(%ebp),%eax
    3c23:	8b 40 04             	mov    0x4(%eax),%eax
    3c26:	c1 e0 10             	shl    $0x10,%eax
    3c29:	89 c1                	mov    %eax,%ecx
    3c2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c2e:	8b 58 04             	mov    0x4(%eax),%ebx
    3c31:	89 c8                	mov    %ecx,%eax
    3c33:	99                   	cltd   
    3c34:	f7 fb                	idiv   %ebx
    3c36:	83 c0 01             	add    $0x1,%eax
    3c39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    3c3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3c3f:	d1 f8                	sar    %eax
    3c41:	2d 00 80 00 00       	sub    $0x8000,%eax
    3c46:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    3c49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3c4c:	d1 f8                	sar    %eax
    3c4e:	2d 00 80 00 00       	sub    $0x8000,%eax
    3c53:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    3c56:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3c59:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    3c5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3c63:	eb 5d                	jmp    3cc2 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    3c65:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3c68:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    3c6b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    3c72:	eb 3a                	jmp    3cae <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    3c74:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c77:	8b 48 08             	mov    0x8(%eax),%ecx
    3c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c7d:	8b 00                	mov    (%eax),%eax
    3c7f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3c83:	89 c2                	mov    %eax,%edx
    3c85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3c88:	01 c2                	add    %eax,%edx
    3c8a:	89 d0                	mov    %edx,%eax
    3c8c:	01 c0                	add    %eax,%eax
    3c8e:	01 d0                	add    %edx,%eax
    3c90:	01 c8                	add    %ecx,%eax
    3c92:	50                   	push   %eax
    3c93:	ff 75 f0             	pushl  -0x10(%ebp)
    3c96:	ff 75 f8             	pushl  -0x8(%ebp)
    3c99:	ff 75 08             	pushl  0x8(%ebp)
    3c9c:	e8 4d fd ff ff       	call   39ee <mixColorInt>
    3ca1:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    3ca4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3ca7:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    3caa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    3cae:	8b 45 0c             	mov    0xc(%ebp),%eax
    3cb1:	8b 00                	mov    (%eax),%eax
    3cb3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    3cb6:	7f bc                	jg     3c74 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    3cb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3cbb:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    3cbe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3cc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    3cc5:	8b 40 04             	mov    0x4(%eax),%eax
    3cc8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3ccb:	7f 98                	jg     3c65 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    3ccd:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3cd2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3cd5:	c9                   	leave  
    3cd6:	c3                   	ret    

00003cd7 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    3cd7:	55                   	push   %ebp
    3cd8:	89 e5                	mov    %esp,%ebp
    3cda:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    3cdd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce0:	8b 00                	mov    (%eax),%eax
    3ce2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3ce5:	db 45 e4             	fildl  -0x1c(%ebp)
    3ce8:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ceb:	8b 00                	mov    (%eax),%eax
    3ced:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3cf0:	db 45 e4             	fildl  -0x1c(%ebp)
    3cf3:	de f9                	fdivrp %st,%st(1)
    3cf5:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    3cf8:	8b 45 08             	mov    0x8(%ebp),%eax
    3cfb:	8b 40 04             	mov    0x4(%eax),%eax
    3cfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3d01:	db 45 e4             	fildl  -0x1c(%ebp)
    3d04:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d07:	8b 40 04             	mov    0x4(%eax),%eax
    3d0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3d0d:	db 45 e4             	fildl  -0x1c(%ebp)
    3d10:	de f9                	fdivrp %st,%st(1)
    3d12:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    3d15:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3d1c:	eb 5e                	jmp    3d7c <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    3d1e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    3d25:	eb 47                	jmp    3d6e <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    3d27:	db 45 f8             	fildl  -0x8(%ebp)
    3d2a:	d8 4d f4             	fmuls  -0xc(%ebp)
    3d2d:	d9 7d ee             	fnstcw -0x12(%ebp)
    3d30:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    3d34:	b4 0c                	mov    $0xc,%ah
    3d36:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    3d3a:	d9 6d ec             	fldcw  -0x14(%ebp)
    3d3d:	db 5d e8             	fistpl -0x18(%ebp)
    3d40:	d9 6d ee             	fldcw  -0x12(%ebp)
    3d43:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3d46:	db 45 fc             	fildl  -0x4(%ebp)
    3d49:	d8 4d f0             	fmuls  -0x10(%ebp)
    3d4c:	d9 6d ec             	fldcw  -0x14(%ebp)
    3d4f:	db 5d e8             	fistpl -0x18(%ebp)
    3d52:	d9 6d ee             	fldcw  -0x12(%ebp)
    3d55:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3d58:	6a 00                	push   $0x0
    3d5a:	52                   	push   %edx
    3d5b:	50                   	push   %eax
    3d5c:	ff 75 08             	pushl  0x8(%ebp)
    3d5f:	e8 10 f9 ff ff       	call   3674 <getColor>
    3d64:	83 c4 10             	add    $0x10,%esp
    3d67:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    3d6a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3d6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d71:	8b 00                	mov    (%eax),%eax
    3d73:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    3d76:	7f af                	jg     3d27 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    3d78:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3d7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d7f:	8b 40 04             	mov    0x4(%eax),%eax
    3d82:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3d85:	7f 97                	jg     3d1e <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    3d87:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3d8c:	c9                   	leave  
    3d8d:	c3                   	ret    

00003d8e <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    3d8e:	55                   	push   %ebp
    3d8f:	89 e5                	mov    %esp,%ebp
    3d91:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    3d94:	8b 45 08             	mov    0x8(%ebp),%eax
    3d97:	8b 00                	mov    (%eax),%eax
    3d99:	89 45 e0             	mov    %eax,-0x20(%ebp)
    3d9c:	db 45 e0             	fildl  -0x20(%ebp)
    3d9f:	d9 5d e0             	fstps  -0x20(%ebp)
    3da2:	83 ec 0c             	sub    $0xc,%esp
    3da5:	ff 75 10             	pushl  0x10(%ebp)
    3da8:	e8 6b e2 ff ff       	call   2018 <cos>
    3dad:	83 c4 10             	add    $0x10,%esp
    3db0:	d9 5d dc             	fstps  -0x24(%ebp)
    3db3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3db6:	83 ec 0c             	sub    $0xc,%esp
    3db9:	50                   	push   %eax
    3dba:	e8 90 e1 ff ff       	call   1f4f <abs>
    3dbf:	83 c4 10             	add    $0x10,%esp
    3dc2:	d8 4d e0             	fmuls  -0x20(%ebp)
    3dc5:	d9 5d e0             	fstps  -0x20(%ebp)
    3dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    3dcb:	8b 00                	mov    (%eax),%eax
    3dcd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    3dd0:	db 45 dc             	fildl  -0x24(%ebp)
    3dd3:	d9 5d dc             	fstps  -0x24(%ebp)
    3dd6:	83 ec 0c             	sub    $0xc,%esp
    3dd9:	ff 75 10             	pushl  0x10(%ebp)
    3ddc:	e8 da e3 ff ff       	call   21bb <sin>
    3de1:	83 c4 10             	add    $0x10,%esp
    3de4:	d9 5d d8             	fstps  -0x28(%ebp)
    3de7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3dea:	83 ec 0c             	sub    $0xc,%esp
    3ded:	50                   	push   %eax
    3dee:	e8 5c e1 ff ff       	call   1f4f <abs>
    3df3:	83 c4 10             	add    $0x10,%esp
    3df6:	d8 4d dc             	fmuls  -0x24(%ebp)
    3df9:	d8 45 e0             	fadds  -0x20(%ebp)
    3dfc:	d9 7d e6             	fnstcw -0x1a(%ebp)
    3dff:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    3e03:	b4 0c                	mov    $0xc,%ah
    3e05:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    3e09:	d9 6d e4             	fldcw  -0x1c(%ebp)
    3e0c:	db 5d f4             	fistpl -0xc(%ebp)
    3e0f:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    3e12:	8b 45 08             	mov    0x8(%ebp),%eax
    3e15:	8b 00                	mov    (%eax),%eax
    3e17:	89 45 e0             	mov    %eax,-0x20(%ebp)
    3e1a:	db 45 e0             	fildl  -0x20(%ebp)
    3e1d:	d9 5d e0             	fstps  -0x20(%ebp)
    3e20:	83 ec 0c             	sub    $0xc,%esp
    3e23:	ff 75 10             	pushl  0x10(%ebp)
    3e26:	e8 90 e3 ff ff       	call   21bb <sin>
    3e2b:	83 c4 10             	add    $0x10,%esp
    3e2e:	d9 5d dc             	fstps  -0x24(%ebp)
    3e31:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3e34:	83 ec 0c             	sub    $0xc,%esp
    3e37:	50                   	push   %eax
    3e38:	e8 12 e1 ff ff       	call   1f4f <abs>
    3e3d:	83 c4 10             	add    $0x10,%esp
    3e40:	d8 4d e0             	fmuls  -0x20(%ebp)
    3e43:	d9 5d e0             	fstps  -0x20(%ebp)
    3e46:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e49:	8b 00                	mov    (%eax),%eax
    3e4b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    3e4e:	db 45 dc             	fildl  -0x24(%ebp)
    3e51:	d9 5d dc             	fstps  -0x24(%ebp)
    3e54:	83 ec 0c             	sub    $0xc,%esp
    3e57:	ff 75 10             	pushl  0x10(%ebp)
    3e5a:	e8 b9 e1 ff ff       	call   2018 <cos>
    3e5f:	83 c4 10             	add    $0x10,%esp
    3e62:	d9 5d d8             	fstps  -0x28(%ebp)
    3e65:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3e68:	83 ec 0c             	sub    $0xc,%esp
    3e6b:	50                   	push   %eax
    3e6c:	e8 de e0 ff ff       	call   1f4f <abs>
    3e71:	83 c4 10             	add    $0x10,%esp
    3e74:	d8 4d dc             	fmuls  -0x24(%ebp)
    3e77:	d8 45 e0             	fadds  -0x20(%ebp)
    3e7a:	d9 7d e6             	fnstcw -0x1a(%ebp)
    3e7d:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    3e81:	b4 0c                	mov    $0xc,%ah
    3e83:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    3e87:	d9 6d e4             	fldcw  -0x1c(%ebp)
    3e8a:	db 5d f0             	fistpl -0x10(%ebp)
    3e8d:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    3e90:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e93:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3e96:	89 10                	mov    %edx,(%eax)
    *width = w;
    3e98:	8b 45 08             	mov    0x8(%ebp),%eax
    3e9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3e9e:	89 10                	mov    %edx,(%eax)
    return 1;
    3ea0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3ea5:	c9                   	leave  
    3ea6:	c3                   	ret    

00003ea7 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    3ea7:	55                   	push   %ebp
    3ea8:	89 e5                	mov    %esp,%ebp
    3eaa:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    3ead:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb0:	8b 40 04             	mov    0x4(%eax),%eax
    3eb3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3eb6:	db 45 c4             	fildl  -0x3c(%ebp)
    3eb9:	d9 05 84 b3 01 00    	flds   0x1b384
    3ebf:	de f9                	fdivrp %st,%st(1)
    3ec1:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    3ec4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec7:	8b 00                	mov    (%eax),%eax
    3ec9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3ecc:	db 45 c4             	fildl  -0x3c(%ebp)
    3ecf:	d9 05 84 b3 01 00    	flds   0x1b384
    3ed5:	de f9                	fdivrp %st,%st(1)
    3ed7:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    3eda:	8b 45 0c             	mov    0xc(%ebp),%eax
    3edd:	8b 50 04             	mov    0x4(%eax),%edx
    3ee0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ee3:	8b 40 04             	mov    0x4(%eax),%eax
    3ee6:	29 c2                	sub    %eax,%edx
    3ee8:	89 d0                	mov    %edx,%eax
    3eea:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3eed:	db 45 c4             	fildl  -0x3c(%ebp)
    3ef0:	d9 05 84 b3 01 00    	flds   0x1b384
    3ef6:	de f9                	fdivrp %st,%st(1)
    3ef8:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    3efb:	8b 45 0c             	mov    0xc(%ebp),%eax
    3efe:	8b 10                	mov    (%eax),%edx
    3f00:	8b 45 08             	mov    0x8(%ebp),%eax
    3f03:	8b 00                	mov    (%eax),%eax
    3f05:	29 c2                	sub    %eax,%edx
    3f07:	89 d0                	mov    %edx,%eax
    3f09:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3f0c:	db 45 c4             	fildl  -0x3c(%ebp)
    3f0f:	d9 05 84 b3 01 00    	flds   0x1b384
    3f15:	de f9                	fdivrp %st,%st(1)
    3f17:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    3f1a:	d9 45 10             	flds   0x10(%ebp)
    3f1d:	d9 e0                	fchs   
    3f1f:	83 ec 0c             	sub    $0xc,%esp
    3f22:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3f26:	d9 1c 24             	fstps  (%esp)
    3f29:	e8 ea e0 ff ff       	call   2018 <cos>
    3f2e:	83 c4 10             	add    $0x10,%esp
    3f31:	d9 5d c4             	fstps  -0x3c(%ebp)
    3f34:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3f37:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    3f3a:	d9 45 10             	flds   0x10(%ebp)
    3f3d:	d9 e0                	fchs   
    3f3f:	83 ec 0c             	sub    $0xc,%esp
    3f42:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3f46:	d9 1c 24             	fstps  (%esp)
    3f49:	e8 6d e2 ff ff       	call   21bb <sin>
    3f4e:	83 c4 10             	add    $0x10,%esp
    3f51:	d9 5d c4             	fstps  -0x3c(%ebp)
    3f54:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3f57:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    3f5a:	d9 ee                	fldz   
    3f5c:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    3f5f:	d9 ee                	fldz   
    3f61:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    3f64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3f6b:	e9 28 01 00 00       	jmp    4098 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    3f70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3f77:	e9 0a 01 00 00       	jmp    4086 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    3f7c:	db 45 f4             	fildl  -0xc(%ebp)
    3f7f:	d8 65 e4             	fsubs  -0x1c(%ebp)
    3f82:	d8 65 ec             	fsubs  -0x14(%ebp)
    3f85:	d8 4d dc             	fmuls  -0x24(%ebp)
    3f88:	db 45 f0             	fildl  -0x10(%ebp)
    3f8b:	d8 65 e0             	fsubs  -0x20(%ebp)
    3f8e:	d8 65 e8             	fsubs  -0x18(%ebp)
    3f91:	d8 4d d8             	fmuls  -0x28(%ebp)
    3f94:	de c1                	faddp  %st,%st(1)
    3f96:	d8 45 ec             	fadds  -0x14(%ebp)
    3f99:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    3f9c:	db 45 f0             	fildl  -0x10(%ebp)
    3f9f:	d8 65 e0             	fsubs  -0x20(%ebp)
    3fa2:	d8 65 e8             	fsubs  -0x18(%ebp)
    3fa5:	d8 4d dc             	fmuls  -0x24(%ebp)
    3fa8:	db 45 f4             	fildl  -0xc(%ebp)
    3fab:	d8 65 e4             	fsubs  -0x1c(%ebp)
    3fae:	d8 65 ec             	fsubs  -0x14(%ebp)
    3fb1:	d8 4d d8             	fmuls  -0x28(%ebp)
    3fb4:	de e9                	fsubrp %st,%st(1)
    3fb6:	d8 45 e8             	fadds  -0x18(%ebp)
    3fb9:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    3fbc:	d9 45 d4             	flds   -0x2c(%ebp)
    3fbf:	d9 ee                	fldz   
    3fc1:	d9 c9                	fxch   %st(1)
    3fc3:	df e9                	fucomip %st(1),%st
    3fc5:	dd d8                	fstp   %st(0)
    3fc7:	0f 93 c0             	setae  %al
    3fca:	83 f0 01             	xor    $0x1,%eax
    3fcd:	84 c0                	test   %al,%al
    3fcf:	75 52                	jne    4023 <picTurn+0x17c>
    3fd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3fd4:	8b 40 04             	mov    0x4(%eax),%eax
    3fd7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3fda:	db 45 c4             	fildl  -0x3c(%ebp)
    3fdd:	d9 45 d4             	flds   -0x2c(%ebp)
    3fe0:	d9 c9                	fxch   %st(1)
    3fe2:	df e9                	fucomip %st(1),%st
    3fe4:	dd d8                	fstp   %st(0)
    3fe6:	0f 97 c0             	seta   %al
    3fe9:	83 f0 01             	xor    $0x1,%eax
    3fec:	84 c0                	test   %al,%al
    3fee:	75 33                	jne    4023 <picTurn+0x17c>
    3ff0:	d9 45 d0             	flds   -0x30(%ebp)
    3ff3:	d9 ee                	fldz   
    3ff5:	d9 c9                	fxch   %st(1)
    3ff7:	df e9                	fucomip %st(1),%st
    3ff9:	dd d8                	fstp   %st(0)
    3ffb:	0f 93 c0             	setae  %al
    3ffe:	83 f0 01             	xor    $0x1,%eax
    4001:	84 c0                	test   %al,%al
    4003:	75 1e                	jne    4023 <picTurn+0x17c>
    4005:	8b 45 08             	mov    0x8(%ebp),%eax
    4008:	8b 00                	mov    (%eax),%eax
    400a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    400d:	db 45 c4             	fildl  -0x3c(%ebp)
    4010:	d9 45 d0             	flds   -0x30(%ebp)
    4013:	d9 c9                	fxch   %st(1)
    4015:	df e9                	fucomip %st(1),%st
    4017:	dd d8                	fstp   %st(0)
    4019:	0f 97 c0             	seta   %al
    401c:	83 f0 01             	xor    $0x1,%eax
    401f:	84 c0                	test   %al,%al
    4021:	74 2f                	je     4052 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    4023:	8b 45 0c             	mov    0xc(%ebp),%eax
    4026:	8b 48 08             	mov    0x8(%eax),%ecx
    4029:	8b 45 0c             	mov    0xc(%ebp),%eax
    402c:	8b 00                	mov    (%eax),%eax
    402e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    4032:	89 c2                	mov    %eax,%edx
    4034:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4037:	01 c2                	add    %eax,%edx
    4039:	89 d0                	mov    %edx,%eax
    403b:	01 c0                	add    %eax,%eax
    403d:	01 d0                	add    %edx,%eax
    403f:	01 c8                	add    %ecx,%eax
    4041:	83 ec 08             	sub    $0x8,%esp
    4044:	50                   	push   %eax
    4045:	68 ad f8 01 00       	push   $0x1f8ad
    404a:	e8 9f f6 ff ff       	call   36ee <setColor>
    404f:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    4052:	8b 45 0c             	mov    0xc(%ebp),%eax
    4055:	8b 48 08             	mov    0x8(%eax),%ecx
    4058:	8b 45 0c             	mov    0xc(%ebp),%eax
    405b:	8b 00                	mov    (%eax),%eax
    405d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    4061:	89 c2                	mov    %eax,%edx
    4063:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4066:	01 c2                	add    %eax,%edx
    4068:	89 d0                	mov    %edx,%eax
    406a:	01 c0                	add    %eax,%eax
    406c:	01 d0                	add    %edx,%eax
    406e:	01 c8                	add    %ecx,%eax
    4070:	50                   	push   %eax
    4071:	ff 75 d0             	pushl  -0x30(%ebp)
    4074:	ff 75 d4             	pushl  -0x2c(%ebp)
    4077:	ff 75 08             	pushl  0x8(%ebp)
    407a:	e8 9e f6 ff ff       	call   371d <mixColor>
    407f:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    4082:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4086:	8b 45 0c             	mov    0xc(%ebp),%eax
    4089:	8b 00                	mov    (%eax),%eax
    408b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    408e:	0f 8f e8 fe ff ff    	jg     3f7c <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    4094:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4098:	8b 45 0c             	mov    0xc(%ebp),%eax
    409b:	8b 40 04             	mov    0x4(%eax),%eax
    409e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    40a1:	0f 8f c9 fe ff ff    	jg     3f70 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    40a7:	b8 01 00 00 00       	mov    $0x1,%eax
}
    40ac:	c9                   	leave  
    40ad:	c3                   	ret    

000040ae <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    40ae:	55                   	push   %ebp
    40af:	89 e5                	mov    %esp,%ebp
    40b1:	53                   	push   %ebx
    40b2:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    40b5:	8b 45 08             	mov    0x8(%ebp),%eax
    40b8:	8b 10                	mov    (%eax),%edx
    40ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    40bd:	8b 00                	mov    (%eax),%eax
    40bf:	39 c2                	cmp    %eax,%edx
    40c1:	75 10                	jne    40d3 <picRollingOver+0x25>
    40c3:	8b 45 08             	mov    0x8(%ebp),%eax
    40c6:	8b 50 04             	mov    0x4(%eax),%edx
    40c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    40cc:	8b 40 04             	mov    0x4(%eax),%eax
    40cf:	39 c2                	cmp    %eax,%edx
    40d1:	74 0a                	je     40dd <picRollingOver+0x2f>
        return 0;
    40d3:	b8 00 00 00 00       	mov    $0x0,%eax
    40d8:	e9 88 00 00 00       	jmp    4165 <picRollingOver+0xb7>

    int h = src->height;
    40dd:	8b 45 08             	mov    0x8(%ebp),%eax
    40e0:	8b 40 04             	mov    0x4(%eax),%eax
    40e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    40e6:	8b 45 08             	mov    0x8(%ebp),%eax
    40e9:	8b 00                	mov    (%eax),%eax
    40eb:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    40ee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    40f5:	eb 61                	jmp    4158 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    40f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    40fe:	eb 4c                	jmp    414c <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    4100:	8b 45 0c             	mov    0xc(%ebp),%eax
    4103:	8b 48 08             	mov    0x8(%eax),%ecx
    4106:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4109:	2b 45 f8             	sub    -0x8(%ebp),%eax
    410c:	83 e8 01             	sub    $0x1,%eax
    410f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    4113:	89 c2                	mov    %eax,%edx
    4115:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4118:	01 c2                	add    %eax,%edx
    411a:	89 d0                	mov    %edx,%eax
    411c:	01 c0                	add    %eax,%eax
    411e:	01 d0                	add    %edx,%eax
    4120:	01 c1                	add    %eax,%ecx
    4122:	8b 45 08             	mov    0x8(%ebp),%eax
    4125:	8b 58 08             	mov    0x8(%eax),%ebx
    4128:	8b 45 f8             	mov    -0x8(%ebp),%eax
    412b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    412f:	89 c2                	mov    %eax,%edx
    4131:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4134:	01 c2                	add    %eax,%edx
    4136:	89 d0                	mov    %edx,%eax
    4138:	01 c0                	add    %eax,%eax
    413a:	01 d0                	add    %edx,%eax
    413c:	01 d8                	add    %ebx,%eax
    413e:	51                   	push   %ecx
    413f:	50                   	push   %eax
    4140:	e8 a9 f5 ff ff       	call   36ee <setColor>
    4145:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    4148:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    414c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    414f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4152:	7c ac                	jl     4100 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    4154:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4158:	8b 45 f8             	mov    -0x8(%ebp),%eax
    415b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    415e:	7c 97                	jl     40f7 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    4160:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4165:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4168:	c9                   	leave  
    4169:	c3                   	ret    

0000416a <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    416a:	55                   	push   %ebp
    416b:	89 e5                	mov    %esp,%ebp
    416d:	53                   	push   %ebx
    416e:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    4171:	8b 45 08             	mov    0x8(%ebp),%eax
    4174:	8b 10                	mov    (%eax),%edx
    4176:	8b 45 0c             	mov    0xc(%ebp),%eax
    4179:	8b 00                	mov    (%eax),%eax
    417b:	39 c2                	cmp    %eax,%edx
    417d:	75 10                	jne    418f <picTurnAround+0x25>
    417f:	8b 45 08             	mov    0x8(%ebp),%eax
    4182:	8b 50 04             	mov    0x4(%eax),%edx
    4185:	8b 45 0c             	mov    0xc(%ebp),%eax
    4188:	8b 40 04             	mov    0x4(%eax),%eax
    418b:	39 c2                	cmp    %eax,%edx
    418d:	74 0a                	je     4199 <picTurnAround+0x2f>
        return 0;
    418f:	b8 00 00 00 00       	mov    $0x0,%eax
    4194:	e9 88 00 00 00       	jmp    4221 <picTurnAround+0xb7>

    int h = src->height;
    4199:	8b 45 08             	mov    0x8(%ebp),%eax
    419c:	8b 40 04             	mov    0x4(%eax),%eax
    419f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    41a2:	8b 45 08             	mov    0x8(%ebp),%eax
    41a5:	8b 00                	mov    (%eax),%eax
    41a7:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    41aa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    41b1:	eb 61                	jmp    4214 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    41b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    41ba:	eb 4c                	jmp    4208 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    41bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    41bf:	8b 48 08             	mov    0x8(%eax),%ecx
    41c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41c5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    41c9:	89 c2                	mov    %eax,%edx
    41cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    41ce:	2b 45 f4             	sub    -0xc(%ebp),%eax
    41d1:	01 c2                	add    %eax,%edx
    41d3:	89 d0                	mov    %edx,%eax
    41d5:	01 c0                	add    %eax,%eax
    41d7:	01 d0                	add    %edx,%eax
    41d9:	83 e8 03             	sub    $0x3,%eax
    41dc:	01 c1                	add    %eax,%ecx
    41de:	8b 45 08             	mov    0x8(%ebp),%eax
    41e1:	8b 58 08             	mov    0x8(%eax),%ebx
    41e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41e7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    41eb:	89 c2                	mov    %eax,%edx
    41ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    41f0:	01 c2                	add    %eax,%edx
    41f2:	89 d0                	mov    %edx,%eax
    41f4:	01 c0                	add    %eax,%eax
    41f6:	01 d0                	add    %edx,%eax
    41f8:	01 d8                	add    %ebx,%eax
    41fa:	51                   	push   %ecx
    41fb:	50                   	push   %eax
    41fc:	e8 ed f4 ff ff       	call   36ee <setColor>
    4201:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    4204:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4208:	8b 45 f4             	mov    -0xc(%ebp),%eax
    420b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    420e:	7c ac                	jl     41bc <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    4210:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4214:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4217:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    421a:	7c 97                	jl     41b3 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    421c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4221:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4224:	c9                   	leave  
    4225:	c3                   	ret    

00004226 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    4226:	55                   	push   %ebp
    4227:	89 e5                	mov    %esp,%ebp
    4229:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    422c:	83 ec 0c             	sub    $0xc,%esp
    422f:	ff 75 08             	pushl  0x8(%ebp)
    4232:	e8 c5 d5 ff ff       	call   17fc <strlen>
    4237:	83 c4 10             	add    $0x10,%esp
    423a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    423d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4240:	8d 50 ff             	lea    -0x1(%eax),%edx
    4243:	8b 45 08             	mov    0x8(%ebp),%eax
    4246:	01 d0                	add    %edx,%eax
    4248:	0f b6 00             	movzbl (%eax),%eax
    424b:	3c 67                	cmp    $0x67,%al
    424d:	75 2b                	jne    427a <type+0x54>
    424f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4252:	8d 50 fe             	lea    -0x2(%eax),%edx
    4255:	8b 45 08             	mov    0x8(%ebp),%eax
    4258:	01 d0                	add    %edx,%eax
    425a:	0f b6 00             	movzbl (%eax),%eax
    425d:	3c 70                	cmp    $0x70,%al
    425f:	75 19                	jne    427a <type+0x54>
    4261:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4264:	8d 50 fd             	lea    -0x3(%eax),%edx
    4267:	8b 45 08             	mov    0x8(%ebp),%eax
    426a:	01 d0                	add    %edx,%eax
    426c:	0f b6 00             	movzbl (%eax),%eax
    426f:	3c 6a                	cmp    $0x6a,%al
    4271:	75 07                	jne    427a <type+0x54>
    4273:	b8 00 00 00 00       	mov    $0x0,%eax
    4278:	eb 7f                	jmp    42f9 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    427a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    427d:	8d 50 ff             	lea    -0x1(%eax),%edx
    4280:	8b 45 08             	mov    0x8(%ebp),%eax
    4283:	01 d0                	add    %edx,%eax
    4285:	0f b6 00             	movzbl (%eax),%eax
    4288:	3c 70                	cmp    $0x70,%al
    428a:	75 2b                	jne    42b7 <type+0x91>
    428c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    428f:	8d 50 fe             	lea    -0x2(%eax),%edx
    4292:	8b 45 08             	mov    0x8(%ebp),%eax
    4295:	01 d0                	add    %edx,%eax
    4297:	0f b6 00             	movzbl (%eax),%eax
    429a:	3c 6d                	cmp    $0x6d,%al
    429c:	75 19                	jne    42b7 <type+0x91>
    429e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    42a1:	8d 50 fd             	lea    -0x3(%eax),%edx
    42a4:	8b 45 08             	mov    0x8(%ebp),%eax
    42a7:	01 d0                	add    %edx,%eax
    42a9:	0f b6 00             	movzbl (%eax),%eax
    42ac:	3c 62                	cmp    $0x62,%al
    42ae:	75 07                	jne    42b7 <type+0x91>
    42b0:	b8 01 00 00 00       	mov    $0x1,%eax
    42b5:	eb 42                	jmp    42f9 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    42b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    42ba:	8d 50 ff             	lea    -0x1(%eax),%edx
    42bd:	8b 45 08             	mov    0x8(%ebp),%eax
    42c0:	01 d0                	add    %edx,%eax
    42c2:	0f b6 00             	movzbl (%eax),%eax
    42c5:	3c 67                	cmp    $0x67,%al
    42c7:	75 2b                	jne    42f4 <type+0xce>
    42c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    42cc:	8d 50 fe             	lea    -0x2(%eax),%edx
    42cf:	8b 45 08             	mov    0x8(%ebp),%eax
    42d2:	01 d0                	add    %edx,%eax
    42d4:	0f b6 00             	movzbl (%eax),%eax
    42d7:	3c 6e                	cmp    $0x6e,%al
    42d9:	75 19                	jne    42f4 <type+0xce>
    42db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    42de:	8d 50 fd             	lea    -0x3(%eax),%edx
    42e1:	8b 45 08             	mov    0x8(%ebp),%eax
    42e4:	01 d0                	add    %edx,%eax
    42e6:	0f b6 00             	movzbl (%eax),%eax
    42e9:	3c 70                	cmp    $0x70,%al
    42eb:	75 07                	jne    42f4 <type+0xce>
    42ed:	b8 02 00 00 00       	mov    $0x2,%eax
    42f2:	eb 05                	jmp    42f9 <type+0xd3>
    else return NONE;
    42f4:	b8 03 00 00 00       	mov    $0x3,%eax
}
    42f9:	c9                   	leave  
    42fa:	c3                   	ret    

000042fb <LoadBmp>:

PBitmap LoadBmp(char* filename){
    42fb:	55                   	push   %ebp
    42fc:	89 e5                	mov    %esp,%ebp
    42fe:	56                   	push   %esi
    42ff:	53                   	push   %ebx
    4300:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    4303:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    430a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    4311:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    4318:	83 ec 08             	sub    $0x8,%esp
    431b:	6a 00                	push   $0x0
    431d:	ff 75 0c             	pushl  0xc(%ebp)
    4320:	e8 d9 d6 ff ff       	call   19fe <open>
    4325:	83 c4 10             	add    $0x10,%esp
    4328:	89 45 ec             	mov    %eax,-0x14(%ebp)
    432b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    432f:	79 2c                	jns    435d <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    4331:	83 ec 08             	sub    $0x8,%esp
    4334:	ff 75 0c             	pushl  0xc(%ebp)
    4337:	68 88 b3 01 00       	push   $0x1b388
    433c:	e8 24 d8 ff ff       	call   1b65 <printf>
    4341:	83 c4 10             	add    $0x10,%esp
        return bmp;
    4344:	8b 45 08             	mov    0x8(%ebp),%eax
    4347:	8b 55 b8             	mov    -0x48(%ebp),%edx
    434a:	89 10                	mov    %edx,(%eax)
    434c:	8b 55 bc             	mov    -0x44(%ebp),%edx
    434f:	89 50 04             	mov    %edx,0x4(%eax)
    4352:	8b 55 c0             	mov    -0x40(%ebp),%edx
    4355:	89 50 08             	mov    %edx,0x8(%eax)
    4358:	e9 2d 02 00 00       	jmp    458a <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    435d:	83 ec 04             	sub    $0x4,%esp
    4360:	6a 0e                	push   $0xe
    4362:	8d 45 aa             	lea    -0x56(%ebp),%eax
    4365:	50                   	push   %eax
    4366:	ff 75 ec             	pushl  -0x14(%ebp)
    4369:	e8 68 d6 ff ff       	call   19d6 <read>
    436e:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    4371:	83 ec 04             	sub    $0x4,%esp
    4374:	6a 28                	push   $0x28
    4376:	8d 45 82             	lea    -0x7e(%ebp),%eax
    4379:	50                   	push   %eax
    437a:	ff 75 ec             	pushl  -0x14(%ebp)
    437d:	e8 54 d6 ff ff       	call   19d6 <read>
    4382:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    4385:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    4389:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    438c:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    4390:	0f b7 d8             	movzwl %ax,%ebx
    4393:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    4396:	8b 55 ac             	mov    -0x54(%ebp),%edx
    4399:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    439d:	0f b7 c0             	movzwl %ax,%eax
    43a0:	83 ec 04             	sub    $0x4,%esp
    43a3:	6a 36                	push   $0x36
    43a5:	56                   	push   %esi
    43a6:	53                   	push   %ebx
    43a7:	51                   	push   %ecx
    43a8:	52                   	push   %edx
    43a9:	50                   	push   %eax
    43aa:	68 98 b3 01 00       	push   $0x1b398
    43af:	e8 b1 d7 ff ff       	call   1b65 <printf>
    43b4:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    43b7:	8b 45 86             	mov    -0x7a(%ebp),%eax
    43ba:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    43bd:	8b 45 8a             	mov    -0x76(%ebp),%eax
    43c0:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    43c3:	8b 55 b8             	mov    -0x48(%ebp),%edx
    43c6:	8b 45 bc             	mov    -0x44(%ebp),%eax
    43c9:	0f af c2             	imul   %edx,%eax
    43cc:	89 c2                	mov    %eax,%edx
    43ce:	89 d0                	mov    %edx,%eax
    43d0:	01 c0                	add    %eax,%eax
    43d2:	01 d0                	add    %edx,%eax
    43d4:	83 ec 0c             	sub    $0xc,%esp
    43d7:	50                   	push   %eax
    43d8:	e8 5b da ff ff       	call   1e38 <malloc>
    43dd:	83 c4 10             	add    $0x10,%esp
    43e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    43e3:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    43e7:	0f b7 c0             	movzwl %ax,%eax
    43ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    43ed:	8b 45 b8             	mov    -0x48(%ebp),%eax
    43f0:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    43f4:	83 c0 1f             	add    $0x1f,%eax
    43f7:	c1 f8 05             	sar    $0x5,%eax
    43fa:	c1 e0 02             	shl    $0x2,%eax
    43fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    4400:	8b 45 bc             	mov    -0x44(%ebp),%eax
    4403:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    4407:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    440a:	8b 55 bc             	mov    -0x44(%ebp),%edx
    440d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    4410:	83 ec 08             	sub    $0x8,%esp
    4413:	52                   	push   %edx
    4414:	50                   	push   %eax
    4415:	ff 75 e8             	pushl  -0x18(%ebp)
    4418:	ff 75 e0             	pushl  -0x20(%ebp)
    441b:	ff 75 e4             	pushl  -0x1c(%ebp)
    441e:	68 c0 b3 01 00       	push   $0x1b3c0
    4423:	e8 3d d7 ff ff       	call   1b65 <printf>
    4428:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    442b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    442e:	83 e8 36             	sub    $0x36,%eax
    4431:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    4434:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4437:	83 ec 0c             	sub    $0xc,%esp
    443a:	50                   	push   %eax
    443b:	e8 f8 d9 ff ff       	call   1e38 <malloc>
    4440:	83 c4 10             	add    $0x10,%esp
    4443:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    4446:	83 ec 04             	sub    $0x4,%esp
    4449:	ff 75 dc             	pushl  -0x24(%ebp)
    444c:	ff 75 d8             	pushl  -0x28(%ebp)
    444f:	ff 75 ec             	pushl  -0x14(%ebp)
    4452:	e8 7f d5 ff ff       	call   19d6 <read>
    4457:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    445a:	8b 45 ac             	mov    -0x54(%ebp),%eax
    445d:	83 ec 0c             	sub    $0xc,%esp
    4460:	50                   	push   %eax
    4461:	e8 d2 d9 ff ff       	call   1e38 <malloc>
    4466:	83 c4 10             	add    $0x10,%esp
    4469:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    446c:	8b 45 ac             	mov    -0x54(%ebp),%eax
    446f:	83 ec 04             	sub    $0x4,%esp
    4472:	50                   	push   %eax
    4473:	ff 75 d4             	pushl  -0x2c(%ebp)
    4476:	ff 75 ec             	pushl  -0x14(%ebp)
    4479:	e8 58 d5 ff ff       	call   19d6 <read>
    447e:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    4481:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    4485:	66 c1 e8 03          	shr    $0x3,%ax
    4489:	0f b7 c0             	movzwl %ax,%eax
    448c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    448f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4496:	e9 c1 00 00 00       	jmp    455c <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    449b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    449e:	2b 45 f4             	sub    -0xc(%ebp),%eax
    44a1:	8d 50 ff             	lea    -0x1(%eax),%edx
    44a4:	8b 45 b8             	mov    -0x48(%ebp),%eax
    44a7:	0f af c2             	imul   %edx,%eax
    44aa:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    44ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44b0:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    44b4:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    44b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    44be:	e9 89 00 00 00       	jmp    454c <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    44c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    44c6:	83 c0 01             	add    $0x1,%eax
    44c9:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    44cd:	89 c2                	mov    %eax,%edx
    44cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
    44d2:	01 d0                	add    %edx,%eax
    44d4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    44d7:	8b 55 c0             	mov    -0x40(%ebp),%edx
    44da:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    44dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    44e0:	01 c8                	add    %ecx,%eax
    44e2:	89 c1                	mov    %eax,%ecx
    44e4:	89 c8                	mov    %ecx,%eax
    44e6:	01 c0                	add    %eax,%eax
    44e8:	01 c8                	add    %ecx,%eax
    44ea:	01 c2                	add    %eax,%edx
    44ec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    44ef:	8d 48 ff             	lea    -0x1(%eax),%ecx
    44f2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    44f5:	01 c8                	add    %ecx,%eax
    44f7:	0f b6 00             	movzbl (%eax),%eax
    44fa:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    44fd:	8b 55 c0             	mov    -0x40(%ebp),%edx
    4500:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    4503:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4506:	01 c8                	add    %ecx,%eax
    4508:	89 c1                	mov    %eax,%ecx
    450a:	89 c8                	mov    %ecx,%eax
    450c:	01 c0                	add    %eax,%eax
    450e:	01 c8                	add    %ecx,%eax
    4510:	01 c2                	add    %eax,%edx
    4512:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4515:	8d 48 fe             	lea    -0x2(%eax),%ecx
    4518:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    451b:	01 c8                	add    %ecx,%eax
    451d:	0f b6 00             	movzbl (%eax),%eax
    4520:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    4523:	8b 55 c0             	mov    -0x40(%ebp),%edx
    4526:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    4529:	8b 45 f0             	mov    -0x10(%ebp),%eax
    452c:	01 c8                	add    %ecx,%eax
    452e:	89 c1                	mov    %eax,%ecx
    4530:	89 c8                	mov    %ecx,%eax
    4532:	01 c0                	add    %eax,%eax
    4534:	01 c8                	add    %ecx,%eax
    4536:	01 c2                	add    %eax,%edx
    4538:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    453b:	8d 48 fd             	lea    -0x3(%eax),%ecx
    453e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4541:	01 c8                	add    %ecx,%eax
    4543:	0f b6 00             	movzbl (%eax),%eax
    4546:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    4548:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    454c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    454f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4552:	0f 8f 6b ff ff ff    	jg     44c3 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    4558:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    455c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    455f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    4562:	0f 8f 33 ff ff ff    	jg     449b <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    4568:	83 ec 0c             	sub    $0xc,%esp
    456b:	ff 75 ec             	pushl  -0x14(%ebp)
    456e:	e8 73 d4 ff ff       	call   19e6 <close>
    4573:	83 c4 10             	add    $0x10,%esp
    return bmp;
    4576:	8b 45 08             	mov    0x8(%ebp),%eax
    4579:	8b 55 b8             	mov    -0x48(%ebp),%edx
    457c:	89 10                	mov    %edx,(%eax)
    457e:	8b 55 bc             	mov    -0x44(%ebp),%edx
    4581:	89 50 04             	mov    %edx,0x4(%eax)
    4584:	8b 55 c0             	mov    -0x40(%ebp),%edx
    4587:	89 50 08             	mov    %edx,0x8(%eax)
}
    458a:	8b 45 08             	mov    0x8(%ebp),%eax
    458d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4590:	5b                   	pop    %ebx
    4591:	5e                   	pop    %esi
    4592:	5d                   	pop    %ebp
    4593:	c2 04 00             	ret    $0x4

00004596 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    4596:	55                   	push   %ebp
    4597:	89 e5                	mov    %esp,%ebp
    4599:	53                   	push   %ebx
    459a:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    459d:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    45a1:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    45a5:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    45a9:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    45ad:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    45b1:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    45b5:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    45b9:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    45bd:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    45c1:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    45c5:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    45c9:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    45cd:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    45d1:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    45d5:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    45d9:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    45dd:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    45e1:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    45e5:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    45e9:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    45ed:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    45f1:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    45f5:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    45f9:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    45fd:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    4601:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    4605:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    4609:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    460d:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    4611:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    4615:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    4619:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    461d:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    4621:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    4625:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    4629:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    462d:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    4631:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    4635:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    4639:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    463d:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    4641:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    4645:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    4649:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    464d:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    4651:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    4655:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    4659:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    465d:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    4661:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    4665:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    4669:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    466d:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    4671:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    4675:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    4679:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    467d:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    4681:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    4685:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    4689:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    468d:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    4691:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    4695:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    4699:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    469d:	83 ec 0c             	sub    $0xc,%esp
    46a0:	68 c8 02 08 00       	push   $0x802c8
    46a5:	e8 8e d7 ff ff       	call   1e38 <malloc>
    46aa:	83 c4 10             	add    $0x10,%esp
    46ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    46b0:	83 ec 04             	sub    $0x4,%esp
    46b3:	68 c8 02 08 00       	push   $0x802c8
    46b8:	6a 00                	push   $0x0
    46ba:	ff 75 f0             	pushl  -0x10(%ebp)
    46bd:	e8 61 d1 ff ff       	call   1823 <memset>
    46c2:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    46c5:	83 ec 08             	sub    $0x8,%esp
    46c8:	6a 00                	push   $0x0
    46ca:	ff 75 0c             	pushl  0xc(%ebp)
    46cd:	e8 2c d3 ff ff       	call   19fe <open>
    46d2:	83 c4 10             	add    $0x10,%esp
    46d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    46d8:	83 ec 0c             	sub    $0xc,%esp
    46db:	68 40 42 0f 00       	push   $0xf4240
    46e0:	e8 53 d7 ff ff       	call   1e38 <malloc>
    46e5:	83 c4 10             	add    $0x10,%esp
    46e8:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    46eb:	83 ec 04             	sub    $0x4,%esp
    46ee:	68 40 42 0f 00       	push   $0xf4240
    46f3:	ff 75 e8             	pushl  -0x18(%ebp)
    46f6:	ff 75 ec             	pushl  -0x14(%ebp)
    46f9:	e8 d8 d2 ff ff       	call   19d6 <read>
    46fe:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    4701:	83 ec 0c             	sub    $0xc,%esp
    4704:	ff 75 ec             	pushl  -0x14(%ebp)
    4707:	e8 da d2 ff ff       	call   19e6 <close>
    470c:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    470f:	68 40 42 0f 00       	push   $0xf4240
    4714:	ff 75 e8             	pushl  -0x18(%ebp)
    4717:	8d 45 9c             	lea    -0x64(%ebp),%eax
    471a:	50                   	push   %eax
    471b:	ff 75 f0             	pushl  -0x10(%ebp)
    471e:	e8 5e 0c 01 00       	call   15381 <_DecodeJPEG>
    4723:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    4726:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    472d:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    4734:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    473b:	83 ec 0c             	sub    $0xc,%esp
    473e:	ff 75 f0             	pushl  -0x10(%ebp)
    4741:	e8 29 0b 01 00       	call   1526f <GetImageSize>
    4746:	83 c4 10             	add    $0x10,%esp
    4749:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    474c:	83 ec 0c             	sub    $0xc,%esp
    474f:	ff 75 f0             	pushl  -0x10(%ebp)
    4752:	e8 e1 0a 01 00       	call   15238 <GetImage>
    4757:	83 c4 10             	add    $0x10,%esp
    475a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    475d:	83 ec 0c             	sub    $0xc,%esp
    4760:	ff 75 f0             	pushl  -0x10(%ebp)
    4763:	e8 f1 0a 01 00       	call   15259 <GetWidth>
    4768:	83 c4 10             	add    $0x10,%esp
    476b:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    476e:	83 ec 0c             	sub    $0xc,%esp
    4771:	ff 75 f0             	pushl  -0x10(%ebp)
    4774:	e8 eb 0a 01 00       	call   15264 <GetHeight>
    4779:	83 c4 10             	add    $0x10,%esp
    477c:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    477f:	8b 55 90             	mov    -0x70(%ebp),%edx
    4782:	8b 45 94             	mov    -0x6c(%ebp),%eax
    4785:	0f af c2             	imul   %edx,%eax
    4788:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    478b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    478e:	89 d0                	mov    %edx,%eax
    4790:	01 c0                	add    %eax,%eax
    4792:	01 d0                	add    %edx,%eax
    4794:	83 ec 0c             	sub    $0xc,%esp
    4797:	50                   	push   %eax
    4798:	e8 9b d6 ff ff       	call   1e38 <malloc>
    479d:	83 c4 10             	add    $0x10,%esp
    47a0:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    47a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    47aa:	e9 9c 00 00 00       	jmp    484b <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    47af:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    47b2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    47b5:	ba 56 55 55 55       	mov    $0x55555556,%edx
    47ba:	89 c8                	mov    %ecx,%eax
    47bc:	f7 ea                	imul   %edx
    47be:	89 c8                	mov    %ecx,%eax
    47c0:	c1 f8 1f             	sar    $0x1f,%eax
    47c3:	29 c2                	sub    %eax,%edx
    47c5:	89 d0                	mov    %edx,%eax
    47c7:	89 c2                	mov    %eax,%edx
    47c9:	89 d0                	mov    %edx,%eax
    47cb:	01 c0                	add    %eax,%eax
    47cd:	01 d0                	add    %edx,%eax
    47cf:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    47d2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    47d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    47d8:	01 c8                	add    %ecx,%eax
    47da:	0f b6 00             	movzbl (%eax),%eax
    47dd:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    47e0:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    47e3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    47e6:	ba 56 55 55 55       	mov    $0x55555556,%edx
    47eb:	89 c8                	mov    %ecx,%eax
    47ed:	f7 ea                	imul   %edx
    47ef:	89 c8                	mov    %ecx,%eax
    47f1:	c1 f8 1f             	sar    $0x1f,%eax
    47f4:	29 c2                	sub    %eax,%edx
    47f6:	89 d0                	mov    %edx,%eax
    47f8:	89 c2                	mov    %eax,%edx
    47fa:	89 d0                	mov    %edx,%eax
    47fc:	01 c0                	add    %eax,%eax
    47fe:	01 d0                	add    %edx,%eax
    4800:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4803:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4806:	8d 48 01             	lea    0x1(%eax),%ecx
    4809:	8b 45 e0             	mov    -0x20(%ebp),%eax
    480c:	01 c8                	add    %ecx,%eax
    480e:	0f b6 00             	movzbl (%eax),%eax
    4811:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    4814:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    4817:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    481a:	ba 56 55 55 55       	mov    $0x55555556,%edx
    481f:	89 c8                	mov    %ecx,%eax
    4821:	f7 ea                	imul   %edx
    4823:	89 c8                	mov    %ecx,%eax
    4825:	c1 f8 1f             	sar    $0x1f,%eax
    4828:	29 c2                	sub    %eax,%edx
    482a:	89 d0                	mov    %edx,%eax
    482c:	89 c2                	mov    %eax,%edx
    482e:	89 d0                	mov    %edx,%eax
    4830:	01 c0                	add    %eax,%eax
    4832:	01 d0                	add    %edx,%eax
    4834:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4837:	8b 45 f4             	mov    -0xc(%ebp),%eax
    483a:	8d 48 02             	lea    0x2(%eax),%ecx
    483d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4840:	01 c8                	add    %ecx,%eax
    4842:	0f b6 00             	movzbl (%eax),%eax
    4845:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    4847:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    484b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    484e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    4851:	0f 8c 58 ff ff ff    	jl     47af <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    4857:	8b 45 08             	mov    0x8(%ebp),%eax
    485a:	8b 55 90             	mov    -0x70(%ebp),%edx
    485d:	89 10                	mov    %edx,(%eax)
    485f:	8b 55 94             	mov    -0x6c(%ebp),%edx
    4862:	89 50 04             	mov    %edx,0x4(%eax)
    4865:	8b 55 98             	mov    -0x68(%ebp),%edx
    4868:	89 50 08             	mov    %edx,0x8(%eax)
}
    486b:	8b 45 08             	mov    0x8(%ebp),%eax
    486e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4871:	c9                   	leave  
    4872:	c2 04 00             	ret    $0x4

00004875 <LoadPng>:

PBitmap LoadPng(char* filename){
    4875:	55                   	push   %ebp
    4876:	89 e5                	mov    %esp,%ebp
    4878:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    487b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    4882:	ff 75 0c             	pushl  0xc(%ebp)
    4885:	8d 45 e0             	lea    -0x20(%ebp),%eax
    4888:	50                   	push   %eax
    4889:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    488c:	50                   	push   %eax
    488d:	8d 45 e8             	lea    -0x18(%ebp),%eax
    4890:	50                   	push   %eax
    4891:	e8 d3 d3 00 00       	call   11c69 <lodepng_decode24_file>
    4896:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    4899:	8b 45 e0             	mov    -0x20(%ebp),%eax
    489c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    489f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    48a5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    48ac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    48af:	8b 45 d8             	mov    -0x28(%ebp),%eax
    48b2:	0f af c2             	imul   %edx,%eax
    48b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    48b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    48bb:	89 d0                	mov    %edx,%eax
    48bd:	01 c0                	add    %eax,%eax
    48bf:	01 d0                	add    %edx,%eax
    48c1:	83 ec 0c             	sub    $0xc,%esp
    48c4:	50                   	push   %eax
    48c5:	e8 6e d5 ff ff       	call   1e38 <malloc>
    48ca:	83 c4 10             	add    $0x10,%esp
    48cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    48d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    48d7:	e9 87 00 00 00       	jmp    4963 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    48dc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    48df:	8b 55 f4             	mov    -0xc(%ebp),%edx
    48e2:	89 d0                	mov    %edx,%eax
    48e4:	01 c0                	add    %eax,%eax
    48e6:	01 d0                	add    %edx,%eax
    48e8:	01 c8                	add    %ecx,%eax
    48ea:	0f b6 00             	movzbl (%eax),%eax
    48ed:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    48f0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    48f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    48f6:	89 d0                	mov    %edx,%eax
    48f8:	01 c0                	add    %eax,%eax
    48fa:	01 d0                	add    %edx,%eax
    48fc:	83 c0 01             	add    $0x1,%eax
    48ff:	01 c8                	add    %ecx,%eax
    4901:	0f b6 00             	movzbl (%eax),%eax
    4904:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    4907:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    490a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    490d:	89 d0                	mov    %edx,%eax
    490f:	01 c0                	add    %eax,%eax
    4911:	01 d0                	add    %edx,%eax
    4913:	83 c0 02             	add    $0x2,%eax
    4916:	01 c8                	add    %ecx,%eax
    4918:	0f b6 00             	movzbl (%eax),%eax
    491b:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    491e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    4921:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4924:	89 d0                	mov    %edx,%eax
    4926:	01 c0                	add    %eax,%eax
    4928:	01 d0                	add    %edx,%eax
    492a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    492d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    4931:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    4934:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    4937:	8b 55 f4             	mov    -0xc(%ebp),%edx
    493a:	89 d0                	mov    %edx,%eax
    493c:	01 c0                	add    %eax,%eax
    493e:	01 d0                	add    %edx,%eax
    4940:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    4943:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    4947:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    494a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    494d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4950:	89 d0                	mov    %edx,%eax
    4952:	01 c0                	add    %eax,%eax
    4954:	01 d0                	add    %edx,%eax
    4956:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    4959:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    495d:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    495f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4963:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4966:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4969:	0f 8c 6d ff ff ff    	jl     48dc <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    496f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4972:	83 ec 0c             	sub    $0xc,%esp
    4975:	50                   	push   %eax
    4976:	e8 7b d3 ff ff       	call   1cf6 <free>
    497b:	83 c4 10             	add    $0x10,%esp
    return bmp;
    497e:	8b 45 08             	mov    0x8(%ebp),%eax
    4981:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    4984:	89 10                	mov    %edx,(%eax)
    4986:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4989:	89 50 04             	mov    %edx,0x4(%eax)
    498c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    498f:	89 50 08             	mov    %edx,0x8(%eax)

}
    4992:	8b 45 08             	mov    0x8(%ebp),%eax
    4995:	c9                   	leave  
    4996:	c2 04 00             	ret    $0x4

00004999 <LoadImg>:

PBitmap LoadImg(char* filename){
    4999:	55                   	push   %ebp
    499a:	89 e5                	mov    %esp,%ebp
    499c:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    499f:	83 ec 0c             	sub    $0xc,%esp
    49a2:	ff 75 0c             	pushl  0xc(%ebp)
    49a5:	e8 7c f8 ff ff       	call   4226 <type>
    49aa:	83 c4 10             	add    $0x10,%esp
    49ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    49b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49b3:	83 f8 01             	cmp    $0x1,%eax
    49b6:	74 1d                	je     49d5 <LoadImg+0x3c>
    49b8:	83 f8 02             	cmp    $0x2,%eax
    49bb:	74 2c                	je     49e9 <LoadImg+0x50>
    49bd:	85 c0                	test   %eax,%eax
    49bf:	75 3c                	jne    49fd <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    49c1:	8b 45 08             	mov    0x8(%ebp),%eax
    49c4:	83 ec 08             	sub    $0x8,%esp
    49c7:	ff 75 0c             	pushl  0xc(%ebp)
    49ca:	50                   	push   %eax
    49cb:	e8 c6 fb ff ff       	call   4596 <LoadJpeg>
    49d0:	83 c4 0c             	add    $0xc,%esp
    49d3:	eb 3c                	jmp    4a11 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    49d5:	8b 45 08             	mov    0x8(%ebp),%eax
    49d8:	83 ec 08             	sub    $0x8,%esp
    49db:	ff 75 0c             	pushl  0xc(%ebp)
    49de:	50                   	push   %eax
    49df:	e8 17 f9 ff ff       	call   42fb <LoadBmp>
    49e4:	83 c4 0c             	add    $0xc,%esp
    49e7:	eb 28                	jmp    4a11 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    49e9:	8b 45 08             	mov    0x8(%ebp),%eax
    49ec:	83 ec 08             	sub    $0x8,%esp
    49ef:	ff 75 0c             	pushl  0xc(%ebp)
    49f2:	50                   	push   %eax
    49f3:	e8 7d fe ff ff       	call   4875 <LoadPng>
    49f8:	83 c4 0c             	add    $0xc,%esp
    49fb:	eb 14                	jmp    4a11 <LoadImg+0x78>

        default: return bmp;
    49fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4a00:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4a03:	89 10                	mov    %edx,(%eax)
    4a05:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4a08:	89 50 04             	mov    %edx,0x4(%eax)
    4a0b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4a0e:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    4a11:	8b 45 08             	mov    0x8(%ebp),%eax
    4a14:	c9                   	leave  
    4a15:	c2 04 00             	ret    $0x4

00004a18 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    4a18:	55                   	push   %ebp
    4a19:	89 e5                	mov    %esp,%ebp
    4a1b:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    4a1e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a21:	83 ec 0c             	sub    $0xc,%esp
    4a24:	50                   	push   %eax
    4a25:	e8 0e d4 ff ff       	call   1e38 <malloc>
    4a2a:	83 c4 10             	add    $0x10,%esp
}
    4a2d:	c9                   	leave  
    4a2e:	c3                   	ret    

00004a2f <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    4a2f:	55                   	push   %ebp
    4a30:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    4a32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    4a37:	5d                   	pop    %ebp
    4a38:	c3                   	ret    

00004a39 <lodepng_free>:

static void lodepng_free(void* ptr) {
    4a39:	55                   	push   %ebp
    4a3a:	89 e5                	mov    %esp,%ebp
    4a3c:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    4a3f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    4a43:	74 0e                	je     4a53 <lodepng_free+0x1a>
    free(ptr);
    4a45:	83 ec 0c             	sub    $0xc,%esp
    4a48:	ff 75 08             	pushl  0x8(%ebp)
    4a4b:	e8 a6 d2 ff ff       	call   1cf6 <free>
    4a50:	83 c4 10             	add    $0x10,%esp
}
    4a53:	90                   	nop
    4a54:	c9                   	leave  
    4a55:	c3                   	ret    

00004a56 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    4a56:	55                   	push   %ebp
    4a57:	89 e5                	mov    %esp,%ebp
    4a59:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    4a5c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    4a63:	eb 19                	jmp    4a7e <lodepng_memcpy+0x28>
    4a65:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4a68:	8b 45 08             	mov    0x8(%ebp),%eax
    4a6b:	01 c2                	add    %eax,%edx
    4a6d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4a70:	8b 45 0c             	mov    0xc(%ebp),%eax
    4a73:	01 c8                	add    %ecx,%eax
    4a75:	0f b6 00             	movzbl (%eax),%eax
    4a78:	88 02                	mov    %al,(%edx)
    4a7a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4a7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4a81:	3b 45 10             	cmp    0x10(%ebp),%eax
    4a84:	7c df                	jl     4a65 <lodepng_memcpy+0xf>
}
    4a86:	90                   	nop
    4a87:	c9                   	leave  
    4a88:	c3                   	ret    

00004a89 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    4a89:	55                   	push   %ebp
    4a8a:	89 e5                	mov    %esp,%ebp
    4a8c:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    4a8f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    4a96:	eb 11                	jmp    4aa9 <lodepng_memset+0x20>
    4a98:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4a9b:	8b 45 08             	mov    0x8(%ebp),%eax
    4a9e:	01 d0                	add    %edx,%eax
    4aa0:	8b 55 0c             	mov    0xc(%ebp),%edx
    4aa3:	88 10                	mov    %dl,(%eax)
    4aa5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4aa9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4aac:	3b 45 10             	cmp    0x10(%ebp),%eax
    4aaf:	7c e7                	jl     4a98 <lodepng_memset+0xf>
}
    4ab1:	90                   	nop
    4ab2:	c9                   	leave  
    4ab3:	c3                   	ret    

00004ab4 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    4ab4:	55                   	push   %ebp
    4ab5:	89 e5                	mov    %esp,%ebp
    4ab7:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    4aba:	8b 45 08             	mov    0x8(%ebp),%eax
    4abd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    4ac0:	eb 04                	jmp    4ac6 <lodepng_strlen+0x12>
    4ac2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    4ac6:	8b 45 08             	mov    0x8(%ebp),%eax
    4ac9:	0f b6 00             	movzbl (%eax),%eax
    4acc:	84 c0                	test   %al,%al
    4ace:	75 f2                	jne    4ac2 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    4ad0:	8b 55 08             	mov    0x8(%ebp),%edx
    4ad3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4ad6:	29 c2                	sub    %eax,%edx
    4ad8:	89 d0                	mov    %edx,%eax
}
    4ada:	c9                   	leave  
    4adb:	c3                   	ret    

00004adc <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    4adc:	55                   	push   %ebp
    4add:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    4adf:	8b 55 08             	mov    0x8(%ebp),%edx
    4ae2:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ae5:	01 c2                	add    %eax,%edx
    4ae7:	8b 45 10             	mov    0x10(%ebp),%eax
    4aea:	89 10                	mov    %edx,(%eax)
  return *result < a;
    4aec:	8b 45 10             	mov    0x10(%ebp),%eax
    4aef:	8b 00                	mov    (%eax),%eax
    4af1:	3b 45 08             	cmp    0x8(%ebp),%eax
    4af4:	0f 9c c0             	setl   %al
    4af7:	0f b6 c0             	movzbl %al,%eax
}
    4afa:	5d                   	pop    %ebp
    4afb:	c3                   	ret    

00004afc <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    4afc:	55                   	push   %ebp
    4afd:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    4aff:	8b 45 08             	mov    0x8(%ebp),%eax
    4b02:	0f af 45 0c          	imul   0xc(%ebp),%eax
    4b06:	89 c2                	mov    %eax,%edx
    4b08:	8b 45 10             	mov    0x10(%ebp),%eax
    4b0b:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    4b0d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    4b11:	74 15                	je     4b28 <lodepng_mulofl+0x2c>
    4b13:	8b 45 10             	mov    0x10(%ebp),%eax
    4b16:	8b 00                	mov    (%eax),%eax
    4b18:	99                   	cltd   
    4b19:	f7 7d 08             	idivl  0x8(%ebp)
    4b1c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4b1f:	74 07                	je     4b28 <lodepng_mulofl+0x2c>
    4b21:	b8 01 00 00 00       	mov    $0x1,%eax
    4b26:	eb 05                	jmp    4b2d <lodepng_mulofl+0x31>
    4b28:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4b2d:	5d                   	pop    %ebp
    4b2e:	c3                   	ret    

00004b2f <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    4b2f:	55                   	push   %ebp
    4b30:	89 e5                	mov    %esp,%ebp
    4b32:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    4b35:	8d 45 fc             	lea    -0x4(%ebp),%eax
    4b38:	50                   	push   %eax
    4b39:	ff 75 0c             	pushl  0xc(%ebp)
    4b3c:	ff 75 08             	pushl  0x8(%ebp)
    4b3f:	e8 98 ff ff ff       	call   4adc <lodepng_addofl>
    4b44:	83 c4 0c             	add    $0xc,%esp
    4b47:	85 c0                	test   %eax,%eax
    4b49:	74 07                	je     4b52 <lodepng_gtofl+0x23>
    4b4b:	b8 01 00 00 00       	mov    $0x1,%eax
    4b50:	eb 0c                	jmp    4b5e <lodepng_gtofl+0x2f>
  return d > c;
    4b52:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4b55:	3b 45 10             	cmp    0x10(%ebp),%eax
    4b58:	0f 9f c0             	setg   %al
    4b5b:	0f b6 c0             	movzbl %al,%eax
}
    4b5e:	c9                   	leave  
    4b5f:	c3                   	ret    

00004b60 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    4b60:	55                   	push   %ebp
    4b61:	89 e5                	mov    %esp,%ebp
    4b63:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    4b66:	8b 45 08             	mov    0x8(%ebp),%eax
    4b69:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    4b70:	8b 45 08             	mov    0x8(%ebp),%eax
    4b73:	8b 50 08             	mov    0x8(%eax),%edx
    4b76:	8b 45 08             	mov    0x8(%ebp),%eax
    4b79:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    4b7c:	8b 45 08             	mov    0x8(%ebp),%eax
    4b7f:	8b 00                	mov    (%eax),%eax
    4b81:	83 ec 0c             	sub    $0xc,%esp
    4b84:	50                   	push   %eax
    4b85:	e8 af fe ff ff       	call   4a39 <lodepng_free>
    4b8a:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    4b8d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    4b96:	90                   	nop
    4b97:	c9                   	leave  
    4b98:	c3                   	ret    

00004b99 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    4b99:	55                   	push   %ebp
    4b9a:	89 e5                	mov    %esp,%ebp
    4b9c:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    4b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ba2:	c1 e0 02             	shl    $0x2,%eax
    4ba5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    4ba8:	8b 45 08             	mov    0x8(%ebp),%eax
    4bab:	8b 40 08             	mov    0x8(%eax),%eax
    4bae:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    4bb1:	7d 46                	jge    4bf9 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    4bb3:	8b 45 08             	mov    0x8(%ebp),%eax
    4bb6:	8b 40 08             	mov    0x8(%eax),%eax
    4bb9:	d1 f8                	sar    %eax
    4bbb:	89 c2                	mov    %eax,%edx
    4bbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4bc0:	01 d0                	add    %edx,%eax
    4bc2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    4bc5:	8b 45 08             	mov    0x8(%ebp),%eax
    4bc8:	8b 00                	mov    (%eax),%eax
    4bca:	ff 75 f8             	pushl  -0x8(%ebp)
    4bcd:	50                   	push   %eax
    4bce:	e8 5c fe ff ff       	call   4a2f <lodepng_realloc>
    4bd3:	83 c4 08             	add    $0x8,%esp
    4bd6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    4bd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4bdd:	74 13                	je     4bf2 <uivector_resize+0x59>
      p->allocsize = newsize;
    4bdf:	8b 45 08             	mov    0x8(%ebp),%eax
    4be2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4be5:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    4be8:	8b 45 08             	mov    0x8(%ebp),%eax
    4beb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4bee:	89 10                	mov    %edx,(%eax)
    4bf0:	eb 07                	jmp    4bf9 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    4bf2:	b8 00 00 00 00       	mov    $0x0,%eax
    4bf7:	eb 0e                	jmp    4c07 <uivector_resize+0x6e>
  }
  p->size = size;
    4bf9:	8b 45 08             	mov    0x8(%ebp),%eax
    4bfc:	8b 55 0c             	mov    0xc(%ebp),%edx
    4bff:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    4c02:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4c07:	c9                   	leave  
    4c08:	c3                   	ret    

00004c09 <uivector_init>:

static void uivector_init(uivector* p) {
    4c09:	55                   	push   %ebp
    4c0a:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    4c0c:	8b 45 08             	mov    0x8(%ebp),%eax
    4c0f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    4c15:	8b 45 08             	mov    0x8(%ebp),%eax
    4c18:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    4c1f:	8b 45 08             	mov    0x8(%ebp),%eax
    4c22:	8b 50 08             	mov    0x8(%eax),%edx
    4c25:	8b 45 08             	mov    0x8(%ebp),%eax
    4c28:	89 50 04             	mov    %edx,0x4(%eax)
}
    4c2b:	90                   	nop
    4c2c:	5d                   	pop    %ebp
    4c2d:	c3                   	ret    

00004c2e <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    4c2e:	55                   	push   %ebp
    4c2f:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    4c31:	8b 45 08             	mov    0x8(%ebp),%eax
    4c34:	8b 40 04             	mov    0x4(%eax),%eax
    4c37:	83 c0 01             	add    $0x1,%eax
    4c3a:	50                   	push   %eax
    4c3b:	ff 75 08             	pushl  0x8(%ebp)
    4c3e:	e8 56 ff ff ff       	call   4b99 <uivector_resize>
    4c43:	83 c4 08             	add    $0x8,%esp
    4c46:	85 c0                	test   %eax,%eax
    4c48:	75 07                	jne    4c51 <uivector_push_back+0x23>
    4c4a:	b8 00 00 00 00       	mov    $0x0,%eax
    4c4f:	eb 1f                	jmp    4c70 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    4c51:	8b 45 08             	mov    0x8(%ebp),%eax
    4c54:	8b 10                	mov    (%eax),%edx
    4c56:	8b 45 08             	mov    0x8(%ebp),%eax
    4c59:	8b 40 04             	mov    0x4(%eax),%eax
    4c5c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    4c61:	c1 e0 02             	shl    $0x2,%eax
    4c64:	01 c2                	add    %eax,%edx
    4c66:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c69:	89 02                	mov    %eax,(%edx)
  return 1;
    4c6b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4c70:	c9                   	leave  
    4c71:	c3                   	ret    

00004c72 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    4c72:	55                   	push   %ebp
    4c73:	89 e5                	mov    %esp,%ebp
    4c75:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    4c78:	8b 45 08             	mov    0x8(%ebp),%eax
    4c7b:	8b 40 08             	mov    0x8(%eax),%eax
    4c7e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4c81:	7d 46                	jge    4cc9 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    4c83:	8b 45 08             	mov    0x8(%ebp),%eax
    4c86:	8b 40 08             	mov    0x8(%eax),%eax
    4c89:	d1 f8                	sar    %eax
    4c8b:	89 c2                	mov    %eax,%edx
    4c8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c90:	01 d0                	add    %edx,%eax
    4c92:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    4c95:	8b 45 08             	mov    0x8(%ebp),%eax
    4c98:	8b 00                	mov    (%eax),%eax
    4c9a:	ff 75 fc             	pushl  -0x4(%ebp)
    4c9d:	50                   	push   %eax
    4c9e:	e8 8c fd ff ff       	call   4a2f <lodepng_realloc>
    4ca3:	83 c4 08             	add    $0x8,%esp
    4ca6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    4ca9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    4cad:	74 13                	je     4cc2 <ucvector_resize+0x50>
      p->allocsize = newsize;
    4caf:	8b 45 08             	mov    0x8(%ebp),%eax
    4cb2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4cb5:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    4cb8:	8b 45 08             	mov    0x8(%ebp),%eax
    4cbb:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4cbe:	89 10                	mov    %edx,(%eax)
    4cc0:	eb 07                	jmp    4cc9 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    4cc2:	b8 00 00 00 00       	mov    $0x0,%eax
    4cc7:	eb 0e                	jmp    4cd7 <ucvector_resize+0x65>
  }
  p->size = size;
    4cc9:	8b 45 08             	mov    0x8(%ebp),%eax
    4ccc:	8b 55 0c             	mov    0xc(%ebp),%edx
    4ccf:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    4cd2:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4cd7:	c9                   	leave  
    4cd8:	c3                   	ret    

00004cd9 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    4cd9:	55                   	push   %ebp
    4cda:	89 e5                	mov    %esp,%ebp
    4cdc:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    4cdf:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ce2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    4ce5:	8b 45 10             	mov    0x10(%ebp),%eax
    4ce8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    4ceb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4cee:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    4cf1:	8b 45 08             	mov    0x8(%ebp),%eax
    4cf4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4cf7:	89 10                	mov    %edx,(%eax)
    4cf9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4cfc:	89 50 04             	mov    %edx,0x4(%eax)
    4cff:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4d02:	89 50 08             	mov    %edx,0x8(%eax)
}
    4d05:	8b 45 08             	mov    0x8(%ebp),%eax
    4d08:	c9                   	leave  
    4d09:	c2 04 00             	ret    $0x4

00004d0c <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    4d0c:	55                   	push   %ebp
    4d0d:	89 e5                	mov    %esp,%ebp
    4d0f:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    4d12:	8b 45 08             	mov    0x8(%ebp),%eax
    4d15:	8b 00                	mov    (%eax),%eax
    4d17:	83 ec 0c             	sub    $0xc,%esp
    4d1a:	50                   	push   %eax
    4d1b:	e8 19 fd ff ff       	call   4a39 <lodepng_free>
    4d20:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    4d23:	8b 45 08             	mov    0x8(%ebp),%eax
    4d26:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    4d2c:	90                   	nop
    4d2d:	c9                   	leave  
    4d2e:	c3                   	ret    

00004d2f <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    4d2f:	55                   	push   %ebp
    4d30:	89 e5                	mov    %esp,%ebp
    4d32:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    4d35:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d38:	83 c0 01             	add    $0x1,%eax
    4d3b:	83 ec 0c             	sub    $0xc,%esp
    4d3e:	50                   	push   %eax
    4d3f:	e8 d4 fc ff ff       	call   4a18 <lodepng_malloc>
    4d44:	83 c4 10             	add    $0x10,%esp
    4d47:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    4d4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d4e:	74 1f                	je     4d6f <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    4d50:	83 ec 04             	sub    $0x4,%esp
    4d53:	ff 75 0c             	pushl  0xc(%ebp)
    4d56:	ff 75 08             	pushl  0x8(%ebp)
    4d59:	ff 75 f4             	pushl  -0xc(%ebp)
    4d5c:	e8 f5 fc ff ff       	call   4a56 <lodepng_memcpy>
    4d61:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    4d64:	8b 55 0c             	mov    0xc(%ebp),%edx
    4d67:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d6a:	01 d0                	add    %edx,%eax
    4d6c:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    4d6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4d72:	c9                   	leave  
    4d73:	c3                   	ret    

00004d74 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    4d74:	55                   	push   %ebp
    4d75:	89 e5                	mov    %esp,%ebp
    4d77:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    4d7a:	ff 75 08             	pushl  0x8(%ebp)
    4d7d:	e8 32 fd ff ff       	call   4ab4 <lodepng_strlen>
    4d82:	83 c4 04             	add    $0x4,%esp
    4d85:	83 ec 08             	sub    $0x8,%esp
    4d88:	50                   	push   %eax
    4d89:	ff 75 08             	pushl  0x8(%ebp)
    4d8c:	e8 9e ff ff ff       	call   4d2f <alloc_string_sized>
    4d91:	83 c4 10             	add    $0x10,%esp
}
    4d94:	c9                   	leave  
    4d95:	c3                   	ret    

00004d96 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    4d96:	55                   	push   %ebp
    4d97:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    4d99:	8b 45 08             	mov    0x8(%ebp),%eax
    4d9c:	0f b6 00             	movzbl (%eax),%eax
    4d9f:	0f b6 c0             	movzbl %al,%eax
    4da2:	c1 e0 18             	shl    $0x18,%eax
    4da5:	89 c2                	mov    %eax,%edx
    4da7:	8b 45 08             	mov    0x8(%ebp),%eax
    4daa:	83 c0 01             	add    $0x1,%eax
    4dad:	0f b6 00             	movzbl (%eax),%eax
    4db0:	0f b6 c0             	movzbl %al,%eax
    4db3:	c1 e0 10             	shl    $0x10,%eax
    4db6:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    4db8:	8b 45 08             	mov    0x8(%ebp),%eax
    4dbb:	83 c0 02             	add    $0x2,%eax
    4dbe:	0f b6 00             	movzbl (%eax),%eax
    4dc1:	0f b6 c0             	movzbl %al,%eax
    4dc4:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    4dc7:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    4dc9:	8b 45 08             	mov    0x8(%ebp),%eax
    4dcc:	83 c0 03             	add    $0x3,%eax
    4dcf:	0f b6 00             	movzbl (%eax),%eax
    4dd2:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    4dd5:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    4dd7:	5d                   	pop    %ebp
    4dd8:	c3                   	ret    

00004dd9 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    4dd9:	55                   	push   %ebp
    4dda:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    4ddc:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ddf:	c1 e8 18             	shr    $0x18,%eax
    4de2:	89 c2                	mov    %eax,%edx
    4de4:	8b 45 08             	mov    0x8(%ebp),%eax
    4de7:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    4de9:	8b 45 08             	mov    0x8(%ebp),%eax
    4dec:	83 c0 01             	add    $0x1,%eax
    4def:	8b 55 0c             	mov    0xc(%ebp),%edx
    4df2:	c1 ea 10             	shr    $0x10,%edx
    4df5:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    4df7:	8b 45 08             	mov    0x8(%ebp),%eax
    4dfa:	83 c0 02             	add    $0x2,%eax
    4dfd:	8b 55 0c             	mov    0xc(%ebp),%edx
    4e00:	c1 ea 08             	shr    $0x8,%edx
    4e03:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    4e05:	8b 45 08             	mov    0x8(%ebp),%eax
    4e08:	83 c0 03             	add    $0x3,%eax
    4e0b:	8b 55 0c             	mov    0xc(%ebp),%edx
    4e0e:	88 10                	mov    %dl,(%eax)
}
    4e10:	90                   	nop
    4e11:	5d                   	pop    %ebp
    4e12:	c3                   	ret    

00004e13 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    4e13:	55                   	push   %ebp
    4e14:	89 e5                	mov    %esp,%ebp
    4e16:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    4e19:	83 ec 08             	sub    $0x8,%esp
    4e1c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    4e1f:	50                   	push   %eax
    4e20:	ff 75 08             	pushl  0x8(%ebp)
    4e23:	e8 b7 ca ff ff       	call   18df <stat>
    4e28:	83 c4 10             	add    $0x10,%esp
  return s.size;
    4e2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4e2e:	c9                   	leave  
    4e2f:	c3                   	ret    

00004e30 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    4e30:	55                   	push   %ebp
    4e31:	89 e5                	mov    %esp,%ebp
    4e33:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    4e36:	83 ec 08             	sub    $0x8,%esp
    4e39:	6a 00                	push   $0x0
    4e3b:	ff 75 10             	pushl  0x10(%ebp)
    4e3e:	e8 bb cb ff ff       	call   19fe <open>
    4e43:	83 c4 10             	add    $0x10,%esp
    4e46:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    4e49:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4e4d:	79 07                	jns    4e56 <lodepng_buffer_file+0x26>
  {
      return -1;
    4e4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    4e54:	eb 19                	jmp    4e6f <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    4e56:	83 ec 04             	sub    $0x4,%esp
    4e59:	ff 75 0c             	pushl  0xc(%ebp)
    4e5c:	ff 75 08             	pushl  0x8(%ebp)
    4e5f:	ff 75 f4             	pushl  -0xc(%ebp)
    4e62:	e8 6f cb ff ff       	call   19d6 <read>
    4e67:	83 c4 10             	add    $0x10,%esp
  return 0;
    4e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4e6f:	c9                   	leave  
    4e70:	c3                   	ret    

00004e71 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    4e71:	55                   	push   %ebp
    4e72:	89 e5                	mov    %esp,%ebp
    4e74:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    4e77:	83 ec 0c             	sub    $0xc,%esp
    4e7a:	ff 75 10             	pushl  0x10(%ebp)
    4e7d:	e8 91 ff ff ff       	call   4e13 <lodepng_filesize>
    4e82:	83 c4 10             	add    $0x10,%esp
    4e85:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    4e88:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4e8c:	79 07                	jns    4e95 <lodepng_load_file+0x24>
    4e8e:	b8 4e 00 00 00       	mov    $0x4e,%eax
    4e93:	eb 4a                	jmp    4edf <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    4e95:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e98:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4e9b:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    4e9d:	83 ec 0c             	sub    $0xc,%esp
    4ea0:	ff 75 f4             	pushl  -0xc(%ebp)
    4ea3:	e8 70 fb ff ff       	call   4a18 <lodepng_malloc>
    4ea8:	83 c4 10             	add    $0x10,%esp
    4eab:	89 c2                	mov    %eax,%edx
    4ead:	8b 45 08             	mov    0x8(%ebp),%eax
    4eb0:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    4eb2:	8b 45 08             	mov    0x8(%ebp),%eax
    4eb5:	8b 00                	mov    (%eax),%eax
    4eb7:	85 c0                	test   %eax,%eax
    4eb9:	75 0d                	jne    4ec8 <lodepng_load_file+0x57>
    4ebb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4ebf:	7e 07                	jle    4ec8 <lodepng_load_file+0x57>
    4ec1:	b8 53 00 00 00       	mov    $0x53,%eax
    4ec6:	eb 17                	jmp    4edf <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    4ec8:	8b 45 08             	mov    0x8(%ebp),%eax
    4ecb:	8b 00                	mov    (%eax),%eax
    4ecd:	83 ec 04             	sub    $0x4,%esp
    4ed0:	ff 75 10             	pushl  0x10(%ebp)
    4ed3:	ff 75 f4             	pushl  -0xc(%ebp)
    4ed6:	50                   	push   %eax
    4ed7:	e8 54 ff ff ff       	call   4e30 <lodepng_buffer_file>
    4edc:	83 c4 10             	add    $0x10,%esp
}
    4edf:	c9                   	leave  
    4ee0:	c3                   	ret    

00004ee1 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    4ee1:	55                   	push   %ebp
    4ee2:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    4ee4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    4ee9:	5d                   	pop    %ebp
    4eea:	c3                   	ret    

00004eeb <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    4eeb:	55                   	push   %ebp
    4eec:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    4eee:	8b 45 08             	mov    0x8(%ebp),%eax
    4ef1:	8b 55 0c             	mov    0xc(%ebp),%edx
    4ef4:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    4ef6:	8b 45 08             	mov    0x8(%ebp),%eax
    4ef9:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    4efd:	90                   	nop
    4efe:	5d                   	pop    %ebp
    4eff:	c3                   	ret    

00004f00 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    4f00:	55                   	push   %ebp
    4f01:	89 e5                	mov    %esp,%ebp
    4f03:	56                   	push   %esi
    4f04:	53                   	push   %ebx
    4f05:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    4f08:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    4f0c:	0f 85 aa 00 00 00    	jne    4fbc <writeBits+0xbc>
    WRITEBIT(writer, value);
    4f12:	8b 45 08             	mov    0x8(%ebp),%eax
    4f15:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4f19:	0f b6 c0             	movzbl %al,%eax
    4f1c:	83 e0 07             	and    $0x7,%eax
    4f1f:	85 c0                	test   %eax,%eax
    4f21:	75 39                	jne    4f5c <writeBits+0x5c>
    4f23:	8b 45 08             	mov    0x8(%ebp),%eax
    4f26:	8b 00                	mov    (%eax),%eax
    4f28:	8b 40 04             	mov    0x4(%eax),%eax
    4f2b:	8d 50 01             	lea    0x1(%eax),%edx
    4f2e:	8b 45 08             	mov    0x8(%ebp),%eax
    4f31:	8b 00                	mov    (%eax),%eax
    4f33:	52                   	push   %edx
    4f34:	50                   	push   %eax
    4f35:	e8 38 fd ff ff       	call   4c72 <ucvector_resize>
    4f3a:	83 c4 08             	add    $0x8,%esp
    4f3d:	85 c0                	test   %eax,%eax
    4f3f:	0f 84 44 01 00 00    	je     5089 <writeBits+0x189>
    4f45:	8b 45 08             	mov    0x8(%ebp),%eax
    4f48:	8b 00                	mov    (%eax),%eax
    4f4a:	8b 10                	mov    (%eax),%edx
    4f4c:	8b 45 08             	mov    0x8(%ebp),%eax
    4f4f:	8b 00                	mov    (%eax),%eax
    4f51:	8b 40 04             	mov    0x4(%eax),%eax
    4f54:	83 e8 01             	sub    $0x1,%eax
    4f57:	01 d0                	add    %edx,%eax
    4f59:	c6 00 00             	movb   $0x0,(%eax)
    4f5c:	8b 45 08             	mov    0x8(%ebp),%eax
    4f5f:	8b 00                	mov    (%eax),%eax
    4f61:	8b 10                	mov    (%eax),%edx
    4f63:	8b 45 08             	mov    0x8(%ebp),%eax
    4f66:	8b 00                	mov    (%eax),%eax
    4f68:	8b 40 04             	mov    0x4(%eax),%eax
    4f6b:	83 e8 01             	sub    $0x1,%eax
    4f6e:	01 c2                	add    %eax,%edx
    4f70:	8b 45 08             	mov    0x8(%ebp),%eax
    4f73:	8b 00                	mov    (%eax),%eax
    4f75:	8b 08                	mov    (%eax),%ecx
    4f77:	8b 45 08             	mov    0x8(%ebp),%eax
    4f7a:	8b 00                	mov    (%eax),%eax
    4f7c:	8b 40 04             	mov    0x4(%eax),%eax
    4f7f:	83 e8 01             	sub    $0x1,%eax
    4f82:	01 c8                	add    %ecx,%eax
    4f84:	0f b6 00             	movzbl (%eax),%eax
    4f87:	88 45 e7             	mov    %al,-0x19(%ebp)
    4f8a:	8b 45 08             	mov    0x8(%ebp),%eax
    4f8d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4f91:	0f b6 c0             	movzbl %al,%eax
    4f94:	83 e0 07             	and    $0x7,%eax
    4f97:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4f9a:	89 de                	mov    %ebx,%esi
    4f9c:	89 c1                	mov    %eax,%ecx
    4f9e:	d3 e6                	shl    %cl,%esi
    4fa0:	89 f0                	mov    %esi,%eax
    4fa2:	0a 45 e7             	or     -0x19(%ebp),%al
    4fa5:	88 02                	mov    %al,(%edx)
    4fa7:	8b 45 08             	mov    0x8(%ebp),%eax
    4faa:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4fae:	8d 50 01             	lea    0x1(%eax),%edx
    4fb1:	8b 45 08             	mov    0x8(%ebp),%eax
    4fb4:	88 50 04             	mov    %dl,0x4(%eax)
    4fb7:	e9 d1 00 00 00       	jmp    508d <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    4fbc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4fc3:	e9 b3 00 00 00       	jmp    507b <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    4fc8:	8b 45 08             	mov    0x8(%ebp),%eax
    4fcb:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4fcf:	0f b6 c0             	movzbl %al,%eax
    4fd2:	83 e0 07             	and    $0x7,%eax
    4fd5:	85 c0                	test   %eax,%eax
    4fd7:	75 39                	jne    5012 <writeBits+0x112>
    4fd9:	8b 45 08             	mov    0x8(%ebp),%eax
    4fdc:	8b 00                	mov    (%eax),%eax
    4fde:	8b 40 04             	mov    0x4(%eax),%eax
    4fe1:	8d 50 01             	lea    0x1(%eax),%edx
    4fe4:	8b 45 08             	mov    0x8(%ebp),%eax
    4fe7:	8b 00                	mov    (%eax),%eax
    4fe9:	52                   	push   %edx
    4fea:	50                   	push   %eax
    4feb:	e8 82 fc ff ff       	call   4c72 <ucvector_resize>
    4ff0:	83 c4 08             	add    $0x8,%esp
    4ff3:	85 c0                	test   %eax,%eax
    4ff5:	0f 84 91 00 00 00    	je     508c <writeBits+0x18c>
    4ffb:	8b 45 08             	mov    0x8(%ebp),%eax
    4ffe:	8b 00                	mov    (%eax),%eax
    5000:	8b 10                	mov    (%eax),%edx
    5002:	8b 45 08             	mov    0x8(%ebp),%eax
    5005:	8b 00                	mov    (%eax),%eax
    5007:	8b 40 04             	mov    0x4(%eax),%eax
    500a:	83 e8 01             	sub    $0x1,%eax
    500d:	01 d0                	add    %edx,%eax
    500f:	c6 00 00             	movb   $0x0,(%eax)
    5012:	8b 45 08             	mov    0x8(%ebp),%eax
    5015:	8b 00                	mov    (%eax),%eax
    5017:	8b 10                	mov    (%eax),%edx
    5019:	8b 45 08             	mov    0x8(%ebp),%eax
    501c:	8b 00                	mov    (%eax),%eax
    501e:	8b 40 04             	mov    0x4(%eax),%eax
    5021:	83 e8 01             	sub    $0x1,%eax
    5024:	01 c2                	add    %eax,%edx
    5026:	8b 45 08             	mov    0x8(%ebp),%eax
    5029:	8b 00                	mov    (%eax),%eax
    502b:	8b 08                	mov    (%eax),%ecx
    502d:	8b 45 08             	mov    0x8(%ebp),%eax
    5030:	8b 00                	mov    (%eax),%eax
    5032:	8b 40 04             	mov    0x4(%eax),%eax
    5035:	83 e8 01             	sub    $0x1,%eax
    5038:	01 c8                	add    %ecx,%eax
    503a:	0f b6 00             	movzbl (%eax),%eax
    503d:	89 c6                	mov    %eax,%esi
    503f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5042:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    5045:	89 c1                	mov    %eax,%ecx
    5047:	d3 eb                	shr    %cl,%ebx
    5049:	89 d8                	mov    %ebx,%eax
    504b:	83 e0 01             	and    $0x1,%eax
    504e:	89 c3                	mov    %eax,%ebx
    5050:	8b 45 08             	mov    0x8(%ebp),%eax
    5053:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    5057:	0f b6 c0             	movzbl %al,%eax
    505a:	83 e0 07             	and    $0x7,%eax
    505d:	89 c1                	mov    %eax,%ecx
    505f:	d3 e3                	shl    %cl,%ebx
    5061:	89 d8                	mov    %ebx,%eax
    5063:	09 f0                	or     %esi,%eax
    5065:	88 02                	mov    %al,(%edx)
    5067:	8b 45 08             	mov    0x8(%ebp),%eax
    506a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    506e:	8d 50 01             	lea    0x1(%eax),%edx
    5071:	8b 45 08             	mov    0x8(%ebp),%eax
    5074:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    5077:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    507b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    507e:	3b 45 10             	cmp    0x10(%ebp),%eax
    5081:	0f 85 41 ff ff ff    	jne    4fc8 <writeBits+0xc8>
    5087:	eb 04                	jmp    508d <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    5089:	90                   	nop
    508a:	eb 01                	jmp    508d <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    508c:	90                   	nop
    }
  }
}
    508d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5090:	5b                   	pop    %ebx
    5091:	5e                   	pop    %esi
    5092:	5d                   	pop    %ebp
    5093:	c3                   	ret    

00005094 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    5094:	55                   	push   %ebp
    5095:	89 e5                	mov    %esp,%ebp
    5097:	56                   	push   %esi
    5098:	53                   	push   %ebx
    5099:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    509c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    50a3:	e9 bd 00 00 00       	jmp    5165 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    50a8:	8b 45 08             	mov    0x8(%ebp),%eax
    50ab:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    50af:	0f b6 c0             	movzbl %al,%eax
    50b2:	83 e0 07             	and    $0x7,%eax
    50b5:	85 c0                	test   %eax,%eax
    50b7:	75 39                	jne    50f2 <writeBitsReversed+0x5e>
    50b9:	8b 45 08             	mov    0x8(%ebp),%eax
    50bc:	8b 00                	mov    (%eax),%eax
    50be:	8b 40 04             	mov    0x4(%eax),%eax
    50c1:	8d 50 01             	lea    0x1(%eax),%edx
    50c4:	8b 45 08             	mov    0x8(%ebp),%eax
    50c7:	8b 00                	mov    (%eax),%eax
    50c9:	52                   	push   %edx
    50ca:	50                   	push   %eax
    50cb:	e8 a2 fb ff ff       	call   4c72 <ucvector_resize>
    50d0:	83 c4 08             	add    $0x8,%esp
    50d3:	85 c0                	test   %eax,%eax
    50d5:	0f 84 98 00 00 00    	je     5173 <writeBitsReversed+0xdf>
    50db:	8b 45 08             	mov    0x8(%ebp),%eax
    50de:	8b 00                	mov    (%eax),%eax
    50e0:	8b 10                	mov    (%eax),%edx
    50e2:	8b 45 08             	mov    0x8(%ebp),%eax
    50e5:	8b 00                	mov    (%eax),%eax
    50e7:	8b 40 04             	mov    0x4(%eax),%eax
    50ea:	83 e8 01             	sub    $0x1,%eax
    50ed:	01 d0                	add    %edx,%eax
    50ef:	c6 00 00             	movb   $0x0,(%eax)
    50f2:	8b 45 08             	mov    0x8(%ebp),%eax
    50f5:	8b 00                	mov    (%eax),%eax
    50f7:	8b 10                	mov    (%eax),%edx
    50f9:	8b 45 08             	mov    0x8(%ebp),%eax
    50fc:	8b 00                	mov    (%eax),%eax
    50fe:	8b 40 04             	mov    0x4(%eax),%eax
    5101:	83 e8 01             	sub    $0x1,%eax
    5104:	01 c2                	add    %eax,%edx
    5106:	8b 45 08             	mov    0x8(%ebp),%eax
    5109:	8b 00                	mov    (%eax),%eax
    510b:	8b 08                	mov    (%eax),%ecx
    510d:	8b 45 08             	mov    0x8(%ebp),%eax
    5110:	8b 00                	mov    (%eax),%eax
    5112:	8b 40 04             	mov    0x4(%eax),%eax
    5115:	83 e8 01             	sub    $0x1,%eax
    5118:	01 c8                	add    %ecx,%eax
    511a:	0f b6 00             	movzbl (%eax),%eax
    511d:	89 c6                	mov    %eax,%esi
    511f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    5122:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5125:	29 c1                	sub    %eax,%ecx
    5127:	89 c8                	mov    %ecx,%eax
    5129:	83 e8 01             	sub    $0x1,%eax
    512c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    512f:	89 c1                	mov    %eax,%ecx
    5131:	d3 eb                	shr    %cl,%ebx
    5133:	89 d8                	mov    %ebx,%eax
    5135:	83 e0 01             	and    $0x1,%eax
    5138:	89 c3                	mov    %eax,%ebx
    513a:	8b 45 08             	mov    0x8(%ebp),%eax
    513d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    5141:	0f b6 c0             	movzbl %al,%eax
    5144:	83 e0 07             	and    $0x7,%eax
    5147:	89 c1                	mov    %eax,%ecx
    5149:	d3 e3                	shl    %cl,%ebx
    514b:	89 d8                	mov    %ebx,%eax
    514d:	09 f0                	or     %esi,%eax
    514f:	88 02                	mov    %al,(%edx)
    5151:	8b 45 08             	mov    0x8(%ebp),%eax
    5154:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    5158:	8d 50 01             	lea    0x1(%eax),%edx
    515b:	8b 45 08             	mov    0x8(%ebp),%eax
    515e:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    5161:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5165:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5168:	3b 45 10             	cmp    0x10(%ebp),%eax
    516b:	0f 85 37 ff ff ff    	jne    50a8 <writeBitsReversed+0x14>
    5171:	eb 01                	jmp    5174 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    5173:	90                   	nop
  }
}
    5174:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5177:	5b                   	pop    %ebx
    5178:	5e                   	pop    %esi
    5179:	5d                   	pop    %ebp
    517a:	c3                   	ret    

0000517b <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    517b:	55                   	push   %ebp
    517c:	89 e5                	mov    %esp,%ebp
    517e:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    5181:	8b 45 08             	mov    0x8(%ebp),%eax
    5184:	8b 55 0c             	mov    0xc(%ebp),%edx
    5187:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    5189:	8b 45 08             	mov    0x8(%ebp),%eax
    518c:	8b 55 10             	mov    0x10(%ebp),%edx
    518f:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    5192:	8b 45 08             	mov    0x8(%ebp),%eax
    5195:	83 c0 08             	add    $0x8,%eax
    5198:	50                   	push   %eax
    5199:	6a 08                	push   $0x8
    519b:	ff 75 10             	pushl  0x10(%ebp)
    519e:	e8 59 f9 ff ff       	call   4afc <lodepng_mulofl>
    51a3:	83 c4 0c             	add    $0xc,%esp
    51a6:	85 c0                	test   %eax,%eax
    51a8:	74 07                	je     51b1 <LodePNGBitReader_init+0x36>
    51aa:	b8 69 00 00 00       	mov    $0x69,%eax
    51af:	eb 39                	jmp    51ea <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    51b1:	8b 45 08             	mov    0x8(%ebp),%eax
    51b4:	8b 40 08             	mov    0x8(%eax),%eax
    51b7:	8d 55 fc             	lea    -0x4(%ebp),%edx
    51ba:	52                   	push   %edx
    51bb:	6a 40                	push   $0x40
    51bd:	50                   	push   %eax
    51be:	e8 19 f9 ff ff       	call   4adc <lodepng_addofl>
    51c3:	83 c4 0c             	add    $0xc,%esp
    51c6:	85 c0                	test   %eax,%eax
    51c8:	74 07                	je     51d1 <LodePNGBitReader_init+0x56>
    51ca:	b8 69 00 00 00       	mov    $0x69,%eax
    51cf:	eb 19                	jmp    51ea <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    51d1:	8b 45 08             	mov    0x8(%ebp),%eax
    51d4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    51db:	8b 45 08             	mov    0x8(%ebp),%eax
    51de:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    51e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    51ea:	c9                   	leave  
    51eb:	c3                   	ret    

000051ec <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    51ec:	55                   	push   %ebp
    51ed:	89 e5                	mov    %esp,%ebp
    51ef:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    51f2:	8b 45 08             	mov    0x8(%ebp),%eax
    51f5:	8b 40 0c             	mov    0xc(%eax),%eax
    51f8:	c1 f8 03             	sar    $0x3,%eax
    51fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    51fe:	8b 45 08             	mov    0x8(%ebp),%eax
    5201:	8b 40 04             	mov    0x4(%eax),%eax
    5204:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    5207:	8b 45 fc             	mov    -0x4(%ebp),%eax
    520a:	8d 50 01             	lea    0x1(%eax),%edx
    520d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5210:	39 c2                	cmp    %eax,%edx
    5212:	73 4e                	jae    5262 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    5214:	8b 45 08             	mov    0x8(%ebp),%eax
    5217:	8b 10                	mov    (%eax),%edx
    5219:	8b 45 fc             	mov    -0x4(%ebp),%eax
    521c:	01 d0                	add    %edx,%eax
    521e:	0f b6 00             	movzbl (%eax),%eax
    5221:	0f b6 d0             	movzbl %al,%edx
    5224:	8b 45 08             	mov    0x8(%ebp),%eax
    5227:	8b 00                	mov    (%eax),%eax
    5229:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    522c:	83 c1 01             	add    $0x1,%ecx
    522f:	01 c8                	add    %ecx,%eax
    5231:	0f b6 00             	movzbl (%eax),%eax
    5234:	0f b6 c0             	movzbl %al,%eax
    5237:	c1 e0 08             	shl    $0x8,%eax
    523a:	09 c2                	or     %eax,%edx
    523c:	8b 45 08             	mov    0x8(%ebp),%eax
    523f:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    5242:	8b 45 08             	mov    0x8(%ebp),%eax
    5245:	8b 50 10             	mov    0x10(%eax),%edx
    5248:	8b 45 08             	mov    0x8(%ebp),%eax
    524b:	8b 40 0c             	mov    0xc(%eax),%eax
    524e:	83 e0 07             	and    $0x7,%eax
    5251:	89 c1                	mov    %eax,%ecx
    5253:	d3 ea                	shr    %cl,%edx
    5255:	8b 45 08             	mov    0x8(%ebp),%eax
    5258:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    525b:	b8 01 00 00 00       	mov    $0x1,%eax
    5260:	eb 64                	jmp    52c6 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    5262:	8b 45 08             	mov    0x8(%ebp),%eax
    5265:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    526c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    526f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5272:	39 c2                	cmp    %eax,%edx
    5274:	73 1e                	jae    5294 <ensureBits9+0xa8>
    5276:	8b 45 08             	mov    0x8(%ebp),%eax
    5279:	8b 50 10             	mov    0x10(%eax),%edx
    527c:	8b 45 08             	mov    0x8(%ebp),%eax
    527f:	8b 08                	mov    (%eax),%ecx
    5281:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5284:	01 c8                	add    %ecx,%eax
    5286:	0f b6 00             	movzbl (%eax),%eax
    5289:	0f b6 c0             	movzbl %al,%eax
    528c:	09 c2                	or     %eax,%edx
    528e:	8b 45 08             	mov    0x8(%ebp),%eax
    5291:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    5294:	8b 45 08             	mov    0x8(%ebp),%eax
    5297:	8b 50 10             	mov    0x10(%eax),%edx
    529a:	8b 45 08             	mov    0x8(%ebp),%eax
    529d:	8b 40 0c             	mov    0xc(%eax),%eax
    52a0:	83 e0 07             	and    $0x7,%eax
    52a3:	89 c1                	mov    %eax,%ecx
    52a5:	d3 ea                	shr    %cl,%edx
    52a7:	8b 45 08             	mov    0x8(%ebp),%eax
    52aa:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    52ad:	8b 45 08             	mov    0x8(%ebp),%eax
    52b0:	8b 50 0c             	mov    0xc(%eax),%edx
    52b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    52b6:	01 c2                	add    %eax,%edx
    52b8:	8b 45 08             	mov    0x8(%ebp),%eax
    52bb:	8b 40 08             	mov    0x8(%eax),%eax
    52be:	39 c2                	cmp    %eax,%edx
    52c0:	0f 9e c0             	setle  %al
    52c3:	0f b6 c0             	movzbl %al,%eax
  }
}
    52c6:	c9                   	leave  
    52c7:	c3                   	ret    

000052c8 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    52c8:	55                   	push   %ebp
    52c9:	89 e5                	mov    %esp,%ebp
    52cb:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    52ce:	8b 45 08             	mov    0x8(%ebp),%eax
    52d1:	8b 40 0c             	mov    0xc(%eax),%eax
    52d4:	c1 f8 03             	sar    $0x3,%eax
    52d7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    52da:	8b 45 08             	mov    0x8(%ebp),%eax
    52dd:	8b 40 04             	mov    0x4(%eax),%eax
    52e0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    52e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    52e6:	8d 50 02             	lea    0x2(%eax),%edx
    52e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    52ec:	39 c2                	cmp    %eax,%edx
    52ee:	73 6d                	jae    535d <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    52f0:	8b 45 08             	mov    0x8(%ebp),%eax
    52f3:	8b 10                	mov    (%eax),%edx
    52f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    52f8:	01 d0                	add    %edx,%eax
    52fa:	0f b6 00             	movzbl (%eax),%eax
    52fd:	0f b6 d0             	movzbl %al,%edx
    5300:	8b 45 08             	mov    0x8(%ebp),%eax
    5303:	8b 00                	mov    (%eax),%eax
    5305:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    5308:	83 c1 01             	add    $0x1,%ecx
    530b:	01 c8                	add    %ecx,%eax
    530d:	0f b6 00             	movzbl (%eax),%eax
    5310:	0f b6 c0             	movzbl %al,%eax
    5313:	c1 e0 08             	shl    $0x8,%eax
    5316:	89 d1                	mov    %edx,%ecx
    5318:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    531a:	8b 45 08             	mov    0x8(%ebp),%eax
    531d:	8b 00                	mov    (%eax),%eax
    531f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    5322:	83 c2 02             	add    $0x2,%edx
    5325:	01 d0                	add    %edx,%eax
    5327:	0f b6 00             	movzbl (%eax),%eax
    532a:	0f b6 c0             	movzbl %al,%eax
    532d:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    5330:	09 c1                	or     %eax,%ecx
    5332:	89 ca                	mov    %ecx,%edx
    5334:	8b 45 08             	mov    0x8(%ebp),%eax
    5337:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    533a:	8b 45 08             	mov    0x8(%ebp),%eax
    533d:	8b 50 10             	mov    0x10(%eax),%edx
    5340:	8b 45 08             	mov    0x8(%ebp),%eax
    5343:	8b 40 0c             	mov    0xc(%eax),%eax
    5346:	83 e0 07             	and    $0x7,%eax
    5349:	89 c1                	mov    %eax,%ecx
    534b:	d3 ea                	shr    %cl,%edx
    534d:	8b 45 08             	mov    0x8(%ebp),%eax
    5350:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    5353:	b8 01 00 00 00       	mov    $0x1,%eax
    5358:	e9 95 00 00 00       	jmp    53f2 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    535d:	8b 45 08             	mov    0x8(%ebp),%eax
    5360:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    5367:	8b 55 fc             	mov    -0x4(%ebp),%edx
    536a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    536d:	39 c2                	cmp    %eax,%edx
    536f:	73 1e                	jae    538f <ensureBits17+0xc7>
    5371:	8b 45 08             	mov    0x8(%ebp),%eax
    5374:	8b 50 10             	mov    0x10(%eax),%edx
    5377:	8b 45 08             	mov    0x8(%ebp),%eax
    537a:	8b 08                	mov    (%eax),%ecx
    537c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    537f:	01 c8                	add    %ecx,%eax
    5381:	0f b6 00             	movzbl (%eax),%eax
    5384:	0f b6 c0             	movzbl %al,%eax
    5387:	09 c2                	or     %eax,%edx
    5389:	8b 45 08             	mov    0x8(%ebp),%eax
    538c:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    538f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5392:	8d 50 01             	lea    0x1(%eax),%edx
    5395:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5398:	39 c2                	cmp    %eax,%edx
    539a:	73 24                	jae    53c0 <ensureBits17+0xf8>
    539c:	8b 45 08             	mov    0x8(%ebp),%eax
    539f:	8b 50 10             	mov    0x10(%eax),%edx
    53a2:	8b 45 08             	mov    0x8(%ebp),%eax
    53a5:	8b 00                	mov    (%eax),%eax
    53a7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    53aa:	83 c1 01             	add    $0x1,%ecx
    53ad:	01 c8                	add    %ecx,%eax
    53af:	0f b6 00             	movzbl (%eax),%eax
    53b2:	0f b6 c0             	movzbl %al,%eax
    53b5:	c1 e0 08             	shl    $0x8,%eax
    53b8:	09 c2                	or     %eax,%edx
    53ba:	8b 45 08             	mov    0x8(%ebp),%eax
    53bd:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    53c0:	8b 45 08             	mov    0x8(%ebp),%eax
    53c3:	8b 50 10             	mov    0x10(%eax),%edx
    53c6:	8b 45 08             	mov    0x8(%ebp),%eax
    53c9:	8b 40 0c             	mov    0xc(%eax),%eax
    53cc:	83 e0 07             	and    $0x7,%eax
    53cf:	89 c1                	mov    %eax,%ecx
    53d1:	d3 ea                	shr    %cl,%edx
    53d3:	8b 45 08             	mov    0x8(%ebp),%eax
    53d6:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    53d9:	8b 45 08             	mov    0x8(%ebp),%eax
    53dc:	8b 50 0c             	mov    0xc(%eax),%edx
    53df:	8b 45 0c             	mov    0xc(%ebp),%eax
    53e2:	01 c2                	add    %eax,%edx
    53e4:	8b 45 08             	mov    0x8(%ebp),%eax
    53e7:	8b 40 08             	mov    0x8(%eax),%eax
    53ea:	39 c2                	cmp    %eax,%edx
    53ec:	0f 9e c0             	setle  %al
    53ef:	0f b6 c0             	movzbl %al,%eax
  }
}
    53f2:	c9                   	leave  
    53f3:	c3                   	ret    

000053f4 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    53f4:	55                   	push   %ebp
    53f5:	89 e5                	mov    %esp,%ebp
    53f7:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    53fa:	8b 45 08             	mov    0x8(%ebp),%eax
    53fd:	8b 40 0c             	mov    0xc(%eax),%eax
    5400:	c1 f8 03             	sar    $0x3,%eax
    5403:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    5406:	8b 45 08             	mov    0x8(%ebp),%eax
    5409:	8b 40 04             	mov    0x4(%eax),%eax
    540c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    540f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5412:	8d 50 03             	lea    0x3(%eax),%edx
    5415:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5418:	39 c2                	cmp    %eax,%edx
    541a:	0f 83 85 00 00 00    	jae    54a5 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    5420:	8b 45 08             	mov    0x8(%ebp),%eax
    5423:	8b 10                	mov    (%eax),%edx
    5425:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5428:	01 d0                	add    %edx,%eax
    542a:	0f b6 00             	movzbl (%eax),%eax
    542d:	0f b6 d0             	movzbl %al,%edx
    5430:	8b 45 08             	mov    0x8(%ebp),%eax
    5433:	8b 00                	mov    (%eax),%eax
    5435:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    5438:	83 c1 01             	add    $0x1,%ecx
    543b:	01 c8                	add    %ecx,%eax
    543d:	0f b6 00             	movzbl (%eax),%eax
    5440:	0f b6 c0             	movzbl %al,%eax
    5443:	c1 e0 08             	shl    $0x8,%eax
    5446:	89 d1                	mov    %edx,%ecx
    5448:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    544a:	8b 45 08             	mov    0x8(%ebp),%eax
    544d:	8b 00                	mov    (%eax),%eax
    544f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    5452:	83 c2 02             	add    $0x2,%edx
    5455:	01 d0                	add    %edx,%eax
    5457:	0f b6 00             	movzbl (%eax),%eax
    545a:	0f b6 c0             	movzbl %al,%eax
    545d:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    5460:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    5462:	8b 45 08             	mov    0x8(%ebp),%eax
    5465:	8b 00                	mov    (%eax),%eax
    5467:	8b 55 fc             	mov    -0x4(%ebp),%edx
    546a:	83 c2 03             	add    $0x3,%edx
    546d:	01 d0                	add    %edx,%eax
    546f:	0f b6 00             	movzbl (%eax),%eax
    5472:	0f b6 c0             	movzbl %al,%eax
    5475:	c1 e0 18             	shl    $0x18,%eax
    5478:	09 c1                	or     %eax,%ecx
    547a:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    547c:	8b 45 08             	mov    0x8(%ebp),%eax
    547f:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    5482:	8b 45 08             	mov    0x8(%ebp),%eax
    5485:	8b 50 10             	mov    0x10(%eax),%edx
    5488:	8b 45 08             	mov    0x8(%ebp),%eax
    548b:	8b 40 0c             	mov    0xc(%eax),%eax
    548e:	83 e0 07             	and    $0x7,%eax
    5491:	89 c1                	mov    %eax,%ecx
    5493:	d3 ea                	shr    %cl,%edx
    5495:	8b 45 08             	mov    0x8(%ebp),%eax
    5498:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    549b:	b8 01 00 00 00       	mov    $0x1,%eax
    54a0:	e9 c6 00 00 00       	jmp    556b <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    54a5:	8b 45 08             	mov    0x8(%ebp),%eax
    54a8:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    54af:	8b 55 fc             	mov    -0x4(%ebp),%edx
    54b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    54b5:	39 c2                	cmp    %eax,%edx
    54b7:	73 1e                	jae    54d7 <ensureBits25+0xe3>
    54b9:	8b 45 08             	mov    0x8(%ebp),%eax
    54bc:	8b 50 10             	mov    0x10(%eax),%edx
    54bf:	8b 45 08             	mov    0x8(%ebp),%eax
    54c2:	8b 08                	mov    (%eax),%ecx
    54c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    54c7:	01 c8                	add    %ecx,%eax
    54c9:	0f b6 00             	movzbl (%eax),%eax
    54cc:	0f b6 c0             	movzbl %al,%eax
    54cf:	09 c2                	or     %eax,%edx
    54d1:	8b 45 08             	mov    0x8(%ebp),%eax
    54d4:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    54d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    54da:	8d 50 01             	lea    0x1(%eax),%edx
    54dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    54e0:	39 c2                	cmp    %eax,%edx
    54e2:	73 24                	jae    5508 <ensureBits25+0x114>
    54e4:	8b 45 08             	mov    0x8(%ebp),%eax
    54e7:	8b 50 10             	mov    0x10(%eax),%edx
    54ea:	8b 45 08             	mov    0x8(%ebp),%eax
    54ed:	8b 00                	mov    (%eax),%eax
    54ef:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    54f2:	83 c1 01             	add    $0x1,%ecx
    54f5:	01 c8                	add    %ecx,%eax
    54f7:	0f b6 00             	movzbl (%eax),%eax
    54fa:	0f b6 c0             	movzbl %al,%eax
    54fd:	c1 e0 08             	shl    $0x8,%eax
    5500:	09 c2                	or     %eax,%edx
    5502:	8b 45 08             	mov    0x8(%ebp),%eax
    5505:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    5508:	8b 45 fc             	mov    -0x4(%ebp),%eax
    550b:	8d 50 02             	lea    0x2(%eax),%edx
    550e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5511:	39 c2                	cmp    %eax,%edx
    5513:	73 24                	jae    5539 <ensureBits25+0x145>
    5515:	8b 45 08             	mov    0x8(%ebp),%eax
    5518:	8b 50 10             	mov    0x10(%eax),%edx
    551b:	8b 45 08             	mov    0x8(%ebp),%eax
    551e:	8b 00                	mov    (%eax),%eax
    5520:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    5523:	83 c1 02             	add    $0x2,%ecx
    5526:	01 c8                	add    %ecx,%eax
    5528:	0f b6 00             	movzbl (%eax),%eax
    552b:	0f b6 c0             	movzbl %al,%eax
    552e:	c1 e0 10             	shl    $0x10,%eax
    5531:	09 c2                	or     %eax,%edx
    5533:	8b 45 08             	mov    0x8(%ebp),%eax
    5536:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    5539:	8b 45 08             	mov    0x8(%ebp),%eax
    553c:	8b 50 10             	mov    0x10(%eax),%edx
    553f:	8b 45 08             	mov    0x8(%ebp),%eax
    5542:	8b 40 0c             	mov    0xc(%eax),%eax
    5545:	83 e0 07             	and    $0x7,%eax
    5548:	89 c1                	mov    %eax,%ecx
    554a:	d3 ea                	shr    %cl,%edx
    554c:	8b 45 08             	mov    0x8(%ebp),%eax
    554f:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    5552:	8b 45 08             	mov    0x8(%ebp),%eax
    5555:	8b 50 0c             	mov    0xc(%eax),%edx
    5558:	8b 45 0c             	mov    0xc(%ebp),%eax
    555b:	01 c2                	add    %eax,%edx
    555d:	8b 45 08             	mov    0x8(%ebp),%eax
    5560:	8b 40 08             	mov    0x8(%eax),%eax
    5563:	39 c2                	cmp    %eax,%edx
    5565:	0f 9e c0             	setle  %al
    5568:	0f b6 c0             	movzbl %al,%eax
  }
}
    556b:	c9                   	leave  
    556c:	c3                   	ret    

0000556d <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    556d:	55                   	push   %ebp
    556e:	89 e5                	mov    %esp,%ebp
    5570:	53                   	push   %ebx
    5571:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    5574:	8b 45 08             	mov    0x8(%ebp),%eax
    5577:	8b 40 0c             	mov    0xc(%eax),%eax
    557a:	c1 f8 03             	sar    $0x3,%eax
    557d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    5580:	8b 45 08             	mov    0x8(%ebp),%eax
    5583:	8b 40 04             	mov    0x4(%eax),%eax
    5586:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    5589:	8b 45 f8             	mov    -0x8(%ebp),%eax
    558c:	8d 50 04             	lea    0x4(%eax),%edx
    558f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5592:	39 c2                	cmp    %eax,%edx
    5594:	0f 83 c3 00 00 00    	jae    565d <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    559a:	8b 45 08             	mov    0x8(%ebp),%eax
    559d:	8b 10                	mov    (%eax),%edx
    559f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    55a2:	01 d0                	add    %edx,%eax
    55a4:	0f b6 00             	movzbl (%eax),%eax
    55a7:	0f b6 d0             	movzbl %al,%edx
    55aa:	8b 45 08             	mov    0x8(%ebp),%eax
    55ad:	8b 00                	mov    (%eax),%eax
    55af:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    55b2:	83 c1 01             	add    $0x1,%ecx
    55b5:	01 c8                	add    %ecx,%eax
    55b7:	0f b6 00             	movzbl (%eax),%eax
    55ba:	0f b6 c0             	movzbl %al,%eax
    55bd:	c1 e0 08             	shl    $0x8,%eax
    55c0:	89 d1                	mov    %edx,%ecx
    55c2:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    55c4:	8b 45 08             	mov    0x8(%ebp),%eax
    55c7:	8b 00                	mov    (%eax),%eax
    55c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    55cc:	83 c2 02             	add    $0x2,%edx
    55cf:	01 d0                	add    %edx,%eax
    55d1:	0f b6 00             	movzbl (%eax),%eax
    55d4:	0f b6 c0             	movzbl %al,%eax
    55d7:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    55da:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    55dc:	8b 45 08             	mov    0x8(%ebp),%eax
    55df:	8b 00                	mov    (%eax),%eax
    55e1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    55e4:	83 c2 03             	add    $0x3,%edx
    55e7:	01 d0                	add    %edx,%eax
    55e9:	0f b6 00             	movzbl (%eax),%eax
    55ec:	0f b6 c0             	movzbl %al,%eax
    55ef:	c1 e0 18             	shl    $0x18,%eax
    55f2:	09 c1                	or     %eax,%ecx
    55f4:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    55f6:	8b 45 08             	mov    0x8(%ebp),%eax
    55f9:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    55fc:	8b 45 08             	mov    0x8(%ebp),%eax
    55ff:	8b 50 10             	mov    0x10(%eax),%edx
    5602:	8b 45 08             	mov    0x8(%ebp),%eax
    5605:	8b 40 0c             	mov    0xc(%eax),%eax
    5608:	83 e0 07             	and    $0x7,%eax
    560b:	89 c1                	mov    %eax,%ecx
    560d:	d3 ea                	shr    %cl,%edx
    560f:	8b 45 08             	mov    0x8(%ebp),%eax
    5612:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    5615:	8b 45 08             	mov    0x8(%ebp),%eax
    5618:	8b 50 10             	mov    0x10(%eax),%edx
    561b:	8b 45 08             	mov    0x8(%ebp),%eax
    561e:	8b 00                	mov    (%eax),%eax
    5620:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    5623:	83 c1 04             	add    $0x4,%ecx
    5626:	01 c8                	add    %ecx,%eax
    5628:	0f b6 00             	movzbl (%eax),%eax
    562b:	0f b6 c0             	movzbl %al,%eax
    562e:	c1 e0 18             	shl    $0x18,%eax
    5631:	89 c3                	mov    %eax,%ebx
    5633:	8b 45 08             	mov    0x8(%ebp),%eax
    5636:	8b 40 0c             	mov    0xc(%eax),%eax
    5639:	83 e0 07             	and    $0x7,%eax
    563c:	b9 08 00 00 00       	mov    $0x8,%ecx
    5641:	29 c1                	sub    %eax,%ecx
    5643:	89 c8                	mov    %ecx,%eax
    5645:	89 c1                	mov    %eax,%ecx
    5647:	d3 e3                	shl    %cl,%ebx
    5649:	89 d8                	mov    %ebx,%eax
    564b:	09 c2                	or     %eax,%edx
    564d:	8b 45 08             	mov    0x8(%ebp),%eax
    5650:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    5653:	b8 01 00 00 00       	mov    $0x1,%eax
    5658:	e9 f7 00 00 00       	jmp    5754 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    565d:	8b 45 08             	mov    0x8(%ebp),%eax
    5660:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    5667:	8b 55 f8             	mov    -0x8(%ebp),%edx
    566a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    566d:	39 c2                	cmp    %eax,%edx
    566f:	73 1e                	jae    568f <ensureBits32+0x122>
    5671:	8b 45 08             	mov    0x8(%ebp),%eax
    5674:	8b 50 10             	mov    0x10(%eax),%edx
    5677:	8b 45 08             	mov    0x8(%ebp),%eax
    567a:	8b 08                	mov    (%eax),%ecx
    567c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    567f:	01 c8                	add    %ecx,%eax
    5681:	0f b6 00             	movzbl (%eax),%eax
    5684:	0f b6 c0             	movzbl %al,%eax
    5687:	09 c2                	or     %eax,%edx
    5689:	8b 45 08             	mov    0x8(%ebp),%eax
    568c:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    568f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5692:	8d 50 01             	lea    0x1(%eax),%edx
    5695:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5698:	39 c2                	cmp    %eax,%edx
    569a:	73 24                	jae    56c0 <ensureBits32+0x153>
    569c:	8b 45 08             	mov    0x8(%ebp),%eax
    569f:	8b 50 10             	mov    0x10(%eax),%edx
    56a2:	8b 45 08             	mov    0x8(%ebp),%eax
    56a5:	8b 00                	mov    (%eax),%eax
    56a7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    56aa:	83 c1 01             	add    $0x1,%ecx
    56ad:	01 c8                	add    %ecx,%eax
    56af:	0f b6 00             	movzbl (%eax),%eax
    56b2:	0f b6 c0             	movzbl %al,%eax
    56b5:	c1 e0 08             	shl    $0x8,%eax
    56b8:	09 c2                	or     %eax,%edx
    56ba:	8b 45 08             	mov    0x8(%ebp),%eax
    56bd:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    56c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    56c3:	8d 50 02             	lea    0x2(%eax),%edx
    56c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    56c9:	39 c2                	cmp    %eax,%edx
    56cb:	73 24                	jae    56f1 <ensureBits32+0x184>
    56cd:	8b 45 08             	mov    0x8(%ebp),%eax
    56d0:	8b 50 10             	mov    0x10(%eax),%edx
    56d3:	8b 45 08             	mov    0x8(%ebp),%eax
    56d6:	8b 00                	mov    (%eax),%eax
    56d8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    56db:	83 c1 02             	add    $0x2,%ecx
    56de:	01 c8                	add    %ecx,%eax
    56e0:	0f b6 00             	movzbl (%eax),%eax
    56e3:	0f b6 c0             	movzbl %al,%eax
    56e6:	c1 e0 10             	shl    $0x10,%eax
    56e9:	09 c2                	or     %eax,%edx
    56eb:	8b 45 08             	mov    0x8(%ebp),%eax
    56ee:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    56f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    56f4:	8d 50 03             	lea    0x3(%eax),%edx
    56f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    56fa:	39 c2                	cmp    %eax,%edx
    56fc:	73 24                	jae    5722 <ensureBits32+0x1b5>
    56fe:	8b 45 08             	mov    0x8(%ebp),%eax
    5701:	8b 50 10             	mov    0x10(%eax),%edx
    5704:	8b 45 08             	mov    0x8(%ebp),%eax
    5707:	8b 00                	mov    (%eax),%eax
    5709:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    570c:	83 c1 03             	add    $0x3,%ecx
    570f:	01 c8                	add    %ecx,%eax
    5711:	0f b6 00             	movzbl (%eax),%eax
    5714:	0f b6 c0             	movzbl %al,%eax
    5717:	c1 e0 18             	shl    $0x18,%eax
    571a:	09 c2                	or     %eax,%edx
    571c:	8b 45 08             	mov    0x8(%ebp),%eax
    571f:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    5722:	8b 45 08             	mov    0x8(%ebp),%eax
    5725:	8b 50 10             	mov    0x10(%eax),%edx
    5728:	8b 45 08             	mov    0x8(%ebp),%eax
    572b:	8b 40 0c             	mov    0xc(%eax),%eax
    572e:	83 e0 07             	and    $0x7,%eax
    5731:	89 c1                	mov    %eax,%ecx
    5733:	d3 ea                	shr    %cl,%edx
    5735:	8b 45 08             	mov    0x8(%ebp),%eax
    5738:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    573b:	8b 45 08             	mov    0x8(%ebp),%eax
    573e:	8b 50 0c             	mov    0xc(%eax),%edx
    5741:	8b 45 0c             	mov    0xc(%ebp),%eax
    5744:	01 c2                	add    %eax,%edx
    5746:	8b 45 08             	mov    0x8(%ebp),%eax
    5749:	8b 40 08             	mov    0x8(%eax),%eax
    574c:	39 c2                	cmp    %eax,%edx
    574e:	0f 9e c0             	setle  %al
    5751:	0f b6 c0             	movzbl %al,%eax
  }
}
    5754:	83 c4 10             	add    $0x10,%esp
    5757:	5b                   	pop    %ebx
    5758:	5d                   	pop    %ebp
    5759:	c3                   	ret    

0000575a <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    575a:	55                   	push   %ebp
    575b:	89 e5                	mov    %esp,%ebp
    575d:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    575e:	8b 45 08             	mov    0x8(%ebp),%eax
    5761:	8b 50 10             	mov    0x10(%eax),%edx
    5764:	8b 45 0c             	mov    0xc(%ebp),%eax
    5767:	bb 01 00 00 00       	mov    $0x1,%ebx
    576c:	89 c1                	mov    %eax,%ecx
    576e:	d3 e3                	shl    %cl,%ebx
    5770:	89 d8                	mov    %ebx,%eax
    5772:	83 e8 01             	sub    $0x1,%eax
    5775:	21 d0                	and    %edx,%eax
}
    5777:	5b                   	pop    %ebx
    5778:	5d                   	pop    %ebp
    5779:	c3                   	ret    

0000577a <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    577a:	55                   	push   %ebp
    577b:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    577d:	8b 45 08             	mov    0x8(%ebp),%eax
    5780:	8b 50 10             	mov    0x10(%eax),%edx
    5783:	8b 45 0c             	mov    0xc(%ebp),%eax
    5786:	89 c1                	mov    %eax,%ecx
    5788:	d3 ea                	shr    %cl,%edx
    578a:	8b 45 08             	mov    0x8(%ebp),%eax
    578d:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    5790:	8b 45 08             	mov    0x8(%ebp),%eax
    5793:	8b 50 0c             	mov    0xc(%eax),%edx
    5796:	8b 45 0c             	mov    0xc(%ebp),%eax
    5799:	01 c2                	add    %eax,%edx
    579b:	8b 45 08             	mov    0x8(%ebp),%eax
    579e:	89 50 0c             	mov    %edx,0xc(%eax)
}
    57a1:	90                   	nop
    57a2:	5d                   	pop    %ebp
    57a3:	c3                   	ret    

000057a4 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    57a4:	55                   	push   %ebp
    57a5:	89 e5                	mov    %esp,%ebp
    57a7:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    57aa:	ff 75 0c             	pushl  0xc(%ebp)
    57ad:	ff 75 08             	pushl  0x8(%ebp)
    57b0:	e8 a5 ff ff ff       	call   575a <peekBits>
    57b5:	83 c4 08             	add    $0x8,%esp
    57b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    57bb:	ff 75 0c             	pushl  0xc(%ebp)
    57be:	ff 75 08             	pushl  0x8(%ebp)
    57c1:	e8 b4 ff ff ff       	call   577a <advanceBits>
    57c6:	83 c4 08             	add    $0x8,%esp
  return result;
    57c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    57cc:	c9                   	leave  
    57cd:	c3                   	ret    

000057ce <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    57ce:	55                   	push   %ebp
    57cf:	89 e5                	mov    %esp,%ebp
    57d1:	53                   	push   %ebx
    57d2:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    57d5:	ff 75 0c             	pushl  0xc(%ebp)
    57d8:	ff 75 08             	pushl  0x8(%ebp)
    57db:	8d 45 d8             	lea    -0x28(%ebp),%eax
    57de:	50                   	push   %eax
    57df:	e8 97 f9 ff ff       	call   517b <LodePNGBitReader_init>
    57e4:	83 c4 0c             	add    $0xc,%esp
    57e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    57ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    57ee:	74 0a                	je     57fa <lode_png_test_bitreader+0x2c>
    57f0:	b8 00 00 00 00       	mov    $0x0,%eax
    57f5:	e9 c3 00 00 00       	jmp    58bd <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    57fa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5801:	e9 a6 00 00 00       	jmp    58ac <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    5806:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5809:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5810:	8b 45 14             	mov    0x14(%ebp),%eax
    5813:	01 d0                	add    %edx,%eax
    5815:	8b 00                	mov    (%eax),%eax
    5817:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    581a:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    581e:	7e 14                	jle    5834 <lode_png_test_bitreader+0x66>
    5820:	ff 75 ec             	pushl  -0x14(%ebp)
    5823:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5826:	50                   	push   %eax
    5827:	e8 41 fd ff ff       	call   556d <ensureBits32>
    582c:	83 c4 08             	add    $0x8,%esp
    582f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5832:	eb 46                	jmp    587a <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    5834:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    5838:	7e 14                	jle    584e <lode_png_test_bitreader+0x80>
    583a:	ff 75 ec             	pushl  -0x14(%ebp)
    583d:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5840:	50                   	push   %eax
    5841:	e8 ae fb ff ff       	call   53f4 <ensureBits25>
    5846:	83 c4 08             	add    $0x8,%esp
    5849:	89 45 f4             	mov    %eax,-0xc(%ebp)
    584c:	eb 2c                	jmp    587a <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    584e:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    5852:	7e 14                	jle    5868 <lode_png_test_bitreader+0x9a>
    5854:	ff 75 ec             	pushl  -0x14(%ebp)
    5857:	8d 45 d8             	lea    -0x28(%ebp),%eax
    585a:	50                   	push   %eax
    585b:	e8 68 fa ff ff       	call   52c8 <ensureBits17>
    5860:	83 c4 08             	add    $0x8,%esp
    5863:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5866:	eb 12                	jmp    587a <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    5868:	ff 75 ec             	pushl  -0x14(%ebp)
    586b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    586e:	50                   	push   %eax
    586f:	e8 78 f9 ff ff       	call   51ec <ensureBits9>
    5874:	83 c4 08             	add    $0x8,%esp
    5877:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    587a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    587e:	75 07                	jne    5887 <lode_png_test_bitreader+0xb9>
    5880:	b8 00 00 00 00       	mov    $0x0,%eax
    5885:	eb 36                	jmp    58bd <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    5887:	8b 45 f8             	mov    -0x8(%ebp),%eax
    588a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5891:	8b 45 18             	mov    0x18(%ebp),%eax
    5894:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5897:	ff 75 ec             	pushl  -0x14(%ebp)
    589a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    589d:	50                   	push   %eax
    589e:	e8 01 ff ff ff       	call   57a4 <readBits>
    58a3:	83 c4 08             	add    $0x8,%esp
    58a6:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    58a8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    58ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    58af:	3b 45 10             	cmp    0x10(%ebp),%eax
    58b2:	0f 8c 4e ff ff ff    	jl     5806 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    58b8:	b8 01 00 00 00       	mov    $0x1,%eax
}
    58bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    58c0:	c9                   	leave  
    58c1:	c3                   	ret    

000058c2 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    58c2:	55                   	push   %ebp
    58c3:	89 e5                	mov    %esp,%ebp
    58c5:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    58c8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    58cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    58d6:	eb 27                	jmp    58ff <reverseBits+0x3d>
    58d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    58db:	2b 45 fc             	sub    -0x4(%ebp),%eax
    58de:	83 e8 01             	sub    $0x1,%eax
    58e1:	8b 55 08             	mov    0x8(%ebp),%edx
    58e4:	89 c1                	mov    %eax,%ecx
    58e6:	d3 ea                	shr    %cl,%edx
    58e8:	89 d0                	mov    %edx,%eax
    58ea:	83 e0 01             	and    $0x1,%eax
    58ed:	89 c2                	mov    %eax,%edx
    58ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
    58f2:	89 c1                	mov    %eax,%ecx
    58f4:	d3 e2                	shl    %cl,%edx
    58f6:	89 d0                	mov    %edx,%eax
    58f8:	09 45 f8             	or     %eax,-0x8(%ebp)
    58fb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    58ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5902:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5905:	72 d1                	jb     58d8 <reverseBits+0x16>
  return result;
    5907:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    590a:	c9                   	leave  
    590b:	c3                   	ret    

0000590c <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    590c:	55                   	push   %ebp
    590d:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    590f:	8b 45 08             	mov    0x8(%ebp),%eax
    5912:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    5918:	8b 45 08             	mov    0x8(%ebp),%eax
    591b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    5922:	8b 45 08             	mov    0x8(%ebp),%eax
    5925:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    592c:	8b 45 08             	mov    0x8(%ebp),%eax
    592f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    5936:	90                   	nop
    5937:	5d                   	pop    %ebp
    5938:	c3                   	ret    

00005939 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    5939:	55                   	push   %ebp
    593a:	89 e5                	mov    %esp,%ebp
    593c:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    593f:	8b 45 08             	mov    0x8(%ebp),%eax
    5942:	8b 00                	mov    (%eax),%eax
    5944:	83 ec 0c             	sub    $0xc,%esp
    5947:	50                   	push   %eax
    5948:	e8 ec f0 ff ff       	call   4a39 <lodepng_free>
    594d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    5950:	8b 45 08             	mov    0x8(%ebp),%eax
    5953:	8b 40 04             	mov    0x4(%eax),%eax
    5956:	83 ec 0c             	sub    $0xc,%esp
    5959:	50                   	push   %eax
    595a:	e8 da f0 ff ff       	call   4a39 <lodepng_free>
    595f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    5962:	8b 45 08             	mov    0x8(%ebp),%eax
    5965:	8b 40 10             	mov    0x10(%eax),%eax
    5968:	83 ec 0c             	sub    $0xc,%esp
    596b:	50                   	push   %eax
    596c:	e8 c8 f0 ff ff       	call   4a39 <lodepng_free>
    5971:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    5974:	8b 45 08             	mov    0x8(%ebp),%eax
    5977:	8b 40 14             	mov    0x14(%eax),%eax
    597a:	83 ec 0c             	sub    $0xc,%esp
    597d:	50                   	push   %eax
    597e:	e8 b6 f0 ff ff       	call   4a39 <lodepng_free>
    5983:	83 c4 10             	add    $0x10,%esp
}
    5986:	90                   	nop
    5987:	c9                   	leave  
    5988:	c3                   	ret    

00005989 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    5989:	55                   	push   %ebp
    598a:	89 e5                	mov    %esp,%ebp
    598c:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    598f:	a1 a8 cc 01 00       	mov    0x1cca8,%eax
    5994:	c1 e0 02             	shl    $0x2,%eax
    5997:	83 ec 0c             	sub    $0xc,%esp
    599a:	50                   	push   %eax
    599b:	e8 78 f0 ff ff       	call   4a18 <lodepng_malloc>
    59a0:	83 c4 10             	add    $0x10,%esp
    59a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    59a6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    59aa:	75 0a                	jne    59b6 <HuffmanTree_makeTable+0x2d>
    59ac:	b8 53 00 00 00       	mov    $0x53,%eax
    59b1:	e9 61 04 00 00       	jmp    5e17 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    59b6:	a1 a8 cc 01 00       	mov    0x1cca8,%eax
    59bb:	c1 e0 02             	shl    $0x2,%eax
    59be:	83 ec 04             	sub    $0x4,%esp
    59c1:	50                   	push   %eax
    59c2:	6a 00                	push   $0x0
    59c4:	ff 75 dc             	pushl  -0x24(%ebp)
    59c7:	e8 bd f0 ff ff       	call   4a89 <lodepng_memset>
    59cc:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    59cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    59d6:	eb 7d                	jmp    5a55 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    59d8:	8b 45 08             	mov    0x8(%ebp),%eax
    59db:	8b 00                	mov    (%eax),%eax
    59dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    59e0:	c1 e2 02             	shl    $0x2,%edx
    59e3:	01 d0                	add    %edx,%eax
    59e5:	8b 00                	mov    (%eax),%eax
    59e7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    59ea:	8b 45 08             	mov    0x8(%ebp),%eax
    59ed:	8b 40 04             	mov    0x4(%eax),%eax
    59f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    59f3:	c1 e2 02             	shl    $0x2,%edx
    59f6:	01 d0                	add    %edx,%eax
    59f8:	8b 00                	mov    (%eax),%eax
    59fa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    59fd:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    5a01:	76 4d                	jbe    5a50 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    5a03:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a06:	83 e8 09             	sub    $0x9,%eax
    5a09:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a0c:	89 c1                	mov    %eax,%ecx
    5a0e:	d3 ea                	shr    %cl,%edx
    5a10:	89 d0                	mov    %edx,%eax
    5a12:	83 ec 08             	sub    $0x8,%esp
    5a15:	6a 09                	push   $0x9
    5a17:	50                   	push   %eax
    5a18:	e8 a5 fe ff ff       	call   58c2 <reverseBits>
    5a1d:	83 c4 10             	add    $0x10,%esp
    5a20:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    5a23:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5a26:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5a30:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    5a33:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5a36:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5a40:	01 d0                	add    %edx,%eax
    5a42:	8b 10                	mov    (%eax),%edx
    5a44:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a47:	39 c2                	cmp    %eax,%edx
    5a49:	0f 43 c2             	cmovae %edx,%eax
    5a4c:	89 01                	mov    %eax,(%ecx)
    5a4e:	eb 01                	jmp    5a51 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    5a50:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    5a51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5a55:	8b 45 08             	mov    0x8(%ebp),%eax
    5a58:	8b 50 0c             	mov    0xc(%eax),%edx
    5a5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5a5e:	39 c2                	cmp    %eax,%edx
    5a60:	0f 87 72 ff ff ff    	ja     59d8 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    5a66:	a1 a8 cc 01 00       	mov    0x1cca8,%eax
    5a6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    5a6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5a75:	eb 35                	jmp    5aac <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    5a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5a7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a81:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5a84:	01 d0                	add    %edx,%eax
    5a86:	8b 00                	mov    (%eax),%eax
    5a88:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    5a8b:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    5a8f:	76 17                	jbe    5aa8 <HuffmanTree_makeTable+0x11f>
    5a91:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5a94:	83 e8 09             	sub    $0x9,%eax
    5a97:	ba 01 00 00 00       	mov    $0x1,%edx
    5a9c:	89 c1                	mov    %eax,%ecx
    5a9e:	d3 e2                	shl    %cl,%edx
    5aa0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5aa3:	01 d0                	add    %edx,%eax
    5aa5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    5aa8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5aac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5aaf:	a1 a8 cc 01 00       	mov    0x1cca8,%eax
    5ab4:	39 c2                	cmp    %eax,%edx
    5ab6:	72 bf                	jb     5a77 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    5ab8:	83 ec 0c             	sub    $0xc,%esp
    5abb:	ff 75 e8             	pushl  -0x18(%ebp)
    5abe:	e8 55 ef ff ff       	call   4a18 <lodepng_malloc>
    5ac3:	83 c4 10             	add    $0x10,%esp
    5ac6:	89 c2                	mov    %eax,%edx
    5ac8:	8b 45 08             	mov    0x8(%ebp),%eax
    5acb:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    5ace:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ad1:	01 c0                	add    %eax,%eax
    5ad3:	83 ec 0c             	sub    $0xc,%esp
    5ad6:	50                   	push   %eax
    5ad7:	e8 3c ef ff ff       	call   4a18 <lodepng_malloc>
    5adc:	83 c4 10             	add    $0x10,%esp
    5adf:	89 c2                	mov    %eax,%edx
    5ae1:	8b 45 08             	mov    0x8(%ebp),%eax
    5ae4:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    5ae7:	8b 45 08             	mov    0x8(%ebp),%eax
    5aea:	8b 40 10             	mov    0x10(%eax),%eax
    5aed:	85 c0                	test   %eax,%eax
    5aef:	74 0a                	je     5afb <HuffmanTree_makeTable+0x172>
    5af1:	8b 45 08             	mov    0x8(%ebp),%eax
    5af4:	8b 40 14             	mov    0x14(%eax),%eax
    5af7:	85 c0                	test   %eax,%eax
    5af9:	75 18                	jne    5b13 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    5afb:	83 ec 0c             	sub    $0xc,%esp
    5afe:	ff 75 dc             	pushl  -0x24(%ebp)
    5b01:	e8 33 ef ff ff       	call   4a39 <lodepng_free>
    5b06:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    5b09:	b8 53 00 00 00       	mov    $0x53,%eax
    5b0e:	e9 04 03 00 00       	jmp    5e17 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    5b13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5b1a:	eb 12                	jmp    5b2e <HuffmanTree_makeTable+0x1a5>
    5b1c:	8b 45 08             	mov    0x8(%ebp),%eax
    5b1f:	8b 50 10             	mov    0x10(%eax),%edx
    5b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b25:	01 d0                	add    %edx,%eax
    5b27:	c6 00 10             	movb   $0x10,(%eax)
    5b2a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b31:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    5b34:	7c e6                	jl     5b1c <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    5b36:	a1 a8 cc 01 00       	mov    0x1cca8,%eax
    5b3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    5b3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5b45:	eb 5b                	jmp    5ba2 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    5b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b4a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b51:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5b54:	01 d0                	add    %edx,%eax
    5b56:	8b 00                	mov    (%eax),%eax
    5b58:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    5b5b:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    5b5f:	76 3c                	jbe    5b9d <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    5b61:	8b 45 08             	mov    0x8(%ebp),%eax
    5b64:	8b 50 10             	mov    0x10(%eax),%edx
    5b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b6a:	01 d0                	add    %edx,%eax
    5b6c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5b6f:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    5b71:	8b 45 08             	mov    0x8(%ebp),%eax
    5b74:	8b 40 14             	mov    0x14(%eax),%eax
    5b77:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5b7a:	01 d2                	add    %edx,%edx
    5b7c:	01 d0                	add    %edx,%eax
    5b7e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5b81:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    5b84:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5b87:	83 e8 09             	sub    $0x9,%eax
    5b8a:	ba 01 00 00 00       	mov    $0x1,%edx
    5b8f:	89 c1                	mov    %eax,%ecx
    5b91:	d3 e2                	shl    %cl,%edx
    5b93:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b96:	01 d0                	add    %edx,%eax
    5b98:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5b9b:	eb 01                	jmp    5b9e <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    5b9d:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    5b9e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5ba2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5ba5:	a1 a8 cc 01 00       	mov    0x1cca8,%eax
    5baa:	39 c2                	cmp    %eax,%edx
    5bac:	72 99                	jb     5b47 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    5bae:	83 ec 0c             	sub    $0xc,%esp
    5bb1:	ff 75 dc             	pushl  -0x24(%ebp)
    5bb4:	e8 80 ee ff ff       	call   4a39 <lodepng_free>
    5bb9:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    5bbc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    5bc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5bca:	e9 9d 01 00 00       	jmp    5d6c <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    5bcf:	8b 45 08             	mov    0x8(%ebp),%eax
    5bd2:	8b 40 04             	mov    0x4(%eax),%eax
    5bd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5bd8:	c1 e2 02             	shl    $0x2,%edx
    5bdb:	01 d0                	add    %edx,%eax
    5bdd:	8b 00                	mov    (%eax),%eax
    5bdf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    5be2:	8b 45 08             	mov    0x8(%ebp),%eax
    5be5:	8b 00                	mov    (%eax),%eax
    5be7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5bea:	c1 e2 02             	shl    $0x2,%edx
    5bed:	01 d0                	add    %edx,%eax
    5bef:	8b 00                	mov    (%eax),%eax
    5bf1:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    5bf4:	83 ec 08             	sub    $0x8,%esp
    5bf7:	ff 75 c4             	pushl  -0x3c(%ebp)
    5bfa:	ff 75 c0             	pushl  -0x40(%ebp)
    5bfd:	e8 c0 fc ff ff       	call   58c2 <reverseBits>
    5c02:	83 c4 10             	add    $0x10,%esp
    5c05:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    5c08:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    5c0c:	0f 84 55 01 00 00    	je     5d67 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    5c12:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    5c16:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    5c1a:	0f 87 81 00 00 00    	ja     5ca1 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    5c20:	b8 09 00 00 00       	mov    $0x9,%eax
    5c25:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    5c28:	ba 01 00 00 00       	mov    $0x1,%edx
    5c2d:	89 c1                	mov    %eax,%ecx
    5c2f:	d3 e2                	shl    %cl,%edx
    5c31:	89 d0                	mov    %edx,%eax
    5c33:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    5c36:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    5c3d:	eb 55                	jmp    5c94 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    5c3f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5c42:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5c45:	89 c1                	mov    %eax,%ecx
    5c47:	d3 e2                	shl    %cl,%edx
    5c49:	89 d0                	mov    %edx,%eax
    5c4b:	0b 45 bc             	or     -0x44(%ebp),%eax
    5c4e:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    5c51:	8b 45 08             	mov    0x8(%ebp),%eax
    5c54:	8b 50 10             	mov    0x10(%eax),%edx
    5c57:	8b 45 98             	mov    -0x68(%ebp),%eax
    5c5a:	01 d0                	add    %edx,%eax
    5c5c:	0f b6 00             	movzbl (%eax),%eax
    5c5f:	3c 10                	cmp    $0x10,%al
    5c61:	74 0a                	je     5c6d <HuffmanTree_makeTable+0x2e4>
    5c63:	b8 37 00 00 00       	mov    $0x37,%eax
    5c68:	e9 aa 01 00 00       	jmp    5e17 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    5c6d:	8b 45 08             	mov    0x8(%ebp),%eax
    5c70:	8b 50 10             	mov    0x10(%eax),%edx
    5c73:	8b 45 98             	mov    -0x68(%ebp),%eax
    5c76:	01 d0                	add    %edx,%eax
    5c78:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    5c7b:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    5c7d:	8b 45 08             	mov    0x8(%ebp),%eax
    5c80:	8b 40 14             	mov    0x14(%eax),%eax
    5c83:	8b 55 98             	mov    -0x68(%ebp),%edx
    5c86:	01 d2                	add    %edx,%edx
    5c88:	01 d0                	add    %edx,%eax
    5c8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5c8d:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    5c90:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    5c94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c97:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    5c9a:	72 a3                	jb     5c3f <HuffmanTree_makeTable+0x2b6>
    5c9c:	e9 c7 00 00 00       	jmp    5d68 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    5ca1:	a1 ac cc 01 00       	mov    0x1ccac,%eax
    5ca6:	23 45 bc             	and    -0x44(%ebp),%eax
    5ca9:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    5cac:	8b 45 08             	mov    0x8(%ebp),%eax
    5caf:	8b 50 10             	mov    0x10(%eax),%edx
    5cb2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    5cb5:	01 d0                	add    %edx,%eax
    5cb7:	0f b6 00             	movzbl (%eax),%eax
    5cba:	0f b6 c0             	movzbl %al,%eax
    5cbd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    5cc0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    5cc3:	83 e8 09             	sub    $0x9,%eax
    5cc6:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    5cc9:	8b 45 08             	mov    0x8(%ebp),%eax
    5ccc:	8b 40 14             	mov    0x14(%eax),%eax
    5ccf:	8b 55 b8             	mov    -0x48(%ebp),%edx
    5cd2:	01 d2                	add    %edx,%edx
    5cd4:	01 d0                	add    %edx,%eax
    5cd6:	0f b7 00             	movzwl (%eax),%eax
    5cd9:	0f b7 c0             	movzwl %ax,%eax
    5cdc:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    5cdf:	8b 45 b0             	mov    -0x50(%ebp),%eax
    5ce2:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    5ce5:	83 c0 09             	add    $0x9,%eax
    5ce8:	ba 01 00 00 00       	mov    $0x1,%edx
    5ced:	89 c1                	mov    %eax,%ecx
    5cef:	d3 e2                	shl    %cl,%edx
    5cf1:	89 d0                	mov    %edx,%eax
    5cf3:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    5cf6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    5cf9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5cfc:	73 0a                	jae    5d08 <HuffmanTree_makeTable+0x37f>
    5cfe:	b8 37 00 00 00       	mov    $0x37,%eax
    5d03:	e9 0f 01 00 00       	jmp    5e17 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    5d08:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    5d0f:	eb 4c                	jmp    5d5d <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    5d11:	8b 45 bc             	mov    -0x44(%ebp),%eax
    5d14:	c1 e8 09             	shr    $0x9,%eax
    5d17:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    5d1a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5d1d:	83 e8 09             	sub    $0x9,%eax
    5d20:	8b 55 e0             	mov    -0x20(%ebp),%edx
    5d23:	89 c1                	mov    %eax,%ecx
    5d25:	d3 e2                	shl    %cl,%edx
    5d27:	89 d0                	mov    %edx,%eax
    5d29:	0b 45 a4             	or     -0x5c(%ebp),%eax
    5d2c:	89 c2                	mov    %eax,%edx
    5d2e:	8b 45 ac             	mov    -0x54(%ebp),%eax
    5d31:	01 d0                	add    %edx,%eax
    5d33:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    5d36:	8b 45 08             	mov    0x8(%ebp),%eax
    5d39:	8b 50 10             	mov    0x10(%eax),%edx
    5d3c:	8b 45 a0             	mov    -0x60(%ebp),%eax
    5d3f:	01 d0                	add    %edx,%eax
    5d41:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    5d44:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    5d46:	8b 45 08             	mov    0x8(%ebp),%eax
    5d49:	8b 40 14             	mov    0x14(%eax),%eax
    5d4c:	8b 55 a0             	mov    -0x60(%ebp),%edx
    5d4f:	01 d2                	add    %edx,%edx
    5d51:	01 d0                	add    %edx,%eax
    5d53:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5d56:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    5d59:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5d5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d60:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    5d63:	72 ac                	jb     5d11 <HuffmanTree_makeTable+0x388>
    5d65:	eb 01                	jmp    5d68 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    5d67:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    5d68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5d6c:	8b 45 08             	mov    0x8(%ebp),%eax
    5d6f:	8b 50 0c             	mov    0xc(%eax),%edx
    5d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5d75:	39 c2                	cmp    %eax,%edx
    5d77:	0f 87 52 fe ff ff    	ja     5bcf <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    5d7d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    5d81:	7f 61                	jg     5de4 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    5d83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5d8a:	eb 4e                	jmp    5dda <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    5d8c:	8b 45 08             	mov    0x8(%ebp),%eax
    5d8f:	8b 50 10             	mov    0x10(%eax),%edx
    5d92:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5d95:	01 d0                	add    %edx,%eax
    5d97:	0f b6 00             	movzbl (%eax),%eax
    5d9a:	3c 10                	cmp    $0x10,%al
    5d9c:	75 38                	jne    5dd6 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    5d9e:	8b 45 08             	mov    0x8(%ebp),%eax
    5da1:	8b 50 10             	mov    0x10(%eax),%edx
    5da4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5da7:	01 d0                	add    %edx,%eax
    5da9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    5dac:	8b 15 a8 cc 01 00    	mov    0x1cca8,%edx
    5db2:	39 d1                	cmp    %edx,%ecx
    5db4:	73 07                	jae    5dbd <HuffmanTree_makeTable+0x434>
    5db6:	ba 01 00 00 00       	mov    $0x1,%edx
    5dbb:	eb 05                	jmp    5dc2 <HuffmanTree_makeTable+0x439>
    5dbd:	ba 0a 00 00 00       	mov    $0xa,%edx
    5dc2:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    5dc4:	8b 45 08             	mov    0x8(%ebp),%eax
    5dc7:	8b 40 14             	mov    0x14(%eax),%eax
    5dca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5dcd:	01 d2                	add    %edx,%edx
    5dcf:	01 d0                	add    %edx,%eax
    5dd1:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    5dd6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5ddd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    5de0:	7c aa                	jl     5d8c <HuffmanTree_makeTable+0x403>
    5de2:	eb 2e                	jmp    5e12 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    5de4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5deb:	eb 1d                	jmp    5e0a <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    5ded:	8b 45 08             	mov    0x8(%ebp),%eax
    5df0:	8b 50 10             	mov    0x10(%eax),%edx
    5df3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5df6:	01 d0                	add    %edx,%eax
    5df8:	0f b6 00             	movzbl (%eax),%eax
    5dfb:	3c 10                	cmp    $0x10,%al
    5dfd:	75 07                	jne    5e06 <HuffmanTree_makeTable+0x47d>
    5dff:	b8 37 00 00 00       	mov    $0x37,%eax
    5e04:	eb 11                	jmp    5e17 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    5e06:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5e0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5e0d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    5e10:	7c db                	jl     5ded <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    5e12:	b8 00 00 00 00       	mov    $0x0,%eax
}
    5e17:	c9                   	leave  
    5e18:	c3                   	ret    

00005e19 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    5e19:	55                   	push   %ebp
    5e1a:	89 e5                	mov    %esp,%ebp
    5e1c:	56                   	push   %esi
    5e1d:	53                   	push   %ebx
    5e1e:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    5e21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    5e28:	8b 45 08             	mov    0x8(%ebp),%eax
    5e2b:	8b 40 0c             	mov    0xc(%eax),%eax
    5e2e:	c1 e0 02             	shl    $0x2,%eax
    5e31:	83 ec 0c             	sub    $0xc,%esp
    5e34:	50                   	push   %eax
    5e35:	e8 de eb ff ff       	call   4a18 <lodepng_malloc>
    5e3a:	83 c4 10             	add    $0x10,%esp
    5e3d:	89 c2                	mov    %eax,%edx
    5e3f:	8b 45 08             	mov    0x8(%ebp),%eax
    5e42:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    5e44:	8b 45 08             	mov    0x8(%ebp),%eax
    5e47:	8b 40 08             	mov    0x8(%eax),%eax
    5e4a:	83 c0 01             	add    $0x1,%eax
    5e4d:	c1 e0 02             	shl    $0x2,%eax
    5e50:	83 ec 0c             	sub    $0xc,%esp
    5e53:	50                   	push   %eax
    5e54:	e8 bf eb ff ff       	call   4a18 <lodepng_malloc>
    5e59:	83 c4 10             	add    $0x10,%esp
    5e5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    5e5f:	8b 45 08             	mov    0x8(%ebp),%eax
    5e62:	8b 40 08             	mov    0x8(%eax),%eax
    5e65:	83 c0 01             	add    $0x1,%eax
    5e68:	c1 e0 02             	shl    $0x2,%eax
    5e6b:	83 ec 0c             	sub    $0xc,%esp
    5e6e:	50                   	push   %eax
    5e6f:	e8 a4 eb ff ff       	call   4a18 <lodepng_malloc>
    5e74:	83 c4 10             	add    $0x10,%esp
    5e77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    5e7a:	8b 45 08             	mov    0x8(%ebp),%eax
    5e7d:	8b 00                	mov    (%eax),%eax
    5e7f:	85 c0                	test   %eax,%eax
    5e81:	74 0c                	je     5e8f <HuffmanTree_makeFromLengths2+0x76>
    5e83:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5e87:	74 06                	je     5e8f <HuffmanTree_makeFromLengths2+0x76>
    5e89:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5e8d:	75 07                	jne    5e96 <HuffmanTree_makeFromLengths2+0x7d>
    5e8f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    5e96:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5e9a:	0f 85 7d 01 00 00    	jne    601d <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    5ea0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5ea7:	eb 2c                	jmp    5ed5 <HuffmanTree_makeFromLengths2+0xbc>
    5ea9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5eac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5eb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5eb6:	01 c2                	add    %eax,%edx
    5eb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ebb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5ec2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5ec5:	01 c8                	add    %ecx,%eax
    5ec7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5ecd:	8b 00                	mov    (%eax),%eax
    5ecf:	89 02                	mov    %eax,(%edx)
    5ed1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5ed5:	8b 45 08             	mov    0x8(%ebp),%eax
    5ed8:	8b 40 08             	mov    0x8(%eax),%eax
    5edb:	83 c0 01             	add    $0x1,%eax
    5ede:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5ee1:	75 c6                	jne    5ea9 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    5ee3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5eea:	eb 27                	jmp    5f13 <HuffmanTree_makeFromLengths2+0xfa>
    5eec:	8b 45 08             	mov    0x8(%ebp),%eax
    5eef:	8b 40 04             	mov    0x4(%eax),%eax
    5ef2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ef5:	c1 e2 02             	shl    $0x2,%edx
    5ef8:	01 d0                	add    %edx,%eax
    5efa:	8b 00                	mov    (%eax),%eax
    5efc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f03:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5f06:	01 d0                	add    %edx,%eax
    5f08:	8b 10                	mov    (%eax),%edx
    5f0a:	83 c2 01             	add    $0x1,%edx
    5f0d:	89 10                	mov    %edx,(%eax)
    5f0f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5f13:	8b 45 08             	mov    0x8(%ebp),%eax
    5f16:	8b 40 0c             	mov    0xc(%eax),%eax
    5f19:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5f1c:	75 ce                	jne    5eec <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    5f1e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    5f25:	eb 47                	jmp    5f6e <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    5f27:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f2a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f34:	01 d0                	add    %edx,%eax
    5f36:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f39:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5f3f:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    5f46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5f49:	01 ca                	add    %ecx,%edx
    5f4b:	8b 0a                	mov    (%edx),%ecx
    5f4d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f50:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5f56:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    5f5d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5f60:	01 da                	add    %ebx,%edx
    5f62:	8b 12                	mov    (%edx),%edx
    5f64:	01 ca                	add    %ecx,%edx
    5f66:	01 d2                	add    %edx,%edx
    5f68:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    5f6a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5f6e:	8b 45 08             	mov    0x8(%ebp),%eax
    5f71:	8b 40 08             	mov    0x8(%eax),%eax
    5f74:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5f77:	73 ae                	jae    5f27 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    5f79:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5f80:	e9 89 00 00 00       	jmp    600e <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    5f85:	8b 45 08             	mov    0x8(%ebp),%eax
    5f88:	8b 40 04             	mov    0x4(%eax),%eax
    5f8b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5f8e:	c1 e2 02             	shl    $0x2,%edx
    5f91:	01 d0                	add    %edx,%eax
    5f93:	8b 00                	mov    (%eax),%eax
    5f95:	85 c0                	test   %eax,%eax
    5f97:	74 71                	je     600a <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    5f99:	8b 45 08             	mov    0x8(%ebp),%eax
    5f9c:	8b 00                	mov    (%eax),%eax
    5f9e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5fa1:	c1 e2 02             	shl    $0x2,%edx
    5fa4:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5fa7:	8b 45 08             	mov    0x8(%ebp),%eax
    5faa:	8b 40 04             	mov    0x4(%eax),%eax
    5fad:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5fb0:	c1 e2 02             	shl    $0x2,%edx
    5fb3:	01 d0                	add    %edx,%eax
    5fb5:	8b 00                	mov    (%eax),%eax
    5fb7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5fbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5fc1:	01 c2                	add    %eax,%edx
    5fc3:	8b 02                	mov    (%edx),%eax
    5fc5:	8d 48 01             	lea    0x1(%eax),%ecx
    5fc8:	89 0a                	mov    %ecx,(%edx)
    5fca:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    5fcc:	8b 45 08             	mov    0x8(%ebp),%eax
    5fcf:	8b 00                	mov    (%eax),%eax
    5fd1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5fd4:	c1 e2 02             	shl    $0x2,%edx
    5fd7:	01 c2                	add    %eax,%edx
    5fd9:	8b 45 08             	mov    0x8(%ebp),%eax
    5fdc:	8b 00                	mov    (%eax),%eax
    5fde:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    5fe1:	c1 e1 02             	shl    $0x2,%ecx
    5fe4:	01 c8                	add    %ecx,%eax
    5fe6:	8b 18                	mov    (%eax),%ebx
    5fe8:	8b 45 08             	mov    0x8(%ebp),%eax
    5feb:	8b 40 04             	mov    0x4(%eax),%eax
    5fee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    5ff1:	c1 e1 02             	shl    $0x2,%ecx
    5ff4:	01 c8                	add    %ecx,%eax
    5ff6:	8b 00                	mov    (%eax),%eax
    5ff8:	be 01 00 00 00       	mov    $0x1,%esi
    5ffd:	89 c1                	mov    %eax,%ecx
    5fff:	d3 e6                	shl    %cl,%esi
    6001:	89 f0                	mov    %esi,%eax
    6003:	83 e8 01             	sub    $0x1,%eax
    6006:	21 d8                	and    %ebx,%eax
    6008:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    600a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    600e:	8b 45 08             	mov    0x8(%ebp),%eax
    6011:	8b 40 0c             	mov    0xc(%eax),%eax
    6014:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6017:	0f 85 68 ff ff ff    	jne    5f85 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    601d:	83 ec 0c             	sub    $0xc,%esp
    6020:	ff 75 e8             	pushl  -0x18(%ebp)
    6023:	e8 11 ea ff ff       	call   4a39 <lodepng_free>
    6028:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    602b:	83 ec 0c             	sub    $0xc,%esp
    602e:	ff 75 e4             	pushl  -0x1c(%ebp)
    6031:	e8 03 ea ff ff       	call   4a39 <lodepng_free>
    6036:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    6039:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    603d:	75 11                	jne    6050 <HuffmanTree_makeFromLengths2+0x237>
    603f:	83 ec 0c             	sub    $0xc,%esp
    6042:	ff 75 08             	pushl  0x8(%ebp)
    6045:	e8 3f f9 ff ff       	call   5989 <HuffmanTree_makeTable>
    604a:	83 c4 10             	add    $0x10,%esp
    604d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    6050:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6053:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6056:	5b                   	pop    %ebx
    6057:	5e                   	pop    %esi
    6058:	5d                   	pop    %ebp
    6059:	c3                   	ret    

0000605a <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    605a:	55                   	push   %ebp
    605b:	89 e5                	mov    %esp,%ebp
    605d:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    6060:	8b 45 10             	mov    0x10(%ebp),%eax
    6063:	c1 e0 02             	shl    $0x2,%eax
    6066:	83 ec 0c             	sub    $0xc,%esp
    6069:	50                   	push   %eax
    606a:	e8 a9 e9 ff ff       	call   4a18 <lodepng_malloc>
    606f:	83 c4 10             	add    $0x10,%esp
    6072:	89 c2                	mov    %eax,%edx
    6074:	8b 45 08             	mov    0x8(%ebp),%eax
    6077:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    607a:	8b 45 08             	mov    0x8(%ebp),%eax
    607d:	8b 40 04             	mov    0x4(%eax),%eax
    6080:	85 c0                	test   %eax,%eax
    6082:	75 07                	jne    608b <HuffmanTree_makeFromLengths+0x31>
    6084:	b8 53 00 00 00       	mov    $0x53,%eax
    6089:	eb 56                	jmp    60e1 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    608b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6092:	eb 25                	jmp    60b9 <HuffmanTree_makeFromLengths+0x5f>
    6094:	8b 45 08             	mov    0x8(%ebp),%eax
    6097:	8b 40 04             	mov    0x4(%eax),%eax
    609a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    609d:	c1 e2 02             	shl    $0x2,%edx
    60a0:	01 c2                	add    %eax,%edx
    60a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60a5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    60ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    60af:	01 c8                	add    %ecx,%eax
    60b1:	8b 00                	mov    (%eax),%eax
    60b3:	89 02                	mov    %eax,(%edx)
    60b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    60b9:	8b 45 10             	mov    0x10(%ebp),%eax
    60bc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    60bf:	75 d3                	jne    6094 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    60c1:	8b 55 10             	mov    0x10(%ebp),%edx
    60c4:	8b 45 08             	mov    0x8(%ebp),%eax
    60c7:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    60ca:	8b 45 08             	mov    0x8(%ebp),%eax
    60cd:	8b 55 14             	mov    0x14(%ebp),%edx
    60d0:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    60d3:	83 ec 0c             	sub    $0xc,%esp
    60d6:	ff 75 08             	pushl  0x8(%ebp)
    60d9:	e8 3b fd ff ff       	call   5e19 <HuffmanTree_makeFromLengths2>
    60de:	83 c4 10             	add    $0x10,%esp
}
    60e1:	c9                   	leave  
    60e2:	c3                   	ret    

000060e3 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    60e3:	55                   	push   %ebp
    60e4:	89 e5                	mov    %esp,%ebp
    60e6:	53                   	push   %ebx
    60e7:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    60ea:	8b 45 08             	mov    0x8(%ebp),%eax
    60ed:	8b 50 0c             	mov    0xc(%eax),%edx
    60f0:	8b 45 08             	mov    0x8(%ebp),%eax
    60f3:	8b 40 08             	mov    0x8(%eax),%eax
    60f6:	39 c2                	cmp    %eax,%edx
    60f8:	0f 82 0b 01 00 00    	jb     6209 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    60fe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6105:	eb 19                	jmp    6120 <bpmnode_create+0x3d>
    6107:	8b 45 08             	mov    0x8(%ebp),%eax
    610a:	8b 40 04             	mov    0x4(%eax),%eax
    610d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6110:	c1 e2 04             	shl    $0x4,%edx
    6113:	01 d0                	add    %edx,%eax
    6115:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    611c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6120:	8b 45 08             	mov    0x8(%ebp),%eax
    6123:	8b 00                	mov    (%eax),%eax
    6125:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6128:	75 dd                	jne    6107 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    612a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6131:	eb 60                	jmp    6193 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    6133:	8b 45 08             	mov    0x8(%ebp),%eax
    6136:	8b 40 18             	mov    0x18(%eax),%eax
    6139:	8b 55 f8             	mov    -0x8(%ebp),%edx
    613c:	c1 e2 02             	shl    $0x2,%edx
    613f:	01 d0                	add    %edx,%eax
    6141:	8b 00                	mov    (%eax),%eax
    6143:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6146:	eb 13                	jmp    615b <bpmnode_create+0x78>
    6148:	8b 45 f4             	mov    -0xc(%ebp),%eax
    614b:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    6152:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6155:	8b 40 08             	mov    0x8(%eax),%eax
    6158:	89 45 f4             	mov    %eax,-0xc(%ebp)
    615b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    615f:	75 e7                	jne    6148 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    6161:	8b 45 08             	mov    0x8(%ebp),%eax
    6164:	8b 40 1c             	mov    0x1c(%eax),%eax
    6167:	8b 55 f8             	mov    -0x8(%ebp),%edx
    616a:	c1 e2 02             	shl    $0x2,%edx
    616d:	01 d0                	add    %edx,%eax
    616f:	8b 00                	mov    (%eax),%eax
    6171:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6174:	eb 13                	jmp    6189 <bpmnode_create+0xa6>
    6176:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6179:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    6180:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6183:	8b 40 08             	mov    0x8(%eax),%eax
    6186:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6189:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    618d:	75 e7                	jne    6176 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    618f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6193:	8b 45 08             	mov    0x8(%ebp),%eax
    6196:	8b 40 14             	mov    0x14(%eax),%eax
    6199:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    619c:	75 95                	jne    6133 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    619e:	8b 45 08             	mov    0x8(%ebp),%eax
    61a1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    61a8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    61af:	eb 44                	jmp    61f5 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    61b1:	8b 45 08             	mov    0x8(%ebp),%eax
    61b4:	8b 40 04             	mov    0x4(%eax),%eax
    61b7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    61ba:	c1 e2 04             	shl    $0x4,%edx
    61bd:	01 d0                	add    %edx,%eax
    61bf:	8b 40 0c             	mov    0xc(%eax),%eax
    61c2:	85 c0                	test   %eax,%eax
    61c4:	75 2b                	jne    61f1 <bpmnode_create+0x10e>
    61c6:	8b 45 08             	mov    0x8(%ebp),%eax
    61c9:	8b 58 10             	mov    0x10(%eax),%ebx
    61cc:	8b 45 08             	mov    0x8(%ebp),%eax
    61cf:	8b 40 08             	mov    0x8(%eax),%eax
    61d2:	8d 48 01             	lea    0x1(%eax),%ecx
    61d5:	8b 55 08             	mov    0x8(%ebp),%edx
    61d8:	89 4a 08             	mov    %ecx,0x8(%edx)
    61db:	c1 e0 02             	shl    $0x2,%eax
    61de:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    61e1:	8b 45 08             	mov    0x8(%ebp),%eax
    61e4:	8b 40 04             	mov    0x4(%eax),%eax
    61e7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    61ea:	c1 e1 04             	shl    $0x4,%ecx
    61ed:	01 c8                	add    %ecx,%eax
    61ef:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    61f1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    61f5:	8b 45 08             	mov    0x8(%ebp),%eax
    61f8:	8b 00                	mov    (%eax),%eax
    61fa:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    61fd:	75 b2                	jne    61b1 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    61ff:	8b 45 08             	mov    0x8(%ebp),%eax
    6202:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    6209:	8b 45 08             	mov    0x8(%ebp),%eax
    620c:	8b 58 10             	mov    0x10(%eax),%ebx
    620f:	8b 45 08             	mov    0x8(%ebp),%eax
    6212:	8b 40 0c             	mov    0xc(%eax),%eax
    6215:	8d 48 01             	lea    0x1(%eax),%ecx
    6218:	8b 55 08             	mov    0x8(%ebp),%edx
    621b:	89 4a 0c             	mov    %ecx,0xc(%edx)
    621e:	c1 e0 02             	shl    $0x2,%eax
    6221:	01 d8                	add    %ebx,%eax
    6223:	8b 00                	mov    (%eax),%eax
    6225:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    6228:	8b 45 f0             	mov    -0x10(%ebp),%eax
    622b:	8b 55 0c             	mov    0xc(%ebp),%edx
    622e:	89 10                	mov    %edx,(%eax)
  result->index = index;
    6230:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6233:	8b 55 10             	mov    0x10(%ebp),%edx
    6236:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    6239:	8b 45 f0             	mov    -0x10(%ebp),%eax
    623c:	8b 55 14             	mov    0x14(%ebp),%edx
    623f:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    6242:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6245:	83 c4 10             	add    $0x10,%esp
    6248:	5b                   	pop    %ebx
    6249:	5d                   	pop    %ebp
    624a:	c3                   	ret    

0000624b <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    624b:	55                   	push   %ebp
    624c:	89 e5                	mov    %esp,%ebp
    624e:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    6251:	8b 45 0c             	mov    0xc(%ebp),%eax
    6254:	c1 e0 04             	shl    $0x4,%eax
    6257:	83 ec 0c             	sub    $0xc,%esp
    625a:	50                   	push   %eax
    625b:	e8 b8 e7 ff ff       	call   4a18 <lodepng_malloc>
    6260:	83 c4 10             	add    $0x10,%esp
    6263:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    6266:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    626d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    6274:	e9 41 01 00 00       	jmp    63ba <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    6279:	8b 45 f0             	mov    -0x10(%ebp),%eax
    627c:	83 e0 01             	and    $0x1,%eax
    627f:	85 c0                	test   %eax,%eax
    6281:	74 05                	je     6288 <bpmnode_sort+0x3d>
    6283:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6286:	eb 03                	jmp    628b <bpmnode_sort+0x40>
    6288:	8b 45 08             	mov    0x8(%ebp),%eax
    628b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    628e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6291:	83 e0 01             	and    $0x1,%eax
    6294:	85 c0                	test   %eax,%eax
    6296:	74 05                	je     629d <bpmnode_sort+0x52>
    6298:	8b 45 08             	mov    0x8(%ebp),%eax
    629b:	eb 03                	jmp    62a0 <bpmnode_sort+0x55>
    629d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    62a0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    62a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    62aa:	e9 f8 00 00 00       	jmp    63a7 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    62af:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    62b5:	01 c2                	add    %eax,%edx
    62b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    62ba:	39 c2                	cmp    %eax,%edx
    62bc:	0f 4e c2             	cmovle %edx,%eax
    62bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    62c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    62c5:	8d 14 00             	lea    (%eax,%eax,1),%edx
    62c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    62cb:	01 c2                	add    %eax,%edx
    62cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    62d0:	39 c2                	cmp    %eax,%edx
    62d2:	0f 4e c2             	cmovle %edx,%eax
    62d5:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    62d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    62db:	89 45 e8             	mov    %eax,-0x18(%ebp)
    62de:	8b 45 d0             	mov    -0x30(%ebp),%eax
    62e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    62e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    62e7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    62ea:	e9 a4 00 00 00       	jmp    6393 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    62ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
    62f2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    62f5:	7d 62                	jge    6359 <bpmnode_sort+0x10e>
    62f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    62fa:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    62fd:	7d 22                	jge    6321 <bpmnode_sort+0xd6>
    62ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6302:	c1 e0 04             	shl    $0x4,%eax
    6305:	89 c2                	mov    %eax,%edx
    6307:	8b 45 d8             	mov    -0x28(%ebp),%eax
    630a:	01 d0                	add    %edx,%eax
    630c:	8b 10                	mov    (%eax),%edx
    630e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6311:	c1 e0 04             	shl    $0x4,%eax
    6314:	89 c1                	mov    %eax,%ecx
    6316:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6319:	01 c8                	add    %ecx,%eax
    631b:	8b 00                	mov    (%eax),%eax
    631d:	39 c2                	cmp    %eax,%edx
    631f:	7f 38                	jg     6359 <bpmnode_sort+0x10e>
    6321:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6324:	c1 e0 04             	shl    $0x4,%eax
    6327:	89 c2                	mov    %eax,%edx
    6329:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    632c:	01 d0                	add    %edx,%eax
    632e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6331:	8d 4a 01             	lea    0x1(%edx),%ecx
    6334:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    6337:	89 d1                	mov    %edx,%ecx
    6339:	c1 e1 04             	shl    $0x4,%ecx
    633c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    633f:	01 ca                	add    %ecx,%edx
    6341:	8b 0a                	mov    (%edx),%ecx
    6343:	89 08                	mov    %ecx,(%eax)
    6345:	8b 4a 04             	mov    0x4(%edx),%ecx
    6348:	89 48 04             	mov    %ecx,0x4(%eax)
    634b:	8b 4a 08             	mov    0x8(%edx),%ecx
    634e:	89 48 08             	mov    %ecx,0x8(%eax)
    6351:	8b 52 0c             	mov    0xc(%edx),%edx
    6354:	89 50 0c             	mov    %edx,0xc(%eax)
    6357:	eb 36                	jmp    638f <bpmnode_sort+0x144>
        else b[k] = a[j++];
    6359:	8b 45 e0             	mov    -0x20(%ebp),%eax
    635c:	c1 e0 04             	shl    $0x4,%eax
    635f:	89 c2                	mov    %eax,%edx
    6361:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6364:	01 d0                	add    %edx,%eax
    6366:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    6369:	8d 4a 01             	lea    0x1(%edx),%ecx
    636c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    636f:	89 d1                	mov    %edx,%ecx
    6371:	c1 e1 04             	shl    $0x4,%ecx
    6374:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6377:	01 ca                	add    %ecx,%edx
    6379:	8b 0a                	mov    (%edx),%ecx
    637b:	89 08                	mov    %ecx,(%eax)
    637d:	8b 4a 04             	mov    0x4(%edx),%ecx
    6380:	89 48 04             	mov    %ecx,0x4(%eax)
    6383:	8b 4a 08             	mov    0x8(%edx),%ecx
    6386:	89 48 08             	mov    %ecx,0x8(%eax)
    6389:	8b 52 0c             	mov    0xc(%edx),%edx
    638c:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    638f:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    6393:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6396:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6399:	0f 8c 50 ff ff ff    	jl     62ef <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    639f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63a2:	01 c0                	add    %eax,%eax
    63a4:	01 45 ec             	add    %eax,-0x14(%ebp)
    63a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    63aa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63ad:	0f 8c fc fe ff ff    	jl     62af <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    63b3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    63b7:	d1 65 f4             	shll   -0xc(%ebp)
    63ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63bd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63c0:	0f 8c b3 fe ff ff    	jl     6279 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    63c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    63c9:	83 e0 01             	and    $0x1,%eax
    63cc:	85 c0                	test   %eax,%eax
    63ce:	74 18                	je     63e8 <bpmnode_sort+0x19d>
    63d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    63d3:	c1 e0 04             	shl    $0x4,%eax
    63d6:	83 ec 04             	sub    $0x4,%esp
    63d9:	50                   	push   %eax
    63da:	ff 75 dc             	pushl  -0x24(%ebp)
    63dd:	ff 75 08             	pushl  0x8(%ebp)
    63e0:	e8 71 e6 ff ff       	call   4a56 <lodepng_memcpy>
    63e5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    63e8:	83 ec 0c             	sub    $0xc,%esp
    63eb:	ff 75 dc             	pushl  -0x24(%ebp)
    63ee:	e8 46 e6 ff ff       	call   4a39 <lodepng_free>
    63f3:	83 c4 10             	add    $0x10,%esp
}
    63f6:	90                   	nop
    63f7:	c9                   	leave  
    63f8:	c3                   	ret    

000063f9 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    63f9:	55                   	push   %ebp
    63fa:	89 e5                	mov    %esp,%ebp
    63fc:	56                   	push   %esi
    63fd:	53                   	push   %ebx
    63fe:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    6401:	8b 45 08             	mov    0x8(%ebp),%eax
    6404:	8b 40 1c             	mov    0x1c(%eax),%eax
    6407:	8b 55 14             	mov    0x14(%ebp),%edx
    640a:	c1 e2 02             	shl    $0x2,%edx
    640d:	01 d0                	add    %edx,%eax
    640f:	8b 00                	mov    (%eax),%eax
    6411:	8b 40 04             	mov    0x4(%eax),%eax
    6414:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    6417:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    641b:	75 66                	jne    6483 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    641d:	8b 45 10             	mov    0x10(%ebp),%eax
    6420:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6423:	0f 83 a0 01 00 00    	jae    65c9 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    6429:	8b 45 08             	mov    0x8(%ebp),%eax
    642c:	8b 40 18             	mov    0x18(%eax),%eax
    642f:	8b 55 14             	mov    0x14(%ebp),%edx
    6432:	c1 e2 02             	shl    $0x2,%edx
    6435:	01 c2                	add    %eax,%edx
    6437:	8b 45 08             	mov    0x8(%ebp),%eax
    643a:	8b 40 1c             	mov    0x1c(%eax),%eax
    643d:	8b 4d 14             	mov    0x14(%ebp),%ecx
    6440:	c1 e1 02             	shl    $0x2,%ecx
    6443:	01 c8                	add    %ecx,%eax
    6445:	8b 00                	mov    (%eax),%eax
    6447:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    6449:	8b 45 08             	mov    0x8(%ebp),%eax
    644c:	8b 40 1c             	mov    0x1c(%eax),%eax
    644f:	8b 55 14             	mov    0x14(%ebp),%edx
    6452:	c1 e2 02             	shl    $0x2,%edx
    6455:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    6458:	8b 45 f4             	mov    -0xc(%ebp),%eax
    645b:	8d 50 01             	lea    0x1(%eax),%edx
    645e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6461:	c1 e0 04             	shl    $0x4,%eax
    6464:	89 c1                	mov    %eax,%ecx
    6466:	8b 45 0c             	mov    0xc(%ebp),%eax
    6469:	01 c8                	add    %ecx,%eax
    646b:	8b 00                	mov    (%eax),%eax
    646d:	6a 00                	push   $0x0
    646f:	52                   	push   %edx
    6470:	50                   	push   %eax
    6471:	ff 75 08             	pushl  0x8(%ebp)
    6474:	e8 6a fc ff ff       	call   60e3 <bpmnode_create>
    6479:	83 c4 10             	add    $0x10,%esp
    647c:	89 03                	mov    %eax,(%ebx)
    647e:	e9 47 01 00 00       	jmp    65ca <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    6483:	8b 45 08             	mov    0x8(%ebp),%eax
    6486:	8b 40 18             	mov    0x18(%eax),%eax
    6489:	8b 55 14             	mov    0x14(%ebp),%edx
    648c:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    6492:	c1 e2 02             	shl    $0x2,%edx
    6495:	01 d0                	add    %edx,%eax
    6497:	8b 00                	mov    (%eax),%eax
    6499:	8b 10                	mov    (%eax),%edx
    649b:	8b 45 08             	mov    0x8(%ebp),%eax
    649e:	8b 40 1c             	mov    0x1c(%eax),%eax
    64a1:	8b 4d 14             	mov    0x14(%ebp),%ecx
    64a4:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    64aa:	c1 e1 02             	shl    $0x2,%ecx
    64ad:	01 c8                	add    %ecx,%eax
    64af:	8b 00                	mov    (%eax),%eax
    64b1:	8b 00                	mov    (%eax),%eax
    64b3:	01 d0                	add    %edx,%eax
    64b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    64b8:	8b 45 08             	mov    0x8(%ebp),%eax
    64bb:	8b 40 18             	mov    0x18(%eax),%eax
    64be:	8b 55 14             	mov    0x14(%ebp),%edx
    64c1:	c1 e2 02             	shl    $0x2,%edx
    64c4:	01 c2                	add    %eax,%edx
    64c6:	8b 45 08             	mov    0x8(%ebp),%eax
    64c9:	8b 40 1c             	mov    0x1c(%eax),%eax
    64cc:	8b 4d 14             	mov    0x14(%ebp),%ecx
    64cf:	c1 e1 02             	shl    $0x2,%ecx
    64d2:	01 c8                	add    %ecx,%eax
    64d4:	8b 00                	mov    (%eax),%eax
    64d6:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    64d8:	8b 45 10             	mov    0x10(%ebp),%eax
    64db:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    64de:	73 60                	jae    6540 <boundaryPM+0x147>
    64e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64e3:	c1 e0 04             	shl    $0x4,%eax
    64e6:	89 c2                	mov    %eax,%edx
    64e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    64eb:	01 d0                	add    %edx,%eax
    64ed:	8b 00                	mov    (%eax),%eax
    64ef:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    64f2:	7d 4c                	jge    6540 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    64f4:	8b 45 08             	mov    0x8(%ebp),%eax
    64f7:	8b 40 1c             	mov    0x1c(%eax),%eax
    64fa:	8b 55 14             	mov    0x14(%ebp),%edx
    64fd:	c1 e2 02             	shl    $0x2,%edx
    6500:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    6503:	8b 45 08             	mov    0x8(%ebp),%eax
    6506:	8b 40 1c             	mov    0x1c(%eax),%eax
    6509:	8b 55 14             	mov    0x14(%ebp),%edx
    650c:	c1 e2 02             	shl    $0x2,%edx
    650f:	01 d0                	add    %edx,%eax
    6511:	8b 00                	mov    (%eax),%eax
    6513:	8b 50 08             	mov    0x8(%eax),%edx
    6516:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6519:	8d 48 01             	lea    0x1(%eax),%ecx
    651c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    651f:	c1 e0 04             	shl    $0x4,%eax
    6522:	89 c6                	mov    %eax,%esi
    6524:	8b 45 0c             	mov    0xc(%ebp),%eax
    6527:	01 f0                	add    %esi,%eax
    6529:	8b 00                	mov    (%eax),%eax
    652b:	52                   	push   %edx
    652c:	51                   	push   %ecx
    652d:	50                   	push   %eax
    652e:	ff 75 08             	pushl  0x8(%ebp)
    6531:	e8 ad fb ff ff       	call   60e3 <bpmnode_create>
    6536:	83 c4 10             	add    $0x10,%esp
    6539:	89 03                	mov    %eax,(%ebx)
      return;
    653b:	e9 8a 00 00 00       	jmp    65ca <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    6540:	8b 45 08             	mov    0x8(%ebp),%eax
    6543:	8b 40 1c             	mov    0x1c(%eax),%eax
    6546:	8b 55 14             	mov    0x14(%ebp),%edx
    6549:	c1 e2 02             	shl    $0x2,%edx
    654c:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    654f:	8b 45 08             	mov    0x8(%ebp),%eax
    6552:	8b 40 1c             	mov    0x1c(%eax),%eax
    6555:	8b 55 14             	mov    0x14(%ebp),%edx
    6558:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    655e:	c1 e2 02             	shl    $0x2,%edx
    6561:	01 d0                	add    %edx,%eax
    6563:	8b 00                	mov    (%eax),%eax
    6565:	50                   	push   %eax
    6566:	ff 75 f4             	pushl  -0xc(%ebp)
    6569:	ff 75 f0             	pushl  -0x10(%ebp)
    656c:	ff 75 08             	pushl  0x8(%ebp)
    656f:	e8 6f fb ff ff       	call   60e3 <bpmnode_create>
    6574:	83 c4 10             	add    $0x10,%esp
    6577:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    6579:	8b 45 18             	mov    0x18(%ebp),%eax
    657c:	8d 50 01             	lea    0x1(%eax),%edx
    657f:	8b 45 10             	mov    0x10(%ebp),%eax
    6582:	83 e8 01             	sub    $0x1,%eax
    6585:	01 c0                	add    %eax,%eax
    6587:	39 c2                	cmp    %eax,%edx
    6589:	7d 3f                	jge    65ca <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    658b:	8b 45 14             	mov    0x14(%ebp),%eax
    658e:	83 e8 01             	sub    $0x1,%eax
    6591:	83 ec 0c             	sub    $0xc,%esp
    6594:	ff 75 18             	pushl  0x18(%ebp)
    6597:	50                   	push   %eax
    6598:	ff 75 10             	pushl  0x10(%ebp)
    659b:	ff 75 0c             	pushl  0xc(%ebp)
    659e:	ff 75 08             	pushl  0x8(%ebp)
    65a1:	e8 53 fe ff ff       	call   63f9 <boundaryPM>
    65a6:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    65a9:	8b 45 14             	mov    0x14(%ebp),%eax
    65ac:	83 e8 01             	sub    $0x1,%eax
    65af:	83 ec 0c             	sub    $0xc,%esp
    65b2:	ff 75 18             	pushl  0x18(%ebp)
    65b5:	50                   	push   %eax
    65b6:	ff 75 10             	pushl  0x10(%ebp)
    65b9:	ff 75 0c             	pushl  0xc(%ebp)
    65bc:	ff 75 08             	pushl  0x8(%ebp)
    65bf:	e8 35 fe ff ff       	call   63f9 <boundaryPM>
    65c4:	83 c4 20             	add    $0x20,%esp
    65c7:	eb 01                	jmp    65ca <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    65c9:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    65ca:	8d 65 f8             	lea    -0x8(%ebp),%esp
    65cd:	5b                   	pop    %ebx
    65ce:	5e                   	pop    %esi
    65cf:	5d                   	pop    %ebp
    65d0:	c3                   	ret    

000065d1 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    65d1:	55                   	push   %ebp
    65d2:	89 e5                	mov    %esp,%ebp
    65d4:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    65d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    65de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    65e5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    65e9:	75 0a                	jne    65f5 <lodepng_huffman_code_lengths+0x24>
    65eb:	b8 50 00 00 00       	mov    $0x50,%eax
    65f0:	e9 4d 03 00 00       	jmp    6942 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    65f5:	8b 45 14             	mov    0x14(%ebp),%eax
    65f8:	ba 01 00 00 00       	mov    $0x1,%edx
    65fd:	89 c1                	mov    %eax,%ecx
    65ff:	d3 e2                	shl    %cl,%edx
    6601:	8b 45 10             	mov    0x10(%ebp),%eax
    6604:	39 c2                	cmp    %eax,%edx
    6606:	73 0a                	jae    6612 <lodepng_huffman_code_lengths+0x41>
    6608:	b8 50 00 00 00       	mov    $0x50,%eax
    660d:	e9 30 03 00 00       	jmp    6942 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    6612:	8b 45 10             	mov    0x10(%ebp),%eax
    6615:	c1 e0 04             	shl    $0x4,%eax
    6618:	83 ec 0c             	sub    $0xc,%esp
    661b:	50                   	push   %eax
    661c:	e8 f7 e3 ff ff       	call   4a18 <lodepng_malloc>
    6621:	83 c4 10             	add    $0x10,%esp
    6624:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    6627:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    662b:	75 0a                	jne    6637 <lodepng_huffman_code_lengths+0x66>
    662d:	b8 53 00 00 00       	mov    $0x53,%eax
    6632:	e9 0b 03 00 00       	jmp    6942 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    6637:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    663e:	eb 50                	jmp    6690 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    6640:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6643:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    664a:	8b 45 0c             	mov    0xc(%ebp),%eax
    664d:	01 d0                	add    %edx,%eax
    664f:	8b 00                	mov    (%eax),%eax
    6651:	85 c0                	test   %eax,%eax
    6653:	74 37                	je     668c <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    6655:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6658:	c1 e0 04             	shl    $0x4,%eax
    665b:	89 c2                	mov    %eax,%edx
    665d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6660:	01 d0                	add    %edx,%eax
    6662:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6665:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    666c:	8b 55 0c             	mov    0xc(%ebp),%edx
    666f:	01 ca                	add    %ecx,%edx
    6671:	8b 12                	mov    (%edx),%edx
    6673:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    6675:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6678:	c1 e0 04             	shl    $0x4,%eax
    667b:	89 c2                	mov    %eax,%edx
    667d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6680:	01 c2                	add    %eax,%edx
    6682:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6685:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    6688:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    668c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6690:	8b 45 10             	mov    0x10(%ebp),%eax
    6693:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    6696:	75 a8                	jne    6640 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    6698:	8b 45 10             	mov    0x10(%ebp),%eax
    669b:	c1 e0 02             	shl    $0x2,%eax
    669e:	83 ec 04             	sub    $0x4,%esp
    66a1:	50                   	push   %eax
    66a2:	6a 00                	push   $0x0
    66a4:	ff 75 08             	pushl  0x8(%ebp)
    66a7:	e8 dd e3 ff ff       	call   4a89 <lodepng_memset>
    66ac:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    66af:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    66b3:	75 18                	jne    66cd <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    66b5:	8b 45 08             	mov    0x8(%ebp),%eax
    66b8:	83 c0 04             	add    $0x4,%eax
    66bb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    66c1:	8b 10                	mov    (%eax),%edx
    66c3:	8b 45 08             	mov    0x8(%ebp),%eax
    66c6:	89 10                	mov    %edx,(%eax)
    66c8:	e9 64 02 00 00       	jmp    6931 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    66cd:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    66d1:	75 3e                	jne    6711 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    66d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    66d6:	8b 40 04             	mov    0x4(%eax),%eax
    66d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    66e0:	8b 45 08             	mov    0x8(%ebp),%eax
    66e3:	01 d0                	add    %edx,%eax
    66e5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    66eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    66ee:	8b 40 04             	mov    0x4(%eax),%eax
    66f1:	85 c0                	test   %eax,%eax
    66f3:	75 07                	jne    66fc <lodepng_huffman_code_lengths+0x12b>
    66f5:	ba 04 00 00 00       	mov    $0x4,%edx
    66fa:	eb 05                	jmp    6701 <lodepng_huffman_code_lengths+0x130>
    66fc:	ba 00 00 00 00       	mov    $0x0,%edx
    6701:	8b 45 08             	mov    0x8(%ebp),%eax
    6704:	01 d0                	add    %edx,%eax
    6706:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    670c:	e9 20 02 00 00       	jmp    6931 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    6711:	83 ec 08             	sub    $0x8,%esp
    6714:	ff 75 ec             	pushl  -0x14(%ebp)
    6717:	ff 75 e4             	pushl  -0x1c(%ebp)
    671a:	e8 2c fb ff ff       	call   624b <bpmnode_sort>
    671f:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    6722:	8b 45 14             	mov    0x14(%ebp),%eax
    6725:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    6728:	8b 45 14             	mov    0x14(%ebp),%eax
    672b:	83 c0 01             	add    $0x1,%eax
    672e:	0f af 45 14          	imul   0x14(%ebp),%eax
    6732:	01 c0                	add    %eax,%eax
    6734:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    6737:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    673e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6741:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    6744:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6747:	c1 e0 04             	shl    $0x4,%eax
    674a:	83 ec 0c             	sub    $0xc,%esp
    674d:	50                   	push   %eax
    674e:	e8 c5 e2 ff ff       	call   4a18 <lodepng_malloc>
    6753:	83 c4 10             	add    $0x10,%esp
    6756:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    6759:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    675c:	c1 e0 02             	shl    $0x2,%eax
    675f:	83 ec 0c             	sub    $0xc,%esp
    6762:	50                   	push   %eax
    6763:	e8 b0 e2 ff ff       	call   4a18 <lodepng_malloc>
    6768:	83 c4 10             	add    $0x10,%esp
    676b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    676e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6771:	c1 e0 02             	shl    $0x2,%eax
    6774:	83 ec 0c             	sub    $0xc,%esp
    6777:	50                   	push   %eax
    6778:	e8 9b e2 ff ff       	call   4a18 <lodepng_malloc>
    677d:	83 c4 10             	add    $0x10,%esp
    6780:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    6783:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6786:	c1 e0 02             	shl    $0x2,%eax
    6789:	83 ec 0c             	sub    $0xc,%esp
    678c:	50                   	push   %eax
    678d:	e8 86 e2 ff ff       	call   4a18 <lodepng_malloc>
    6792:	83 c4 10             	add    $0x10,%esp
    6795:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    6798:	8b 45 c8             	mov    -0x38(%ebp),%eax
    679b:	85 c0                	test   %eax,%eax
    679d:	74 15                	je     67b4 <lodepng_huffman_code_lengths+0x1e3>
    679f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    67a2:	85 c0                	test   %eax,%eax
    67a4:	74 0e                	je     67b4 <lodepng_huffman_code_lengths+0x1e3>
    67a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    67a9:	85 c0                	test   %eax,%eax
    67ab:	74 07                	je     67b4 <lodepng_huffman_code_lengths+0x1e3>
    67ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
    67b0:	85 c0                	test   %eax,%eax
    67b2:	75 07                	jne    67bb <lodepng_huffman_code_lengths+0x1ea>
    67b4:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    67bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    67bf:	0f 85 30 01 00 00    	jne    68f5 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    67c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    67cc:	eb 1c                	jmp    67ea <lodepng_huffman_code_lengths+0x219>
    67ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    67d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    67d4:	c1 e2 02             	shl    $0x2,%edx
    67d7:	01 d0                	add    %edx,%eax
    67d9:	8b 55 c8             	mov    -0x38(%ebp),%edx
    67dc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    67df:	c1 e1 04             	shl    $0x4,%ecx
    67e2:	01 ca                	add    %ecx,%edx
    67e4:	89 10                	mov    %edx,(%eax)
    67e6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    67ea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    67ed:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    67f0:	75 dc                	jne    67ce <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    67f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    67f5:	8b 00                	mov    (%eax),%eax
    67f7:	6a 00                	push   $0x0
    67f9:	6a 01                	push   $0x1
    67fb:	50                   	push   %eax
    67fc:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    67ff:	50                   	push   %eax
    6800:	e8 de f8 ff ff       	call   60e3 <bpmnode_create>
    6805:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    6808:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    680b:	83 c0 10             	add    $0x10,%eax
    680e:	8b 00                	mov    (%eax),%eax
    6810:	6a 00                	push   $0x0
    6812:	6a 02                	push   $0x2
    6814:	50                   	push   %eax
    6815:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    6818:	50                   	push   %eax
    6819:	e8 c5 f8 ff ff       	call   60e3 <bpmnode_create>
    681e:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    6821:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6828:	eb 27                	jmp    6851 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    682a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    682d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6830:	c1 e2 02             	shl    $0x2,%edx
    6833:	01 c2                	add    %eax,%edx
    6835:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6838:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    683a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    683d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6840:	c1 e2 02             	shl    $0x2,%edx
    6843:	01 d0                	add    %edx,%eax
    6845:	8b 55 c8             	mov    -0x38(%ebp),%edx
    6848:	83 c2 10             	add    $0x10,%edx
    684b:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    684d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6851:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6854:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6857:	75 d1                	jne    682a <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    6859:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    6860:	eb 24                	jmp    6886 <lodepng_huffman_code_lengths+0x2b5>
    6862:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6865:	8b 55 14             	mov    0x14(%ebp),%edx
    6868:	83 ea 01             	sub    $0x1,%edx
    686b:	83 ec 0c             	sub    $0xc,%esp
    686e:	50                   	push   %eax
    686f:	52                   	push   %edx
    6870:	ff 75 ec             	pushl  -0x14(%ebp)
    6873:	ff 75 e4             	pushl  -0x1c(%ebp)
    6876:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    6879:	50                   	push   %eax
    687a:	e8 7a fb ff ff       	call   63f9 <boundaryPM>
    687f:	83 c4 20             	add    $0x20,%esp
    6882:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6886:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6889:	83 e8 01             	sub    $0x1,%eax
    688c:	01 c0                	add    %eax,%eax
    688e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6891:	75 cf                	jne    6862 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    6893:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6896:	8b 55 14             	mov    0x14(%ebp),%edx
    6899:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    689f:	c1 e2 02             	shl    $0x2,%edx
    68a2:	01 d0                	add    %edx,%eax
    68a4:	8b 00                	mov    (%eax),%eax
    68a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    68a9:	eb 44                	jmp    68ef <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    68ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    68b2:	eb 27                	jmp    68db <lodepng_huffman_code_lengths+0x30a>
    68b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    68b7:	c1 e0 04             	shl    $0x4,%eax
    68ba:	89 c2                	mov    %eax,%edx
    68bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    68bf:	01 d0                	add    %edx,%eax
    68c1:	8b 40 04             	mov    0x4(%eax),%eax
    68c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    68cb:	8b 45 08             	mov    0x8(%ebp),%eax
    68ce:	01 d0                	add    %edx,%eax
    68d0:	8b 10                	mov    (%eax),%edx
    68d2:	83 c2 01             	add    $0x1,%edx
    68d5:	89 10                	mov    %edx,(%eax)
    68d7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    68db:	8b 45 e8             	mov    -0x18(%ebp),%eax
    68de:	8b 40 04             	mov    0x4(%eax),%eax
    68e1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68e4:	75 ce                	jne    68b4 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    68e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    68e9:	8b 40 08             	mov    0x8(%eax),%eax
    68ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
    68ef:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    68f3:	75 b6                	jne    68ab <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    68f5:	8b 45 c8             	mov    -0x38(%ebp),%eax
    68f8:	83 ec 0c             	sub    $0xc,%esp
    68fb:	50                   	push   %eax
    68fc:	e8 38 e1 ff ff       	call   4a39 <lodepng_free>
    6901:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    6904:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6907:	83 ec 0c             	sub    $0xc,%esp
    690a:	50                   	push   %eax
    690b:	e8 29 e1 ff ff       	call   4a39 <lodepng_free>
    6910:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    6913:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6916:	83 ec 0c             	sub    $0xc,%esp
    6919:	50                   	push   %eax
    691a:	e8 1a e1 ff ff       	call   4a39 <lodepng_free>
    691f:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    6922:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6925:	83 ec 0c             	sub    $0xc,%esp
    6928:	50                   	push   %eax
    6929:	e8 0b e1 ff ff       	call   4a39 <lodepng_free>
    692e:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    6931:	83 ec 0c             	sub    $0xc,%esp
    6934:	ff 75 e4             	pushl  -0x1c(%ebp)
    6937:	e8 fd e0 ff ff       	call   4a39 <lodepng_free>
    693c:	83 c4 10             	add    $0x10,%esp
  return error;
    693f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6942:	c9                   	leave  
    6943:	c3                   	ret    

00006944 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    6944:	55                   	push   %ebp
    6945:	89 e5                	mov    %esp,%ebp
    6947:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    694a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    6951:	eb 04                	jmp    6957 <HuffmanTree_makeFromFrequencies+0x13>
    6953:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    6957:	8b 45 14             	mov    0x14(%ebp),%eax
    695a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    695f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6966:	8b 45 0c             	mov    0xc(%ebp),%eax
    6969:	01 d0                	add    %edx,%eax
    696b:	8b 00                	mov    (%eax),%eax
    696d:	85 c0                	test   %eax,%eax
    696f:	75 08                	jne    6979 <HuffmanTree_makeFromFrequencies+0x35>
    6971:	8b 45 14             	mov    0x14(%ebp),%eax
    6974:	3b 45 10             	cmp    0x10(%ebp),%eax
    6977:	7f da                	jg     6953 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    6979:	8b 45 14             	mov    0x14(%ebp),%eax
    697c:	c1 e0 02             	shl    $0x2,%eax
    697f:	83 ec 0c             	sub    $0xc,%esp
    6982:	50                   	push   %eax
    6983:	e8 90 e0 ff ff       	call   4a18 <lodepng_malloc>
    6988:	83 c4 10             	add    $0x10,%esp
    698b:	89 c2                	mov    %eax,%edx
    698d:	8b 45 08             	mov    0x8(%ebp),%eax
    6990:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    6993:	8b 45 08             	mov    0x8(%ebp),%eax
    6996:	8b 40 04             	mov    0x4(%eax),%eax
    6999:	85 c0                	test   %eax,%eax
    699b:	75 07                	jne    69a4 <HuffmanTree_makeFromFrequencies+0x60>
    699d:	b8 53 00 00 00       	mov    $0x53,%eax
    69a2:	eb 47                	jmp    69eb <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    69a4:	8b 45 08             	mov    0x8(%ebp),%eax
    69a7:	8b 55 18             	mov    0x18(%ebp),%edx
    69aa:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    69ad:	8b 55 14             	mov    0x14(%ebp),%edx
    69b0:	8b 45 08             	mov    0x8(%ebp),%eax
    69b3:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    69b6:	8b 45 08             	mov    0x8(%ebp),%eax
    69b9:	8b 40 04             	mov    0x4(%eax),%eax
    69bc:	ff 75 18             	pushl  0x18(%ebp)
    69bf:	ff 75 14             	pushl  0x14(%ebp)
    69c2:	ff 75 0c             	pushl  0xc(%ebp)
    69c5:	50                   	push   %eax
    69c6:	e8 06 fc ff ff       	call   65d1 <lodepng_huffman_code_lengths>
    69cb:	83 c4 10             	add    $0x10,%esp
    69ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    69d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    69d5:	75 11                	jne    69e8 <HuffmanTree_makeFromFrequencies+0xa4>
    69d7:	83 ec 0c             	sub    $0xc,%esp
    69da:	ff 75 08             	pushl  0x8(%ebp)
    69dd:	e8 37 f4 ff ff       	call   5e19 <HuffmanTree_makeFromLengths2>
    69e2:	83 c4 10             	add    $0x10,%esp
    69e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    69e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    69eb:	c9                   	leave  
    69ec:	c3                   	ret    

000069ed <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    69ed:	55                   	push   %ebp
    69ee:	89 e5                	mov    %esp,%ebp
    69f0:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    69f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    69fa:	83 ec 0c             	sub    $0xc,%esp
    69fd:	68 80 04 00 00       	push   $0x480
    6a02:	e8 11 e0 ff ff       	call   4a18 <lodepng_malloc>
    6a07:	83 c4 10             	add    $0x10,%esp
    6a0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    6a0d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6a11:	75 0a                	jne    6a1d <generateFixedLitLenTree+0x30>
    6a13:	b8 53 00 00 00       	mov    $0x53,%eax
    6a18:	e9 d5 00 00 00       	jmp    6af2 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    6a1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6a24:	eb 19                	jmp    6a3f <generateFixedLitLenTree+0x52>
    6a26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6a29:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6a30:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a33:	01 d0                	add    %edx,%eax
    6a35:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    6a3b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6a3f:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    6a46:	76 de                	jbe    6a26 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    6a48:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    6a4f:	eb 19                	jmp    6a6a <generateFixedLitLenTree+0x7d>
    6a51:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6a54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6a5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a5e:	01 d0                	add    %edx,%eax
    6a60:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    6a66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6a6a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    6a71:	76 de                	jbe    6a51 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    6a73:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    6a7a:	eb 19                	jmp    6a95 <generateFixedLitLenTree+0xa8>
    6a7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6a7f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6a86:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a89:	01 d0                	add    %edx,%eax
    6a8b:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    6a91:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6a95:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    6a9c:	76 de                	jbe    6a7c <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    6a9e:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    6aa5:	eb 19                	jmp    6ac0 <generateFixedLitLenTree+0xd3>
    6aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6aaa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6ab1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ab4:	01 d0                	add    %edx,%eax
    6ab6:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    6abc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6ac0:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    6ac7:	76 de                	jbe    6aa7 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    6ac9:	6a 0f                	push   $0xf
    6acb:	68 20 01 00 00       	push   $0x120
    6ad0:	ff 75 ec             	pushl  -0x14(%ebp)
    6ad3:	ff 75 08             	pushl  0x8(%ebp)
    6ad6:	e8 7f f5 ff ff       	call   605a <HuffmanTree_makeFromLengths>
    6adb:	83 c4 10             	add    $0x10,%esp
    6ade:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    6ae1:	83 ec 0c             	sub    $0xc,%esp
    6ae4:	ff 75 ec             	pushl  -0x14(%ebp)
    6ae7:	e8 4d df ff ff       	call   4a39 <lodepng_free>
    6aec:	83 c4 10             	add    $0x10,%esp
  return error;
    6aef:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6af2:	c9                   	leave  
    6af3:	c3                   	ret    

00006af4 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    6af4:	55                   	push   %ebp
    6af5:	89 e5                	mov    %esp,%ebp
    6af7:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    6afa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    6b01:	83 ec 0c             	sub    $0xc,%esp
    6b04:	68 80 00 00 00       	push   $0x80
    6b09:	e8 0a df ff ff       	call   4a18 <lodepng_malloc>
    6b0e:	83 c4 10             	add    $0x10,%esp
    6b11:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    6b14:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6b18:	75 07                	jne    6b21 <generateFixedDistanceTree+0x2d>
    6b1a:	b8 53 00 00 00       	mov    $0x53,%eax
    6b1f:	eb 4e                	jmp    6b6f <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    6b21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6b28:	eb 19                	jmp    6b43 <generateFixedDistanceTree+0x4f>
    6b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6b2d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6b34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6b37:	01 d0                	add    %edx,%eax
    6b39:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    6b3f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6b43:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    6b47:	75 e1                	jne    6b2a <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    6b49:	6a 0f                	push   $0xf
    6b4b:	6a 20                	push   $0x20
    6b4d:	ff 75 ec             	pushl  -0x14(%ebp)
    6b50:	ff 75 08             	pushl  0x8(%ebp)
    6b53:	e8 02 f5 ff ff       	call   605a <HuffmanTree_makeFromLengths>
    6b58:	83 c4 10             	add    $0x10,%esp
    6b5b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    6b5e:	83 ec 0c             	sub    $0xc,%esp
    6b61:	ff 75 ec             	pushl  -0x14(%ebp)
    6b64:	e8 d0 de ff ff       	call   4a39 <lodepng_free>
    6b69:	83 c4 10             	add    $0x10,%esp
  return error;
    6b6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6b6f:	c9                   	leave  
    6b70:	c3                   	ret    

00006b71 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    6b71:	55                   	push   %ebp
    6b72:	89 e5                	mov    %esp,%ebp
    6b74:	53                   	push   %ebx
    6b75:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    6b78:	6a 09                	push   $0x9
    6b7a:	ff 75 08             	pushl  0x8(%ebp)
    6b7d:	e8 d8 eb ff ff       	call   575a <peekBits>
    6b82:	83 c4 08             	add    $0x8,%esp
    6b85:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    6b89:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b8c:	8b 50 10             	mov    0x10(%eax),%edx
    6b8f:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    6b93:	01 d0                	add    %edx,%eax
    6b95:	0f b6 00             	movzbl (%eax),%eax
    6b98:	0f b6 c0             	movzbl %al,%eax
    6b9b:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    6b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ba2:	8b 40 14             	mov    0x14(%eax),%eax
    6ba5:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    6ba9:	01 d2                	add    %edx,%edx
    6bab:	01 d0                	add    %edx,%eax
    6bad:	0f b7 00             	movzwl (%eax),%eax
    6bb0:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    6bb4:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    6bb9:	77 16                	ja     6bd1 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    6bbb:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    6bbf:	50                   	push   %eax
    6bc0:	ff 75 08             	pushl  0x8(%ebp)
    6bc3:	e8 b2 eb ff ff       	call   577a <advanceBits>
    6bc8:	83 c4 08             	add    $0x8,%esp
    return value;
    6bcb:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    6bcf:	eb 5c                	jmp    6c2d <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    6bd1:	6a 09                	push   $0x9
    6bd3:	ff 75 08             	pushl  0x8(%ebp)
    6bd6:	e8 9f eb ff ff       	call   577a <advanceBits>
    6bdb:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    6bde:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    6be2:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    6be6:	83 e8 09             	sub    $0x9,%eax
    6be9:	50                   	push   %eax
    6bea:	ff 75 08             	pushl  0x8(%ebp)
    6bed:	e8 68 eb ff ff       	call   575a <peekBits>
    6bf2:	83 c4 08             	add    $0x8,%esp
    6bf5:	01 d8                	add    %ebx,%eax
    6bf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    6bfa:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bfd:	8b 50 10             	mov    0x10(%eax),%edx
    6c00:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c03:	01 d0                	add    %edx,%eax
    6c05:	0f b6 00             	movzbl (%eax),%eax
    6c08:	0f b6 c0             	movzbl %al,%eax
    6c0b:	83 e8 09             	sub    $0x9,%eax
    6c0e:	50                   	push   %eax
    6c0f:	ff 75 08             	pushl  0x8(%ebp)
    6c12:	e8 63 eb ff ff       	call   577a <advanceBits>
    6c17:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    6c1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6c1d:	8b 40 14             	mov    0x14(%eax),%eax
    6c20:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c23:	01 d2                	add    %edx,%edx
    6c25:	01 d0                	add    %edx,%eax
    6c27:	0f b7 00             	movzwl (%eax),%eax
    6c2a:	0f b7 c0             	movzwl %ax,%eax
  }
}
    6c2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6c30:	c9                   	leave  
    6c31:	c3                   	ret    

00006c32 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    6c32:	55                   	push   %ebp
    6c33:	89 e5                	mov    %esp,%ebp
    6c35:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    6c38:	83 ec 0c             	sub    $0xc,%esp
    6c3b:	ff 75 08             	pushl  0x8(%ebp)
    6c3e:	e8 aa fd ff ff       	call   69ed <generateFixedLitLenTree>
    6c43:	83 c4 10             	add    $0x10,%esp
    6c46:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    6c49:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6c4d:	74 05                	je     6c54 <getTreeInflateFixed+0x22>
    6c4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6c52:	eb 0e                	jmp    6c62 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    6c54:	83 ec 0c             	sub    $0xc,%esp
    6c57:	ff 75 0c             	pushl  0xc(%ebp)
    6c5a:	e8 95 fe ff ff       	call   6af4 <generateFixedDistanceTree>
    6c5f:	83 c4 10             	add    $0x10,%esp
}
    6c62:	c9                   	leave  
    6c63:	c3                   	ret    

00006c64 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    6c64:	55                   	push   %ebp
    6c65:	89 e5                	mov    %esp,%ebp
    6c67:	53                   	push   %ebx
    6c68:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    6c6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    6c72:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    6c79:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    6c80:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    6c87:	6a 0e                	push   $0xe
    6c89:	ff 75 10             	pushl  0x10(%ebp)
    6c8c:	e8 37 e6 ff ff       	call   52c8 <ensureBits17>
    6c91:	83 c4 08             	add    $0x8,%esp
    6c94:	85 c0                	test   %eax,%eax
    6c96:	75 0a                	jne    6ca2 <getTreeInflateDynamic+0x3e>
    6c98:	b8 31 00 00 00       	mov    $0x31,%eax
    6c9d:	e9 ec 04 00 00       	jmp    718e <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    6ca2:	6a 05                	push   $0x5
    6ca4:	ff 75 10             	pushl  0x10(%ebp)
    6ca7:	e8 f8 ea ff ff       	call   57a4 <readBits>
    6cac:	83 c4 08             	add    $0x8,%esp
    6caf:	05 01 01 00 00       	add    $0x101,%eax
    6cb4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    6cb7:	6a 05                	push   $0x5
    6cb9:	ff 75 10             	pushl  0x10(%ebp)
    6cbc:	e8 e3 ea ff ff       	call   57a4 <readBits>
    6cc1:	83 c4 08             	add    $0x8,%esp
    6cc4:	83 c0 01             	add    $0x1,%eax
    6cc7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    6cca:	6a 04                	push   $0x4
    6ccc:	ff 75 10             	pushl  0x10(%ebp)
    6ccf:	e8 d0 ea ff ff       	call   57a4 <readBits>
    6cd4:	83 c4 08             	add    $0x8,%esp
    6cd7:	83 c0 04             	add    $0x4,%eax
    6cda:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    6cdd:	83 ec 0c             	sub    $0xc,%esp
    6ce0:	6a 4c                	push   $0x4c
    6ce2:	e8 31 dd ff ff       	call   4a18 <lodepng_malloc>
    6ce7:	83 c4 10             	add    $0x10,%esp
    6cea:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    6ced:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    6cf1:	75 0a                	jne    6cfd <getTreeInflateDynamic+0x99>
    6cf3:	b8 53 00 00 00       	mov    $0x53,%eax
    6cf8:	e9 91 04 00 00       	jmp    718e <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    6cfd:	83 ec 0c             	sub    $0xc,%esp
    6d00:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6d03:	50                   	push   %eax
    6d04:	e8 03 ec ff ff       	call   590c <HuffmanTree_init>
    6d09:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    6d0c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6d10:	0f 85 3c 04 00 00    	jne    7152 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    6d16:	8b 45 10             	mov    0x10(%ebp),%eax
    6d19:	8b 48 08             	mov    0x8(%eax),%ecx
    6d1c:	8b 55 d0             	mov    -0x30(%ebp),%edx
    6d1f:	89 d0                	mov    %edx,%eax
    6d21:	01 c0                	add    %eax,%eax
    6d23:	01 d0                	add    %edx,%eax
    6d25:	89 c2                	mov    %eax,%edx
    6d27:	8b 45 10             	mov    0x10(%ebp),%eax
    6d2a:	8b 40 0c             	mov    0xc(%eax),%eax
    6d2d:	83 ec 04             	sub    $0x4,%esp
    6d30:	51                   	push   %ecx
    6d31:	52                   	push   %edx
    6d32:	50                   	push   %eax
    6d33:	e8 f7 dd ff ff       	call   4b2f <lodepng_gtofl>
    6d38:	83 c4 10             	add    $0x10,%esp
    6d3b:	85 c0                	test   %eax,%eax
    6d3d:	74 0c                	je     6d4b <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    6d3f:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    6d46:	e9 07 04 00 00       	jmp    7152 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    6d4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    6d52:	eb 3d                	jmp    6d91 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    6d54:	83 ec 08             	sub    $0x8,%esp
    6d57:	6a 03                	push   $0x3
    6d59:	ff 75 10             	pushl  0x10(%ebp)
    6d5c:	e8 8b e4 ff ff       	call   51ec <ensureBits9>
    6d61:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    6d64:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d67:	8b 04 85 20 b6 01 00 	mov    0x1b620(,%eax,4),%eax
    6d6e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6d75:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6d78:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    6d7b:	83 ec 08             	sub    $0x8,%esp
    6d7e:	6a 03                	push   $0x3
    6d80:	ff 75 10             	pushl  0x10(%ebp)
    6d83:	e8 1c ea ff ff       	call   57a4 <readBits>
    6d88:	83 c4 10             	add    $0x10,%esp
    6d8b:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    6d8d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6d91:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d94:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    6d97:	75 bb                	jne    6d54 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    6d99:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6d9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6d9f:	eb 20                	jmp    6dc1 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    6da1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6da4:	8b 04 85 20 b6 01 00 	mov    0x1b620(,%eax,4),%eax
    6dab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6db2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6db5:	01 d0                	add    %edx,%eax
    6db7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    6dbd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6dc1:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    6dc5:	75 da                	jne    6da1 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    6dc7:	6a 07                	push   $0x7
    6dc9:	6a 13                	push   $0x13
    6dcb:	ff 75 dc             	pushl  -0x24(%ebp)
    6dce:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6dd1:	50                   	push   %eax
    6dd2:	e8 83 f2 ff ff       	call   605a <HuffmanTree_makeFromLengths>
    6dd7:	83 c4 10             	add    $0x10,%esp
    6dda:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    6ddd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6de1:	0f 85 64 03 00 00    	jne    714b <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    6de7:	83 ec 0c             	sub    $0xc,%esp
    6dea:	68 80 04 00 00       	push   $0x480
    6def:	e8 24 dc ff ff       	call   4a18 <lodepng_malloc>
    6df4:	83 c4 10             	add    $0x10,%esp
    6df7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    6dfa:	83 ec 0c             	sub    $0xc,%esp
    6dfd:	68 80 00 00 00       	push   $0x80
    6e02:	e8 11 dc ff ff       	call   4a18 <lodepng_malloc>
    6e07:	83 c4 10             	add    $0x10,%esp
    6e0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    6e0d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6e11:	74 06                	je     6e19 <getTreeInflateDynamic+0x1b5>
    6e13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6e17:	75 0c                	jne    6e25 <getTreeInflateDynamic+0x1c1>
    6e19:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6e20:	e9 2d 03 00 00       	jmp    7152 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    6e25:	83 ec 04             	sub    $0x4,%esp
    6e28:	68 80 04 00 00       	push   $0x480
    6e2d:	6a 00                	push   $0x0
    6e2f:	ff 75 e8             	pushl  -0x18(%ebp)
    6e32:	e8 52 dc ff ff       	call   4a89 <lodepng_memset>
    6e37:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    6e3a:	83 ec 04             	sub    $0x4,%esp
    6e3d:	68 80 00 00 00       	push   $0x80
    6e42:	6a 00                	push   $0x0
    6e44:	ff 75 e4             	pushl  -0x1c(%ebp)
    6e47:	e8 3d dc ff ff       	call   4a89 <lodepng_memset>
    6e4c:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    6e4f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    6e56:	e9 8d 02 00 00       	jmp    70e8 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    6e5b:	83 ec 08             	sub    $0x8,%esp
    6e5e:	6a 16                	push   $0x16
    6e60:	ff 75 10             	pushl  0x10(%ebp)
    6e63:	e8 8c e5 ff ff       	call   53f4 <ensureBits25>
    6e68:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    6e6b:	83 ec 08             	sub    $0x8,%esp
    6e6e:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6e71:	50                   	push   %eax
    6e72:	ff 75 10             	pushl  0x10(%ebp)
    6e75:	e8 f7 fc ff ff       	call   6b71 <huffmanDecodeSymbol>
    6e7a:	83 c4 10             	add    $0x10,%esp
    6e7d:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    6e80:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    6e84:	77 3e                	ja     6ec4 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    6e86:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6e89:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6e8c:	73 16                	jae    6ea4 <getTreeInflateDynamic+0x240>
    6e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6e91:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6e98:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e9b:	01 c2                	add    %eax,%edx
    6e9d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    6ea0:	89 02                	mov    %eax,(%edx)
    6ea2:	eb 17                	jmp    6ebb <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    6ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ea7:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6eaa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6eb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6eb4:	01 c2                	add    %eax,%edx
    6eb6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    6eb9:	89 02                	mov    %eax,(%edx)
        ++i;
    6ebb:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6ebf:	e9 0b 02 00 00       	jmp    70cf <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    6ec4:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    6ec8:	0f 85 da 00 00 00    	jne    6fa8 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    6ece:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    6ed5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6ed9:	75 0c                	jne    6ee7 <getTreeInflateDynamic+0x283>
    6edb:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    6ee2:	e9 12 02 00 00       	jmp    70f9 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    6ee7:	83 ec 08             	sub    $0x8,%esp
    6eea:	6a 02                	push   $0x2
    6eec:	ff 75 10             	pushl  0x10(%ebp)
    6eef:	e8 b0 e8 ff ff       	call   57a4 <readBits>
    6ef4:	83 c4 10             	add    $0x10,%esp
    6ef7:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    6efa:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6efd:	83 c0 01             	add    $0x1,%eax
    6f00:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6f03:	76 1b                	jbe    6f20 <getTreeInflateDynamic+0x2bc>
    6f05:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f08:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    6f0d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6f14:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6f17:	01 d0                	add    %edx,%eax
    6f19:	8b 00                	mov    (%eax),%eax
    6f1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    6f1e:	eb 1c                	jmp    6f3c <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    6f20:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f23:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6f26:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    6f2b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6f32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6f35:	01 d0                	add    %edx,%eax
    6f37:	8b 00                	mov    (%eax),%eax
    6f39:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6f3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6f43:	eb 56                	jmp    6f9b <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    6f45:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6f48:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6f4b:	01 d0                	add    %edx,%eax
    6f4d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6f50:	77 0c                	ja     6f5e <getTreeInflateDynamic+0x2fa>
    6f52:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    6f59:	e9 71 01 00 00       	jmp    70cf <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    6f5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f61:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6f64:	73 16                	jae    6f7c <getTreeInflateDynamic+0x318>
    6f66:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f69:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6f70:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6f73:	01 c2                	add    %eax,%edx
    6f75:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f78:	89 02                	mov    %eax,(%edx)
    6f7a:	eb 17                	jmp    6f93 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    6f7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f7f:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6f82:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6f89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6f8c:	01 c2                	add    %eax,%edx
    6f8e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f91:	89 02                	mov    %eax,(%edx)
          ++i;
    6f93:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6f97:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6f9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f9e:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6fa1:	72 a2                	jb     6f45 <getTreeInflateDynamic+0x2e1>
    6fa3:	e9 27 01 00 00       	jmp    70cf <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    6fa8:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    6fac:	0f 85 88 00 00 00    	jne    703a <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    6fb2:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    6fb9:	83 ec 08             	sub    $0x8,%esp
    6fbc:	6a 03                	push   $0x3
    6fbe:	ff 75 10             	pushl  0x10(%ebp)
    6fc1:	e8 de e7 ff ff       	call   57a4 <readBits>
    6fc6:	83 c4 10             	add    $0x10,%esp
    6fc9:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6fcc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6fd3:	eb 58                	jmp    702d <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    6fd5:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6fd8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6fdb:	01 d0                	add    %edx,%eax
    6fdd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6fe0:	77 0c                	ja     6fee <getTreeInflateDynamic+0x38a>
    6fe2:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    6fe9:	e9 e1 00 00 00       	jmp    70cf <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    6fee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ff1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6ff4:	73 17                	jae    700d <getTreeInflateDynamic+0x3a9>
    6ff6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ff9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7000:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7003:	01 d0                	add    %edx,%eax
    7005:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    700b:	eb 18                	jmp    7025 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    700d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7010:	2b 45 d8             	sub    -0x28(%ebp),%eax
    7013:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    701a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    701d:	01 d0                	add    %edx,%eax
    701f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    7025:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    7029:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    702d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7030:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    7033:	72 a0                	jb     6fd5 <getTreeInflateDynamic+0x371>
    7035:	e9 95 00 00 00       	jmp    70cf <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    703a:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    703e:	0f 85 82 00 00 00    	jne    70c6 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    7044:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    704b:	83 ec 08             	sub    $0x8,%esp
    704e:	6a 07                	push   $0x7
    7050:	ff 75 10             	pushl  0x10(%ebp)
    7053:	e8 4c e7 ff ff       	call   57a4 <readBits>
    7058:	83 c4 10             	add    $0x10,%esp
    705b:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    705e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7065:	eb 55                	jmp    70bc <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    7067:	8b 55 d8             	mov    -0x28(%ebp),%edx
    706a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    706d:	01 d0                	add    %edx,%eax
    706f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    7072:	77 09                	ja     707d <getTreeInflateDynamic+0x419>
    7074:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    707b:	eb 52                	jmp    70cf <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    707d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7080:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    7083:	73 17                	jae    709c <getTreeInflateDynamic+0x438>
    7085:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7088:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    708f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7092:	01 d0                	add    %edx,%eax
    7094:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    709a:	eb 18                	jmp    70b4 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    709c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    709f:	2b 45 d8             	sub    -0x28(%ebp),%eax
    70a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    70a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    70ac:	01 d0                	add    %edx,%eax
    70ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    70b4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    70b8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    70bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    70bf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    70c2:	72 a3                	jb     7067 <getTreeInflateDynamic+0x403>
    70c4:	eb 09                	jmp    70cf <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    70c6:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    70cd:	eb 2a                	jmp    70f9 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    70cf:	8b 45 10             	mov    0x10(%ebp),%eax
    70d2:	8b 50 0c             	mov    0xc(%eax),%edx
    70d5:	8b 45 10             	mov    0x10(%ebp),%eax
    70d8:	8b 40 08             	mov    0x8(%eax),%eax
    70db:	39 c2                	cmp    %eax,%edx
    70dd:	7e 09                	jle    70e8 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    70df:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    70e6:	eb 11                	jmp    70f9 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    70e8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    70eb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    70ee:	01 d0                	add    %edx,%eax
    70f0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    70f3:	0f 87 62 fd ff ff    	ja     6e5b <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    70f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    70fd:	75 4f                	jne    714e <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    70ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7102:	05 00 04 00 00       	add    $0x400,%eax
    7107:	8b 00                	mov    (%eax),%eax
    7109:	85 c0                	test   %eax,%eax
    710b:	75 09                	jne    7116 <getTreeInflateDynamic+0x4b2>
    710d:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7114:	eb 3c                	jmp    7152 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    7116:	6a 0f                	push   $0xf
    7118:	68 20 01 00 00       	push   $0x120
    711d:	ff 75 e8             	pushl  -0x18(%ebp)
    7120:	ff 75 08             	pushl  0x8(%ebp)
    7123:	e8 32 ef ff ff       	call   605a <HuffmanTree_makeFromLengths>
    7128:	83 c4 10             	add    $0x10,%esp
    712b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    712e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7132:	75 1d                	jne    7151 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    7134:	6a 0f                	push   $0xf
    7136:	6a 20                	push   $0x20
    7138:	ff 75 e4             	pushl  -0x1c(%ebp)
    713b:	ff 75 0c             	pushl  0xc(%ebp)
    713e:	e8 17 ef ff ff       	call   605a <HuffmanTree_makeFromLengths>
    7143:	83 c4 10             	add    $0x10,%esp
    7146:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    7149:	eb 07                	jmp    7152 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    714b:	90                   	nop
    714c:	eb 04                	jmp    7152 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    714e:	90                   	nop
    714f:	eb 01                	jmp    7152 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    7151:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    7152:	83 ec 0c             	sub    $0xc,%esp
    7155:	ff 75 dc             	pushl  -0x24(%ebp)
    7158:	e8 dc d8 ff ff       	call   4a39 <lodepng_free>
    715d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    7160:	83 ec 0c             	sub    $0xc,%esp
    7163:	ff 75 e8             	pushl  -0x18(%ebp)
    7166:	e8 ce d8 ff ff       	call   4a39 <lodepng_free>
    716b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    716e:	83 ec 0c             	sub    $0xc,%esp
    7171:	ff 75 e4             	pushl  -0x1c(%ebp)
    7174:	e8 c0 d8 ff ff       	call   4a39 <lodepng_free>
    7179:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    717c:	83 ec 0c             	sub    $0xc,%esp
    717f:	8d 45 a8             	lea    -0x58(%ebp),%eax
    7182:	50                   	push   %eax
    7183:	e8 b1 e7 ff ff       	call   5939 <HuffmanTree_cleanup>
    7188:	83 c4 10             	add    $0x10,%esp

  return error;
    718b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    718e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7191:	c9                   	leave  
    7192:	c3                   	ret    

00007193 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    7193:	55                   	push   %ebp
    7194:	89 e5                	mov    %esp,%ebp
    7196:	53                   	push   %ebx
    7197:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    719a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    71a1:	8d 45 b8             	lea    -0x48(%ebp),%eax
    71a4:	50                   	push   %eax
    71a5:	e8 62 e7 ff ff       	call   590c <HuffmanTree_init>
    71aa:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    71ad:	8d 45 a0             	lea    -0x60(%ebp),%eax
    71b0:	50                   	push   %eax
    71b1:	e8 56 e7 ff ff       	call   590c <HuffmanTree_init>
    71b6:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    71b9:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    71bd:	75 1b                	jne    71da <inflateHuffmanBlock+0x47>
    71bf:	83 ec 08             	sub    $0x8,%esp
    71c2:	8d 45 a0             	lea    -0x60(%ebp),%eax
    71c5:	50                   	push   %eax
    71c6:	8d 45 b8             	lea    -0x48(%ebp),%eax
    71c9:	50                   	push   %eax
    71ca:	e8 63 fa ff ff       	call   6c32 <getTreeInflateFixed>
    71cf:	83 c4 10             	add    $0x10,%esp
    71d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    71d5:	e9 9a 02 00 00       	jmp    7474 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    71da:	83 ec 04             	sub    $0x4,%esp
    71dd:	ff 75 0c             	pushl  0xc(%ebp)
    71e0:	8d 45 a0             	lea    -0x60(%ebp),%eax
    71e3:	50                   	push   %eax
    71e4:	8d 45 b8             	lea    -0x48(%ebp),%eax
    71e7:	50                   	push   %eax
    71e8:	e8 77 fa ff ff       	call   6c64 <getTreeInflateDynamic>
    71ed:	83 c4 10             	add    $0x10,%esp
    71f0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    71f3:	e9 7c 02 00 00       	jmp    7474 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    71f8:	83 ec 08             	sub    $0x8,%esp
    71fb:	6a 14                	push   $0x14
    71fd:	ff 75 0c             	pushl  0xc(%ebp)
    7200:	e8 ef e1 ff ff       	call   53f4 <ensureBits25>
    7205:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    7208:	83 ec 08             	sub    $0x8,%esp
    720b:	8d 45 b8             	lea    -0x48(%ebp),%eax
    720e:	50                   	push   %eax
    720f:	ff 75 0c             	pushl  0xc(%ebp)
    7212:	e8 5a f9 ff ff       	call   6b71 <huffmanDecodeSymbol>
    7217:	83 c4 10             	add    $0x10,%esp
    721a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    721d:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    7224:	77 42                	ja     7268 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    7226:	8b 45 08             	mov    0x8(%ebp),%eax
    7229:	8b 40 04             	mov    0x4(%eax),%eax
    722c:	83 c0 01             	add    $0x1,%eax
    722f:	83 ec 08             	sub    $0x8,%esp
    7232:	50                   	push   %eax
    7233:	ff 75 08             	pushl  0x8(%ebp)
    7236:	e8 37 da ff ff       	call   4c72 <ucvector_resize>
    723b:	83 c4 10             	add    $0x10,%esp
    723e:	85 c0                	test   %eax,%eax
    7240:	75 0c                	jne    724e <inflateHuffmanBlock+0xbb>
    7242:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7249:	e9 33 02 00 00       	jmp    7481 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    724e:	8b 45 08             	mov    0x8(%ebp),%eax
    7251:	8b 10                	mov    (%eax),%edx
    7253:	8b 45 08             	mov    0x8(%ebp),%eax
    7256:	8b 40 04             	mov    0x4(%eax),%eax
    7259:	83 e8 01             	sub    $0x1,%eax
    725c:	01 d0                	add    %edx,%eax
    725e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7261:	88 10                	mov    %dl,(%eax)
    7263:	e9 d9 01 00 00       	jmp    7441 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    7268:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    726f:	0f 86 ba 01 00 00    	jbe    742f <inflateHuffmanBlock+0x29c>
    7275:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    727c:	0f 87 ad 01 00 00    	ja     742f <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    7282:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7285:	2d 01 01 00 00       	sub    $0x101,%eax
    728a:	8b 04 85 20 b4 01 00 	mov    0x1b420(,%eax,4),%eax
    7291:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    7294:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7297:	2d 01 01 00 00       	sub    $0x101,%eax
    729c:	8b 04 85 a0 b4 01 00 	mov    0x1b4a0(,%eax,4),%eax
    72a3:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    72a6:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    72aa:	74 1c                	je     72c8 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    72ac:	8b 45 d8             	mov    -0x28(%ebp),%eax
    72af:	83 ec 08             	sub    $0x8,%esp
    72b2:	50                   	push   %eax
    72b3:	ff 75 0c             	pushl  0xc(%ebp)
    72b6:	e8 e9 e4 ff ff       	call   57a4 <readBits>
    72bb:	83 c4 10             	add    $0x10,%esp
    72be:	89 c2                	mov    %eax,%edx
    72c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72c3:	01 d0                	add    %edx,%eax
    72c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    72c8:	83 ec 08             	sub    $0x8,%esp
    72cb:	6a 1c                	push   $0x1c
    72cd:	ff 75 0c             	pushl  0xc(%ebp)
    72d0:	e8 98 e2 ff ff       	call   556d <ensureBits32>
    72d5:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    72d8:	83 ec 08             	sub    $0x8,%esp
    72db:	8d 45 a0             	lea    -0x60(%ebp),%eax
    72de:	50                   	push   %eax
    72df:	ff 75 0c             	pushl  0xc(%ebp)
    72e2:	e8 8a f8 ff ff       	call   6b71 <huffmanDecodeSymbol>
    72e7:	83 c4 10             	add    $0x10,%esp
    72ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    72ed:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    72f1:	76 1e                	jbe    7311 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    72f3:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    72f7:	77 0c                	ja     7305 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    72f9:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    7300:	e9 7c 01 00 00       	jmp    7481 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    7305:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    730c:	e9 70 01 00 00       	jmp    7481 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    7311:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7314:	8b 04 85 20 b5 01 00 	mov    0x1b520(,%eax,4),%eax
    731b:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    731e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7321:	8b 04 85 a0 b5 01 00 	mov    0x1b5a0(,%eax,4),%eax
    7328:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    732b:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    732f:	74 15                	je     7346 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    7331:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7334:	83 ec 08             	sub    $0x8,%esp
    7337:	50                   	push   %eax
    7338:	ff 75 0c             	pushl  0xc(%ebp)
    733b:	e8 64 e4 ff ff       	call   57a4 <readBits>
    7340:	83 c4 10             	add    $0x10,%esp
    7343:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    7346:	8b 45 08             	mov    0x8(%ebp),%eax
    7349:	8b 40 04             	mov    0x4(%eax),%eax
    734c:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    734f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7352:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    7355:	76 0c                	jbe    7363 <inflateHuffmanBlock+0x1d0>
    7357:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    735e:	e9 1e 01 00 00       	jmp    7481 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    7363:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7366:	2b 45 f0             	sub    -0x10(%ebp),%eax
    7369:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    736c:	8b 45 08             	mov    0x8(%ebp),%eax
    736f:	8b 50 04             	mov    0x4(%eax),%edx
    7372:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7375:	01 d0                	add    %edx,%eax
    7377:	83 ec 08             	sub    $0x8,%esp
    737a:	50                   	push   %eax
    737b:	ff 75 08             	pushl  0x8(%ebp)
    737e:	e8 ef d8 ff ff       	call   4c72 <ucvector_resize>
    7383:	83 c4 10             	add    $0x10,%esp
    7386:	85 c0                	test   %eax,%eax
    7388:	75 0c                	jne    7396 <inflateHuffmanBlock+0x203>
    738a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7391:	e9 eb 00 00 00       	jmp    7481 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    7396:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7399:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    739c:	73 6b                	jae    7409 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    739e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73a1:	8b 55 08             	mov    0x8(%ebp),%edx
    73a4:	8b 0a                	mov    (%edx),%ecx
    73a6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73a9:	01 d1                	add    %edx,%ecx
    73ab:	8b 55 08             	mov    0x8(%ebp),%edx
    73ae:	8b 1a                	mov    (%edx),%ebx
    73b0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    73b3:	01 da                	add    %ebx,%edx
    73b5:	83 ec 04             	sub    $0x4,%esp
    73b8:	50                   	push   %eax
    73b9:	51                   	push   %ecx
    73ba:	52                   	push   %edx
    73bb:	e8 96 d6 ff ff       	call   4a56 <lodepng_memcpy>
    73c0:	83 c4 10             	add    $0x10,%esp
        start += distance;
    73c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    73c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73c9:	01 d0                	add    %edx,%eax
    73cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    73ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    73d4:	eb 29                	jmp    73ff <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    73d6:	8b 45 08             	mov    0x8(%ebp),%eax
    73d9:	8b 08                	mov    (%eax),%ecx
    73db:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73de:	8d 50 01             	lea    0x1(%eax),%edx
    73e1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    73e4:	01 c1                	add    %eax,%ecx
    73e6:	8b 45 08             	mov    0x8(%ebp),%eax
    73e9:	8b 18                	mov    (%eax),%ebx
    73eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73ee:	8d 50 01             	lea    0x1(%eax),%edx
    73f1:	89 55 e8             	mov    %edx,-0x18(%ebp)
    73f4:	01 d8                	add    %ebx,%eax
    73f6:	0f b6 00             	movzbl (%eax),%eax
    73f9:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    73fb:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    73ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7402:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7405:	7c cf                	jl     73d6 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    7407:	eb 38                	jmp    7441 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    7409:	8b 45 08             	mov    0x8(%ebp),%eax
    740c:	8b 10                	mov    (%eax),%edx
    740e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7411:	01 c2                	add    %eax,%edx
    7413:	8b 45 08             	mov    0x8(%ebp),%eax
    7416:	8b 08                	mov    (%eax),%ecx
    7418:	8b 45 ec             	mov    -0x14(%ebp),%eax
    741b:	01 c8                	add    %ecx,%eax
    741d:	83 ec 04             	sub    $0x4,%esp
    7420:	ff 75 e4             	pushl  -0x1c(%ebp)
    7423:	52                   	push   %edx
    7424:	50                   	push   %eax
    7425:	e8 2c d6 ff ff       	call   4a56 <lodepng_memcpy>
    742a:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    742d:	eb 12                	jmp    7441 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    742f:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    7436:	74 48                	je     7480 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    7438:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    743f:	eb 40                	jmp    7481 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    7441:	8b 45 0c             	mov    0xc(%ebp),%eax
    7444:	8b 50 0c             	mov    0xc(%eax),%edx
    7447:	8b 45 0c             	mov    0xc(%ebp),%eax
    744a:	8b 40 08             	mov    0x8(%eax),%eax
    744d:	39 c2                	cmp    %eax,%edx
    744f:	7e 09                	jle    745a <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    7451:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    7458:	eb 27                	jmp    7481 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    745a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    745e:	74 14                	je     7474 <inflateHuffmanBlock+0x2e1>
    7460:	8b 45 08             	mov    0x8(%ebp),%eax
    7463:	8b 40 04             	mov    0x4(%eax),%eax
    7466:	3b 45 14             	cmp    0x14(%ebp),%eax
    7469:	7e 09                	jle    7474 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    746b:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7472:	eb 0d                	jmp    7481 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    7474:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7478:	0f 84 7a fd ff ff    	je     71f8 <inflateHuffmanBlock+0x65>
    747e:	eb 01                	jmp    7481 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    7480:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    7481:	83 ec 0c             	sub    $0xc,%esp
    7484:	8d 45 b8             	lea    -0x48(%ebp),%eax
    7487:	50                   	push   %eax
    7488:	e8 ac e4 ff ff       	call   5939 <HuffmanTree_cleanup>
    748d:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7490:	83 ec 0c             	sub    $0xc,%esp
    7493:	8d 45 a0             	lea    -0x60(%ebp),%eax
    7496:	50                   	push   %eax
    7497:	e8 9d e4 ff ff       	call   5939 <HuffmanTree_cleanup>
    749c:	83 c4 10             	add    $0x10,%esp

  return error;
    749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    74a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    74a5:	c9                   	leave  
    74a6:	c3                   	ret    

000074a7 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    74a7:	55                   	push   %ebp
    74a8:	89 e5                	mov    %esp,%ebp
    74aa:	53                   	push   %ebx
    74ab:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    74ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    74b1:	8b 40 04             	mov    0x4(%eax),%eax
    74b4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    74b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    74be:	8b 45 0c             	mov    0xc(%ebp),%eax
    74c1:	8b 40 0c             	mov    0xc(%eax),%eax
    74c4:	83 c0 07             	add    $0x7,%eax
    74c7:	c1 e8 03             	shr    $0x3,%eax
    74ca:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    74cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74d0:	83 c0 04             	add    $0x4,%eax
    74d3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    74d6:	7c 0a                	jl     74e2 <inflateNoCompression+0x3b>
    74d8:	b8 34 00 00 00       	mov    $0x34,%eax
    74dd:	e9 01 01 00 00       	jmp    75e3 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    74e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    74e5:	8b 10                	mov    (%eax),%edx
    74e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74ea:	01 d0                	add    %edx,%eax
    74ec:	0f b6 00             	movzbl (%eax),%eax
    74ef:	0f b6 d0             	movzbl %al,%edx
    74f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    74f5:	8b 00                	mov    (%eax),%eax
    74f7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    74fa:	83 c1 01             	add    $0x1,%ecx
    74fd:	01 c8                	add    %ecx,%eax
    74ff:	0f b6 00             	movzbl (%eax),%eax
    7502:	0f b6 c0             	movzbl %al,%eax
    7505:	c1 e0 08             	shl    $0x8,%eax
    7508:	01 d0                	add    %edx,%eax
    750a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    750d:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    7511:	8b 45 0c             	mov    0xc(%ebp),%eax
    7514:	8b 10                	mov    (%eax),%edx
    7516:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7519:	01 d0                	add    %edx,%eax
    751b:	0f b6 00             	movzbl (%eax),%eax
    751e:	0f b6 d0             	movzbl %al,%edx
    7521:	8b 45 0c             	mov    0xc(%ebp),%eax
    7524:	8b 00                	mov    (%eax),%eax
    7526:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7529:	83 c1 01             	add    $0x1,%ecx
    752c:	01 c8                	add    %ecx,%eax
    752e:	0f b6 00             	movzbl (%eax),%eax
    7531:	0f b6 c0             	movzbl %al,%eax
    7534:	c1 e0 08             	shl    $0x8,%eax
    7537:	01 d0                	add    %edx,%eax
    7539:	89 45 e8             	mov    %eax,-0x18(%ebp)
    753c:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    7540:	8b 45 10             	mov    0x10(%ebp),%eax
    7543:	8b 40 04             	mov    0x4(%eax),%eax
    7546:	85 c0                	test   %eax,%eax
    7548:	75 19                	jne    7563 <inflateNoCompression+0xbc>
    754a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    754d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7550:	01 d0                	add    %edx,%eax
    7552:	3d ff ff 00 00       	cmp    $0xffff,%eax
    7557:	74 0a                	je     7563 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    7559:	b8 15 00 00 00       	mov    $0x15,%eax
    755e:	e9 80 00 00 00       	jmp    75e3 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    7563:	8b 45 08             	mov    0x8(%ebp),%eax
    7566:	8b 40 04             	mov    0x4(%eax),%eax
    7569:	89 c2                	mov    %eax,%edx
    756b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    756e:	01 d0                	add    %edx,%eax
    7570:	50                   	push   %eax
    7571:	ff 75 08             	pushl  0x8(%ebp)
    7574:	e8 f9 d6 ff ff       	call   4c72 <ucvector_resize>
    7579:	83 c4 08             	add    $0x8,%esp
    757c:	85 c0                	test   %eax,%eax
    757e:	75 07                	jne    7587 <inflateNoCompression+0xe0>
    7580:	b8 53 00 00 00       	mov    $0x53,%eax
    7585:	eb 5c                	jmp    75e3 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    7587:	8b 55 f0             	mov    -0x10(%ebp),%edx
    758a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    758d:	01 c2                	add    %eax,%edx
    758f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7592:	39 c2                	cmp    %eax,%edx
    7594:	76 07                	jbe    759d <inflateNoCompression+0xf6>
    7596:	b8 17 00 00 00       	mov    $0x17,%eax
    759b:	eb 46                	jmp    75e3 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    759d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75a0:	8b 55 0c             	mov    0xc(%ebp),%edx
    75a3:	8b 0a                	mov    (%edx),%ecx
    75a5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    75a8:	01 d1                	add    %edx,%ecx
    75aa:	8b 55 08             	mov    0x8(%ebp),%edx
    75ad:	8b 1a                	mov    (%edx),%ebx
    75af:	8b 55 08             	mov    0x8(%ebp),%edx
    75b2:	8b 52 04             	mov    0x4(%edx),%edx
    75b5:	2b 55 ec             	sub    -0x14(%ebp),%edx
    75b8:	01 da                	add    %ebx,%edx
    75ba:	50                   	push   %eax
    75bb:	51                   	push   %ecx
    75bc:	52                   	push   %edx
    75bd:	e8 94 d4 ff ff       	call   4a56 <lodepng_memcpy>
    75c2:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    75c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    75c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75cb:	01 d0                	add    %edx,%eax
    75cd:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    75d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    75d3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    75da:	8b 45 0c             	mov    0xc(%ebp),%eax
    75dd:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    75e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    75e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    75e6:	c9                   	leave  
    75e7:	c3                   	ret    

000075e8 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    75e8:	55                   	push   %ebp
    75e9:	89 e5                	mov    %esp,%ebp
    75eb:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    75ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    75f5:	ff 75 10             	pushl  0x10(%ebp)
    75f8:	ff 75 0c             	pushl  0xc(%ebp)
    75fb:	8d 45 d8             	lea    -0x28(%ebp),%eax
    75fe:	50                   	push   %eax
    75ff:	e8 77 db ff ff       	call   517b <LodePNGBitReader_init>
    7604:	83 c4 0c             	add    $0xc,%esp
    7607:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    760a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    760e:	0f 84 b9 00 00 00    	je     76cd <lodepng_inflatev+0xe5>
    7614:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7617:	e9 c1 00 00 00       	jmp    76dd <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    761c:	6a 03                	push   $0x3
    761e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7621:	50                   	push   %eax
    7622:	e8 c5 db ff ff       	call   51ec <ensureBits9>
    7627:	83 c4 08             	add    $0x8,%esp
    762a:	85 c0                	test   %eax,%eax
    762c:	75 0a                	jne    7638 <lodepng_inflatev+0x50>
    762e:	b8 34 00 00 00       	mov    $0x34,%eax
    7633:	e9 a5 00 00 00       	jmp    76dd <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    7638:	6a 01                	push   $0x1
    763a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    763d:	50                   	push   %eax
    763e:	e8 61 e1 ff ff       	call   57a4 <readBits>
    7643:	83 c4 08             	add    $0x8,%esp
    7646:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    7649:	6a 02                	push   $0x2
    764b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    764e:	50                   	push   %eax
    764f:	e8 50 e1 ff ff       	call   57a4 <readBits>
    7654:	83 c4 08             	add    $0x8,%esp
    7657:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    765a:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    765e:	75 07                	jne    7667 <lodepng_inflatev+0x7f>
    7660:	b8 14 00 00 00       	mov    $0x14,%eax
    7665:	eb 76                	jmp    76dd <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    7667:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    766b:	75 17                	jne    7684 <lodepng_inflatev+0x9c>
    766d:	ff 75 14             	pushl  0x14(%ebp)
    7670:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7673:	50                   	push   %eax
    7674:	ff 75 08             	pushl  0x8(%ebp)
    7677:	e8 2b fe ff ff       	call   74a7 <inflateNoCompression>
    767c:	83 c4 0c             	add    $0xc,%esp
    767f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7682:	eb 1c                	jmp    76a0 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    7684:	8b 45 14             	mov    0x14(%ebp),%eax
    7687:	8b 40 08             	mov    0x8(%eax),%eax
    768a:	50                   	push   %eax
    768b:	ff 75 ec             	pushl  -0x14(%ebp)
    768e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7691:	50                   	push   %eax
    7692:	ff 75 08             	pushl  0x8(%ebp)
    7695:	e8 f9 fa ff ff       	call   7193 <inflateHuffmanBlock>
    769a:	83 c4 10             	add    $0x10,%esp
    769d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    76a0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    76a4:	75 21                	jne    76c7 <lodepng_inflatev+0xdf>
    76a6:	8b 45 14             	mov    0x14(%ebp),%eax
    76a9:	8b 40 08             	mov    0x8(%eax),%eax
    76ac:	85 c0                	test   %eax,%eax
    76ae:	74 17                	je     76c7 <lodepng_inflatev+0xdf>
    76b0:	8b 45 08             	mov    0x8(%ebp),%eax
    76b3:	8b 50 04             	mov    0x4(%eax),%edx
    76b6:	8b 45 14             	mov    0x14(%ebp),%eax
    76b9:	8b 40 08             	mov    0x8(%eax),%eax
    76bc:	39 c2                	cmp    %eax,%edx
    76be:	7e 07                	jle    76c7 <lodepng_inflatev+0xdf>
    76c0:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    76c7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    76cb:	75 0c                	jne    76d9 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    76cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    76d1:	0f 84 45 ff ff ff    	je     761c <lodepng_inflatev+0x34>
    76d7:	eb 01                	jmp    76da <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    76d9:	90                   	nop
  }

  return error;
    76da:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    76dd:	c9                   	leave  
    76de:	c3                   	ret    

000076df <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    76df:	55                   	push   %ebp
    76e0:	89 e5                	mov    %esp,%ebp
    76e2:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    76e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    76e8:	8b 08                	mov    (%eax),%ecx
    76ea:	8b 45 08             	mov    0x8(%ebp),%eax
    76ed:	8b 10                	mov    (%eax),%edx
    76ef:	8d 45 e8             	lea    -0x18(%ebp),%eax
    76f2:	51                   	push   %ecx
    76f3:	52                   	push   %edx
    76f4:	50                   	push   %eax
    76f5:	e8 df d5 ff ff       	call   4cd9 <ucvector_init>
    76fa:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    76fd:	ff 75 18             	pushl  0x18(%ebp)
    7700:	ff 75 14             	pushl  0x14(%ebp)
    7703:	ff 75 10             	pushl  0x10(%ebp)
    7706:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7709:	50                   	push   %eax
    770a:	e8 d9 fe ff ff       	call   75e8 <lodepng_inflatev>
    770f:	83 c4 10             	add    $0x10,%esp
    7712:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7715:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7718:	8b 45 08             	mov    0x8(%ebp),%eax
    771b:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    771d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7720:	8b 45 0c             	mov    0xc(%ebp),%eax
    7723:	89 10                	mov    %edx,(%eax)
  return error;
    7725:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7728:	c9                   	leave  
    7729:	c3                   	ret    

0000772a <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    772a:	55                   	push   %ebp
    772b:	89 e5                	mov    %esp,%ebp
    772d:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    7730:	8b 45 14             	mov    0x14(%ebp),%eax
    7733:	8b 40 10             	mov    0x10(%eax),%eax
    7736:	85 c0                	test   %eax,%eax
    7738:	74 64                	je     779e <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    773a:	8b 45 14             	mov    0x14(%ebp),%eax
    773d:	8b 40 10             	mov    0x10(%eax),%eax
    7740:	8b 55 08             	mov    0x8(%ebp),%edx
    7743:	8d 4a 04             	lea    0x4(%edx),%ecx
    7746:	8b 55 08             	mov    0x8(%ebp),%edx
    7749:	83 ec 0c             	sub    $0xc,%esp
    774c:	ff 75 14             	pushl  0x14(%ebp)
    774f:	ff 75 10             	pushl  0x10(%ebp)
    7752:	ff 75 0c             	pushl  0xc(%ebp)
    7755:	51                   	push   %ecx
    7756:	52                   	push   %edx
    7757:	ff d0                	call   *%eax
    7759:	83 c4 20             	add    $0x20,%esp
    775c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    775f:	8b 45 08             	mov    0x8(%ebp),%eax
    7762:	8b 50 04             	mov    0x4(%eax),%edx
    7765:	8b 45 08             	mov    0x8(%ebp),%eax
    7768:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    776b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    776f:	74 28                	je     7799 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7771:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    7778:	8b 45 14             	mov    0x14(%ebp),%eax
    777b:	8b 40 08             	mov    0x8(%eax),%eax
    777e:	85 c0                	test   %eax,%eax
    7780:	74 17                	je     7799 <inflatev+0x6f>
    7782:	8b 45 08             	mov    0x8(%ebp),%eax
    7785:	8b 50 04             	mov    0x4(%eax),%edx
    7788:	8b 45 14             	mov    0x14(%ebp),%eax
    778b:	8b 40 08             	mov    0x8(%eax),%eax
    778e:	39 c2                	cmp    %eax,%edx
    7790:	7e 07                	jle    7799 <inflatev+0x6f>
    7792:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    7799:	8b 45 f4             	mov    -0xc(%ebp),%eax
    779c:	eb 14                	jmp    77b2 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    779e:	ff 75 14             	pushl  0x14(%ebp)
    77a1:	ff 75 10             	pushl  0x10(%ebp)
    77a4:	ff 75 0c             	pushl  0xc(%ebp)
    77a7:	ff 75 08             	pushl  0x8(%ebp)
    77aa:	e8 39 fe ff ff       	call   75e8 <lodepng_inflatev>
    77af:	83 c4 10             	add    $0x10,%esp
  }
}
    77b2:	c9                   	leave  
    77b3:	c3                   	ret    

000077b4 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    77b4:	55                   	push   %ebp
    77b5:	89 e5                	mov    %esp,%ebp
    77b7:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    77ba:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    77c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    77c4:	83 e8 01             	sub    $0x1,%eax
    77c7:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    77ca:	eb 39                	jmp    7805 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    77cc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    77cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    77d2:	01 d0                	add    %edx,%eax
    77d4:	d1 f8                	sar    %eax
    77d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    77d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    77dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77e3:	8b 45 08             	mov    0x8(%ebp),%eax
    77e6:	01 d0                	add    %edx,%eax
    77e8:	8b 10                	mov    (%eax),%edx
    77ea:	8b 45 10             	mov    0x10(%ebp),%eax
    77ed:	39 c2                	cmp    %eax,%edx
    77ef:	72 0b                	jb     77fc <searchCodeIndex+0x48>
    77f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    77f4:	83 e8 01             	sub    $0x1,%eax
    77f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    77fa:	eb 09                	jmp    7805 <searchCodeIndex+0x51>
    else left = mid + 1;
    77fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    77ff:	83 c0 01             	add    $0x1,%eax
    7802:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    7805:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7808:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    780b:	7e bf                	jle    77cc <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    780d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7810:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7813:	7d 18                	jge    782d <searchCodeIndex+0x79>
    7815:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7818:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    781f:	8b 45 08             	mov    0x8(%ebp),%eax
    7822:	01 d0                	add    %edx,%eax
    7824:	8b 10                	mov    (%eax),%edx
    7826:	8b 45 10             	mov    0x10(%ebp),%eax
    7829:	39 c2                	cmp    %eax,%edx
    782b:	76 04                	jbe    7831 <searchCodeIndex+0x7d>
    782d:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    7831:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    7834:	c9                   	leave  
    7835:	c3                   	ret    

00007836 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    7836:	55                   	push   %ebp
    7837:	89 e5                	mov    %esp,%ebp
    7839:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    783c:	ff 75 0c             	pushl  0xc(%ebp)
    783f:	6a 1d                	push   $0x1d
    7841:	68 20 b4 01 00       	push   $0x1b420
    7846:	e8 69 ff ff ff       	call   77b4 <searchCodeIndex>
    784b:	83 c4 0c             	add    $0xc,%esp
    784e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    7851:	8b 55 0c             	mov    0xc(%ebp),%edx
    7854:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7857:	8b 04 85 20 b4 01 00 	mov    0x1b420(,%eax,4),%eax
    785e:	29 c2                	sub    %eax,%edx
    7860:	89 d0                	mov    %edx,%eax
    7862:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    7865:	ff 75 10             	pushl  0x10(%ebp)
    7868:	6a 1e                	push   $0x1e
    786a:	68 20 b5 01 00       	push   $0x1b520
    786f:	e8 40 ff ff ff       	call   77b4 <searchCodeIndex>
    7874:	83 c4 0c             	add    $0xc,%esp
    7877:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    787a:	8b 55 10             	mov    0x10(%ebp),%edx
    787d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7880:	8b 04 85 20 b5 01 00 	mov    0x1b520(,%eax,4),%eax
    7887:	29 c2                	sub    %eax,%edx
    7889:	89 d0                	mov    %edx,%eax
    788b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    788e:	8b 45 08             	mov    0x8(%ebp),%eax
    7891:	8b 40 04             	mov    0x4(%eax),%eax
    7894:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    7897:	8b 45 08             	mov    0x8(%ebp),%eax
    789a:	8b 40 04             	mov    0x4(%eax),%eax
    789d:	83 c0 04             	add    $0x4,%eax
    78a0:	50                   	push   %eax
    78a1:	ff 75 08             	pushl  0x8(%ebp)
    78a4:	e8 f0 d2 ff ff       	call   4b99 <uivector_resize>
    78a9:	83 c4 08             	add    $0x8,%esp
    78ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    78af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    78b3:	74 57                	je     790c <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    78b5:	8b 45 08             	mov    0x8(%ebp),%eax
    78b8:	8b 00                	mov    (%eax),%eax
    78ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
    78bd:	c1 e2 02             	shl    $0x2,%edx
    78c0:	01 d0                	add    %edx,%eax
    78c2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    78c5:	81 c2 01 01 00 00    	add    $0x101,%edx
    78cb:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    78cd:	8b 45 08             	mov    0x8(%ebp),%eax
    78d0:	8b 00                	mov    (%eax),%eax
    78d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    78d5:	83 c2 01             	add    $0x1,%edx
    78d8:	c1 e2 02             	shl    $0x2,%edx
    78db:	01 c2                	add    %eax,%edx
    78dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    78e0:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    78e2:	8b 45 08             	mov    0x8(%ebp),%eax
    78e5:	8b 00                	mov    (%eax),%eax
    78e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    78ea:	83 c2 02             	add    $0x2,%edx
    78ed:	c1 e2 02             	shl    $0x2,%edx
    78f0:	01 c2                	add    %eax,%edx
    78f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    78f5:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    78f7:	8b 45 08             	mov    0x8(%ebp),%eax
    78fa:	8b 00                	mov    (%eax),%eax
    78fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    78ff:	83 c2 03             	add    $0x3,%edx
    7902:	c1 e2 02             	shl    $0x2,%edx
    7905:	01 c2                	add    %eax,%edx
    7907:	8b 45 f0             	mov    -0x10(%ebp),%eax
    790a:	89 02                	mov    %eax,(%edx)
  }
}
    790c:	90                   	nop
    790d:	c9                   	leave  
    790e:	c3                   	ret    

0000790f <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    790f:	55                   	push   %ebp
    7910:	89 e5                	mov    %esp,%ebp
    7912:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    7915:	b8 00 00 01 00       	mov    $0x10000,%eax
    791a:	c1 e0 02             	shl    $0x2,%eax
    791d:	83 ec 0c             	sub    $0xc,%esp
    7920:	50                   	push   %eax
    7921:	e8 f2 d0 ff ff       	call   4a18 <lodepng_malloc>
    7926:	83 c4 10             	add    $0x10,%esp
    7929:	89 c2                	mov    %eax,%edx
    792b:	8b 45 08             	mov    0x8(%ebp),%eax
    792e:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    7930:	8b 45 0c             	mov    0xc(%ebp),%eax
    7933:	c1 e0 02             	shl    $0x2,%eax
    7936:	83 ec 0c             	sub    $0xc,%esp
    7939:	50                   	push   %eax
    793a:	e8 d9 d0 ff ff       	call   4a18 <lodepng_malloc>
    793f:	83 c4 10             	add    $0x10,%esp
    7942:	89 c2                	mov    %eax,%edx
    7944:	8b 45 08             	mov    0x8(%ebp),%eax
    7947:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    794a:	8b 45 0c             	mov    0xc(%ebp),%eax
    794d:	01 c0                	add    %eax,%eax
    794f:	83 ec 0c             	sub    $0xc,%esp
    7952:	50                   	push   %eax
    7953:	e8 c0 d0 ff ff       	call   4a18 <lodepng_malloc>
    7958:	83 c4 10             	add    $0x10,%esp
    795b:	89 c2                	mov    %eax,%edx
    795d:	8b 45 08             	mov    0x8(%ebp),%eax
    7960:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    7963:	8b 45 0c             	mov    0xc(%ebp),%eax
    7966:	01 c0                	add    %eax,%eax
    7968:	83 ec 0c             	sub    $0xc,%esp
    796b:	50                   	push   %eax
    796c:	e8 a7 d0 ff ff       	call   4a18 <lodepng_malloc>
    7971:	83 c4 10             	add    $0x10,%esp
    7974:	89 c2                	mov    %eax,%edx
    7976:	8b 45 08             	mov    0x8(%ebp),%eax
    7979:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    797c:	b8 02 01 00 00       	mov    $0x102,%eax
    7981:	83 c0 01             	add    $0x1,%eax
    7984:	c1 e0 02             	shl    $0x2,%eax
    7987:	83 ec 0c             	sub    $0xc,%esp
    798a:	50                   	push   %eax
    798b:	e8 88 d0 ff ff       	call   4a18 <lodepng_malloc>
    7990:	83 c4 10             	add    $0x10,%esp
    7993:	89 c2                	mov    %eax,%edx
    7995:	8b 45 08             	mov    0x8(%ebp),%eax
    7998:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    799b:	8b 45 0c             	mov    0xc(%ebp),%eax
    799e:	01 c0                	add    %eax,%eax
    79a0:	83 ec 0c             	sub    $0xc,%esp
    79a3:	50                   	push   %eax
    79a4:	e8 6f d0 ff ff       	call   4a18 <lodepng_malloc>
    79a9:	83 c4 10             	add    $0x10,%esp
    79ac:	89 c2                	mov    %eax,%edx
    79ae:	8b 45 08             	mov    0x8(%ebp),%eax
    79b1:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    79b4:	8b 45 08             	mov    0x8(%ebp),%eax
    79b7:	8b 00                	mov    (%eax),%eax
    79b9:	85 c0                	test   %eax,%eax
    79bb:	74 32                	je     79ef <hash_init+0xe0>
    79bd:	8b 45 08             	mov    0x8(%ebp),%eax
    79c0:	8b 40 04             	mov    0x4(%eax),%eax
    79c3:	85 c0                	test   %eax,%eax
    79c5:	74 28                	je     79ef <hash_init+0xe0>
    79c7:	8b 45 08             	mov    0x8(%ebp),%eax
    79ca:	8b 40 08             	mov    0x8(%eax),%eax
    79cd:	85 c0                	test   %eax,%eax
    79cf:	74 1e                	je     79ef <hash_init+0xe0>
    79d1:	8b 45 08             	mov    0x8(%ebp),%eax
    79d4:	8b 40 0c             	mov    0xc(%eax),%eax
    79d7:	85 c0                	test   %eax,%eax
    79d9:	74 14                	je     79ef <hash_init+0xe0>
    79db:	8b 45 08             	mov    0x8(%ebp),%eax
    79de:	8b 40 10             	mov    0x10(%eax),%eax
    79e1:	85 c0                	test   %eax,%eax
    79e3:	74 0a                	je     79ef <hash_init+0xe0>
    79e5:	8b 45 08             	mov    0x8(%ebp),%eax
    79e8:	8b 40 14             	mov    0x14(%eax),%eax
    79eb:	85 c0                	test   %eax,%eax
    79ed:	75 0a                	jne    79f9 <hash_init+0xea>
    return 83; /*alloc fail*/
    79ef:	b8 53 00 00 00       	mov    $0x53,%eax
    79f4:	e9 d3 00 00 00       	jmp    7acc <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    79f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7a00:	eb 17                	jmp    7a19 <hash_init+0x10a>
    7a02:	8b 45 08             	mov    0x8(%ebp),%eax
    7a05:	8b 00                	mov    (%eax),%eax
    7a07:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7a0a:	c1 e2 02             	shl    $0x2,%edx
    7a0d:	01 d0                	add    %edx,%eax
    7a0f:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    7a15:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7a19:	b8 00 00 01 00       	mov    $0x10000,%eax
    7a1e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    7a21:	75 df                	jne    7a02 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    7a23:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7a2a:	eb 18                	jmp    7a44 <hash_init+0x135>
    7a2c:	8b 45 08             	mov    0x8(%ebp),%eax
    7a2f:	8b 40 08             	mov    0x8(%eax),%eax
    7a32:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7a35:	c1 e2 02             	shl    $0x2,%edx
    7a38:	01 d0                	add    %edx,%eax
    7a3a:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    7a40:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7a44:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7a47:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7a4a:	75 e0                	jne    7a2c <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    7a4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7a53:	eb 17                	jmp    7a6c <hash_init+0x15d>
    7a55:	8b 45 08             	mov    0x8(%ebp),%eax
    7a58:	8b 40 04             	mov    0x4(%eax),%eax
    7a5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7a5e:	01 d2                	add    %edx,%edx
    7a60:	01 d0                	add    %edx,%eax
    7a62:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7a65:	66 89 10             	mov    %dx,(%eax)
    7a68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7a6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7a6f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7a72:	75 e1                	jne    7a55 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    7a74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7a7b:	eb 18                	jmp    7a95 <hash_init+0x186>
    7a7d:	8b 45 08             	mov    0x8(%ebp),%eax
    7a80:	8b 40 0c             	mov    0xc(%eax),%eax
    7a83:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7a86:	c1 e2 02             	shl    $0x2,%edx
    7a89:	01 d0                	add    %edx,%eax
    7a8b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    7a91:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7a95:	b8 02 01 00 00       	mov    $0x102,%eax
    7a9a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    7a9d:	76 de                	jbe    7a7d <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    7a9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7aa6:	eb 17                	jmp    7abf <hash_init+0x1b0>
    7aa8:	8b 45 08             	mov    0x8(%ebp),%eax
    7aab:	8b 40 10             	mov    0x10(%eax),%eax
    7aae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7ab1:	01 d2                	add    %edx,%edx
    7ab3:	01 d0                	add    %edx,%eax
    7ab5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7ab8:	66 89 10             	mov    %dx,(%eax)
    7abb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7ac2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7ac5:	75 e1                	jne    7aa8 <hash_init+0x199>

  return 0;
    7ac7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7acc:	c9                   	leave  
    7acd:	c3                   	ret    

00007ace <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    7ace:	55                   	push   %ebp
    7acf:	89 e5                	mov    %esp,%ebp
    7ad1:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    7ad4:	8b 45 08             	mov    0x8(%ebp),%eax
    7ad7:	8b 00                	mov    (%eax),%eax
    7ad9:	83 ec 0c             	sub    $0xc,%esp
    7adc:	50                   	push   %eax
    7add:	e8 57 cf ff ff       	call   4a39 <lodepng_free>
    7ae2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    7ae5:	8b 45 08             	mov    0x8(%ebp),%eax
    7ae8:	8b 40 08             	mov    0x8(%eax),%eax
    7aeb:	83 ec 0c             	sub    $0xc,%esp
    7aee:	50                   	push   %eax
    7aef:	e8 45 cf ff ff       	call   4a39 <lodepng_free>
    7af4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    7af7:	8b 45 08             	mov    0x8(%ebp),%eax
    7afa:	8b 40 04             	mov    0x4(%eax),%eax
    7afd:	83 ec 0c             	sub    $0xc,%esp
    7b00:	50                   	push   %eax
    7b01:	e8 33 cf ff ff       	call   4a39 <lodepng_free>
    7b06:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    7b09:	8b 45 08             	mov    0x8(%ebp),%eax
    7b0c:	8b 40 14             	mov    0x14(%eax),%eax
    7b0f:	83 ec 0c             	sub    $0xc,%esp
    7b12:	50                   	push   %eax
    7b13:	e8 21 cf ff ff       	call   4a39 <lodepng_free>
    7b18:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    7b1b:	8b 45 08             	mov    0x8(%ebp),%eax
    7b1e:	8b 40 0c             	mov    0xc(%eax),%eax
    7b21:	83 ec 0c             	sub    $0xc,%esp
    7b24:	50                   	push   %eax
    7b25:	e8 0f cf ff ff       	call   4a39 <lodepng_free>
    7b2a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    7b2d:	8b 45 08             	mov    0x8(%ebp),%eax
    7b30:	8b 40 10             	mov    0x10(%eax),%eax
    7b33:	83 ec 0c             	sub    $0xc,%esp
    7b36:	50                   	push   %eax
    7b37:	e8 fd ce ff ff       	call   4a39 <lodepng_free>
    7b3c:	83 c4 10             	add    $0x10,%esp
}
    7b3f:	90                   	nop
    7b40:	c9                   	leave  
    7b41:	c3                   	ret    

00007b42 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    7b42:	55                   	push   %ebp
    7b43:	89 e5                	mov    %esp,%ebp
    7b45:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    7b48:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    7b4f:	8b 45 10             	mov    0x10(%ebp),%eax
    7b52:	83 c0 02             	add    $0x2,%eax
    7b55:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7b58:	7d 41                	jge    7b9b <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    7b5a:	8b 55 10             	mov    0x10(%ebp),%edx
    7b5d:	8b 45 08             	mov    0x8(%ebp),%eax
    7b60:	01 d0                	add    %edx,%eax
    7b62:	0f b6 00             	movzbl (%eax),%eax
    7b65:	0f b6 c0             	movzbl %al,%eax
    7b68:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    7b6b:	8b 45 10             	mov    0x10(%ebp),%eax
    7b6e:	8d 50 01             	lea    0x1(%eax),%edx
    7b71:	8b 45 08             	mov    0x8(%ebp),%eax
    7b74:	01 d0                	add    %edx,%eax
    7b76:	0f b6 00             	movzbl (%eax),%eax
    7b79:	0f b6 c0             	movzbl %al,%eax
    7b7c:	c1 e0 04             	shl    $0x4,%eax
    7b7f:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    7b82:	8b 45 10             	mov    0x10(%ebp),%eax
    7b85:	8d 50 02             	lea    0x2(%eax),%edx
    7b88:	8b 45 08             	mov    0x8(%ebp),%eax
    7b8b:	01 d0                	add    %edx,%eax
    7b8d:	0f b6 00             	movzbl (%eax),%eax
    7b90:	0f b6 c0             	movzbl %al,%eax
    7b93:	c1 e0 08             	shl    $0x8,%eax
    7b96:	31 45 fc             	xor    %eax,-0x4(%ebp)
    7b99:	eb 51                	jmp    7bec <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    7b9b:	8b 45 10             	mov    0x10(%ebp),%eax
    7b9e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7ba1:	7c 07                	jl     7baa <getHash+0x68>
    7ba3:	b8 00 00 00 00       	mov    $0x0,%eax
    7ba8:	eb 4a                	jmp    7bf4 <getHash+0xb2>
    amount = size - pos;
    7baa:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bad:	2b 45 10             	sub    0x10(%ebp),%eax
    7bb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    7bb3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    7bba:	eb 28                	jmp    7be4 <getHash+0xa2>
    7bbc:	8b 55 10             	mov    0x10(%ebp),%edx
    7bbf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7bc2:	01 d0                	add    %edx,%eax
    7bc4:	89 c2                	mov    %eax,%edx
    7bc6:	8b 45 08             	mov    0x8(%ebp),%eax
    7bc9:	01 d0                	add    %edx,%eax
    7bcb:	0f b6 00             	movzbl (%eax),%eax
    7bce:	0f b6 d0             	movzbl %al,%edx
    7bd1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7bd4:	c1 e0 03             	shl    $0x3,%eax
    7bd7:	89 c1                	mov    %eax,%ecx
    7bd9:	d3 e2                	shl    %cl,%edx
    7bdb:	89 d0                	mov    %edx,%eax
    7bdd:	31 45 fc             	xor    %eax,-0x4(%ebp)
    7be0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7be4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7be7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    7bea:	75 d0                	jne    7bbc <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    7bec:	b8 ff ff 00 00       	mov    $0xffff,%eax
    7bf1:	23 45 fc             	and    -0x4(%ebp),%eax
}
    7bf4:	c9                   	leave  
    7bf5:	c3                   	ret    

00007bf6 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    7bf6:	55                   	push   %ebp
    7bf7:	89 e5                	mov    %esp,%ebp
    7bf9:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    7bfc:	8b 55 10             	mov    0x10(%ebp),%edx
    7bff:	8b 45 08             	mov    0x8(%ebp),%eax
    7c02:	01 d0                	add    %edx,%eax
    7c04:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    7c07:	b8 02 01 00 00       	mov    $0x102,%eax
    7c0c:	89 c2                	mov    %eax,%edx
    7c0e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c11:	01 d0                	add    %edx,%eax
    7c13:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    7c16:	8b 55 0c             	mov    0xc(%ebp),%edx
    7c19:	8b 45 08             	mov    0x8(%ebp),%eax
    7c1c:	01 d0                	add    %edx,%eax
    7c1e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    7c21:	73 0b                	jae    7c2e <countZeros+0x38>
    7c23:	8b 55 0c             	mov    0xc(%ebp),%edx
    7c26:	8b 45 08             	mov    0x8(%ebp),%eax
    7c29:	01 d0                	add    %edx,%eax
    7c2b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    7c2e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c31:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    7c34:	eb 04                	jmp    7c3a <countZeros+0x44>
    7c36:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    7c3a:	8b 45 08             	mov    0x8(%ebp),%eax
    7c3d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    7c40:	74 0a                	je     7c4c <countZeros+0x56>
    7c42:	8b 45 08             	mov    0x8(%ebp),%eax
    7c45:	0f b6 00             	movzbl (%eax),%eax
    7c48:	84 c0                	test   %al,%al
    7c4a:	74 ea                	je     7c36 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    7c4c:	8b 55 08             	mov    0x8(%ebp),%edx
    7c4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c52:	29 c2                	sub    %eax,%edx
    7c54:	89 d0                	mov    %edx,%eax
}
    7c56:	c9                   	leave  
    7c57:	c3                   	ret    

00007c58 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    7c58:	55                   	push   %ebp
    7c59:	89 e5                	mov    %esp,%ebp
    7c5b:	83 ec 04             	sub    $0x4,%esp
    7c5e:	8b 45 14             	mov    0x14(%ebp),%eax
    7c61:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    7c65:	8b 45 08             	mov    0x8(%ebp),%eax
    7c68:	8b 40 08             	mov    0x8(%eax),%eax
    7c6b:	8b 55 0c             	mov    0xc(%ebp),%edx
    7c6e:	c1 e2 02             	shl    $0x2,%edx
    7c71:	01 c2                	add    %eax,%edx
    7c73:	8b 45 10             	mov    0x10(%ebp),%eax
    7c76:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    7c78:	8b 45 08             	mov    0x8(%ebp),%eax
    7c7b:	8b 00                	mov    (%eax),%eax
    7c7d:	8b 55 10             	mov    0x10(%ebp),%edx
    7c80:	c1 e2 02             	shl    $0x2,%edx
    7c83:	01 d0                	add    %edx,%eax
    7c85:	8b 00                	mov    (%eax),%eax
    7c87:	83 f8 ff             	cmp    $0xffffffff,%eax
    7c8a:	74 1f                	je     7cab <updateHashChain+0x53>
    7c8c:	8b 45 08             	mov    0x8(%ebp),%eax
    7c8f:	8b 40 04             	mov    0x4(%eax),%eax
    7c92:	8b 55 0c             	mov    0xc(%ebp),%edx
    7c95:	01 d2                	add    %edx,%edx
    7c97:	01 c2                	add    %eax,%edx
    7c99:	8b 45 08             	mov    0x8(%ebp),%eax
    7c9c:	8b 00                	mov    (%eax),%eax
    7c9e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    7ca1:	c1 e1 02             	shl    $0x2,%ecx
    7ca4:	01 c8                	add    %ecx,%eax
    7ca6:	8b 00                	mov    (%eax),%eax
    7ca8:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    7cab:	8b 45 08             	mov    0x8(%ebp),%eax
    7cae:	8b 00                	mov    (%eax),%eax
    7cb0:	8b 55 10             	mov    0x10(%ebp),%edx
    7cb3:	c1 e2 02             	shl    $0x2,%edx
    7cb6:	01 c2                	add    %eax,%edx
    7cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cbb:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    7cbd:	8b 45 08             	mov    0x8(%ebp),%eax
    7cc0:	8b 40 14             	mov    0x14(%eax),%eax
    7cc3:	8b 55 0c             	mov    0xc(%ebp),%edx
    7cc6:	01 d2                	add    %edx,%edx
    7cc8:	01 c2                	add    %eax,%edx
    7cca:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    7cce:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    7cd1:	8b 45 08             	mov    0x8(%ebp),%eax
    7cd4:	8b 40 0c             	mov    0xc(%eax),%eax
    7cd7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    7cdb:	c1 e2 02             	shl    $0x2,%edx
    7cde:	01 d0                	add    %edx,%eax
    7ce0:	8b 00                	mov    (%eax),%eax
    7ce2:	83 f8 ff             	cmp    $0xffffffff,%eax
    7ce5:	74 21                	je     7d08 <updateHashChain+0xb0>
    7ce7:	8b 45 08             	mov    0x8(%ebp),%eax
    7cea:	8b 40 10             	mov    0x10(%eax),%eax
    7ced:	8b 55 0c             	mov    0xc(%ebp),%edx
    7cf0:	01 d2                	add    %edx,%edx
    7cf2:	01 c2                	add    %eax,%edx
    7cf4:	8b 45 08             	mov    0x8(%ebp),%eax
    7cf7:	8b 40 0c             	mov    0xc(%eax),%eax
    7cfa:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    7cfe:	c1 e1 02             	shl    $0x2,%ecx
    7d01:	01 c8                	add    %ecx,%eax
    7d03:	8b 00                	mov    (%eax),%eax
    7d05:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    7d08:	8b 45 08             	mov    0x8(%ebp),%eax
    7d0b:	8b 40 0c             	mov    0xc(%eax),%eax
    7d0e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    7d12:	c1 e2 02             	shl    $0x2,%edx
    7d15:	01 c2                	add    %eax,%edx
    7d17:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d1a:	89 02                	mov    %eax,(%edx)
}
    7d1c:	90                   	nop
    7d1d:	c9                   	leave  
    7d1e:	c3                   	ret    

00007d1f <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    7d1f:	55                   	push   %ebp
    7d20:	89 e5                	mov    %esp,%ebp
    7d22:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    7d25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    7d2c:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    7d33:	77 08                	ja     7d3d <encodeLZ77+0x1e>
    7d35:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7d38:	c1 e8 03             	shr    $0x3,%eax
    7d3b:	eb 03                	jmp    7d40 <encodeLZ77+0x21>
    7d3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7d40:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    7d43:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    7d4a:	76 07                	jbe    7d53 <encodeLZ77+0x34>
    7d4c:	b8 02 01 00 00       	mov    $0x102,%eax
    7d51:	eb 05                	jmp    7d58 <encodeLZ77+0x39>
    7d53:	b8 40 00 00 00       	mov    $0x40,%eax
    7d58:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    7d5b:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    7d62:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    7d69:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    7d70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    7d77:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    7d7e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    7d82:	74 09                	je     7d8d <encodeLZ77+0x6e>
    7d84:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    7d8b:	76 0a                	jbe    7d97 <encodeLZ77+0x78>
    7d8d:	b8 3c 00 00 00       	mov    $0x3c,%eax
    7d92:	e9 e3 04 00 00       	jmp    827a <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    7d97:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7d9a:	83 e8 01             	sub    $0x1,%eax
    7d9d:	23 45 1c             	and    0x1c(%ebp),%eax
    7da0:	85 c0                	test   %eax,%eax
    7da2:	74 0a                	je     7dae <encodeLZ77+0x8f>
    7da4:	b8 5a 00 00 00       	mov    $0x5a,%eax
    7da9:	e9 cc 04 00 00       	jmp    827a <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    7dae:	b8 02 01 00 00       	mov    $0x102,%eax
    7db3:	39 45 24             	cmp    %eax,0x24(%ebp)
    7db6:	76 08                	jbe    7dc0 <encodeLZ77+0xa1>
    7db8:	b8 02 01 00 00       	mov    $0x102,%eax
    7dbd:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    7dc0:	8b 45 14             	mov    0x14(%ebp),%eax
    7dc3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    7dc6:	e9 a0 04 00 00       	jmp    826b <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    7dcb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7dce:	8d 50 ff             	lea    -0x1(%eax),%edx
    7dd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7dd4:	21 d0                	and    %edx,%eax
    7dd6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    7dd9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    7de0:	ff 75 fc             	pushl  -0x4(%ebp)
    7de3:	ff 75 18             	pushl  0x18(%ebp)
    7de6:	ff 75 10             	pushl  0x10(%ebp)
    7de9:	e8 54 fd ff ff       	call   7b42 <getHash>
    7dee:	83 c4 0c             	add    $0xc,%esp
    7df1:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    7df4:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    7df8:	74 4e                	je     7e48 <encodeLZ77+0x129>
    7dfa:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    7dfe:	75 48                	jne    7e48 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7e00:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7e04:	75 16                	jne    7e1c <encodeLZ77+0xfd>
    7e06:	ff 75 fc             	pushl  -0x4(%ebp)
    7e09:	ff 75 18             	pushl  0x18(%ebp)
    7e0c:	ff 75 10             	pushl  0x10(%ebp)
    7e0f:	e8 e2 fd ff ff       	call   7bf6 <countZeros>
    7e14:	83 c4 0c             	add    $0xc,%esp
    7e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7e1a:	eb 35                	jmp    7e51 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    7e1c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7e1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e22:	01 c2                	add    %eax,%edx
    7e24:	8b 45 18             	mov    0x18(%ebp),%eax
    7e27:	39 c2                	cmp    %eax,%edx
    7e29:	77 17                	ja     7e42 <encodeLZ77+0x123>
    7e2b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7e2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e31:	01 d0                	add    %edx,%eax
    7e33:	8d 50 ff             	lea    -0x1(%eax),%edx
    7e36:	8b 45 10             	mov    0x10(%ebp),%eax
    7e39:	01 d0                	add    %edx,%eax
    7e3b:	0f b6 00             	movzbl (%eax),%eax
    7e3e:	84 c0                	test   %al,%al
    7e40:	74 0f                	je     7e51 <encodeLZ77+0x132>
    7e42:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7e46:	eb 09                	jmp    7e51 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    7e48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7e4f:	eb 01                	jmp    7e52 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7e51:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    7e52:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e55:	0f b7 c0             	movzwl %ax,%eax
    7e58:	50                   	push   %eax
    7e59:	ff 75 b0             	pushl  -0x50(%ebp)
    7e5c:	ff 75 b4             	pushl  -0x4c(%ebp)
    7e5f:	ff 75 0c             	pushl  0xc(%ebp)
    7e62:	e8 f1 fd ff ff       	call   7c58 <updateHashChain>
    7e67:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    7e6a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    7e71:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    7e78:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e7b:	8b 40 04             	mov    0x4(%eax),%eax
    7e7e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    7e81:	01 d2                	add    %edx,%edx
    7e83:	01 d0                	add    %edx,%eax
    7e85:	0f b7 00             	movzwl (%eax),%eax
    7e88:	0f b7 c0             	movzwl %ax,%eax
    7e8b:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    7e8e:	ba 02 01 00 00       	mov    $0x102,%edx
    7e93:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7e96:	01 c2                	add    %eax,%edx
    7e98:	8b 45 18             	mov    0x18(%ebp),%eax
    7e9b:	39 c2                	cmp    %eax,%edx
    7e9d:	0f 4e c2             	cmovle %edx,%eax
    7ea0:	89 c2                	mov    %eax,%edx
    7ea2:	8b 45 10             	mov    0x10(%ebp),%eax
    7ea5:	01 d0                	add    %edx,%eax
    7ea7:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    7eaa:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    7eb1:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7eb4:	8d 50 01             	lea    0x1(%eax),%edx
    7eb7:	89 55 c8             	mov    %edx,-0x38(%ebp)
    7eba:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    7ebd:	0f 83 67 01 00 00    	jae    802a <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    7ec3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7ec6:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    7ec9:	77 08                	ja     7ed3 <encodeLZ77+0x1b4>
    7ecb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7ece:	2b 45 cc             	sub    -0x34(%ebp),%eax
    7ed1:	eb 0d                	jmp    7ee0 <encodeLZ77+0x1c1>
    7ed3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7ed6:	2b 45 cc             	sub    -0x34(%ebp),%eax
    7ed9:	89 c2                	mov    %eax,%edx
    7edb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ede:	01 d0                	add    %edx,%eax
    7ee0:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    7ee3:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7ee6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    7ee9:	0f 82 3e 01 00 00    	jb     802d <encodeLZ77+0x30e>
      prev_offset = current_offset;
    7eef:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7ef2:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    7ef5:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    7ef9:	0f 84 a3 00 00 00    	je     7fa2 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    7eff:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7f02:	8b 45 10             	mov    0x10(%ebp),%eax
    7f05:	01 d0                	add    %edx,%eax
    7f07:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    7f0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7f0d:	2b 45 a8             	sub    -0x58(%ebp),%eax
    7f10:	89 c2                	mov    %eax,%edx
    7f12:	8b 45 10             	mov    0x10(%ebp),%eax
    7f15:	01 d0                	add    %edx,%eax
    7f17:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    7f1a:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    7f1e:	76 3a                	jbe    7f5a <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    7f20:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f23:	8b 40 14             	mov    0x14(%eax),%eax
    7f26:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7f29:	01 d2                	add    %edx,%edx
    7f2b:	01 d0                	add    %edx,%eax
    7f2d:	0f b7 00             	movzwl (%eax),%eax
    7f30:	0f b7 c0             	movzwl %ax,%eax
    7f33:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    7f36:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7f39:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7f3c:	76 06                	jbe    7f44 <encodeLZ77+0x225>
    7f3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7f41:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    7f44:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7f47:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    7f4a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7f4d:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    7f50:	eb 08                	jmp    7f5a <encodeLZ77+0x23b>
          ++backptr;
    7f52:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    7f56:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    7f5a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7f5d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7f60:	74 10                	je     7f72 <encodeLZ77+0x253>
    7f62:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f65:	0f b6 10             	movzbl (%eax),%edx
    7f68:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7f6b:	0f b6 00             	movzbl (%eax),%eax
    7f6e:	38 c2                	cmp    %al,%dl
    7f70:	74 e0                	je     7f52 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    7f72:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7f75:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7f78:	8b 55 10             	mov    0x10(%ebp),%edx
    7f7b:	01 ca                	add    %ecx,%edx
    7f7d:	29 d0                	sub    %edx,%eax
    7f7f:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    7f82:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    7f85:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7f88:	76 18                	jbe    7fa2 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    7f8a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    7f8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    7f90:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7f93:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    7f96:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    7f99:	3b 45 24             	cmp    0x24(%ebp),%eax
    7f9c:	0f 83 8e 00 00 00    	jae    8030 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    7fa2:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fa5:	8b 40 04             	mov    0x4(%eax),%eax
    7fa8:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7fab:	01 d2                	add    %edx,%edx
    7fad:	01 d0                	add    %edx,%eax
    7faf:	0f b7 00             	movzwl (%eax),%eax
    7fb2:	0f b7 c0             	movzwl %ax,%eax
    7fb5:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    7fb8:	74 79                	je     8033 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    7fba:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    7fbe:	76 38                	jbe    7ff8 <encodeLZ77+0x2d9>
    7fc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7fc3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7fc6:	76 30                	jbe    7ff8 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    7fc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fcb:	8b 40 10             	mov    0x10(%eax),%eax
    7fce:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7fd1:	01 d2                	add    %edx,%edx
    7fd3:	01 d0                	add    %edx,%eax
    7fd5:	0f b7 00             	movzwl (%eax),%eax
    7fd8:	0f b7 c0             	movzwl %ax,%eax
    7fdb:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    7fde:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fe1:	8b 40 14             	mov    0x14(%eax),%eax
    7fe4:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7fe7:	01 d2                	add    %edx,%edx
    7fe9:	01 d0                	add    %edx,%eax
    7feb:	0f b7 00             	movzwl (%eax),%eax
    7fee:	0f b7 c0             	movzwl %ax,%eax
    7ff1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7ff4:	74 2f                	je     8025 <encodeLZ77+0x306>
    7ff6:	eb 3f                	jmp    8037 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    7ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ffb:	8b 40 04             	mov    0x4(%eax),%eax
    7ffe:	8b 55 cc             	mov    -0x34(%ebp),%edx
    8001:	01 d2                	add    %edx,%edx
    8003:	01 d0                	add    %edx,%eax
    8005:	0f b7 00             	movzwl (%eax),%eax
    8008:	0f b7 c0             	movzwl %ax,%eax
    800b:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    800e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8011:	8b 40 08             	mov    0x8(%eax),%eax
    8014:	8b 55 cc             	mov    -0x34(%ebp),%edx
    8017:	c1 e2 02             	shl    $0x2,%edx
    801a:	01 d0                	add    %edx,%eax
    801c:	8b 10                	mov    (%eax),%edx
    801e:	8b 45 b0             	mov    -0x50(%ebp),%eax
    8021:	39 c2                	cmp    %eax,%edx
    8023:	75 11                	jne    8036 <encodeLZ77+0x317>
      }
    }
    8025:	e9 87 fe ff ff       	jmp    7eb1 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    802a:	90                   	nop
    802b:	eb 0a                	jmp    8037 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    802d:	90                   	nop
    802e:	eb 07                	jmp    8037 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    8030:	90                   	nop
    8031:	eb 04                	jmp    8037 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    8033:	90                   	nop
    8034:	eb 01                	jmp    8037 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    8036:	90                   	nop
      }
    }

    if(lazymatching) {
    8037:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    803b:	0f 84 c8 00 00 00    	je     8109 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    8041:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    8045:	75 30                	jne    8077 <encodeLZ77+0x358>
    8047:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    804b:	76 2a                	jbe    8077 <encodeLZ77+0x358>
    804d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8050:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    8053:	77 22                	ja     8077 <encodeLZ77+0x358>
    8055:	b8 02 01 00 00       	mov    $0x102,%eax
    805a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    805d:	73 18                	jae    8077 <encodeLZ77+0x358>
        lazy = 1;
    805f:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    8066:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8069:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    806c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    806f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    8072:	e9 f0 01 00 00       	jmp    8267 <encodeLZ77+0x548>
      }
      if(lazy) {
    8077:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    807b:	0f 84 88 00 00 00    	je     8109 <encodeLZ77+0x3ea>
        lazy = 0;
    8081:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    8088:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    808c:	75 0c                	jne    809a <encodeLZ77+0x37b>
    808e:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    8095:	e9 dd 01 00 00       	jmp    8277 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    809a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    809d:	83 c0 01             	add    $0x1,%eax
    80a0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    80a3:	73 2d                	jae    80d2 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    80a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    80a8:	8d 50 ff             	lea    -0x1(%eax),%edx
    80ab:	8b 45 10             	mov    0x10(%ebp),%eax
    80ae:	01 d0                	add    %edx,%eax
    80b0:	0f b6 00             	movzbl (%eax),%eax
    80b3:	0f b6 c0             	movzbl %al,%eax
    80b6:	50                   	push   %eax
    80b7:	ff 75 08             	pushl  0x8(%ebp)
    80ba:	e8 6f cb ff ff       	call   4c2e <uivector_push_back>
    80bf:	83 c4 08             	add    $0x8,%esp
    80c2:	85 c0                	test   %eax,%eax
    80c4:	75 43                	jne    8109 <encodeLZ77+0x3ea>
    80c6:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    80cd:	e9 a5 01 00 00       	jmp    8277 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    80d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    80d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    80d8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    80db:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    80de:	8b 45 0c             	mov    0xc(%ebp),%eax
    80e1:	8b 00                	mov    (%eax),%eax
    80e3:	8b 55 b0             	mov    -0x50(%ebp),%edx
    80e6:	c1 e2 02             	shl    $0x2,%edx
    80e9:	01 d0                	add    %edx,%eax
    80eb:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    80f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    80f4:	8b 40 0c             	mov    0xc(%eax),%eax
    80f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    80fa:	c1 e2 02             	shl    $0x2,%edx
    80fd:	01 d0                	add    %edx,%eax
    80ff:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    8105:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    8109:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    810d:	76 14                	jbe    8123 <encodeLZ77+0x404>
    810f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8112:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    8115:	76 0c                	jbe    8123 <encodeLZ77+0x404>
    8117:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    811e:	e9 54 01 00 00       	jmp    8277 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    8123:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    8127:	77 2e                	ja     8157 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    8129:	8b 55 fc             	mov    -0x4(%ebp),%edx
    812c:	8b 45 10             	mov    0x10(%ebp),%eax
    812f:	01 d0                	add    %edx,%eax
    8131:	0f b6 00             	movzbl (%eax),%eax
    8134:	0f b6 c0             	movzbl %al,%eax
    8137:	50                   	push   %eax
    8138:	ff 75 08             	pushl  0x8(%ebp)
    813b:	e8 ee ca ff ff       	call   4c2e <uivector_push_back>
    8140:	83 c4 08             	add    $0x8,%esp
    8143:	85 c0                	test   %eax,%eax
    8145:	0f 85 1c 01 00 00    	jne    8267 <encodeLZ77+0x548>
    814b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    8152:	e9 20 01 00 00       	jmp    8277 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    8157:	8b 45 e8             	mov    -0x18(%ebp),%eax
    815a:	3b 45 20             	cmp    0x20(%ebp),%eax
    815d:	72 0f                	jb     816e <encodeLZ77+0x44f>
    815f:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    8163:	75 37                	jne    819c <encodeLZ77+0x47d>
    8165:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    816c:	76 2e                	jbe    819c <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    816e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8171:	8b 45 10             	mov    0x10(%ebp),%eax
    8174:	01 d0                	add    %edx,%eax
    8176:	0f b6 00             	movzbl (%eax),%eax
    8179:	0f b6 c0             	movzbl %al,%eax
    817c:	50                   	push   %eax
    817d:	ff 75 08             	pushl  0x8(%ebp)
    8180:	e8 a9 ca ff ff       	call   4c2e <uivector_push_back>
    8185:	83 c4 08             	add    $0x8,%esp
    8188:	85 c0                	test   %eax,%eax
    818a:	0f 85 d7 00 00 00    	jne    8267 <encodeLZ77+0x548>
    8190:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    8197:	e9 db 00 00 00       	jmp    8277 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    819c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    819f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    81a2:	52                   	push   %edx
    81a3:	50                   	push   %eax
    81a4:	ff 75 08             	pushl  0x8(%ebp)
    81a7:	e8 8a f6 ff ff       	call   7836 <addLengthDistance>
    81ac:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    81af:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    81b6:	e9 a0 00 00 00       	jmp    825b <encodeLZ77+0x53c>
        ++pos;
    81bb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    81bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    81c2:	8d 50 ff             	lea    -0x1(%eax),%edx
    81c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    81c8:	21 d0                	and    %edx,%eax
    81ca:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    81cd:	ff 75 fc             	pushl  -0x4(%ebp)
    81d0:	ff 75 18             	pushl  0x18(%ebp)
    81d3:	ff 75 10             	pushl  0x10(%ebp)
    81d6:	e8 67 f9 ff ff       	call   7b42 <getHash>
    81db:	83 c4 0c             	add    $0xc,%esp
    81de:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    81e1:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    81e5:	74 4e                	je     8235 <encodeLZ77+0x516>
    81e7:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    81eb:	75 48                	jne    8235 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    81ed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    81f1:	75 16                	jne    8209 <encodeLZ77+0x4ea>
    81f3:	ff 75 fc             	pushl  -0x4(%ebp)
    81f6:	ff 75 18             	pushl  0x18(%ebp)
    81f9:	ff 75 10             	pushl  0x10(%ebp)
    81fc:	e8 f5 f9 ff ff       	call   7bf6 <countZeros>
    8201:	83 c4 0c             	add    $0xc,%esp
    8204:	89 45 f0             	mov    %eax,-0x10(%ebp)
    8207:	eb 35                	jmp    823e <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    8209:	8b 55 fc             	mov    -0x4(%ebp),%edx
    820c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    820f:	01 c2                	add    %eax,%edx
    8211:	8b 45 18             	mov    0x18(%ebp),%eax
    8214:	39 c2                	cmp    %eax,%edx
    8216:	77 17                	ja     822f <encodeLZ77+0x510>
    8218:	8b 55 fc             	mov    -0x4(%ebp),%edx
    821b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    821e:	01 d0                	add    %edx,%eax
    8220:	8d 50 ff             	lea    -0x1(%eax),%edx
    8223:	8b 45 10             	mov    0x10(%ebp),%eax
    8226:	01 d0                	add    %edx,%eax
    8228:	0f b6 00             	movzbl (%eax),%eax
    822b:	84 c0                	test   %al,%al
    822d:	74 0f                	je     823e <encodeLZ77+0x51f>
    822f:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    8233:	eb 09                	jmp    823e <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    8235:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    823c:	eb 01                	jmp    823f <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    823e:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    823f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8242:	0f b7 c0             	movzwl %ax,%eax
    8245:	50                   	push   %eax
    8246:	ff 75 b0             	pushl  -0x50(%ebp)
    8249:	ff 75 b4             	pushl  -0x4c(%ebp)
    824c:	ff 75 0c             	pushl  0xc(%ebp)
    824f:	e8 04 fa ff ff       	call   7c58 <updateHashChain>
    8254:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    8257:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    825b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    825e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    8261:	0f 82 54 ff ff ff    	jb     81bb <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    8267:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    826b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    826e:	3b 45 18             	cmp    0x18(%ebp),%eax
    8271:	0f 8c 54 fb ff ff    	jl     7dcb <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    8277:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    827a:	c9                   	leave  
    827b:	c3                   	ret    

0000827c <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    827c:	55                   	push   %ebp
    827d:	89 e5                	mov    %esp,%ebp
    827f:	53                   	push   %ebx
    8280:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    8283:	8b 45 10             	mov    0x10(%ebp),%eax
    8286:	05 fe ff 00 00       	add    $0xfffe,%eax
    828b:	ba 01 80 00 80       	mov    $0x80008001,%edx
    8290:	f7 e2                	mul    %edx
    8292:	89 d0                	mov    %edx,%eax
    8294:	c1 e8 0f             	shr    $0xf,%eax
    8297:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    829a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    82a1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    82a8:	e9 1b 01 00 00       	jmp    83c8 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    82ad:	8b 45 08             	mov    0x8(%ebp),%eax
    82b0:	8b 40 04             	mov    0x4(%eax),%eax
    82b3:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    82b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    82b9:	83 e8 01             	sub    $0x1,%eax
    82bc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    82bf:	0f 94 c0             	sete   %al
    82c2:	0f b6 c0             	movzbl %al,%eax
    82c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    82c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    82cf:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    82d6:	8b 45 10             	mov    0x10(%ebp),%eax
    82d9:	2b 45 f4             	sub    -0xc(%ebp),%eax
    82dc:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    82e1:	77 09                	ja     82ec <deflateNoCompression+0x70>
    82e3:	8b 45 10             	mov    0x10(%ebp),%eax
    82e6:	2b 45 f4             	sub    -0xc(%ebp),%eax
    82e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    82ec:	b8 ff ff 00 00       	mov    $0xffff,%eax
    82f1:	2b 45 f0             	sub    -0x10(%ebp),%eax
    82f4:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    82f7:	8b 45 08             	mov    0x8(%ebp),%eax
    82fa:	8b 40 04             	mov    0x4(%eax),%eax
    82fd:	89 c2                	mov    %eax,%edx
    82ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8302:	01 d0                	add    %edx,%eax
    8304:	83 c0 05             	add    $0x5,%eax
    8307:	50                   	push   %eax
    8308:	ff 75 08             	pushl  0x8(%ebp)
    830b:	e8 62 c9 ff ff       	call   4c72 <ucvector_resize>
    8310:	83 c4 08             	add    $0x8,%esp
    8313:	85 c0                	test   %eax,%eax
    8315:	75 0a                	jne    8321 <deflateNoCompression+0xa5>
    8317:	b8 53 00 00 00       	mov    $0x53,%eax
    831c:	e9 b8 00 00 00       	jmp    83d9 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    8321:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8324:	89 c2                	mov    %eax,%edx
    8326:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8329:	83 e0 01             	and    $0x1,%eax
    832c:	01 c0                	add    %eax,%eax
    832e:	01 c2                	add    %eax,%edx
    8330:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8333:	83 e0 02             	and    $0x2,%eax
    8336:	01 c0                	add    %eax,%eax
    8338:	01 d0                	add    %edx,%eax
    833a:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    833d:	8b 45 08             	mov    0x8(%ebp),%eax
    8340:	8b 10                	mov    (%eax),%edx
    8342:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8345:	01 c2                	add    %eax,%edx
    8347:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    834b:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    834d:	8b 45 08             	mov    0x8(%ebp),%eax
    8350:	8b 00                	mov    (%eax),%eax
    8352:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8355:	83 c2 01             	add    $0x1,%edx
    8358:	01 d0                	add    %edx,%eax
    835a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    835d:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    835f:	8b 45 08             	mov    0x8(%ebp),%eax
    8362:	8b 00                	mov    (%eax),%eax
    8364:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8367:	83 c2 02             	add    $0x2,%edx
    836a:	01 d0                	add    %edx,%eax
    836c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    836f:	c1 ea 08             	shr    $0x8,%edx
    8372:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    8374:	8b 45 08             	mov    0x8(%ebp),%eax
    8377:	8b 00                	mov    (%eax),%eax
    8379:	8b 55 e8             	mov    -0x18(%ebp),%edx
    837c:	83 c2 03             	add    $0x3,%edx
    837f:	01 d0                	add    %edx,%eax
    8381:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8384:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    8386:	8b 45 08             	mov    0x8(%ebp),%eax
    8389:	8b 00                	mov    (%eax),%eax
    838b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    838e:	83 c2 04             	add    $0x4,%edx
    8391:	01 d0                	add    %edx,%eax
    8393:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8396:	c1 ea 08             	shr    $0x8,%edx
    8399:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    839b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    839e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    83a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    83a4:	01 d1                	add    %edx,%ecx
    83a6:	8b 55 08             	mov    0x8(%ebp),%edx
    83a9:	8b 12                	mov    (%edx),%edx
    83ab:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    83ae:	83 c3 05             	add    $0x5,%ebx
    83b1:	01 da                	add    %ebx,%edx
    83b3:	50                   	push   %eax
    83b4:	51                   	push   %ecx
    83b5:	52                   	push   %edx
    83b6:	e8 9b c6 ff ff       	call   4a56 <lodepng_memcpy>
    83bb:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    83be:	8b 45 f0             	mov    -0x10(%ebp),%eax
    83c1:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    83c4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    83c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    83cb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    83ce:	0f 85 d9 fe ff ff    	jne    82ad <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    83d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    83d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    83dc:	c9                   	leave  
    83dd:	c3                   	ret    

000083de <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    83de:	55                   	push   %ebp
    83df:	89 e5                	mov    %esp,%ebp
    83e1:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    83e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    83eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    83f2:	e9 10 01 00 00       	jmp    8507 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    83f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    83fa:	8b 00                	mov    (%eax),%eax
    83fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    83ff:	c1 e2 02             	shl    $0x2,%edx
    8402:	01 d0                	add    %edx,%eax
    8404:	8b 00                	mov    (%eax),%eax
    8406:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    8409:	8b 45 10             	mov    0x10(%ebp),%eax
    840c:	8b 40 04             	mov    0x4(%eax),%eax
    840f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8412:	c1 e2 02             	shl    $0x2,%edx
    8415:	01 d0                	add    %edx,%eax
    8417:	8b 00                	mov    (%eax),%eax
    8419:	89 c1                	mov    %eax,%ecx
    841b:	8b 45 10             	mov    0x10(%ebp),%eax
    841e:	8b 00                	mov    (%eax),%eax
    8420:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8423:	c1 e2 02             	shl    $0x2,%edx
    8426:	01 d0                	add    %edx,%eax
    8428:	8b 00                	mov    (%eax),%eax
    842a:	51                   	push   %ecx
    842b:	50                   	push   %eax
    842c:	ff 75 08             	pushl  0x8(%ebp)
    842f:	e8 60 cc ff ff       	call   5094 <writeBitsReversed>
    8434:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    8437:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    843e:	0f 86 bf 00 00 00    	jbe    8503 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    8444:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8447:	2d 01 01 00 00       	sub    $0x101,%eax
    844c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    844f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8452:	8b 04 85 a0 b4 01 00 	mov    0x1b4a0(,%eax,4),%eax
    8459:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    845c:	8b 45 0c             	mov    0xc(%ebp),%eax
    845f:	8b 00                	mov    (%eax),%eax
    8461:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8465:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8468:	c1 e2 02             	shl    $0x2,%edx
    846b:	01 d0                	add    %edx,%eax
    846d:	8b 00                	mov    (%eax),%eax
    846f:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    8472:	8b 45 0c             	mov    0xc(%ebp),%eax
    8475:	8b 00                	mov    (%eax),%eax
    8477:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    847b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    847e:	c1 e2 02             	shl    $0x2,%edx
    8481:	01 d0                	add    %edx,%eax
    8483:	8b 00                	mov    (%eax),%eax
    8485:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    8488:	8b 45 e8             	mov    -0x18(%ebp),%eax
    848b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    848e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8491:	8b 04 85 a0 b5 01 00 	mov    0x1b5a0(,%eax,4),%eax
    8498:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    849b:	8b 45 0c             	mov    0xc(%ebp),%eax
    849e:	8b 00                	mov    (%eax),%eax
    84a0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    84a4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    84a7:	c1 e2 02             	shl    $0x2,%edx
    84aa:	01 d0                	add    %edx,%eax
    84ac:	8b 00                	mov    (%eax),%eax
    84ae:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    84b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    84b4:	50                   	push   %eax
    84b5:	ff 75 ec             	pushl  -0x14(%ebp)
    84b8:	ff 75 08             	pushl  0x8(%ebp)
    84bb:	e8 40 ca ff ff       	call   4f00 <writeBits>
    84c0:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    84c3:	8b 45 14             	mov    0x14(%ebp),%eax
    84c6:	8b 40 04             	mov    0x4(%eax),%eax
    84c9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    84cc:	c1 e2 02             	shl    $0x2,%edx
    84cf:	01 d0                	add    %edx,%eax
    84d1:	8b 00                	mov    (%eax),%eax
    84d3:	89 c1                	mov    %eax,%ecx
    84d5:	8b 45 14             	mov    0x14(%ebp),%eax
    84d8:	8b 00                	mov    (%eax),%eax
    84da:	8b 55 e8             	mov    -0x18(%ebp),%edx
    84dd:	c1 e2 02             	shl    $0x2,%edx
    84e0:	01 d0                	add    %edx,%eax
    84e2:	8b 00                	mov    (%eax),%eax
    84e4:	51                   	push   %ecx
    84e5:	50                   	push   %eax
    84e6:	ff 75 08             	pushl  0x8(%ebp)
    84e9:	e8 a6 cb ff ff       	call   5094 <writeBitsReversed>
    84ee:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    84f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    84f4:	50                   	push   %eax
    84f5:	ff 75 dc             	pushl  -0x24(%ebp)
    84f8:	ff 75 08             	pushl  0x8(%ebp)
    84fb:	e8 00 ca ff ff       	call   4f00 <writeBits>
    8500:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    8503:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8507:	8b 45 0c             	mov    0xc(%ebp),%eax
    850a:	8b 40 04             	mov    0x4(%eax),%eax
    850d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8510:	0f 85 e1 fe ff ff    	jne    83f7 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    8516:	90                   	nop
    8517:	c9                   	leave  
    8518:	c3                   	ret    

00008519 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    8519:	55                   	push   %ebp
    851a:	89 e5                	mov    %esp,%ebp
    851c:	53                   	push   %ebx
    851d:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    8523:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    852a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    8531:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    8538:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    853f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    8546:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    854d:	8b 45 18             	mov    0x18(%ebp),%eax
    8550:	2b 45 14             	sub    0x14(%ebp),%eax
    8553:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    8556:	8b 45 20             	mov    0x20(%ebp),%eax
    8559:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    855c:	8d 45 90             	lea    -0x70(%ebp),%eax
    855f:	50                   	push   %eax
    8560:	e8 a4 c6 ff ff       	call   4c09 <uivector_init>
    8565:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    8568:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    856e:	50                   	push   %eax
    856f:	e8 98 d3 ff ff       	call   590c <HuffmanTree_init>
    8574:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    8577:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    857d:	50                   	push   %eax
    857e:	e8 89 d3 ff ff       	call   590c <HuffmanTree_init>
    8583:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    8586:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    858c:	50                   	push   %eax
    858d:	e8 7a d3 ff ff       	call   590c <HuffmanTree_init>
    8592:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    8595:	83 ec 0c             	sub    $0xc,%esp
    8598:	68 78 04 00 00       	push   $0x478
    859d:	e8 76 c4 ff ff       	call   4a18 <lodepng_malloc>
    85a2:	83 c4 10             	add    $0x10,%esp
    85a5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    85a8:	83 ec 0c             	sub    $0xc,%esp
    85ab:	6a 78                	push   $0x78
    85ad:	e8 66 c4 ff ff       	call   4a18 <lodepng_malloc>
    85b2:	83 c4 10             	add    $0x10,%esp
    85b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    85b8:	83 ec 0c             	sub    $0xc,%esp
    85bb:	6a 4c                	push   $0x4c
    85bd:	e8 56 c4 ff ff       	call   4a18 <lodepng_malloc>
    85c2:	83 c4 10             	add    $0x10,%esp
    85c5:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    85c8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    85cc:	74 0c                	je     85da <deflateDynamic+0xc1>
    85ce:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    85d2:	74 06                	je     85da <deflateDynamic+0xc1>
    85d4:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    85d8:	75 07                	jne    85e1 <deflateDynamic+0xc8>
    85da:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    85e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    85e5:	0f 85 f6 07 00 00    	jne    8de1 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    85eb:	83 ec 04             	sub    $0x4,%esp
    85ee:	68 78 04 00 00       	push   $0x478
    85f3:	6a 00                	push   $0x0
    85f5:	ff 75 d4             	pushl  -0x2c(%ebp)
    85f8:	e8 8c c4 ff ff       	call   4a89 <lodepng_memset>
    85fd:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    8600:	83 ec 04             	sub    $0x4,%esp
    8603:	6a 78                	push   $0x78
    8605:	6a 00                	push   $0x0
    8607:	ff 75 d0             	pushl  -0x30(%ebp)
    860a:	e8 7a c4 ff ff       	call   4a89 <lodepng_memset>
    860f:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    8612:	83 ec 04             	sub    $0x4,%esp
    8615:	6a 4c                	push   $0x4c
    8617:	6a 00                	push   $0x0
    8619:	ff 75 cc             	pushl  -0x34(%ebp)
    861c:	e8 68 c4 ff ff       	call   4a89 <lodepng_memset>
    8621:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    8624:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8627:	8b 40 04             	mov    0x4(%eax),%eax
    862a:	85 c0                	test   %eax,%eax
    862c:	74 45                	je     8673 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    862e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8631:	8b 58 14             	mov    0x14(%eax),%ebx
    8634:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8637:	8b 48 10             	mov    0x10(%eax),%ecx
    863a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    863d:	8b 50 0c             	mov    0xc(%eax),%edx
    8640:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8643:	8b 40 08             	mov    0x8(%eax),%eax
    8646:	83 ec 0c             	sub    $0xc,%esp
    8649:	53                   	push   %ebx
    864a:	51                   	push   %ecx
    864b:	52                   	push   %edx
    864c:	50                   	push   %eax
    864d:	ff 75 18             	pushl  0x18(%ebp)
    8650:	ff 75 14             	pushl  0x14(%ebp)
    8653:	ff 75 10             	pushl  0x10(%ebp)
    8656:	ff 75 0c             	pushl  0xc(%ebp)
    8659:	8d 45 90             	lea    -0x70(%ebp),%eax
    865c:	50                   	push   %eax
    865d:	e8 bd f6 ff ff       	call   7d1f <encodeLZ77>
    8662:	83 c4 30             	add    $0x30,%esp
    8665:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    8668:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    866c:	74 59                	je     86c7 <deflateDynamic+0x1ae>
    866e:	e9 6e 07 00 00       	jmp    8de1 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    8673:	83 ec 08             	sub    $0x8,%esp
    8676:	ff 75 c8             	pushl  -0x38(%ebp)
    8679:	8d 45 90             	lea    -0x70(%ebp),%eax
    867c:	50                   	push   %eax
    867d:	e8 17 c5 ff ff       	call   4b99 <uivector_resize>
    8682:	83 c4 10             	add    $0x10,%esp
    8685:	85 c0                	test   %eax,%eax
    8687:	75 0c                	jne    8695 <deflateDynamic+0x17c>
    8689:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    8690:	e9 4c 07 00 00       	jmp    8de1 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    8695:	8b 45 14             	mov    0x14(%ebp),%eax
    8698:	89 45 e8             	mov    %eax,-0x18(%ebp)
    869b:	eb 22                	jmp    86bf <deflateDynamic+0x1a6>
    869d:	8b 55 90             	mov    -0x70(%ebp),%edx
    86a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    86a3:	2b 45 14             	sub    0x14(%ebp),%eax
    86a6:	c1 e0 02             	shl    $0x2,%eax
    86a9:	01 c2                	add    %eax,%edx
    86ab:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    86ae:	8b 45 10             	mov    0x10(%ebp),%eax
    86b1:	01 c8                	add    %ecx,%eax
    86b3:	0f b6 00             	movzbl (%eax),%eax
    86b6:	0f b6 c0             	movzbl %al,%eax
    86b9:	89 02                	mov    %eax,(%edx)
    86bb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    86bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    86c2:	3b 45 18             	cmp    0x18(%ebp),%eax
    86c5:	7c d6                	jl     869d <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    86c7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    86ce:	eb 60                	jmp    8730 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    86d0:	8b 45 90             	mov    -0x70(%ebp),%eax
    86d3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    86d6:	c1 e2 02             	shl    $0x2,%edx
    86d9:	01 d0                	add    %edx,%eax
    86db:	8b 00                	mov    (%eax),%eax
    86dd:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    86e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    86e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    86ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    86ed:	01 d0                	add    %edx,%eax
    86ef:	8b 10                	mov    (%eax),%edx
    86f1:	83 c2 01             	add    $0x1,%edx
    86f4:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    86f6:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    86fd:	76 2d                	jbe    872c <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    86ff:	8b 45 90             	mov    -0x70(%ebp),%eax
    8702:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8705:	83 c2 02             	add    $0x2,%edx
    8708:	c1 e2 02             	shl    $0x2,%edx
    870b:	01 d0                	add    %edx,%eax
    870d:	8b 00                	mov    (%eax),%eax
    870f:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    8712:	8b 45 bc             	mov    -0x44(%ebp),%eax
    8715:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    871c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    871f:	01 d0                	add    %edx,%eax
    8721:	8b 10                	mov    (%eax),%edx
    8723:	83 c2 01             	add    $0x1,%edx
    8726:	89 10                	mov    %edx,(%eax)
        i += 3;
    8728:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    872c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8730:	8b 45 94             	mov    -0x6c(%ebp),%eax
    8733:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    8736:	75 98                	jne    86d0 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    8738:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    873b:	05 00 04 00 00       	add    $0x400,%eax
    8740:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    8746:	83 ec 0c             	sub    $0xc,%esp
    8749:	6a 0f                	push   $0xf
    874b:	68 1e 01 00 00       	push   $0x11e
    8750:	68 01 01 00 00       	push   $0x101
    8755:	ff 75 d4             	pushl  -0x2c(%ebp)
    8758:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    875e:	50                   	push   %eax
    875f:	e8 e0 e1 ff ff       	call   6944 <HuffmanTree_makeFromFrequencies>
    8764:	83 c4 20             	add    $0x20,%esp
    8767:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    876a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    876e:	0f 85 66 06 00 00    	jne    8dda <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    8774:	83 ec 0c             	sub    $0xc,%esp
    8777:	6a 0f                	push   $0xf
    8779:	6a 1e                	push   $0x1e
    877b:	6a 02                	push   $0x2
    877d:	ff 75 d0             	pushl  -0x30(%ebp)
    8780:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    8786:	50                   	push   %eax
    8787:	e8 b8 e1 ff ff       	call   6944 <HuffmanTree_makeFromFrequencies>
    878c:	83 c4 20             	add    $0x20,%esp
    878f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    8792:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8796:	0f 85 41 06 00 00    	jne    8ddd <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    879c:	8b 45 84             	mov    -0x7c(%ebp),%eax
    879f:	ba 1e 01 00 00       	mov    $0x11e,%edx
    87a4:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    87a9:	0f 47 c2             	cmova  %edx,%eax
    87ac:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    87af:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    87b5:	ba 1e 00 00 00       	mov    $0x1e,%edx
    87ba:	83 f8 1e             	cmp    $0x1e,%eax
    87bd:	0f 47 c2             	cmova  %edx,%eax
    87c0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    87c3:	8b 55 b8             	mov    -0x48(%ebp),%edx
    87c6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    87c9:	01 d0                	add    %edx,%eax
    87cb:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    87ce:	8b 45 b0             	mov    -0x50(%ebp),%eax
    87d1:	c1 e0 02             	shl    $0x2,%eax
    87d4:	83 ec 0c             	sub    $0xc,%esp
    87d7:	50                   	push   %eax
    87d8:	e8 3b c2 ff ff       	call   4a18 <lodepng_malloc>
    87dd:	83 c4 10             	add    $0x10,%esp
    87e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    87e3:	8b 45 b0             	mov    -0x50(%ebp),%eax
    87e6:	c1 e0 02             	shl    $0x2,%eax
    87e9:	83 ec 0c             	sub    $0xc,%esp
    87ec:	50                   	push   %eax
    87ed:	e8 26 c2 ff ff       	call   4a18 <lodepng_malloc>
    87f2:	83 c4 10             	add    $0x10,%esp
    87f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    87f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    87fc:	74 06                	je     8804 <deflateDynamic+0x2eb>
    87fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    8802:	75 0c                	jne    8810 <deflateDynamic+0x2f7>
    8804:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    880b:	e9 d1 05 00 00       	jmp    8de1 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    8810:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    8817:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    881e:	eb 25                	jmp    8845 <deflateDynamic+0x32c>
    8820:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8823:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    882a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    882d:	01 c2                	add    %eax,%edx
    882f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    8835:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    8838:	c1 e1 02             	shl    $0x2,%ecx
    883b:	01 c8                	add    %ecx,%eax
    883d:	8b 00                	mov    (%eax),%eax
    883f:	89 02                	mov    %eax,(%edx)
    8841:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8845:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8848:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    884b:	75 d3                	jne    8820 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    884d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8854:	eb 2a                	jmp    8880 <deflateDynamic+0x367>
    8856:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8859:	8b 45 e8             	mov    -0x18(%ebp),%eax
    885c:	01 d0                	add    %edx,%eax
    885e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8865:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8868:	01 c2                	add    %eax,%edx
    886a:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    8870:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    8873:	c1 e1 02             	shl    $0x2,%ecx
    8876:	01 c8                	add    %ecx,%eax
    8878:	8b 00                	mov    (%eax),%eax
    887a:	89 02                	mov    %eax,(%edx)
    887c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8880:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8883:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    8886:	75 ce                	jne    8856 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    8888:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    888f:	e9 3b 02 00 00       	jmp    8acf <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    8894:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    889b:	eb 04                	jmp    88a1 <deflateDynamic+0x388>
    889d:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    88a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    88a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    88a7:	01 d0                	add    %edx,%eax
    88a9:	8d 50 01             	lea    0x1(%eax),%edx
    88ac:	8b 45 b0             	mov    -0x50(%ebp),%eax
    88af:	39 c2                	cmp    %eax,%edx
    88b1:	73 2e                	jae    88e1 <deflateDynamic+0x3c8>
    88b3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    88b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    88b9:	01 d0                	add    %edx,%eax
    88bb:	83 c0 01             	add    $0x1,%eax
    88be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    88c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88c8:	01 d0                	add    %edx,%eax
    88ca:	8b 10                	mov    (%eax),%edx
    88cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    88cf:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    88d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88d9:	01 c8                	add    %ecx,%eax
    88db:	8b 00                	mov    (%eax),%eax
    88dd:	39 c2                	cmp    %eax,%edx
    88df:	74 bc                	je     889d <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    88e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    88e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    88eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88ee:	01 d0                	add    %edx,%eax
    88f0:	8b 00                	mov    (%eax),%eax
    88f2:	85 c0                	test   %eax,%eax
    88f4:	0f 85 a9 00 00 00    	jne    89a3 <deflateDynamic+0x48a>
    88fa:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    88fe:	0f 86 9f 00 00 00    	jbe    89a3 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    8904:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    8908:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    890c:	77 3a                	ja     8948 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    890e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8911:	8d 50 01             	lea    0x1(%eax),%edx
    8914:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8917:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    891e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8921:	01 d0                	add    %edx,%eax
    8923:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    8929:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    892c:	8d 50 01             	lea    0x1(%eax),%edx
    892f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8932:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8939:	8b 45 ec             	mov    -0x14(%ebp),%eax
    893c:	01 d0                	add    %edx,%eax
    893e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8941:	83 ea 03             	sub    $0x3,%edx
    8944:	89 10                	mov    %edx,(%eax)
    8946:	eb 48                	jmp    8990 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    8948:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    894f:	76 07                	jbe    8958 <deflateDynamic+0x43f>
    8951:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    8958:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    895b:	8d 50 01             	lea    0x1(%eax),%edx
    895e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8961:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8968:	8b 45 ec             	mov    -0x14(%ebp),%eax
    896b:	01 d0                	add    %edx,%eax
    896d:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    8973:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8976:	8d 50 01             	lea    0x1(%eax),%edx
    8979:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    897c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8983:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8986:	01 d0                	add    %edx,%eax
    8988:	8b 55 dc             	mov    -0x24(%ebp),%edx
    898b:	83 ea 0b             	sub    $0xb,%edx
    898e:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    8990:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8993:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8996:	01 d0                	add    %edx,%eax
    8998:	83 e8 01             	sub    $0x1,%eax
    899b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    899e:	e9 28 01 00 00       	jmp    8acb <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    89a3:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    89a7:	0f 86 f6 00 00 00    	jbe    8aa3 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    89ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
    89b0:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    89b5:	f7 e2                	mul    %edx
    89b7:	89 d0                	mov    %edx,%eax
    89b9:	c1 e8 02             	shr    $0x2,%eax
    89bc:	89 45 ac             	mov    %eax,-0x54(%ebp)
    89bf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    89c2:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    89c7:	89 c8                	mov    %ecx,%eax
    89c9:	f7 e2                	mul    %edx
    89cb:	c1 ea 02             	shr    $0x2,%edx
    89ce:	89 d0                	mov    %edx,%eax
    89d0:	01 c0                	add    %eax,%eax
    89d2:	01 d0                	add    %edx,%eax
    89d4:	01 c0                	add    %eax,%eax
    89d6:	29 c1                	sub    %eax,%ecx
    89d8:	89 c8                	mov    %ecx,%eax
    89da:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    89dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    89e0:	8d 50 01             	lea    0x1(%eax),%edx
    89e3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    89e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    89ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    89f0:	01 c2                	add    %eax,%edx
    89f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    89f5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    89fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    89ff:	01 c8                	add    %ecx,%eax
    8a01:	8b 00                	mov    (%eax),%eax
    8a03:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    8a05:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    8a0c:	eb 3a                	jmp    8a48 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    8a0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8a11:	8d 50 01             	lea    0x1(%eax),%edx
    8a14:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8a17:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8a1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8a21:	01 d0                	add    %edx,%eax
    8a23:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    8a29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8a2c:	8d 50 01             	lea    0x1(%eax),%edx
    8a2f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8a32:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8a39:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8a3c:	01 d0                	add    %edx,%eax
    8a3e:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    8a44:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    8a48:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8a4b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    8a4e:	72 be                	jb     8a0e <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    8a50:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    8a54:	76 3a                	jbe    8a90 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    8a56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8a59:	8d 50 01             	lea    0x1(%eax),%edx
    8a5c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8a5f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8a66:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8a69:	01 d0                	add    %edx,%eax
    8a6b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    8a71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8a74:	8d 50 01             	lea    0x1(%eax),%edx
    8a77:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8a7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8a81:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8a84:	01 d0                	add    %edx,%eax
    8a86:	8b 55 a8             	mov    -0x58(%ebp),%edx
    8a89:	83 ea 03             	sub    $0x3,%edx
    8a8c:	89 10                	mov    %edx,(%eax)
    8a8e:	eb 06                	jmp    8a96 <deflateDynamic+0x57d>
        }
        else j -= rest;
    8a90:	8b 45 a8             	mov    -0x58(%ebp),%eax
    8a93:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    8a96:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8a99:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8a9c:	01 d0                	add    %edx,%eax
    8a9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    8aa1:	eb 28                	jmp    8acb <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    8aa3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8aa6:	8d 50 01             	lea    0x1(%eax),%edx
    8aa9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8aac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8ab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8ab6:	01 c2                	add    %eax,%edx
    8ab8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8abb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8ac2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8ac5:	01 c8                	add    %ecx,%eax
    8ac7:	8b 00                	mov    (%eax),%eax
    8ac9:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    8acb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8acf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8ad2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    8ad5:	0f 85 b9 fd ff ff    	jne    8894 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    8adb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8ae2:	eb 42                	jmp    8b26 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    8ae4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8ae7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8aee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8af1:	01 d0                	add    %edx,%eax
    8af3:	8b 00                	mov    (%eax),%eax
    8af5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8afc:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8aff:	01 d0                	add    %edx,%eax
    8b01:	8b 10                	mov    (%eax),%edx
    8b03:	83 c2 01             	add    $0x1,%edx
    8b06:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    8b08:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8b0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8b12:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8b15:	01 d0                	add    %edx,%eax
    8b17:	8b 00                	mov    (%eax),%eax
    8b19:	83 f8 0f             	cmp    $0xf,%eax
    8b1c:	76 04                	jbe    8b22 <deflateDynamic+0x609>
    8b1e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    8b22:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8b26:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8b29:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8b2c:	75 b6                	jne    8ae4 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    8b2e:	83 ec 0c             	sub    $0xc,%esp
    8b31:	6a 07                	push   $0x7
    8b33:	6a 13                	push   $0x13
    8b35:	6a 13                	push   $0x13
    8b37:	ff 75 cc             	pushl  -0x34(%ebp)
    8b3a:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    8b40:	50                   	push   %eax
    8b41:	e8 fe dd ff ff       	call   6944 <HuffmanTree_makeFromFrequencies>
    8b46:	83 c4 20             	add    $0x20,%esp
    8b49:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    8b4c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8b50:	0f 85 8a 02 00 00    	jne    8de0 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    8b56:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    8b5d:	eb 04                	jmp    8b63 <deflateDynamic+0x64a>
      numcodes_cl--;
    8b5f:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    8b63:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8b66:	83 f8 04             	cmp    $0x4,%eax
    8b69:	76 1e                	jbe    8b89 <deflateDynamic+0x670>
    8b6b:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    8b71:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8b74:	83 ea 01             	sub    $0x1,%edx
    8b77:	8b 14 95 20 b6 01 00 	mov    0x1b620(,%edx,4),%edx
    8b7e:	c1 e2 02             	shl    $0x2,%edx
    8b81:	01 d0                	add    %edx,%eax
    8b83:	8b 00                	mov    (%eax),%eax
    8b85:	85 c0                	test   %eax,%eax
    8b87:	74 d6                	je     8b5f <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    8b89:	83 ec 04             	sub    $0x4,%esp
    8b8c:	6a 01                	push   $0x1
    8b8e:	ff 75 c4             	pushl  -0x3c(%ebp)
    8b91:	ff 75 08             	pushl  0x8(%ebp)
    8b94:	e8 67 c3 ff ff       	call   4f00 <writeBits>
    8b99:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    8b9c:	83 ec 04             	sub    $0x4,%esp
    8b9f:	6a 01                	push   $0x1
    8ba1:	6a 00                	push   $0x0
    8ba3:	ff 75 08             	pushl  0x8(%ebp)
    8ba6:	e8 55 c3 ff ff       	call   4f00 <writeBits>
    8bab:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    8bae:	83 ec 04             	sub    $0x4,%esp
    8bb1:	6a 01                	push   $0x1
    8bb3:	6a 01                	push   $0x1
    8bb5:	ff 75 08             	pushl  0x8(%ebp)
    8bb8:	e8 43 c3 ff ff       	call   4f00 <writeBits>
    8bbd:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    8bc0:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8bc3:	2d 01 01 00 00       	sub    $0x101,%eax
    8bc8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    8bcb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    8bce:	83 e8 01             	sub    $0x1,%eax
    8bd1:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    8bd4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8bd7:	83 e8 04             	sub    $0x4,%eax
    8bda:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    8bdd:	83 ec 04             	sub    $0x4,%esp
    8be0:	6a 05                	push   $0x5
    8be2:	ff 75 a4             	pushl  -0x5c(%ebp)
    8be5:	ff 75 08             	pushl  0x8(%ebp)
    8be8:	e8 13 c3 ff ff       	call   4f00 <writeBits>
    8bed:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    8bf0:	83 ec 04             	sub    $0x4,%esp
    8bf3:	6a 05                	push   $0x5
    8bf5:	ff 75 a0             	pushl  -0x60(%ebp)
    8bf8:	ff 75 08             	pushl  0x8(%ebp)
    8bfb:	e8 00 c3 ff ff       	call   4f00 <writeBits>
    8c00:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    8c03:	83 ec 04             	sub    $0x4,%esp
    8c06:	6a 04                	push   $0x4
    8c08:	ff 75 9c             	pushl  -0x64(%ebp)
    8c0b:	ff 75 08             	pushl  0x8(%ebp)
    8c0e:	e8 ed c2 ff ff       	call   4f00 <writeBits>
    8c13:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    8c16:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8c1d:	eb 2c                	jmp    8c4b <deflateDynamic+0x732>
    8c1f:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    8c25:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8c28:	8b 04 85 20 b6 01 00 	mov    0x1b620(,%eax,4),%eax
    8c2f:	c1 e0 02             	shl    $0x2,%eax
    8c32:	01 d0                	add    %edx,%eax
    8c34:	8b 00                	mov    (%eax),%eax
    8c36:	83 ec 04             	sub    $0x4,%esp
    8c39:	6a 03                	push   $0x3
    8c3b:	50                   	push   %eax
    8c3c:	ff 75 08             	pushl  0x8(%ebp)
    8c3f:	e8 bc c2 ff ff       	call   4f00 <writeBits>
    8c44:	83 c4 10             	add    $0x10,%esp
    8c47:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8c4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8c4e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    8c51:	75 cc                	jne    8c1f <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    8c53:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8c5a:	e9 0a 01 00 00       	jmp    8d69 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    8c5f:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    8c65:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8c68:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8c6f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8c72:	01 ca                	add    %ecx,%edx
    8c74:	8b 12                	mov    (%edx),%edx
    8c76:	c1 e2 02             	shl    $0x2,%edx
    8c79:	01 d0                	add    %edx,%eax
    8c7b:	8b 00                	mov    (%eax),%eax
    8c7d:	89 c3                	mov    %eax,%ebx
    8c7f:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    8c85:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8c88:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8c8f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8c92:	01 ca                	add    %ecx,%edx
    8c94:	8b 12                	mov    (%edx),%edx
    8c96:	c1 e2 02             	shl    $0x2,%edx
    8c99:	01 d0                	add    %edx,%eax
    8c9b:	8b 00                	mov    (%eax),%eax
    8c9d:	83 ec 04             	sub    $0x4,%esp
    8ca0:	53                   	push   %ebx
    8ca1:	50                   	push   %eax
    8ca2:	ff 75 08             	pushl  0x8(%ebp)
    8ca5:	e8 ea c3 ff ff       	call   5094 <writeBitsReversed>
    8caa:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    8cad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8cb0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8cb7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8cba:	01 d0                	add    %edx,%eax
    8cbc:	8b 00                	mov    (%eax),%eax
    8cbe:	83 f8 10             	cmp    $0x10,%eax
    8cc1:	75 28                	jne    8ceb <deflateDynamic+0x7d2>
    8cc3:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8cc7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8cca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8cd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8cd4:	01 d0                	add    %edx,%eax
    8cd6:	8b 00                	mov    (%eax),%eax
    8cd8:	83 ec 04             	sub    $0x4,%esp
    8cdb:	6a 02                	push   $0x2
    8cdd:	50                   	push   %eax
    8cde:	ff 75 08             	pushl  0x8(%ebp)
    8ce1:	e8 1a c2 ff ff       	call   4f00 <writeBits>
    8ce6:	83 c4 10             	add    $0x10,%esp
    8ce9:	eb 7a                	jmp    8d65 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    8ceb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8cee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8cf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8cf8:	01 d0                	add    %edx,%eax
    8cfa:	8b 00                	mov    (%eax),%eax
    8cfc:	83 f8 11             	cmp    $0x11,%eax
    8cff:	75 28                	jne    8d29 <deflateDynamic+0x810>
    8d01:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8d05:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8d08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8d0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8d12:	01 d0                	add    %edx,%eax
    8d14:	8b 00                	mov    (%eax),%eax
    8d16:	83 ec 04             	sub    $0x4,%esp
    8d19:	6a 03                	push   $0x3
    8d1b:	50                   	push   %eax
    8d1c:	ff 75 08             	pushl  0x8(%ebp)
    8d1f:	e8 dc c1 ff ff       	call   4f00 <writeBits>
    8d24:	83 c4 10             	add    $0x10,%esp
    8d27:	eb 3c                	jmp    8d65 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    8d29:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8d2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8d33:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8d36:	01 d0                	add    %edx,%eax
    8d38:	8b 00                	mov    (%eax),%eax
    8d3a:	83 f8 12             	cmp    $0x12,%eax
    8d3d:	75 26                	jne    8d65 <deflateDynamic+0x84c>
    8d3f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8d43:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8d46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8d4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8d50:	01 d0                	add    %edx,%eax
    8d52:	8b 00                	mov    (%eax),%eax
    8d54:	83 ec 04             	sub    $0x4,%esp
    8d57:	6a 07                	push   $0x7
    8d59:	50                   	push   %eax
    8d5a:	ff 75 08             	pushl  0x8(%ebp)
    8d5d:	e8 9e c1 ff ff       	call   4f00 <writeBits>
    8d62:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    8d65:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8d69:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8d6c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8d6f:	0f 85 ea fe ff ff    	jne    8c5f <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    8d75:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    8d7b:	50                   	push   %eax
    8d7c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    8d82:	50                   	push   %eax
    8d83:	8d 45 90             	lea    -0x70(%ebp),%eax
    8d86:	50                   	push   %eax
    8d87:	ff 75 08             	pushl  0x8(%ebp)
    8d8a:	e8 4f f6 ff ff       	call   83de <writeLZ77data>
    8d8f:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    8d92:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    8d98:	05 00 04 00 00       	add    $0x400,%eax
    8d9d:	8b 00                	mov    (%eax),%eax
    8d9f:	85 c0                	test   %eax,%eax
    8da1:	75 09                	jne    8dac <deflateDynamic+0x893>
    8da3:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    8daa:	eb 35                	jmp    8de1 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    8dac:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    8db2:	05 00 04 00 00       	add    $0x400,%eax
    8db7:	8b 00                	mov    (%eax),%eax
    8db9:	89 c2                	mov    %eax,%edx
    8dbb:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    8dc1:	05 00 04 00 00       	add    $0x400,%eax
    8dc6:	8b 00                	mov    (%eax),%eax
    8dc8:	83 ec 04             	sub    $0x4,%esp
    8dcb:	52                   	push   %edx
    8dcc:	50                   	push   %eax
    8dcd:	ff 75 08             	pushl  0x8(%ebp)
    8dd0:	e8 bf c2 ff ff       	call   5094 <writeBitsReversed>
    8dd5:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    8dd8:	eb 07                	jmp    8de1 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    8dda:	90                   	nop
    8ddb:	eb 04                	jmp    8de1 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    8ddd:	90                   	nop
    8dde:	eb 01                	jmp    8de1 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    8de0:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    8de1:	83 ec 0c             	sub    $0xc,%esp
    8de4:	8d 45 90             	lea    -0x70(%ebp),%eax
    8de7:	50                   	push   %eax
    8de8:	e8 73 bd ff ff       	call   4b60 <uivector_cleanup>
    8ded:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    8df0:	83 ec 0c             	sub    $0xc,%esp
    8df3:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    8df9:	50                   	push   %eax
    8dfa:	e8 3a cb ff ff       	call   5939 <HuffmanTree_cleanup>
    8dff:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    8e02:	83 ec 0c             	sub    $0xc,%esp
    8e05:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    8e0b:	50                   	push   %eax
    8e0c:	e8 28 cb ff ff       	call   5939 <HuffmanTree_cleanup>
    8e11:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    8e14:	83 ec 0c             	sub    $0xc,%esp
    8e17:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    8e1d:	50                   	push   %eax
    8e1e:	e8 16 cb ff ff       	call   5939 <HuffmanTree_cleanup>
    8e23:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    8e26:	83 ec 0c             	sub    $0xc,%esp
    8e29:	ff 75 d4             	pushl  -0x2c(%ebp)
    8e2c:	e8 08 bc ff ff       	call   4a39 <lodepng_free>
    8e31:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    8e34:	83 ec 0c             	sub    $0xc,%esp
    8e37:	ff 75 d0             	pushl  -0x30(%ebp)
    8e3a:	e8 fa bb ff ff       	call   4a39 <lodepng_free>
    8e3f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    8e42:	83 ec 0c             	sub    $0xc,%esp
    8e45:	ff 75 cc             	pushl  -0x34(%ebp)
    8e48:	e8 ec bb ff ff       	call   4a39 <lodepng_free>
    8e4d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    8e50:	83 ec 0c             	sub    $0xc,%esp
    8e53:	ff 75 f0             	pushl  -0x10(%ebp)
    8e56:	e8 de bb ff ff       	call   4a39 <lodepng_free>
    8e5b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    8e5e:	83 ec 0c             	sub    $0xc,%esp
    8e61:	ff 75 ec             	pushl  -0x14(%ebp)
    8e64:	e8 d0 bb ff ff       	call   4a39 <lodepng_free>
    8e69:	83 c4 10             	add    $0x10,%esp

  return error;
    8e6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8e6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8e72:	c9                   	leave  
    8e73:	c3                   	ret    

00008e74 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    8e74:	55                   	push   %ebp
    8e75:	89 e5                	mov    %esp,%ebp
    8e77:	53                   	push   %ebx
    8e78:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    8e7b:	8b 45 20             	mov    0x20(%ebp),%eax
    8e7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    8e81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    8e88:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8e8b:	50                   	push   %eax
    8e8c:	e8 7b ca ff ff       	call   590c <HuffmanTree_init>
    8e91:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    8e94:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8e97:	50                   	push   %eax
    8e98:	e8 6f ca ff ff       	call   590c <HuffmanTree_init>
    8e9d:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    8ea0:	83 ec 0c             	sub    $0xc,%esp
    8ea3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8ea6:	50                   	push   %eax
    8ea7:	e8 41 db ff ff       	call   69ed <generateFixedLitLenTree>
    8eac:	83 c4 10             	add    $0x10,%esp
    8eaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    8eb2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8eb6:	75 12                	jne    8eca <deflateFixed+0x56>
    8eb8:	83 ec 0c             	sub    $0xc,%esp
    8ebb:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8ebe:	50                   	push   %eax
    8ebf:	e8 30 dc ff ff       	call   6af4 <generateFixedDistanceTree>
    8ec4:	83 c4 10             	add    $0x10,%esp
    8ec7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    8eca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8ece:	0f 85 3a 01 00 00    	jne    900e <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    8ed4:	83 ec 04             	sub    $0x4,%esp
    8ed7:	6a 01                	push   $0x1
    8ed9:	ff 75 ec             	pushl  -0x14(%ebp)
    8edc:	ff 75 08             	pushl  0x8(%ebp)
    8edf:	e8 1c c0 ff ff       	call   4f00 <writeBits>
    8ee4:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    8ee7:	83 ec 04             	sub    $0x4,%esp
    8eea:	6a 01                	push   $0x1
    8eec:	6a 01                	push   $0x1
    8eee:	ff 75 08             	pushl  0x8(%ebp)
    8ef1:	e8 0a c0 ff ff       	call   4f00 <writeBits>
    8ef6:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    8ef9:	83 ec 04             	sub    $0x4,%esp
    8efc:	6a 01                	push   $0x1
    8efe:	6a 00                	push   $0x0
    8f00:	ff 75 08             	pushl  0x8(%ebp)
    8f03:	e8 f8 bf ff ff       	call   4f00 <writeBits>
    8f08:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    8f0b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8f0e:	8b 40 04             	mov    0x4(%eax),%eax
    8f11:	85 c0                	test   %eax,%eax
    8f13:	74 77                	je     8f8c <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    8f15:	83 ec 0c             	sub    $0xc,%esp
    8f18:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8f1b:	50                   	push   %eax
    8f1c:	e8 e8 bc ff ff       	call   4c09 <uivector_init>
    8f21:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    8f24:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8f27:	8b 58 14             	mov    0x14(%eax),%ebx
    8f2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8f2d:	8b 48 10             	mov    0x10(%eax),%ecx
    8f30:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8f33:	8b 50 0c             	mov    0xc(%eax),%edx
    8f36:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8f39:	8b 40 08             	mov    0x8(%eax),%eax
    8f3c:	83 ec 0c             	sub    $0xc,%esp
    8f3f:	53                   	push   %ebx
    8f40:	51                   	push   %ecx
    8f41:	52                   	push   %edx
    8f42:	50                   	push   %eax
    8f43:	ff 75 18             	pushl  0x18(%ebp)
    8f46:	ff 75 14             	pushl  0x14(%ebp)
    8f49:	ff 75 10             	pushl  0x10(%ebp)
    8f4c:	ff 75 0c             	pushl  0xc(%ebp)
    8f4f:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8f52:	50                   	push   %eax
    8f53:	e8 c7 ed ff ff       	call   7d1f <encodeLZ77>
    8f58:	83 c4 30             	add    $0x30,%esp
    8f5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    8f5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8f62:	75 17                	jne    8f7b <deflateFixed+0x107>
    8f64:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8f67:	50                   	push   %eax
    8f68:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8f6b:	50                   	push   %eax
    8f6c:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8f6f:	50                   	push   %eax
    8f70:	ff 75 08             	pushl  0x8(%ebp)
    8f73:	e8 66 f4 ff ff       	call   83de <writeLZ77data>
    8f78:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    8f7b:	83 ec 0c             	sub    $0xc,%esp
    8f7e:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8f81:	50                   	push   %eax
    8f82:	e8 d9 bb ff ff       	call   4b60 <uivector_cleanup>
    8f87:	83 c4 10             	add    $0x10,%esp
    8f8a:	eb 56                	jmp    8fe2 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    8f8c:	8b 45 14             	mov    0x14(%ebp),%eax
    8f8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    8f92:	eb 46                	jmp    8fda <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    8f94:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8f97:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    8f9a:	8b 55 10             	mov    0x10(%ebp),%edx
    8f9d:	01 ca                	add    %ecx,%edx
    8f9f:	0f b6 12             	movzbl (%edx),%edx
    8fa2:	0f b6 d2             	movzbl %dl,%edx
    8fa5:	c1 e2 02             	shl    $0x2,%edx
    8fa8:	01 d0                	add    %edx,%eax
    8faa:	8b 00                	mov    (%eax),%eax
    8fac:	89 c3                	mov    %eax,%ebx
    8fae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8fb1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    8fb4:	8b 55 10             	mov    0x10(%ebp),%edx
    8fb7:	01 ca                	add    %ecx,%edx
    8fb9:	0f b6 12             	movzbl (%edx),%edx
    8fbc:	0f b6 d2             	movzbl %dl,%edx
    8fbf:	c1 e2 02             	shl    $0x2,%edx
    8fc2:	01 d0                	add    %edx,%eax
    8fc4:	8b 00                	mov    (%eax),%eax
    8fc6:	83 ec 04             	sub    $0x4,%esp
    8fc9:	53                   	push   %ebx
    8fca:	50                   	push   %eax
    8fcb:	ff 75 08             	pushl  0x8(%ebp)
    8fce:	e8 c1 c0 ff ff       	call   5094 <writeBitsReversed>
    8fd3:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    8fd6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8fda:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8fdd:	3b 45 18             	cmp    0x18(%ebp),%eax
    8fe0:	7c b2                	jl     8f94 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    8fe2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8fe6:	75 26                	jne    900e <deflateFixed+0x19a>
    8fe8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8feb:	05 00 04 00 00       	add    $0x400,%eax
    8ff0:	8b 00                	mov    (%eax),%eax
    8ff2:	89 c2                	mov    %eax,%edx
    8ff4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8ff7:	05 00 04 00 00       	add    $0x400,%eax
    8ffc:	8b 00                	mov    (%eax),%eax
    8ffe:	83 ec 04             	sub    $0x4,%esp
    9001:	52                   	push   %edx
    9002:	50                   	push   %eax
    9003:	ff 75 08             	pushl  0x8(%ebp)
    9006:	e8 89 c0 ff ff       	call   5094 <writeBitsReversed>
    900b:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    900e:	83 ec 0c             	sub    $0xc,%esp
    9011:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    9014:	50                   	push   %eax
    9015:	e8 1f c9 ff ff       	call   5939 <HuffmanTree_cleanup>
    901a:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    901d:	83 ec 0c             	sub    $0xc,%esp
    9020:	8d 45 bc             	lea    -0x44(%ebp),%eax
    9023:	50                   	push   %eax
    9024:	e8 10 c9 ff ff       	call   5939 <HuffmanTree_cleanup>
    9029:	83 c4 10             	add    $0x10,%esp

  return error;
    902c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    902f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9032:	c9                   	leave  
    9033:	c3                   	ret    

00009034 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    9034:	55                   	push   %ebp
    9035:	89 e5                	mov    %esp,%ebp
    9037:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    903a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    9041:	ff 75 08             	pushl  0x8(%ebp)
    9044:	8d 45 bc             	lea    -0x44(%ebp),%eax
    9047:	50                   	push   %eax
    9048:	e8 9e be ff ff       	call   4eeb <LodePNGBitWriter_init>
    904d:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    9050:	8b 45 14             	mov    0x14(%ebp),%eax
    9053:	8b 00                	mov    (%eax),%eax
    9055:	83 f8 02             	cmp    $0x2,%eax
    9058:	76 0a                	jbe    9064 <lodepng_deflatev+0x30>
    905a:	b8 3d 00 00 00       	mov    $0x3d,%eax
    905f:	e9 68 01 00 00       	jmp    91cc <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    9064:	8b 45 14             	mov    0x14(%ebp),%eax
    9067:	8b 00                	mov    (%eax),%eax
    9069:	85 c0                	test   %eax,%eax
    906b:	75 16                	jne    9083 <lodepng_deflatev+0x4f>
    906d:	ff 75 10             	pushl  0x10(%ebp)
    9070:	ff 75 0c             	pushl  0xc(%ebp)
    9073:	ff 75 08             	pushl  0x8(%ebp)
    9076:	e8 01 f2 ff ff       	call   827c <deflateNoCompression>
    907b:	83 c4 0c             	add    $0xc,%esp
    907e:	e9 49 01 00 00       	jmp    91cc <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    9083:	8b 45 14             	mov    0x14(%ebp),%eax
    9086:	8b 00                	mov    (%eax),%eax
    9088:	83 f8 01             	cmp    $0x1,%eax
    908b:	75 08                	jne    9095 <lodepng_deflatev+0x61>
    908d:	8b 45 10             	mov    0x10(%ebp),%eax
    9090:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9093:	eb 2c                	jmp    90c1 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    9095:	8b 45 10             	mov    0x10(%ebp),%eax
    9098:	c1 e8 03             	shr    $0x3,%eax
    909b:	83 c0 08             	add    $0x8,%eax
    909e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    90a1:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    90a8:	7f 07                	jg     90b1 <lodepng_deflatev+0x7d>
    90aa:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    90b1:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    90b8:	7e 07                	jle    90c1 <lodepng_deflatev+0x8d>
    90ba:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    90c1:	8b 55 10             	mov    0x10(%ebp),%edx
    90c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90c7:	01 d0                	add    %edx,%eax
    90c9:	83 e8 01             	sub    $0x1,%eax
    90cc:	99                   	cltd   
    90cd:	f7 7d ec             	idivl  -0x14(%ebp)
    90d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    90d3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    90d7:	75 07                	jne    90e0 <lodepng_deflatev+0xac>
    90d9:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    90e0:	8b 45 14             	mov    0x14(%ebp),%eax
    90e3:	8b 40 08             	mov    0x8(%eax),%eax
    90e6:	83 ec 08             	sub    $0x8,%esp
    90e9:	50                   	push   %eax
    90ea:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    90ed:	50                   	push   %eax
    90ee:	e8 1c e8 ff ff       	call   790f <hash_init>
    90f3:	83 c4 10             	add    $0x10,%esp
    90f6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    90f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    90fd:	0f 85 b7 00 00 00    	jne    91ba <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    9103:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    910a:	e9 99 00 00 00       	jmp    91a8 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    910f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9112:	83 e8 01             	sub    $0x1,%eax
    9115:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9118:	0f 94 c0             	sete   %al
    911b:	0f b6 c0             	movzbl %al,%eax
    911e:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    9121:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9124:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    9128:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    912b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    912e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9131:	01 d0                	add    %edx,%eax
    9133:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    9136:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9139:	3b 45 10             	cmp    0x10(%ebp),%eax
    913c:	7e 06                	jle    9144 <lodepng_deflatev+0x110>
    913e:	8b 45 10             	mov    0x10(%ebp),%eax
    9141:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    9144:	8b 45 14             	mov    0x14(%ebp),%eax
    9147:	8b 00                	mov    (%eax),%eax
    9149:	83 f8 01             	cmp    $0x1,%eax
    914c:	75 27                	jne    9175 <lodepng_deflatev+0x141>
    914e:	83 ec 04             	sub    $0x4,%esp
    9151:	ff 75 e0             	pushl  -0x20(%ebp)
    9154:	ff 75 14             	pushl  0x14(%ebp)
    9157:	ff 75 e4             	pushl  -0x1c(%ebp)
    915a:	ff 75 dc             	pushl  -0x24(%ebp)
    915d:	ff 75 0c             	pushl  0xc(%ebp)
    9160:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    9163:	50                   	push   %eax
    9164:	8d 45 bc             	lea    -0x44(%ebp),%eax
    9167:	50                   	push   %eax
    9168:	e8 07 fd ff ff       	call   8e74 <deflateFixed>
    916d:	83 c4 20             	add    $0x20,%esp
    9170:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9173:	eb 2f                	jmp    91a4 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    9175:	8b 45 14             	mov    0x14(%ebp),%eax
    9178:	8b 00                	mov    (%eax),%eax
    917a:	83 f8 02             	cmp    $0x2,%eax
    917d:	75 25                	jne    91a4 <lodepng_deflatev+0x170>
    917f:	83 ec 04             	sub    $0x4,%esp
    9182:	ff 75 e0             	pushl  -0x20(%ebp)
    9185:	ff 75 14             	pushl  0x14(%ebp)
    9188:	ff 75 e4             	pushl  -0x1c(%ebp)
    918b:	ff 75 dc             	pushl  -0x24(%ebp)
    918e:	ff 75 0c             	pushl  0xc(%ebp)
    9191:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    9194:	50                   	push   %eax
    9195:	8d 45 bc             	lea    -0x44(%ebp),%eax
    9198:	50                   	push   %eax
    9199:	e8 7b f3 ff ff       	call   8519 <deflateDynamic>
    919e:	83 c4 20             	add    $0x20,%esp
    91a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    91a4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    91a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    91ab:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    91ae:	74 0a                	je     91ba <lodepng_deflatev+0x186>
    91b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    91b4:	0f 84 55 ff ff ff    	je     910f <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    91ba:	83 ec 0c             	sub    $0xc,%esp
    91bd:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    91c0:	50                   	push   %eax
    91c1:	e8 08 e9 ff ff       	call   7ace <hash_cleanup>
    91c6:	83 c4 10             	add    $0x10,%esp

  return error;
    91c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    91cc:	c9                   	leave  
    91cd:	c3                   	ret    

000091ce <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    91ce:	55                   	push   %ebp
    91cf:	89 e5                	mov    %esp,%ebp
    91d1:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    91d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    91d7:	8b 08                	mov    (%eax),%ecx
    91d9:	8b 45 08             	mov    0x8(%ebp),%eax
    91dc:	8b 10                	mov    (%eax),%edx
    91de:	8d 45 e8             	lea    -0x18(%ebp),%eax
    91e1:	51                   	push   %ecx
    91e2:	52                   	push   %edx
    91e3:	50                   	push   %eax
    91e4:	e8 f0 ba ff ff       	call   4cd9 <ucvector_init>
    91e9:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    91ec:	ff 75 18             	pushl  0x18(%ebp)
    91ef:	ff 75 14             	pushl  0x14(%ebp)
    91f2:	ff 75 10             	pushl  0x10(%ebp)
    91f5:	8d 45 e8             	lea    -0x18(%ebp),%eax
    91f8:	50                   	push   %eax
    91f9:	e8 36 fe ff ff       	call   9034 <lodepng_deflatev>
    91fe:	83 c4 10             	add    $0x10,%esp
    9201:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    9204:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9207:	8b 45 08             	mov    0x8(%ebp),%eax
    920a:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    920c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    920f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9212:	89 10                	mov    %edx,(%eax)
  return error;
    9214:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    9217:	c9                   	leave  
    9218:	c3                   	ret    

00009219 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    9219:	55                   	push   %ebp
    921a:	89 e5                	mov    %esp,%ebp
    921c:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    921f:	8b 45 18             	mov    0x18(%ebp),%eax
    9222:	8b 40 1c             	mov    0x1c(%eax),%eax
    9225:	85 c0                	test   %eax,%eax
    9227:	74 34                	je     925d <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    9229:	8b 45 18             	mov    0x18(%ebp),%eax
    922c:	8b 40 1c             	mov    0x1c(%eax),%eax
    922f:	83 ec 0c             	sub    $0xc,%esp
    9232:	ff 75 18             	pushl  0x18(%ebp)
    9235:	ff 75 14             	pushl  0x14(%ebp)
    9238:	ff 75 10             	pushl  0x10(%ebp)
    923b:	ff 75 0c             	pushl  0xc(%ebp)
    923e:	ff 75 08             	pushl  0x8(%ebp)
    9241:	ff d0                	call   *%eax
    9243:	83 c4 20             	add    $0x20,%esp
    9246:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    9249:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    924d:	74 07                	je     9256 <deflate+0x3d>
    924f:	b8 6f 00 00 00       	mov    $0x6f,%eax
    9254:	eb 21                	jmp    9277 <deflate+0x5e>
    9256:	b8 00 00 00 00       	mov    $0x0,%eax
    925b:	eb 1a                	jmp    9277 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    925d:	83 ec 0c             	sub    $0xc,%esp
    9260:	ff 75 18             	pushl  0x18(%ebp)
    9263:	ff 75 14             	pushl  0x14(%ebp)
    9266:	ff 75 10             	pushl  0x10(%ebp)
    9269:	ff 75 0c             	pushl  0xc(%ebp)
    926c:	ff 75 08             	pushl  0x8(%ebp)
    926f:	e8 5a ff ff ff       	call   91ce <lodepng_deflate>
    9274:	83 c4 20             	add    $0x20,%esp
  }
}
    9277:	c9                   	leave  
    9278:	c3                   	ret    

00009279 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    9279:	55                   	push   %ebp
    927a:	89 e5                	mov    %esp,%ebp
    927c:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    927f:	8b 45 08             	mov    0x8(%ebp),%eax
    9282:	0f b7 c0             	movzwl %ax,%eax
    9285:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    9288:	8b 45 08             	mov    0x8(%ebp),%eax
    928b:	c1 e8 10             	shr    $0x10,%eax
    928e:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    9291:	e9 82 00 00 00       	jmp    9318 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    9296:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    929b:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    92a2:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    92a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    92a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92ac:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    92af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    92b6:	eb 1c                	jmp    92d4 <update_adler32+0x5b>
      s1 += (*data++);
    92b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    92bb:	8d 50 01             	lea    0x1(%eax),%edx
    92be:	89 55 0c             	mov    %edx,0xc(%ebp)
    92c1:	0f b6 00             	movzbl (%eax),%eax
    92c4:	0f b6 c0             	movzbl %al,%eax
    92c7:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    92ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    92cd:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    92d0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    92d7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    92da:	75 dc                	jne    92b8 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    92dc:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    92df:	ba 71 80 07 80       	mov    $0x80078071,%edx
    92e4:	89 c8                	mov    %ecx,%eax
    92e6:	f7 e2                	mul    %edx
    92e8:	89 d0                	mov    %edx,%eax
    92ea:	c1 e8 0f             	shr    $0xf,%eax
    92ed:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    92f3:	29 c1                	sub    %eax,%ecx
    92f5:	89 c8                	mov    %ecx,%eax
    92f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    92fa:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    92fd:	ba 71 80 07 80       	mov    $0x80078071,%edx
    9302:	89 c8                	mov    %ecx,%eax
    9304:	f7 e2                	mul    %edx
    9306:	89 d0                	mov    %edx,%eax
    9308:	c1 e8 0f             	shr    $0xf,%eax
    930b:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    9311:	29 c1                	sub    %eax,%ecx
    9313:	89 c8                	mov    %ecx,%eax
    9315:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    9318:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    931c:	0f 85 74 ff ff ff    	jne    9296 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    9322:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9325:	c1 e0 10             	shl    $0x10,%eax
    9328:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    932b:	c9                   	leave  
    932c:	c3                   	ret    

0000932d <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    932d:	55                   	push   %ebp
    932e:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    9330:	ff 75 0c             	pushl  0xc(%ebp)
    9333:	ff 75 08             	pushl  0x8(%ebp)
    9336:	6a 01                	push   $0x1
    9338:	e8 3c ff ff ff       	call   9279 <update_adler32>
    933d:	83 c4 0c             	add    $0xc,%esp
}
    9340:	c9                   	leave  
    9341:	c3                   	ret    

00009342 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    9342:	55                   	push   %ebp
    9343:	89 e5                	mov    %esp,%ebp
    9345:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    9348:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    934f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9353:	7f 0a                	jg     935f <lodepng_zlib_decompressv+0x1d>
    9355:	b8 35 00 00 00       	mov    $0x35,%eax
    935a:	e9 27 01 00 00       	jmp    9486 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    935f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9362:	0f b6 00             	movzbl (%eax),%eax
    9365:	0f b6 c0             	movzbl %al,%eax
    9368:	c1 e0 08             	shl    $0x8,%eax
    936b:	89 c2                	mov    %eax,%edx
    936d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9370:	83 c0 01             	add    $0x1,%eax
    9373:	0f b6 00             	movzbl (%eax),%eax
    9376:	0f b6 c0             	movzbl %al,%eax
    9379:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    937c:	ba 43 08 21 84       	mov    $0x84210843,%edx
    9381:	89 c8                	mov    %ecx,%eax
    9383:	f7 ea                	imul   %edx
    9385:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    9388:	c1 f8 04             	sar    $0x4,%eax
    938b:	89 c2                	mov    %eax,%edx
    938d:	89 c8                	mov    %ecx,%eax
    938f:	c1 f8 1f             	sar    $0x1f,%eax
    9392:	29 c2                	sub    %eax,%edx
    9394:	89 d0                	mov    %edx,%eax
    9396:	89 c2                	mov    %eax,%edx
    9398:	c1 e2 05             	shl    $0x5,%edx
    939b:	29 c2                	sub    %eax,%edx
    939d:	89 c8                	mov    %ecx,%eax
    939f:	29 d0                	sub    %edx,%eax
    93a1:	85 c0                	test   %eax,%eax
    93a3:	74 0a                	je     93af <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    93a5:	b8 18 00 00 00       	mov    $0x18,%eax
    93aa:	e9 d7 00 00 00       	jmp    9486 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    93af:	8b 45 0c             	mov    0xc(%ebp),%eax
    93b2:	0f b6 00             	movzbl (%eax),%eax
    93b5:	0f b6 c0             	movzbl %al,%eax
    93b8:	83 e0 0f             	and    $0xf,%eax
    93bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    93be:	8b 45 0c             	mov    0xc(%ebp),%eax
    93c1:	0f b6 00             	movzbl (%eax),%eax
    93c4:	c0 e8 04             	shr    $0x4,%al
    93c7:	0f b6 c0             	movzbl %al,%eax
    93ca:	83 e0 0f             	and    $0xf,%eax
    93cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    93d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    93d3:	83 c0 01             	add    $0x1,%eax
    93d6:	0f b6 00             	movzbl (%eax),%eax
    93d9:	c0 e8 05             	shr    $0x5,%al
    93dc:	0f b6 c0             	movzbl %al,%eax
    93df:	83 e0 01             	and    $0x1,%eax
    93e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    93e5:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    93e9:	75 06                	jne    93f1 <lodepng_zlib_decompressv+0xaf>
    93eb:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    93ef:	76 0a                	jbe    93fb <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    93f1:	b8 19 00 00 00       	mov    $0x19,%eax
    93f6:	e9 8b 00 00 00       	jmp    9486 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    93fb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    93ff:	74 07                	je     9408 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    9401:	b8 1a 00 00 00       	mov    $0x1a,%eax
    9406:	eb 7e                	jmp    9486 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    9408:	8b 45 10             	mov    0x10(%ebp),%eax
    940b:	8d 50 fe             	lea    -0x2(%eax),%edx
    940e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9411:	83 c0 02             	add    $0x2,%eax
    9414:	ff 75 14             	pushl  0x14(%ebp)
    9417:	52                   	push   %edx
    9418:	50                   	push   %eax
    9419:	ff 75 08             	pushl  0x8(%ebp)
    941c:	e8 09 e3 ff ff       	call   772a <inflatev>
    9421:	83 c4 10             	add    $0x10,%esp
    9424:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    9427:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    942b:	74 05                	je     9432 <lodepng_zlib_decompressv+0xf0>
    942d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9430:	eb 54                	jmp    9486 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    9432:	8b 45 14             	mov    0x14(%ebp),%eax
    9435:	8b 00                	mov    (%eax),%eax
    9437:	85 c0                	test   %eax,%eax
    9439:	75 46                	jne    9481 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    943b:	8b 45 10             	mov    0x10(%ebp),%eax
    943e:	8d 50 fc             	lea    -0x4(%eax),%edx
    9441:	8b 45 0c             	mov    0xc(%ebp),%eax
    9444:	01 d0                	add    %edx,%eax
    9446:	83 ec 0c             	sub    $0xc,%esp
    9449:	50                   	push   %eax
    944a:	e8 47 b9 ff ff       	call   4d96 <lodepng_read32bitInt>
    944f:	83 c4 10             	add    $0x10,%esp
    9452:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    9455:	8b 45 08             	mov    0x8(%ebp),%eax
    9458:	8b 40 04             	mov    0x4(%eax),%eax
    945b:	89 c2                	mov    %eax,%edx
    945d:	8b 45 08             	mov    0x8(%ebp),%eax
    9460:	8b 00                	mov    (%eax),%eax
    9462:	83 ec 08             	sub    $0x8,%esp
    9465:	52                   	push   %edx
    9466:	50                   	push   %eax
    9467:	e8 c1 fe ff ff       	call   932d <adler32>
    946c:	83 c4 10             	add    $0x10,%esp
    946f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    9472:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9475:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    9478:	74 07                	je     9481 <lodepng_zlib_decompressv+0x13f>
    947a:	b8 3a 00 00 00       	mov    $0x3a,%eax
    947f:	eb 05                	jmp    9486 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    9481:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9486:	c9                   	leave  
    9487:	c3                   	ret    

00009488 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    9488:	55                   	push   %ebp
    9489:	89 e5                	mov    %esp,%ebp
    948b:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    948e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9491:	8b 08                	mov    (%eax),%ecx
    9493:	8b 45 08             	mov    0x8(%ebp),%eax
    9496:	8b 10                	mov    (%eax),%edx
    9498:	8d 45 e8             	lea    -0x18(%ebp),%eax
    949b:	51                   	push   %ecx
    949c:	52                   	push   %edx
    949d:	50                   	push   %eax
    949e:	e8 36 b8 ff ff       	call   4cd9 <ucvector_init>
    94a3:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    94a6:	ff 75 18             	pushl  0x18(%ebp)
    94a9:	ff 75 14             	pushl  0x14(%ebp)
    94ac:	ff 75 10             	pushl  0x10(%ebp)
    94af:	8d 45 e8             	lea    -0x18(%ebp),%eax
    94b2:	50                   	push   %eax
    94b3:	e8 8a fe ff ff       	call   9342 <lodepng_zlib_decompressv>
    94b8:	83 c4 10             	add    $0x10,%esp
    94bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    94be:	8b 55 e8             	mov    -0x18(%ebp),%edx
    94c1:	8b 45 08             	mov    0x8(%ebp),%eax
    94c4:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    94c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    94c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    94cc:	89 10                	mov    %edx,(%eax)
  return error;
    94ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    94d1:	c9                   	leave  
    94d2:	c3                   	ret    

000094d3 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    94d3:	55                   	push   %ebp
    94d4:	89 e5                	mov    %esp,%ebp
    94d6:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    94d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    94dc:	8b 40 0c             	mov    0xc(%eax),%eax
    94df:	85 c0                	test   %eax,%eax
    94e1:	74 57                	je     953a <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    94e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    94e6:	8b 40 0c             	mov    0xc(%eax),%eax
    94e9:	83 ec 0c             	sub    $0xc,%esp
    94ec:	ff 75 1c             	pushl  0x1c(%ebp)
    94ef:	ff 75 18             	pushl  0x18(%ebp)
    94f2:	ff 75 14             	pushl  0x14(%ebp)
    94f5:	ff 75 0c             	pushl  0xc(%ebp)
    94f8:	ff 75 08             	pushl  0x8(%ebp)
    94fb:	ff d0                	call   *%eax
    94fd:	83 c4 20             	add    $0x20,%esp
    9500:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    9503:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9507:	0f 84 98 00 00 00    	je     95a5 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    950d:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    9514:	8b 45 1c             	mov    0x1c(%ebp),%eax
    9517:	8b 40 08             	mov    0x8(%eax),%eax
    951a:	85 c0                	test   %eax,%eax
    951c:	0f 84 83 00 00 00    	je     95a5 <zlib_decompress+0xd2>
    9522:	8b 45 0c             	mov    0xc(%ebp),%eax
    9525:	8b 10                	mov    (%eax),%edx
    9527:	8b 45 1c             	mov    0x1c(%ebp),%eax
    952a:	8b 40 08             	mov    0x8(%eax),%eax
    952d:	39 c2                	cmp    %eax,%edx
    952f:	7e 74                	jle    95a5 <zlib_decompress+0xd2>
    9531:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    9538:	eb 6b                	jmp    95a5 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    953a:	8b 45 0c             	mov    0xc(%ebp),%eax
    953d:	8b 08                	mov    (%eax),%ecx
    953f:	8b 45 08             	mov    0x8(%ebp),%eax
    9542:	8b 10                	mov    (%eax),%edx
    9544:	8d 45 e8             	lea    -0x18(%ebp),%eax
    9547:	83 ec 04             	sub    $0x4,%esp
    954a:	51                   	push   %ecx
    954b:	52                   	push   %edx
    954c:	50                   	push   %eax
    954d:	e8 87 b7 ff ff       	call   4cd9 <ucvector_init>
    9552:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    9555:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    9559:	74 22                	je     957d <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    955b:	8b 45 0c             	mov    0xc(%ebp),%eax
    955e:	8b 10                	mov    (%eax),%edx
    9560:	8b 45 10             	mov    0x10(%ebp),%eax
    9563:	01 d0                	add    %edx,%eax
    9565:	83 ec 08             	sub    $0x8,%esp
    9568:	50                   	push   %eax
    9569:	8d 45 e8             	lea    -0x18(%ebp),%eax
    956c:	50                   	push   %eax
    956d:	e8 00 b7 ff ff       	call   4c72 <ucvector_resize>
    9572:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    9575:	8b 45 0c             	mov    0xc(%ebp),%eax
    9578:	8b 00                	mov    (%eax),%eax
    957a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    957d:	ff 75 1c             	pushl  0x1c(%ebp)
    9580:	ff 75 18             	pushl  0x18(%ebp)
    9583:	ff 75 14             	pushl  0x14(%ebp)
    9586:	8d 45 e8             	lea    -0x18(%ebp),%eax
    9589:	50                   	push   %eax
    958a:	e8 b3 fd ff ff       	call   9342 <lodepng_zlib_decompressv>
    958f:	83 c4 10             	add    $0x10,%esp
    9592:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    9595:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9598:	8b 45 08             	mov    0x8(%ebp),%eax
    959b:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    959d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    95a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    95a3:	89 10                	mov    %edx,(%eax)
  }
  return error;
    95a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    95a8:	c9                   	leave  
    95a9:	c3                   	ret    

000095aa <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    95aa:	55                   	push   %ebp
    95ab:	89 e5                	mov    %esp,%ebp
    95ad:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    95b0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    95b7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    95be:	83 ec 0c             	sub    $0xc,%esp
    95c1:	ff 75 18             	pushl  0x18(%ebp)
    95c4:	ff 75 14             	pushl  0x14(%ebp)
    95c7:	ff 75 10             	pushl  0x10(%ebp)
    95ca:	8d 45 d0             	lea    -0x30(%ebp),%eax
    95cd:	50                   	push   %eax
    95ce:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    95d1:	50                   	push   %eax
    95d2:	e8 42 fc ff ff       	call   9219 <deflate>
    95d7:	83 c4 20             	add    $0x20,%esp
    95da:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    95dd:	8b 45 08             	mov    0x8(%ebp),%eax
    95e0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    95e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    95e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    95ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    95f3:	75 33                	jne    9628 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    95f5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    95f8:	8d 50 06             	lea    0x6(%eax),%edx
    95fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    95fe:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    9600:	8b 45 0c             	mov    0xc(%ebp),%eax
    9603:	8b 00                	mov    (%eax),%eax
    9605:	83 ec 0c             	sub    $0xc,%esp
    9608:	50                   	push   %eax
    9609:	e8 0a b4 ff ff       	call   4a18 <lodepng_malloc>
    960e:	83 c4 10             	add    $0x10,%esp
    9611:	89 c2                	mov    %eax,%edx
    9613:	8b 45 08             	mov    0x8(%ebp),%eax
    9616:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    9618:	8b 45 08             	mov    0x8(%ebp),%eax
    961b:	8b 00                	mov    (%eax),%eax
    961d:	85 c0                	test   %eax,%eax
    961f:	75 07                	jne    9628 <lodepng_zlib_compress+0x7e>
    9621:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    9628:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    962c:	0f 85 e2 00 00 00    	jne    9714 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    9632:	8b 45 14             	mov    0x14(%ebp),%eax
    9635:	83 ec 08             	sub    $0x8,%esp
    9638:	50                   	push   %eax
    9639:	ff 75 10             	pushl  0x10(%ebp)
    963c:	e8 ec fc ff ff       	call   932d <adler32>
    9641:	83 c4 10             	add    $0x10,%esp
    9644:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    9647:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    964e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    9655:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    965c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    965f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9666:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9669:	01 d0                	add    %edx,%eax
    966b:	8d 14 00             	lea    (%eax,%eax,1),%edx
    966e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9671:	01 d0                	add    %edx,%eax
    9673:	c1 e0 05             	shl    $0x5,%eax
    9676:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    9679:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    967c:	ba 85 10 42 08       	mov    $0x8421085,%edx
    9681:	89 c8                	mov    %ecx,%eax
    9683:	f7 e2                	mul    %edx
    9685:	89 c8                	mov    %ecx,%eax
    9687:	29 d0                	sub    %edx,%eax
    9689:	d1 e8                	shr    %eax
    968b:	01 d0                	add    %edx,%eax
    968d:	c1 e8 04             	shr    $0x4,%eax
    9690:	89 c2                	mov    %eax,%edx
    9692:	c1 e2 05             	shl    $0x5,%edx
    9695:	29 c2                	sub    %eax,%edx
    9697:	89 c8                	mov    %ecx,%eax
    9699:	29 d0                	sub    %edx,%eax
    969b:	ba 1f 00 00 00       	mov    $0x1f,%edx
    96a0:	29 c2                	sub    %eax,%edx
    96a2:	89 d0                	mov    %edx,%eax
    96a4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    96a7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    96aa:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    96ad:	8b 45 08             	mov    0x8(%ebp),%eax
    96b0:	8b 00                	mov    (%eax),%eax
    96b2:	8b 55 dc             	mov    -0x24(%ebp),%edx
    96b5:	c1 ea 08             	shr    $0x8,%edx
    96b8:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    96ba:	8b 45 08             	mov    0x8(%ebp),%eax
    96bd:	8b 00                	mov    (%eax),%eax
    96bf:	83 c0 01             	add    $0x1,%eax
    96c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
    96c5:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    96c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    96ce:	eb 1e                	jmp    96ee <lodepng_zlib_compress+0x144>
    96d0:	8b 45 08             	mov    0x8(%ebp),%eax
    96d3:	8b 00                	mov    (%eax),%eax
    96d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96d8:	83 c2 02             	add    $0x2,%edx
    96db:	01 c2                	add    %eax,%edx
    96dd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    96e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    96e3:	01 c8                	add    %ecx,%eax
    96e5:	0f b6 00             	movzbl (%eax),%eax
    96e8:	88 02                	mov    %al,(%edx)
    96ea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    96ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
    96f1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    96f4:	75 da                	jne    96d0 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    96f6:	8b 45 08             	mov    0x8(%ebp),%eax
    96f9:	8b 10                	mov    (%eax),%edx
    96fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    96fe:	8b 00                	mov    (%eax),%eax
    9700:	83 e8 04             	sub    $0x4,%eax
    9703:	01 d0                	add    %edx,%eax
    9705:	83 ec 08             	sub    $0x8,%esp
    9708:	ff 75 ec             	pushl  -0x14(%ebp)
    970b:	50                   	push   %eax
    970c:	e8 c8 b6 ff ff       	call   4dd9 <lodepng_set32bitInt>
    9711:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    9714:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    9717:	83 ec 0c             	sub    $0xc,%esp
    971a:	50                   	push   %eax
    971b:	e8 19 b3 ff ff       	call   4a39 <lodepng_free>
    9720:	83 c4 10             	add    $0x10,%esp
  return error;
    9723:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    9726:	c9                   	leave  
    9727:	c3                   	ret    

00009728 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    9728:	55                   	push   %ebp
    9729:	89 e5                	mov    %esp,%ebp
    972b:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    972e:	8b 45 18             	mov    0x18(%ebp),%eax
    9731:	8b 40 18             	mov    0x18(%eax),%eax
    9734:	85 c0                	test   %eax,%eax
    9736:	74 34                	je     976c <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    9738:	8b 45 18             	mov    0x18(%ebp),%eax
    973b:	8b 40 18             	mov    0x18(%eax),%eax
    973e:	83 ec 0c             	sub    $0xc,%esp
    9741:	ff 75 18             	pushl  0x18(%ebp)
    9744:	ff 75 14             	pushl  0x14(%ebp)
    9747:	ff 75 10             	pushl  0x10(%ebp)
    974a:	ff 75 0c             	pushl  0xc(%ebp)
    974d:	ff 75 08             	pushl  0x8(%ebp)
    9750:	ff d0                	call   *%eax
    9752:	83 c4 20             	add    $0x20,%esp
    9755:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    9758:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    975c:	74 07                	je     9765 <zlib_compress+0x3d>
    975e:	b8 6f 00 00 00       	mov    $0x6f,%eax
    9763:	eb 21                	jmp    9786 <zlib_compress+0x5e>
    9765:	b8 00 00 00 00       	mov    $0x0,%eax
    976a:	eb 1a                	jmp    9786 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    976c:	83 ec 0c             	sub    $0xc,%esp
    976f:	ff 75 18             	pushl  0x18(%ebp)
    9772:	ff 75 14             	pushl  0x14(%ebp)
    9775:	ff 75 10             	pushl  0x10(%ebp)
    9778:	ff 75 0c             	pushl  0xc(%ebp)
    977b:	ff 75 08             	pushl  0x8(%ebp)
    977e:	e8 27 fe ff ff       	call   95aa <lodepng_zlib_compress>
    9783:	83 c4 20             	add    $0x20,%esp
  }
}
    9786:	c9                   	leave  
    9787:	c3                   	ret    

00009788 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    9788:	55                   	push   %ebp
    9789:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    978b:	8b 45 08             	mov    0x8(%ebp),%eax
    978e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    9794:	8b 45 08             	mov    0x8(%ebp),%eax
    9797:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    979e:	8b 45 08             	mov    0x8(%ebp),%eax
    97a1:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    97a8:	8b 45 08             	mov    0x8(%ebp),%eax
    97ab:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    97b2:	8b 45 08             	mov    0x8(%ebp),%eax
    97b5:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    97bc:	8b 45 08             	mov    0x8(%ebp),%eax
    97bf:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    97c6:	8b 45 08             	mov    0x8(%ebp),%eax
    97c9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    97d0:	8b 45 08             	mov    0x8(%ebp),%eax
    97d3:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    97da:	8b 45 08             	mov    0x8(%ebp),%eax
    97dd:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    97e4:	90                   	nop
    97e5:	5d                   	pop    %ebp
    97e6:	c3                   	ret    

000097e7 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    97e7:	55                   	push   %ebp
    97e8:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    97ea:	8b 45 08             	mov    0x8(%ebp),%eax
    97ed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    97f3:	8b 45 08             	mov    0x8(%ebp),%eax
    97f6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    97fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9800:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    9807:	8b 45 08             	mov    0x8(%ebp),%eax
    980a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    9811:	8b 45 08             	mov    0x8(%ebp),%eax
    9814:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    981b:	8b 45 08             	mov    0x8(%ebp),%eax
    981e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    9825:	90                   	nop
    9826:	5d                   	pop    %ebp
    9827:	c3                   	ret    

00009828 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    9828:	55                   	push   %ebp
    9829:	89 e5                	mov    %esp,%ebp
    982b:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    982e:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    9835:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    983c:	eb 2a                	jmp    9868 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    983e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9841:	8b 45 08             	mov    0x8(%ebp),%eax
    9844:	01 d0                	add    %edx,%eax
    9846:	0f b6 00             	movzbl (%eax),%eax
    9849:	0f b6 c0             	movzbl %al,%eax
    984c:	33 45 fc             	xor    -0x4(%ebp),%eax
    984f:	0f b6 c0             	movzbl %al,%eax
    9852:	8b 04 85 e0 f8 01 00 	mov    0x1f8e0(,%eax,4),%eax
    9859:	8b 55 fc             	mov    -0x4(%ebp),%edx
    985c:	c1 ea 08             	shr    $0x8,%edx
    985f:	31 d0                	xor    %edx,%eax
    9861:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    9864:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9868:	8b 45 f8             	mov    -0x8(%ebp),%eax
    986b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    986e:	7c ce                	jl     983e <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    9870:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9873:	f7 d0                	not    %eax
}
    9875:	c9                   	leave  
    9876:	c3                   	ret    

00009877 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    9877:	55                   	push   %ebp
    9878:	89 e5                	mov    %esp,%ebp
    987a:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    987d:	8b 45 08             	mov    0x8(%ebp),%eax
    9880:	8b 00                	mov    (%eax),%eax
    9882:	c1 f8 03             	sar    $0x3,%eax
    9885:	89 c2                	mov    %eax,%edx
    9887:	8b 45 0c             	mov    0xc(%ebp),%eax
    988a:	01 d0                	add    %edx,%eax
    988c:	0f b6 00             	movzbl (%eax),%eax
    988f:	0f b6 d0             	movzbl %al,%edx
    9892:	8b 45 08             	mov    0x8(%ebp),%eax
    9895:	8b 00                	mov    (%eax),%eax
    9897:	f7 d0                	not    %eax
    9899:	83 e0 07             	and    $0x7,%eax
    989c:	89 c1                	mov    %eax,%ecx
    989e:	d3 fa                	sar    %cl,%edx
    98a0:	89 d0                	mov    %edx,%eax
    98a2:	83 e0 01             	and    $0x1,%eax
    98a5:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    98a8:	8b 45 08             	mov    0x8(%ebp),%eax
    98ab:	8b 00                	mov    (%eax),%eax
    98ad:	8d 50 01             	lea    0x1(%eax),%edx
    98b0:	8b 45 08             	mov    0x8(%ebp),%eax
    98b3:	89 10                	mov    %edx,(%eax)
  return result;
    98b5:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    98b9:	c9                   	leave  
    98ba:	c3                   	ret    

000098bb <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    98bb:	55                   	push   %ebp
    98bc:	89 e5                	mov    %esp,%ebp
    98be:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    98c1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    98c8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    98cf:	eb 1b                	jmp    98ec <readBitsFromReversedStream+0x31>
    result <<= 1u;
    98d1:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    98d4:	ff 75 0c             	pushl  0xc(%ebp)
    98d7:	ff 75 08             	pushl  0x8(%ebp)
    98da:	e8 98 ff ff ff       	call   9877 <readBitFromReversedStream>
    98df:	83 c4 08             	add    $0x8,%esp
    98e2:	0f b6 c0             	movzbl %al,%eax
    98e5:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    98e8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    98ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
    98ef:	3b 45 10             	cmp    0x10(%ebp),%eax
    98f2:	7c dd                	jl     98d1 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    98f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    98f7:	c9                   	leave  
    98f8:	c3                   	ret    

000098f9 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    98f9:	55                   	push   %ebp
    98fa:	89 e5                	mov    %esp,%ebp
    98fc:	56                   	push   %esi
    98fd:	53                   	push   %ebx
    98fe:	83 ec 04             	sub    $0x4,%esp
    9901:	8b 45 10             	mov    0x10(%ebp),%eax
    9904:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    9907:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    990b:	75 3e                	jne    994b <setBitOfReversedStream+0x52>
    990d:	8b 45 08             	mov    0x8(%ebp),%eax
    9910:	8b 00                	mov    (%eax),%eax
    9912:	c1 f8 03             	sar    $0x3,%eax
    9915:	89 c2                	mov    %eax,%edx
    9917:	8b 45 0c             	mov    0xc(%ebp),%eax
    991a:	01 c2                	add    %eax,%edx
    991c:	8b 45 08             	mov    0x8(%ebp),%eax
    991f:	8b 00                	mov    (%eax),%eax
    9921:	c1 f8 03             	sar    $0x3,%eax
    9924:	89 c1                	mov    %eax,%ecx
    9926:	8b 45 0c             	mov    0xc(%ebp),%eax
    9929:	01 c8                	add    %ecx,%eax
    992b:	0f b6 18             	movzbl (%eax),%ebx
    992e:	8b 45 08             	mov    0x8(%ebp),%eax
    9931:	8b 00                	mov    (%eax),%eax
    9933:	f7 d0                	not    %eax
    9935:	83 e0 07             	and    $0x7,%eax
    9938:	be 01 00 00 00       	mov    $0x1,%esi
    993d:	89 c1                	mov    %eax,%ecx
    993f:	d3 e6                	shl    %cl,%esi
    9941:	89 f0                	mov    %esi,%eax
    9943:	f7 d0                	not    %eax
    9945:	21 d8                	and    %ebx,%eax
    9947:	88 02                	mov    %al,(%edx)
    9949:	eb 3a                	jmp    9985 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    994b:	8b 45 08             	mov    0x8(%ebp),%eax
    994e:	8b 00                	mov    (%eax),%eax
    9950:	c1 f8 03             	sar    $0x3,%eax
    9953:	89 c2                	mov    %eax,%edx
    9955:	8b 45 0c             	mov    0xc(%ebp),%eax
    9958:	01 c2                	add    %eax,%edx
    995a:	8b 45 08             	mov    0x8(%ebp),%eax
    995d:	8b 00                	mov    (%eax),%eax
    995f:	c1 f8 03             	sar    $0x3,%eax
    9962:	89 c1                	mov    %eax,%ecx
    9964:	8b 45 0c             	mov    0xc(%ebp),%eax
    9967:	01 c8                	add    %ecx,%eax
    9969:	0f b6 18             	movzbl (%eax),%ebx
    996c:	8b 45 08             	mov    0x8(%ebp),%eax
    996f:	8b 00                	mov    (%eax),%eax
    9971:	f7 d0                	not    %eax
    9973:	83 e0 07             	and    $0x7,%eax
    9976:	be 01 00 00 00       	mov    $0x1,%esi
    997b:	89 c1                	mov    %eax,%ecx
    997d:	d3 e6                	shl    %cl,%esi
    997f:	89 f0                	mov    %esi,%eax
    9981:	09 d8                	or     %ebx,%eax
    9983:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    9985:	8b 45 08             	mov    0x8(%ebp),%eax
    9988:	8b 00                	mov    (%eax),%eax
    998a:	8d 50 01             	lea    0x1(%eax),%edx
    998d:	8b 45 08             	mov    0x8(%ebp),%eax
    9990:	89 10                	mov    %edx,(%eax)
}
    9992:	90                   	nop
    9993:	83 c4 04             	add    $0x4,%esp
    9996:	5b                   	pop    %ebx
    9997:	5e                   	pop    %esi
    9998:	5d                   	pop    %ebp
    9999:	c3                   	ret    

0000999a <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    999a:	55                   	push   %ebp
    999b:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    999d:	ff 75 08             	pushl  0x8(%ebp)
    99a0:	e8 f1 b3 ff ff       	call   4d96 <lodepng_read32bitInt>
    99a5:	83 c4 04             	add    $0x4,%esp
}
    99a8:	c9                   	leave  
    99a9:	c3                   	ret    

000099aa <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    99aa:	55                   	push   %ebp
    99ab:	89 e5                	mov    %esp,%ebp
    99ad:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    99b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    99b7:	eb 1c                	jmp    99d5 <lodepng_chunk_type+0x2b>
    99b9:	8b 55 08             	mov    0x8(%ebp),%edx
    99bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    99bf:	01 d0                	add    %edx,%eax
    99c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    99c4:	8d 4a 04             	lea    0x4(%edx),%ecx
    99c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    99ca:	01 ca                	add    %ecx,%edx
    99cc:	0f b6 12             	movzbl (%edx),%edx
    99cf:	88 10                	mov    %dl,(%eax)
    99d1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    99d5:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    99d9:	75 de                	jne    99b9 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    99db:	8b 45 08             	mov    0x8(%ebp),%eax
    99de:	83 c0 04             	add    $0x4,%eax
    99e1:	c6 00 00             	movb   $0x0,(%eax)
}
    99e4:	90                   	nop
    99e5:	c9                   	leave  
    99e6:	c3                   	ret    

000099e7 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    99e7:	55                   	push   %ebp
    99e8:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    99ea:	ff 75 0c             	pushl  0xc(%ebp)
    99ed:	e8 c2 b0 ff ff       	call   4ab4 <lodepng_strlen>
    99f2:	83 c4 04             	add    $0x4,%esp
    99f5:	83 f8 04             	cmp    $0x4,%eax
    99f8:	74 07                	je     9a01 <lodepng_chunk_type_equals+0x1a>
    99fa:	b8 00 00 00 00       	mov    $0x0,%eax
    99ff:	eb 79                	jmp    9a7a <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    9a01:	8b 45 08             	mov    0x8(%ebp),%eax
    9a04:	83 c0 04             	add    $0x4,%eax
    9a07:	0f b6 00             	movzbl (%eax),%eax
    9a0a:	0f b6 d0             	movzbl %al,%edx
    9a0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a10:	0f b6 00             	movzbl (%eax),%eax
    9a13:	0f be c0             	movsbl %al,%eax
    9a16:	39 c2                	cmp    %eax,%edx
    9a18:	75 5b                	jne    9a75 <lodepng_chunk_type_equals+0x8e>
    9a1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1d:	83 c0 05             	add    $0x5,%eax
    9a20:	0f b6 00             	movzbl (%eax),%eax
    9a23:	0f b6 d0             	movzbl %al,%edx
    9a26:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a29:	83 c0 01             	add    $0x1,%eax
    9a2c:	0f b6 00             	movzbl (%eax),%eax
    9a2f:	0f be c0             	movsbl %al,%eax
    9a32:	39 c2                	cmp    %eax,%edx
    9a34:	75 3f                	jne    9a75 <lodepng_chunk_type_equals+0x8e>
    9a36:	8b 45 08             	mov    0x8(%ebp),%eax
    9a39:	83 c0 06             	add    $0x6,%eax
    9a3c:	0f b6 00             	movzbl (%eax),%eax
    9a3f:	0f b6 d0             	movzbl %al,%edx
    9a42:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a45:	83 c0 02             	add    $0x2,%eax
    9a48:	0f b6 00             	movzbl (%eax),%eax
    9a4b:	0f be c0             	movsbl %al,%eax
    9a4e:	39 c2                	cmp    %eax,%edx
    9a50:	75 23                	jne    9a75 <lodepng_chunk_type_equals+0x8e>
    9a52:	8b 45 08             	mov    0x8(%ebp),%eax
    9a55:	83 c0 07             	add    $0x7,%eax
    9a58:	0f b6 00             	movzbl (%eax),%eax
    9a5b:	0f b6 d0             	movzbl %al,%edx
    9a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a61:	83 c0 03             	add    $0x3,%eax
    9a64:	0f b6 00             	movzbl (%eax),%eax
    9a67:	0f be c0             	movsbl %al,%eax
    9a6a:	39 c2                	cmp    %eax,%edx
    9a6c:	75 07                	jne    9a75 <lodepng_chunk_type_equals+0x8e>
    9a6e:	b8 01 00 00 00       	mov    $0x1,%eax
    9a73:	eb 05                	jmp    9a7a <lodepng_chunk_type_equals+0x93>
    9a75:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a7a:	c9                   	leave  
    9a7b:	c3                   	ret    

00009a7c <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    9a7c:	55                   	push   %ebp
    9a7d:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    9a7f:	8b 45 08             	mov    0x8(%ebp),%eax
    9a82:	83 c0 04             	add    $0x4,%eax
    9a85:	0f b6 00             	movzbl (%eax),%eax
    9a88:	0f b6 c0             	movzbl %al,%eax
    9a8b:	83 e0 20             	and    $0x20,%eax
    9a8e:	85 c0                	test   %eax,%eax
    9a90:	0f 95 c0             	setne  %al
}
    9a93:	5d                   	pop    %ebp
    9a94:	c3                   	ret    

00009a95 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    9a95:	55                   	push   %ebp
    9a96:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    9a98:	8b 45 08             	mov    0x8(%ebp),%eax
    9a9b:	83 c0 06             	add    $0x6,%eax
    9a9e:	0f b6 00             	movzbl (%eax),%eax
    9aa1:	0f b6 c0             	movzbl %al,%eax
    9aa4:	83 e0 20             	and    $0x20,%eax
    9aa7:	85 c0                	test   %eax,%eax
    9aa9:	0f 95 c0             	setne  %al
}
    9aac:	5d                   	pop    %ebp
    9aad:	c3                   	ret    

00009aae <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    9aae:	55                   	push   %ebp
    9aaf:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    9ab1:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab4:	83 c0 07             	add    $0x7,%eax
    9ab7:	0f b6 00             	movzbl (%eax),%eax
    9aba:	0f b6 c0             	movzbl %al,%eax
    9abd:	83 e0 20             	and    $0x20,%eax
    9ac0:	85 c0                	test   %eax,%eax
    9ac2:	0f 95 c0             	setne  %al
}
    9ac5:	5d                   	pop    %ebp
    9ac6:	c3                   	ret    

00009ac7 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    9ac7:	55                   	push   %ebp
    9ac8:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    9aca:	8b 45 08             	mov    0x8(%ebp),%eax
    9acd:	83 c0 08             	add    $0x8,%eax
}
    9ad0:	5d                   	pop    %ebp
    9ad1:	c3                   	ret    

00009ad2 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    9ad2:	55                   	push   %ebp
    9ad3:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    9ad5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad8:	83 c0 08             	add    $0x8,%eax
}
    9adb:	5d                   	pop    %ebp
    9adc:	c3                   	ret    

00009add <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    9add:	55                   	push   %ebp
    9ade:	89 e5                	mov    %esp,%ebp
    9ae0:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    9ae3:	ff 75 08             	pushl  0x8(%ebp)
    9ae6:	e8 af fe ff ff       	call   999a <lodepng_chunk_length>
    9aeb:	83 c4 04             	add    $0x4,%esp
    9aee:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    9af1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9af4:	8d 50 08             	lea    0x8(%eax),%edx
    9af7:	8b 45 08             	mov    0x8(%ebp),%eax
    9afa:	01 d0                	add    %edx,%eax
    9afc:	50                   	push   %eax
    9afd:	e8 94 b2 ff ff       	call   4d96 <lodepng_read32bitInt>
    9b02:	83 c4 04             	add    $0x4,%esp
    9b05:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    9b08:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9b0b:	83 c0 04             	add    $0x4,%eax
    9b0e:	89 c2                	mov    %eax,%edx
    9b10:	8b 45 08             	mov    0x8(%ebp),%eax
    9b13:	83 c0 04             	add    $0x4,%eax
    9b16:	52                   	push   %edx
    9b17:	50                   	push   %eax
    9b18:	e8 0b fd ff ff       	call   9828 <lodepng_crc32>
    9b1d:	83 c4 08             	add    $0x8,%esp
    9b20:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    9b23:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9b26:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9b29:	74 07                	je     9b32 <lodepng_chunk_check_crc+0x55>
    9b2b:	b8 01 00 00 00       	mov    $0x1,%eax
    9b30:	eb 05                	jmp    9b37 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    9b32:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9b37:	c9                   	leave  
    9b38:	c3                   	ret    

00009b39 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    9b39:	55                   	push   %ebp
    9b3a:	89 e5                	mov    %esp,%ebp
    9b3c:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    9b3f:	ff 75 08             	pushl  0x8(%ebp)
    9b42:	e8 53 fe ff ff       	call   999a <lodepng_chunk_length>
    9b47:	83 c4 04             	add    $0x4,%esp
    9b4a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    9b4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9b50:	83 c0 04             	add    $0x4,%eax
    9b53:	89 c2                	mov    %eax,%edx
    9b55:	8b 45 08             	mov    0x8(%ebp),%eax
    9b58:	83 c0 04             	add    $0x4,%eax
    9b5b:	52                   	push   %edx
    9b5c:	50                   	push   %eax
    9b5d:	e8 c6 fc ff ff       	call   9828 <lodepng_crc32>
    9b62:	83 c4 08             	add    $0x8,%esp
    9b65:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    9b68:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9b6b:	8d 50 08             	lea    0x8(%eax),%edx
    9b6e:	8b 45 08             	mov    0x8(%ebp),%eax
    9b71:	01 d0                	add    %edx,%eax
    9b73:	ff 75 f8             	pushl  -0x8(%ebp)
    9b76:	50                   	push   %eax
    9b77:	e8 5d b2 ff ff       	call   4dd9 <lodepng_set32bitInt>
    9b7c:	83 c4 08             	add    $0x8,%esp
}
    9b7f:	90                   	nop
    9b80:	c9                   	leave  
    9b81:	c3                   	ret    

00009b82 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    9b82:	55                   	push   %ebp
    9b83:	89 e5                	mov    %esp,%ebp
    9b85:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    9b88:	8b 45 08             	mov    0x8(%ebp),%eax
    9b8b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9b8e:	73 0f                	jae    9b9f <lodepng_chunk_next+0x1d>
    9b90:	8b 55 0c             	mov    0xc(%ebp),%edx
    9b93:	8b 45 08             	mov    0x8(%ebp),%eax
    9b96:	29 c2                	sub    %eax,%edx
    9b98:	89 d0                	mov    %edx,%eax
    9b9a:	83 f8 0b             	cmp    $0xb,%eax
    9b9d:	7f 08                	jg     9ba7 <lodepng_chunk_next+0x25>
    9b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ba2:	e9 af 00 00 00       	jmp    9c56 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    9ba7:	8b 45 08             	mov    0x8(%ebp),%eax
    9baa:	0f b6 00             	movzbl (%eax),%eax
    9bad:	3c 89                	cmp    $0x89,%al
    9baf:	75 63                	jne    9c14 <lodepng_chunk_next+0x92>
    9bb1:	8b 45 08             	mov    0x8(%ebp),%eax
    9bb4:	83 c0 01             	add    $0x1,%eax
    9bb7:	0f b6 00             	movzbl (%eax),%eax
    9bba:	3c 50                	cmp    $0x50,%al
    9bbc:	75 56                	jne    9c14 <lodepng_chunk_next+0x92>
    9bbe:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc1:	83 c0 02             	add    $0x2,%eax
    9bc4:	0f b6 00             	movzbl (%eax),%eax
    9bc7:	3c 4e                	cmp    $0x4e,%al
    9bc9:	75 49                	jne    9c14 <lodepng_chunk_next+0x92>
    9bcb:	8b 45 08             	mov    0x8(%ebp),%eax
    9bce:	83 c0 03             	add    $0x3,%eax
    9bd1:	0f b6 00             	movzbl (%eax),%eax
    9bd4:	3c 47                	cmp    $0x47,%al
    9bd6:	75 3c                	jne    9c14 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    9bd8:	8b 45 08             	mov    0x8(%ebp),%eax
    9bdb:	83 c0 04             	add    $0x4,%eax
    9bde:	0f b6 00             	movzbl (%eax),%eax
    9be1:	3c 0d                	cmp    $0xd,%al
    9be3:	75 2f                	jne    9c14 <lodepng_chunk_next+0x92>
    9be5:	8b 45 08             	mov    0x8(%ebp),%eax
    9be8:	83 c0 05             	add    $0x5,%eax
    9beb:	0f b6 00             	movzbl (%eax),%eax
    9bee:	3c 0a                	cmp    $0xa,%al
    9bf0:	75 22                	jne    9c14 <lodepng_chunk_next+0x92>
    9bf2:	8b 45 08             	mov    0x8(%ebp),%eax
    9bf5:	83 c0 06             	add    $0x6,%eax
    9bf8:	0f b6 00             	movzbl (%eax),%eax
    9bfb:	3c 1a                	cmp    $0x1a,%al
    9bfd:	75 15                	jne    9c14 <lodepng_chunk_next+0x92>
    9bff:	8b 45 08             	mov    0x8(%ebp),%eax
    9c02:	83 c0 07             	add    $0x7,%eax
    9c05:	0f b6 00             	movzbl (%eax),%eax
    9c08:	3c 0a                	cmp    $0xa,%al
    9c0a:	75 08                	jne    9c14 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    9c0c:	8b 45 08             	mov    0x8(%ebp),%eax
    9c0f:	83 c0 08             	add    $0x8,%eax
    9c12:	eb 42                	jmp    9c56 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    9c14:	ff 75 08             	pushl  0x8(%ebp)
    9c17:	e8 7e fd ff ff       	call   999a <lodepng_chunk_length>
    9c1c:	83 c4 04             	add    $0x4,%esp
    9c1f:	89 c2                	mov    %eax,%edx
    9c21:	8d 45 f8             	lea    -0x8(%ebp),%eax
    9c24:	50                   	push   %eax
    9c25:	6a 0c                	push   $0xc
    9c27:	52                   	push   %edx
    9c28:	e8 af ae ff ff       	call   4adc <lodepng_addofl>
    9c2d:	83 c4 0c             	add    $0xc,%esp
    9c30:	85 c0                	test   %eax,%eax
    9c32:	74 05                	je     9c39 <lodepng_chunk_next+0xb7>
    9c34:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c37:	eb 1d                	jmp    9c56 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    9c39:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9c3c:	89 c2                	mov    %eax,%edx
    9c3e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c41:	01 d0                	add    %edx,%eax
    9c43:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    9c46:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9c49:	3b 45 08             	cmp    0x8(%ebp),%eax
    9c4c:	73 05                	jae    9c53 <lodepng_chunk_next+0xd1>
    9c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c51:	eb 03                	jmp    9c56 <lodepng_chunk_next+0xd4>
    return result;
    9c53:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    9c56:	c9                   	leave  
    9c57:	c3                   	ret    

00009c58 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    9c58:	55                   	push   %ebp
    9c59:	89 e5                	mov    %esp,%ebp
    9c5b:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    9c5e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c61:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9c64:	73 0f                	jae    9c75 <lodepng_chunk_next_const+0x1d>
    9c66:	8b 55 0c             	mov    0xc(%ebp),%edx
    9c69:	8b 45 08             	mov    0x8(%ebp),%eax
    9c6c:	29 c2                	sub    %eax,%edx
    9c6e:	89 d0                	mov    %edx,%eax
    9c70:	83 f8 0b             	cmp    $0xb,%eax
    9c73:	7f 08                	jg     9c7d <lodepng_chunk_next_const+0x25>
    9c75:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c78:	e9 af 00 00 00       	jmp    9d2c <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    9c7d:	8b 45 08             	mov    0x8(%ebp),%eax
    9c80:	0f b6 00             	movzbl (%eax),%eax
    9c83:	3c 89                	cmp    $0x89,%al
    9c85:	75 63                	jne    9cea <lodepng_chunk_next_const+0x92>
    9c87:	8b 45 08             	mov    0x8(%ebp),%eax
    9c8a:	83 c0 01             	add    $0x1,%eax
    9c8d:	0f b6 00             	movzbl (%eax),%eax
    9c90:	3c 50                	cmp    $0x50,%al
    9c92:	75 56                	jne    9cea <lodepng_chunk_next_const+0x92>
    9c94:	8b 45 08             	mov    0x8(%ebp),%eax
    9c97:	83 c0 02             	add    $0x2,%eax
    9c9a:	0f b6 00             	movzbl (%eax),%eax
    9c9d:	3c 4e                	cmp    $0x4e,%al
    9c9f:	75 49                	jne    9cea <lodepng_chunk_next_const+0x92>
    9ca1:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca4:	83 c0 03             	add    $0x3,%eax
    9ca7:	0f b6 00             	movzbl (%eax),%eax
    9caa:	3c 47                	cmp    $0x47,%al
    9cac:	75 3c                	jne    9cea <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    9cae:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb1:	83 c0 04             	add    $0x4,%eax
    9cb4:	0f b6 00             	movzbl (%eax),%eax
    9cb7:	3c 0d                	cmp    $0xd,%al
    9cb9:	75 2f                	jne    9cea <lodepng_chunk_next_const+0x92>
    9cbb:	8b 45 08             	mov    0x8(%ebp),%eax
    9cbe:	83 c0 05             	add    $0x5,%eax
    9cc1:	0f b6 00             	movzbl (%eax),%eax
    9cc4:	3c 0a                	cmp    $0xa,%al
    9cc6:	75 22                	jne    9cea <lodepng_chunk_next_const+0x92>
    9cc8:	8b 45 08             	mov    0x8(%ebp),%eax
    9ccb:	83 c0 06             	add    $0x6,%eax
    9cce:	0f b6 00             	movzbl (%eax),%eax
    9cd1:	3c 1a                	cmp    $0x1a,%al
    9cd3:	75 15                	jne    9cea <lodepng_chunk_next_const+0x92>
    9cd5:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd8:	83 c0 07             	add    $0x7,%eax
    9cdb:	0f b6 00             	movzbl (%eax),%eax
    9cde:	3c 0a                	cmp    $0xa,%al
    9ce0:	75 08                	jne    9cea <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    9ce2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce5:	83 c0 08             	add    $0x8,%eax
    9ce8:	eb 42                	jmp    9d2c <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    9cea:	ff 75 08             	pushl  0x8(%ebp)
    9ced:	e8 a8 fc ff ff       	call   999a <lodepng_chunk_length>
    9cf2:	83 c4 04             	add    $0x4,%esp
    9cf5:	89 c2                	mov    %eax,%edx
    9cf7:	8d 45 f8             	lea    -0x8(%ebp),%eax
    9cfa:	50                   	push   %eax
    9cfb:	6a 0c                	push   $0xc
    9cfd:	52                   	push   %edx
    9cfe:	e8 d9 ad ff ff       	call   4adc <lodepng_addofl>
    9d03:	83 c4 0c             	add    $0xc,%esp
    9d06:	85 c0                	test   %eax,%eax
    9d08:	74 05                	je     9d0f <lodepng_chunk_next_const+0xb7>
    9d0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d0d:	eb 1d                	jmp    9d2c <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    9d0f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d12:	89 c2                	mov    %eax,%edx
    9d14:	8b 45 08             	mov    0x8(%ebp),%eax
    9d17:	01 d0                	add    %edx,%eax
    9d19:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    9d1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d1f:	3b 45 08             	cmp    0x8(%ebp),%eax
    9d22:	73 05                	jae    9d29 <lodepng_chunk_next_const+0xd1>
    9d24:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d27:	eb 03                	jmp    9d2c <lodepng_chunk_next_const+0xd4>
    return result;
    9d29:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    9d2c:	c9                   	leave  
    9d2d:	c3                   	ret    

00009d2e <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    9d2e:	55                   	push   %ebp
    9d2f:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    9d31:	8b 45 08             	mov    0x8(%ebp),%eax
    9d34:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9d37:	73 0f                	jae    9d48 <lodepng_chunk_find+0x1a>
    9d39:	8b 55 0c             	mov    0xc(%ebp),%edx
    9d3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9d3f:	29 c2                	sub    %eax,%edx
    9d41:	89 d0                	mov    %edx,%eax
    9d43:	83 f8 0b             	cmp    $0xb,%eax
    9d46:	7f 07                	jg     9d4f <lodepng_chunk_find+0x21>
    9d48:	b8 00 00 00 00       	mov    $0x0,%eax
    9d4d:	eb 2a                	jmp    9d79 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    9d4f:	ff 75 10             	pushl  0x10(%ebp)
    9d52:	ff 75 08             	pushl  0x8(%ebp)
    9d55:	e8 8d fc ff ff       	call   99e7 <lodepng_chunk_type_equals>
    9d5a:	83 c4 08             	add    $0x8,%esp
    9d5d:	84 c0                	test   %al,%al
    9d5f:	74 05                	je     9d66 <lodepng_chunk_find+0x38>
    9d61:	8b 45 08             	mov    0x8(%ebp),%eax
    9d64:	eb 13                	jmp    9d79 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    9d66:	ff 75 0c             	pushl  0xc(%ebp)
    9d69:	ff 75 08             	pushl  0x8(%ebp)
    9d6c:	e8 11 fe ff ff       	call   9b82 <lodepng_chunk_next>
    9d71:	83 c4 08             	add    $0x8,%esp
    9d74:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    9d77:	eb b8                	jmp    9d31 <lodepng_chunk_find+0x3>
}
    9d79:	c9                   	leave  
    9d7a:	c3                   	ret    

00009d7b <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    9d7b:	55                   	push   %ebp
    9d7c:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    9d7e:	8b 45 08             	mov    0x8(%ebp),%eax
    9d81:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9d84:	73 0f                	jae    9d95 <lodepng_chunk_find_const+0x1a>
    9d86:	8b 55 0c             	mov    0xc(%ebp),%edx
    9d89:	8b 45 08             	mov    0x8(%ebp),%eax
    9d8c:	29 c2                	sub    %eax,%edx
    9d8e:	89 d0                	mov    %edx,%eax
    9d90:	83 f8 0b             	cmp    $0xb,%eax
    9d93:	7f 07                	jg     9d9c <lodepng_chunk_find_const+0x21>
    9d95:	b8 00 00 00 00       	mov    $0x0,%eax
    9d9a:	eb 2a                	jmp    9dc6 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    9d9c:	ff 75 10             	pushl  0x10(%ebp)
    9d9f:	ff 75 08             	pushl  0x8(%ebp)
    9da2:	e8 40 fc ff ff       	call   99e7 <lodepng_chunk_type_equals>
    9da7:	83 c4 08             	add    $0x8,%esp
    9daa:	84 c0                	test   %al,%al
    9dac:	74 05                	je     9db3 <lodepng_chunk_find_const+0x38>
    9dae:	8b 45 08             	mov    0x8(%ebp),%eax
    9db1:	eb 13                	jmp    9dc6 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    9db3:	ff 75 0c             	pushl  0xc(%ebp)
    9db6:	ff 75 08             	pushl  0x8(%ebp)
    9db9:	e8 9a fe ff ff       	call   9c58 <lodepng_chunk_next_const>
    9dbe:	83 c4 08             	add    $0x8,%esp
    9dc1:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    9dc4:	eb b8                	jmp    9d7e <lodepng_chunk_find_const+0x3>
}
    9dc6:	c9                   	leave  
    9dc7:	c3                   	ret    

00009dc8 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    9dc8:	55                   	push   %ebp
    9dc9:	89 e5                	mov    %esp,%ebp
    9dcb:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    9dce:	ff 75 10             	pushl  0x10(%ebp)
    9dd1:	e8 c4 fb ff ff       	call   999a <lodepng_chunk_length>
    9dd6:	83 c4 04             	add    $0x4,%esp
    9dd9:	89 c2                	mov    %eax,%edx
    9ddb:	8d 45 f0             	lea    -0x10(%ebp),%eax
    9dde:	50                   	push   %eax
    9ddf:	6a 0c                	push   $0xc
    9de1:	52                   	push   %edx
    9de2:	e8 f5 ac ff ff       	call   4adc <lodepng_addofl>
    9de7:	83 c4 0c             	add    $0xc,%esp
    9dea:	85 c0                	test   %eax,%eax
    9dec:	74 0a                	je     9df8 <lodepng_chunk_append+0x30>
    9dee:	b8 4d 00 00 00       	mov    $0x4d,%eax
    9df3:	e9 96 00 00 00       	jmp    9e8e <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    9df8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9dfb:	8b 45 0c             	mov    0xc(%ebp),%eax
    9dfe:	8b 00                	mov    (%eax),%eax
    9e00:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    9e03:	51                   	push   %ecx
    9e04:	52                   	push   %edx
    9e05:	50                   	push   %eax
    9e06:	e8 d1 ac ff ff       	call   4adc <lodepng_addofl>
    9e0b:	83 c4 0c             	add    $0xc,%esp
    9e0e:	85 c0                	test   %eax,%eax
    9e10:	74 07                	je     9e19 <lodepng_chunk_append+0x51>
    9e12:	b8 4d 00 00 00       	mov    $0x4d,%eax
    9e17:	eb 75                	jmp    9e8e <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    9e19:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9e1c:	8b 45 08             	mov    0x8(%ebp),%eax
    9e1f:	8b 00                	mov    (%eax),%eax
    9e21:	52                   	push   %edx
    9e22:	50                   	push   %eax
    9e23:	e8 07 ac ff ff       	call   4a2f <lodepng_realloc>
    9e28:	83 c4 08             	add    $0x8,%esp
    9e2b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    9e2e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9e32:	75 07                	jne    9e3b <lodepng_chunk_append+0x73>
    9e34:	b8 53 00 00 00       	mov    $0x53,%eax
    9e39:	eb 53                	jmp    9e8e <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    9e3b:	8b 45 08             	mov    0x8(%ebp),%eax
    9e3e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9e41:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    9e43:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9e46:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e49:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    9e4b:	8b 45 08             	mov    0x8(%ebp),%eax
    9e4e:	8b 00                	mov    (%eax),%eax
    9e50:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    9e53:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9e56:	29 d1                	sub    %edx,%ecx
    9e58:	89 ca                	mov    %ecx,%edx
    9e5a:	01 d0                	add    %edx,%eax
    9e5c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    9e5f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9e66:	eb 19                	jmp    9e81 <lodepng_chunk_append+0xb9>
    9e68:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9e6e:	01 c2                	add    %eax,%edx
    9e70:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e73:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9e76:	01 c8                	add    %ecx,%eax
    9e78:	0f b6 00             	movzbl (%eax),%eax
    9e7b:	88 02                	mov    %al,(%edx)
    9e7d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9e81:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9e84:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    9e87:	75 df                	jne    9e68 <lodepng_chunk_append+0xa0>

  return 0;
    9e89:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9e8e:	c9                   	leave  
    9e8f:	c3                   	ret    

00009e90 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    9e90:	55                   	push   %ebp
    9e91:	89 e5                	mov    %esp,%ebp
    9e93:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    9e96:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e99:	8b 40 04             	mov    0x4(%eax),%eax
    9e9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    9e9f:	8b 55 10             	mov    0x10(%ebp),%edx
    9ea2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9ea5:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    9ea8:	51                   	push   %ecx
    9ea9:	52                   	push   %edx
    9eaa:	50                   	push   %eax
    9eab:	e8 2c ac ff ff       	call   4adc <lodepng_addofl>
    9eb0:	83 c4 0c             	add    $0xc,%esp
    9eb3:	85 c0                	test   %eax,%eax
    9eb5:	74 07                	je     9ebe <lodepng_chunk_init+0x2e>
    9eb7:	b8 4d 00 00 00       	mov    $0x4d,%eax
    9ebc:	eb 78                	jmp    9f36 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    9ebe:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9ec1:	8d 55 fc             	lea    -0x4(%ebp),%edx
    9ec4:	52                   	push   %edx
    9ec5:	6a 0c                	push   $0xc
    9ec7:	50                   	push   %eax
    9ec8:	e8 0f ac ff ff       	call   4adc <lodepng_addofl>
    9ecd:	83 c4 0c             	add    $0xc,%esp
    9ed0:	85 c0                	test   %eax,%eax
    9ed2:	74 07                	je     9edb <lodepng_chunk_init+0x4b>
    9ed4:	b8 4d 00 00 00       	mov    $0x4d,%eax
    9ed9:	eb 5b                	jmp    9f36 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    9edb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9ede:	50                   	push   %eax
    9edf:	ff 75 0c             	pushl  0xc(%ebp)
    9ee2:	e8 8b ad ff ff       	call   4c72 <ucvector_resize>
    9ee7:	83 c4 08             	add    $0x8,%esp
    9eea:	85 c0                	test   %eax,%eax
    9eec:	75 07                	jne    9ef5 <lodepng_chunk_init+0x65>
    9eee:	b8 53 00 00 00       	mov    $0x53,%eax
    9ef3:	eb 41                	jmp    9f36 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    9ef5:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ef8:	8b 00                	mov    (%eax),%eax
    9efa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9efd:	2b 55 10             	sub    0x10(%ebp),%edx
    9f00:	83 ea 0c             	sub    $0xc,%edx
    9f03:	01 c2                	add    %eax,%edx
    9f05:	8b 45 08             	mov    0x8(%ebp),%eax
    9f08:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    9f0a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f0d:	8b 00                	mov    (%eax),%eax
    9f0f:	ff 75 10             	pushl  0x10(%ebp)
    9f12:	50                   	push   %eax
    9f13:	e8 c1 ae ff ff       	call   4dd9 <lodepng_set32bitInt>
    9f18:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    9f1b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f1e:	8b 00                	mov    (%eax),%eax
    9f20:	83 c0 04             	add    $0x4,%eax
    9f23:	6a 04                	push   $0x4
    9f25:	ff 75 14             	pushl  0x14(%ebp)
    9f28:	50                   	push   %eax
    9f29:	e8 28 ab ff ff       	call   4a56 <lodepng_memcpy>
    9f2e:	83 c4 0c             	add    $0xc,%esp

  return 0;
    9f31:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f36:	c9                   	leave  
    9f37:	c3                   	ret    

00009f38 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    9f38:	55                   	push   %ebp
    9f39:	89 e5                	mov    %esp,%ebp
    9f3b:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    9f3e:	ff 75 10             	pushl  0x10(%ebp)
    9f41:	ff 75 0c             	pushl  0xc(%ebp)
    9f44:	ff 75 08             	pushl  0x8(%ebp)
    9f47:	8d 45 f8             	lea    -0x8(%ebp),%eax
    9f4a:	50                   	push   %eax
    9f4b:	e8 40 ff ff ff       	call   9e90 <lodepng_chunk_init>
    9f50:	83 c4 10             	add    $0x10,%esp
    9f53:	89 45 fc             	mov    %eax,-0x4(%ebp)
    9f56:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    9f5a:	74 05                	je     9f61 <lodepng_chunk_createv+0x29>
    9f5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9f5f:	eb 27                	jmp    9f88 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    9f61:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f64:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9f67:	83 c2 08             	add    $0x8,%edx
    9f6a:	50                   	push   %eax
    9f6b:	ff 75 14             	pushl  0x14(%ebp)
    9f6e:	52                   	push   %edx
    9f6f:	e8 e2 aa ff ff       	call   4a56 <lodepng_memcpy>
    9f74:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    9f77:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9f7a:	50                   	push   %eax
    9f7b:	e8 b9 fb ff ff       	call   9b39 <lodepng_chunk_generate_crc>
    9f80:	83 c4 04             	add    $0x4,%esp

  return 0;
    9f83:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f88:	c9                   	leave  
    9f89:	c3                   	ret    

00009f8a <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    9f8a:	55                   	push   %ebp
    9f8b:	89 e5                	mov    %esp,%ebp
    9f8d:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    9f90:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f93:	8b 08                	mov    (%eax),%ecx
    9f95:	8b 45 08             	mov    0x8(%ebp),%eax
    9f98:	8b 10                	mov    (%eax),%edx
    9f9a:	8d 45 f0             	lea    -0x10(%ebp),%eax
    9f9d:	51                   	push   %ecx
    9f9e:	52                   	push   %edx
    9f9f:	50                   	push   %eax
    9fa0:	e8 34 ad ff ff       	call   4cd9 <ucvector_init>
    9fa5:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    9fa8:	ff 75 18             	pushl  0x18(%ebp)
    9fab:	ff 75 14             	pushl  0x14(%ebp)
    9fae:	ff 75 10             	pushl  0x10(%ebp)
    9fb1:	8d 45 f0             	lea    -0x10(%ebp),%eax
    9fb4:	50                   	push   %eax
    9fb5:	e8 7e ff ff ff       	call   9f38 <lodepng_chunk_createv>
    9fba:	83 c4 10             	add    $0x10,%esp
    9fbd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    9fc0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9fc3:	8b 45 08             	mov    0x8(%ebp),%eax
    9fc6:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    9fc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fcb:	8b 45 0c             	mov    0xc(%ebp),%eax
    9fce:	89 10                	mov    %edx,(%eax)
  return error;
    9fd0:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    9fd3:	c9                   	leave  
    9fd4:	c3                   	ret    

00009fd5 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    9fd5:	55                   	push   %ebp
    9fd6:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    9fd8:	8b 45 08             	mov    0x8(%ebp),%eax
    9fdb:	83 f8 03             	cmp    $0x3,%eax
    9fde:	74 6d                	je     a04d <checkColorValidity+0x78>
    9fe0:	83 f8 03             	cmp    $0x3,%eax
    9fe3:	77 0e                	ja     9ff3 <checkColorValidity+0x1e>
    9fe5:	85 c0                	test   %eax,%eax
    9fe7:	74 28                	je     a011 <checkColorValidity+0x3c>
    9fe9:	83 f8 02             	cmp    $0x2,%eax
    9fec:	74 4c                	je     a03a <checkColorValidity+0x65>
    9fee:	e9 a6 00 00 00       	jmp    a099 <checkColorValidity+0xc4>
    9ff3:	83 f8 06             	cmp    $0x6,%eax
    9ff6:	0f 84 83 00 00 00    	je     a07f <checkColorValidity+0xaa>
    9ffc:	3d ff 00 00 00       	cmp    $0xff,%eax
    a001:	0f 84 8b 00 00 00    	je     a092 <checkColorValidity+0xbd>
    a007:	83 f8 04             	cmp    $0x4,%eax
    a00a:	74 60                	je     a06c <checkColorValidity+0x97>
    a00c:	e9 88 00 00 00       	jmp    a099 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    a011:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    a015:	0f 84 85 00 00 00    	je     a0a0 <checkColorValidity+0xcb>
    a01b:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    a01f:	74 7f                	je     a0a0 <checkColorValidity+0xcb>
    a021:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    a025:	74 79                	je     a0a0 <checkColorValidity+0xcb>
    a027:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    a02b:	74 73                	je     a0a0 <checkColorValidity+0xcb>
    a02d:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    a031:	74 6d                	je     a0a0 <checkColorValidity+0xcb>
    a033:	b8 25 00 00 00       	mov    $0x25,%eax
    a038:	eb 78                	jmp    a0b2 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    a03a:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    a03e:	74 63                	je     a0a3 <checkColorValidity+0xce>
    a040:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    a044:	74 5d                	je     a0a3 <checkColorValidity+0xce>
    a046:	b8 25 00 00 00       	mov    $0x25,%eax
    a04b:	eb 65                	jmp    a0b2 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    a04d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    a051:	74 53                	je     a0a6 <checkColorValidity+0xd1>
    a053:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    a057:	74 4d                	je     a0a6 <checkColorValidity+0xd1>
    a059:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    a05d:	74 47                	je     a0a6 <checkColorValidity+0xd1>
    a05f:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    a063:	74 41                	je     a0a6 <checkColorValidity+0xd1>
    a065:	b8 25 00 00 00       	mov    $0x25,%eax
    a06a:	eb 46                	jmp    a0b2 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    a06c:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    a070:	74 37                	je     a0a9 <checkColorValidity+0xd4>
    a072:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    a076:	74 31                	je     a0a9 <checkColorValidity+0xd4>
    a078:	b8 25 00 00 00       	mov    $0x25,%eax
    a07d:	eb 33                	jmp    a0b2 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    a07f:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    a083:	74 27                	je     a0ac <checkColorValidity+0xd7>
    a085:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    a089:	74 21                	je     a0ac <checkColorValidity+0xd7>
    a08b:	b8 25 00 00 00       	mov    $0x25,%eax
    a090:	eb 20                	jmp    a0b2 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    a092:	b8 1f 00 00 00       	mov    $0x1f,%eax
    a097:	eb 19                	jmp    a0b2 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    a099:	b8 1f 00 00 00       	mov    $0x1f,%eax
    a09e:	eb 12                	jmp    a0b2 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    a0a0:	90                   	nop
    a0a1:	eb 0a                	jmp    a0ad <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    a0a3:	90                   	nop
    a0a4:	eb 07                	jmp    a0ad <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    a0a6:	90                   	nop
    a0a7:	eb 04                	jmp    a0ad <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    a0a9:	90                   	nop
    a0aa:	eb 01                	jmp    a0ad <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    a0ac:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    a0ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a0b2:	5d                   	pop    %ebp
    a0b3:	c3                   	ret    

0000a0b4 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    a0b4:	55                   	push   %ebp
    a0b5:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    a0b7:	8b 45 08             	mov    0x8(%ebp),%eax
    a0ba:	83 f8 03             	cmp    $0x3,%eax
    a0bd:	74 31                	je     a0f0 <getNumColorChannels+0x3c>
    a0bf:	83 f8 03             	cmp    $0x3,%eax
    a0c2:	77 0b                	ja     a0cf <getNumColorChannels+0x1b>
    a0c4:	85 c0                	test   %eax,%eax
    a0c6:	74 1a                	je     a0e2 <getNumColorChannels+0x2e>
    a0c8:	83 f8 02             	cmp    $0x2,%eax
    a0cb:	74 1c                	je     a0e9 <getNumColorChannels+0x35>
    a0cd:	eb 3d                	jmp    a10c <getNumColorChannels+0x58>
    a0cf:	83 f8 06             	cmp    $0x6,%eax
    a0d2:	74 2a                	je     a0fe <getNumColorChannels+0x4a>
    a0d4:	3d ff 00 00 00       	cmp    $0xff,%eax
    a0d9:	74 2a                	je     a105 <getNumColorChannels+0x51>
    a0db:	83 f8 04             	cmp    $0x4,%eax
    a0de:	74 17                	je     a0f7 <getNumColorChannels+0x43>
    a0e0:	eb 2a                	jmp    a10c <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    a0e2:	b8 01 00 00 00       	mov    $0x1,%eax
    a0e7:	eb 28                	jmp    a111 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    a0e9:	b8 03 00 00 00       	mov    $0x3,%eax
    a0ee:	eb 21                	jmp    a111 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    a0f0:	b8 01 00 00 00       	mov    $0x1,%eax
    a0f5:	eb 1a                	jmp    a111 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    a0f7:	b8 02 00 00 00       	mov    $0x2,%eax
    a0fc:	eb 13                	jmp    a111 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    a0fe:	b8 04 00 00 00       	mov    $0x4,%eax
    a103:	eb 0c                	jmp    a111 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    a105:	b8 00 00 00 00       	mov    $0x0,%eax
    a10a:	eb 05                	jmp    a111 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    a10c:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    a111:	5d                   	pop    %ebp
    a112:	c3                   	ret    

0000a113 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    a113:	55                   	push   %ebp
    a114:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    a116:	ff 75 08             	pushl  0x8(%ebp)
    a119:	e8 96 ff ff ff       	call   a0b4 <getNumColorChannels>
    a11e:	83 c4 04             	add    $0x4,%esp
    a121:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    a125:	c9                   	leave  
    a126:	c3                   	ret    

0000a127 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    a127:	55                   	push   %ebp
    a128:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    a12a:	8b 45 08             	mov    0x8(%ebp),%eax
    a12d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    a134:	8b 45 08             	mov    0x8(%ebp),%eax
    a137:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    a13e:	8b 45 08             	mov    0x8(%ebp),%eax
    a141:	8b 50 1c             	mov    0x1c(%eax),%edx
    a144:	8b 45 08             	mov    0x8(%ebp),%eax
    a147:	89 50 18             	mov    %edx,0x18(%eax)
    a14a:	8b 45 08             	mov    0x8(%ebp),%eax
    a14d:	8b 50 18             	mov    0x18(%eax),%edx
    a150:	8b 45 08             	mov    0x8(%ebp),%eax
    a153:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    a156:	8b 45 08             	mov    0x8(%ebp),%eax
    a159:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    a15f:	8b 45 08             	mov    0x8(%ebp),%eax
    a162:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    a169:	8b 45 08             	mov    0x8(%ebp),%eax
    a16c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    a173:	8b 45 08             	mov    0x8(%ebp),%eax
    a176:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    a17d:	90                   	nop
    a17e:	5d                   	pop    %ebp
    a17f:	c3                   	ret    

0000a180 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    a180:	55                   	push   %ebp
    a181:	89 e5                	mov    %esp,%ebp
    a183:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    a186:	8b 45 08             	mov    0x8(%ebp),%eax
    a189:	8b 40 08             	mov    0x8(%eax),%eax
    a18c:	85 c0                	test   %eax,%eax
    a18e:	75 18                	jne    a1a8 <lodepng_color_mode_alloc_palette+0x28>
    a190:	83 ec 0c             	sub    $0xc,%esp
    a193:	68 00 04 00 00       	push   $0x400
    a198:	e8 7b a8 ff ff       	call   4a18 <lodepng_malloc>
    a19d:	83 c4 10             	add    $0x10,%esp
    a1a0:	89 c2                	mov    %eax,%edx
    a1a2:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a5:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    a1a8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1ab:	8b 40 08             	mov    0x8(%eax),%eax
    a1ae:	85 c0                	test   %eax,%eax
    a1b0:	74 65                	je     a217 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    a1b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a1b9:	eb 51                	jmp    a20c <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    a1bb:	8b 45 08             	mov    0x8(%ebp),%eax
    a1be:	8b 40 08             	mov    0x8(%eax),%eax
    a1c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a1c4:	c1 e2 02             	shl    $0x2,%edx
    a1c7:	01 d0                	add    %edx,%eax
    a1c9:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    a1cc:	8b 45 08             	mov    0x8(%ebp),%eax
    a1cf:	8b 40 08             	mov    0x8(%eax),%eax
    a1d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a1d5:	c1 e2 02             	shl    $0x2,%edx
    a1d8:	83 c2 01             	add    $0x1,%edx
    a1db:	01 d0                	add    %edx,%eax
    a1dd:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    a1e0:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e3:	8b 40 08             	mov    0x8(%eax),%eax
    a1e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a1e9:	c1 e2 02             	shl    $0x2,%edx
    a1ec:	83 c2 02             	add    $0x2,%edx
    a1ef:	01 d0                	add    %edx,%eax
    a1f1:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    a1f4:	8b 45 08             	mov    0x8(%ebp),%eax
    a1f7:	8b 40 08             	mov    0x8(%eax),%eax
    a1fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a1fd:	c1 e2 02             	shl    $0x2,%edx
    a200:	83 c2 03             	add    $0x3,%edx
    a203:	01 d0                	add    %edx,%eax
    a205:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    a208:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a20c:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    a213:	75 a6                	jne    a1bb <lodepng_color_mode_alloc_palette+0x3b>
    a215:	eb 01                	jmp    a218 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    a217:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    a218:	c9                   	leave  
    a219:	c3                   	ret    

0000a21a <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    a21a:	55                   	push   %ebp
    a21b:	89 e5                	mov    %esp,%ebp
    a21d:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    a220:	83 ec 0c             	sub    $0xc,%esp
    a223:	ff 75 08             	pushl  0x8(%ebp)
    a226:	e8 f3 01 00 00       	call   a41e <lodepng_palette_clear>
    a22b:	83 c4 10             	add    $0x10,%esp
}
    a22e:	90                   	nop
    a22f:	c9                   	leave  
    a230:	c3                   	ret    

0000a231 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    a231:	55                   	push   %ebp
    a232:	89 e5                	mov    %esp,%ebp
    a234:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    a237:	83 ec 0c             	sub    $0xc,%esp
    a23a:	ff 75 08             	pushl  0x8(%ebp)
    a23d:	e8 d8 ff ff ff       	call   a21a <lodepng_color_mode_cleanup>
    a242:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    a245:	83 ec 04             	sub    $0x4,%esp
    a248:	6a 20                	push   $0x20
    a24a:	ff 75 0c             	pushl  0xc(%ebp)
    a24d:	ff 75 08             	pushl  0x8(%ebp)
    a250:	e8 01 a8 ff ff       	call   4a56 <lodepng_memcpy>
    a255:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    a258:	8b 45 0c             	mov    0xc(%ebp),%eax
    a25b:	8b 40 08             	mov    0x8(%eax),%eax
    a25e:	85 c0                	test   %eax,%eax
    a260:	74 5a                	je     a2bc <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    a262:	83 ec 0c             	sub    $0xc,%esp
    a265:	68 00 04 00 00       	push   $0x400
    a26a:	e8 a9 a7 ff ff       	call   4a18 <lodepng_malloc>
    a26f:	83 c4 10             	add    $0x10,%esp
    a272:	89 c2                	mov    %eax,%edx
    a274:	8b 45 08             	mov    0x8(%ebp),%eax
    a277:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    a27a:	8b 45 08             	mov    0x8(%ebp),%eax
    a27d:	8b 40 08             	mov    0x8(%eax),%eax
    a280:	85 c0                	test   %eax,%eax
    a282:	75 11                	jne    a295 <lodepng_color_mode_copy+0x64>
    a284:	8b 45 0c             	mov    0xc(%ebp),%eax
    a287:	8b 40 0c             	mov    0xc(%eax),%eax
    a28a:	85 c0                	test   %eax,%eax
    a28c:	74 07                	je     a295 <lodepng_color_mode_copy+0x64>
    a28e:	b8 53 00 00 00       	mov    $0x53,%eax
    a293:	eb 2c                	jmp    a2c1 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    a295:	8b 45 0c             	mov    0xc(%ebp),%eax
    a298:	8b 40 0c             	mov    0xc(%eax),%eax
    a29b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    a2a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2a5:	8b 50 08             	mov    0x8(%eax),%edx
    a2a8:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ab:	8b 40 08             	mov    0x8(%eax),%eax
    a2ae:	83 ec 04             	sub    $0x4,%esp
    a2b1:	51                   	push   %ecx
    a2b2:	52                   	push   %edx
    a2b3:	50                   	push   %eax
    a2b4:	e8 9d a7 ff ff       	call   4a56 <lodepng_memcpy>
    a2b9:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    a2bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a2c1:	c9                   	leave  
    a2c2:	c3                   	ret    

0000a2c3 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    a2c3:	55                   	push   %ebp
    a2c4:	89 e5                	mov    %esp,%ebp
    a2c6:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    a2c9:	8d 45 e0             	lea    -0x20(%ebp),%eax
    a2cc:	50                   	push   %eax
    a2cd:	e8 55 fe ff ff       	call   a127 <lodepng_color_mode_init>
    a2d2:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    a2d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    a2db:	8b 45 10             	mov    0x10(%ebp),%eax
    a2de:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    a2e1:	8b 45 08             	mov    0x8(%ebp),%eax
    a2e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
    a2e7:	89 10                	mov    %edx,(%eax)
    a2e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    a2ec:	89 50 04             	mov    %edx,0x4(%eax)
    a2ef:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a2f2:	89 50 08             	mov    %edx,0x8(%eax)
    a2f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    a2f8:	89 50 0c             	mov    %edx,0xc(%eax)
    a2fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a2fe:	89 50 10             	mov    %edx,0x10(%eax)
    a301:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a304:	89 50 14             	mov    %edx,0x14(%eax)
    a307:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a30a:	89 50 18             	mov    %edx,0x18(%eax)
    a30d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a310:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    a313:	8b 45 08             	mov    0x8(%ebp),%eax
    a316:	c9                   	leave  
    a317:	c2 04 00             	ret    $0x4

0000a31a <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    a31a:	55                   	push   %ebp
    a31b:	89 e5                	mov    %esp,%ebp
    a31d:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    a320:	8b 45 08             	mov    0x8(%ebp),%eax
    a323:	8b 10                	mov    (%eax),%edx
    a325:	8b 45 0c             	mov    0xc(%ebp),%eax
    a328:	8b 00                	mov    (%eax),%eax
    a32a:	39 c2                	cmp    %eax,%edx
    a32c:	74 0a                	je     a338 <lodepng_color_mode_equal+0x1e>
    a32e:	b8 00 00 00 00       	mov    $0x0,%eax
    a333:	e9 e4 00 00 00       	jmp    a41c <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    a338:	8b 45 08             	mov    0x8(%ebp),%eax
    a33b:	8b 50 04             	mov    0x4(%eax),%edx
    a33e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a341:	8b 40 04             	mov    0x4(%eax),%eax
    a344:	39 c2                	cmp    %eax,%edx
    a346:	74 0a                	je     a352 <lodepng_color_mode_equal+0x38>
    a348:	b8 00 00 00 00       	mov    $0x0,%eax
    a34d:	e9 ca 00 00 00       	jmp    a41c <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    a352:	8b 45 08             	mov    0x8(%ebp),%eax
    a355:	8b 50 10             	mov    0x10(%eax),%edx
    a358:	8b 45 0c             	mov    0xc(%ebp),%eax
    a35b:	8b 40 10             	mov    0x10(%eax),%eax
    a35e:	39 c2                	cmp    %eax,%edx
    a360:	74 0a                	je     a36c <lodepng_color_mode_equal+0x52>
    a362:	b8 00 00 00 00       	mov    $0x0,%eax
    a367:	e9 b0 00 00 00       	jmp    a41c <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    a36c:	8b 45 08             	mov    0x8(%ebp),%eax
    a36f:	8b 40 10             	mov    0x10(%eax),%eax
    a372:	85 c0                	test   %eax,%eax
    a374:	74 48                	je     a3be <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    a376:	8b 45 08             	mov    0x8(%ebp),%eax
    a379:	8b 50 14             	mov    0x14(%eax),%edx
    a37c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a37f:	8b 40 14             	mov    0x14(%eax),%eax
    a382:	39 c2                	cmp    %eax,%edx
    a384:	74 0a                	je     a390 <lodepng_color_mode_equal+0x76>
    a386:	b8 00 00 00 00       	mov    $0x0,%eax
    a38b:	e9 8c 00 00 00       	jmp    a41c <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    a390:	8b 45 08             	mov    0x8(%ebp),%eax
    a393:	8b 50 18             	mov    0x18(%eax),%edx
    a396:	8b 45 0c             	mov    0xc(%ebp),%eax
    a399:	8b 40 18             	mov    0x18(%eax),%eax
    a39c:	39 c2                	cmp    %eax,%edx
    a39e:	74 07                	je     a3a7 <lodepng_color_mode_equal+0x8d>
    a3a0:	b8 00 00 00 00       	mov    $0x0,%eax
    a3a5:	eb 75                	jmp    a41c <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    a3a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a3aa:	8b 50 1c             	mov    0x1c(%eax),%edx
    a3ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3b0:	8b 40 1c             	mov    0x1c(%eax),%eax
    a3b3:	39 c2                	cmp    %eax,%edx
    a3b5:	74 07                	je     a3be <lodepng_color_mode_equal+0xa4>
    a3b7:	b8 00 00 00 00       	mov    $0x0,%eax
    a3bc:	eb 5e                	jmp    a41c <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    a3be:	8b 45 08             	mov    0x8(%ebp),%eax
    a3c1:	8b 50 0c             	mov    0xc(%eax),%edx
    a3c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3c7:	8b 40 0c             	mov    0xc(%eax),%eax
    a3ca:	39 c2                	cmp    %eax,%edx
    a3cc:	74 07                	je     a3d5 <lodepng_color_mode_equal+0xbb>
    a3ce:	b8 00 00 00 00       	mov    $0x0,%eax
    a3d3:	eb 47                	jmp    a41c <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    a3d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    a3dc:	eb 2b                	jmp    a409 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    a3de:	8b 45 08             	mov    0x8(%ebp),%eax
    a3e1:	8b 50 08             	mov    0x8(%eax),%edx
    a3e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a3e7:	01 d0                	add    %edx,%eax
    a3e9:	0f b6 10             	movzbl (%eax),%edx
    a3ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3ef:	8b 48 08             	mov    0x8(%eax),%ecx
    a3f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a3f5:	01 c8                	add    %ecx,%eax
    a3f7:	0f b6 00             	movzbl (%eax),%eax
    a3fa:	38 c2                	cmp    %al,%dl
    a3fc:	74 07                	je     a405 <lodepng_color_mode_equal+0xeb>
    a3fe:	b8 00 00 00 00       	mov    $0x0,%eax
    a403:	eb 17                	jmp    a41c <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    a405:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a409:	8b 45 08             	mov    0x8(%ebp),%eax
    a40c:	8b 40 0c             	mov    0xc(%eax),%eax
    a40f:	c1 e0 02             	shl    $0x2,%eax
    a412:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    a415:	75 c7                	jne    a3de <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    a417:	b8 01 00 00 00       	mov    $0x1,%eax
}
    a41c:	c9                   	leave  
    a41d:	c3                   	ret    

0000a41e <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    a41e:	55                   	push   %ebp
    a41f:	89 e5                	mov    %esp,%ebp
    a421:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    a424:	8b 45 08             	mov    0x8(%ebp),%eax
    a427:	8b 40 08             	mov    0x8(%eax),%eax
    a42a:	85 c0                	test   %eax,%eax
    a42c:	74 12                	je     a440 <lodepng_palette_clear+0x22>
    a42e:	8b 45 08             	mov    0x8(%ebp),%eax
    a431:	8b 40 08             	mov    0x8(%eax),%eax
    a434:	83 ec 0c             	sub    $0xc,%esp
    a437:	50                   	push   %eax
    a438:	e8 fc a5 ff ff       	call   4a39 <lodepng_free>
    a43d:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    a440:	8b 45 08             	mov    0x8(%ebp),%eax
    a443:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    a44a:	8b 45 08             	mov    0x8(%ebp),%eax
    a44d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    a454:	90                   	nop
    a455:	c9                   	leave  
    a456:	c3                   	ret    

0000a457 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a457:	55                   	push   %ebp
    a458:	89 e5                	mov    %esp,%ebp
    a45a:	53                   	push   %ebx
    a45b:	83 ec 14             	sub    $0x14,%esp
    a45e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a461:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a464:	8b 55 14             	mov    0x14(%ebp),%edx
    a467:	8b 45 18             	mov    0x18(%ebp),%eax
    a46a:	88 5d f4             	mov    %bl,-0xc(%ebp)
    a46d:	88 4d f0             	mov    %cl,-0x10(%ebp)
    a470:	88 55 ec             	mov    %dl,-0x14(%ebp)
    a473:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    a476:	8b 45 08             	mov    0x8(%ebp),%eax
    a479:	8b 40 08             	mov    0x8(%eax),%eax
    a47c:	85 c0                	test   %eax,%eax
    a47e:	75 22                	jne    a4a2 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    a480:	83 ec 0c             	sub    $0xc,%esp
    a483:	ff 75 08             	pushl  0x8(%ebp)
    a486:	e8 f5 fc ff ff       	call   a180 <lodepng_color_mode_alloc_palette>
    a48b:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    a48e:	8b 45 08             	mov    0x8(%ebp),%eax
    a491:	8b 40 08             	mov    0x8(%eax),%eax
    a494:	85 c0                	test   %eax,%eax
    a496:	75 0a                	jne    a4a2 <lodepng_palette_add+0x4b>
    a498:	b8 53 00 00 00       	mov    $0x53,%eax
    a49d:	e9 8d 00 00 00       	jmp    a52f <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    a4a2:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a5:	8b 40 0c             	mov    0xc(%eax),%eax
    a4a8:	3d ff 00 00 00       	cmp    $0xff,%eax
    a4ad:	7e 07                	jle    a4b6 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    a4af:	b8 6c 00 00 00       	mov    $0x6c,%eax
    a4b4:	eb 79                	jmp    a52f <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    a4b6:	8b 45 08             	mov    0x8(%ebp),%eax
    a4b9:	8b 50 08             	mov    0x8(%eax),%edx
    a4bc:	8b 45 08             	mov    0x8(%ebp),%eax
    a4bf:	8b 40 0c             	mov    0xc(%eax),%eax
    a4c2:	c1 e0 02             	shl    $0x2,%eax
    a4c5:	01 c2                	add    %eax,%edx
    a4c7:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    a4cb:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    a4cd:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d0:	8b 50 08             	mov    0x8(%eax),%edx
    a4d3:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d6:	8b 40 0c             	mov    0xc(%eax),%eax
    a4d9:	c1 e0 02             	shl    $0x2,%eax
    a4dc:	83 c0 01             	add    $0x1,%eax
    a4df:	01 c2                	add    %eax,%edx
    a4e1:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    a4e5:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    a4e7:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ea:	8b 50 08             	mov    0x8(%eax),%edx
    a4ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a4f0:	8b 40 0c             	mov    0xc(%eax),%eax
    a4f3:	c1 e0 02             	shl    $0x2,%eax
    a4f6:	83 c0 02             	add    $0x2,%eax
    a4f9:	01 c2                	add    %eax,%edx
    a4fb:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    a4ff:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    a501:	8b 45 08             	mov    0x8(%ebp),%eax
    a504:	8b 50 08             	mov    0x8(%eax),%edx
    a507:	8b 45 08             	mov    0x8(%ebp),%eax
    a50a:	8b 40 0c             	mov    0xc(%eax),%eax
    a50d:	c1 e0 02             	shl    $0x2,%eax
    a510:	83 c0 03             	add    $0x3,%eax
    a513:	01 c2                	add    %eax,%edx
    a515:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a519:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    a51b:	8b 45 08             	mov    0x8(%ebp),%eax
    a51e:	8b 40 0c             	mov    0xc(%eax),%eax
    a521:	8d 50 01             	lea    0x1(%eax),%edx
    a524:	8b 45 08             	mov    0x8(%ebp),%eax
    a527:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    a52a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a52f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a532:	c9                   	leave  
    a533:	c3                   	ret    

0000a534 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    a534:	55                   	push   %ebp
    a535:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    a537:	8b 45 08             	mov    0x8(%ebp),%eax
    a53a:	8b 50 04             	mov    0x4(%eax),%edx
    a53d:	8b 45 08             	mov    0x8(%ebp),%eax
    a540:	8b 00                	mov    (%eax),%eax
    a542:	52                   	push   %edx
    a543:	50                   	push   %eax
    a544:	e8 ca fb ff ff       	call   a113 <lodepng_get_bpp_lct>
    a549:	83 c4 08             	add    $0x8,%esp
}
    a54c:	c9                   	leave  
    a54d:	c3                   	ret    

0000a54e <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    a54e:	55                   	push   %ebp
    a54f:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    a551:	8b 45 08             	mov    0x8(%ebp),%eax
    a554:	8b 00                	mov    (%eax),%eax
    a556:	50                   	push   %eax
    a557:	e8 58 fb ff ff       	call   a0b4 <getNumColorChannels>
    a55c:	83 c4 04             	add    $0x4,%esp
}
    a55f:	c9                   	leave  
    a560:	c3                   	ret    

0000a561 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    a561:	55                   	push   %ebp
    a562:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    a564:	8b 45 08             	mov    0x8(%ebp),%eax
    a567:	8b 00                	mov    (%eax),%eax
    a569:	85 c0                	test   %eax,%eax
    a56b:	74 0a                	je     a577 <lodepng_is_greyscale_type+0x16>
    a56d:	8b 45 08             	mov    0x8(%ebp),%eax
    a570:	8b 00                	mov    (%eax),%eax
    a572:	83 f8 04             	cmp    $0x4,%eax
    a575:	75 07                	jne    a57e <lodepng_is_greyscale_type+0x1d>
    a577:	b8 01 00 00 00       	mov    $0x1,%eax
    a57c:	eb 05                	jmp    a583 <lodepng_is_greyscale_type+0x22>
    a57e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a583:	5d                   	pop    %ebp
    a584:	c3                   	ret    

0000a585 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    a585:	55                   	push   %ebp
    a586:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    a588:	8b 45 08             	mov    0x8(%ebp),%eax
    a58b:	8b 00                	mov    (%eax),%eax
    a58d:	83 e0 04             	and    $0x4,%eax
    a590:	85 c0                	test   %eax,%eax
    a592:	0f 95 c0             	setne  %al
    a595:	0f b6 c0             	movzbl %al,%eax
}
    a598:	5d                   	pop    %ebp
    a599:	c3                   	ret    

0000a59a <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    a59a:	55                   	push   %ebp
    a59b:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    a59d:	8b 45 08             	mov    0x8(%ebp),%eax
    a5a0:	8b 00                	mov    (%eax),%eax
    a5a2:	83 f8 03             	cmp    $0x3,%eax
    a5a5:	0f 94 c0             	sete   %al
    a5a8:	0f b6 c0             	movzbl %al,%eax
}
    a5ab:	5d                   	pop    %ebp
    a5ac:	c3                   	ret    

0000a5ad <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    a5ad:	55                   	push   %ebp
    a5ae:	89 e5                	mov    %esp,%ebp
    a5b0:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    a5b3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    a5ba:	eb 23                	jmp    a5df <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    a5bc:	8b 45 08             	mov    0x8(%ebp),%eax
    a5bf:	8b 40 08             	mov    0x8(%eax),%eax
    a5c2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a5c5:	c1 e2 02             	shl    $0x2,%edx
    a5c8:	83 c2 03             	add    $0x3,%edx
    a5cb:	01 d0                	add    %edx,%eax
    a5cd:	0f b6 00             	movzbl (%eax),%eax
    a5d0:	3c ff                	cmp    $0xff,%al
    a5d2:	74 07                	je     a5db <lodepng_has_palette_alpha+0x2e>
    a5d4:	b8 01 00 00 00       	mov    $0x1,%eax
    a5d9:	eb 14                	jmp    a5ef <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    a5db:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a5df:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e2:	8b 40 0c             	mov    0xc(%eax),%eax
    a5e5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    a5e8:	75 d2                	jne    a5bc <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    a5ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a5ef:	c9                   	leave  
    a5f0:	c3                   	ret    

0000a5f1 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    a5f1:	55                   	push   %ebp
    a5f2:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    a5f4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f7:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    a5fa:	85 c0                	test   %eax,%eax
    a5fc:	75 1e                	jne    a61c <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    a5fe:	ff 75 08             	pushl  0x8(%ebp)
    a601:	e8 7f ff ff ff       	call   a585 <lodepng_is_alpha_type>
    a606:	83 c4 04             	add    $0x4,%esp
    a609:	85 c0                	test   %eax,%eax
    a60b:	75 0f                	jne    a61c <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    a60d:	ff 75 08             	pushl  0x8(%ebp)
    a610:	e8 98 ff ff ff       	call   a5ad <lodepng_has_palette_alpha>
    a615:	83 c4 04             	add    $0x4,%esp
    a618:	85 c0                	test   %eax,%eax
    a61a:	74 07                	je     a623 <lodepng_can_have_alpha+0x32>
    a61c:	b8 01 00 00 00       	mov    $0x1,%eax
    a621:	eb 05                	jmp    a628 <lodepng_can_have_alpha+0x37>
    a623:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a628:	c9                   	leave  
    a629:	c3                   	ret    

0000a62a <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    a62a:	55                   	push   %ebp
    a62b:	89 e5                	mov    %esp,%ebp
    a62d:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    a630:	ff 75 14             	pushl  0x14(%ebp)
    a633:	ff 75 10             	pushl  0x10(%ebp)
    a636:	e8 d8 fa ff ff       	call   a113 <lodepng_get_bpp_lct>
    a63b:	83 c4 08             	add    $0x8,%esp
    a63e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    a641:	8b 55 08             	mov    0x8(%ebp),%edx
    a644:	8b 45 0c             	mov    0xc(%ebp),%eax
    a647:	0f af c2             	imul   %edx,%eax
    a64a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    a64d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a650:	c1 e8 03             	shr    $0x3,%eax
    a653:	89 c2                	mov    %eax,%edx
    a655:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a658:	0f af c2             	imul   %edx,%eax
    a65b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a65e:	89 d1                	mov    %edx,%ecx
    a660:	83 e1 07             	and    $0x7,%ecx
    a663:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a666:	0f af d1             	imul   %ecx,%edx
    a669:	83 c2 07             	add    $0x7,%edx
    a66c:	c1 ea 03             	shr    $0x3,%edx
    a66f:	01 d0                	add    %edx,%eax
}
    a671:	c9                   	leave  
    a672:	c3                   	ret    

0000a673 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    a673:	55                   	push   %ebp
    a674:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    a676:	8b 45 10             	mov    0x10(%ebp),%eax
    a679:	8b 50 04             	mov    0x4(%eax),%edx
    a67c:	8b 45 10             	mov    0x10(%ebp),%eax
    a67f:	8b 00                	mov    (%eax),%eax
    a681:	52                   	push   %edx
    a682:	50                   	push   %eax
    a683:	ff 75 0c             	pushl  0xc(%ebp)
    a686:	ff 75 08             	pushl  0x8(%ebp)
    a689:	e8 9c ff ff ff       	call   a62a <lodepng_get_raw_size_lct>
    a68e:	83 c4 10             	add    $0x10,%esp
}
    a691:	c9                   	leave  
    a692:	c3                   	ret    

0000a693 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    a693:	55                   	push   %ebp
    a694:	89 e5                	mov    %esp,%ebp
    a696:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    a699:	8b 45 08             	mov    0x8(%ebp),%eax
    a69c:	c1 e8 03             	shr    $0x3,%eax
    a69f:	0f af 45 10          	imul   0x10(%ebp),%eax
    a6a3:	8b 55 08             	mov    0x8(%ebp),%edx
    a6a6:	83 e2 07             	and    $0x7,%edx
    a6a9:	0f af 55 10          	imul   0x10(%ebp),%edx
    a6ad:	83 c2 07             	add    $0x7,%edx
    a6b0:	c1 ea 03             	shr    $0x3,%edx
    a6b3:	01 d0                	add    %edx,%eax
    a6b5:	83 c0 01             	add    $0x1,%eax
    a6b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    a6bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6be:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    a6c2:	c9                   	leave  
    a6c3:	c3                   	ret    

0000a6c4 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    a6c4:	55                   	push   %ebp
    a6c5:	89 e5                	mov    %esp,%ebp
    a6c7:	53                   	push   %ebx
    a6c8:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    a6cb:	ff 75 10             	pushl  0x10(%ebp)
    a6ce:	e8 61 fe ff ff       	call   a534 <lodepng_get_bpp>
    a6d3:	83 c4 04             	add    $0x4,%esp
    a6d6:	89 c3                	mov    %eax,%ebx
    a6d8:	ff 75 14             	pushl  0x14(%ebp)
    a6db:	e8 54 fe ff ff       	call   a534 <lodepng_get_bpp>
    a6e0:	83 c4 04             	add    $0x4,%esp
    a6e3:	39 c3                	cmp    %eax,%ebx
    a6e5:	76 0d                	jbe    a6f4 <lodepng_pixel_overflow+0x30>
    a6e7:	ff 75 10             	pushl  0x10(%ebp)
    a6ea:	e8 45 fe ff ff       	call   a534 <lodepng_get_bpp>
    a6ef:	83 c4 04             	add    $0x4,%esp
    a6f2:	eb 0b                	jmp    a6ff <lodepng_pixel_overflow+0x3b>
    a6f4:	ff 75 14             	pushl  0x14(%ebp)
    a6f7:	e8 38 fe ff ff       	call   a534 <lodepng_get_bpp>
    a6fc:	83 c4 04             	add    $0x4,%esp
    a6ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    a702:	8b 55 0c             	mov    0xc(%ebp),%edx
    a705:	8b 45 08             	mov    0x8(%ebp),%eax
    a708:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    a70b:	51                   	push   %ecx
    a70c:	52                   	push   %edx
    a70d:	50                   	push   %eax
    a70e:	e8 e9 a3 ff ff       	call   4afc <lodepng_mulofl>
    a713:	83 c4 0c             	add    $0xc,%esp
    a716:	85 c0                	test   %eax,%eax
    a718:	74 0a                	je     a724 <lodepng_pixel_overflow+0x60>
    a71a:	b8 01 00 00 00       	mov    $0x1,%eax
    a71f:	e9 b6 00 00 00       	jmp    a7da <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    a724:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a727:	8d 55 f0             	lea    -0x10(%ebp),%edx
    a72a:	52                   	push   %edx
    a72b:	6a 08                	push   $0x8
    a72d:	50                   	push   %eax
    a72e:	e8 c9 a3 ff ff       	call   4afc <lodepng_mulofl>
    a733:	83 c4 0c             	add    $0xc,%esp
    a736:	85 c0                	test   %eax,%eax
    a738:	74 0a                	je     a744 <lodepng_pixel_overflow+0x80>
    a73a:	b8 01 00 00 00       	mov    $0x1,%eax
    a73f:	e9 96 00 00 00       	jmp    a7da <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    a744:	8b 45 08             	mov    0x8(%ebp),%eax
    a747:	c1 e8 03             	shr    $0x3,%eax
    a74a:	89 c2                	mov    %eax,%edx
    a74c:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a74f:	50                   	push   %eax
    a750:	ff 75 f8             	pushl  -0x8(%ebp)
    a753:	52                   	push   %edx
    a754:	e8 a3 a3 ff ff       	call   4afc <lodepng_mulofl>
    a759:	83 c4 0c             	add    $0xc,%esp
    a75c:	85 c0                	test   %eax,%eax
    a75e:	74 07                	je     a767 <lodepng_pixel_overflow+0xa3>
    a760:	b8 01 00 00 00       	mov    $0x1,%eax
    a765:	eb 73                	jmp    a7da <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    a767:	8b 45 08             	mov    0x8(%ebp),%eax
    a76a:	83 e0 07             	and    $0x7,%eax
    a76d:	89 c2                	mov    %eax,%edx
    a76f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a772:	0f af c2             	imul   %edx,%eax
    a775:	83 c0 07             	add    $0x7,%eax
    a778:	c1 e8 03             	shr    $0x3,%eax
    a77b:	89 c1                	mov    %eax,%ecx
    a77d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a780:	8d 55 ec             	lea    -0x14(%ebp),%edx
    a783:	52                   	push   %edx
    a784:	51                   	push   %ecx
    a785:	50                   	push   %eax
    a786:	e8 51 a3 ff ff       	call   4adc <lodepng_addofl>
    a78b:	83 c4 0c             	add    $0xc,%esp
    a78e:	85 c0                	test   %eax,%eax
    a790:	74 07                	je     a799 <lodepng_pixel_overflow+0xd5>
    a792:	b8 01 00 00 00       	mov    $0x1,%eax
    a797:	eb 41                	jmp    a7da <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    a799:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a79c:	8d 55 ec             	lea    -0x14(%ebp),%edx
    a79f:	52                   	push   %edx
    a7a0:	6a 05                	push   $0x5
    a7a2:	50                   	push   %eax
    a7a3:	e8 34 a3 ff ff       	call   4adc <lodepng_addofl>
    a7a8:	83 c4 0c             	add    $0xc,%esp
    a7ab:	85 c0                	test   %eax,%eax
    a7ad:	74 07                	je     a7b6 <lodepng_pixel_overflow+0xf2>
    a7af:	b8 01 00 00 00       	mov    $0x1,%eax
    a7b4:	eb 24                	jmp    a7da <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    a7b6:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a7bc:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    a7bf:	51                   	push   %ecx
    a7c0:	52                   	push   %edx
    a7c1:	50                   	push   %eax
    a7c2:	e8 35 a3 ff ff       	call   4afc <lodepng_mulofl>
    a7c7:	83 c4 0c             	add    $0xc,%esp
    a7ca:	85 c0                	test   %eax,%eax
    a7cc:	74 07                	je     a7d5 <lodepng_pixel_overflow+0x111>
    a7ce:	b8 01 00 00 00       	mov    $0x1,%eax
    a7d3:	eb 05                	jmp    a7da <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    a7d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a7da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a7dd:	c9                   	leave  
    a7de:	c3                   	ret    

0000a7df <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    a7df:	55                   	push   %ebp
    a7e0:	89 e5                	mov    %esp,%ebp
    a7e2:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    a7e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    a7ec:	eb 15                	jmp    a803 <LodePNGUnknownChunks_init+0x24>
    a7ee:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a7f4:	83 c2 30             	add    $0x30,%edx
    a7f7:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    a7fe:	00 
    a7ff:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a803:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    a807:	75 e5                	jne    a7ee <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    a809:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    a810:	eb 15                	jmp    a827 <LodePNGUnknownChunks_init+0x48>
    a812:	8b 45 08             	mov    0x8(%ebp),%eax
    a815:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a818:	83 c2 34             	add    $0x34,%edx
    a81b:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    a822:	00 
    a823:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a827:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    a82b:	75 e5                	jne    a812 <LodePNGUnknownChunks_init+0x33>
}
    a82d:	90                   	nop
    a82e:	c9                   	leave  
    a82f:	c3                   	ret    

0000a830 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    a830:	55                   	push   %ebp
    a831:	89 e5                	mov    %esp,%ebp
    a833:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    a836:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a83d:	eb 1d                	jmp    a85c <LodePNGUnknownChunks_cleanup+0x2c>
    a83f:	8b 45 08             	mov    0x8(%ebp),%eax
    a842:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a845:	83 c2 30             	add    $0x30,%edx
    a848:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    a84c:	83 ec 0c             	sub    $0xc,%esp
    a84f:	50                   	push   %eax
    a850:	e8 e4 a1 ff ff       	call   4a39 <lodepng_free>
    a855:	83 c4 10             	add    $0x10,%esp
    a858:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a85c:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    a860:	75 dd                	jne    a83f <LodePNGUnknownChunks_cleanup+0xf>
}
    a862:	90                   	nop
    a863:	c9                   	leave  
    a864:	c3                   	ret    

0000a865 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    a865:	55                   	push   %ebp
    a866:	89 e5                	mov    %esp,%ebp
    a868:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    a86b:	83 ec 0c             	sub    $0xc,%esp
    a86e:	ff 75 08             	pushl  0x8(%ebp)
    a871:	e8 ba ff ff ff       	call   a830 <LodePNGUnknownChunks_cleanup>
    a876:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    a879:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a880:	e9 b7 00 00 00       	jmp    a93c <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    a885:	8b 45 0c             	mov    0xc(%ebp),%eax
    a888:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a88b:	83 c2 34             	add    $0x34,%edx
    a88e:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    a892:	8b 45 08             	mov    0x8(%ebp),%eax
    a895:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    a898:	83 c1 34             	add    $0x34,%ecx
    a89b:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    a89f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a8a5:	83 c2 34             	add    $0x34,%edx
    a8a8:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    a8ac:	83 ec 0c             	sub    $0xc,%esp
    a8af:	50                   	push   %eax
    a8b0:	e8 63 a1 ff ff       	call   4a18 <lodepng_malloc>
    a8b5:	83 c4 10             	add    $0x10,%esp
    a8b8:	89 c1                	mov    %eax,%ecx
    a8ba:	8b 45 08             	mov    0x8(%ebp),%eax
    a8bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a8c0:	83 c2 30             	add    $0x30,%edx
    a8c3:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    a8c7:	8b 45 08             	mov    0x8(%ebp),%eax
    a8ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a8cd:	83 c2 30             	add    $0x30,%edx
    a8d0:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    a8d4:	85 c0                	test   %eax,%eax
    a8d6:	75 18                	jne    a8f0 <LodePNGUnknownChunks_copy+0x8b>
    a8d8:	8b 45 08             	mov    0x8(%ebp),%eax
    a8db:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a8de:	83 c2 34             	add    $0x34,%edx
    a8e1:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    a8e5:	85 c0                	test   %eax,%eax
    a8e7:	74 07                	je     a8f0 <LodePNGUnknownChunks_copy+0x8b>
    a8e9:	b8 53 00 00 00       	mov    $0x53,%eax
    a8ee:	eb 5b                	jmp    a94b <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    a8f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    a8f7:	eb 2d                	jmp    a926 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    a8f9:	8b 45 08             	mov    0x8(%ebp),%eax
    a8fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a8ff:	83 c2 30             	add    $0x30,%edx
    a902:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    a906:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a909:	01 c2                	add    %eax,%edx
    a90b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a90e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    a911:	83 c1 30             	add    $0x30,%ecx
    a914:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    a918:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a91b:	01 c8                	add    %ecx,%eax
    a91d:	0f b6 00             	movzbl (%eax),%eax
    a920:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    a922:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    a926:	8b 45 0c             	mov    0xc(%ebp),%eax
    a929:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a92c:	83 c2 34             	add    $0x34,%edx
    a92f:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    a933:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    a936:	7f c1                	jg     a8f9 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    a938:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a93c:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    a940:	0f 85 3f ff ff ff    	jne    a885 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    a946:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a94b:	c9                   	leave  
    a94c:	c3                   	ret    

0000a94d <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    a94d:	55                   	push   %ebp
    a94e:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    a950:	8b 45 08             	mov    0x8(%ebp),%eax
    a953:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    a95a:	8b 45 08             	mov    0x8(%ebp),%eax
    a95d:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    a964:	8b 45 08             	mov    0x8(%ebp),%eax
    a967:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    a96e:	90                   	nop
    a96f:	5d                   	pop    %ebp
    a970:	c3                   	ret    

0000a971 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    a971:	55                   	push   %ebp
    a972:	89 e5                	mov    %esp,%ebp
    a974:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    a977:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a97e:	eb 38                	jmp    a9b8 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    a980:	8b 45 08             	mov    0x8(%ebp),%eax
    a983:	8b 40 40             	mov    0x40(%eax),%eax
    a986:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a989:	c1 e2 02             	shl    $0x2,%edx
    a98c:	01 d0                	add    %edx,%eax
    a98e:	83 ec 0c             	sub    $0xc,%esp
    a991:	50                   	push   %eax
    a992:	e8 75 a3 ff ff       	call   4d0c <string_cleanup>
    a997:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    a99a:	8b 45 08             	mov    0x8(%ebp),%eax
    a99d:	8b 40 44             	mov    0x44(%eax),%eax
    a9a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a9a3:	c1 e2 02             	shl    $0x2,%edx
    a9a6:	01 d0                	add    %edx,%eax
    a9a8:	83 ec 0c             	sub    $0xc,%esp
    a9ab:	50                   	push   %eax
    a9ac:	e8 5b a3 ff ff       	call   4d0c <string_cleanup>
    a9b1:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    a9b4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a9b8:	8b 45 08             	mov    0x8(%ebp),%eax
    a9bb:	8b 40 3c             	mov    0x3c(%eax),%eax
    a9be:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a9c1:	75 bd                	jne    a980 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    a9c3:	8b 45 08             	mov    0x8(%ebp),%eax
    a9c6:	8b 40 40             	mov    0x40(%eax),%eax
    a9c9:	83 ec 0c             	sub    $0xc,%esp
    a9cc:	50                   	push   %eax
    a9cd:	e8 67 a0 ff ff       	call   4a39 <lodepng_free>
    a9d2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    a9d5:	8b 45 08             	mov    0x8(%ebp),%eax
    a9d8:	8b 40 44             	mov    0x44(%eax),%eax
    a9db:	83 ec 0c             	sub    $0xc,%esp
    a9de:	50                   	push   %eax
    a9df:	e8 55 a0 ff ff       	call   4a39 <lodepng_free>
    a9e4:	83 c4 10             	add    $0x10,%esp
}
    a9e7:	90                   	nop
    a9e8:	c9                   	leave  
    a9e9:	c3                   	ret    

0000a9ea <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    a9ea:	55                   	push   %ebp
    a9eb:	89 e5                	mov    %esp,%ebp
    a9ed:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    a9f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    a9f7:	8b 45 08             	mov    0x8(%ebp),%eax
    a9fa:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    aa01:	8b 45 08             	mov    0x8(%ebp),%eax
    aa04:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    aa0b:	8b 45 08             	mov    0x8(%ebp),%eax
    aa0e:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    aa15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    aa1c:	eb 42                	jmp    aa60 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    aa1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa21:	8b 40 44             	mov    0x44(%eax),%eax
    aa24:	8b 55 f4             	mov    -0xc(%ebp),%edx
    aa27:	c1 e2 02             	shl    $0x2,%edx
    aa2a:	01 d0                	add    %edx,%eax
    aa2c:	8b 10                	mov    (%eax),%edx
    aa2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa31:	8b 40 40             	mov    0x40(%eax),%eax
    aa34:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    aa37:	c1 e1 02             	shl    $0x2,%ecx
    aa3a:	01 c8                	add    %ecx,%eax
    aa3c:	8b 00                	mov    (%eax),%eax
    aa3e:	83 ec 04             	sub    $0x4,%esp
    aa41:	52                   	push   %edx
    aa42:	50                   	push   %eax
    aa43:	ff 75 08             	pushl  0x8(%ebp)
    aa46:	e8 4d 01 00 00       	call   ab98 <lodepng_add_text>
    aa4b:	83 c4 10             	add    $0x10,%esp
    aa4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    aa51:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    aa55:	74 05                	je     aa5c <LodePNGText_copy+0x72>
    aa57:	8b 45 f0             	mov    -0x10(%ebp),%eax
    aa5a:	eb 14                	jmp    aa70 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    aa5c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    aa60:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa63:	8b 40 3c             	mov    0x3c(%eax),%eax
    aa66:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    aa69:	75 b3                	jne    aa1e <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    aa6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    aa70:	c9                   	leave  
    aa71:	c3                   	ret    

0000aa72 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    aa72:	55                   	push   %ebp
    aa73:	89 e5                	mov    %esp,%ebp
    aa75:	53                   	push   %ebx
    aa76:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    aa79:	8b 45 08             	mov    0x8(%ebp),%eax
    aa7c:	8b 40 3c             	mov    0x3c(%eax),%eax
    aa7f:	83 c0 01             	add    $0x1,%eax
    aa82:	c1 e0 02             	shl    $0x2,%eax
    aa85:	89 c2                	mov    %eax,%edx
    aa87:	8b 45 08             	mov    0x8(%ebp),%eax
    aa8a:	8b 40 40             	mov    0x40(%eax),%eax
    aa8d:	52                   	push   %edx
    aa8e:	50                   	push   %eax
    aa8f:	e8 9b 9f ff ff       	call   4a2f <lodepng_realloc>
    aa94:	83 c4 08             	add    $0x8,%esp
    aa97:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    aa9a:	8b 45 08             	mov    0x8(%ebp),%eax
    aa9d:	8b 40 3c             	mov    0x3c(%eax),%eax
    aaa0:	83 c0 01             	add    $0x1,%eax
    aaa3:	c1 e0 02             	shl    $0x2,%eax
    aaa6:	89 c2                	mov    %eax,%edx
    aaa8:	8b 45 08             	mov    0x8(%ebp),%eax
    aaab:	8b 40 44             	mov    0x44(%eax),%eax
    aaae:	52                   	push   %edx
    aaaf:	50                   	push   %eax
    aab0:	e8 7a 9f ff ff       	call   4a2f <lodepng_realloc>
    aab5:	83 c4 08             	add    $0x8,%esp
    aab8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    aabb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    aabf:	74 09                	je     aaca <lodepng_add_text_sized+0x58>
    aac1:	8b 45 08             	mov    0x8(%ebp),%eax
    aac4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    aac7:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    aaca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    aace:	74 09                	je     aad9 <lodepng_add_text_sized+0x67>
    aad0:	8b 45 08             	mov    0x8(%ebp),%eax
    aad3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aad6:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    aad9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    aadd:	74 06                	je     aae5 <lodepng_add_text_sized+0x73>
    aadf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    aae3:	75 0a                	jne    aaef <lodepng_add_text_sized+0x7d>
    aae5:	b8 53 00 00 00       	mov    $0x53,%eax
    aaea:	e9 a4 00 00 00       	jmp    ab93 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    aaef:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf2:	8b 40 3c             	mov    0x3c(%eax),%eax
    aaf5:	8d 50 01             	lea    0x1(%eax),%edx
    aaf8:	8b 45 08             	mov    0x8(%ebp),%eax
    aafb:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    aafe:	8b 45 08             	mov    0x8(%ebp),%eax
    ab01:	8b 50 40             	mov    0x40(%eax),%edx
    ab04:	8b 45 08             	mov    0x8(%ebp),%eax
    ab07:	8b 40 3c             	mov    0x3c(%eax),%eax
    ab0a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    ab0f:	c1 e0 02             	shl    $0x2,%eax
    ab12:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ab15:	83 ec 0c             	sub    $0xc,%esp
    ab18:	ff 75 0c             	pushl  0xc(%ebp)
    ab1b:	e8 54 a2 ff ff       	call   4d74 <alloc_string>
    ab20:	83 c4 10             	add    $0x10,%esp
    ab23:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    ab25:	8b 45 08             	mov    0x8(%ebp),%eax
    ab28:	8b 50 44             	mov    0x44(%eax),%edx
    ab2b:	8b 45 08             	mov    0x8(%ebp),%eax
    ab2e:	8b 40 3c             	mov    0x3c(%eax),%eax
    ab31:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    ab36:	c1 e0 02             	shl    $0x2,%eax
    ab39:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ab3c:	83 ec 08             	sub    $0x8,%esp
    ab3f:	ff 75 14             	pushl  0x14(%ebp)
    ab42:	ff 75 10             	pushl  0x10(%ebp)
    ab45:	e8 e5 a1 ff ff       	call   4d2f <alloc_string_sized>
    ab4a:	83 c4 10             	add    $0x10,%esp
    ab4d:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    ab4f:	8b 45 08             	mov    0x8(%ebp),%eax
    ab52:	8b 50 40             	mov    0x40(%eax),%edx
    ab55:	8b 45 08             	mov    0x8(%ebp),%eax
    ab58:	8b 40 3c             	mov    0x3c(%eax),%eax
    ab5b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    ab60:	c1 e0 02             	shl    $0x2,%eax
    ab63:	01 d0                	add    %edx,%eax
    ab65:	8b 00                	mov    (%eax),%eax
    ab67:	85 c0                	test   %eax,%eax
    ab69:	74 1c                	je     ab87 <lodepng_add_text_sized+0x115>
    ab6b:	8b 45 08             	mov    0x8(%ebp),%eax
    ab6e:	8b 50 44             	mov    0x44(%eax),%edx
    ab71:	8b 45 08             	mov    0x8(%ebp),%eax
    ab74:	8b 40 3c             	mov    0x3c(%eax),%eax
    ab77:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    ab7c:	c1 e0 02             	shl    $0x2,%eax
    ab7f:	01 d0                	add    %edx,%eax
    ab81:	8b 00                	mov    (%eax),%eax
    ab83:	85 c0                	test   %eax,%eax
    ab85:	75 07                	jne    ab8e <lodepng_add_text_sized+0x11c>
    ab87:	b8 53 00 00 00       	mov    $0x53,%eax
    ab8c:	eb 05                	jmp    ab93 <lodepng_add_text_sized+0x121>

  return 0;
    ab8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ab93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ab96:	c9                   	leave  
    ab97:	c3                   	ret    

0000ab98 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    ab98:	55                   	push   %ebp
    ab99:	89 e5                	mov    %esp,%ebp
    ab9b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    ab9e:	ff 75 10             	pushl  0x10(%ebp)
    aba1:	e8 0e 9f ff ff       	call   4ab4 <lodepng_strlen>
    aba6:	83 c4 04             	add    $0x4,%esp
    aba9:	50                   	push   %eax
    abaa:	ff 75 10             	pushl  0x10(%ebp)
    abad:	ff 75 0c             	pushl  0xc(%ebp)
    abb0:	ff 75 08             	pushl  0x8(%ebp)
    abb3:	e8 ba fe ff ff       	call   aa72 <lodepng_add_text_sized>
    abb8:	83 c4 10             	add    $0x10,%esp
}
    abbb:	c9                   	leave  
    abbc:	c3                   	ret    

0000abbd <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    abbd:	55                   	push   %ebp
    abbe:	89 e5                	mov    %esp,%ebp
    abc0:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    abc3:	83 ec 0c             	sub    $0xc,%esp
    abc6:	ff 75 08             	pushl  0x8(%ebp)
    abc9:	e8 a3 fd ff ff       	call   a971 <LodePNGText_cleanup>
    abce:	83 c4 10             	add    $0x10,%esp
}
    abd1:	90                   	nop
    abd2:	c9                   	leave  
    abd3:	c3                   	ret    

0000abd4 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    abd4:	55                   	push   %ebp
    abd5:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    abd7:	8b 45 08             	mov    0x8(%ebp),%eax
    abda:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    abe1:	8b 45 08             	mov    0x8(%ebp),%eax
    abe4:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    abeb:	8b 45 08             	mov    0x8(%ebp),%eax
    abee:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    abf5:	8b 45 08             	mov    0x8(%ebp),%eax
    abf8:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    abff:	8b 45 08             	mov    0x8(%ebp),%eax
    ac02:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    ac09:	90                   	nop
    ac0a:	5d                   	pop    %ebp
    ac0b:	c3                   	ret    

0000ac0c <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    ac0c:	55                   	push   %ebp
    ac0d:	89 e5                	mov    %esp,%ebp
    ac0f:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    ac12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ac19:	eb 6c                	jmp    ac87 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    ac1b:	8b 45 08             	mov    0x8(%ebp),%eax
    ac1e:	8b 40 4c             	mov    0x4c(%eax),%eax
    ac21:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ac24:	c1 e2 02             	shl    $0x2,%edx
    ac27:	01 d0                	add    %edx,%eax
    ac29:	83 ec 0c             	sub    $0xc,%esp
    ac2c:	50                   	push   %eax
    ac2d:	e8 da a0 ff ff       	call   4d0c <string_cleanup>
    ac32:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    ac35:	8b 45 08             	mov    0x8(%ebp),%eax
    ac38:	8b 40 50             	mov    0x50(%eax),%eax
    ac3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ac3e:	c1 e2 02             	shl    $0x2,%edx
    ac41:	01 d0                	add    %edx,%eax
    ac43:	83 ec 0c             	sub    $0xc,%esp
    ac46:	50                   	push   %eax
    ac47:	e8 c0 a0 ff ff       	call   4d0c <string_cleanup>
    ac4c:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    ac4f:	8b 45 08             	mov    0x8(%ebp),%eax
    ac52:	8b 40 54             	mov    0x54(%eax),%eax
    ac55:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ac58:	c1 e2 02             	shl    $0x2,%edx
    ac5b:	01 d0                	add    %edx,%eax
    ac5d:	83 ec 0c             	sub    $0xc,%esp
    ac60:	50                   	push   %eax
    ac61:	e8 a6 a0 ff ff       	call   4d0c <string_cleanup>
    ac66:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    ac69:	8b 45 08             	mov    0x8(%ebp),%eax
    ac6c:	8b 40 58             	mov    0x58(%eax),%eax
    ac6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ac72:	c1 e2 02             	shl    $0x2,%edx
    ac75:	01 d0                	add    %edx,%eax
    ac77:	83 ec 0c             	sub    $0xc,%esp
    ac7a:	50                   	push   %eax
    ac7b:	e8 8c a0 ff ff       	call   4d0c <string_cleanup>
    ac80:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    ac83:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ac87:	8b 45 08             	mov    0x8(%ebp),%eax
    ac8a:	8b 40 48             	mov    0x48(%eax),%eax
    ac8d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    ac90:	75 89                	jne    ac1b <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    ac92:	8b 45 08             	mov    0x8(%ebp),%eax
    ac95:	8b 40 4c             	mov    0x4c(%eax),%eax
    ac98:	83 ec 0c             	sub    $0xc,%esp
    ac9b:	50                   	push   %eax
    ac9c:	e8 98 9d ff ff       	call   4a39 <lodepng_free>
    aca1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    aca4:	8b 45 08             	mov    0x8(%ebp),%eax
    aca7:	8b 40 50             	mov    0x50(%eax),%eax
    acaa:	83 ec 0c             	sub    $0xc,%esp
    acad:	50                   	push   %eax
    acae:	e8 86 9d ff ff       	call   4a39 <lodepng_free>
    acb3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    acb6:	8b 45 08             	mov    0x8(%ebp),%eax
    acb9:	8b 40 54             	mov    0x54(%eax),%eax
    acbc:	83 ec 0c             	sub    $0xc,%esp
    acbf:	50                   	push   %eax
    acc0:	e8 74 9d ff ff       	call   4a39 <lodepng_free>
    acc5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    acc8:	8b 45 08             	mov    0x8(%ebp),%eax
    accb:	8b 40 58             	mov    0x58(%eax),%eax
    acce:	83 ec 0c             	sub    $0xc,%esp
    acd1:	50                   	push   %eax
    acd2:	e8 62 9d ff ff       	call   4a39 <lodepng_free>
    acd7:	83 c4 10             	add    $0x10,%esp
}
    acda:	90                   	nop
    acdb:	c9                   	leave  
    acdc:	c3                   	ret    

0000acdd <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    acdd:	55                   	push   %ebp
    acde:	89 e5                	mov    %esp,%ebp
    ace0:	56                   	push   %esi
    ace1:	53                   	push   %ebx
    ace2:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    ace5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    acec:	8b 45 08             	mov    0x8(%ebp),%eax
    acef:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    acf6:	8b 45 08             	mov    0x8(%ebp),%eax
    acf9:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    ad00:	8b 45 08             	mov    0x8(%ebp),%eax
    ad03:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    ad0a:	8b 45 08             	mov    0x8(%ebp),%eax
    ad0d:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    ad14:	8b 45 08             	mov    0x8(%ebp),%eax
    ad17:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    ad1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ad25:	eb 64                	jmp    ad8b <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    ad27:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad2a:	8b 40 58             	mov    0x58(%eax),%eax
    ad2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ad30:	c1 e2 02             	shl    $0x2,%edx
    ad33:	01 d0                	add    %edx,%eax
    ad35:	8b 18                	mov    (%eax),%ebx
    ad37:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad3a:	8b 40 54             	mov    0x54(%eax),%eax
    ad3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ad40:	c1 e2 02             	shl    $0x2,%edx
    ad43:	01 d0                	add    %edx,%eax
    ad45:	8b 08                	mov    (%eax),%ecx
    ad47:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad4a:	8b 40 50             	mov    0x50(%eax),%eax
    ad4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ad50:	c1 e2 02             	shl    $0x2,%edx
    ad53:	01 d0                	add    %edx,%eax
    ad55:	8b 10                	mov    (%eax),%edx
    ad57:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad5a:	8b 40 4c             	mov    0x4c(%eax),%eax
    ad5d:	8b 75 f4             	mov    -0xc(%ebp),%esi
    ad60:	c1 e6 02             	shl    $0x2,%esi
    ad63:	01 f0                	add    %esi,%eax
    ad65:	8b 00                	mov    (%eax),%eax
    ad67:	83 ec 0c             	sub    $0xc,%esp
    ad6a:	53                   	push   %ebx
    ad6b:	51                   	push   %ecx
    ad6c:	52                   	push   %edx
    ad6d:	50                   	push   %eax
    ad6e:	ff 75 08             	pushl  0x8(%ebp)
    ad71:	e8 e4 01 00 00       	call   af5a <lodepng_add_itext>
    ad76:	83 c4 20             	add    $0x20,%esp
    ad79:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ad7c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ad80:	74 05                	je     ad87 <LodePNGIText_copy+0xaa>
    ad82:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ad85:	eb 14                	jmp    ad9b <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    ad87:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ad8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad8e:	8b 40 48             	mov    0x48(%eax),%eax
    ad91:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    ad94:	75 91                	jne    ad27 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    ad96:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ad9b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ad9e:	5b                   	pop    %ebx
    ad9f:	5e                   	pop    %esi
    ada0:	5d                   	pop    %ebp
    ada1:	c3                   	ret    

0000ada2 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    ada2:	55                   	push   %ebp
    ada3:	89 e5                	mov    %esp,%ebp
    ada5:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    ada8:	83 ec 0c             	sub    $0xc,%esp
    adab:	ff 75 08             	pushl  0x8(%ebp)
    adae:	e8 59 fe ff ff       	call   ac0c <LodePNGIText_cleanup>
    adb3:	83 c4 10             	add    $0x10,%esp
}
    adb6:	90                   	nop
    adb7:	c9                   	leave  
    adb8:	c3                   	ret    

0000adb9 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    adb9:	55                   	push   %ebp
    adba:	89 e5                	mov    %esp,%ebp
    adbc:	53                   	push   %ebx
    adbd:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    adc0:	8b 45 08             	mov    0x8(%ebp),%eax
    adc3:	8b 40 48             	mov    0x48(%eax),%eax
    adc6:	83 c0 01             	add    $0x1,%eax
    adc9:	c1 e0 02             	shl    $0x2,%eax
    adcc:	89 c2                	mov    %eax,%edx
    adce:	8b 45 08             	mov    0x8(%ebp),%eax
    add1:	8b 40 4c             	mov    0x4c(%eax),%eax
    add4:	52                   	push   %edx
    add5:	50                   	push   %eax
    add6:	e8 54 9c ff ff       	call   4a2f <lodepng_realloc>
    addb:	83 c4 08             	add    $0x8,%esp
    adde:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    ade1:	8b 45 08             	mov    0x8(%ebp),%eax
    ade4:	8b 40 48             	mov    0x48(%eax),%eax
    ade7:	83 c0 01             	add    $0x1,%eax
    adea:	c1 e0 02             	shl    $0x2,%eax
    aded:	89 c2                	mov    %eax,%edx
    adef:	8b 45 08             	mov    0x8(%ebp),%eax
    adf2:	8b 40 50             	mov    0x50(%eax),%eax
    adf5:	52                   	push   %edx
    adf6:	50                   	push   %eax
    adf7:	e8 33 9c ff ff       	call   4a2f <lodepng_realloc>
    adfc:	83 c4 08             	add    $0x8,%esp
    adff:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    ae02:	8b 45 08             	mov    0x8(%ebp),%eax
    ae05:	8b 40 48             	mov    0x48(%eax),%eax
    ae08:	83 c0 01             	add    $0x1,%eax
    ae0b:	c1 e0 02             	shl    $0x2,%eax
    ae0e:	89 c2                	mov    %eax,%edx
    ae10:	8b 45 08             	mov    0x8(%ebp),%eax
    ae13:	8b 40 54             	mov    0x54(%eax),%eax
    ae16:	52                   	push   %edx
    ae17:	50                   	push   %eax
    ae18:	e8 12 9c ff ff       	call   4a2f <lodepng_realloc>
    ae1d:	83 c4 08             	add    $0x8,%esp
    ae20:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    ae23:	8b 45 08             	mov    0x8(%ebp),%eax
    ae26:	8b 40 48             	mov    0x48(%eax),%eax
    ae29:	83 c0 01             	add    $0x1,%eax
    ae2c:	c1 e0 02             	shl    $0x2,%eax
    ae2f:	89 c2                	mov    %eax,%edx
    ae31:	8b 45 08             	mov    0x8(%ebp),%eax
    ae34:	8b 40 58             	mov    0x58(%eax),%eax
    ae37:	52                   	push   %edx
    ae38:	50                   	push   %eax
    ae39:	e8 f1 9b ff ff       	call   4a2f <lodepng_realloc>
    ae3e:	83 c4 08             	add    $0x8,%esp
    ae41:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    ae44:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ae48:	74 09                	je     ae53 <lodepng_add_itext_sized+0x9a>
    ae4a:	8b 45 08             	mov    0x8(%ebp),%eax
    ae4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ae50:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    ae53:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ae57:	74 09                	je     ae62 <lodepng_add_itext_sized+0xa9>
    ae59:	8b 45 08             	mov    0x8(%ebp),%eax
    ae5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ae5f:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    ae62:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ae66:	74 09                	je     ae71 <lodepng_add_itext_sized+0xb8>
    ae68:	8b 45 08             	mov    0x8(%ebp),%eax
    ae6b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ae6e:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    ae71:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ae75:	74 09                	je     ae80 <lodepng_add_itext_sized+0xc7>
    ae77:	8b 45 08             	mov    0x8(%ebp),%eax
    ae7a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ae7d:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    ae80:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ae84:	74 12                	je     ae98 <lodepng_add_itext_sized+0xdf>
    ae86:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ae8a:	74 0c                	je     ae98 <lodepng_add_itext_sized+0xdf>
    ae8c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ae90:	74 06                	je     ae98 <lodepng_add_itext_sized+0xdf>
    ae92:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ae96:	75 0a                	jne    aea2 <lodepng_add_itext_sized+0xe9>
    ae98:	b8 53 00 00 00       	mov    $0x53,%eax
    ae9d:	e9 b3 00 00 00       	jmp    af55 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    aea2:	8b 45 08             	mov    0x8(%ebp),%eax
    aea5:	8b 40 48             	mov    0x48(%eax),%eax
    aea8:	8d 50 01             	lea    0x1(%eax),%edx
    aeab:	8b 45 08             	mov    0x8(%ebp),%eax
    aeae:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    aeb1:	8b 45 08             	mov    0x8(%ebp),%eax
    aeb4:	8b 50 4c             	mov    0x4c(%eax),%edx
    aeb7:	8b 45 08             	mov    0x8(%ebp),%eax
    aeba:	8b 40 48             	mov    0x48(%eax),%eax
    aebd:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    aec2:	c1 e0 02             	shl    $0x2,%eax
    aec5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    aec8:	83 ec 0c             	sub    $0xc,%esp
    aecb:	ff 75 0c             	pushl  0xc(%ebp)
    aece:	e8 a1 9e ff ff       	call   4d74 <alloc_string>
    aed3:	83 c4 10             	add    $0x10,%esp
    aed6:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    aed8:	8b 45 08             	mov    0x8(%ebp),%eax
    aedb:	8b 50 50             	mov    0x50(%eax),%edx
    aede:	8b 45 08             	mov    0x8(%ebp),%eax
    aee1:	8b 40 48             	mov    0x48(%eax),%eax
    aee4:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    aee9:	c1 e0 02             	shl    $0x2,%eax
    aeec:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    aeef:	83 ec 0c             	sub    $0xc,%esp
    aef2:	ff 75 10             	pushl  0x10(%ebp)
    aef5:	e8 7a 9e ff ff       	call   4d74 <alloc_string>
    aefa:	83 c4 10             	add    $0x10,%esp
    aefd:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    aeff:	8b 45 08             	mov    0x8(%ebp),%eax
    af02:	8b 50 54             	mov    0x54(%eax),%edx
    af05:	8b 45 08             	mov    0x8(%ebp),%eax
    af08:	8b 40 48             	mov    0x48(%eax),%eax
    af0b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    af10:	c1 e0 02             	shl    $0x2,%eax
    af13:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    af16:	83 ec 0c             	sub    $0xc,%esp
    af19:	ff 75 14             	pushl  0x14(%ebp)
    af1c:	e8 53 9e ff ff       	call   4d74 <alloc_string>
    af21:	83 c4 10             	add    $0x10,%esp
    af24:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    af26:	8b 45 08             	mov    0x8(%ebp),%eax
    af29:	8b 50 58             	mov    0x58(%eax),%edx
    af2c:	8b 45 08             	mov    0x8(%ebp),%eax
    af2f:	8b 40 48             	mov    0x48(%eax),%eax
    af32:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    af37:	c1 e0 02             	shl    $0x2,%eax
    af3a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    af3d:	83 ec 08             	sub    $0x8,%esp
    af40:	ff 75 1c             	pushl  0x1c(%ebp)
    af43:	ff 75 18             	pushl  0x18(%ebp)
    af46:	e8 e4 9d ff ff       	call   4d2f <alloc_string_sized>
    af4b:	83 c4 10             	add    $0x10,%esp
    af4e:	89 03                	mov    %eax,(%ebx)

  return 0;
    af50:	b8 00 00 00 00       	mov    $0x0,%eax
}
    af55:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    af58:	c9                   	leave  
    af59:	c3                   	ret    

0000af5a <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    af5a:	55                   	push   %ebp
    af5b:	89 e5                	mov    %esp,%ebp
    af5d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    af60:	ff 75 18             	pushl  0x18(%ebp)
    af63:	e8 4c 9b ff ff       	call   4ab4 <lodepng_strlen>
    af68:	83 c4 04             	add    $0x4,%esp
    af6b:	83 ec 08             	sub    $0x8,%esp
    af6e:	50                   	push   %eax
    af6f:	ff 75 18             	pushl  0x18(%ebp)
    af72:	ff 75 14             	pushl  0x14(%ebp)
    af75:	ff 75 10             	pushl  0x10(%ebp)
    af78:	ff 75 0c             	pushl  0xc(%ebp)
    af7b:	ff 75 08             	pushl  0x8(%ebp)
    af7e:	e8 36 fe ff ff       	call   adb9 <lodepng_add_itext_sized>
    af83:	83 c4 20             	add    $0x20,%esp
}
    af86:	c9                   	leave  
    af87:	c3                   	ret    

0000af88 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    af88:	55                   	push   %ebp
    af89:	89 e5                	mov    %esp,%ebp
    af8b:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    af8e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    af92:	75 0a                	jne    af9e <lodepng_assign_icc+0x16>
    af94:	b8 64 00 00 00       	mov    $0x64,%eax
    af99:	e9 81 00 00 00       	jmp    b01f <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    af9e:	83 ec 0c             	sub    $0xc,%esp
    afa1:	ff 75 0c             	pushl  0xc(%ebp)
    afa4:	e8 cb 9d ff ff       	call   4d74 <alloc_string>
    afa9:	83 c4 10             	add    $0x10,%esp
    afac:	89 c2                	mov    %eax,%edx
    afae:	8b 45 08             	mov    0x8(%ebp),%eax
    afb1:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    afb7:	8b 45 14             	mov    0x14(%ebp),%eax
    afba:	83 ec 0c             	sub    $0xc,%esp
    afbd:	50                   	push   %eax
    afbe:	e8 55 9a ff ff       	call   4a18 <lodepng_malloc>
    afc3:	83 c4 10             	add    $0x10,%esp
    afc6:	89 c2                	mov    %eax,%edx
    afc8:	8b 45 08             	mov    0x8(%ebp),%eax
    afcb:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    afd1:	8b 45 08             	mov    0x8(%ebp),%eax
    afd4:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    afda:	85 c0                	test   %eax,%eax
    afdc:	74 0d                	je     afeb <lodepng_assign_icc+0x63>
    afde:	8b 45 08             	mov    0x8(%ebp),%eax
    afe1:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    afe7:	85 c0                	test   %eax,%eax
    afe9:	75 07                	jne    aff2 <lodepng_assign_icc+0x6a>
    afeb:	b8 53 00 00 00       	mov    $0x53,%eax
    aff0:	eb 2d                	jmp    b01f <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    aff2:	8b 55 14             	mov    0x14(%ebp),%edx
    aff5:	8b 45 08             	mov    0x8(%ebp),%eax
    aff8:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    affe:	83 ec 04             	sub    $0x4,%esp
    b001:	52                   	push   %edx
    b002:	ff 75 10             	pushl  0x10(%ebp)
    b005:	50                   	push   %eax
    b006:	e8 4b 9a ff ff       	call   4a56 <lodepng_memcpy>
    b00b:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    b00e:	8b 45 08             	mov    0x8(%ebp),%eax
    b011:	8b 55 14             	mov    0x14(%ebp),%edx
    b014:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    b01a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b01f:	c9                   	leave  
    b020:	c3                   	ret    

0000b021 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    b021:	55                   	push   %ebp
    b022:	89 e5                	mov    %esp,%ebp
    b024:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    b027:	8b 45 08             	mov    0x8(%ebp),%eax
    b02a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    b030:	85 c0                	test   %eax,%eax
    b032:	74 0e                	je     b042 <lodepng_set_icc+0x21>
    b034:	83 ec 0c             	sub    $0xc,%esp
    b037:	ff 75 08             	pushl  0x8(%ebp)
    b03a:	e8 26 00 00 00       	call   b065 <lodepng_clear_icc>
    b03f:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    b042:	8b 45 08             	mov    0x8(%ebp),%eax
    b045:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    b04c:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    b04f:	ff 75 14             	pushl  0x14(%ebp)
    b052:	ff 75 10             	pushl  0x10(%ebp)
    b055:	ff 75 0c             	pushl  0xc(%ebp)
    b058:	ff 75 08             	pushl  0x8(%ebp)
    b05b:	e8 28 ff ff ff       	call   af88 <lodepng_assign_icc>
    b060:	83 c4 10             	add    $0x10,%esp
}
    b063:	c9                   	leave  
    b064:	c3                   	ret    

0000b065 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    b065:	55                   	push   %ebp
    b066:	89 e5                	mov    %esp,%ebp
    b068:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    b06b:	8b 45 08             	mov    0x8(%ebp),%eax
    b06e:	05 c0 00 00 00       	add    $0xc0,%eax
    b073:	83 ec 0c             	sub    $0xc,%esp
    b076:	50                   	push   %eax
    b077:	e8 90 9c ff ff       	call   4d0c <string_cleanup>
    b07c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    b07f:	8b 45 08             	mov    0x8(%ebp),%eax
    b082:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    b088:	83 ec 0c             	sub    $0xc,%esp
    b08b:	50                   	push   %eax
    b08c:	e8 a8 99 ff ff       	call   4a39 <lodepng_free>
    b091:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    b094:	8b 45 08             	mov    0x8(%ebp),%eax
    b097:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    b09e:	00 00 00 
  info->iccp_profile_size = 0;
    b0a1:	8b 45 08             	mov    0x8(%ebp),%eax
    b0a4:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    b0ab:	00 00 00 
  info->iccp_defined = 0;
    b0ae:	8b 45 08             	mov    0x8(%ebp),%eax
    b0b1:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    b0b8:	00 00 00 
}
    b0bb:	90                   	nop
    b0bc:	c9                   	leave  
    b0bd:	c3                   	ret    

0000b0be <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    b0be:	55                   	push   %ebp
    b0bf:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    b0c1:	8b 45 08             	mov    0x8(%ebp),%eax
    b0c4:	83 c0 0c             	add    $0xc,%eax
    b0c7:	50                   	push   %eax
    b0c8:	e8 5a f0 ff ff       	call   a127 <lodepng_color_mode_init>
    b0cd:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    b0d0:	8b 45 08             	mov    0x8(%ebp),%eax
    b0d3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    b0da:	8b 45 08             	mov    0x8(%ebp),%eax
    b0dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    b0e3:	8b 45 08             	mov    0x8(%ebp),%eax
    b0e6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    b0ed:	8b 45 08             	mov    0x8(%ebp),%eax
    b0f0:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    b0f7:	8b 45 08             	mov    0x8(%ebp),%eax
    b0fa:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    b101:	8b 45 08             	mov    0x8(%ebp),%eax
    b104:	8b 50 38             	mov    0x38(%eax),%edx
    b107:	8b 45 08             	mov    0x8(%ebp),%eax
    b10a:	89 50 34             	mov    %edx,0x34(%eax)
    b10d:	8b 45 08             	mov    0x8(%ebp),%eax
    b110:	8b 50 34             	mov    0x34(%eax),%edx
    b113:	8b 45 08             	mov    0x8(%ebp),%eax
    b116:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    b119:	ff 75 08             	pushl  0x8(%ebp)
    b11c:	e8 2c f8 ff ff       	call   a94d <LodePNGText_init>
    b121:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    b124:	ff 75 08             	pushl  0x8(%ebp)
    b127:	e8 a8 fa ff ff       	call   abd4 <LodePNGIText_init>
    b12c:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    b12f:	8b 45 08             	mov    0x8(%ebp),%eax
    b132:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    b139:	8b 45 08             	mov    0x8(%ebp),%eax
    b13c:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    b143:	8b 45 08             	mov    0x8(%ebp),%eax
    b146:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    b14d:	00 00 00 
  info->chrm_defined = 0;
    b150:	8b 45 08             	mov    0x8(%ebp),%eax
    b153:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    b15a:	00 00 00 
  info->srgb_defined = 0;
    b15d:	8b 45 08             	mov    0x8(%ebp),%eax
    b160:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    b167:	00 00 00 
  info->iccp_defined = 0;
    b16a:	8b 45 08             	mov    0x8(%ebp),%eax
    b16d:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    b174:	00 00 00 
  info->iccp_name = NULL;
    b177:	8b 45 08             	mov    0x8(%ebp),%eax
    b17a:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    b181:	00 00 00 
  info->iccp_profile = NULL;
    b184:	8b 45 08             	mov    0x8(%ebp),%eax
    b187:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    b18e:	00 00 00 

  LodePNGUnknownChunks_init(info);
    b191:	ff 75 08             	pushl  0x8(%ebp)
    b194:	e8 46 f6 ff ff       	call   a7df <LodePNGUnknownChunks_init>
    b199:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    b19c:	90                   	nop
    b19d:	c9                   	leave  
    b19e:	c3                   	ret    

0000b19f <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    b19f:	55                   	push   %ebp
    b1a0:	89 e5                	mov    %esp,%ebp
    b1a2:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    b1a5:	8b 45 08             	mov    0x8(%ebp),%eax
    b1a8:	83 c0 0c             	add    $0xc,%eax
    b1ab:	83 ec 0c             	sub    $0xc,%esp
    b1ae:	50                   	push   %eax
    b1af:	e8 66 f0 ff ff       	call   a21a <lodepng_color_mode_cleanup>
    b1b4:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    b1b7:	83 ec 0c             	sub    $0xc,%esp
    b1ba:	ff 75 08             	pushl  0x8(%ebp)
    b1bd:	e8 af f7 ff ff       	call   a971 <LodePNGText_cleanup>
    b1c2:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    b1c5:	83 ec 0c             	sub    $0xc,%esp
    b1c8:	ff 75 08             	pushl  0x8(%ebp)
    b1cb:	e8 3c fa ff ff       	call   ac0c <LodePNGIText_cleanup>
    b1d0:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    b1d3:	83 ec 0c             	sub    $0xc,%esp
    b1d6:	ff 75 08             	pushl  0x8(%ebp)
    b1d9:	e8 87 fe ff ff       	call   b065 <lodepng_clear_icc>
    b1de:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    b1e1:	83 ec 0c             	sub    $0xc,%esp
    b1e4:	ff 75 08             	pushl  0x8(%ebp)
    b1e7:	e8 44 f6 ff ff       	call   a830 <LodePNGUnknownChunks_cleanup>
    b1ec:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    b1ef:	90                   	nop
    b1f0:	c9                   	leave  
    b1f1:	c3                   	ret    

0000b1f2 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    b1f2:	55                   	push   %ebp
    b1f3:	89 e5                	mov    %esp,%ebp
    b1f5:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    b1f8:	83 ec 0c             	sub    $0xc,%esp
    b1fb:	ff 75 08             	pushl  0x8(%ebp)
    b1fe:	e8 9c ff ff ff       	call   b19f <lodepng_info_cleanup>
    b203:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    b206:	83 ec 04             	sub    $0x4,%esp
    b209:	68 e4 00 00 00       	push   $0xe4
    b20e:	ff 75 0c             	pushl  0xc(%ebp)
    b211:	ff 75 08             	pushl  0x8(%ebp)
    b214:	e8 3d 98 ff ff       	call   4a56 <lodepng_memcpy>
    b219:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    b21c:	8b 45 08             	mov    0x8(%ebp),%eax
    b21f:	83 c0 0c             	add    $0xc,%eax
    b222:	83 ec 0c             	sub    $0xc,%esp
    b225:	50                   	push   %eax
    b226:	e8 fc ee ff ff       	call   a127 <lodepng_color_mode_init>
    b22b:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    b22e:	8b 45 0c             	mov    0xc(%ebp),%eax
    b231:	8d 50 0c             	lea    0xc(%eax),%edx
    b234:	8b 45 08             	mov    0x8(%ebp),%eax
    b237:	83 c0 0c             	add    $0xc,%eax
    b23a:	83 ec 08             	sub    $0x8,%esp
    b23d:	52                   	push   %edx
    b23e:	50                   	push   %eax
    b23f:	e8 ed ef ff ff       	call   a231 <lodepng_color_mode_copy>
    b244:	83 c4 10             	add    $0x10,%esp
    b247:	89 45 f4             	mov    %eax,-0xc(%ebp)
    b24a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b24e:	74 08                	je     b258 <lodepng_info_copy+0x66>
    b250:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b253:	e9 b7 00 00 00       	jmp    b30f <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    b258:	83 ec 08             	sub    $0x8,%esp
    b25b:	ff 75 0c             	pushl  0xc(%ebp)
    b25e:	ff 75 08             	pushl  0x8(%ebp)
    b261:	e8 84 f7 ff ff       	call   a9ea <LodePNGText_copy>
    b266:	83 c4 10             	add    $0x10,%esp
    b269:	89 45 f0             	mov    %eax,-0x10(%ebp)
    b26c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    b270:	74 08                	je     b27a <lodepng_info_copy+0x88>
    b272:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b275:	e9 95 00 00 00       	jmp    b30f <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    b27a:	83 ec 08             	sub    $0x8,%esp
    b27d:	ff 75 0c             	pushl  0xc(%ebp)
    b280:	ff 75 08             	pushl  0x8(%ebp)
    b283:	e8 55 fa ff ff       	call   acdd <LodePNGIText_copy>
    b288:	83 c4 10             	add    $0x10,%esp
    b28b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    b28e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    b292:	74 05                	je     b299 <lodepng_info_copy+0xa7>
    b294:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b297:	eb 76                	jmp    b30f <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    b299:	8b 45 0c             	mov    0xc(%ebp),%eax
    b29c:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    b2a2:	85 c0                	test   %eax,%eax
    b2a4:	74 37                	je     b2dd <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    b2a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2a9:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    b2af:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2b2:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    b2b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2bb:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    b2c1:	51                   	push   %ecx
    b2c2:	52                   	push   %edx
    b2c3:	50                   	push   %eax
    b2c4:	ff 75 08             	pushl  0x8(%ebp)
    b2c7:	e8 bc fc ff ff       	call   af88 <lodepng_assign_icc>
    b2cc:	83 c4 10             	add    $0x10,%esp
    b2cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    b2d2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    b2d6:	74 05                	je     b2dd <lodepng_info_copy+0xeb>
    b2d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b2db:	eb 32                	jmp    b30f <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    b2dd:	83 ec 0c             	sub    $0xc,%esp
    b2e0:	ff 75 08             	pushl  0x8(%ebp)
    b2e3:	e8 f7 f4 ff ff       	call   a7df <LodePNGUnknownChunks_init>
    b2e8:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    b2eb:	83 ec 08             	sub    $0x8,%esp
    b2ee:	ff 75 0c             	pushl  0xc(%ebp)
    b2f1:	ff 75 08             	pushl  0x8(%ebp)
    b2f4:	e8 6c f5 ff ff       	call   a865 <LodePNGUnknownChunks_copy>
    b2f9:	83 c4 10             	add    $0x10,%esp
    b2fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    b2ff:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    b303:	74 05                	je     b30a <lodepng_info_copy+0x118>
    b305:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b308:	eb 05                	jmp    b30f <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    b30a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b30f:	c9                   	leave  
    b310:	c3                   	ret    

0000b311 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    b311:	55                   	push   %ebp
    b312:	89 e5                	mov    %esp,%ebp
    b314:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    b317:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    b31b:	74 14                	je     b331 <addColorBits+0x20>
    b31d:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    b321:	75 07                	jne    b32a <addColorBits+0x19>
    b323:	b8 03 00 00 00       	mov    $0x3,%eax
    b328:	eb 0c                	jmp    b336 <addColorBits+0x25>
    b32a:	b8 01 00 00 00       	mov    $0x1,%eax
    b32f:	eb 05                	jmp    b336 <addColorBits+0x25>
    b331:	b8 07 00 00 00       	mov    $0x7,%eax
    b336:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    b339:	8b 45 0c             	mov    0xc(%ebp),%eax
    b33c:	23 45 fc             	and    -0x4(%ebp),%eax
    b33f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    b342:	8b 45 10             	mov    0x10(%ebp),%eax
    b345:	ba 01 00 00 00       	mov    $0x1,%edx
    b34a:	89 c1                	mov    %eax,%ecx
    b34c:	d3 e2                	shl    %cl,%edx
    b34e:	89 d0                	mov    %edx,%eax
    b350:	83 e8 01             	sub    $0x1,%eax
    b353:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    b356:	8b 45 fc             	mov    -0x4(%ebp),%eax
    b359:	2b 45 f8             	sub    -0x8(%ebp),%eax
    b35c:	0f af 45 10          	imul   0x10(%ebp),%eax
    b360:	89 c1                	mov    %eax,%ecx
    b362:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    b365:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    b369:	75 18                	jne    b383 <addColorBits+0x72>
    b36b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b36e:	0f af 45 10          	imul   0x10(%ebp),%eax
    b372:	c1 e8 03             	shr    $0x3,%eax
    b375:	89 c2                	mov    %eax,%edx
    b377:	8b 45 08             	mov    0x8(%ebp),%eax
    b37a:	01 d0                	add    %edx,%eax
    b37c:	8b 55 14             	mov    0x14(%ebp),%edx
    b37f:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    b381:	eb 1e                	jmp    b3a1 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    b383:	8b 45 0c             	mov    0xc(%ebp),%eax
    b386:	0f af 45 10          	imul   0x10(%ebp),%eax
    b38a:	c1 e8 03             	shr    $0x3,%eax
    b38d:	8b 55 08             	mov    0x8(%ebp),%edx
    b390:	01 c2                	add    %eax,%edx
    b392:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b395:	01 c8                	add    %ecx,%eax
    b397:	0f b6 08             	movzbl (%eax),%ecx
    b39a:	8b 45 14             	mov    0x14(%ebp),%eax
    b39d:	09 c8                	or     %ecx,%eax
    b39f:	88 02                	mov    %al,(%edx)
}
    b3a1:	90                   	nop
    b3a2:	c9                   	leave  
    b3a3:	c3                   	ret    

0000b3a4 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    b3a4:	55                   	push   %ebp
    b3a5:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    b3a7:	8b 45 08             	mov    0x8(%ebp),%eax
    b3aa:	6a 40                	push   $0x40
    b3ac:	6a 00                	push   $0x0
    b3ae:	50                   	push   %eax
    b3af:	e8 d5 96 ff ff       	call   4a89 <lodepng_memset>
    b3b4:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    b3b7:	8b 45 08             	mov    0x8(%ebp),%eax
    b3ba:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    b3c1:	90                   	nop
    b3c2:	c9                   	leave  
    b3c3:	c3                   	ret    

0000b3c4 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    b3c4:	55                   	push   %ebp
    b3c5:	89 e5                	mov    %esp,%ebp
    b3c7:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    b3ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    b3d1:	eb 3b                	jmp    b40e <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    b3d3:	8b 45 08             	mov    0x8(%ebp),%eax
    b3d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b3d9:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b3dc:	85 c0                	test   %eax,%eax
    b3de:	74 2a                	je     b40a <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    b3e0:	8b 45 08             	mov    0x8(%ebp),%eax
    b3e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b3e6:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b3e9:	83 ec 0c             	sub    $0xc,%esp
    b3ec:	50                   	push   %eax
    b3ed:	e8 d2 ff ff ff       	call   b3c4 <color_tree_cleanup>
    b3f2:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    b3f5:	8b 45 08             	mov    0x8(%ebp),%eax
    b3f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b3fb:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b3fe:	83 ec 0c             	sub    $0xc,%esp
    b401:	50                   	push   %eax
    b402:	e8 32 96 ff ff       	call   4a39 <lodepng_free>
    b407:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    b40a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    b40e:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    b412:	75 bf                	jne    b3d3 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    b414:	90                   	nop
    b415:	c9                   	leave  
    b416:	c3                   	ret    

0000b417 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    b417:	55                   	push   %ebp
    b418:	89 e5                	mov    %esp,%ebp
    b41a:	53                   	push   %ebx
    b41b:	83 ec 20             	sub    $0x20,%esp
    b41e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    b421:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b424:	8b 55 14             	mov    0x14(%ebp),%edx
    b427:	8b 45 18             	mov    0x18(%ebp),%eax
    b42a:	88 5d e8             	mov    %bl,-0x18(%ebp)
    b42d:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    b430:	88 55 e0             	mov    %dl,-0x20(%ebp)
    b433:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    b436:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    b43d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b444:	eb 76                	jmp    b4bc <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    b446:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    b44a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b44d:	89 c1                	mov    %eax,%ecx
    b44f:	d3 fa                	sar    %cl,%edx
    b451:	89 d0                	mov    %edx,%eax
    b453:	83 e0 01             	and    $0x1,%eax
    b456:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    b459:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b45d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b460:	89 c1                	mov    %eax,%ecx
    b462:	d3 fa                	sar    %cl,%edx
    b464:	89 d0                	mov    %edx,%eax
    b466:	83 e0 01             	and    $0x1,%eax
    b469:	01 d8                	add    %ebx,%eax
    b46b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    b46e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    b472:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b475:	89 c1                	mov    %eax,%ecx
    b477:	d3 fa                	sar    %cl,%edx
    b479:	89 d0                	mov    %edx,%eax
    b47b:	83 e0 01             	and    $0x1,%eax
    b47e:	01 d8                	add    %ebx,%eax
    b480:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    b483:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    b487:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b48a:	89 c1                	mov    %eax,%ecx
    b48c:	d3 fa                	sar    %cl,%edx
    b48e:	89 d0                	mov    %edx,%eax
    b490:	83 e0 01             	and    $0x1,%eax
    b493:	01 d8                	add    %ebx,%eax
    b495:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    b498:	8b 45 08             	mov    0x8(%ebp),%eax
    b49b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b49e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b4a1:	85 c0                	test   %eax,%eax
    b4a3:	75 07                	jne    b4ac <color_tree_get+0x95>
    b4a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b4aa:	eb 2a                	jmp    b4d6 <color_tree_get+0xbf>
    else tree = tree->children[i];
    b4ac:	8b 45 08             	mov    0x8(%ebp),%eax
    b4af:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b4b2:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b4b5:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    b4b8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4bc:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    b4c0:	7e 84                	jle    b446 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    b4c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    b4c6:	74 08                	je     b4d0 <color_tree_get+0xb9>
    b4c8:	8b 45 08             	mov    0x8(%ebp),%eax
    b4cb:	8b 40 40             	mov    0x40(%eax),%eax
    b4ce:	eb 05                	jmp    b4d5 <color_tree_get+0xbe>
    b4d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b4d5:	90                   	nop
}
    b4d6:	83 c4 20             	add    $0x20,%esp
    b4d9:	5b                   	pop    %ebx
    b4da:	5d                   	pop    %ebp
    b4db:	c3                   	ret    

0000b4dc <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    b4dc:	55                   	push   %ebp
    b4dd:	89 e5                	mov    %esp,%ebp
    b4df:	53                   	push   %ebx
    b4e0:	83 ec 10             	sub    $0x10,%esp
    b4e3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    b4e6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b4e9:	8b 55 14             	mov    0x14(%ebp),%edx
    b4ec:	8b 45 18             	mov    0x18(%ebp),%eax
    b4ef:	88 5d f8             	mov    %bl,-0x8(%ebp)
    b4f2:	88 4d f4             	mov    %cl,-0xc(%ebp)
    b4f5:	88 55 f0             	mov    %dl,-0x10(%ebp)
    b4f8:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    b4fb:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    b4ff:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    b503:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    b507:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    b50b:	53                   	push   %ebx
    b50c:	51                   	push   %ecx
    b50d:	52                   	push   %edx
    b50e:	50                   	push   %eax
    b50f:	ff 75 08             	pushl  0x8(%ebp)
    b512:	e8 00 ff ff ff       	call   b417 <color_tree_get>
    b517:	83 c4 14             	add    $0x14,%esp
    b51a:	f7 d0                	not    %eax
    b51c:	c1 e8 1f             	shr    $0x1f,%eax
    b51f:	0f b6 c0             	movzbl %al,%eax
}
    b522:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b525:	c9                   	leave  
    b526:	c3                   	ret    

0000b527 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    b527:	55                   	push   %ebp
    b528:	89 e5                	mov    %esp,%ebp
    b52a:	53                   	push   %ebx
    b52b:	83 ec 24             	sub    $0x24,%esp
    b52e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    b531:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b534:	8b 55 14             	mov    0x14(%ebp),%edx
    b537:	8b 45 18             	mov    0x18(%ebp),%eax
    b53a:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    b53d:	88 4d e0             	mov    %cl,-0x20(%ebp)
    b540:	88 55 dc             	mov    %dl,-0x24(%ebp)
    b543:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    b546:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    b54d:	e9 b0 00 00 00       	jmp    b602 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    b552:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b556:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b559:	89 c1                	mov    %eax,%ecx
    b55b:	d3 fa                	sar    %cl,%edx
    b55d:	89 d0                	mov    %edx,%eax
    b55f:	83 e0 01             	and    $0x1,%eax
    b562:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    b565:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    b569:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b56c:	89 c1                	mov    %eax,%ecx
    b56e:	d3 fa                	sar    %cl,%edx
    b570:	89 d0                	mov    %edx,%eax
    b572:	83 e0 01             	and    $0x1,%eax
    b575:	01 d8                	add    %ebx,%eax
    b577:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    b57a:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    b57e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b581:	89 c1                	mov    %eax,%ecx
    b583:	d3 fa                	sar    %cl,%edx
    b585:	89 d0                	mov    %edx,%eax
    b587:	83 e0 01             	and    $0x1,%eax
    b58a:	01 d8                	add    %ebx,%eax
    b58c:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    b58f:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    b593:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b596:	89 c1                	mov    %eax,%ecx
    b598:	d3 fa                	sar    %cl,%edx
    b59a:	89 d0                	mov    %edx,%eax
    b59c:	83 e0 01             	and    $0x1,%eax
    b59f:	01 d8                	add    %ebx,%eax
    b5a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    b5a4:	8b 45 08             	mov    0x8(%ebp),%eax
    b5a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b5aa:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b5ad:	85 c0                	test   %eax,%eax
    b5af:	75 41                	jne    b5f2 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    b5b1:	83 ec 0c             	sub    $0xc,%esp
    b5b4:	6a 44                	push   $0x44
    b5b6:	e8 5d 94 ff ff       	call   4a18 <lodepng_malloc>
    b5bb:	83 c4 10             	add    $0x10,%esp
    b5be:	89 c1                	mov    %eax,%ecx
    b5c0:	8b 45 08             	mov    0x8(%ebp),%eax
    b5c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b5c6:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    b5c9:	8b 45 08             	mov    0x8(%ebp),%eax
    b5cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b5cf:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b5d2:	85 c0                	test   %eax,%eax
    b5d4:	75 07                	jne    b5dd <color_tree_add+0xb6>
    b5d6:	b8 53 00 00 00       	mov    $0x53,%eax
    b5db:	eb 3d                	jmp    b61a <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    b5dd:	8b 45 08             	mov    0x8(%ebp),%eax
    b5e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b5e3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b5e6:	83 ec 0c             	sub    $0xc,%esp
    b5e9:	50                   	push   %eax
    b5ea:	e8 b5 fd ff ff       	call   b3a4 <color_tree_init>
    b5ef:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    b5f2:	8b 45 08             	mov    0x8(%ebp),%eax
    b5f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b5f8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    b5fb:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    b5fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    b602:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    b606:	0f 8e 46 ff ff ff    	jle    b552 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    b60c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b60f:	8b 45 08             	mov    0x8(%ebp),%eax
    b612:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    b615:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b61a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b61d:	c9                   	leave  
    b61e:	c3                   	ret    

0000b61f <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    b61f:	55                   	push   %ebp
    b620:	89 e5                	mov    %esp,%ebp
    b622:	53                   	push   %ebx
    b623:	83 ec 20             	sub    $0x20,%esp
    b626:	8b 5d 18             	mov    0x18(%ebp),%ebx
    b629:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    b62c:	8b 55 20             	mov    0x20(%ebp),%edx
    b62f:	8b 45 24             	mov    0x24(%ebp),%eax
    b632:	88 5d e8             	mov    %bl,-0x18(%ebp)
    b635:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    b638:	88 55 e0             	mov    %dl,-0x20(%ebp)
    b63b:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    b63e:	8b 45 10             	mov    0x10(%ebp),%eax
    b641:	8b 00                	mov    (%eax),%eax
    b643:	85 c0                	test   %eax,%eax
    b645:	0f 85 ad 00 00 00    	jne    b6f8 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    b64b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b64f:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    b652:	8b 45 10             	mov    0x10(%ebp),%eax
    b655:	8b 40 04             	mov    0x4(%eax),%eax
    b658:	83 f8 08             	cmp    $0x8,%eax
    b65b:	75 13                	jne    b670 <rgba8ToPixel+0x51>
    b65d:	8b 55 0c             	mov    0xc(%ebp),%edx
    b660:	8b 45 08             	mov    0x8(%ebp),%eax
    b663:	01 c2                	add    %eax,%edx
    b665:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    b669:	88 02                	mov    %al,(%edx)
    b66b:	e9 b4 03 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    b670:	8b 45 10             	mov    0x10(%ebp),%eax
    b673:	8b 40 04             	mov    0x4(%eax),%eax
    b676:	83 f8 10             	cmp    $0x10,%eax
    b679:	75 2a                	jne    b6a5 <rgba8ToPixel+0x86>
    b67b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b67e:	01 c0                	add    %eax,%eax
    b680:	89 c2                	mov    %eax,%edx
    b682:	8b 45 08             	mov    0x8(%ebp),%eax
    b685:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b688:	8b 45 0c             	mov    0xc(%ebp),%eax
    b68b:	01 c0                	add    %eax,%eax
    b68d:	8d 50 01             	lea    0x1(%eax),%edx
    b690:	8b 45 08             	mov    0x8(%ebp),%eax
    b693:	01 d0                	add    %edx,%eax
    b695:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    b699:	88 10                	mov    %dl,(%eax)
    b69b:	0f b6 00             	movzbl (%eax),%eax
    b69e:	88 01                	mov    %al,(%ecx)
    b6a0:	e9 7f 03 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    b6a5:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    b6a9:	8b 45 10             	mov    0x10(%ebp),%eax
    b6ac:	8b 40 04             	mov    0x4(%eax),%eax
    b6af:	b9 08 00 00 00       	mov    $0x8,%ecx
    b6b4:	29 c1                	sub    %eax,%ecx
    b6b6:	89 c8                	mov    %ecx,%eax
    b6b8:	89 c1                	mov    %eax,%ecx
    b6ba:	d3 ea                	shr    %cl,%edx
    b6bc:	89 d0                	mov    %edx,%eax
    b6be:	89 c2                	mov    %eax,%edx
    b6c0:	8b 45 10             	mov    0x10(%ebp),%eax
    b6c3:	8b 40 04             	mov    0x4(%eax),%eax
    b6c6:	bb 01 00 00 00       	mov    $0x1,%ebx
    b6cb:	89 c1                	mov    %eax,%ecx
    b6cd:	d3 e3                	shl    %cl,%ebx
    b6cf:	89 d8                	mov    %ebx,%eax
    b6d1:	83 e8 01             	sub    $0x1,%eax
    b6d4:	21 d0                	and    %edx,%eax
    b6d6:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    b6d9:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    b6dd:	8b 45 10             	mov    0x10(%ebp),%eax
    b6e0:	8b 40 04             	mov    0x4(%eax),%eax
    b6e3:	52                   	push   %edx
    b6e4:	50                   	push   %eax
    b6e5:	ff 75 0c             	pushl  0xc(%ebp)
    b6e8:	ff 75 08             	pushl  0x8(%ebp)
    b6eb:	e8 21 fc ff ff       	call   b311 <addColorBits>
    b6f0:	83 c4 10             	add    $0x10,%esp
    b6f3:	e9 2c 03 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    b6f8:	8b 45 10             	mov    0x10(%ebp),%eax
    b6fb:	8b 00                	mov    (%eax),%eax
    b6fd:	83 f8 02             	cmp    $0x2,%eax
    b700:	0f 85 ee 00 00 00    	jne    b7f4 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    b706:	8b 45 10             	mov    0x10(%ebp),%eax
    b709:	8b 40 04             	mov    0x4(%eax),%eax
    b70c:	83 f8 08             	cmp    $0x8,%eax
    b70f:	75 49                	jne    b75a <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    b711:	8b 55 0c             	mov    0xc(%ebp),%edx
    b714:	89 d0                	mov    %edx,%eax
    b716:	01 c0                	add    %eax,%eax
    b718:	01 d0                	add    %edx,%eax
    b71a:	89 c2                	mov    %eax,%edx
    b71c:	8b 45 08             	mov    0x8(%ebp),%eax
    b71f:	01 c2                	add    %eax,%edx
    b721:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b725:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    b727:	8b 55 0c             	mov    0xc(%ebp),%edx
    b72a:	89 d0                	mov    %edx,%eax
    b72c:	01 c0                	add    %eax,%eax
    b72e:	01 d0                	add    %edx,%eax
    b730:	8d 50 01             	lea    0x1(%eax),%edx
    b733:	8b 45 08             	mov    0x8(%ebp),%eax
    b736:	01 c2                	add    %eax,%edx
    b738:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    b73c:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    b73e:	8b 55 0c             	mov    0xc(%ebp),%edx
    b741:	89 d0                	mov    %edx,%eax
    b743:	01 c0                	add    %eax,%eax
    b745:	01 d0                	add    %edx,%eax
    b747:	8d 50 02             	lea    0x2(%eax),%edx
    b74a:	8b 45 08             	mov    0x8(%ebp),%eax
    b74d:	01 c2                	add    %eax,%edx
    b74f:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    b753:	88 02                	mov    %al,(%edx)
    b755:	e9 ca 02 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    b75a:	8b 55 0c             	mov    0xc(%ebp),%edx
    b75d:	89 d0                	mov    %edx,%eax
    b75f:	01 c0                	add    %eax,%eax
    b761:	01 d0                	add    %edx,%eax
    b763:	01 c0                	add    %eax,%eax
    b765:	89 c2                	mov    %eax,%edx
    b767:	8b 45 08             	mov    0x8(%ebp),%eax
    b76a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b76d:	8b 55 0c             	mov    0xc(%ebp),%edx
    b770:	89 d0                	mov    %edx,%eax
    b772:	01 c0                	add    %eax,%eax
    b774:	01 d0                	add    %edx,%eax
    b776:	01 c0                	add    %eax,%eax
    b778:	8d 50 01             	lea    0x1(%eax),%edx
    b77b:	8b 45 08             	mov    0x8(%ebp),%eax
    b77e:	01 d0                	add    %edx,%eax
    b780:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    b784:	88 10                	mov    %dl,(%eax)
    b786:	0f b6 00             	movzbl (%eax),%eax
    b789:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    b78b:	8b 55 0c             	mov    0xc(%ebp),%edx
    b78e:	89 d0                	mov    %edx,%eax
    b790:	01 c0                	add    %eax,%eax
    b792:	01 d0                	add    %edx,%eax
    b794:	01 c0                	add    %eax,%eax
    b796:	8d 50 02             	lea    0x2(%eax),%edx
    b799:	8b 45 08             	mov    0x8(%ebp),%eax
    b79c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b79f:	8b 55 0c             	mov    0xc(%ebp),%edx
    b7a2:	89 d0                	mov    %edx,%eax
    b7a4:	01 c0                	add    %eax,%eax
    b7a6:	01 d0                	add    %edx,%eax
    b7a8:	01 c0                	add    %eax,%eax
    b7aa:	8d 50 03             	lea    0x3(%eax),%edx
    b7ad:	8b 45 08             	mov    0x8(%ebp),%eax
    b7b0:	01 d0                	add    %edx,%eax
    b7b2:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b7b6:	88 10                	mov    %dl,(%eax)
    b7b8:	0f b6 00             	movzbl (%eax),%eax
    b7bb:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    b7bd:	8b 55 0c             	mov    0xc(%ebp),%edx
    b7c0:	89 d0                	mov    %edx,%eax
    b7c2:	01 c0                	add    %eax,%eax
    b7c4:	01 d0                	add    %edx,%eax
    b7c6:	01 c0                	add    %eax,%eax
    b7c8:	8d 50 04             	lea    0x4(%eax),%edx
    b7cb:	8b 45 08             	mov    0x8(%ebp),%eax
    b7ce:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b7d1:	8b 55 0c             	mov    0xc(%ebp),%edx
    b7d4:	89 d0                	mov    %edx,%eax
    b7d6:	01 c0                	add    %eax,%eax
    b7d8:	01 d0                	add    %edx,%eax
    b7da:	01 c0                	add    %eax,%eax
    b7dc:	8d 50 05             	lea    0x5(%eax),%edx
    b7df:	8b 45 08             	mov    0x8(%ebp),%eax
    b7e2:	01 d0                	add    %edx,%eax
    b7e4:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    b7e8:	88 10                	mov    %dl,(%eax)
    b7ea:	0f b6 00             	movzbl (%eax),%eax
    b7ed:	88 01                	mov    %al,(%ecx)
    b7ef:	e9 30 02 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b7f4:	8b 45 10             	mov    0x10(%ebp),%eax
    b7f7:	8b 00                	mov    (%eax),%eax
    b7f9:	83 f8 03             	cmp    $0x3,%eax
    b7fc:	75 6d                	jne    b86b <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    b7fe:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    b802:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    b806:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b80a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b80e:	53                   	push   %ebx
    b80f:	51                   	push   %ecx
    b810:	52                   	push   %edx
    b811:	50                   	push   %eax
    b812:	ff 75 14             	pushl  0x14(%ebp)
    b815:	e8 fd fb ff ff       	call   b417 <color_tree_get>
    b81a:	83 c4 14             	add    $0x14,%esp
    b81d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    b820:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    b824:	79 0a                	jns    b830 <rgba8ToPixel+0x211>
    b826:	b8 52 00 00 00       	mov    $0x52,%eax
    b82b:	e9 f9 01 00 00       	jmp    ba29 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    b830:	8b 45 10             	mov    0x10(%ebp),%eax
    b833:	8b 40 04             	mov    0x4(%eax),%eax
    b836:	83 f8 08             	cmp    $0x8,%eax
    b839:	75 12                	jne    b84d <rgba8ToPixel+0x22e>
    b83b:	8b 55 0c             	mov    0xc(%ebp),%edx
    b83e:	8b 45 08             	mov    0x8(%ebp),%eax
    b841:	01 d0                	add    %edx,%eax
    b843:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b846:	88 10                	mov    %dl,(%eax)
    b848:	e9 d7 01 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    b84d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b850:	8b 45 10             	mov    0x10(%ebp),%eax
    b853:	8b 40 04             	mov    0x4(%eax),%eax
    b856:	52                   	push   %edx
    b857:	50                   	push   %eax
    b858:	ff 75 0c             	pushl  0xc(%ebp)
    b85b:	ff 75 08             	pushl  0x8(%ebp)
    b85e:	e8 ae fa ff ff       	call   b311 <addColorBits>
    b863:	83 c4 10             	add    $0x10,%esp
    b866:	e9 b9 01 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b86b:	8b 45 10             	mov    0x10(%ebp),%eax
    b86e:	8b 00                	mov    (%eax),%eax
    b870:	83 f8 04             	cmp    $0x4,%eax
    b873:	0f 85 9f 00 00 00    	jne    b918 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    b879:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b87d:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    b880:	8b 45 10             	mov    0x10(%ebp),%eax
    b883:	8b 40 04             	mov    0x4(%eax),%eax
    b886:	83 f8 08             	cmp    $0x8,%eax
    b889:	75 2a                	jne    b8b5 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    b88b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b88e:	01 c0                	add    %eax,%eax
    b890:	89 c2                	mov    %eax,%edx
    b892:	8b 45 08             	mov    0x8(%ebp),%eax
    b895:	01 c2                	add    %eax,%edx
    b897:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    b89b:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    b89d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8a0:	01 c0                	add    %eax,%eax
    b8a2:	8d 50 01             	lea    0x1(%eax),%edx
    b8a5:	8b 45 08             	mov    0x8(%ebp),%eax
    b8a8:	01 c2                	add    %eax,%edx
    b8aa:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    b8ae:	88 02                	mov    %al,(%edx)
    b8b0:	e9 6f 01 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    b8b5:	8b 45 10             	mov    0x10(%ebp),%eax
    b8b8:	8b 40 04             	mov    0x4(%eax),%eax
    b8bb:	83 f8 10             	cmp    $0x10,%eax
    b8be:	0f 85 60 01 00 00    	jne    ba24 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    b8c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8c7:	c1 e0 02             	shl    $0x2,%eax
    b8ca:	89 c2                	mov    %eax,%edx
    b8cc:	8b 45 08             	mov    0x8(%ebp),%eax
    b8cf:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b8d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8d5:	c1 e0 02             	shl    $0x2,%eax
    b8d8:	8d 50 01             	lea    0x1(%eax),%edx
    b8db:	8b 45 08             	mov    0x8(%ebp),%eax
    b8de:	01 d0                	add    %edx,%eax
    b8e0:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    b8e4:	88 10                	mov    %dl,(%eax)
    b8e6:	0f b6 00             	movzbl (%eax),%eax
    b8e9:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    b8eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8ee:	c1 e0 02             	shl    $0x2,%eax
    b8f1:	8d 50 02             	lea    0x2(%eax),%edx
    b8f4:	8b 45 08             	mov    0x8(%ebp),%eax
    b8f7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b8fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8fd:	c1 e0 02             	shl    $0x2,%eax
    b900:	8d 50 03             	lea    0x3(%eax),%edx
    b903:	8b 45 08             	mov    0x8(%ebp),%eax
    b906:	01 d0                	add    %edx,%eax
    b908:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    b90c:	88 10                	mov    %dl,(%eax)
    b90e:	0f b6 00             	movzbl (%eax),%eax
    b911:	88 01                	mov    %al,(%ecx)
    b913:	e9 0c 01 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    b918:	8b 45 10             	mov    0x10(%ebp),%eax
    b91b:	8b 00                	mov    (%eax),%eax
    b91d:	83 f8 06             	cmp    $0x6,%eax
    b920:	0f 85 fe 00 00 00    	jne    ba24 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    b926:	8b 45 10             	mov    0x10(%ebp),%eax
    b929:	8b 40 04             	mov    0x4(%eax),%eax
    b92c:	83 f8 08             	cmp    $0x8,%eax
    b92f:	75 54                	jne    b985 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    b931:	8b 45 0c             	mov    0xc(%ebp),%eax
    b934:	c1 e0 02             	shl    $0x2,%eax
    b937:	89 c2                	mov    %eax,%edx
    b939:	8b 45 08             	mov    0x8(%ebp),%eax
    b93c:	01 c2                	add    %eax,%edx
    b93e:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b942:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    b944:	8b 45 0c             	mov    0xc(%ebp),%eax
    b947:	c1 e0 02             	shl    $0x2,%eax
    b94a:	8d 50 01             	lea    0x1(%eax),%edx
    b94d:	8b 45 08             	mov    0x8(%ebp),%eax
    b950:	01 c2                	add    %eax,%edx
    b952:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    b956:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    b958:	8b 45 0c             	mov    0xc(%ebp),%eax
    b95b:	c1 e0 02             	shl    $0x2,%eax
    b95e:	8d 50 02             	lea    0x2(%eax),%edx
    b961:	8b 45 08             	mov    0x8(%ebp),%eax
    b964:	01 c2                	add    %eax,%edx
    b966:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    b96a:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    b96c:	8b 45 0c             	mov    0xc(%ebp),%eax
    b96f:	c1 e0 02             	shl    $0x2,%eax
    b972:	8d 50 03             	lea    0x3(%eax),%edx
    b975:	8b 45 08             	mov    0x8(%ebp),%eax
    b978:	01 c2                	add    %eax,%edx
    b97a:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    b97e:	88 02                	mov    %al,(%edx)
    b980:	e9 9f 00 00 00       	jmp    ba24 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    b985:	8b 45 0c             	mov    0xc(%ebp),%eax
    b988:	c1 e0 03             	shl    $0x3,%eax
    b98b:	89 c2                	mov    %eax,%edx
    b98d:	8b 45 08             	mov    0x8(%ebp),%eax
    b990:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b993:	8b 45 0c             	mov    0xc(%ebp),%eax
    b996:	c1 e0 03             	shl    $0x3,%eax
    b999:	8d 50 01             	lea    0x1(%eax),%edx
    b99c:	8b 45 08             	mov    0x8(%ebp),%eax
    b99f:	01 d0                	add    %edx,%eax
    b9a1:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    b9a5:	88 10                	mov    %dl,(%eax)
    b9a7:	0f b6 00             	movzbl (%eax),%eax
    b9aa:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    b9ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9af:	c1 e0 03             	shl    $0x3,%eax
    b9b2:	8d 50 02             	lea    0x2(%eax),%edx
    b9b5:	8b 45 08             	mov    0x8(%ebp),%eax
    b9b8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b9bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9be:	c1 e0 03             	shl    $0x3,%eax
    b9c1:	8d 50 03             	lea    0x3(%eax),%edx
    b9c4:	8b 45 08             	mov    0x8(%ebp),%eax
    b9c7:	01 d0                	add    %edx,%eax
    b9c9:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b9cd:	88 10                	mov    %dl,(%eax)
    b9cf:	0f b6 00             	movzbl (%eax),%eax
    b9d2:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    b9d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9d7:	c1 e0 03             	shl    $0x3,%eax
    b9da:	8d 50 04             	lea    0x4(%eax),%edx
    b9dd:	8b 45 08             	mov    0x8(%ebp),%eax
    b9e0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b9e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9e6:	c1 e0 03             	shl    $0x3,%eax
    b9e9:	8d 50 05             	lea    0x5(%eax),%edx
    b9ec:	8b 45 08             	mov    0x8(%ebp),%eax
    b9ef:	01 d0                	add    %edx,%eax
    b9f1:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    b9f5:	88 10                	mov    %dl,(%eax)
    b9f7:	0f b6 00             	movzbl (%eax),%eax
    b9fa:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    b9fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9ff:	c1 e0 03             	shl    $0x3,%eax
    ba02:	8d 50 06             	lea    0x6(%eax),%edx
    ba05:	8b 45 08             	mov    0x8(%ebp),%eax
    ba08:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ba0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba0e:	c1 e0 03             	shl    $0x3,%eax
    ba11:	8d 50 07             	lea    0x7(%eax),%edx
    ba14:	8b 45 08             	mov    0x8(%ebp),%eax
    ba17:	01 d0                	add    %edx,%eax
    ba19:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    ba1d:	88 10                	mov    %dl,(%eax)
    ba1f:	0f b6 00             	movzbl (%eax),%eax
    ba22:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    ba24:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ba29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ba2c:	c9                   	leave  
    ba2d:	c3                   	ret    

0000ba2e <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    ba2e:	55                   	push   %ebp
    ba2f:	89 e5                	mov    %esp,%ebp
    ba31:	53                   	push   %ebx
    ba32:	83 ec 20             	sub    $0x20,%esp
    ba35:	8b 5d 14             	mov    0x14(%ebp),%ebx
    ba38:	8b 4d 18             	mov    0x18(%ebp),%ecx
    ba3b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba3e:	8b 45 20             	mov    0x20(%ebp),%eax
    ba41:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    ba45:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    ba49:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    ba4d:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    ba51:	8b 45 10             	mov    0x10(%ebp),%eax
    ba54:	8b 00                	mov    (%eax),%eax
    ba56:	85 c0                	test   %eax,%eax
    ba58:	75 36                	jne    ba90 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    ba5a:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    ba5e:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    ba62:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba65:	01 c0                	add    %eax,%eax
    ba67:	89 c2                	mov    %eax,%edx
    ba69:	8b 45 08             	mov    0x8(%ebp),%eax
    ba6c:	01 d0                	add    %edx,%eax
    ba6e:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    ba72:	66 c1 ea 08          	shr    $0x8,%dx
    ba76:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    ba78:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba7b:	01 c0                	add    %eax,%eax
    ba7d:	8d 50 01             	lea    0x1(%eax),%edx
    ba80:	8b 45 08             	mov    0x8(%ebp),%eax
    ba83:	01 d0                	add    %edx,%eax
    ba85:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    ba89:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    ba8b:	e9 df 01 00 00       	jmp    bc6f <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    ba90:	8b 45 10             	mov    0x10(%ebp),%eax
    ba93:	8b 00                	mov    (%eax),%eax
    ba95:	83 f8 02             	cmp    $0x2,%eax
    ba98:	0f 85 a6 00 00 00    	jne    bb44 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    ba9e:	8b 55 0c             	mov    0xc(%ebp),%edx
    baa1:	89 d0                	mov    %edx,%eax
    baa3:	01 c0                	add    %eax,%eax
    baa5:	01 d0                	add    %edx,%eax
    baa7:	01 c0                	add    %eax,%eax
    baa9:	89 c2                	mov    %eax,%edx
    baab:	8b 45 08             	mov    0x8(%ebp),%eax
    baae:	01 d0                	add    %edx,%eax
    bab0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    bab4:	66 c1 ea 08          	shr    $0x8,%dx
    bab8:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    baba:	8b 55 0c             	mov    0xc(%ebp),%edx
    babd:	89 d0                	mov    %edx,%eax
    babf:	01 c0                	add    %eax,%eax
    bac1:	01 d0                	add    %edx,%eax
    bac3:	01 c0                	add    %eax,%eax
    bac5:	8d 50 01             	lea    0x1(%eax),%edx
    bac8:	8b 45 08             	mov    0x8(%ebp),%eax
    bacb:	01 d0                	add    %edx,%eax
    bacd:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    bad1:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    bad3:	8b 55 0c             	mov    0xc(%ebp),%edx
    bad6:	89 d0                	mov    %edx,%eax
    bad8:	01 c0                	add    %eax,%eax
    bada:	01 d0                	add    %edx,%eax
    badc:	01 c0                	add    %eax,%eax
    bade:	8d 50 02             	lea    0x2(%eax),%edx
    bae1:	8b 45 08             	mov    0x8(%ebp),%eax
    bae4:	01 d0                	add    %edx,%eax
    bae6:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    baea:	66 c1 ea 08          	shr    $0x8,%dx
    baee:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    baf0:	8b 55 0c             	mov    0xc(%ebp),%edx
    baf3:	89 d0                	mov    %edx,%eax
    baf5:	01 c0                	add    %eax,%eax
    baf7:	01 d0                	add    %edx,%eax
    baf9:	01 c0                	add    %eax,%eax
    bafb:	8d 50 03             	lea    0x3(%eax),%edx
    bafe:	8b 45 08             	mov    0x8(%ebp),%eax
    bb01:	01 d0                	add    %edx,%eax
    bb03:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    bb07:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    bb09:	8b 55 0c             	mov    0xc(%ebp),%edx
    bb0c:	89 d0                	mov    %edx,%eax
    bb0e:	01 c0                	add    %eax,%eax
    bb10:	01 d0                	add    %edx,%eax
    bb12:	01 c0                	add    %eax,%eax
    bb14:	8d 50 04             	lea    0x4(%eax),%edx
    bb17:	8b 45 08             	mov    0x8(%ebp),%eax
    bb1a:	01 d0                	add    %edx,%eax
    bb1c:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    bb20:	66 c1 ea 08          	shr    $0x8,%dx
    bb24:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    bb26:	8b 55 0c             	mov    0xc(%ebp),%edx
    bb29:	89 d0                	mov    %edx,%eax
    bb2b:	01 c0                	add    %eax,%eax
    bb2d:	01 d0                	add    %edx,%eax
    bb2f:	01 c0                	add    %eax,%eax
    bb31:	8d 50 05             	lea    0x5(%eax),%edx
    bb34:	8b 45 08             	mov    0x8(%ebp),%eax
    bb37:	01 d0                	add    %edx,%eax
    bb39:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    bb3d:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    bb3f:	e9 2b 01 00 00       	jmp    bc6f <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    bb44:	8b 45 10             	mov    0x10(%ebp),%eax
    bb47:	8b 00                	mov    (%eax),%eax
    bb49:	83 f8 04             	cmp    $0x4,%eax
    bb4c:	75 64                	jne    bbb2 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    bb4e:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    bb52:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    bb56:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb59:	c1 e0 02             	shl    $0x2,%eax
    bb5c:	89 c2                	mov    %eax,%edx
    bb5e:	8b 45 08             	mov    0x8(%ebp),%eax
    bb61:	01 d0                	add    %edx,%eax
    bb63:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    bb67:	66 c1 ea 08          	shr    $0x8,%dx
    bb6b:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    bb6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb70:	c1 e0 02             	shl    $0x2,%eax
    bb73:	8d 50 01             	lea    0x1(%eax),%edx
    bb76:	8b 45 08             	mov    0x8(%ebp),%eax
    bb79:	01 d0                	add    %edx,%eax
    bb7b:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    bb7f:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    bb81:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb84:	c1 e0 02             	shl    $0x2,%eax
    bb87:	8d 50 02             	lea    0x2(%eax),%edx
    bb8a:	8b 45 08             	mov    0x8(%ebp),%eax
    bb8d:	01 d0                	add    %edx,%eax
    bb8f:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    bb93:	66 c1 ea 08          	shr    $0x8,%dx
    bb97:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    bb99:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb9c:	c1 e0 02             	shl    $0x2,%eax
    bb9f:	8d 50 03             	lea    0x3(%eax),%edx
    bba2:	8b 45 08             	mov    0x8(%ebp),%eax
    bba5:	01 d0                	add    %edx,%eax
    bba7:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    bbab:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    bbad:	e9 bd 00 00 00       	jmp    bc6f <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    bbb2:	8b 45 10             	mov    0x10(%ebp),%eax
    bbb5:	8b 00                	mov    (%eax),%eax
    bbb7:	83 f8 06             	cmp    $0x6,%eax
    bbba:	0f 85 af 00 00 00    	jne    bc6f <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    bbc0:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbc3:	c1 e0 03             	shl    $0x3,%eax
    bbc6:	89 c2                	mov    %eax,%edx
    bbc8:	8b 45 08             	mov    0x8(%ebp),%eax
    bbcb:	01 d0                	add    %edx,%eax
    bbcd:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    bbd1:	66 c1 ea 08          	shr    $0x8,%dx
    bbd5:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    bbd7:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbda:	c1 e0 03             	shl    $0x3,%eax
    bbdd:	8d 50 01             	lea    0x1(%eax),%edx
    bbe0:	8b 45 08             	mov    0x8(%ebp),%eax
    bbe3:	01 d0                	add    %edx,%eax
    bbe5:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    bbe9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    bbeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbee:	c1 e0 03             	shl    $0x3,%eax
    bbf1:	8d 50 02             	lea    0x2(%eax),%edx
    bbf4:	8b 45 08             	mov    0x8(%ebp),%eax
    bbf7:	01 d0                	add    %edx,%eax
    bbf9:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    bbfd:	66 c1 ea 08          	shr    $0x8,%dx
    bc01:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    bc03:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc06:	c1 e0 03             	shl    $0x3,%eax
    bc09:	8d 50 03             	lea    0x3(%eax),%edx
    bc0c:	8b 45 08             	mov    0x8(%ebp),%eax
    bc0f:	01 d0                	add    %edx,%eax
    bc11:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    bc15:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    bc17:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc1a:	c1 e0 03             	shl    $0x3,%eax
    bc1d:	8d 50 04             	lea    0x4(%eax),%edx
    bc20:	8b 45 08             	mov    0x8(%ebp),%eax
    bc23:	01 d0                	add    %edx,%eax
    bc25:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    bc29:	66 c1 ea 08          	shr    $0x8,%dx
    bc2d:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    bc2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc32:	c1 e0 03             	shl    $0x3,%eax
    bc35:	8d 50 05             	lea    0x5(%eax),%edx
    bc38:	8b 45 08             	mov    0x8(%ebp),%eax
    bc3b:	01 d0                	add    %edx,%eax
    bc3d:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    bc41:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    bc43:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc46:	c1 e0 03             	shl    $0x3,%eax
    bc49:	8d 50 06             	lea    0x6(%eax),%edx
    bc4c:	8b 45 08             	mov    0x8(%ebp),%eax
    bc4f:	01 d0                	add    %edx,%eax
    bc51:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    bc55:	66 c1 ea 08          	shr    $0x8,%dx
    bc59:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    bc5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc5e:	c1 e0 03             	shl    $0x3,%eax
    bc61:	8d 50 07             	lea    0x7(%eax),%edx
    bc64:	8b 45 08             	mov    0x8(%ebp),%eax
    bc67:	01 d0                	add    %edx,%eax
    bc69:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    bc6d:	88 10                	mov    %dl,(%eax)
  }
}
    bc6f:	90                   	nop
    bc70:	83 c4 20             	add    $0x20,%esp
    bc73:	5b                   	pop    %ebx
    bc74:	5d                   	pop    %ebp
    bc75:	c3                   	ret    

0000bc76 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    bc76:	55                   	push   %ebp
    bc77:	89 e5                	mov    %esp,%ebp
    bc79:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    bc7c:	8b 45 20             	mov    0x20(%ebp),%eax
    bc7f:	8b 00                	mov    (%eax),%eax
    bc81:	85 c0                	test   %eax,%eax
    bc83:	0f 85 8c 01 00 00    	jne    be15 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    bc89:	8b 45 20             	mov    0x20(%ebp),%eax
    bc8c:	8b 40 04             	mov    0x4(%eax),%eax
    bc8f:	83 f8 08             	cmp    $0x8,%eax
    bc92:	75 59                	jne    bced <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    bc94:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bc97:	8b 45 18             	mov    0x18(%ebp),%eax
    bc9a:	01 d0                	add    %edx,%eax
    bc9c:	0f b6 10             	movzbl (%eax),%edx
    bc9f:	8b 45 10             	mov    0x10(%ebp),%eax
    bca2:	88 10                	mov    %dl,(%eax)
    bca4:	8b 45 10             	mov    0x10(%ebp),%eax
    bca7:	0f b6 10             	movzbl (%eax),%edx
    bcaa:	8b 45 0c             	mov    0xc(%ebp),%eax
    bcad:	88 10                	mov    %dl,(%eax)
    bcaf:	8b 45 0c             	mov    0xc(%ebp),%eax
    bcb2:	0f b6 10             	movzbl (%eax),%edx
    bcb5:	8b 45 08             	mov    0x8(%ebp),%eax
    bcb8:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    bcba:	8b 45 20             	mov    0x20(%ebp),%eax
    bcbd:	8b 40 10             	mov    0x10(%eax),%eax
    bcc0:	85 c0                	test   %eax,%eax
    bcc2:	74 1e                	je     bce2 <getPixelColorRGBA8+0x6c>
    bcc4:	8b 45 08             	mov    0x8(%ebp),%eax
    bcc7:	0f b6 00             	movzbl (%eax),%eax
    bcca:	0f b6 d0             	movzbl %al,%edx
    bccd:	8b 45 20             	mov    0x20(%ebp),%eax
    bcd0:	8b 40 14             	mov    0x14(%eax),%eax
    bcd3:	39 c2                	cmp    %eax,%edx
    bcd5:	75 0b                	jne    bce2 <getPixelColorRGBA8+0x6c>
    bcd7:	8b 45 14             	mov    0x14(%ebp),%eax
    bcda:	c6 00 00             	movb   $0x0,(%eax)
    bcdd:	e9 5e 05 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    bce2:	8b 45 14             	mov    0x14(%ebp),%eax
    bce5:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    bce8:	e9 53 05 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    bced:	8b 45 20             	mov    0x20(%ebp),%eax
    bcf0:	8b 40 04             	mov    0x4(%eax),%eax
    bcf3:	83 f8 10             	cmp    $0x10,%eax
    bcf6:	0f 85 80 00 00 00    	jne    bd7c <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    bcfc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcff:	01 c0                	add    %eax,%eax
    bd01:	89 c2                	mov    %eax,%edx
    bd03:	8b 45 18             	mov    0x18(%ebp),%eax
    bd06:	01 d0                	add    %edx,%eax
    bd08:	0f b6 10             	movzbl (%eax),%edx
    bd0b:	8b 45 10             	mov    0x10(%ebp),%eax
    bd0e:	88 10                	mov    %dl,(%eax)
    bd10:	8b 45 10             	mov    0x10(%ebp),%eax
    bd13:	0f b6 10             	movzbl (%eax),%edx
    bd16:	8b 45 0c             	mov    0xc(%ebp),%eax
    bd19:	88 10                	mov    %dl,(%eax)
    bd1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    bd1e:	0f b6 10             	movzbl (%eax),%edx
    bd21:	8b 45 08             	mov    0x8(%ebp),%eax
    bd24:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    bd26:	8b 45 20             	mov    0x20(%ebp),%eax
    bd29:	8b 40 10             	mov    0x10(%eax),%eax
    bd2c:	85 c0                	test   %eax,%eax
    bd2e:	74 41                	je     bd71 <getPixelColorRGBA8+0xfb>
    bd30:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd33:	01 c0                	add    %eax,%eax
    bd35:	89 c2                	mov    %eax,%edx
    bd37:	8b 45 18             	mov    0x18(%ebp),%eax
    bd3a:	01 d0                	add    %edx,%eax
    bd3c:	0f b6 00             	movzbl (%eax),%eax
    bd3f:	0f b6 c0             	movzbl %al,%eax
    bd42:	c1 e0 08             	shl    $0x8,%eax
    bd45:	89 c2                	mov    %eax,%edx
    bd47:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd4a:	01 c0                	add    %eax,%eax
    bd4c:	8d 48 01             	lea    0x1(%eax),%ecx
    bd4f:	8b 45 18             	mov    0x18(%ebp),%eax
    bd52:	01 c8                	add    %ecx,%eax
    bd54:	0f b6 00             	movzbl (%eax),%eax
    bd57:	0f b6 c0             	movzbl %al,%eax
    bd5a:	01 c2                	add    %eax,%edx
    bd5c:	8b 45 20             	mov    0x20(%ebp),%eax
    bd5f:	8b 40 14             	mov    0x14(%eax),%eax
    bd62:	39 c2                	cmp    %eax,%edx
    bd64:	75 0b                	jne    bd71 <getPixelColorRGBA8+0xfb>
    bd66:	8b 45 14             	mov    0x14(%ebp),%eax
    bd69:	c6 00 00             	movb   $0x0,(%eax)
    bd6c:	e9 cf 04 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    bd71:	8b 45 14             	mov    0x14(%ebp),%eax
    bd74:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    bd77:	e9 c4 04 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    bd7c:	8b 45 20             	mov    0x20(%ebp),%eax
    bd7f:	8b 40 04             	mov    0x4(%eax),%eax
    bd82:	ba 01 00 00 00       	mov    $0x1,%edx
    bd87:	89 c1                	mov    %eax,%ecx
    bd89:	d3 e2                	shl    %cl,%edx
    bd8b:	89 d0                	mov    %edx,%eax
    bd8d:	83 e8 01             	sub    $0x1,%eax
    bd90:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    bd93:	8b 45 20             	mov    0x20(%ebp),%eax
    bd96:	8b 50 04             	mov    0x4(%eax),%edx
    bd99:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd9c:	0f af c2             	imul   %edx,%eax
    bd9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    bda2:	8b 45 20             	mov    0x20(%ebp),%eax
    bda5:	8b 40 04             	mov    0x4(%eax),%eax
    bda8:	50                   	push   %eax
    bda9:	ff 75 18             	pushl  0x18(%ebp)
    bdac:	8d 45 f0             	lea    -0x10(%ebp),%eax
    bdaf:	50                   	push   %eax
    bdb0:	e8 06 db ff ff       	call   98bb <readBitsFromReversedStream>
    bdb5:	83 c4 0c             	add    $0xc,%esp
    bdb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    bdbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bdbe:	89 d0                	mov    %edx,%eax
    bdc0:	c1 e0 08             	shl    $0x8,%eax
    bdc3:	29 d0                	sub    %edx,%eax
    bdc5:	ba 00 00 00 00       	mov    $0x0,%edx
    bdca:	f7 75 f8             	divl   -0x8(%ebp)
    bdcd:	89 c2                	mov    %eax,%edx
    bdcf:	8b 45 10             	mov    0x10(%ebp),%eax
    bdd2:	88 10                	mov    %dl,(%eax)
    bdd4:	8b 45 10             	mov    0x10(%ebp),%eax
    bdd7:	0f b6 10             	movzbl (%eax),%edx
    bdda:	8b 45 0c             	mov    0xc(%ebp),%eax
    bddd:	88 10                	mov    %dl,(%eax)
    bddf:	8b 45 0c             	mov    0xc(%ebp),%eax
    bde2:	0f b6 10             	movzbl (%eax),%edx
    bde5:	8b 45 08             	mov    0x8(%ebp),%eax
    bde8:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    bdea:	8b 45 20             	mov    0x20(%ebp),%eax
    bded:	8b 40 10             	mov    0x10(%eax),%eax
    bdf0:	85 c0                	test   %eax,%eax
    bdf2:	74 16                	je     be0a <getPixelColorRGBA8+0x194>
    bdf4:	8b 45 20             	mov    0x20(%ebp),%eax
    bdf7:	8b 40 14             	mov    0x14(%eax),%eax
    bdfa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    bdfd:	75 0b                	jne    be0a <getPixelColorRGBA8+0x194>
    bdff:	8b 45 14             	mov    0x14(%ebp),%eax
    be02:	c6 00 00             	movb   $0x0,(%eax)
    be05:	e9 36 04 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    be0a:	8b 45 14             	mov    0x14(%ebp),%eax
    be0d:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    be10:	e9 2b 04 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    be15:	8b 45 20             	mov    0x20(%ebp),%eax
    be18:	8b 00                	mov    (%eax),%eax
    be1a:	83 f8 02             	cmp    $0x2,%eax
    be1d:	0f 85 f5 01 00 00    	jne    c018 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    be23:	8b 45 20             	mov    0x20(%ebp),%eax
    be26:	8b 40 04             	mov    0x4(%eax),%eax
    be29:	83 f8 08             	cmp    $0x8,%eax
    be2c:	0f 85 a3 00 00 00    	jne    bed5 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    be32:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be35:	89 d0                	mov    %edx,%eax
    be37:	01 c0                	add    %eax,%eax
    be39:	01 d0                	add    %edx,%eax
    be3b:	89 c2                	mov    %eax,%edx
    be3d:	8b 45 18             	mov    0x18(%ebp),%eax
    be40:	01 d0                	add    %edx,%eax
    be42:	0f b6 10             	movzbl (%eax),%edx
    be45:	8b 45 08             	mov    0x8(%ebp),%eax
    be48:	88 10                	mov    %dl,(%eax)
    be4a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be4d:	89 d0                	mov    %edx,%eax
    be4f:	01 c0                	add    %eax,%eax
    be51:	01 d0                	add    %edx,%eax
    be53:	8d 50 01             	lea    0x1(%eax),%edx
    be56:	8b 45 18             	mov    0x18(%ebp),%eax
    be59:	01 d0                	add    %edx,%eax
    be5b:	0f b6 10             	movzbl (%eax),%edx
    be5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    be61:	88 10                	mov    %dl,(%eax)
    be63:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be66:	89 d0                	mov    %edx,%eax
    be68:	01 c0                	add    %eax,%eax
    be6a:	01 d0                	add    %edx,%eax
    be6c:	8d 50 02             	lea    0x2(%eax),%edx
    be6f:	8b 45 18             	mov    0x18(%ebp),%eax
    be72:	01 d0                	add    %edx,%eax
    be74:	0f b6 10             	movzbl (%eax),%edx
    be77:	8b 45 10             	mov    0x10(%ebp),%eax
    be7a:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    be7c:	8b 45 20             	mov    0x20(%ebp),%eax
    be7f:	8b 40 10             	mov    0x10(%eax),%eax
    be82:	85 c0                	test   %eax,%eax
    be84:	74 44                	je     beca <getPixelColorRGBA8+0x254>
    be86:	8b 45 08             	mov    0x8(%ebp),%eax
    be89:	0f b6 00             	movzbl (%eax),%eax
    be8c:	0f b6 d0             	movzbl %al,%edx
    be8f:	8b 45 20             	mov    0x20(%ebp),%eax
    be92:	8b 40 14             	mov    0x14(%eax),%eax
    be95:	39 c2                	cmp    %eax,%edx
    be97:	75 31                	jne    beca <getPixelColorRGBA8+0x254>
    be99:	8b 45 0c             	mov    0xc(%ebp),%eax
    be9c:	0f b6 00             	movzbl (%eax),%eax
    be9f:	0f b6 d0             	movzbl %al,%edx
    bea2:	8b 45 20             	mov    0x20(%ebp),%eax
    bea5:	8b 40 18             	mov    0x18(%eax),%eax
    bea8:	39 c2                	cmp    %eax,%edx
    beaa:	75 1e                	jne    beca <getPixelColorRGBA8+0x254>
    beac:	8b 45 10             	mov    0x10(%ebp),%eax
    beaf:	0f b6 00             	movzbl (%eax),%eax
    beb2:	0f b6 d0             	movzbl %al,%edx
    beb5:	8b 45 20             	mov    0x20(%ebp),%eax
    beb8:	8b 40 1c             	mov    0x1c(%eax),%eax
    bebb:	39 c2                	cmp    %eax,%edx
    bebd:	75 0b                	jne    beca <getPixelColorRGBA8+0x254>
    bebf:	8b 45 14             	mov    0x14(%ebp),%eax
    bec2:	c6 00 00             	movb   $0x0,(%eax)
    bec5:	e9 76 03 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    beca:	8b 45 14             	mov    0x14(%ebp),%eax
    becd:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    bed0:	e9 6b 03 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    bed5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bed8:	89 d0                	mov    %edx,%eax
    beda:	01 c0                	add    %eax,%eax
    bedc:	01 d0                	add    %edx,%eax
    bede:	01 c0                	add    %eax,%eax
    bee0:	89 c2                	mov    %eax,%edx
    bee2:	8b 45 18             	mov    0x18(%ebp),%eax
    bee5:	01 d0                	add    %edx,%eax
    bee7:	0f b6 10             	movzbl (%eax),%edx
    beea:	8b 45 08             	mov    0x8(%ebp),%eax
    beed:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    beef:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bef2:	89 d0                	mov    %edx,%eax
    bef4:	01 c0                	add    %eax,%eax
    bef6:	01 d0                	add    %edx,%eax
    bef8:	01 c0                	add    %eax,%eax
    befa:	8d 50 02             	lea    0x2(%eax),%edx
    befd:	8b 45 18             	mov    0x18(%ebp),%eax
    bf00:	01 d0                	add    %edx,%eax
    bf02:	0f b6 10             	movzbl (%eax),%edx
    bf05:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf08:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    bf0a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf0d:	89 d0                	mov    %edx,%eax
    bf0f:	01 c0                	add    %eax,%eax
    bf11:	01 d0                	add    %edx,%eax
    bf13:	01 c0                	add    %eax,%eax
    bf15:	8d 50 04             	lea    0x4(%eax),%edx
    bf18:	8b 45 18             	mov    0x18(%ebp),%eax
    bf1b:	01 d0                	add    %edx,%eax
    bf1d:	0f b6 10             	movzbl (%eax),%edx
    bf20:	8b 45 10             	mov    0x10(%ebp),%eax
    bf23:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    bf25:	8b 45 20             	mov    0x20(%ebp),%eax
    bf28:	8b 40 10             	mov    0x10(%eax),%eax
    bf2b:	85 c0                	test   %eax,%eax
    bf2d:	0f 84 da 00 00 00    	je     c00d <getPixelColorRGBA8+0x397>
    bf33:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf36:	89 d0                	mov    %edx,%eax
    bf38:	01 c0                	add    %eax,%eax
    bf3a:	01 d0                	add    %edx,%eax
    bf3c:	01 c0                	add    %eax,%eax
    bf3e:	89 c2                	mov    %eax,%edx
    bf40:	8b 45 18             	mov    0x18(%ebp),%eax
    bf43:	01 d0                	add    %edx,%eax
    bf45:	0f b6 00             	movzbl (%eax),%eax
    bf48:	0f b6 c0             	movzbl %al,%eax
    bf4b:	c1 e0 08             	shl    $0x8,%eax
    bf4e:	89 c1                	mov    %eax,%ecx
    bf50:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf53:	89 d0                	mov    %edx,%eax
    bf55:	01 c0                	add    %eax,%eax
    bf57:	01 d0                	add    %edx,%eax
    bf59:	01 c0                	add    %eax,%eax
    bf5b:	8d 50 01             	lea    0x1(%eax),%edx
    bf5e:	8b 45 18             	mov    0x18(%ebp),%eax
    bf61:	01 d0                	add    %edx,%eax
    bf63:	0f b6 00             	movzbl (%eax),%eax
    bf66:	0f b6 c0             	movzbl %al,%eax
    bf69:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bf6c:	8b 45 20             	mov    0x20(%ebp),%eax
    bf6f:	8b 40 14             	mov    0x14(%eax),%eax
    bf72:	39 c2                	cmp    %eax,%edx
    bf74:	0f 85 93 00 00 00    	jne    c00d <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    bf7a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf7d:	89 d0                	mov    %edx,%eax
    bf7f:	01 c0                	add    %eax,%eax
    bf81:	01 d0                	add    %edx,%eax
    bf83:	01 c0                	add    %eax,%eax
    bf85:	8d 50 02             	lea    0x2(%eax),%edx
    bf88:	8b 45 18             	mov    0x18(%ebp),%eax
    bf8b:	01 d0                	add    %edx,%eax
    bf8d:	0f b6 00             	movzbl (%eax),%eax
    bf90:	0f b6 c0             	movzbl %al,%eax
    bf93:	c1 e0 08             	shl    $0x8,%eax
    bf96:	89 c1                	mov    %eax,%ecx
    bf98:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf9b:	89 d0                	mov    %edx,%eax
    bf9d:	01 c0                	add    %eax,%eax
    bf9f:	01 d0                	add    %edx,%eax
    bfa1:	01 c0                	add    %eax,%eax
    bfa3:	8d 50 03             	lea    0x3(%eax),%edx
    bfa6:	8b 45 18             	mov    0x18(%ebp),%eax
    bfa9:	01 d0                	add    %edx,%eax
    bfab:	0f b6 00             	movzbl (%eax),%eax
    bfae:	0f b6 c0             	movzbl %al,%eax
    bfb1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bfb4:	8b 45 20             	mov    0x20(%ebp),%eax
    bfb7:	8b 40 18             	mov    0x18(%eax),%eax
    bfba:	39 c2                	cmp    %eax,%edx
    bfbc:	75 4f                	jne    c00d <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    bfbe:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bfc1:	89 d0                	mov    %edx,%eax
    bfc3:	01 c0                	add    %eax,%eax
    bfc5:	01 d0                	add    %edx,%eax
    bfc7:	01 c0                	add    %eax,%eax
    bfc9:	8d 50 04             	lea    0x4(%eax),%edx
    bfcc:	8b 45 18             	mov    0x18(%ebp),%eax
    bfcf:	01 d0                	add    %edx,%eax
    bfd1:	0f b6 00             	movzbl (%eax),%eax
    bfd4:	0f b6 c0             	movzbl %al,%eax
    bfd7:	c1 e0 08             	shl    $0x8,%eax
    bfda:	89 c1                	mov    %eax,%ecx
    bfdc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bfdf:	89 d0                	mov    %edx,%eax
    bfe1:	01 c0                	add    %eax,%eax
    bfe3:	01 d0                	add    %edx,%eax
    bfe5:	01 c0                	add    %eax,%eax
    bfe7:	8d 50 05             	lea    0x5(%eax),%edx
    bfea:	8b 45 18             	mov    0x18(%ebp),%eax
    bfed:	01 d0                	add    %edx,%eax
    bfef:	0f b6 00             	movzbl (%eax),%eax
    bff2:	0f b6 c0             	movzbl %al,%eax
    bff5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bff8:	8b 45 20             	mov    0x20(%ebp),%eax
    bffb:	8b 40 1c             	mov    0x1c(%eax),%eax
    bffe:	39 c2                	cmp    %eax,%edx
    c000:	75 0b                	jne    c00d <getPixelColorRGBA8+0x397>
    c002:	8b 45 14             	mov    0x14(%ebp),%eax
    c005:	c6 00 00             	movb   $0x0,(%eax)
    c008:	e9 33 02 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    c00d:	8b 45 14             	mov    0x14(%ebp),%eax
    c010:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    c013:	e9 28 02 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    c018:	8b 45 20             	mov    0x20(%ebp),%eax
    c01b:	8b 00                	mov    (%eax),%eax
    c01d:	83 f8 03             	cmp    $0x3,%eax
    c020:	0f 85 ac 00 00 00    	jne    c0d2 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    c026:	8b 45 20             	mov    0x20(%ebp),%eax
    c029:	8b 40 04             	mov    0x4(%eax),%eax
    c02c:	83 f8 08             	cmp    $0x8,%eax
    c02f:	75 13                	jne    c044 <getPixelColorRGBA8+0x3ce>
    c031:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c034:	8b 45 18             	mov    0x18(%ebp),%eax
    c037:	01 d0                	add    %edx,%eax
    c039:	0f b6 00             	movzbl (%eax),%eax
    c03c:	0f b6 c0             	movzbl %al,%eax
    c03f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c042:	eb 28                	jmp    c06c <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    c044:	8b 45 20             	mov    0x20(%ebp),%eax
    c047:	8b 50 04             	mov    0x4(%eax),%edx
    c04a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c04d:	0f af c2             	imul   %edx,%eax
    c050:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c053:	8b 45 20             	mov    0x20(%ebp),%eax
    c056:	8b 40 04             	mov    0x4(%eax),%eax
    c059:	50                   	push   %eax
    c05a:	ff 75 18             	pushl  0x18(%ebp)
    c05d:	8d 45 ec             	lea    -0x14(%ebp),%eax
    c060:	50                   	push   %eax
    c061:	e8 55 d8 ff ff       	call   98bb <readBitsFromReversedStream>
    c066:	83 c4 0c             	add    $0xc,%esp
    c069:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    c06c:	8b 45 20             	mov    0x20(%ebp),%eax
    c06f:	8b 40 08             	mov    0x8(%eax),%eax
    c072:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c075:	c1 e2 02             	shl    $0x2,%edx
    c078:	01 d0                	add    %edx,%eax
    c07a:	0f b6 10             	movzbl (%eax),%edx
    c07d:	8b 45 08             	mov    0x8(%ebp),%eax
    c080:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    c082:	8b 45 20             	mov    0x20(%ebp),%eax
    c085:	8b 40 08             	mov    0x8(%eax),%eax
    c088:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c08b:	c1 e2 02             	shl    $0x2,%edx
    c08e:	83 c2 01             	add    $0x1,%edx
    c091:	01 d0                	add    %edx,%eax
    c093:	0f b6 10             	movzbl (%eax),%edx
    c096:	8b 45 0c             	mov    0xc(%ebp),%eax
    c099:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    c09b:	8b 45 20             	mov    0x20(%ebp),%eax
    c09e:	8b 40 08             	mov    0x8(%eax),%eax
    c0a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c0a4:	c1 e2 02             	shl    $0x2,%edx
    c0a7:	83 c2 02             	add    $0x2,%edx
    c0aa:	01 d0                	add    %edx,%eax
    c0ac:	0f b6 10             	movzbl (%eax),%edx
    c0af:	8b 45 10             	mov    0x10(%ebp),%eax
    c0b2:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    c0b4:	8b 45 20             	mov    0x20(%ebp),%eax
    c0b7:	8b 40 08             	mov    0x8(%eax),%eax
    c0ba:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c0bd:	c1 e2 02             	shl    $0x2,%edx
    c0c0:	83 c2 03             	add    $0x3,%edx
    c0c3:	01 d0                	add    %edx,%eax
    c0c5:	0f b6 10             	movzbl (%eax),%edx
    c0c8:	8b 45 14             	mov    0x14(%ebp),%eax
    c0cb:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    c0cd:	e9 6e 01 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    c0d2:	8b 45 20             	mov    0x20(%ebp),%eax
    c0d5:	8b 00                	mov    (%eax),%eax
    c0d7:	83 f8 04             	cmp    $0x4,%eax
    c0da:	0f 85 95 00 00 00    	jne    c175 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    c0e0:	8b 45 20             	mov    0x20(%ebp),%eax
    c0e3:	8b 40 04             	mov    0x4(%eax),%eax
    c0e6:	83 f8 08             	cmp    $0x8,%eax
    c0e9:	75 44                	jne    c12f <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    c0eb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c0ee:	01 c0                	add    %eax,%eax
    c0f0:	89 c2                	mov    %eax,%edx
    c0f2:	8b 45 18             	mov    0x18(%ebp),%eax
    c0f5:	01 d0                	add    %edx,%eax
    c0f7:	0f b6 10             	movzbl (%eax),%edx
    c0fa:	8b 45 10             	mov    0x10(%ebp),%eax
    c0fd:	88 10                	mov    %dl,(%eax)
    c0ff:	8b 45 10             	mov    0x10(%ebp),%eax
    c102:	0f b6 10             	movzbl (%eax),%edx
    c105:	8b 45 0c             	mov    0xc(%ebp),%eax
    c108:	88 10                	mov    %dl,(%eax)
    c10a:	8b 45 0c             	mov    0xc(%ebp),%eax
    c10d:	0f b6 10             	movzbl (%eax),%edx
    c110:	8b 45 08             	mov    0x8(%ebp),%eax
    c113:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    c115:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c118:	01 c0                	add    %eax,%eax
    c11a:	8d 50 01             	lea    0x1(%eax),%edx
    c11d:	8b 45 18             	mov    0x18(%ebp),%eax
    c120:	01 d0                	add    %edx,%eax
    c122:	0f b6 10             	movzbl (%eax),%edx
    c125:	8b 45 14             	mov    0x14(%ebp),%eax
    c128:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    c12a:	e9 11 01 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    c12f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c132:	c1 e0 02             	shl    $0x2,%eax
    c135:	89 c2                	mov    %eax,%edx
    c137:	8b 45 18             	mov    0x18(%ebp),%eax
    c13a:	01 d0                	add    %edx,%eax
    c13c:	0f b6 10             	movzbl (%eax),%edx
    c13f:	8b 45 10             	mov    0x10(%ebp),%eax
    c142:	88 10                	mov    %dl,(%eax)
    c144:	8b 45 10             	mov    0x10(%ebp),%eax
    c147:	0f b6 10             	movzbl (%eax),%edx
    c14a:	8b 45 0c             	mov    0xc(%ebp),%eax
    c14d:	88 10                	mov    %dl,(%eax)
    c14f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c152:	0f b6 10             	movzbl (%eax),%edx
    c155:	8b 45 08             	mov    0x8(%ebp),%eax
    c158:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    c15a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c15d:	c1 e0 02             	shl    $0x2,%eax
    c160:	8d 50 02             	lea    0x2(%eax),%edx
    c163:	8b 45 18             	mov    0x18(%ebp),%eax
    c166:	01 d0                	add    %edx,%eax
    c168:	0f b6 10             	movzbl (%eax),%edx
    c16b:	8b 45 14             	mov    0x14(%ebp),%eax
    c16e:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    c170:	e9 cb 00 00 00       	jmp    c240 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    c175:	8b 45 20             	mov    0x20(%ebp),%eax
    c178:	8b 00                	mov    (%eax),%eax
    c17a:	83 f8 06             	cmp    $0x6,%eax
    c17d:	0f 85 bd 00 00 00    	jne    c240 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    c183:	8b 45 20             	mov    0x20(%ebp),%eax
    c186:	8b 40 04             	mov    0x4(%eax),%eax
    c189:	83 f8 08             	cmp    $0x8,%eax
    c18c:	75 59                	jne    c1e7 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    c18e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c191:	c1 e0 02             	shl    $0x2,%eax
    c194:	89 c2                	mov    %eax,%edx
    c196:	8b 45 18             	mov    0x18(%ebp),%eax
    c199:	01 d0                	add    %edx,%eax
    c19b:	0f b6 10             	movzbl (%eax),%edx
    c19e:	8b 45 08             	mov    0x8(%ebp),%eax
    c1a1:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    c1a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1a6:	c1 e0 02             	shl    $0x2,%eax
    c1a9:	8d 50 01             	lea    0x1(%eax),%edx
    c1ac:	8b 45 18             	mov    0x18(%ebp),%eax
    c1af:	01 d0                	add    %edx,%eax
    c1b1:	0f b6 10             	movzbl (%eax),%edx
    c1b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    c1b7:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    c1b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1bc:	c1 e0 02             	shl    $0x2,%eax
    c1bf:	8d 50 02             	lea    0x2(%eax),%edx
    c1c2:	8b 45 18             	mov    0x18(%ebp),%eax
    c1c5:	01 d0                	add    %edx,%eax
    c1c7:	0f b6 10             	movzbl (%eax),%edx
    c1ca:	8b 45 10             	mov    0x10(%ebp),%eax
    c1cd:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    c1cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1d2:	c1 e0 02             	shl    $0x2,%eax
    c1d5:	8d 50 03             	lea    0x3(%eax),%edx
    c1d8:	8b 45 18             	mov    0x18(%ebp),%eax
    c1db:	01 d0                	add    %edx,%eax
    c1dd:	0f b6 10             	movzbl (%eax),%edx
    c1e0:	8b 45 14             	mov    0x14(%ebp),%eax
    c1e3:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    c1e5:	eb 59                	jmp    c240 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    c1e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1ea:	c1 e0 03             	shl    $0x3,%eax
    c1ed:	89 c2                	mov    %eax,%edx
    c1ef:	8b 45 18             	mov    0x18(%ebp),%eax
    c1f2:	01 d0                	add    %edx,%eax
    c1f4:	0f b6 10             	movzbl (%eax),%edx
    c1f7:	8b 45 08             	mov    0x8(%ebp),%eax
    c1fa:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    c1fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1ff:	c1 e0 03             	shl    $0x3,%eax
    c202:	8d 50 02             	lea    0x2(%eax),%edx
    c205:	8b 45 18             	mov    0x18(%ebp),%eax
    c208:	01 d0                	add    %edx,%eax
    c20a:	0f b6 10             	movzbl (%eax),%edx
    c20d:	8b 45 0c             	mov    0xc(%ebp),%eax
    c210:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    c212:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c215:	c1 e0 03             	shl    $0x3,%eax
    c218:	8d 50 04             	lea    0x4(%eax),%edx
    c21b:	8b 45 18             	mov    0x18(%ebp),%eax
    c21e:	01 d0                	add    %edx,%eax
    c220:	0f b6 10             	movzbl (%eax),%edx
    c223:	8b 45 10             	mov    0x10(%ebp),%eax
    c226:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    c228:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c22b:	c1 e0 03             	shl    $0x3,%eax
    c22e:	8d 50 06             	lea    0x6(%eax),%edx
    c231:	8b 45 18             	mov    0x18(%ebp),%eax
    c234:	01 d0                	add    %edx,%eax
    c236:	0f b6 10             	movzbl (%eax),%edx
    c239:	8b 45 14             	mov    0x14(%ebp),%eax
    c23c:	88 10                	mov    %dl,(%eax)
    }
  }
}
    c23e:	eb 00                	jmp    c240 <getPixelColorRGBA8+0x5ca>
    c240:	90                   	nop
    c241:	c9                   	leave  
    c242:	c3                   	ret    

0000c243 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    c243:	55                   	push   %ebp
    c244:	89 e5                	mov    %esp,%ebp
    c246:	53                   	push   %ebx
    c247:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    c24a:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    c251:	8b 45 14             	mov    0x14(%ebp),%eax
    c254:	8b 00                	mov    (%eax),%eax
    c256:	85 c0                	test   %eax,%eax
    c258:	0f 85 14 02 00 00    	jne    c472 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    c25e:	8b 45 14             	mov    0x14(%ebp),%eax
    c261:	8b 40 04             	mov    0x4(%eax),%eax
    c264:	83 f8 08             	cmp    $0x8,%eax
    c267:	0f 85 a0 00 00 00    	jne    c30d <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c26d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c274:	eb 39                	jmp    c2af <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    c276:	8b 45 08             	mov    0x8(%ebp),%eax
    c279:	83 c0 01             	add    $0x1,%eax
    c27c:	8b 55 08             	mov    0x8(%ebp),%edx
    c27f:	83 c2 02             	add    $0x2,%edx
    c282:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    c285:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c288:	01 d9                	add    %ebx,%ecx
    c28a:	0f b6 09             	movzbl (%ecx),%ecx
    c28d:	88 0a                	mov    %cl,(%edx)
    c28f:	0f b6 12             	movzbl (%edx),%edx
    c292:	88 10                	mov    %dl,(%eax)
    c294:	0f b6 10             	movzbl (%eax),%edx
    c297:	8b 45 08             	mov    0x8(%ebp),%eax
    c29a:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    c29c:	8b 45 08             	mov    0x8(%ebp),%eax
    c29f:	83 c0 03             	add    $0x3,%eax
    c2a2:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c2a5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c2a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2ac:	01 45 08             	add    %eax,0x8(%ebp)
    c2af:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c2b2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c2b5:	75 bf                	jne    c276 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    c2b7:	8b 45 14             	mov    0x14(%ebp),%eax
    c2ba:	8b 40 10             	mov    0x10(%eax),%eax
    c2bd:	85 c0                	test   %eax,%eax
    c2bf:	0f 84 48 06 00 00    	je     c90d <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    c2c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    c2c8:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    c2cc:	f7 d8                	neg    %eax
    c2ce:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c2d1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c2d8:	eb 26                	jmp    c300 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    c2da:	8b 45 08             	mov    0x8(%ebp),%eax
    c2dd:	0f b6 00             	movzbl (%eax),%eax
    c2e0:	0f b6 d0             	movzbl %al,%edx
    c2e3:	8b 45 14             	mov    0x14(%ebp),%eax
    c2e6:	8b 40 14             	mov    0x14(%eax),%eax
    c2e9:	39 c2                	cmp    %eax,%edx
    c2eb:	75 09                	jne    c2f6 <getPixelColorsRGBA8+0xb3>
    c2ed:	8b 45 08             	mov    0x8(%ebp),%eax
    c2f0:	83 c0 03             	add    $0x3,%eax
    c2f3:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c2f6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c2fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2fd:	01 45 08             	add    %eax,0x8(%ebp)
    c300:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c303:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c306:	75 d2                	jne    c2da <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c308:	e9 00 06 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    c30d:	8b 45 14             	mov    0x14(%ebp),%eax
    c310:	8b 40 04             	mov    0x4(%eax),%eax
    c313:	83 f8 10             	cmp    $0x10,%eax
    c316:	0f 85 a5 00 00 00    	jne    c3c1 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c31c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c323:	e9 88 00 00 00       	jmp    c3b0 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    c328:	8b 45 08             	mov    0x8(%ebp),%eax
    c32b:	83 c0 01             	add    $0x1,%eax
    c32e:	8b 55 08             	mov    0x8(%ebp),%edx
    c331:	83 c2 02             	add    $0x2,%edx
    c334:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c337:	01 c9                	add    %ecx,%ecx
    c339:	89 cb                	mov    %ecx,%ebx
    c33b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c33e:	01 d9                	add    %ebx,%ecx
    c340:	0f b6 09             	movzbl (%ecx),%ecx
    c343:	88 0a                	mov    %cl,(%edx)
    c345:	0f b6 12             	movzbl (%edx),%edx
    c348:	88 10                	mov    %dl,(%eax)
    c34a:	0f b6 10             	movzbl (%eax),%edx
    c34d:	8b 45 08             	mov    0x8(%ebp),%eax
    c350:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    c352:	8b 45 08             	mov    0x8(%ebp),%eax
    c355:	8d 50 03             	lea    0x3(%eax),%edx
    c358:	8b 45 14             	mov    0x14(%ebp),%eax
    c35b:	8b 40 10             	mov    0x10(%eax),%eax
    c35e:	85 c0                	test   %eax,%eax
    c360:	74 3d                	je     c39f <getPixelColorsRGBA8+0x15c>
    c362:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c365:	01 c0                	add    %eax,%eax
    c367:	89 c1                	mov    %eax,%ecx
    c369:	8b 45 10             	mov    0x10(%ebp),%eax
    c36c:	01 c8                	add    %ecx,%eax
    c36e:	0f b6 00             	movzbl (%eax),%eax
    c371:	0f b6 c0             	movzbl %al,%eax
    c374:	c1 e0 08             	shl    $0x8,%eax
    c377:	89 c1                	mov    %eax,%ecx
    c379:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c37c:	01 c0                	add    %eax,%eax
    c37e:	8d 58 01             	lea    0x1(%eax),%ebx
    c381:	8b 45 10             	mov    0x10(%ebp),%eax
    c384:	01 d8                	add    %ebx,%eax
    c386:	0f b6 00             	movzbl (%eax),%eax
    c389:	0f b6 c0             	movzbl %al,%eax
    c38c:	01 c1                	add    %eax,%ecx
    c38e:	8b 45 14             	mov    0x14(%ebp),%eax
    c391:	8b 40 14             	mov    0x14(%eax),%eax
    c394:	39 c1                	cmp    %eax,%ecx
    c396:	75 07                	jne    c39f <getPixelColorsRGBA8+0x15c>
    c398:	b8 00 00 00 00       	mov    $0x0,%eax
    c39d:	eb 05                	jmp    c3a4 <getPixelColorsRGBA8+0x161>
    c39f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    c3a4:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c3a6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c3aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3ad:	01 45 08             	add    %eax,0x8(%ebp)
    c3b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c3b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c3b6:	0f 85 6c ff ff ff    	jne    c328 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c3bc:	e9 4c 05 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    c3c1:	8b 45 14             	mov    0x14(%ebp),%eax
    c3c4:	8b 40 04             	mov    0x4(%eax),%eax
    c3c7:	ba 01 00 00 00       	mov    $0x1,%edx
    c3cc:	89 c1                	mov    %eax,%ecx
    c3ce:	d3 e2                	shl    %cl,%edx
    c3d0:	89 d0                	mov    %edx,%eax
    c3d2:	83 e8 01             	sub    $0x1,%eax
    c3d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    c3d8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c3df:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c3e6:	eb 79                	jmp    c461 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c3e8:	8b 45 14             	mov    0x14(%ebp),%eax
    c3eb:	8b 40 04             	mov    0x4(%eax),%eax
    c3ee:	50                   	push   %eax
    c3ef:	ff 75 10             	pushl  0x10(%ebp)
    c3f2:	8d 45 e0             	lea    -0x20(%ebp),%eax
    c3f5:	50                   	push   %eax
    c3f6:	e8 c0 d4 ff ff       	call   98bb <readBitsFromReversedStream>
    c3fb:	83 c4 0c             	add    $0xc,%esp
    c3fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    c401:	8b 45 08             	mov    0x8(%ebp),%eax
    c404:	8d 48 01             	lea    0x1(%eax),%ecx
    c407:	8b 45 08             	mov    0x8(%ebp),%eax
    c40a:	8d 58 02             	lea    0x2(%eax),%ebx
    c40d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c410:	89 d0                	mov    %edx,%eax
    c412:	c1 e0 08             	shl    $0x8,%eax
    c415:	29 d0                	sub    %edx,%eax
    c417:	ba 00 00 00 00       	mov    $0x0,%edx
    c41c:	f7 75 f0             	divl   -0x10(%ebp)
    c41f:	88 03                	mov    %al,(%ebx)
    c421:	0f b6 03             	movzbl (%ebx),%eax
    c424:	88 01                	mov    %al,(%ecx)
    c426:	0f b6 11             	movzbl (%ecx),%edx
    c429:	8b 45 08             	mov    0x8(%ebp),%eax
    c42c:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    c42e:	8b 45 08             	mov    0x8(%ebp),%eax
    c431:	8d 50 03             	lea    0x3(%eax),%edx
    c434:	8b 45 14             	mov    0x14(%ebp),%eax
    c437:	8b 40 10             	mov    0x10(%eax),%eax
    c43a:	85 c0                	test   %eax,%eax
    c43c:	74 12                	je     c450 <getPixelColorsRGBA8+0x20d>
    c43e:	8b 45 14             	mov    0x14(%ebp),%eax
    c441:	8b 40 14             	mov    0x14(%eax),%eax
    c444:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    c447:	75 07                	jne    c450 <getPixelColorsRGBA8+0x20d>
    c449:	b8 00 00 00 00       	mov    $0x0,%eax
    c44e:	eb 05                	jmp    c455 <getPixelColorsRGBA8+0x212>
    c450:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    c455:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c457:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c45b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c45e:	01 45 08             	add    %eax,0x8(%ebp)
    c461:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c464:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c467:	0f 85 7b ff ff ff    	jne    c3e8 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c46d:	e9 9b 04 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    c472:	8b 45 14             	mov    0x14(%ebp),%eax
    c475:	8b 00                	mov    (%eax),%eax
    c477:	83 f8 02             	cmp    $0x2,%eax
    c47a:	0f 85 41 02 00 00    	jne    c6c1 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    c480:	8b 45 14             	mov    0x14(%ebp),%eax
    c483:	8b 40 04             	mov    0x4(%eax),%eax
    c486:	83 f8 08             	cmp    $0x8,%eax
    c489:	0f 85 c4 00 00 00    	jne    c553 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c48f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c496:	eb 31                	jmp    c4c9 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    c498:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c49b:	89 d0                	mov    %edx,%eax
    c49d:	01 c0                	add    %eax,%eax
    c49f:	01 d0                	add    %edx,%eax
    c4a1:	89 c2                	mov    %eax,%edx
    c4a3:	8b 45 10             	mov    0x10(%ebp),%eax
    c4a6:	01 d0                	add    %edx,%eax
    c4a8:	6a 03                	push   $0x3
    c4aa:	50                   	push   %eax
    c4ab:	ff 75 08             	pushl  0x8(%ebp)
    c4ae:	e8 a3 85 ff ff       	call   4a56 <lodepng_memcpy>
    c4b3:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    c4b6:	8b 45 08             	mov    0x8(%ebp),%eax
    c4b9:	83 c0 03             	add    $0x3,%eax
    c4bc:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c4bf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c4c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c4c6:	01 45 08             	add    %eax,0x8(%ebp)
    c4c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c4cc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c4cf:	75 c7                	jne    c498 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    c4d1:	8b 45 14             	mov    0x14(%ebp),%eax
    c4d4:	8b 40 10             	mov    0x10(%eax),%eax
    c4d7:	85 c0                	test   %eax,%eax
    c4d9:	0f 84 2e 04 00 00    	je     c90d <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    c4df:	8b 45 0c             	mov    0xc(%ebp),%eax
    c4e2:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    c4e6:	f7 d8                	neg    %eax
    c4e8:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c4eb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c4f2:	eb 52                	jmp    c546 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    c4f4:	8b 45 08             	mov    0x8(%ebp),%eax
    c4f7:	0f b6 00             	movzbl (%eax),%eax
    c4fa:	0f b6 d0             	movzbl %al,%edx
    c4fd:	8b 45 14             	mov    0x14(%ebp),%eax
    c500:	8b 40 14             	mov    0x14(%eax),%eax
    c503:	39 c2                	cmp    %eax,%edx
    c505:	75 35                	jne    c53c <getPixelColorsRGBA8+0x2f9>
    c507:	8b 45 08             	mov    0x8(%ebp),%eax
    c50a:	83 c0 01             	add    $0x1,%eax
    c50d:	0f b6 00             	movzbl (%eax),%eax
    c510:	0f b6 d0             	movzbl %al,%edx
    c513:	8b 45 14             	mov    0x14(%ebp),%eax
    c516:	8b 40 18             	mov    0x18(%eax),%eax
    c519:	39 c2                	cmp    %eax,%edx
    c51b:	75 1f                	jne    c53c <getPixelColorsRGBA8+0x2f9>
    c51d:	8b 45 08             	mov    0x8(%ebp),%eax
    c520:	83 c0 02             	add    $0x2,%eax
    c523:	0f b6 00             	movzbl (%eax),%eax
    c526:	0f b6 d0             	movzbl %al,%edx
    c529:	8b 45 14             	mov    0x14(%ebp),%eax
    c52c:	8b 40 1c             	mov    0x1c(%eax),%eax
    c52f:	39 c2                	cmp    %eax,%edx
    c531:	75 09                	jne    c53c <getPixelColorsRGBA8+0x2f9>
    c533:	8b 45 08             	mov    0x8(%ebp),%eax
    c536:	83 c0 03             	add    $0x3,%eax
    c539:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c53c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c540:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c543:	01 45 08             	add    %eax,0x8(%ebp)
    c546:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c549:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c54c:	75 a6                	jne    c4f4 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c54e:	e9 ba 03 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c553:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c55a:	e9 51 01 00 00       	jmp    c6b0 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    c55f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c562:	89 d0                	mov    %edx,%eax
    c564:	01 c0                	add    %eax,%eax
    c566:	01 d0                	add    %edx,%eax
    c568:	01 c0                	add    %eax,%eax
    c56a:	89 c2                	mov    %eax,%edx
    c56c:	8b 45 10             	mov    0x10(%ebp),%eax
    c56f:	01 d0                	add    %edx,%eax
    c571:	0f b6 10             	movzbl (%eax),%edx
    c574:	8b 45 08             	mov    0x8(%ebp),%eax
    c577:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    c579:	8b 45 08             	mov    0x8(%ebp),%eax
    c57c:	8d 48 01             	lea    0x1(%eax),%ecx
    c57f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c582:	89 d0                	mov    %edx,%eax
    c584:	01 c0                	add    %eax,%eax
    c586:	01 d0                	add    %edx,%eax
    c588:	01 c0                	add    %eax,%eax
    c58a:	8d 50 02             	lea    0x2(%eax),%edx
    c58d:	8b 45 10             	mov    0x10(%ebp),%eax
    c590:	01 d0                	add    %edx,%eax
    c592:	0f b6 00             	movzbl (%eax),%eax
    c595:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    c597:	8b 45 08             	mov    0x8(%ebp),%eax
    c59a:	8d 48 02             	lea    0x2(%eax),%ecx
    c59d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c5a0:	89 d0                	mov    %edx,%eax
    c5a2:	01 c0                	add    %eax,%eax
    c5a4:	01 d0                	add    %edx,%eax
    c5a6:	01 c0                	add    %eax,%eax
    c5a8:	8d 50 04             	lea    0x4(%eax),%edx
    c5ab:	8b 45 10             	mov    0x10(%ebp),%eax
    c5ae:	01 d0                	add    %edx,%eax
    c5b0:	0f b6 00             	movzbl (%eax),%eax
    c5b3:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    c5b5:	8b 45 08             	mov    0x8(%ebp),%eax
    c5b8:	8d 48 03             	lea    0x3(%eax),%ecx
    c5bb:	8b 45 14             	mov    0x14(%ebp),%eax
    c5be:	8b 40 10             	mov    0x10(%eax),%eax
    c5c1:	85 c0                	test   %eax,%eax
    c5c3:	0f 84 d6 00 00 00    	je     c69f <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    c5c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c5cc:	89 d0                	mov    %edx,%eax
    c5ce:	01 c0                	add    %eax,%eax
    c5d0:	01 d0                	add    %edx,%eax
    c5d2:	01 c0                	add    %eax,%eax
    c5d4:	89 c2                	mov    %eax,%edx
    c5d6:	8b 45 10             	mov    0x10(%ebp),%eax
    c5d9:	01 d0                	add    %edx,%eax
    c5db:	0f b6 00             	movzbl (%eax),%eax
    c5de:	0f b6 c0             	movzbl %al,%eax
    c5e1:	c1 e0 08             	shl    $0x8,%eax
    c5e4:	89 c3                	mov    %eax,%ebx
    c5e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c5e9:	89 d0                	mov    %edx,%eax
    c5eb:	01 c0                	add    %eax,%eax
    c5ed:	01 d0                	add    %edx,%eax
    c5ef:	01 c0                	add    %eax,%eax
    c5f1:	8d 50 01             	lea    0x1(%eax),%edx
    c5f4:	8b 45 10             	mov    0x10(%ebp),%eax
    c5f7:	01 d0                	add    %edx,%eax
    c5f9:	0f b6 00             	movzbl (%eax),%eax
    c5fc:	0f b6 c0             	movzbl %al,%eax
    c5ff:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    c602:	8b 45 14             	mov    0x14(%ebp),%eax
    c605:	8b 40 14             	mov    0x14(%eax),%eax
    c608:	39 c2                	cmp    %eax,%edx
    c60a:	0f 85 8f 00 00 00    	jne    c69f <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    c610:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c613:	89 d0                	mov    %edx,%eax
    c615:	01 c0                	add    %eax,%eax
    c617:	01 d0                	add    %edx,%eax
    c619:	01 c0                	add    %eax,%eax
    c61b:	8d 50 02             	lea    0x2(%eax),%edx
    c61e:	8b 45 10             	mov    0x10(%ebp),%eax
    c621:	01 d0                	add    %edx,%eax
    c623:	0f b6 00             	movzbl (%eax),%eax
    c626:	0f b6 c0             	movzbl %al,%eax
    c629:	c1 e0 08             	shl    $0x8,%eax
    c62c:	89 c3                	mov    %eax,%ebx
    c62e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c631:	89 d0                	mov    %edx,%eax
    c633:	01 c0                	add    %eax,%eax
    c635:	01 d0                	add    %edx,%eax
    c637:	01 c0                	add    %eax,%eax
    c639:	8d 50 03             	lea    0x3(%eax),%edx
    c63c:	8b 45 10             	mov    0x10(%ebp),%eax
    c63f:	01 d0                	add    %edx,%eax
    c641:	0f b6 00             	movzbl (%eax),%eax
    c644:	0f b6 c0             	movzbl %al,%eax
    c647:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    c64a:	8b 45 14             	mov    0x14(%ebp),%eax
    c64d:	8b 40 18             	mov    0x18(%eax),%eax
    c650:	39 c2                	cmp    %eax,%edx
    c652:	75 4b                	jne    c69f <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    c654:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c657:	89 d0                	mov    %edx,%eax
    c659:	01 c0                	add    %eax,%eax
    c65b:	01 d0                	add    %edx,%eax
    c65d:	01 c0                	add    %eax,%eax
    c65f:	8d 50 04             	lea    0x4(%eax),%edx
    c662:	8b 45 10             	mov    0x10(%ebp),%eax
    c665:	01 d0                	add    %edx,%eax
    c667:	0f b6 00             	movzbl (%eax),%eax
    c66a:	0f b6 c0             	movzbl %al,%eax
    c66d:	c1 e0 08             	shl    $0x8,%eax
    c670:	89 c3                	mov    %eax,%ebx
    c672:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c675:	89 d0                	mov    %edx,%eax
    c677:	01 c0                	add    %eax,%eax
    c679:	01 d0                	add    %edx,%eax
    c67b:	01 c0                	add    %eax,%eax
    c67d:	8d 50 05             	lea    0x5(%eax),%edx
    c680:	8b 45 10             	mov    0x10(%ebp),%eax
    c683:	01 d0                	add    %edx,%eax
    c685:	0f b6 00             	movzbl (%eax),%eax
    c688:	0f b6 c0             	movzbl %al,%eax
    c68b:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    c68e:	8b 45 14             	mov    0x14(%ebp),%eax
    c691:	8b 40 1c             	mov    0x1c(%eax),%eax
    c694:	39 c2                	cmp    %eax,%edx
    c696:	75 07                	jne    c69f <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    c698:	b8 00 00 00 00       	mov    $0x0,%eax
    c69d:	eb 05                	jmp    c6a4 <getPixelColorsRGBA8+0x461>
    c69f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    c6a4:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c6a6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c6aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6ad:	01 45 08             	add    %eax,0x8(%ebp)
    c6b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c6b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c6b6:	0f 85 a3 fe ff ff    	jne    c55f <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c6bc:	e9 4c 02 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    c6c1:	8b 45 14             	mov    0x14(%ebp),%eax
    c6c4:	8b 00                	mov    (%eax),%eax
    c6c6:	83 f8 03             	cmp    $0x3,%eax
    c6c9:	0f 85 b4 00 00 00    	jne    c783 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    c6cf:	8b 45 14             	mov    0x14(%ebp),%eax
    c6d2:	8b 40 04             	mov    0x4(%eax),%eax
    c6d5:	83 f8 08             	cmp    $0x8,%eax
    c6d8:	75 4d                	jne    c727 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c6da:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c6e1:	eb 37                	jmp    c71a <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    c6e3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c6e6:	8b 45 10             	mov    0x10(%ebp),%eax
    c6e9:	01 d0                	add    %edx,%eax
    c6eb:	0f b6 00             	movzbl (%eax),%eax
    c6ee:	0f b6 c0             	movzbl %al,%eax
    c6f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    c6f4:	8b 45 14             	mov    0x14(%ebp),%eax
    c6f7:	8b 40 08             	mov    0x8(%eax),%eax
    c6fa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    c6fd:	c1 e2 02             	shl    $0x2,%edx
    c700:	01 d0                	add    %edx,%eax
    c702:	6a 04                	push   $0x4
    c704:	50                   	push   %eax
    c705:	ff 75 08             	pushl  0x8(%ebp)
    c708:	e8 49 83 ff ff       	call   4a56 <lodepng_memcpy>
    c70d:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c710:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c714:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c717:	01 45 08             	add    %eax,0x8(%ebp)
    c71a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c71d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c720:	75 c1                	jne    c6e3 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c722:	e9 e6 01 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    c727:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c72e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c735:	eb 3f                	jmp    c776 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c737:	8b 45 14             	mov    0x14(%ebp),%eax
    c73a:	8b 40 04             	mov    0x4(%eax),%eax
    c73d:	50                   	push   %eax
    c73e:	ff 75 10             	pushl  0x10(%ebp)
    c741:	8d 45 dc             	lea    -0x24(%ebp),%eax
    c744:	50                   	push   %eax
    c745:	e8 71 d1 ff ff       	call   98bb <readBitsFromReversedStream>
    c74a:	83 c4 0c             	add    $0xc,%esp
    c74d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    c750:	8b 45 14             	mov    0x14(%ebp),%eax
    c753:	8b 40 08             	mov    0x8(%eax),%eax
    c756:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c759:	c1 e2 02             	shl    $0x2,%edx
    c75c:	01 d0                	add    %edx,%eax
    c75e:	6a 04                	push   $0x4
    c760:	50                   	push   %eax
    c761:	ff 75 08             	pushl  0x8(%ebp)
    c764:	e8 ed 82 ff ff       	call   4a56 <lodepng_memcpy>
    c769:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c76c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c770:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c773:	01 45 08             	add    %eax,0x8(%ebp)
    c776:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c779:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c77c:	75 b9                	jne    c737 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c77e:	e9 8a 01 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    c783:	8b 45 14             	mov    0x14(%ebp),%eax
    c786:	8b 00                	mov    (%eax),%eax
    c788:	83 f8 04             	cmp    $0x4,%eax
    c78b:	0f 85 d1 00 00 00    	jne    c862 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    c791:	8b 45 14             	mov    0x14(%ebp),%eax
    c794:	8b 40 04             	mov    0x4(%eax),%eax
    c797:	83 f8 08             	cmp    $0x8,%eax
    c79a:	75 62                	jne    c7fe <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c79c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c7a3:	eb 4c                	jmp    c7f1 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    c7a5:	8b 45 08             	mov    0x8(%ebp),%eax
    c7a8:	83 c0 01             	add    $0x1,%eax
    c7ab:	8b 55 08             	mov    0x8(%ebp),%edx
    c7ae:	83 c2 02             	add    $0x2,%edx
    c7b1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c7b4:	01 c9                	add    %ecx,%ecx
    c7b6:	89 cb                	mov    %ecx,%ebx
    c7b8:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c7bb:	01 d9                	add    %ebx,%ecx
    c7bd:	0f b6 09             	movzbl (%ecx),%ecx
    c7c0:	88 0a                	mov    %cl,(%edx)
    c7c2:	0f b6 12             	movzbl (%edx),%edx
    c7c5:	88 10                	mov    %dl,(%eax)
    c7c7:	0f b6 10             	movzbl (%eax),%edx
    c7ca:	8b 45 08             	mov    0x8(%ebp),%eax
    c7cd:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    c7cf:	8b 45 08             	mov    0x8(%ebp),%eax
    c7d2:	8d 50 03             	lea    0x3(%eax),%edx
    c7d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c7d8:	01 c0                	add    %eax,%eax
    c7da:	8d 48 01             	lea    0x1(%eax),%ecx
    c7dd:	8b 45 10             	mov    0x10(%ebp),%eax
    c7e0:	01 c8                	add    %ecx,%eax
    c7e2:	0f b6 00             	movzbl (%eax),%eax
    c7e5:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c7e7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c7eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c7ee:	01 45 08             	add    %eax,0x8(%ebp)
    c7f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c7f4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c7f7:	75 ac                	jne    c7a5 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c7f9:	e9 0f 01 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c7fe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c805:	eb 4e                	jmp    c855 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    c807:	8b 45 08             	mov    0x8(%ebp),%eax
    c80a:	83 c0 01             	add    $0x1,%eax
    c80d:	8b 55 08             	mov    0x8(%ebp),%edx
    c810:	83 c2 02             	add    $0x2,%edx
    c813:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c816:	c1 e1 02             	shl    $0x2,%ecx
    c819:	89 cb                	mov    %ecx,%ebx
    c81b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c81e:	01 d9                	add    %ebx,%ecx
    c820:	0f b6 09             	movzbl (%ecx),%ecx
    c823:	88 0a                	mov    %cl,(%edx)
    c825:	0f b6 12             	movzbl (%edx),%edx
    c828:	88 10                	mov    %dl,(%eax)
    c82a:	0f b6 10             	movzbl (%eax),%edx
    c82d:	8b 45 08             	mov    0x8(%ebp),%eax
    c830:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    c832:	8b 45 08             	mov    0x8(%ebp),%eax
    c835:	8d 50 03             	lea    0x3(%eax),%edx
    c838:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c83b:	c1 e0 02             	shl    $0x2,%eax
    c83e:	8d 48 02             	lea    0x2(%eax),%ecx
    c841:	8b 45 10             	mov    0x10(%ebp),%eax
    c844:	01 c8                	add    %ecx,%eax
    c846:	0f b6 00             	movzbl (%eax),%eax
    c849:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c84b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c84f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c852:	01 45 08             	add    %eax,0x8(%ebp)
    c855:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c858:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c85b:	75 aa                	jne    c807 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c85d:	e9 ab 00 00 00       	jmp    c90d <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    c862:	8b 45 14             	mov    0x14(%ebp),%eax
    c865:	8b 00                	mov    (%eax),%eax
    c867:	83 f8 06             	cmp    $0x6,%eax
    c86a:	0f 85 9d 00 00 00    	jne    c90d <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    c870:	8b 45 14             	mov    0x14(%ebp),%eax
    c873:	8b 40 04             	mov    0x4(%eax),%eax
    c876:	83 f8 08             	cmp    $0x8,%eax
    c879:	75 17                	jne    c892 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    c87b:	8b 45 0c             	mov    0xc(%ebp),%eax
    c87e:	c1 e0 02             	shl    $0x2,%eax
    c881:	50                   	push   %eax
    c882:	ff 75 10             	pushl  0x10(%ebp)
    c885:	ff 75 08             	pushl  0x8(%ebp)
    c888:	e8 c9 81 ff ff       	call   4a56 <lodepng_memcpy>
    c88d:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c890:	eb 7b                	jmp    c90d <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c892:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c899:	eb 6a                	jmp    c905 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    c89b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c89e:	c1 e0 03             	shl    $0x3,%eax
    c8a1:	89 c2                	mov    %eax,%edx
    c8a3:	8b 45 10             	mov    0x10(%ebp),%eax
    c8a6:	01 d0                	add    %edx,%eax
    c8a8:	0f b6 10             	movzbl (%eax),%edx
    c8ab:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ae:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    c8b0:	8b 45 08             	mov    0x8(%ebp),%eax
    c8b3:	8d 50 01             	lea    0x1(%eax),%edx
    c8b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c8b9:	c1 e0 03             	shl    $0x3,%eax
    c8bc:	8d 48 02             	lea    0x2(%eax),%ecx
    c8bf:	8b 45 10             	mov    0x10(%ebp),%eax
    c8c2:	01 c8                	add    %ecx,%eax
    c8c4:	0f b6 00             	movzbl (%eax),%eax
    c8c7:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    c8c9:	8b 45 08             	mov    0x8(%ebp),%eax
    c8cc:	8d 50 02             	lea    0x2(%eax),%edx
    c8cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c8d2:	c1 e0 03             	shl    $0x3,%eax
    c8d5:	8d 48 04             	lea    0x4(%eax),%ecx
    c8d8:	8b 45 10             	mov    0x10(%ebp),%eax
    c8db:	01 c8                	add    %ecx,%eax
    c8dd:	0f b6 00             	movzbl (%eax),%eax
    c8e0:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    c8e2:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e5:	8d 50 03             	lea    0x3(%eax),%edx
    c8e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c8eb:	c1 e0 03             	shl    $0x3,%eax
    c8ee:	8d 48 06             	lea    0x6(%eax),%ecx
    c8f1:	8b 45 10             	mov    0x10(%ebp),%eax
    c8f4:	01 c8                	add    %ecx,%eax
    c8f6:	0f b6 00             	movzbl (%eax),%eax
    c8f9:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c8fb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c8ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c902:	01 45 08             	add    %eax,0x8(%ebp)
    c905:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c908:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c90b:	75 8e                	jne    c89b <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c90d:	90                   	nop
    c90e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c911:	c9                   	leave  
    c912:	c3                   	ret    

0000c913 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    c913:	55                   	push   %ebp
    c914:	89 e5                	mov    %esp,%ebp
    c916:	53                   	push   %ebx
    c917:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    c91a:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    c921:	8b 45 14             	mov    0x14(%ebp),%eax
    c924:	8b 00                	mov    (%eax),%eax
    c926:	85 c0                	test   %eax,%eax
    c928:	0f 85 2a 01 00 00    	jne    ca58 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    c92e:	8b 45 14             	mov    0x14(%ebp),%eax
    c931:	8b 40 04             	mov    0x4(%eax),%eax
    c934:	83 f8 08             	cmp    $0x8,%eax
    c937:	75 46                	jne    c97f <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c939:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c940:	eb 30                	jmp    c972 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    c942:	8b 45 08             	mov    0x8(%ebp),%eax
    c945:	83 c0 01             	add    $0x1,%eax
    c948:	8b 55 08             	mov    0x8(%ebp),%edx
    c94b:	83 c2 02             	add    $0x2,%edx
    c94e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    c951:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c954:	01 d9                	add    %ebx,%ecx
    c956:	0f b6 09             	movzbl (%ecx),%ecx
    c959:	88 0a                	mov    %cl,(%edx)
    c95b:	0f b6 12             	movzbl (%edx),%edx
    c95e:	88 10                	mov    %dl,(%eax)
    c960:	0f b6 10             	movzbl (%eax),%edx
    c963:	8b 45 08             	mov    0x8(%ebp),%eax
    c966:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c968:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c96c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c96f:	01 45 08             	add    %eax,0x8(%ebp)
    c972:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c975:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c978:	75 c8                	jne    c942 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c97a:	e9 a8 03 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    c97f:	8b 45 14             	mov    0x14(%ebp),%eax
    c982:	8b 40 04             	mov    0x4(%eax),%eax
    c985:	83 f8 10             	cmp    $0x10,%eax
    c988:	75 4a                	jne    c9d4 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c98a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c991:	eb 34                	jmp    c9c7 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    c993:	8b 45 08             	mov    0x8(%ebp),%eax
    c996:	83 c0 01             	add    $0x1,%eax
    c999:	8b 55 08             	mov    0x8(%ebp),%edx
    c99c:	83 c2 02             	add    $0x2,%edx
    c99f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c9a2:	01 c9                	add    %ecx,%ecx
    c9a4:	89 cb                	mov    %ecx,%ebx
    c9a6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c9a9:	01 d9                	add    %ebx,%ecx
    c9ab:	0f b6 09             	movzbl (%ecx),%ecx
    c9ae:	88 0a                	mov    %cl,(%edx)
    c9b0:	0f b6 12             	movzbl (%edx),%edx
    c9b3:	88 10                	mov    %dl,(%eax)
    c9b5:	0f b6 10             	movzbl (%eax),%edx
    c9b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c9bb:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c9bd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c9c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c9c4:	01 45 08             	add    %eax,0x8(%ebp)
    c9c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c9ca:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c9cd:	75 c4                	jne    c993 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c9cf:	e9 53 03 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    c9d4:	8b 45 14             	mov    0x14(%ebp),%eax
    c9d7:	8b 40 04             	mov    0x4(%eax),%eax
    c9da:	ba 01 00 00 00       	mov    $0x1,%edx
    c9df:	89 c1                	mov    %eax,%ecx
    c9e1:	d3 e2                	shl    %cl,%edx
    c9e3:	89 d0                	mov    %edx,%eax
    c9e5:	83 e8 01             	sub    $0x1,%eax
    c9e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    c9eb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c9f2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c9f9:	eb 50                	jmp    ca4b <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c9fb:	8b 45 14             	mov    0x14(%ebp),%eax
    c9fe:	8b 40 04             	mov    0x4(%eax),%eax
    ca01:	50                   	push   %eax
    ca02:	ff 75 10             	pushl  0x10(%ebp)
    ca05:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ca08:	50                   	push   %eax
    ca09:	e8 ad ce ff ff       	call   98bb <readBitsFromReversedStream>
    ca0e:	83 c4 0c             	add    $0xc,%esp
    ca11:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ca14:	8b 45 08             	mov    0x8(%ebp),%eax
    ca17:	8d 48 01             	lea    0x1(%eax),%ecx
    ca1a:	8b 45 08             	mov    0x8(%ebp),%eax
    ca1d:	8d 58 02             	lea    0x2(%eax),%ebx
    ca20:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ca23:	89 d0                	mov    %edx,%eax
    ca25:	c1 e0 08             	shl    $0x8,%eax
    ca28:	29 d0                	sub    %edx,%eax
    ca2a:	ba 00 00 00 00       	mov    $0x0,%edx
    ca2f:	f7 75 f0             	divl   -0x10(%ebp)
    ca32:	88 03                	mov    %al,(%ebx)
    ca34:	0f b6 03             	movzbl (%ebx),%eax
    ca37:	88 01                	mov    %al,(%ecx)
    ca39:	0f b6 11             	movzbl (%ecx),%edx
    ca3c:	8b 45 08             	mov    0x8(%ebp),%eax
    ca3f:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ca41:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ca45:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ca48:	01 45 08             	add    %eax,0x8(%ebp)
    ca4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ca4e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ca51:	75 a8                	jne    c9fb <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ca53:	e9 cf 02 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ca58:	8b 45 14             	mov    0x14(%ebp),%eax
    ca5b:	8b 00                	mov    (%eax),%eax
    ca5d:	83 f8 02             	cmp    $0x2,%eax
    ca60:	0f 85 9e 00 00 00    	jne    cb04 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    ca66:	8b 45 14             	mov    0x14(%ebp),%eax
    ca69:	8b 40 04             	mov    0x4(%eax),%eax
    ca6c:	83 f8 08             	cmp    $0x8,%eax
    ca6f:	75 1d                	jne    ca8e <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    ca71:	8b 55 0c             	mov    0xc(%ebp),%edx
    ca74:	89 d0                	mov    %edx,%eax
    ca76:	01 c0                	add    %eax,%eax
    ca78:	01 d0                	add    %edx,%eax
    ca7a:	50                   	push   %eax
    ca7b:	ff 75 10             	pushl  0x10(%ebp)
    ca7e:	ff 75 08             	pushl  0x8(%ebp)
    ca81:	e8 d0 7f ff ff       	call   4a56 <lodepng_memcpy>
    ca86:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ca89:	e9 99 02 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ca8e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ca95:	eb 60                	jmp    caf7 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    ca97:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ca9a:	89 d0                	mov    %edx,%eax
    ca9c:	01 c0                	add    %eax,%eax
    ca9e:	01 d0                	add    %edx,%eax
    caa0:	01 c0                	add    %eax,%eax
    caa2:	89 c2                	mov    %eax,%edx
    caa4:	8b 45 10             	mov    0x10(%ebp),%eax
    caa7:	01 d0                	add    %edx,%eax
    caa9:	0f b6 10             	movzbl (%eax),%edx
    caac:	8b 45 08             	mov    0x8(%ebp),%eax
    caaf:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    cab1:	8b 45 08             	mov    0x8(%ebp),%eax
    cab4:	8d 48 01             	lea    0x1(%eax),%ecx
    cab7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    caba:	89 d0                	mov    %edx,%eax
    cabc:	01 c0                	add    %eax,%eax
    cabe:	01 d0                	add    %edx,%eax
    cac0:	01 c0                	add    %eax,%eax
    cac2:	8d 50 02             	lea    0x2(%eax),%edx
    cac5:	8b 45 10             	mov    0x10(%ebp),%eax
    cac8:	01 d0                	add    %edx,%eax
    caca:	0f b6 00             	movzbl (%eax),%eax
    cacd:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    cacf:	8b 45 08             	mov    0x8(%ebp),%eax
    cad2:	8d 48 02             	lea    0x2(%eax),%ecx
    cad5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    cad8:	89 d0                	mov    %edx,%eax
    cada:	01 c0                	add    %eax,%eax
    cadc:	01 d0                	add    %edx,%eax
    cade:	01 c0                	add    %eax,%eax
    cae0:	8d 50 04             	lea    0x4(%eax),%edx
    cae3:	8b 45 10             	mov    0x10(%ebp),%eax
    cae6:	01 d0                	add    %edx,%eax
    cae8:	0f b6 00             	movzbl (%eax),%eax
    caeb:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    caed:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    caf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    caf4:	01 45 08             	add    %eax,0x8(%ebp)
    caf7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cafa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cafd:	75 98                	jne    ca97 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    caff:	e9 23 02 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    cb04:	8b 45 14             	mov    0x14(%ebp),%eax
    cb07:	8b 00                	mov    (%eax),%eax
    cb09:	83 f8 03             	cmp    $0x3,%eax
    cb0c:	0f 85 b4 00 00 00    	jne    cbc6 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    cb12:	8b 45 14             	mov    0x14(%ebp),%eax
    cb15:	8b 40 04             	mov    0x4(%eax),%eax
    cb18:	83 f8 08             	cmp    $0x8,%eax
    cb1b:	75 4d                	jne    cb6a <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cb1d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    cb24:	eb 37                	jmp    cb5d <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    cb26:	8b 55 f8             	mov    -0x8(%ebp),%edx
    cb29:	8b 45 10             	mov    0x10(%ebp),%eax
    cb2c:	01 d0                	add    %edx,%eax
    cb2e:	0f b6 00             	movzbl (%eax),%eax
    cb31:	0f b6 c0             	movzbl %al,%eax
    cb34:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    cb37:	8b 45 14             	mov    0x14(%ebp),%eax
    cb3a:	8b 40 08             	mov    0x8(%eax),%eax
    cb3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    cb40:	c1 e2 02             	shl    $0x2,%edx
    cb43:	01 d0                	add    %edx,%eax
    cb45:	6a 03                	push   $0x3
    cb47:	50                   	push   %eax
    cb48:	ff 75 08             	pushl  0x8(%ebp)
    cb4b:	e8 06 7f ff ff       	call   4a56 <lodepng_memcpy>
    cb50:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cb53:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    cb57:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb5a:	01 45 08             	add    %eax,0x8(%ebp)
    cb5d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cb60:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cb63:	75 c1                	jne    cb26 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    cb65:	e9 bd 01 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    cb6a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cb71:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    cb78:	eb 3f                	jmp    cbb9 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    cb7a:	8b 45 14             	mov    0x14(%ebp),%eax
    cb7d:	8b 40 04             	mov    0x4(%eax),%eax
    cb80:	50                   	push   %eax
    cb81:	ff 75 10             	pushl  0x10(%ebp)
    cb84:	8d 45 dc             	lea    -0x24(%ebp),%eax
    cb87:	50                   	push   %eax
    cb88:	e8 2e cd ff ff       	call   98bb <readBitsFromReversedStream>
    cb8d:	83 c4 0c             	add    $0xc,%esp
    cb90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    cb93:	8b 45 14             	mov    0x14(%ebp),%eax
    cb96:	8b 40 08             	mov    0x8(%eax),%eax
    cb99:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    cb9c:	c1 e2 02             	shl    $0x2,%edx
    cb9f:	01 d0                	add    %edx,%eax
    cba1:	6a 03                	push   $0x3
    cba3:	50                   	push   %eax
    cba4:	ff 75 08             	pushl  0x8(%ebp)
    cba7:	e8 aa 7e ff ff       	call   4a56 <lodepng_memcpy>
    cbac:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cbaf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    cbb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cbb6:	01 45 08             	add    %eax,0x8(%ebp)
    cbb9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cbbc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cbbf:	75 b9                	jne    cb7a <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    cbc1:	e9 61 01 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    cbc6:	8b 45 14             	mov    0x14(%ebp),%eax
    cbc9:	8b 00                	mov    (%eax),%eax
    cbcb:	83 f8 04             	cmp    $0x4,%eax
    cbce:	0f 85 a0 00 00 00    	jne    cc74 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    cbd4:	8b 45 14             	mov    0x14(%ebp),%eax
    cbd7:	8b 40 04             	mov    0x4(%eax),%eax
    cbda:	83 f8 08             	cmp    $0x8,%eax
    cbdd:	75 4a                	jne    cc29 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cbdf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    cbe6:	eb 34                	jmp    cc1c <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    cbe8:	8b 45 08             	mov    0x8(%ebp),%eax
    cbeb:	83 c0 01             	add    $0x1,%eax
    cbee:	8b 55 08             	mov    0x8(%ebp),%edx
    cbf1:	83 c2 02             	add    $0x2,%edx
    cbf4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    cbf7:	01 c9                	add    %ecx,%ecx
    cbf9:	89 cb                	mov    %ecx,%ebx
    cbfb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    cbfe:	01 d9                	add    %ebx,%ecx
    cc00:	0f b6 09             	movzbl (%ecx),%ecx
    cc03:	88 0a                	mov    %cl,(%edx)
    cc05:	0f b6 12             	movzbl (%edx),%edx
    cc08:	88 10                	mov    %dl,(%eax)
    cc0a:	0f b6 10             	movzbl (%eax),%edx
    cc0d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc10:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cc12:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    cc16:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc19:	01 45 08             	add    %eax,0x8(%ebp)
    cc1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cc1f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cc22:	75 c4                	jne    cbe8 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    cc24:	e9 fe 00 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cc29:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    cc30:	eb 35                	jmp    cc67 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    cc32:	8b 45 08             	mov    0x8(%ebp),%eax
    cc35:	83 c0 01             	add    $0x1,%eax
    cc38:	8b 55 08             	mov    0x8(%ebp),%edx
    cc3b:	83 c2 02             	add    $0x2,%edx
    cc3e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    cc41:	c1 e1 02             	shl    $0x2,%ecx
    cc44:	89 cb                	mov    %ecx,%ebx
    cc46:	8b 4d 10             	mov    0x10(%ebp),%ecx
    cc49:	01 d9                	add    %ebx,%ecx
    cc4b:	0f b6 09             	movzbl (%ecx),%ecx
    cc4e:	88 0a                	mov    %cl,(%edx)
    cc50:	0f b6 12             	movzbl (%edx),%edx
    cc53:	88 10                	mov    %dl,(%eax)
    cc55:	0f b6 10             	movzbl (%eax),%edx
    cc58:	8b 45 08             	mov    0x8(%ebp),%eax
    cc5b:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cc5d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    cc61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc64:	01 45 08             	add    %eax,0x8(%ebp)
    cc67:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cc6a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cc6d:	75 c3                	jne    cc32 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    cc6f:	e9 b3 00 00 00       	jmp    cd27 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    cc74:	8b 45 14             	mov    0x14(%ebp),%eax
    cc77:	8b 00                	mov    (%eax),%eax
    cc79:	83 f8 06             	cmp    $0x6,%eax
    cc7c:	0f 85 a5 00 00 00    	jne    cd27 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    cc82:	8b 45 14             	mov    0x14(%ebp),%eax
    cc85:	8b 40 04             	mov    0x4(%eax),%eax
    cc88:	83 f8 08             	cmp    $0x8,%eax
    cc8b:	75 38                	jne    ccc5 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cc8d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    cc94:	eb 25                	jmp    ccbb <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    cc96:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cc99:	c1 e0 02             	shl    $0x2,%eax
    cc9c:	89 c2                	mov    %eax,%edx
    cc9e:	8b 45 10             	mov    0x10(%ebp),%eax
    cca1:	01 d0                	add    %edx,%eax
    cca3:	6a 03                	push   $0x3
    cca5:	50                   	push   %eax
    cca6:	ff 75 08             	pushl  0x8(%ebp)
    cca9:	e8 a8 7d ff ff       	call   4a56 <lodepng_memcpy>
    ccae:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ccb1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ccb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ccb8:	01 45 08             	add    %eax,0x8(%ebp)
    ccbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ccbe:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ccc1:	75 d3                	jne    cc96 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ccc3:	eb 62                	jmp    cd27 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ccc5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    cccc:	eb 51                	jmp    cd1f <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    ccce:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ccd1:	c1 e0 03             	shl    $0x3,%eax
    ccd4:	89 c2                	mov    %eax,%edx
    ccd6:	8b 45 10             	mov    0x10(%ebp),%eax
    ccd9:	01 d0                	add    %edx,%eax
    ccdb:	0f b6 10             	movzbl (%eax),%edx
    ccde:	8b 45 08             	mov    0x8(%ebp),%eax
    cce1:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    cce3:	8b 45 08             	mov    0x8(%ebp),%eax
    cce6:	8d 50 01             	lea    0x1(%eax),%edx
    cce9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ccec:	c1 e0 03             	shl    $0x3,%eax
    ccef:	8d 48 02             	lea    0x2(%eax),%ecx
    ccf2:	8b 45 10             	mov    0x10(%ebp),%eax
    ccf5:	01 c8                	add    %ecx,%eax
    ccf7:	0f b6 00             	movzbl (%eax),%eax
    ccfa:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    ccfc:	8b 45 08             	mov    0x8(%ebp),%eax
    ccff:	8d 50 02             	lea    0x2(%eax),%edx
    cd02:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cd05:	c1 e0 03             	shl    $0x3,%eax
    cd08:	8d 48 04             	lea    0x4(%eax),%ecx
    cd0b:	8b 45 10             	mov    0x10(%ebp),%eax
    cd0e:	01 c8                	add    %ecx,%eax
    cd10:	0f b6 00             	movzbl (%eax),%eax
    cd13:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    cd15:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    cd19:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cd1c:	01 45 08             	add    %eax,0x8(%ebp)
    cd1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cd22:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cd25:	75 a7                	jne    ccce <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    cd27:	90                   	nop
    cd28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    cd2b:	c9                   	leave  
    cd2c:	c3                   	ret    

0000cd2d <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    cd2d:	55                   	push   %ebp
    cd2e:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    cd30:	8b 45 20             	mov    0x20(%ebp),%eax
    cd33:	8b 00                	mov    (%eax),%eax
    cd35:	85 c0                	test   %eax,%eax
    cd37:	0f 85 a4 00 00 00    	jne    cde1 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    cd3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cd40:	01 c0                	add    %eax,%eax
    cd42:	89 c2                	mov    %eax,%edx
    cd44:	8b 45 18             	mov    0x18(%ebp),%eax
    cd47:	01 d0                	add    %edx,%eax
    cd49:	0f b6 00             	movzbl (%eax),%eax
    cd4c:	0f b6 c0             	movzbl %al,%eax
    cd4f:	c1 e0 08             	shl    $0x8,%eax
    cd52:	89 c2                	mov    %eax,%edx
    cd54:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cd57:	01 c0                	add    %eax,%eax
    cd59:	8d 48 01             	lea    0x1(%eax),%ecx
    cd5c:	8b 45 18             	mov    0x18(%ebp),%eax
    cd5f:	01 c8                	add    %ecx,%eax
    cd61:	0f b6 00             	movzbl (%eax),%eax
    cd64:	0f b6 c0             	movzbl %al,%eax
    cd67:	01 c2                	add    %eax,%edx
    cd69:	8b 45 10             	mov    0x10(%ebp),%eax
    cd6c:	66 89 10             	mov    %dx,(%eax)
    cd6f:	8b 45 10             	mov    0x10(%ebp),%eax
    cd72:	0f b7 10             	movzwl (%eax),%edx
    cd75:	8b 45 0c             	mov    0xc(%ebp),%eax
    cd78:	66 89 10             	mov    %dx,(%eax)
    cd7b:	8b 45 0c             	mov    0xc(%ebp),%eax
    cd7e:	0f b7 10             	movzwl (%eax),%edx
    cd81:	8b 45 08             	mov    0x8(%ebp),%eax
    cd84:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    cd87:	8b 45 20             	mov    0x20(%ebp),%eax
    cd8a:	8b 40 10             	mov    0x10(%eax),%eax
    cd8d:	85 c0                	test   %eax,%eax
    cd8f:	74 43                	je     cdd4 <getPixelColorRGBA16+0xa7>
    cd91:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cd94:	01 c0                	add    %eax,%eax
    cd96:	89 c2                	mov    %eax,%edx
    cd98:	8b 45 18             	mov    0x18(%ebp),%eax
    cd9b:	01 d0                	add    %edx,%eax
    cd9d:	0f b6 00             	movzbl (%eax),%eax
    cda0:	0f b6 c0             	movzbl %al,%eax
    cda3:	c1 e0 08             	shl    $0x8,%eax
    cda6:	89 c2                	mov    %eax,%edx
    cda8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cdab:	01 c0                	add    %eax,%eax
    cdad:	8d 48 01             	lea    0x1(%eax),%ecx
    cdb0:	8b 45 18             	mov    0x18(%ebp),%eax
    cdb3:	01 c8                	add    %ecx,%eax
    cdb5:	0f b6 00             	movzbl (%eax),%eax
    cdb8:	0f b6 c0             	movzbl %al,%eax
    cdbb:	01 c2                	add    %eax,%edx
    cdbd:	8b 45 20             	mov    0x20(%ebp),%eax
    cdc0:	8b 40 14             	mov    0x14(%eax),%eax
    cdc3:	39 c2                	cmp    %eax,%edx
    cdc5:	75 0d                	jne    cdd4 <getPixelColorRGBA16+0xa7>
    cdc7:	8b 45 14             	mov    0x14(%ebp),%eax
    cdca:	66 c7 00 00 00       	movw   $0x0,(%eax)
    cdcf:	e9 48 03 00 00       	jmp    d11c <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    cdd4:	8b 45 14             	mov    0x14(%ebp),%eax
    cdd7:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    cddc:	e9 3b 03 00 00       	jmp    d11c <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    cde1:	8b 45 20             	mov    0x20(%ebp),%eax
    cde4:	8b 00                	mov    (%eax),%eax
    cde6:	83 f8 02             	cmp    $0x2,%eax
    cde9:	0f 85 b6 01 00 00    	jne    cfa5 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    cdef:	8b 55 1c             	mov    0x1c(%ebp),%edx
    cdf2:	89 d0                	mov    %edx,%eax
    cdf4:	01 c0                	add    %eax,%eax
    cdf6:	01 d0                	add    %edx,%eax
    cdf8:	01 c0                	add    %eax,%eax
    cdfa:	89 c2                	mov    %eax,%edx
    cdfc:	8b 45 18             	mov    0x18(%ebp),%eax
    cdff:	01 d0                	add    %edx,%eax
    ce01:	0f b6 00             	movzbl (%eax),%eax
    ce04:	0f b6 c0             	movzbl %al,%eax
    ce07:	c1 e0 08             	shl    $0x8,%eax
    ce0a:	89 c1                	mov    %eax,%ecx
    ce0c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ce0f:	89 d0                	mov    %edx,%eax
    ce11:	01 c0                	add    %eax,%eax
    ce13:	01 d0                	add    %edx,%eax
    ce15:	01 c0                	add    %eax,%eax
    ce17:	8d 50 01             	lea    0x1(%eax),%edx
    ce1a:	8b 45 18             	mov    0x18(%ebp),%eax
    ce1d:	01 d0                	add    %edx,%eax
    ce1f:	0f b6 00             	movzbl (%eax),%eax
    ce22:	0f b6 c0             	movzbl %al,%eax
    ce25:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ce28:	8b 45 08             	mov    0x8(%ebp),%eax
    ce2b:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    ce2e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ce31:	89 d0                	mov    %edx,%eax
    ce33:	01 c0                	add    %eax,%eax
    ce35:	01 d0                	add    %edx,%eax
    ce37:	01 c0                	add    %eax,%eax
    ce39:	8d 50 02             	lea    0x2(%eax),%edx
    ce3c:	8b 45 18             	mov    0x18(%ebp),%eax
    ce3f:	01 d0                	add    %edx,%eax
    ce41:	0f b6 00             	movzbl (%eax),%eax
    ce44:	0f b6 c0             	movzbl %al,%eax
    ce47:	c1 e0 08             	shl    $0x8,%eax
    ce4a:	89 c1                	mov    %eax,%ecx
    ce4c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ce4f:	89 d0                	mov    %edx,%eax
    ce51:	01 c0                	add    %eax,%eax
    ce53:	01 d0                	add    %edx,%eax
    ce55:	01 c0                	add    %eax,%eax
    ce57:	8d 50 03             	lea    0x3(%eax),%edx
    ce5a:	8b 45 18             	mov    0x18(%ebp),%eax
    ce5d:	01 d0                	add    %edx,%eax
    ce5f:	0f b6 00             	movzbl (%eax),%eax
    ce62:	0f b6 c0             	movzbl %al,%eax
    ce65:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ce68:	8b 45 0c             	mov    0xc(%ebp),%eax
    ce6b:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    ce6e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ce71:	89 d0                	mov    %edx,%eax
    ce73:	01 c0                	add    %eax,%eax
    ce75:	01 d0                	add    %edx,%eax
    ce77:	01 c0                	add    %eax,%eax
    ce79:	8d 50 04             	lea    0x4(%eax),%edx
    ce7c:	8b 45 18             	mov    0x18(%ebp),%eax
    ce7f:	01 d0                	add    %edx,%eax
    ce81:	0f b6 00             	movzbl (%eax),%eax
    ce84:	0f b6 c0             	movzbl %al,%eax
    ce87:	c1 e0 08             	shl    $0x8,%eax
    ce8a:	89 c1                	mov    %eax,%ecx
    ce8c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ce8f:	89 d0                	mov    %edx,%eax
    ce91:	01 c0                	add    %eax,%eax
    ce93:	01 d0                	add    %edx,%eax
    ce95:	01 c0                	add    %eax,%eax
    ce97:	8d 50 05             	lea    0x5(%eax),%edx
    ce9a:	8b 45 18             	mov    0x18(%ebp),%eax
    ce9d:	01 d0                	add    %edx,%eax
    ce9f:	0f b6 00             	movzbl (%eax),%eax
    cea2:	0f b6 c0             	movzbl %al,%eax
    cea5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    cea8:	8b 45 10             	mov    0x10(%ebp),%eax
    ceab:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    ceae:	8b 45 20             	mov    0x20(%ebp),%eax
    ceb1:	8b 40 10             	mov    0x10(%eax),%eax
    ceb4:	85 c0                	test   %eax,%eax
    ceb6:	0f 84 dc 00 00 00    	je     cf98 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    cebc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    cebf:	89 d0                	mov    %edx,%eax
    cec1:	01 c0                	add    %eax,%eax
    cec3:	01 d0                	add    %edx,%eax
    cec5:	01 c0                	add    %eax,%eax
    cec7:	89 c2                	mov    %eax,%edx
    cec9:	8b 45 18             	mov    0x18(%ebp),%eax
    cecc:	01 d0                	add    %edx,%eax
    cece:	0f b6 00             	movzbl (%eax),%eax
    ced1:	0f b6 c0             	movzbl %al,%eax
    ced4:	c1 e0 08             	shl    $0x8,%eax
    ced7:	89 c1                	mov    %eax,%ecx
    ced9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    cedc:	89 d0                	mov    %edx,%eax
    cede:	01 c0                	add    %eax,%eax
    cee0:	01 d0                	add    %edx,%eax
    cee2:	01 c0                	add    %eax,%eax
    cee4:	8d 50 01             	lea    0x1(%eax),%edx
    cee7:	8b 45 18             	mov    0x18(%ebp),%eax
    ceea:	01 d0                	add    %edx,%eax
    ceec:	0f b6 00             	movzbl (%eax),%eax
    ceef:	0f b6 c0             	movzbl %al,%eax
    cef2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    cef5:	8b 45 20             	mov    0x20(%ebp),%eax
    cef8:	8b 40 14             	mov    0x14(%eax),%eax
    cefb:	39 c2                	cmp    %eax,%edx
    cefd:	0f 85 95 00 00 00    	jne    cf98 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    cf03:	8b 55 1c             	mov    0x1c(%ebp),%edx
    cf06:	89 d0                	mov    %edx,%eax
    cf08:	01 c0                	add    %eax,%eax
    cf0a:	01 d0                	add    %edx,%eax
    cf0c:	01 c0                	add    %eax,%eax
    cf0e:	8d 50 02             	lea    0x2(%eax),%edx
    cf11:	8b 45 18             	mov    0x18(%ebp),%eax
    cf14:	01 d0                	add    %edx,%eax
    cf16:	0f b6 00             	movzbl (%eax),%eax
    cf19:	0f b6 c0             	movzbl %al,%eax
    cf1c:	c1 e0 08             	shl    $0x8,%eax
    cf1f:	89 c1                	mov    %eax,%ecx
    cf21:	8b 55 1c             	mov    0x1c(%ebp),%edx
    cf24:	89 d0                	mov    %edx,%eax
    cf26:	01 c0                	add    %eax,%eax
    cf28:	01 d0                	add    %edx,%eax
    cf2a:	01 c0                	add    %eax,%eax
    cf2c:	8d 50 03             	lea    0x3(%eax),%edx
    cf2f:	8b 45 18             	mov    0x18(%ebp),%eax
    cf32:	01 d0                	add    %edx,%eax
    cf34:	0f b6 00             	movzbl (%eax),%eax
    cf37:	0f b6 c0             	movzbl %al,%eax
    cf3a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    cf3d:	8b 45 20             	mov    0x20(%ebp),%eax
    cf40:	8b 40 18             	mov    0x18(%eax),%eax
    cf43:	39 c2                	cmp    %eax,%edx
    cf45:	75 51                	jne    cf98 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    cf47:	8b 55 1c             	mov    0x1c(%ebp),%edx
    cf4a:	89 d0                	mov    %edx,%eax
    cf4c:	01 c0                	add    %eax,%eax
    cf4e:	01 d0                	add    %edx,%eax
    cf50:	01 c0                	add    %eax,%eax
    cf52:	8d 50 04             	lea    0x4(%eax),%edx
    cf55:	8b 45 18             	mov    0x18(%ebp),%eax
    cf58:	01 d0                	add    %edx,%eax
    cf5a:	0f b6 00             	movzbl (%eax),%eax
    cf5d:	0f b6 c0             	movzbl %al,%eax
    cf60:	c1 e0 08             	shl    $0x8,%eax
    cf63:	89 c1                	mov    %eax,%ecx
    cf65:	8b 55 1c             	mov    0x1c(%ebp),%edx
    cf68:	89 d0                	mov    %edx,%eax
    cf6a:	01 c0                	add    %eax,%eax
    cf6c:	01 d0                	add    %edx,%eax
    cf6e:	01 c0                	add    %eax,%eax
    cf70:	8d 50 05             	lea    0x5(%eax),%edx
    cf73:	8b 45 18             	mov    0x18(%ebp),%eax
    cf76:	01 d0                	add    %edx,%eax
    cf78:	0f b6 00             	movzbl (%eax),%eax
    cf7b:	0f b6 c0             	movzbl %al,%eax
    cf7e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    cf81:	8b 45 20             	mov    0x20(%ebp),%eax
    cf84:	8b 40 1c             	mov    0x1c(%eax),%eax
    cf87:	39 c2                	cmp    %eax,%edx
    cf89:	75 0d                	jne    cf98 <getPixelColorRGBA16+0x26b>
    cf8b:	8b 45 14             	mov    0x14(%ebp),%eax
    cf8e:	66 c7 00 00 00       	movw   $0x0,(%eax)
    cf93:	e9 84 01 00 00       	jmp    d11c <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    cf98:	8b 45 14             	mov    0x14(%ebp),%eax
    cf9b:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    cfa0:	e9 77 01 00 00       	jmp    d11c <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    cfa5:	8b 45 20             	mov    0x20(%ebp),%eax
    cfa8:	8b 00                	mov    (%eax),%eax
    cfaa:	83 f8 04             	cmp    $0x4,%eax
    cfad:	0f 85 86 00 00 00    	jne    d039 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    cfb3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cfb6:	c1 e0 02             	shl    $0x2,%eax
    cfb9:	89 c2                	mov    %eax,%edx
    cfbb:	8b 45 18             	mov    0x18(%ebp),%eax
    cfbe:	01 d0                	add    %edx,%eax
    cfc0:	0f b6 00             	movzbl (%eax),%eax
    cfc3:	0f b6 c0             	movzbl %al,%eax
    cfc6:	c1 e0 08             	shl    $0x8,%eax
    cfc9:	89 c2                	mov    %eax,%edx
    cfcb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cfce:	c1 e0 02             	shl    $0x2,%eax
    cfd1:	8d 48 01             	lea    0x1(%eax),%ecx
    cfd4:	8b 45 18             	mov    0x18(%ebp),%eax
    cfd7:	01 c8                	add    %ecx,%eax
    cfd9:	0f b6 00             	movzbl (%eax),%eax
    cfdc:	0f b6 c0             	movzbl %al,%eax
    cfdf:	01 c2                	add    %eax,%edx
    cfe1:	8b 45 10             	mov    0x10(%ebp),%eax
    cfe4:	66 89 10             	mov    %dx,(%eax)
    cfe7:	8b 45 10             	mov    0x10(%ebp),%eax
    cfea:	0f b7 10             	movzwl (%eax),%edx
    cfed:	8b 45 0c             	mov    0xc(%ebp),%eax
    cff0:	66 89 10             	mov    %dx,(%eax)
    cff3:	8b 45 0c             	mov    0xc(%ebp),%eax
    cff6:	0f b7 10             	movzwl (%eax),%edx
    cff9:	8b 45 08             	mov    0x8(%ebp),%eax
    cffc:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    cfff:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d002:	c1 e0 02             	shl    $0x2,%eax
    d005:	8d 50 02             	lea    0x2(%eax),%edx
    d008:	8b 45 18             	mov    0x18(%ebp),%eax
    d00b:	01 d0                	add    %edx,%eax
    d00d:	0f b6 00             	movzbl (%eax),%eax
    d010:	0f b6 c0             	movzbl %al,%eax
    d013:	c1 e0 08             	shl    $0x8,%eax
    d016:	89 c2                	mov    %eax,%edx
    d018:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d01b:	c1 e0 02             	shl    $0x2,%eax
    d01e:	8d 48 03             	lea    0x3(%eax),%ecx
    d021:	8b 45 18             	mov    0x18(%ebp),%eax
    d024:	01 c8                	add    %ecx,%eax
    d026:	0f b6 00             	movzbl (%eax),%eax
    d029:	0f b6 c0             	movzbl %al,%eax
    d02c:	01 c2                	add    %eax,%edx
    d02e:	8b 45 14             	mov    0x14(%ebp),%eax
    d031:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    d034:	e9 e3 00 00 00       	jmp    d11c <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    d039:	8b 45 20             	mov    0x20(%ebp),%eax
    d03c:	8b 00                	mov    (%eax),%eax
    d03e:	83 f8 06             	cmp    $0x6,%eax
    d041:	0f 85 d5 00 00 00    	jne    d11c <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    d047:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d04a:	c1 e0 03             	shl    $0x3,%eax
    d04d:	89 c2                	mov    %eax,%edx
    d04f:	8b 45 18             	mov    0x18(%ebp),%eax
    d052:	01 d0                	add    %edx,%eax
    d054:	0f b6 00             	movzbl (%eax),%eax
    d057:	0f b6 c0             	movzbl %al,%eax
    d05a:	c1 e0 08             	shl    $0x8,%eax
    d05d:	89 c2                	mov    %eax,%edx
    d05f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d062:	c1 e0 03             	shl    $0x3,%eax
    d065:	8d 48 01             	lea    0x1(%eax),%ecx
    d068:	8b 45 18             	mov    0x18(%ebp),%eax
    d06b:	01 c8                	add    %ecx,%eax
    d06d:	0f b6 00             	movzbl (%eax),%eax
    d070:	0f b6 c0             	movzbl %al,%eax
    d073:	01 c2                	add    %eax,%edx
    d075:	8b 45 08             	mov    0x8(%ebp),%eax
    d078:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    d07b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d07e:	c1 e0 03             	shl    $0x3,%eax
    d081:	8d 50 02             	lea    0x2(%eax),%edx
    d084:	8b 45 18             	mov    0x18(%ebp),%eax
    d087:	01 d0                	add    %edx,%eax
    d089:	0f b6 00             	movzbl (%eax),%eax
    d08c:	0f b6 c0             	movzbl %al,%eax
    d08f:	c1 e0 08             	shl    $0x8,%eax
    d092:	89 c2                	mov    %eax,%edx
    d094:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d097:	c1 e0 03             	shl    $0x3,%eax
    d09a:	8d 48 03             	lea    0x3(%eax),%ecx
    d09d:	8b 45 18             	mov    0x18(%ebp),%eax
    d0a0:	01 c8                	add    %ecx,%eax
    d0a2:	0f b6 00             	movzbl (%eax),%eax
    d0a5:	0f b6 c0             	movzbl %al,%eax
    d0a8:	01 c2                	add    %eax,%edx
    d0aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0ad:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    d0b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d0b3:	c1 e0 03             	shl    $0x3,%eax
    d0b6:	8d 50 04             	lea    0x4(%eax),%edx
    d0b9:	8b 45 18             	mov    0x18(%ebp),%eax
    d0bc:	01 d0                	add    %edx,%eax
    d0be:	0f b6 00             	movzbl (%eax),%eax
    d0c1:	0f b6 c0             	movzbl %al,%eax
    d0c4:	c1 e0 08             	shl    $0x8,%eax
    d0c7:	89 c2                	mov    %eax,%edx
    d0c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d0cc:	c1 e0 03             	shl    $0x3,%eax
    d0cf:	8d 48 05             	lea    0x5(%eax),%ecx
    d0d2:	8b 45 18             	mov    0x18(%ebp),%eax
    d0d5:	01 c8                	add    %ecx,%eax
    d0d7:	0f b6 00             	movzbl (%eax),%eax
    d0da:	0f b6 c0             	movzbl %al,%eax
    d0dd:	01 c2                	add    %eax,%edx
    d0df:	8b 45 10             	mov    0x10(%ebp),%eax
    d0e2:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    d0e5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d0e8:	c1 e0 03             	shl    $0x3,%eax
    d0eb:	8d 50 06             	lea    0x6(%eax),%edx
    d0ee:	8b 45 18             	mov    0x18(%ebp),%eax
    d0f1:	01 d0                	add    %edx,%eax
    d0f3:	0f b6 00             	movzbl (%eax),%eax
    d0f6:	0f b6 c0             	movzbl %al,%eax
    d0f9:	c1 e0 08             	shl    $0x8,%eax
    d0fc:	89 c2                	mov    %eax,%edx
    d0fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d101:	c1 e0 03             	shl    $0x3,%eax
    d104:	8d 48 07             	lea    0x7(%eax),%ecx
    d107:	8b 45 18             	mov    0x18(%ebp),%eax
    d10a:	01 c8                	add    %ecx,%eax
    d10c:	0f b6 00             	movzbl (%eax),%eax
    d10f:	0f b6 c0             	movzbl %al,%eax
    d112:	01 c2                	add    %eax,%edx
    d114:	8b 45 14             	mov    0x14(%ebp),%eax
    d117:	66 89 10             	mov    %dx,(%eax)
  }
}
    d11a:	eb 00                	jmp    d11c <getPixelColorRGBA16+0x3ef>
    d11c:	90                   	nop
    d11d:	5d                   	pop    %ebp
    d11e:	c3                   	ret    

0000d11f <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    d11f:	55                   	push   %ebp
    d120:	89 e5                	mov    %esp,%ebp
    d122:	56                   	push   %esi
    d123:	53                   	push   %ebx
    d124:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    d127:	8b 55 18             	mov    0x18(%ebp),%edx
    d12a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d12d:	0f af c2             	imul   %edx,%eax
    d130:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    d133:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    d13a:	8b 45 14             	mov    0x14(%ebp),%eax
    d13d:	8b 00                	mov    (%eax),%eax
    d13f:	83 f8 03             	cmp    $0x3,%eax
    d142:	75 14                	jne    d158 <lodepng_convert+0x39>
    d144:	8b 45 14             	mov    0x14(%ebp),%eax
    d147:	8b 40 08             	mov    0x8(%eax),%eax
    d14a:	85 c0                	test   %eax,%eax
    d14c:	75 0a                	jne    d158 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    d14e:	b8 6b 00 00 00       	mov    $0x6b,%eax
    d153:	e9 19 03 00 00       	jmp    d471 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    d158:	ff 75 14             	pushl  0x14(%ebp)
    d15b:	ff 75 10             	pushl  0x10(%ebp)
    d15e:	e8 b7 d1 ff ff       	call   a31a <lodepng_color_mode_equal>
    d163:	83 c4 08             	add    $0x8,%esp
    d166:	85 c0                	test   %eax,%eax
    d168:	74 2f                	je     d199 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    d16a:	ff 75 14             	pushl  0x14(%ebp)
    d16d:	ff 75 1c             	pushl  0x1c(%ebp)
    d170:	ff 75 18             	pushl  0x18(%ebp)
    d173:	e8 fb d4 ff ff       	call   a673 <lodepng_get_raw_size>
    d178:	83 c4 0c             	add    $0xc,%esp
    d17b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    d17e:	ff 75 dc             	pushl  -0x24(%ebp)
    d181:	ff 75 0c             	pushl  0xc(%ebp)
    d184:	ff 75 08             	pushl  0x8(%ebp)
    d187:	e8 ca 78 ff ff       	call   4a56 <lodepng_memcpy>
    d18c:	83 c4 0c             	add    $0xc,%esp
    return 0;
    d18f:	b8 00 00 00 00       	mov    $0x0,%eax
    d194:	e9 d8 02 00 00       	jmp    d471 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    d199:	8b 45 10             	mov    0x10(%ebp),%eax
    d19c:	8b 00                	mov    (%eax),%eax
    d19e:	83 f8 03             	cmp    $0x3,%eax
    d1a1:	0f 85 16 01 00 00    	jne    d2bd <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    d1a7:	8b 45 10             	mov    0x10(%ebp),%eax
    d1aa:	8b 40 0c             	mov    0xc(%eax),%eax
    d1ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    d1b0:	8b 45 10             	mov    0x10(%ebp),%eax
    d1b3:	8b 40 08             	mov    0x8(%eax),%eax
    d1b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    d1b9:	8b 45 10             	mov    0x10(%ebp),%eax
    d1bc:	8b 40 04             	mov    0x4(%eax),%eax
    d1bf:	ba 01 00 00 00       	mov    $0x1,%edx
    d1c4:	89 c1                	mov    %eax,%ecx
    d1c6:	d3 e2                	shl    %cl,%edx
    d1c8:	89 d0                	mov    %edx,%eax
    d1ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    d1cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d1d1:	75 5b                	jne    d22e <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    d1d3:	8b 45 14             	mov    0x14(%ebp),%eax
    d1d6:	8b 40 0c             	mov    0xc(%eax),%eax
    d1d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    d1dc:	8b 45 14             	mov    0x14(%ebp),%eax
    d1df:	8b 40 08             	mov    0x8(%eax),%eax
    d1e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    d1e5:	8b 45 14             	mov    0x14(%ebp),%eax
    d1e8:	8b 00                	mov    (%eax),%eax
    d1ea:	83 f8 03             	cmp    $0x3,%eax
    d1ed:	75 3f                	jne    d22e <lodepng_convert+0x10f>
    d1ef:	8b 45 14             	mov    0x14(%ebp),%eax
    d1f2:	8b 50 04             	mov    0x4(%eax),%edx
    d1f5:	8b 45 10             	mov    0x10(%ebp),%eax
    d1f8:	8b 40 04             	mov    0x4(%eax),%eax
    d1fb:	39 c2                	cmp    %eax,%edx
    d1fd:	75 2f                	jne    d22e <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    d1ff:	ff 75 14             	pushl  0x14(%ebp)
    d202:	ff 75 1c             	pushl  0x1c(%ebp)
    d205:	ff 75 18             	pushl  0x18(%ebp)
    d208:	e8 66 d4 ff ff       	call   a673 <lodepng_get_raw_size>
    d20d:	83 c4 0c             	add    $0xc,%esp
    d210:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    d213:	ff 75 d8             	pushl  -0x28(%ebp)
    d216:	ff 75 0c             	pushl  0xc(%ebp)
    d219:	ff 75 08             	pushl  0x8(%ebp)
    d21c:	e8 35 78 ff ff       	call   4a56 <lodepng_memcpy>
    d221:	83 c4 0c             	add    $0xc,%esp
        return 0;
    d224:	b8 00 00 00 00       	mov    $0x0,%eax
    d229:	e9 43 02 00 00       	jmp    d471 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    d22e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    d231:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d234:	7d 06                	jge    d23c <lodepng_convert+0x11d>
    d236:	8b 45 ec             	mov    -0x14(%ebp),%eax
    d239:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    d23c:	8d 45 90             	lea    -0x70(%ebp),%eax
    d23f:	50                   	push   %eax
    d240:	e8 5f e1 ff ff       	call   b3a4 <color_tree_init>
    d245:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    d248:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d24f:	eb 61                	jmp    d2b2 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    d251:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d254:	c1 e0 02             	shl    $0x2,%eax
    d257:	89 c2                	mov    %eax,%edx
    d259:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d25c:	01 d0                	add    %edx,%eax
    d25e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    d261:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d264:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d267:	83 c0 03             	add    $0x3,%eax
    d26a:	0f b6 00             	movzbl (%eax),%eax
    d26d:	0f b6 d8             	movzbl %al,%ebx
    d270:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d273:	83 c0 02             	add    $0x2,%eax
    d276:	0f b6 00             	movzbl (%eax),%eax
    d279:	0f b6 c8             	movzbl %al,%ecx
    d27c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d27f:	83 c0 01             	add    $0x1,%eax
    d282:	0f b6 00             	movzbl (%eax),%eax
    d285:	0f b6 d0             	movzbl %al,%edx
    d288:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d28b:	0f b6 00             	movzbl (%eax),%eax
    d28e:	0f b6 c0             	movzbl %al,%eax
    d291:	83 ec 08             	sub    $0x8,%esp
    d294:	56                   	push   %esi
    d295:	53                   	push   %ebx
    d296:	51                   	push   %ecx
    d297:	52                   	push   %edx
    d298:	50                   	push   %eax
    d299:	8d 45 90             	lea    -0x70(%ebp),%eax
    d29c:	50                   	push   %eax
    d29d:	e8 85 e2 ff ff       	call   b527 <color_tree_add>
    d2a2:	83 c4 20             	add    $0x20,%esp
    d2a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    d2a8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d2ac:	75 0e                	jne    d2bc <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    d2ae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d2b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2b5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d2b8:	75 97                	jne    d251 <lodepng_convert+0x132>
    d2ba:	eb 01                	jmp    d2bd <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    d2bc:	90                   	nop
    }
  }

  if(!error) {
    d2bd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d2c1:	0f 85 8e 01 00 00    	jne    d455 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    d2c7:	8b 45 14             	mov    0x14(%ebp),%eax
    d2ca:	8b 40 04             	mov    0x4(%eax),%eax
    d2cd:	83 f8 10             	cmp    $0x10,%eax
    d2d0:	0f 85 99 00 00 00    	jne    d36f <lodepng_convert+0x250>
    d2d6:	8b 45 10             	mov    0x10(%ebp),%eax
    d2d9:	8b 40 04             	mov    0x4(%eax),%eax
    d2dc:	83 f8 10             	cmp    $0x10,%eax
    d2df:	0f 85 8a 00 00 00    	jne    d36f <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    d2e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d2ec:	eb 74                	jmp    d362 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    d2ee:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    d2f4:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    d2fa:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    d300:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    d306:	83 ec 04             	sub    $0x4,%esp
    d309:	ff 75 14             	pushl  0x14(%ebp)
    d30c:	ff 75 f4             	pushl  -0xc(%ebp)
    d30f:	ff 75 0c             	pushl  0xc(%ebp)
    d312:	8d 45 88             	lea    -0x78(%ebp),%eax
    d315:	50                   	push   %eax
    d316:	8d 45 8a             	lea    -0x76(%ebp),%eax
    d319:	50                   	push   %eax
    d31a:	8d 45 8c             	lea    -0x74(%ebp),%eax
    d31d:	50                   	push   %eax
    d31e:	8d 45 8e             	lea    -0x72(%ebp),%eax
    d321:	50                   	push   %eax
    d322:	e8 06 fa ff ff       	call   cd2d <getPixelColorRGBA16>
    d327:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    d32a:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    d32e:	0f b7 d8             	movzwl %ax,%ebx
    d331:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    d335:	0f b7 c8             	movzwl %ax,%ecx
    d338:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    d33c:	0f b7 d0             	movzwl %ax,%edx
    d33f:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    d343:	0f b7 c0             	movzwl %ax,%eax
    d346:	83 ec 04             	sub    $0x4,%esp
    d349:	53                   	push   %ebx
    d34a:	51                   	push   %ecx
    d34b:	52                   	push   %edx
    d34c:	50                   	push   %eax
    d34d:	ff 75 10             	pushl  0x10(%ebp)
    d350:	ff 75 f4             	pushl  -0xc(%ebp)
    d353:	ff 75 08             	pushl  0x8(%ebp)
    d356:	e8 d3 e6 ff ff       	call   ba2e <rgba16ToPixel>
    d35b:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    d35e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d362:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d365:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    d368:	75 84                	jne    d2ee <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    d36a:	e9 e6 00 00 00       	jmp    d455 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    d36f:	8b 45 10             	mov    0x10(%ebp),%eax
    d372:	8b 40 04             	mov    0x4(%eax),%eax
    d375:	83 f8 08             	cmp    $0x8,%eax
    d378:	75 23                	jne    d39d <lodepng_convert+0x27e>
    d37a:	8b 45 10             	mov    0x10(%ebp),%eax
    d37d:	8b 00                	mov    (%eax),%eax
    d37f:	83 f8 06             	cmp    $0x6,%eax
    d382:	75 19                	jne    d39d <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    d384:	ff 75 14             	pushl  0x14(%ebp)
    d387:	ff 75 0c             	pushl  0xc(%ebp)
    d38a:	ff 75 e0             	pushl  -0x20(%ebp)
    d38d:	ff 75 08             	pushl  0x8(%ebp)
    d390:	e8 ae ee ff ff       	call   c243 <getPixelColorsRGBA8>
    d395:	83 c4 10             	add    $0x10,%esp
    d398:	e9 b8 00 00 00       	jmp    d455 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    d39d:	8b 45 10             	mov    0x10(%ebp),%eax
    d3a0:	8b 40 04             	mov    0x4(%eax),%eax
    d3a3:	83 f8 08             	cmp    $0x8,%eax
    d3a6:	75 23                	jne    d3cb <lodepng_convert+0x2ac>
    d3a8:	8b 45 10             	mov    0x10(%ebp),%eax
    d3ab:	8b 00                	mov    (%eax),%eax
    d3ad:	83 f8 02             	cmp    $0x2,%eax
    d3b0:	75 19                	jne    d3cb <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    d3b2:	ff 75 14             	pushl  0x14(%ebp)
    d3b5:	ff 75 0c             	pushl  0xc(%ebp)
    d3b8:	ff 75 e0             	pushl  -0x20(%ebp)
    d3bb:	ff 75 08             	pushl  0x8(%ebp)
    d3be:	e8 50 f5 ff ff       	call   c913 <getPixelColorsRGB8>
    d3c3:	83 c4 10             	add    $0x10,%esp
    d3c6:	e9 8a 00 00 00       	jmp    d455 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    d3cb:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    d3cf:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    d3d3:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    d3d7:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    d3db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d3e2:	eb 66                	jmp    d44a <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    d3e4:	83 ec 04             	sub    $0x4,%esp
    d3e7:	ff 75 14             	pushl  0x14(%ebp)
    d3ea:	ff 75 f4             	pushl  -0xc(%ebp)
    d3ed:	ff 75 0c             	pushl  0xc(%ebp)
    d3f0:	8d 45 84             	lea    -0x7c(%ebp),%eax
    d3f3:	50                   	push   %eax
    d3f4:	8d 45 85             	lea    -0x7b(%ebp),%eax
    d3f7:	50                   	push   %eax
    d3f8:	8d 45 86             	lea    -0x7a(%ebp),%eax
    d3fb:	50                   	push   %eax
    d3fc:	8d 45 87             	lea    -0x79(%ebp),%eax
    d3ff:	50                   	push   %eax
    d400:	e8 71 e8 ff ff       	call   bc76 <getPixelColorRGBA8>
    d405:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    d408:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    d40c:	0f b6 d8             	movzbl %al,%ebx
    d40f:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    d413:	0f b6 c8             	movzbl %al,%ecx
    d416:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    d41a:	0f b6 d0             	movzbl %al,%edx
    d41d:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    d421:	0f b6 c0             	movzbl %al,%eax
    d424:	53                   	push   %ebx
    d425:	51                   	push   %ecx
    d426:	52                   	push   %edx
    d427:	50                   	push   %eax
    d428:	8d 45 90             	lea    -0x70(%ebp),%eax
    d42b:	50                   	push   %eax
    d42c:	ff 75 10             	pushl  0x10(%ebp)
    d42f:	ff 75 f4             	pushl  -0xc(%ebp)
    d432:	ff 75 08             	pushl  0x8(%ebp)
    d435:	e8 e5 e1 ff ff       	call   b61f <rgba8ToPixel>
    d43a:	83 c4 20             	add    $0x20,%esp
    d43d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    d440:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d444:	75 0e                	jne    d454 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    d446:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d44a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d44d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    d450:	75 92                	jne    d3e4 <lodepng_convert+0x2c5>
    d452:	eb 01                	jmp    d455 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    d454:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    d455:	8b 45 10             	mov    0x10(%ebp),%eax
    d458:	8b 00                	mov    (%eax),%eax
    d45a:	83 f8 03             	cmp    $0x3,%eax
    d45d:	75 0f                	jne    d46e <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    d45f:	83 ec 0c             	sub    $0xc,%esp
    d462:	8d 45 90             	lea    -0x70(%ebp),%eax
    d465:	50                   	push   %eax
    d466:	e8 59 df ff ff       	call   b3c4 <color_tree_cleanup>
    d46b:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    d46e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    d471:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d474:	5b                   	pop    %ebx
    d475:	5e                   	pop    %esi
    d476:	5d                   	pop    %ebp
    d477:	c3                   	ret    

0000d478 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    d478:	55                   	push   %ebp
    d479:	89 e5                	mov    %esp,%ebp
    d47b:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    d47e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    d485:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    d48c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    d493:	8b 45 24             	mov    0x24(%ebp),%eax
    d496:	8b 40 04             	mov    0x4(%eax),%eax
    d499:	ba 01 00 00 00       	mov    $0x1,%edx
    d49e:	89 c1                	mov    %eax,%ecx
    d4a0:	d3 e2                	shl    %cl,%edx
    d4a2:	89 d0                	mov    %edx,%eax
    d4a4:	8d 48 ff             	lea    -0x1(%eax),%ecx
    d4a7:	b8 ff ff 00 00       	mov    $0xffff,%eax
    d4ac:	ba 00 00 00 00       	mov    $0x0,%edx
    d4b1:	f7 f1                	div    %ecx
    d4b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    d4b6:	8b 45 20             	mov    0x20(%ebp),%eax
    d4b9:	8b 40 04             	mov    0x4(%eax),%eax
    d4bc:	ba 10 00 00 00       	mov    $0x10,%edx
    d4c1:	29 c2                	sub    %eax,%edx
    d4c3:	89 d0                	mov    %edx,%eax
    d4c5:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    d4c8:	8b 45 24             	mov    0x24(%ebp),%eax
    d4cb:	8b 00                	mov    (%eax),%eax
    d4cd:	85 c0                	test   %eax,%eax
    d4cf:	74 0a                	je     d4db <lodepng_convert_rgb+0x63>
    d4d1:	8b 45 24             	mov    0x24(%ebp),%eax
    d4d4:	8b 00                	mov    (%eax),%eax
    d4d6:	83 f8 04             	cmp    $0x4,%eax
    d4d9:	75 1b                	jne    d4f6 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    d4db:	8b 45 14             	mov    0x14(%ebp),%eax
    d4de:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    d4e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d4e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    d4eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d4ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
    d4f1:	e9 c2 00 00 00       	jmp    d5b8 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    d4f6:	8b 45 24             	mov    0x24(%ebp),%eax
    d4f9:	8b 00                	mov    (%eax),%eax
    d4fb:	83 f8 02             	cmp    $0x2,%eax
    d4fe:	74 0a                	je     d50a <lodepng_convert_rgb+0x92>
    d500:	8b 45 24             	mov    0x24(%ebp),%eax
    d503:	8b 00                	mov    (%eax),%eax
    d505:	83 f8 06             	cmp    $0x6,%eax
    d508:	75 23                	jne    d52d <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    d50a:	8b 45 14             	mov    0x14(%ebp),%eax
    d50d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    d511:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    d514:	8b 45 18             	mov    0x18(%ebp),%eax
    d517:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    d51b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    d51e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d521:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    d525:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d528:	e9 8b 00 00 00       	jmp    d5b8 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    d52d:	8b 45 24             	mov    0x24(%ebp),%eax
    d530:	8b 00                	mov    (%eax),%eax
    d532:	83 f8 03             	cmp    $0x3,%eax
    d535:	75 77                	jne    d5ae <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    d537:	8b 45 24             	mov    0x24(%ebp),%eax
    d53a:	8b 40 0c             	mov    0xc(%eax),%eax
    d53d:	3b 45 14             	cmp    0x14(%ebp),%eax
    d540:	77 0a                	ja     d54c <lodepng_convert_rgb+0xd4>
    d542:	b8 52 00 00 00       	mov    $0x52,%eax
    d547:	e9 cb 01 00 00       	jmp    d717 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    d54c:	8b 45 24             	mov    0x24(%ebp),%eax
    d54f:	8b 40 08             	mov    0x8(%eax),%eax
    d552:	8b 55 14             	mov    0x14(%ebp),%edx
    d555:	c1 e2 02             	shl    $0x2,%edx
    d558:	01 d0                	add    %edx,%eax
    d55a:	0f b6 00             	movzbl (%eax),%eax
    d55d:	0f b6 d0             	movzbl %al,%edx
    d560:	89 d0                	mov    %edx,%eax
    d562:	c1 e0 08             	shl    $0x8,%eax
    d565:	01 d0                	add    %edx,%eax
    d567:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    d56a:	8b 45 24             	mov    0x24(%ebp),%eax
    d56d:	8b 40 08             	mov    0x8(%eax),%eax
    d570:	8b 55 14             	mov    0x14(%ebp),%edx
    d573:	c1 e2 02             	shl    $0x2,%edx
    d576:	83 c2 01             	add    $0x1,%edx
    d579:	01 d0                	add    %edx,%eax
    d57b:	0f b6 00             	movzbl (%eax),%eax
    d57e:	0f b6 d0             	movzbl %al,%edx
    d581:	89 d0                	mov    %edx,%eax
    d583:	c1 e0 08             	shl    $0x8,%eax
    d586:	01 d0                	add    %edx,%eax
    d588:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    d58b:	8b 45 24             	mov    0x24(%ebp),%eax
    d58e:	8b 40 08             	mov    0x8(%eax),%eax
    d591:	8b 55 14             	mov    0x14(%ebp),%edx
    d594:	c1 e2 02             	shl    $0x2,%edx
    d597:	83 c2 02             	add    $0x2,%edx
    d59a:	01 d0                	add    %edx,%eax
    d59c:	0f b6 00             	movzbl (%eax),%eax
    d59f:	0f b6 d0             	movzbl %al,%edx
    d5a2:	89 d0                	mov    %edx,%eax
    d5a4:	c1 e0 08             	shl    $0x8,%eax
    d5a7:	01 d0                	add    %edx,%eax
    d5a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d5ac:	eb 0a                	jmp    d5b8 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    d5ae:	b8 1f 00 00 00       	mov    $0x1f,%eax
    d5b3:	e9 5f 01 00 00       	jmp    d717 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    d5b8:	8b 45 20             	mov    0x20(%ebp),%eax
    d5bb:	8b 00                	mov    (%eax),%eax
    d5bd:	85 c0                	test   %eax,%eax
    d5bf:	74 0a                	je     d5cb <lodepng_convert_rgb+0x153>
    d5c1:	8b 45 20             	mov    0x20(%ebp),%eax
    d5c4:	8b 00                	mov    (%eax),%eax
    d5c6:	83 f8 04             	cmp    $0x4,%eax
    d5c9:	75 14                	jne    d5df <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    d5cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d5ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d5d1:	89 c1                	mov    %eax,%ecx
    d5d3:	d3 ea                	shr    %cl,%edx
    d5d5:	8b 45 08             	mov    0x8(%ebp),%eax
    d5d8:	89 10                	mov    %edx,(%eax)
    d5da:	e9 33 01 00 00       	jmp    d712 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    d5df:	8b 45 20             	mov    0x20(%ebp),%eax
    d5e2:	8b 00                	mov    (%eax),%eax
    d5e4:	83 f8 02             	cmp    $0x2,%eax
    d5e7:	74 0a                	je     d5f3 <lodepng_convert_rgb+0x17b>
    d5e9:	8b 45 20             	mov    0x20(%ebp),%eax
    d5ec:	8b 00                	mov    (%eax),%eax
    d5ee:	83 f8 06             	cmp    $0x6,%eax
    d5f1:	75 32                	jne    d625 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    d5f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d5f6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d5f9:	89 c1                	mov    %eax,%ecx
    d5fb:	d3 ea                	shr    %cl,%edx
    d5fd:	8b 45 08             	mov    0x8(%ebp),%eax
    d600:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    d602:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d605:	8b 55 f8             	mov    -0x8(%ebp),%edx
    d608:	89 c1                	mov    %eax,%ecx
    d60a:	d3 ea                	shr    %cl,%edx
    d60c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d60f:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    d611:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d614:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d617:	89 c1                	mov    %eax,%ecx
    d619:	d3 ea                	shr    %cl,%edx
    d61b:	8b 45 10             	mov    0x10(%ebp),%eax
    d61e:	89 10                	mov    %edx,(%eax)
    d620:	e9 ed 00 00 00       	jmp    d712 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    d625:	8b 45 20             	mov    0x20(%ebp),%eax
    d628:	8b 00                	mov    (%eax),%eax
    d62a:	83 f8 03             	cmp    $0x3,%eax
    d62d:	0f 85 d8 00 00 00    	jne    d70b <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    d633:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d636:	c1 e8 08             	shr    $0x8,%eax
    d639:	89 c2                	mov    %eax,%edx
    d63b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d63e:	0f b6 c0             	movzbl %al,%eax
    d641:	39 c2                	cmp    %eax,%edx
    d643:	75 24                	jne    d669 <lodepng_convert_rgb+0x1f1>
    d645:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d648:	c1 e8 08             	shr    $0x8,%eax
    d64b:	89 c2                	mov    %eax,%edx
    d64d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d650:	0f b6 c0             	movzbl %al,%eax
    d653:	39 c2                	cmp    %eax,%edx
    d655:	75 12                	jne    d669 <lodepng_convert_rgb+0x1f1>
    d657:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d65a:	c1 e8 08             	shr    $0x8,%eax
    d65d:	89 c2                	mov    %eax,%edx
    d65f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d662:	0f b6 c0             	movzbl %al,%eax
    d665:	39 c2                	cmp    %eax,%edx
    d667:	74 0a                	je     d673 <lodepng_convert_rgb+0x1fb>
    d669:	b8 52 00 00 00       	mov    $0x52,%eax
    d66e:	e9 a4 00 00 00       	jmp    d717 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    d673:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d67a:	eb 79                	jmp    d6f5 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    d67c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d67f:	c1 e0 02             	shl    $0x2,%eax
    d682:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    d685:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d688:	c1 e8 08             	shr    $0x8,%eax
    d68b:	89 c1                	mov    %eax,%ecx
    d68d:	8b 45 20             	mov    0x20(%ebp),%eax
    d690:	8b 50 08             	mov    0x8(%eax),%edx
    d693:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d696:	01 d0                	add    %edx,%eax
    d698:	0f b6 00             	movzbl (%eax),%eax
    d69b:	0f b6 c0             	movzbl %al,%eax
    d69e:	39 c1                	cmp    %eax,%ecx
    d6a0:	75 4f                	jne    d6f1 <lodepng_convert_rgb+0x279>
    d6a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d6a5:	c1 e8 08             	shr    $0x8,%eax
    d6a8:	89 c1                	mov    %eax,%ecx
    d6aa:	8b 45 20             	mov    0x20(%ebp),%eax
    d6ad:	8b 40 08             	mov    0x8(%eax),%eax
    d6b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    d6b3:	83 c2 01             	add    $0x1,%edx
    d6b6:	01 d0                	add    %edx,%eax
    d6b8:	0f b6 00             	movzbl (%eax),%eax
    d6bb:	0f b6 c0             	movzbl %al,%eax
    d6be:	39 c1                	cmp    %eax,%ecx
    d6c0:	75 2f                	jne    d6f1 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    d6c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6c5:	c1 e8 08             	shr    $0x8,%eax
    d6c8:	89 c1                	mov    %eax,%ecx
    d6ca:	8b 45 20             	mov    0x20(%ebp),%eax
    d6cd:	8b 40 08             	mov    0x8(%eax),%eax
    d6d0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    d6d3:	83 c2 02             	add    $0x2,%edx
    d6d6:	01 d0                	add    %edx,%eax
    d6d8:	0f b6 00             	movzbl (%eax),%eax
    d6db:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    d6de:	39 c1                	cmp    %eax,%ecx
    d6e0:	75 0f                	jne    d6f1 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    d6e2:	8b 45 08             	mov    0x8(%ebp),%eax
    d6e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d6e8:	89 10                	mov    %edx,(%eax)
        return 0;
    d6ea:	b8 00 00 00 00       	mov    $0x0,%eax
    d6ef:	eb 26                	jmp    d717 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    d6f1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    d6f5:	8b 45 20             	mov    0x20(%ebp),%eax
    d6f8:	8b 40 0c             	mov    0xc(%eax),%eax
    d6fb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    d6fe:	0f 87 78 ff ff ff    	ja     d67c <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    d704:	b8 52 00 00 00       	mov    $0x52,%eax
    d709:	eb 0c                	jmp    d717 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    d70b:	b8 1f 00 00 00       	mov    $0x1f,%eax
    d710:	eb 05                	jmp    d717 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    d712:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d717:	c9                   	leave  
    d718:	c3                   	ret    

0000d719 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    d719:	55                   	push   %ebp
    d71a:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    d71c:	8b 45 08             	mov    0x8(%ebp),%eax
    d71f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    d725:	8b 45 08             	mov    0x8(%ebp),%eax
    d728:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    d72f:	8b 45 08             	mov    0x8(%ebp),%eax
    d732:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    d738:	8b 45 08             	mov    0x8(%ebp),%eax
    d73b:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d73f:	8b 45 08             	mov    0x8(%ebp),%eax
    d742:	66 89 50 0a          	mov    %dx,0xa(%eax)
    d746:	8b 45 08             	mov    0x8(%ebp),%eax
    d749:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d74d:	8b 45 08             	mov    0x8(%ebp),%eax
    d750:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    d754:	8b 45 08             	mov    0x8(%ebp),%eax
    d757:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    d75e:	8b 45 08             	mov    0x8(%ebp),%eax
    d761:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    d768:	8b 45 08             	mov    0x8(%ebp),%eax
    d76b:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    d772:	00 00 00 
  stats->numpixels = 0;
    d775:	8b 45 08             	mov    0x8(%ebp),%eax
    d778:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    d77f:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    d782:	8b 45 08             	mov    0x8(%ebp),%eax
    d785:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    d78c:	00 00 00 
  stats->allow_greyscale = 1;
    d78f:	8b 45 08             	mov    0x8(%ebp),%eax
    d792:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    d799:	00 00 00 
}
    d79c:	90                   	nop
    d79d:	5d                   	pop    %ebp
    d79e:	c3                   	ret    

0000d79f <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    d79f:	55                   	push   %ebp
    d7a0:	89 e5                	mov    %esp,%ebp
    d7a2:	53                   	push   %ebx
    d7a3:	83 ec 04             	sub    $0x4,%esp
    d7a6:	8b 45 08             	mov    0x8(%ebp),%eax
    d7a9:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    d7ac:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    d7b0:	74 06                	je     d7b8 <getValueRequiredBits+0x19>
    d7b2:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    d7b6:	75 07                	jne    d7bf <getValueRequiredBits+0x20>
    d7b8:	b8 01 00 00 00       	mov    $0x1,%eax
    d7bd:	eb 6b                	jmp    d82a <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    d7bf:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    d7c3:	0f b6 d9             	movzbl %cl,%ebx
    d7c6:	89 da                	mov    %ebx,%edx
    d7c8:	89 d0                	mov    %edx,%eax
    d7ca:	c1 e0 04             	shl    $0x4,%eax
    d7cd:	89 c2                	mov    %eax,%edx
    d7cf:	89 d0                	mov    %edx,%eax
    d7d1:	c1 e0 04             	shl    $0x4,%eax
    d7d4:	29 d0                	sub    %edx,%eax
    d7d6:	01 d8                	add    %ebx,%eax
    d7d8:	66 c1 e8 08          	shr    $0x8,%ax
    d7dc:	c0 e8 04             	shr    $0x4,%al
    d7df:	89 c2                	mov    %eax,%edx
    d7e1:	c1 e2 04             	shl    $0x4,%edx
    d7e4:	01 c2                	add    %eax,%edx
    d7e6:	89 c8                	mov    %ecx,%eax
    d7e8:	29 d0                	sub    %edx,%eax
    d7ea:	84 c0                	test   %al,%al
    d7ec:	75 37                	jne    d825 <getValueRequiredBits+0x86>
    d7ee:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    d7f2:	0f b6 d1             	movzbl %cl,%edx
    d7f5:	89 d0                	mov    %edx,%eax
    d7f7:	01 c0                	add    %eax,%eax
    d7f9:	01 d0                	add    %edx,%eax
    d7fb:	c1 e0 06             	shl    $0x6,%eax
    d7fe:	01 d0                	add    %edx,%eax
    d800:	66 c1 e8 08          	shr    $0x8,%ax
    d804:	c0 e8 06             	shr    $0x6,%al
    d807:	ba 55 00 00 00       	mov    $0x55,%edx
    d80c:	0f af c2             	imul   %edx,%eax
    d80f:	29 c1                	sub    %eax,%ecx
    d811:	89 c8                	mov    %ecx,%eax
    d813:	84 c0                	test   %al,%al
    d815:	75 07                	jne    d81e <getValueRequiredBits+0x7f>
    d817:	b8 02 00 00 00       	mov    $0x2,%eax
    d81c:	eb 0c                	jmp    d82a <getValueRequiredBits+0x8b>
    d81e:	b8 04 00 00 00       	mov    $0x4,%eax
    d823:	eb 05                	jmp    d82a <getValueRequiredBits+0x8b>
  return 8;
    d825:	b8 08 00 00 00       	mov    $0x8,%eax
}
    d82a:	83 c4 04             	add    $0x4,%esp
    d82d:	5b                   	pop    %ebx
    d82e:	5d                   	pop    %ebp
    d82f:	c3                   	ret    

0000d830 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    d830:	55                   	push   %ebp
    d831:	89 e5                	mov    %esp,%ebp
    d833:	56                   	push   %esi
    d834:	53                   	push   %ebx
    d835:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    d83b:	8b 55 10             	mov    0x10(%ebp),%edx
    d83e:	8b 45 14             	mov    0x14(%ebp),%eax
    d841:	0f af c2             	imul   %edx,%eax
    d844:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    d847:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    d84e:	ff 75 18             	pushl  0x18(%ebp)
    d851:	e8 0b cd ff ff       	call   a561 <lodepng_is_greyscale_type>
    d856:	83 c4 04             	add    $0x4,%esp
    d859:	85 c0                	test   %eax,%eax
    d85b:	0f 95 c0             	setne  %al
    d85e:	0f b6 c0             	movzbl %al,%eax
    d861:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    d864:	ff 75 18             	pushl  0x18(%ebp)
    d867:	e8 85 cd ff ff       	call   a5f1 <lodepng_can_have_alpha>
    d86c:	83 c4 04             	add    $0x4,%esp
    d86f:	85 c0                	test   %eax,%eax
    d871:	0f 94 c0             	sete   %al
    d874:	0f b6 c0             	movzbl %al,%eax
    d877:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    d87a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    d881:	ff 75 18             	pushl  0x18(%ebp)
    d884:	e8 ab cc ff ff       	call   a534 <lodepng_get_bpp>
    d889:	83 c4 04             	add    $0x4,%esp
    d88c:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    d88f:	8b 45 08             	mov    0x8(%ebp),%eax
    d892:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d898:	83 f8 01             	cmp    $0x1,%eax
    d89b:	75 0d                	jne    d8aa <lodepng_compute_color_stats+0x7a>
    d89d:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    d8a1:	75 07                	jne    d8aa <lodepng_compute_color_stats+0x7a>
    d8a3:	b8 01 00 00 00       	mov    $0x1,%eax
    d8a8:	eb 05                	jmp    d8af <lodepng_compute_color_stats+0x7f>
    d8aa:	b8 00 00 00 00       	mov    $0x0,%eax
    d8af:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    d8b2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    d8b9:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    d8c0:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    d8c4:	77 26                	ja     d8ec <lodepng_compute_color_stats+0xbc>
    d8c6:	8b 45 08             	mov    0x8(%ebp),%eax
    d8c9:	8b 50 14             	mov    0x14(%eax),%edx
    d8cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d8cf:	bb 01 00 00 00       	mov    $0x1,%ebx
    d8d4:	89 c1                	mov    %eax,%ecx
    d8d6:	d3 e3                	shl    %cl,%ebx
    d8d8:	89 d8                	mov    %ebx,%eax
    d8da:	01 d0                	add    %edx,%eax
    d8dc:	ba 01 01 00 00       	mov    $0x101,%edx
    d8e1:	3d 01 01 00 00       	cmp    $0x101,%eax
    d8e6:	0f 47 c2             	cmova  %edx,%eax
    d8e9:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    d8ec:	8b 45 08             	mov    0x8(%ebp),%eax
    d8ef:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    d8f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d8f8:	01 c2                	add    %eax,%edx
    d8fa:	8b 45 08             	mov    0x8(%ebp),%eax
    d8fd:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    d903:	8b 45 08             	mov    0x8(%ebp),%eax
    d906:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d90c:	85 c0                	test   %eax,%eax
    d90e:	75 07                	jne    d917 <lodepng_compute_color_stats+0xe7>
    d910:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    d917:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d91d:	50                   	push   %eax
    d91e:	e8 81 da ff ff       	call   b3a4 <color_tree_init>
    d923:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    d926:	8b 45 08             	mov    0x8(%ebp),%eax
    d929:	8b 40 10             	mov    0x10(%eax),%eax
    d92c:	85 c0                	test   %eax,%eax
    d92e:	74 07                	je     d937 <lodepng_compute_color_stats+0x107>
    d930:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    d937:	8b 45 08             	mov    0x8(%ebp),%eax
    d93a:	8b 00                	mov    (%eax),%eax
    d93c:	85 c0                	test   %eax,%eax
    d93e:	74 07                	je     d947 <lodepng_compute_color_stats+0x117>
    d940:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    d947:	8b 45 08             	mov    0x8(%ebp),%eax
    d94a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d950:	83 f8 10             	cmp    $0x10,%eax
    d953:	75 07                	jne    d95c <lodepng_compute_color_stats+0x12c>
    d955:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    d95c:	8b 45 08             	mov    0x8(%ebp),%eax
    d95f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d965:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d968:	72 07                	jb     d971 <lodepng_compute_color_stats+0x141>
    d96a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    d971:	8b 45 08             	mov    0x8(%ebp),%eax
    d974:	8b 40 14             	mov    0x14(%eax),%eax
    d977:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d97a:	72 07                	jb     d983 <lodepng_compute_color_stats+0x153>
    d97c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    d983:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d987:	0f 85 82 00 00 00    	jne    da0f <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    d98d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d994:	eb 6c                	jmp    da02 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    d996:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d999:	c1 e0 02             	shl    $0x2,%eax
    d99c:	8d 50 10             	lea    0x10(%eax),%edx
    d99f:	8b 45 08             	mov    0x8(%ebp),%eax
    d9a2:	01 d0                	add    %edx,%eax
    d9a4:	83 c0 08             	add    $0x8,%eax
    d9a7:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    d9aa:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d9ad:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d9b0:	83 c0 03             	add    $0x3,%eax
    d9b3:	0f b6 00             	movzbl (%eax),%eax
    d9b6:	0f b6 d8             	movzbl %al,%ebx
    d9b9:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d9bc:	83 c0 02             	add    $0x2,%eax
    d9bf:	0f b6 00             	movzbl (%eax),%eax
    d9c2:	0f b6 c8             	movzbl %al,%ecx
    d9c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d9c8:	83 c0 01             	add    $0x1,%eax
    d9cb:	0f b6 00             	movzbl (%eax),%eax
    d9ce:	0f b6 d0             	movzbl %al,%edx
    d9d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d9d4:	0f b6 00             	movzbl (%eax),%eax
    d9d7:	0f b6 c0             	movzbl %al,%eax
    d9da:	83 ec 08             	sub    $0x8,%esp
    d9dd:	56                   	push   %esi
    d9de:	53                   	push   %ebx
    d9df:	51                   	push   %ecx
    d9e0:	52                   	push   %edx
    d9e1:	50                   	push   %eax
    d9e2:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d9e8:	50                   	push   %eax
    d9e9:	e8 39 db ff ff       	call   b527 <color_tree_add>
    d9ee:	83 c4 20             	add    $0x20,%esp
    d9f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    d9f4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d9f8:	0f 85 22 09 00 00    	jne    e320 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    d9fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da02:	8b 45 08             	mov    0x8(%ebp),%eax
    da05:	8b 50 14             	mov    0x14(%eax),%edx
    da08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da0b:	39 c2                	cmp    %eax,%edx
    da0d:	77 87                	ja     d996 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    da0f:	8b 45 18             	mov    0x18(%ebp),%eax
    da12:	8b 40 04             	mov    0x4(%eax),%eax
    da15:	83 f8 10             	cmp    $0x10,%eax
    da18:	0f 85 1e 01 00 00    	jne    db3c <lodepng_compute_color_stats+0x30c>
    da1e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    da22:	0f 85 14 01 00 00    	jne    db3c <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    da28:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    da2f:	00 00 
    da31:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    da38:	00 00 
    da3a:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    da41:	00 00 
    da43:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    da4a:	00 00 
    for(i = 0; i != numpixels; ++i) {
    da4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    da53:	e9 d8 00 00 00       	jmp    db30 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    da58:	83 ec 04             	sub    $0x4,%esp
    da5b:	ff 75 18             	pushl  0x18(%ebp)
    da5e:	ff 75 f4             	pushl  -0xc(%ebp)
    da61:	ff 75 0c             	pushl  0xc(%ebp)
    da64:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    da6a:	50                   	push   %eax
    da6b:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    da71:	50                   	push   %eax
    da72:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    da78:	50                   	push   %eax
    da79:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    da7f:	50                   	push   %eax
    da80:	e8 a8 f2 ff ff       	call   cd2d <getPixelColorRGBA16>
    da85:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    da88:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    da8f:	66 c1 e8 08          	shr    $0x8,%ax
    da93:	89 c2                	mov    %eax,%edx
    da95:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    da9c:	31 d0                	xor    %edx,%eax
    da9e:	0f b7 c0             	movzwl %ax,%eax
    daa1:	0f b6 c0             	movzbl %al,%eax
    daa4:	85 c0                	test   %eax,%eax
    daa6:	75 60                	jne    db08 <lodepng_compute_color_stats+0x2d8>
    daa8:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    daaf:	66 c1 e8 08          	shr    $0x8,%ax
    dab3:	89 c2                	mov    %eax,%edx
    dab5:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    dabc:	31 d0                	xor    %edx,%eax
    dabe:	0f b7 c0             	movzwl %ax,%eax
    dac1:	0f b6 c0             	movzbl %al,%eax
    dac4:	85 c0                	test   %eax,%eax
    dac6:	75 40                	jne    db08 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    dac8:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    dacf:	66 c1 e8 08          	shr    $0x8,%ax
    dad3:	89 c2                	mov    %eax,%edx
    dad5:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    dadc:	31 d0                	xor    %edx,%eax
    dade:	0f b7 c0             	movzwl %ax,%eax
    dae1:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    dae4:	85 c0                	test   %eax,%eax
    dae6:	75 20                	jne    db08 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    dae8:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    daef:	66 c1 e8 08          	shr    $0x8,%ax
    daf3:	89 c2                	mov    %eax,%edx
    daf5:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    dafc:	31 d0                	xor    %edx,%eax
    dafe:	0f b7 c0             	movzwl %ax,%eax
    db01:	0f b6 c0             	movzbl %al,%eax
    db04:	85 c0                	test   %eax,%eax
    db06:	74 24                	je     db2c <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    db08:	8b 45 08             	mov    0x8(%ebp),%eax
    db0b:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    db12:	00 00 00 
        sixteen = 1;
    db15:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    db1c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    db23:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    db2a:	eb 10                	jmp    db3c <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    db2c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    db30:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db33:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    db36:	0f 85 1c ff ff ff    	jne    da58 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    db3c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    db40:	0f 84 bd 02 00 00    	je     de03 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    db46:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    db4d:	00 00 
    db4f:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    db56:	00 00 
    db58:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    db5f:	00 00 
    db61:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    db68:	00 00 

    for(i = 0; i != numpixels; ++i) {
    db6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    db71:	e9 b1 01 00 00       	jmp    dd27 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    db76:	83 ec 04             	sub    $0x4,%esp
    db79:	ff 75 18             	pushl  0x18(%ebp)
    db7c:	ff 75 f4             	pushl  -0xc(%ebp)
    db7f:	ff 75 0c             	pushl  0xc(%ebp)
    db82:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    db88:	50                   	push   %eax
    db89:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    db8f:	50                   	push   %eax
    db90:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    db96:	50                   	push   %eax
    db97:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    db9d:	50                   	push   %eax
    db9e:	e8 8a f1 ff ff       	call   cd2d <getPixelColorRGBA16>
    dba3:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    dba6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    dbaa:	75 36                	jne    dbe2 <lodepng_compute_color_stats+0x3b2>
    dbac:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    dbb3:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    dbba:	66 39 c2             	cmp    %ax,%dx
    dbbd:	75 13                	jne    dbd2 <lodepng_compute_color_stats+0x3a2>
    dbbf:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    dbc6:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    dbcd:	66 39 c2             	cmp    %ax,%dx
    dbd0:	74 10                	je     dbe2 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    dbd2:	8b 45 08             	mov    0x8(%ebp),%eax
    dbd5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    dbdb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    dbe2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    dbe6:	0f 85 1f 01 00 00    	jne    dd0b <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    dbec:	8b 45 08             	mov    0x8(%ebp),%eax
    dbef:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    dbf3:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    dbfa:	66 39 c2             	cmp    %ax,%dx
    dbfd:	75 2d                	jne    dc2c <lodepng_compute_color_stats+0x3fc>
    dbff:	8b 45 08             	mov    0x8(%ebp),%eax
    dc02:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    dc06:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    dc0d:	66 39 c2             	cmp    %ax,%dx
    dc10:	75 1a                	jne    dc2c <lodepng_compute_color_stats+0x3fc>
    dc12:	8b 45 08             	mov    0x8(%ebp),%eax
    dc15:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    dc19:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    dc20:	66 39 c2             	cmp    %ax,%dx
    dc23:	75 07                	jne    dc2c <lodepng_compute_color_stats+0x3fc>
    dc25:	b8 01 00 00 00       	mov    $0x1,%eax
    dc2a:	eb 05                	jmp    dc31 <lodepng_compute_color_stats+0x401>
    dc2c:	b8 00 00 00 00       	mov    $0x0,%eax
    dc31:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    dc34:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    dc3b:	66 83 f8 ff          	cmp    $0xffff,%ax
    dc3f:	74 3c                	je     dc7d <lodepng_compute_color_stats+0x44d>
    dc41:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    dc48:	66 85 c0             	test   %ax,%ax
    dc4b:	75 10                	jne    dc5d <lodepng_compute_color_stats+0x42d>
    dc4d:	8b 45 08             	mov    0x8(%ebp),%eax
    dc50:	8b 40 04             	mov    0x4(%eax),%eax
    dc53:	85 c0                	test   %eax,%eax
    dc55:	74 26                	je     dc7d <lodepng_compute_color_stats+0x44d>
    dc57:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    dc5b:	75 20                	jne    dc7d <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    dc5d:	8b 45 08             	mov    0x8(%ebp),%eax
    dc60:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    dc67:	8b 45 08             	mov    0x8(%ebp),%eax
    dc6a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    dc71:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    dc78:	e9 8e 00 00 00       	jmp    dd0b <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    dc7d:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    dc84:	66 85 c0             	test   %ax,%ax
    dc87:	75 4a                	jne    dcd3 <lodepng_compute_color_stats+0x4a3>
    dc89:	8b 45 08             	mov    0x8(%ebp),%eax
    dc8c:	8b 40 10             	mov    0x10(%eax),%eax
    dc8f:	85 c0                	test   %eax,%eax
    dc91:	75 40                	jne    dcd3 <lodepng_compute_color_stats+0x4a3>
    dc93:	8b 45 08             	mov    0x8(%ebp),%eax
    dc96:	8b 40 04             	mov    0x4(%eax),%eax
    dc99:	85 c0                	test   %eax,%eax
    dc9b:	75 36                	jne    dcd3 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    dc9d:	8b 45 08             	mov    0x8(%ebp),%eax
    dca0:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    dca7:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    dcae:	8b 45 08             	mov    0x8(%ebp),%eax
    dcb1:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    dcb5:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    dcbc:	8b 45 08             	mov    0x8(%ebp),%eax
    dcbf:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    dcc3:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    dcca:	8b 45 08             	mov    0x8(%ebp),%eax
    dccd:	66 89 50 0c          	mov    %dx,0xc(%eax)
    dcd1:	eb 38                	jmp    dd0b <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    dcd3:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    dcda:	66 83 f8 ff          	cmp    $0xffff,%ax
    dcde:	75 2b                	jne    dd0b <lodepng_compute_color_stats+0x4db>
    dce0:	8b 45 08             	mov    0x8(%ebp),%eax
    dce3:	8b 40 04             	mov    0x4(%eax),%eax
    dce6:	85 c0                	test   %eax,%eax
    dce8:	74 21                	je     dd0b <lodepng_compute_color_stats+0x4db>
    dcea:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    dcee:	74 1b                	je     dd0b <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    dcf0:	8b 45 08             	mov    0x8(%ebp),%eax
    dcf3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    dcfa:	8b 45 08             	mov    0x8(%ebp),%eax
    dcfd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    dd04:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    dd0b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    dd0f:	74 12                	je     dd23 <lodepng_compute_color_stats+0x4f3>
    dd11:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    dd15:	74 0c                	je     dd23 <lodepng_compute_color_stats+0x4f3>
    dd17:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    dd1b:	74 06                	je     dd23 <lodepng_compute_color_stats+0x4f3>
    dd1d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    dd21:	75 12                	jne    dd35 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    dd23:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd2a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    dd2d:	0f 85 43 fe ff ff    	jne    db76 <lodepng_compute_color_stats+0x346>
    dd33:	eb 01                	jmp    dd36 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    dd35:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    dd36:	8b 45 08             	mov    0x8(%ebp),%eax
    dd39:	8b 40 04             	mov    0x4(%eax),%eax
    dd3c:	85 c0                	test   %eax,%eax
    dd3e:	0f 84 e0 05 00 00    	je     e324 <lodepng_compute_color_stats+0xaf4>
    dd44:	8b 45 08             	mov    0x8(%ebp),%eax
    dd47:	8b 40 10             	mov    0x10(%eax),%eax
    dd4a:	85 c0                	test   %eax,%eax
    dd4c:	0f 85 d2 05 00 00    	jne    e324 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    dd52:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd59:	e9 94 00 00 00       	jmp    ddf2 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    dd5e:	83 ec 04             	sub    $0x4,%esp
    dd61:	ff 75 18             	pushl  0x18(%ebp)
    dd64:	ff 75 f4             	pushl  -0xc(%ebp)
    dd67:	ff 75 0c             	pushl  0xc(%ebp)
    dd6a:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    dd70:	50                   	push   %eax
    dd71:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    dd77:	50                   	push   %eax
    dd78:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    dd7e:	50                   	push   %eax
    dd7f:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    dd85:	50                   	push   %eax
    dd86:	e8 a2 ef ff ff       	call   cd2d <getPixelColorRGBA16>
    dd8b:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    dd8e:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    dd95:	66 85 c0             	test   %ax,%ax
    dd98:	74 54                	je     ddee <lodepng_compute_color_stats+0x5be>
    dd9a:	8b 45 08             	mov    0x8(%ebp),%eax
    dd9d:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    dda1:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    dda8:	66 39 c2             	cmp    %ax,%dx
    ddab:	75 41                	jne    ddee <lodepng_compute_color_stats+0x5be>
    ddad:	8b 45 08             	mov    0x8(%ebp),%eax
    ddb0:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    ddb4:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    ddbb:	66 39 c2             	cmp    %ax,%dx
    ddbe:	75 2e                	jne    ddee <lodepng_compute_color_stats+0x5be>
    ddc0:	8b 45 08             	mov    0x8(%ebp),%eax
    ddc3:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    ddc7:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    ddce:	66 39 c2             	cmp    %ax,%dx
    ddd1:	75 1b                	jne    ddee <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    ddd3:	8b 45 08             	mov    0x8(%ebp),%eax
    ddd6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    dddd:	8b 45 08             	mov    0x8(%ebp),%eax
    dde0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    dde7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    ddee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ddf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddf5:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    ddf8:	0f 85 60 ff ff ff    	jne    dd5e <lodepng_compute_color_stats+0x52e>
    ddfe:	e9 21 05 00 00       	jmp    e324 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    de03:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    de0a:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    de11:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    de18:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    de1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    de26:	e9 ab 03 00 00       	jmp    e1d6 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    de2b:	83 ec 04             	sub    $0x4,%esp
    de2e:	ff 75 18             	pushl  0x18(%ebp)
    de31:	ff 75 f4             	pushl  -0xc(%ebp)
    de34:	ff 75 0c             	pushl  0xc(%ebp)
    de37:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    de3d:	50                   	push   %eax
    de3e:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    de44:	50                   	push   %eax
    de45:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    de4b:	50                   	push   %eax
    de4c:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    de52:	50                   	push   %eax
    de53:	e8 1e de ff ff       	call   bc76 <getPixelColorRGBA8>
    de58:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    de5b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    de5f:	75 41                	jne    dea2 <lodepng_compute_color_stats+0x672>
    de61:	8b 45 08             	mov    0x8(%ebp),%eax
    de64:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    de6a:	83 f8 07             	cmp    $0x7,%eax
    de6d:	77 33                	ja     dea2 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    de6f:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    de76:	0f b6 c0             	movzbl %al,%eax
    de79:	83 ec 0c             	sub    $0xc,%esp
    de7c:	50                   	push   %eax
    de7d:	e8 1d f9 ff ff       	call   d79f <getValueRequiredBits>
    de82:	83 c4 10             	add    $0x10,%esp
    de85:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    de88:	8b 45 08             	mov    0x8(%ebp),%eax
    de8b:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    de91:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    de94:	73 0c                	jae    dea2 <lodepng_compute_color_stats+0x672>
    de96:	8b 45 08             	mov    0x8(%ebp),%eax
    de99:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    de9c:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    dea2:	8b 45 08             	mov    0x8(%ebp),%eax
    dea5:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    deab:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    deae:	0f 93 c0             	setae  %al
    deb1:	0f b6 c0             	movzbl %al,%eax
    deb4:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    deb7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    debb:	75 4f                	jne    df0c <lodepng_compute_color_stats+0x6dc>
    debd:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    dec4:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    decb:	38 c2                	cmp    %al,%dl
    decd:	75 12                	jne    dee1 <lodepng_compute_color_stats+0x6b1>
    decf:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    ded6:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    dedd:	38 c2                	cmp    %al,%dl
    dedf:	74 2b                	je     df0c <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    dee1:	8b 45 08             	mov    0x8(%ebp),%eax
    dee4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    deea:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    def1:	8b 45 08             	mov    0x8(%ebp),%eax
    def4:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    defa:	83 f8 07             	cmp    $0x7,%eax
    defd:	77 0d                	ja     df0c <lodepng_compute_color_stats+0x6dc>
    deff:	8b 45 08             	mov    0x8(%ebp),%eax
    df02:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    df09:	00 00 00 
      }

      if(!alpha_done) {
    df0c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    df10:	0f 85 65 01 00 00    	jne    e07b <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    df16:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    df1d:	0f b6 d0             	movzbl %al,%edx
    df20:	8b 45 08             	mov    0x8(%ebp),%eax
    df23:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    df27:	66 39 c2             	cmp    %ax,%dx
    df2a:	75 33                	jne    df5f <lodepng_compute_color_stats+0x72f>
    df2c:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    df33:	0f b6 d0             	movzbl %al,%edx
    df36:	8b 45 08             	mov    0x8(%ebp),%eax
    df39:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    df3d:	66 39 c2             	cmp    %ax,%dx
    df40:	75 1d                	jne    df5f <lodepng_compute_color_stats+0x72f>
    df42:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    df49:	0f b6 d0             	movzbl %al,%edx
    df4c:	8b 45 08             	mov    0x8(%ebp),%eax
    df4f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    df53:	66 39 c2             	cmp    %ax,%dx
    df56:	75 07                	jne    df5f <lodepng_compute_color_stats+0x72f>
    df58:	b8 01 00 00 00       	mov    $0x1,%eax
    df5d:	eb 05                	jmp    df64 <lodepng_compute_color_stats+0x734>
    df5f:	b8 00 00 00 00       	mov    $0x0,%eax
    df64:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    df67:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    df6e:	3c ff                	cmp    $0xff,%al
    df70:	74 5a                	je     dfcc <lodepng_compute_color_stats+0x79c>
    df72:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    df79:	84 c0                	test   %al,%al
    df7b:	75 10                	jne    df8d <lodepng_compute_color_stats+0x75d>
    df7d:	8b 45 08             	mov    0x8(%ebp),%eax
    df80:	8b 40 04             	mov    0x4(%eax),%eax
    df83:	85 c0                	test   %eax,%eax
    df85:	74 45                	je     dfcc <lodepng_compute_color_stats+0x79c>
    df87:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    df8b:	75 3f                	jne    dfcc <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    df8d:	8b 45 08             	mov    0x8(%ebp),%eax
    df90:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    df97:	8b 45 08             	mov    0x8(%ebp),%eax
    df9a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    dfa1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    dfa8:	8b 45 08             	mov    0x8(%ebp),%eax
    dfab:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    dfb1:	83 f8 07             	cmp    $0x7,%eax
    dfb4:	0f 87 c1 00 00 00    	ja     e07b <lodepng_compute_color_stats+0x84b>
    dfba:	8b 45 08             	mov    0x8(%ebp),%eax
    dfbd:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    dfc4:	00 00 00 
    dfc7:	e9 af 00 00 00       	jmp    e07b <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    dfcc:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    dfd3:	84 c0                	test   %al,%al
    dfd5:	75 53                	jne    e02a <lodepng_compute_color_stats+0x7fa>
    dfd7:	8b 45 08             	mov    0x8(%ebp),%eax
    dfda:	8b 40 10             	mov    0x10(%eax),%eax
    dfdd:	85 c0                	test   %eax,%eax
    dfdf:	75 49                	jne    e02a <lodepng_compute_color_stats+0x7fa>
    dfe1:	8b 45 08             	mov    0x8(%ebp),%eax
    dfe4:	8b 40 04             	mov    0x4(%eax),%eax
    dfe7:	85 c0                	test   %eax,%eax
    dfe9:	75 3f                	jne    e02a <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    dfeb:	8b 45 08             	mov    0x8(%ebp),%eax
    dfee:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    dff5:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    dffc:	0f b6 d0             	movzbl %al,%edx
    dfff:	8b 45 08             	mov    0x8(%ebp),%eax
    e002:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    e006:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    e00d:	0f b6 d0             	movzbl %al,%edx
    e010:	8b 45 08             	mov    0x8(%ebp),%eax
    e013:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    e017:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    e01e:	0f b6 d0             	movzbl %al,%edx
    e021:	8b 45 08             	mov    0x8(%ebp),%eax
    e024:	66 89 50 0c          	mov    %dx,0xc(%eax)
    e028:	eb 51                	jmp    e07b <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    e02a:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    e031:	3c ff                	cmp    $0xff,%al
    e033:	75 46                	jne    e07b <lodepng_compute_color_stats+0x84b>
    e035:	8b 45 08             	mov    0x8(%ebp),%eax
    e038:	8b 40 04             	mov    0x4(%eax),%eax
    e03b:	85 c0                	test   %eax,%eax
    e03d:	74 3c                	je     e07b <lodepng_compute_color_stats+0x84b>
    e03f:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    e043:	74 36                	je     e07b <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    e045:	8b 45 08             	mov    0x8(%ebp),%eax
    e048:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    e04f:	8b 45 08             	mov    0x8(%ebp),%eax
    e052:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    e059:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    e060:	8b 45 08             	mov    0x8(%ebp),%eax
    e063:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    e069:	83 f8 07             	cmp    $0x7,%eax
    e06c:	77 0d                	ja     e07b <lodepng_compute_color_stats+0x84b>
    e06e:	8b 45 08             	mov    0x8(%ebp),%eax
    e071:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    e078:	00 00 00 
        }
      }

      if(!numcolors_done) {
    e07b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e07f:	0f 85 35 01 00 00    	jne    e1ba <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    e085:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    e08c:	0f b6 d8             	movzbl %al,%ebx
    e08f:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    e096:	0f b6 c8             	movzbl %al,%ecx
    e099:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    e0a0:	0f b6 d0             	movzbl %al,%edx
    e0a3:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    e0aa:	0f b6 c0             	movzbl %al,%eax
    e0ad:	83 ec 0c             	sub    $0xc,%esp
    e0b0:	53                   	push   %ebx
    e0b1:	51                   	push   %ecx
    e0b2:	52                   	push   %edx
    e0b3:	50                   	push   %eax
    e0b4:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e0ba:	50                   	push   %eax
    e0bb:	e8 1c d4 ff ff       	call   b4dc <color_tree_has>
    e0c0:	83 c4 20             	add    $0x20,%esp
    e0c3:	85 c0                	test   %eax,%eax
    e0c5:	0f 85 ef 00 00 00    	jne    e1ba <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    e0cb:	8b 45 08             	mov    0x8(%ebp),%eax
    e0ce:	8b 70 14             	mov    0x14(%eax),%esi
    e0d1:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    e0d8:	0f b6 d8             	movzbl %al,%ebx
    e0db:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    e0e2:	0f b6 c8             	movzbl %al,%ecx
    e0e5:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    e0ec:	0f b6 d0             	movzbl %al,%edx
    e0ef:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    e0f6:	0f b6 c0             	movzbl %al,%eax
    e0f9:	83 ec 08             	sub    $0x8,%esp
    e0fc:	56                   	push   %esi
    e0fd:	53                   	push   %ebx
    e0fe:	51                   	push   %ecx
    e0ff:	52                   	push   %edx
    e100:	50                   	push   %eax
    e101:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e107:	50                   	push   %eax
    e108:	e8 1a d4 ff ff       	call   b527 <color_tree_add>
    e10d:	83 c4 20             	add    $0x20,%esp
    e110:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    e113:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e117:	0f 85 06 02 00 00    	jne    e323 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    e11d:	8b 45 08             	mov    0x8(%ebp),%eax
    e120:	8b 40 14             	mov    0x14(%eax),%eax
    e123:	3d ff 00 00 00       	cmp    $0xff,%eax
    e128:	77 6f                	ja     e199 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    e12a:	8b 45 08             	mov    0x8(%ebp),%eax
    e12d:	83 c0 18             	add    $0x18,%eax
    e130:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    e133:	8b 45 08             	mov    0x8(%ebp),%eax
    e136:	8b 40 14             	mov    0x14(%eax),%eax
    e139:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    e13c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    e13f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e146:	8b 45 bc             	mov    -0x44(%ebp),%eax
    e149:	01 c2                	add    %eax,%edx
    e14b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    e152:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    e154:	8b 45 b8             	mov    -0x48(%ebp),%eax
    e157:	c1 e0 02             	shl    $0x2,%eax
    e15a:	8d 50 01             	lea    0x1(%eax),%edx
    e15d:	8b 45 bc             	mov    -0x44(%ebp),%eax
    e160:	01 c2                	add    %eax,%edx
    e162:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    e169:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    e16b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    e16e:	c1 e0 02             	shl    $0x2,%eax
    e171:	8d 50 02             	lea    0x2(%eax),%edx
    e174:	8b 45 bc             	mov    -0x44(%ebp),%eax
    e177:	01 c2                	add    %eax,%edx
    e179:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    e180:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    e182:	8b 45 b8             	mov    -0x48(%ebp),%eax
    e185:	c1 e0 02             	shl    $0x2,%eax
    e188:	8d 50 03             	lea    0x3(%eax),%edx
    e18b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    e18e:	01 c2                	add    %eax,%edx
    e190:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    e197:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    e199:	8b 45 08             	mov    0x8(%ebp),%eax
    e19c:	8b 40 14             	mov    0x14(%eax),%eax
    e19f:	8d 50 01             	lea    0x1(%eax),%edx
    e1a2:	8b 45 08             	mov    0x8(%ebp),%eax
    e1a5:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    e1a8:	8b 45 08             	mov    0x8(%ebp),%eax
    e1ab:	8b 40 14             	mov    0x14(%eax),%eax
    e1ae:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    e1b1:	0f 93 c0             	setae  %al
    e1b4:	0f b6 c0             	movzbl %al,%eax
    e1b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    e1ba:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e1be:	74 12                	je     e1d2 <lodepng_compute_color_stats+0x9a2>
    e1c0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e1c4:	74 0c                	je     e1d2 <lodepng_compute_color_stats+0x9a2>
    e1c6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e1ca:	74 06                	je     e1d2 <lodepng_compute_color_stats+0x9a2>
    e1cc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e1d0:	75 12                	jne    e1e4 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    e1d2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e1d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1d9:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    e1dc:	0f 85 49 fc ff ff    	jne    de2b <lodepng_compute_color_stats+0x5fb>
    e1e2:	eb 01                	jmp    e1e5 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    e1e4:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    e1e5:	8b 45 08             	mov    0x8(%ebp),%eax
    e1e8:	8b 40 04             	mov    0x4(%eax),%eax
    e1eb:	85 c0                	test   %eax,%eax
    e1ed:	0f 84 dd 00 00 00    	je     e2d0 <lodepng_compute_color_stats+0xaa0>
    e1f3:	8b 45 08             	mov    0x8(%ebp),%eax
    e1f6:	8b 40 10             	mov    0x10(%eax),%eax
    e1f9:	85 c0                	test   %eax,%eax
    e1fb:	0f 85 cf 00 00 00    	jne    e2d0 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    e201:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e208:	e9 b7 00 00 00       	jmp    e2c4 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    e20d:	83 ec 04             	sub    $0x4,%esp
    e210:	ff 75 18             	pushl  0x18(%ebp)
    e213:	ff 75 f4             	pushl  -0xc(%ebp)
    e216:	ff 75 0c             	pushl  0xc(%ebp)
    e219:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    e21f:	50                   	push   %eax
    e220:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    e226:	50                   	push   %eax
    e227:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    e22d:	50                   	push   %eax
    e22e:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    e234:	50                   	push   %eax
    e235:	e8 3c da ff ff       	call   bc76 <getPixelColorRGBA8>
    e23a:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    e23d:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    e244:	84 c0                	test   %al,%al
    e246:	74 78                	je     e2c0 <lodepng_compute_color_stats+0xa90>
    e248:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    e24f:	0f b6 d0             	movzbl %al,%edx
    e252:	8b 45 08             	mov    0x8(%ebp),%eax
    e255:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    e259:	66 39 c2             	cmp    %ax,%dx
    e25c:	75 62                	jne    e2c0 <lodepng_compute_color_stats+0xa90>
    e25e:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    e265:	0f b6 d0             	movzbl %al,%edx
    e268:	8b 45 08             	mov    0x8(%ebp),%eax
    e26b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    e26f:	66 39 c2             	cmp    %ax,%dx
    e272:	75 4c                	jne    e2c0 <lodepng_compute_color_stats+0xa90>
    e274:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    e27b:	0f b6 d0             	movzbl %al,%edx
    e27e:	8b 45 08             	mov    0x8(%ebp),%eax
    e281:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    e285:	66 39 c2             	cmp    %ax,%dx
    e288:	75 36                	jne    e2c0 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    e28a:	8b 45 08             	mov    0x8(%ebp),%eax
    e28d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    e294:	8b 45 08             	mov    0x8(%ebp),%eax
    e297:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    e29e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    e2a5:	8b 45 08             	mov    0x8(%ebp),%eax
    e2a8:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    e2ae:	83 f8 07             	cmp    $0x7,%eax
    e2b1:	77 0d                	ja     e2c0 <lodepng_compute_color_stats+0xa90>
    e2b3:	8b 45 08             	mov    0x8(%ebp),%eax
    e2b6:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    e2bd:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    e2c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e2c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2c7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    e2ca:	0f 85 3d ff ff ff    	jne    e20d <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    e2d0:	8b 45 08             	mov    0x8(%ebp),%eax
    e2d3:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    e2d7:	8b 45 08             	mov    0x8(%ebp),%eax
    e2da:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    e2de:	c1 e0 08             	shl    $0x8,%eax
    e2e1:	01 c2                	add    %eax,%edx
    e2e3:	8b 45 08             	mov    0x8(%ebp),%eax
    e2e6:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    e2ea:	8b 45 08             	mov    0x8(%ebp),%eax
    e2ed:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    e2f1:	8b 45 08             	mov    0x8(%ebp),%eax
    e2f4:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    e2f8:	c1 e0 08             	shl    $0x8,%eax
    e2fb:	01 c2                	add    %eax,%edx
    e2fd:	8b 45 08             	mov    0x8(%ebp),%eax
    e300:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    e304:	8b 45 08             	mov    0x8(%ebp),%eax
    e307:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    e30b:	8b 45 08             	mov    0x8(%ebp),%eax
    e30e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    e312:	c1 e0 08             	shl    $0x8,%eax
    e315:	01 c2                	add    %eax,%edx
    e317:	8b 45 08             	mov    0x8(%ebp),%eax
    e31a:	66 89 50 0c          	mov    %dx,0xc(%eax)
    e31e:	eb 04                	jmp    e324 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    e320:	90                   	nop
    e321:	eb 01                	jmp    e324 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    e323:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    e324:	83 ec 0c             	sub    $0xc,%esp
    e327:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e32d:	50                   	push   %eax
    e32e:	e8 91 d0 ff ff       	call   b3c4 <color_tree_cleanup>
    e333:	83 c4 10             	add    $0x10,%esp
  return error;
    e336:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    e339:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e33c:	5b                   	pop    %ebx
    e33d:	5e                   	pop    %esi
    e33e:	5d                   	pop    %ebp
    e33f:	c3                   	ret    

0000e340 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    e340:	55                   	push   %ebp
    e341:	89 e5                	mov    %esp,%ebp
    e343:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e346:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    e34d:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e350:	50                   	push   %eax
    e351:	e8 d1 bd ff ff       	call   a127 <lodepng_color_mode_init>
    e356:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    e359:	8b 45 0c             	mov    0xc(%ebp),%eax
    e35c:	c1 e8 08             	shr    $0x8,%eax
    e35f:	88 45 ec             	mov    %al,-0x14(%ebp)
    e362:	8b 45 0c             	mov    0xc(%ebp),%eax
    e365:	88 45 ed             	mov    %al,-0x13(%ebp)
    e368:	8b 45 10             	mov    0x10(%ebp),%eax
    e36b:	c1 e8 08             	shr    $0x8,%eax
    e36e:	88 45 ee             	mov    %al,-0x12(%ebp)
    e371:	8b 45 10             	mov    0x10(%ebp),%eax
    e374:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    e377:	8b 45 14             	mov    0x14(%ebp),%eax
    e37a:	c1 e8 08             	shr    $0x8,%eax
    e37d:	88 45 f0             	mov    %al,-0x10(%ebp)
    e380:	8b 45 14             	mov    0x14(%ebp),%eax
    e383:	88 45 f1             	mov    %al,-0xf(%ebp)
    e386:	8b 45 18             	mov    0x18(%ebp),%eax
    e389:	c1 e8 08             	shr    $0x8,%eax
    e38c:	88 45 f2             	mov    %al,-0xe(%ebp)
    e38f:	8b 45 18             	mov    0x18(%ebp),%eax
    e392:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    e395:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    e39c:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    e3a3:	83 ec 0c             	sub    $0xc,%esp
    e3a6:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e3a9:	50                   	push   %eax
    e3aa:	6a 01                	push   $0x1
    e3ac:	6a 01                	push   $0x1
    e3ae:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e3b1:	50                   	push   %eax
    e3b2:	ff 75 08             	pushl  0x8(%ebp)
    e3b5:	e8 76 f4 ff ff       	call   d830 <lodepng_compute_color_stats>
    e3ba:	83 c4 20             	add    $0x20,%esp
    e3bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    e3c0:	83 ec 0c             	sub    $0xc,%esp
    e3c3:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e3c6:	50                   	push   %eax
    e3c7:	e8 4e be ff ff       	call   a21a <lodepng_color_mode_cleanup>
    e3cc:	83 c4 10             	add    $0x10,%esp
  return error;
    e3cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e3d2:	c9                   	leave  
    e3d3:	c3                   	ret    

0000e3d4 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    e3d4:	55                   	push   %ebp
    e3d5:	89 e5                	mov    %esp,%ebp
    e3d7:	56                   	push   %esi
    e3d8:	53                   	push   %ebx
    e3d9:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    e3dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    e3e3:	8b 45 10             	mov    0x10(%ebp),%eax
    e3e6:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    e3ec:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    e3ef:	8b 45 10             	mov    0x10(%ebp),%eax
    e3f2:	8b 40 10             	mov    0x10(%eax),%eax
    e3f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    e3f8:	8b 45 10             	mov    0x10(%ebp),%eax
    e3fb:	8b 40 04             	mov    0x4(%eax),%eax
    e3fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    e401:	8b 45 10             	mov    0x10(%ebp),%eax
    e404:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    e40a:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    e40d:	8b 45 08             	mov    0x8(%ebp),%eax
    e410:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    e417:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e41b:	74 21                	je     e43e <auto_choose_color+0x6a>
    e41d:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    e421:	7f 1b                	jg     e43e <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    e423:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    e42a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    e431:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    e435:	77 07                	ja     e43e <auto_choose_color+0x6a>
    e437:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    e43e:	8b 45 10             	mov    0x10(%ebp),%eax
    e441:	8b 00                	mov    (%eax),%eax
    e443:	85 c0                	test   %eax,%eax
    e445:	0f 94 c0             	sete   %al
    e448:	0f b6 c0             	movzbl %al,%eax
    e44b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    e44e:	8b 45 10             	mov    0x10(%ebp),%eax
    e451:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    e457:	85 c0                	test   %eax,%eax
    e459:	75 07                	jne    e462 <auto_choose_color+0x8e>
    e45b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    e462:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e466:	75 0d                	jne    e475 <auto_choose_color+0xa1>
    e468:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    e46c:	77 07                	ja     e475 <auto_choose_color+0xa1>
    e46e:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    e475:	8b 45 10             	mov    0x10(%ebp),%eax
    e478:	8b 40 14             	mov    0x14(%eax),%eax
    e47b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    e47e:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    e482:	7e 21                	jle    e4a5 <auto_choose_color+0xd1>
    e484:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    e488:	7e 14                	jle    e49e <auto_choose_color+0xca>
    e48a:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    e48e:	7f 07                	jg     e497 <auto_choose_color+0xc3>
    e490:	b8 04 00 00 00       	mov    $0x4,%eax
    e495:	eb 13                	jmp    e4aa <auto_choose_color+0xd6>
    e497:	b8 08 00 00 00       	mov    $0x8,%eax
    e49c:	eb 0c                	jmp    e4aa <auto_choose_color+0xd6>
    e49e:	b8 02 00 00 00       	mov    $0x2,%eax
    e4a3:	eb 05                	jmp    e4aa <auto_choose_color+0xd6>
    e4a5:	b8 01 00 00 00       	mov    $0x1,%eax
    e4aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    e4ad:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    e4b4:	7f 13                	jg     e4c9 <auto_choose_color+0xf5>
    e4b6:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    e4ba:	77 0d                	ja     e4c9 <auto_choose_color+0xf5>
    e4bc:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    e4c0:	74 07                	je     e4c9 <auto_choose_color+0xf5>
    e4c2:	b8 01 00 00 00       	mov    $0x1,%eax
    e4c7:	eb 05                	jmp    e4ce <auto_choose_color+0xfa>
    e4c9:	b8 00 00 00 00       	mov    $0x0,%eax
    e4ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    e4d1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e4d4:	01 c0                	add    %eax,%eax
    e4d6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    e4d9:	7e 07                	jle    e4e2 <auto_choose_color+0x10e>
    e4db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    e4e2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e4e6:	74 15                	je     e4fd <auto_choose_color+0x129>
    e4e8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e4ec:	75 0f                	jne    e4fd <auto_choose_color+0x129>
    e4ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e4f1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    e4f4:	77 07                	ja     e4fd <auto_choose_color+0x129>
    e4f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    e4fd:	8b 45 10             	mov    0x10(%ebp),%eax
    e500:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    e506:	85 c0                	test   %eax,%eax
    e508:	75 07                	jne    e511 <auto_choose_color+0x13d>
    e50a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    e511:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e515:	0f 84 0a 01 00 00    	je     e625 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    e51b:	8b 45 10             	mov    0x10(%ebp),%eax
    e51e:	83 c0 18             	add    $0x18,%eax
    e521:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    e524:	83 ec 0c             	sub    $0xc,%esp
    e527:	ff 75 08             	pushl  0x8(%ebp)
    e52a:	e8 ef be ff ff       	call   a41e <lodepng_palette_clear>
    e52f:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    e532:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e539:	eb 6e                	jmp    e5a9 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    e53b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e53e:	c1 e0 02             	shl    $0x2,%eax
    e541:	8d 50 03             	lea    0x3(%eax),%edx
    e544:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e547:	01 d0                	add    %edx,%eax
    e549:	0f b6 00             	movzbl (%eax),%eax
    e54c:	0f b6 d8             	movzbl %al,%ebx
    e54f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e552:	c1 e0 02             	shl    $0x2,%eax
    e555:	8d 50 02             	lea    0x2(%eax),%edx
    e558:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e55b:	01 d0                	add    %edx,%eax
    e55d:	0f b6 00             	movzbl (%eax),%eax
    e560:	0f b6 c8             	movzbl %al,%ecx
    e563:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e566:	c1 e0 02             	shl    $0x2,%eax
    e569:	8d 50 01             	lea    0x1(%eax),%edx
    e56c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e56f:	01 d0                	add    %edx,%eax
    e571:	0f b6 00             	movzbl (%eax),%eax
    e574:	0f b6 d0             	movzbl %al,%edx
    e577:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e57a:	c1 e0 02             	shl    $0x2,%eax
    e57d:	89 c6                	mov    %eax,%esi
    e57f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e582:	01 f0                	add    %esi,%eax
    e584:	0f b6 00             	movzbl (%eax),%eax
    e587:	0f b6 c0             	movzbl %al,%eax
    e58a:	83 ec 0c             	sub    $0xc,%esp
    e58d:	53                   	push   %ebx
    e58e:	51                   	push   %ecx
    e58f:	52                   	push   %edx
    e590:	50                   	push   %eax
    e591:	ff 75 08             	pushl  0x8(%ebp)
    e594:	e8 be be ff ff       	call   a457 <lodepng_palette_add>
    e599:	83 c4 20             	add    $0x20,%esp
    e59c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    e59f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e5a3:	75 13                	jne    e5b8 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    e5a5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e5a9:	8b 45 10             	mov    0x10(%ebp),%eax
    e5ac:	8b 50 14             	mov    0x14(%eax),%edx
    e5af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e5b2:	39 c2                	cmp    %eax,%edx
    e5b4:	75 85                	jne    e53b <auto_choose_color+0x167>
    e5b6:	eb 01                	jmp    e5b9 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    e5b8:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    e5b9:	8b 45 08             	mov    0x8(%ebp),%eax
    e5bc:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    e5c2:	8b 45 08             	mov    0x8(%ebp),%eax
    e5c5:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e5c8:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    e5cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5ce:	8b 00                	mov    (%eax),%eax
    e5d0:	83 f8 03             	cmp    $0x3,%eax
    e5d3:	0f 85 ec 00 00 00    	jne    e6c5 <auto_choose_color+0x2f1>
    e5d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5dc:	8b 50 0c             	mov    0xc(%eax),%edx
    e5df:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e2:	8b 40 0c             	mov    0xc(%eax),%eax
    e5e5:	39 c2                	cmp    %eax,%edx
    e5e7:	0f 8c d8 00 00 00    	jl     e6c5 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    e5ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5f0:	8b 50 04             	mov    0x4(%eax),%edx
    e5f3:	8b 45 08             	mov    0x8(%ebp),%eax
    e5f6:	8b 40 04             	mov    0x4(%eax),%eax
    e5f9:	39 c2                	cmp    %eax,%edx
    e5fb:	0f 85 c4 00 00 00    	jne    e6c5 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    e601:	83 ec 0c             	sub    $0xc,%esp
    e604:	ff 75 08             	pushl  0x8(%ebp)
    e607:	e8 0e bc ff ff       	call   a21a <lodepng_color_mode_cleanup>
    e60c:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    e60f:	83 ec 08             	sub    $0x8,%esp
    e612:	ff 75 0c             	pushl  0xc(%ebp)
    e615:	ff 75 08             	pushl  0x8(%ebp)
    e618:	e8 14 bc ff ff       	call   a231 <lodepng_color_mode_copy>
    e61d:	83 c4 10             	add    $0x10,%esp
    e620:	e9 a0 00 00 00       	jmp    e6c5 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    e625:	8b 45 08             	mov    0x8(%ebp),%eax
    e628:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e62b:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    e62e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e632:	74 14                	je     e648 <auto_choose_color+0x274>
    e634:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e638:	74 07                	je     e641 <auto_choose_color+0x26d>
    e63a:	b8 04 00 00 00       	mov    $0x4,%eax
    e63f:	eb 19                	jmp    e65a <auto_choose_color+0x286>
    e641:	b8 06 00 00 00       	mov    $0x6,%eax
    e646:	eb 12                	jmp    e65a <auto_choose_color+0x286>
    e648:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e64c:	74 07                	je     e655 <auto_choose_color+0x281>
    e64e:	b8 00 00 00 00       	mov    $0x0,%eax
    e653:	eb 05                	jmp    e65a <auto_choose_color+0x286>
    e655:	b8 02 00 00 00       	mov    $0x2,%eax
    e65a:	8b 55 08             	mov    0x8(%ebp),%edx
    e65d:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    e65f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e663:	74 60                	je     e6c5 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    e665:	8b 45 08             	mov    0x8(%ebp),%eax
    e668:	8b 40 04             	mov    0x4(%eax),%eax
    e66b:	ba 01 00 00 00       	mov    $0x1,%edx
    e670:	89 c1                	mov    %eax,%ecx
    e672:	d3 e2                	shl    %cl,%edx
    e674:	89 d0                	mov    %edx,%eax
    e676:	83 e8 01             	sub    $0x1,%eax
    e679:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    e67c:	8b 45 10             	mov    0x10(%ebp),%eax
    e67f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    e683:	0f b7 c0             	movzwl %ax,%eax
    e686:	23 45 c8             	and    -0x38(%ebp),%eax
    e689:	89 c2                	mov    %eax,%edx
    e68b:	8b 45 08             	mov    0x8(%ebp),%eax
    e68e:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    e691:	8b 45 10             	mov    0x10(%ebp),%eax
    e694:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    e698:	0f b7 c0             	movzwl %ax,%eax
    e69b:	23 45 c8             	and    -0x38(%ebp),%eax
    e69e:	89 c2                	mov    %eax,%edx
    e6a0:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a3:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    e6a6:	8b 45 10             	mov    0x10(%ebp),%eax
    e6a9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    e6ad:	0f b7 c0             	movzwl %ax,%eax
    e6b0:	23 45 c8             	and    -0x38(%ebp),%eax
    e6b3:	89 c2                	mov    %eax,%edx
    e6b5:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b8:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    e6bb:	8b 45 08             	mov    0x8(%ebp),%eax
    e6be:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    e6c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e6c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e6cb:	5b                   	pop    %ebx
    e6cc:	5e                   	pop    %esi
    e6cd:	5d                   	pop    %ebp
    e6ce:	c3                   	ret    

0000e6cf <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    e6cf:	55                   	push   %ebp
    e6d0:	89 e5                	mov    %esp,%ebp
    e6d2:	83 ec 1c             	sub    $0x1c,%esp
    e6d5:	8b 4d 08             	mov    0x8(%ebp),%ecx
    e6d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6db:	8b 45 10             	mov    0x10(%ebp),%eax
    e6de:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    e6e2:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    e6e6:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    e6ea:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    e6ee:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e6f2:	29 c2                	sub    %eax,%edx
    e6f4:	89 d0                	mov    %edx,%eax
    e6f6:	99                   	cltd   
    e6f7:	31 d0                	xor    %edx,%eax
    e6f9:	29 d0                	sub    %edx,%eax
    e6fb:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    e6ff:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    e703:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e707:	29 c2                	sub    %eax,%edx
    e709:	89 d0                	mov    %edx,%eax
    e70b:	99                   	cltd   
    e70c:	31 d0                	xor    %edx,%eax
    e70e:	29 d0                	sub    %edx,%eax
    e710:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    e714:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    e718:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    e71c:	01 c2                	add    %eax,%edx
    e71e:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e722:	29 c2                	sub    %eax,%edx
    e724:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e728:	29 c2                	sub    %eax,%edx
    e72a:	89 d0                	mov    %edx,%eax
    e72c:	99                   	cltd   
    e72d:	31 d0                	xor    %edx,%eax
    e72f:	29 d0                	sub    %edx,%eax
    e731:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    e735:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    e739:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    e73d:	7d 10                	jge    e74f <paethPredictor+0x80>
    e73f:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    e743:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    e747:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    e74b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    e74f:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    e753:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    e757:	7d 06                	jge    e75f <paethPredictor+0x90>
    e759:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    e75d:	eb 04                	jmp    e763 <paethPredictor+0x94>
    e75f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    e763:	c9                   	leave  
    e764:	c3                   	ret    

0000e765 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    e765:	55                   	push   %ebp
    e766:	89 e5                	mov    %esp,%ebp
    e768:	56                   	push   %esi
    e769:	53                   	push   %ebx
    e76a:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    e76d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e774:	e9 e2 00 00 00       	jmp    e85b <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    e779:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e77c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e783:	8b 45 08             	mov    0x8(%ebp),%eax
    e786:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    e789:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e78c:	8b 14 85 f4 b6 01 00 	mov    0x1b6f4(,%eax,4),%edx
    e793:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e796:	01 c2                	add    %eax,%edx
    e798:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e79b:	8b 04 85 bc b6 01 00 	mov    0x1b6bc(,%eax,4),%eax
    e7a2:	29 c2                	sub    %eax,%edx
    e7a4:	89 d0                	mov    %edx,%eax
    e7a6:	8d 58 ff             	lea    -0x1(%eax),%ebx
    e7a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7ac:	8b 34 85 f4 b6 01 00 	mov    0x1b6f4(,%eax,4),%esi
    e7b3:	89 d8                	mov    %ebx,%eax
    e7b5:	ba 00 00 00 00       	mov    $0x0,%edx
    e7ba:	f7 f6                	div    %esi
    e7bc:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    e7be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7c1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e7c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7cb:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    e7ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7d1:	8b 14 85 10 b7 01 00 	mov    0x1b710(,%eax,4),%edx
    e7d8:	8b 45 20             	mov    0x20(%ebp),%eax
    e7db:	01 c2                	add    %eax,%edx
    e7dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7e0:	8b 04 85 d8 b6 01 00 	mov    0x1b6d8(,%eax,4),%eax
    e7e7:	29 c2                	sub    %eax,%edx
    e7e9:	89 d0                	mov    %edx,%eax
    e7eb:	8d 58 ff             	lea    -0x1(%eax),%ebx
    e7ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7f1:	8b 34 85 10 b7 01 00 	mov    0x1b710(,%eax,4),%esi
    e7f8:	89 d8                	mov    %ebx,%eax
    e7fa:	ba 00 00 00 00       	mov    $0x0,%edx
    e7ff:	f7 f6                	div    %esi
    e801:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    e803:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e806:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e80d:	8b 45 08             	mov    0x8(%ebp),%eax
    e810:	01 d0                	add    %edx,%eax
    e812:	8b 00                	mov    (%eax),%eax
    e814:	85 c0                	test   %eax,%eax
    e816:	75 15                	jne    e82d <Adam7_getpassvalues+0xc8>
    e818:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e81b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e822:	8b 45 0c             	mov    0xc(%ebp),%eax
    e825:	01 d0                	add    %edx,%eax
    e827:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    e82d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e830:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e837:	8b 45 0c             	mov    0xc(%ebp),%eax
    e83a:	01 d0                	add    %edx,%eax
    e83c:	8b 00                	mov    (%eax),%eax
    e83e:	85 c0                	test   %eax,%eax
    e840:	75 15                	jne    e857 <Adam7_getpassvalues+0xf2>
    e842:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e845:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e84c:	8b 45 08             	mov    0x8(%ebp),%eax
    e84f:	01 d0                	add    %edx,%eax
    e851:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    e857:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e85b:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    e85f:	0f 85 14 ff ff ff    	jne    e779 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    e865:	8b 45 18             	mov    0x18(%ebp),%eax
    e868:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    e86e:	8b 45 18             	mov    0x18(%ebp),%eax
    e871:	8b 10                	mov    (%eax),%edx
    e873:	8b 45 14             	mov    0x14(%ebp),%eax
    e876:	89 10                	mov    %edx,(%eax)
    e878:	8b 45 14             	mov    0x14(%ebp),%eax
    e87b:	8b 10                	mov    (%eax),%edx
    e87d:	8b 45 10             	mov    0x10(%ebp),%eax
    e880:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    e882:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e889:	e9 40 01 00 00       	jmp    e9ce <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    e88e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e891:	83 c0 01             	add    $0x1,%eax
    e894:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e89b:	8b 45 10             	mov    0x10(%ebp),%eax
    e89e:	01 c2                	add    %eax,%edx
    e8a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8a3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e8aa:	8b 45 10             	mov    0x10(%ebp),%eax
    e8ad:	01 c8                	add    %ecx,%eax
    e8af:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    e8b1:	89 c6                	mov    %eax,%esi
    e8b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8b6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e8bd:	8b 45 08             	mov    0x8(%ebp),%eax
    e8c0:	01 c8                	add    %ecx,%eax
    e8c2:	8b 00                	mov    (%eax),%eax
    e8c4:	85 c0                	test   %eax,%eax
    e8c6:	74 49                	je     e911 <Adam7_getpassvalues+0x1ac>
    e8c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8cb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e8d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8d5:	01 c8                	add    %ecx,%eax
    e8d7:	8b 00                	mov    (%eax),%eax
    e8d9:	85 c0                	test   %eax,%eax
    e8db:	74 34                	je     e911 <Adam7_getpassvalues+0x1ac>
    e8dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8e0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e8e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8ea:	01 c8                	add    %ecx,%eax
    e8ec:	8b 08                	mov    (%eax),%ecx
    e8ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8f1:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    e8f8:	8b 45 08             	mov    0x8(%ebp),%eax
    e8fb:	01 d8                	add    %ebx,%eax
    e8fd:	8b 00                	mov    (%eax),%eax
    e8ff:	0f af 45 24          	imul   0x24(%ebp),%eax
    e903:	83 c0 07             	add    $0x7,%eax
    e906:	c1 e8 03             	shr    $0x3,%eax
    e909:	83 c0 01             	add    $0x1,%eax
    e90c:	0f af c1             	imul   %ecx,%eax
    e90f:	eb 05                	jmp    e916 <Adam7_getpassvalues+0x1b1>
    e911:	b8 00 00 00 00       	mov    $0x0,%eax
    e916:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    e918:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    e91a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e91d:	83 c0 01             	add    $0x1,%eax
    e920:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e927:	8b 45 14             	mov    0x14(%ebp),%eax
    e92a:	01 c2                	add    %eax,%edx
    e92c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e92f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e936:	8b 45 14             	mov    0x14(%ebp),%eax
    e939:	01 c8                	add    %ecx,%eax
    e93b:	8b 00                	mov    (%eax),%eax
    e93d:	89 c6                	mov    %eax,%esi
    e93f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e942:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e949:	8b 45 0c             	mov    0xc(%ebp),%eax
    e94c:	01 c8                	add    %ecx,%eax
    e94e:	8b 08                	mov    (%eax),%ecx
    e950:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e953:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    e95a:	8b 45 08             	mov    0x8(%ebp),%eax
    e95d:	01 d8                	add    %ebx,%eax
    e95f:	8b 00                	mov    (%eax),%eax
    e961:	0f af 45 24          	imul   0x24(%ebp),%eax
    e965:	83 c0 07             	add    $0x7,%eax
    e968:	c1 e8 03             	shr    $0x3,%eax
    e96b:	0f af c1             	imul   %ecx,%eax
    e96e:	01 f0                	add    %esi,%eax
    e970:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    e972:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e975:	83 c0 01             	add    $0x1,%eax
    e978:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e97f:	8b 45 18             	mov    0x18(%ebp),%eax
    e982:	01 c2                	add    %eax,%edx
    e984:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e987:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e98e:	8b 45 18             	mov    0x18(%ebp),%eax
    e991:	01 c8                	add    %ecx,%eax
    e993:	8b 00                	mov    (%eax),%eax
    e995:	89 c6                	mov    %eax,%esi
    e997:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e99a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e9a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9a4:	01 c8                	add    %ecx,%eax
    e9a6:	8b 08                	mov    (%eax),%ecx
    e9a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e9ab:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    e9b2:	8b 45 08             	mov    0x8(%ebp),%eax
    e9b5:	01 d8                	add    %ebx,%eax
    e9b7:	8b 00                	mov    (%eax),%eax
    e9b9:	0f af c1             	imul   %ecx,%eax
    e9bc:	0f af 45 24          	imul   0x24(%ebp),%eax
    e9c0:	83 c0 07             	add    $0x7,%eax
    e9c3:	c1 e8 03             	shr    $0x3,%eax
    e9c6:	01 f0                	add    %esi,%eax
    e9c8:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    e9ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e9ce:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    e9d2:	0f 85 b6 fe ff ff    	jne    e88e <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    e9d8:	90                   	nop
    e9d9:	83 c4 10             	add    $0x10,%esp
    e9dc:	5b                   	pop    %ebx
    e9dd:	5e                   	pop    %esi
    e9de:	5d                   	pop    %ebp
    e9df:	c3                   	ret    

0000e9e0 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    e9e0:	55                   	push   %ebp
    e9e1:	89 e5                	mov    %esp,%ebp
    e9e3:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    e9e6:	8b 45 10             	mov    0x10(%ebp),%eax
    e9e9:	05 98 00 00 00       	add    $0x98,%eax
    e9ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    e9f1:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    e9f5:	74 06                	je     e9fd <lodepng_inspect+0x1d>
    e9f7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    e9fb:	75 17                	jne    ea14 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    e9fd:	8b 45 10             	mov    0x10(%ebp),%eax
    ea00:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    ea07:	00 00 00 
    ea0a:	b8 30 00 00 00       	mov    $0x30,%eax
    ea0f:	e9 ce 02 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    ea14:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    ea18:	7f 17                	jg     ea31 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    ea1a:	8b 45 10             	mov    0x10(%ebp),%eax
    ea1d:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    ea24:	00 00 00 
    ea27:	b8 1b 00 00 00       	mov    $0x1b,%eax
    ea2c:	e9 b1 02 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    ea31:	83 ec 0c             	sub    $0xc,%esp
    ea34:	ff 75 f4             	pushl  -0xc(%ebp)
    ea37:	e8 63 c7 ff ff       	call   b19f <lodepng_info_cleanup>
    ea3c:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    ea3f:	83 ec 0c             	sub    $0xc,%esp
    ea42:	ff 75 f4             	pushl  -0xc(%ebp)
    ea45:	e8 74 c6 ff ff       	call   b0be <lodepng_info_init>
    ea4a:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    ea4d:	8b 45 14             	mov    0x14(%ebp),%eax
    ea50:	0f b6 00             	movzbl (%eax),%eax
    ea53:	3c 89                	cmp    $0x89,%al
    ea55:	75 5b                	jne    eab2 <lodepng_inspect+0xd2>
    ea57:	8b 45 14             	mov    0x14(%ebp),%eax
    ea5a:	83 c0 01             	add    $0x1,%eax
    ea5d:	0f b6 00             	movzbl (%eax),%eax
    ea60:	3c 50                	cmp    $0x50,%al
    ea62:	75 4e                	jne    eab2 <lodepng_inspect+0xd2>
    ea64:	8b 45 14             	mov    0x14(%ebp),%eax
    ea67:	83 c0 02             	add    $0x2,%eax
    ea6a:	0f b6 00             	movzbl (%eax),%eax
    ea6d:	3c 4e                	cmp    $0x4e,%al
    ea6f:	75 41                	jne    eab2 <lodepng_inspect+0xd2>
    ea71:	8b 45 14             	mov    0x14(%ebp),%eax
    ea74:	83 c0 03             	add    $0x3,%eax
    ea77:	0f b6 00             	movzbl (%eax),%eax
    ea7a:	3c 47                	cmp    $0x47,%al
    ea7c:	75 34                	jne    eab2 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    ea7e:	8b 45 14             	mov    0x14(%ebp),%eax
    ea81:	83 c0 04             	add    $0x4,%eax
    ea84:	0f b6 00             	movzbl (%eax),%eax
    ea87:	3c 0d                	cmp    $0xd,%al
    ea89:	75 27                	jne    eab2 <lodepng_inspect+0xd2>
    ea8b:	8b 45 14             	mov    0x14(%ebp),%eax
    ea8e:	83 c0 05             	add    $0x5,%eax
    ea91:	0f b6 00             	movzbl (%eax),%eax
    ea94:	3c 0a                	cmp    $0xa,%al
    ea96:	75 1a                	jne    eab2 <lodepng_inspect+0xd2>
    ea98:	8b 45 14             	mov    0x14(%ebp),%eax
    ea9b:	83 c0 06             	add    $0x6,%eax
    ea9e:	0f b6 00             	movzbl (%eax),%eax
    eaa1:	3c 1a                	cmp    $0x1a,%al
    eaa3:	75 0d                	jne    eab2 <lodepng_inspect+0xd2>
    eaa5:	8b 45 14             	mov    0x14(%ebp),%eax
    eaa8:	83 c0 07             	add    $0x7,%eax
    eaab:	0f b6 00             	movzbl (%eax),%eax
    eaae:	3c 0a                	cmp    $0xa,%al
    eab0:	74 17                	je     eac9 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    eab2:	8b 45 10             	mov    0x10(%ebp),%eax
    eab5:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    eabc:	00 00 00 
    eabf:	b8 1c 00 00 00       	mov    $0x1c,%eax
    eac4:	e9 19 02 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    eac9:	8b 45 14             	mov    0x14(%ebp),%eax
    eacc:	83 c0 08             	add    $0x8,%eax
    eacf:	83 ec 0c             	sub    $0xc,%esp
    ead2:	50                   	push   %eax
    ead3:	e8 c2 ae ff ff       	call   999a <lodepng_chunk_length>
    ead8:	83 c4 10             	add    $0x10,%esp
    eadb:	83 f8 0d             	cmp    $0xd,%eax
    eade:	74 17                	je     eaf7 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    eae0:	8b 45 10             	mov    0x10(%ebp),%eax
    eae3:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    eaea:	00 00 00 
    eaed:	b8 5e 00 00 00       	mov    $0x5e,%eax
    eaf2:	e9 eb 01 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    eaf7:	8b 45 14             	mov    0x14(%ebp),%eax
    eafa:	83 c0 08             	add    $0x8,%eax
    eafd:	83 ec 08             	sub    $0x8,%esp
    eb00:	68 2c b7 01 00       	push   $0x1b72c
    eb05:	50                   	push   %eax
    eb06:	e8 dc ae ff ff       	call   99e7 <lodepng_chunk_type_equals>
    eb0b:	83 c4 10             	add    $0x10,%esp
    eb0e:	84 c0                	test   %al,%al
    eb10:	75 17                	jne    eb29 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    eb12:	8b 45 10             	mov    0x10(%ebp),%eax
    eb15:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    eb1c:	00 00 00 
    eb1f:	b8 1d 00 00 00       	mov    $0x1d,%eax
    eb24:	e9 b9 01 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    eb29:	8b 45 14             	mov    0x14(%ebp),%eax
    eb2c:	83 c0 10             	add    $0x10,%eax
    eb2f:	83 ec 0c             	sub    $0xc,%esp
    eb32:	50                   	push   %eax
    eb33:	e8 5e 62 ff ff       	call   4d96 <lodepng_read32bitInt>
    eb38:	83 c4 10             	add    $0x10,%esp
    eb3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    eb3e:	8b 45 14             	mov    0x14(%ebp),%eax
    eb41:	83 c0 14             	add    $0x14,%eax
    eb44:	83 ec 0c             	sub    $0xc,%esp
    eb47:	50                   	push   %eax
    eb48:	e8 49 62 ff ff       	call   4d96 <lodepng_read32bitInt>
    eb4d:	83 c4 10             	add    $0x10,%esp
    eb50:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    eb53:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    eb57:	74 08                	je     eb61 <lodepng_inspect+0x181>
    eb59:	8b 45 08             	mov    0x8(%ebp),%eax
    eb5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eb5f:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    eb61:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    eb65:	74 08                	je     eb6f <lodepng_inspect+0x18f>
    eb67:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eb6d:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    eb6f:	8b 45 14             	mov    0x14(%ebp),%eax
    eb72:	83 c0 18             	add    $0x18,%eax
    eb75:	0f b6 00             	movzbl (%eax),%eax
    eb78:	0f b6 d0             	movzbl %al,%edx
    eb7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb7e:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    eb81:	8b 45 14             	mov    0x14(%ebp),%eax
    eb84:	83 c0 19             	add    $0x19,%eax
    eb87:	0f b6 00             	movzbl (%eax),%eax
    eb8a:	0f b6 d0             	movzbl %al,%edx
    eb8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb90:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    eb93:	8b 45 14             	mov    0x14(%ebp),%eax
    eb96:	83 c0 1a             	add    $0x1a,%eax
    eb99:	0f b6 00             	movzbl (%eax),%eax
    eb9c:	0f b6 d0             	movzbl %al,%edx
    eb9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eba2:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    eba4:	8b 45 14             	mov    0x14(%ebp),%eax
    eba7:	83 c0 1b             	add    $0x1b,%eax
    ebaa:	0f b6 00             	movzbl (%eax),%eax
    ebad:	0f b6 d0             	movzbl %al,%edx
    ebb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ebb3:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    ebb6:	8b 45 14             	mov    0x14(%ebp),%eax
    ebb9:	83 c0 1c             	add    $0x1c,%eax
    ebbc:	0f b6 00             	movzbl (%eax),%eax
    ebbf:	0f b6 d0             	movzbl %al,%edx
    ebc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ebc5:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    ebc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ebcc:	74 06                	je     ebd4 <lodepng_inspect+0x1f4>
    ebce:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ebd2:	75 17                	jne    ebeb <lodepng_inspect+0x20b>
    ebd4:	8b 45 10             	mov    0x10(%ebp),%eax
    ebd7:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    ebde:	00 00 00 
    ebe1:	b8 5d 00 00 00       	mov    $0x5d,%eax
    ebe6:	e9 f7 00 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    ebeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ebee:	8b 50 10             	mov    0x10(%eax),%edx
    ebf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ebf4:	8b 40 0c             	mov    0xc(%eax),%eax
    ebf7:	83 ec 08             	sub    $0x8,%esp
    ebfa:	52                   	push   %edx
    ebfb:	50                   	push   %eax
    ebfc:	e8 d4 b3 ff ff       	call   9fd5 <checkColorValidity>
    ec01:	83 c4 10             	add    $0x10,%esp
    ec04:	89 c2                	mov    %eax,%edx
    ec06:	8b 45 10             	mov    0x10(%ebp),%eax
    ec09:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    ec0f:	8b 45 10             	mov    0x10(%ebp),%eax
    ec12:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ec18:	85 c0                	test   %eax,%eax
    ec1a:	74 0e                	je     ec2a <lodepng_inspect+0x24a>
    ec1c:	8b 45 10             	mov    0x10(%ebp),%eax
    ec1f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ec25:	e9 b8 00 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    ec2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec2d:	8b 00                	mov    (%eax),%eax
    ec2f:	85 c0                	test   %eax,%eax
    ec31:	74 17                	je     ec4a <lodepng_inspect+0x26a>
    ec33:	8b 45 10             	mov    0x10(%ebp),%eax
    ec36:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    ec3d:	00 00 00 
    ec40:	b8 20 00 00 00       	mov    $0x20,%eax
    ec45:	e9 98 00 00 00       	jmp    ece2 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    ec4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec4d:	8b 40 04             	mov    0x4(%eax),%eax
    ec50:	85 c0                	test   %eax,%eax
    ec52:	74 14                	je     ec68 <lodepng_inspect+0x288>
    ec54:	8b 45 10             	mov    0x10(%ebp),%eax
    ec57:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    ec5e:	00 00 00 
    ec61:	b8 21 00 00 00       	mov    $0x21,%eax
    ec66:	eb 7a                	jmp    ece2 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    ec68:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec6b:	8b 40 08             	mov    0x8(%eax),%eax
    ec6e:	83 f8 01             	cmp    $0x1,%eax
    ec71:	76 14                	jbe    ec87 <lodepng_inspect+0x2a7>
    ec73:	8b 45 10             	mov    0x10(%ebp),%eax
    ec76:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    ec7d:	00 00 00 
    ec80:	b8 22 00 00 00       	mov    $0x22,%eax
    ec85:	eb 5b                	jmp    ece2 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    ec87:	8b 45 10             	mov    0x10(%ebp),%eax
    ec8a:	8b 40 18             	mov    0x18(%eax),%eax
    ec8d:	85 c0                	test   %eax,%eax
    ec8f:	75 48                	jne    ecd9 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    ec91:	8b 45 14             	mov    0x14(%ebp),%eax
    ec94:	83 c0 1d             	add    $0x1d,%eax
    ec97:	83 ec 0c             	sub    $0xc,%esp
    ec9a:	50                   	push   %eax
    ec9b:	e8 f6 60 ff ff       	call   4d96 <lodepng_read32bitInt>
    eca0:	83 c4 10             	add    $0x10,%esp
    eca3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    eca6:	8b 45 14             	mov    0x14(%ebp),%eax
    eca9:	83 c0 0c             	add    $0xc,%eax
    ecac:	83 ec 08             	sub    $0x8,%esp
    ecaf:	6a 11                	push   $0x11
    ecb1:	50                   	push   %eax
    ecb2:	e8 71 ab ff ff       	call   9828 <lodepng_crc32>
    ecb7:	83 c4 10             	add    $0x10,%esp
    ecba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    ecbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ecc0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    ecc3:	74 14                	je     ecd9 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    ecc5:	8b 45 10             	mov    0x10(%ebp),%eax
    ecc8:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    eccf:	00 00 00 
    ecd2:	b8 39 00 00 00       	mov    $0x39,%eax
    ecd7:	eb 09                	jmp    ece2 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    ecd9:	8b 45 10             	mov    0x10(%ebp),%eax
    ecdc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    ece2:	c9                   	leave  
    ece3:	c3                   	ret    

0000ece4 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    ece4:	55                   	push   %ebp
    ece5:	89 e5                	mov    %esp,%ebp
    ece7:	56                   	push   %esi
    ece8:	53                   	push   %ebx
    ece9:	83 ec 44             	sub    $0x44,%esp
    ecec:	8b 45 18             	mov    0x18(%ebp),%eax
    ecef:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    ecf2:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    ecf6:	83 f8 04             	cmp    $0x4,%eax
    ecf9:	0f 87 81 07 00 00    	ja     f480 <unfilterScanline+0x79c>
    ecff:	8b 04 85 34 b7 01 00 	mov    0x1b734(,%eax,4),%eax
    ed06:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    ed08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ed0f:	eb 19                	jmp    ed2a <unfilterScanline+0x46>
    ed11:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ed14:	8b 45 08             	mov    0x8(%ebp),%eax
    ed17:	01 c2                	add    %eax,%edx
    ed19:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ed1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed1f:	01 c8                	add    %ecx,%eax
    ed21:	0f b6 00             	movzbl (%eax),%eax
    ed24:	88 02                	mov    %al,(%edx)
    ed26:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ed2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed2d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ed30:	75 df                	jne    ed11 <unfilterScanline+0x2d>
      break;
    ed32:	e9 50 07 00 00       	jmp    f487 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    ed37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ed3e:	eb 19                	jmp    ed59 <unfilterScanline+0x75>
    ed40:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ed43:	8b 45 08             	mov    0x8(%ebp),%eax
    ed46:	01 c2                	add    %eax,%edx
    ed48:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ed4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed4e:	01 c8                	add    %ecx,%eax
    ed50:	0f b6 00             	movzbl (%eax),%eax
    ed53:	88 02                	mov    %al,(%edx)
    ed55:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ed59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed5c:	3b 45 14             	cmp    0x14(%ebp),%eax
    ed5f:	75 df                	jne    ed40 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    ed61:	8b 45 14             	mov    0x14(%ebp),%eax
    ed64:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ed67:	eb 2b                	jmp    ed94 <unfilterScanline+0xb0>
    ed69:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ed6c:	8b 45 08             	mov    0x8(%ebp),%eax
    ed6f:	01 c2                	add    %eax,%edx
    ed71:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ed74:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed77:	01 c8                	add    %ecx,%eax
    ed79:	0f b6 08             	movzbl (%eax),%ecx
    ed7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed7f:	2b 45 14             	sub    0x14(%ebp),%eax
    ed82:	89 c3                	mov    %eax,%ebx
    ed84:	8b 45 08             	mov    0x8(%ebp),%eax
    ed87:	01 d8                	add    %ebx,%eax
    ed89:	0f b6 00             	movzbl (%eax),%eax
    ed8c:	01 c8                	add    %ecx,%eax
    ed8e:	88 02                	mov    %al,(%edx)
    ed90:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ed94:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed97:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ed9a:	7c cd                	jl     ed69 <unfilterScanline+0x85>
      break;
    ed9c:	e9 e6 06 00 00       	jmp    f487 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    eda1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    eda5:	74 3c                	je     ede3 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    eda7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    edae:	eb 26                	jmp    edd6 <unfilterScanline+0xf2>
    edb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    edb3:	8b 45 08             	mov    0x8(%ebp),%eax
    edb6:	01 d0                	add    %edx,%eax
    edb8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    edbb:	8b 55 0c             	mov    0xc(%ebp),%edx
    edbe:	01 ca                	add    %ecx,%edx
    edc0:	0f b6 0a             	movzbl (%edx),%ecx
    edc3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    edc6:	8b 55 10             	mov    0x10(%ebp),%edx
    edc9:	01 da                	add    %ebx,%edx
    edcb:	0f b6 12             	movzbl (%edx),%edx
    edce:	01 ca                	add    %ecx,%edx
    edd0:	88 10                	mov    %dl,(%eax)
    edd2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    edd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    edd9:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    eddc:	75 d2                	jne    edb0 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    edde:	e9 a4 06 00 00       	jmp    f487 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    ede3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    edea:	eb 19                	jmp    ee05 <unfilterScanline+0x121>
    edec:	8b 55 f4             	mov    -0xc(%ebp),%edx
    edef:	8b 45 08             	mov    0x8(%ebp),%eax
    edf2:	01 c2                	add    %eax,%edx
    edf4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    edf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    edfa:	01 c8                	add    %ecx,%eax
    edfc:	0f b6 00             	movzbl (%eax),%eax
    edff:	88 02                	mov    %al,(%edx)
    ee01:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ee05:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee08:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ee0b:	75 df                	jne    edec <unfilterScanline+0x108>
      }
      break;
    ee0d:	e9 75 06 00 00       	jmp    f487 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    ee12:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    ee16:	0f 84 8e 00 00 00    	je     eeaa <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    ee1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ee23:	eb 28                	jmp    ee4d <unfilterScanline+0x169>
    ee25:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ee28:	8b 45 08             	mov    0x8(%ebp),%eax
    ee2b:	01 d0                	add    %edx,%eax
    ee2d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ee30:	8b 55 0c             	mov    0xc(%ebp),%edx
    ee33:	01 ca                	add    %ecx,%edx
    ee35:	0f b6 12             	movzbl (%edx),%edx
    ee38:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ee3b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ee3e:	01 d9                	add    %ebx,%ecx
    ee40:	0f b6 09             	movzbl (%ecx),%ecx
    ee43:	d0 e9                	shr    %cl
    ee45:	01 ca                	add    %ecx,%edx
    ee47:	88 10                	mov    %dl,(%eax)
    ee49:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ee4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee50:	3b 45 14             	cmp    0x14(%ebp),%eax
    ee53:	75 d0                	jne    ee25 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    ee55:	8b 45 14             	mov    0x14(%ebp),%eax
    ee58:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ee5b:	eb 40                	jmp    ee9d <unfilterScanline+0x1b9>
    ee5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ee60:	8b 45 08             	mov    0x8(%ebp),%eax
    ee63:	01 c2                	add    %eax,%edx
    ee65:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ee68:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee6b:	01 c8                	add    %ecx,%eax
    ee6d:	0f b6 08             	movzbl (%eax),%ecx
    ee70:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee73:	2b 45 14             	sub    0x14(%ebp),%eax
    ee76:	89 c3                	mov    %eax,%ebx
    ee78:	8b 45 08             	mov    0x8(%ebp),%eax
    ee7b:	01 d8                	add    %ebx,%eax
    ee7d:	0f b6 00             	movzbl (%eax),%eax
    ee80:	0f b6 d8             	movzbl %al,%ebx
    ee83:	8b 75 f4             	mov    -0xc(%ebp),%esi
    ee86:	8b 45 10             	mov    0x10(%ebp),%eax
    ee89:	01 f0                	add    %esi,%eax
    ee8b:	0f b6 00             	movzbl (%eax),%eax
    ee8e:	0f b6 c0             	movzbl %al,%eax
    ee91:	01 d8                	add    %ebx,%eax
    ee93:	d1 f8                	sar    %eax
    ee95:	01 c8                	add    %ecx,%eax
    ee97:	88 02                	mov    %al,(%edx)
    ee99:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ee9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eea0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    eea3:	7c b8                	jl     ee5d <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    eea5:	e9 dd 05 00 00       	jmp    f487 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    eeaa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    eeb1:	eb 19                	jmp    eecc <unfilterScanline+0x1e8>
    eeb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    eeb6:	8b 45 08             	mov    0x8(%ebp),%eax
    eeb9:	01 c2                	add    %eax,%edx
    eebb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    eebe:	8b 45 0c             	mov    0xc(%ebp),%eax
    eec1:	01 c8                	add    %ecx,%eax
    eec3:	0f b6 00             	movzbl (%eax),%eax
    eec6:	88 02                	mov    %al,(%edx)
    eec8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    eecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eecf:	3b 45 14             	cmp    0x14(%ebp),%eax
    eed2:	75 df                	jne    eeb3 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    eed4:	8b 45 14             	mov    0x14(%ebp),%eax
    eed7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    eeda:	eb 2d                	jmp    ef09 <unfilterScanline+0x225>
    eedc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    eedf:	8b 45 08             	mov    0x8(%ebp),%eax
    eee2:	01 c2                	add    %eax,%edx
    eee4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    eee7:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeea:	01 c8                	add    %ecx,%eax
    eeec:	0f b6 08             	movzbl (%eax),%ecx
    eeef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eef2:	2b 45 14             	sub    0x14(%ebp),%eax
    eef5:	89 c3                	mov    %eax,%ebx
    eef7:	8b 45 08             	mov    0x8(%ebp),%eax
    eefa:	01 d8                	add    %ebx,%eax
    eefc:	0f b6 00             	movzbl (%eax),%eax
    eeff:	d0 e8                	shr    %al
    ef01:	01 c8                	add    %ecx,%eax
    ef03:	88 02                	mov    %al,(%edx)
    ef05:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ef09:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef0c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ef0f:	7c cb                	jl     eedc <unfilterScanline+0x1f8>
      }
      break;
    ef11:	e9 71 05 00 00       	jmp    f487 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    ef16:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    ef1a:	0f 84 f9 04 00 00    	je     f419 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    ef20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ef27:	eb 26                	jmp    ef4f <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    ef29:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ef2c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef2f:	01 d0                	add    %edx,%eax
    ef31:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ef34:	8b 55 0c             	mov    0xc(%ebp),%edx
    ef37:	01 ca                	add    %ecx,%edx
    ef39:	0f b6 0a             	movzbl (%edx),%ecx
    ef3c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ef3f:	8b 55 10             	mov    0x10(%ebp),%edx
    ef42:	01 da                	add    %ebx,%edx
    ef44:	0f b6 12             	movzbl (%edx),%edx
    ef47:	01 ca                	add    %ecx,%edx
    ef49:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    ef4b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ef4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef52:	3b 45 14             	cmp    0x14(%ebp),%eax
    ef55:	75 d2                	jne    ef29 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    ef57:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    ef5b:	0f 8e db 01 00 00    	jle    f13c <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    ef61:	e9 c2 01 00 00       	jmp    f128 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    ef66:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef69:	2b 45 14             	sub    0x14(%ebp),%eax
    ef6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    ef6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ef72:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef75:	01 d0                	add    %edx,%eax
    ef77:	0f b6 00             	movzbl (%eax),%eax
    ef7a:	88 45 ef             	mov    %al,-0x11(%ebp)
    ef7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef80:	8d 50 01             	lea    0x1(%eax),%edx
    ef83:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef86:	01 d0                	add    %edx,%eax
    ef88:	0f b6 00             	movzbl (%eax),%eax
    ef8b:	88 45 ee             	mov    %al,-0x12(%ebp)
    ef8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef91:	8d 50 02             	lea    0x2(%eax),%edx
    ef94:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef97:	01 d0                	add    %edx,%eax
    ef99:	0f b6 00             	movzbl (%eax),%eax
    ef9c:	88 45 ed             	mov    %al,-0x13(%ebp)
    ef9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    efa2:	8d 50 03             	lea    0x3(%eax),%edx
    efa5:	8b 45 0c             	mov    0xc(%ebp),%eax
    efa8:	01 d0                	add    %edx,%eax
    efaa:	0f b6 00             	movzbl (%eax),%eax
    efad:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    efb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    efb3:	8b 45 08             	mov    0x8(%ebp),%eax
    efb6:	01 d0                	add    %edx,%eax
    efb8:	0f b6 00             	movzbl (%eax),%eax
    efbb:	88 45 eb             	mov    %al,-0x15(%ebp)
    efbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    efc1:	8d 50 01             	lea    0x1(%eax),%edx
    efc4:	8b 45 08             	mov    0x8(%ebp),%eax
    efc7:	01 d0                	add    %edx,%eax
    efc9:	0f b6 00             	movzbl (%eax),%eax
    efcc:	88 45 ea             	mov    %al,-0x16(%ebp)
    efcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    efd2:	8d 50 02             	lea    0x2(%eax),%edx
    efd5:	8b 45 08             	mov    0x8(%ebp),%eax
    efd8:	01 d0                	add    %edx,%eax
    efda:	0f b6 00             	movzbl (%eax),%eax
    efdd:	88 45 e9             	mov    %al,-0x17(%ebp)
    efe0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    efe3:	8d 50 03             	lea    0x3(%eax),%edx
    efe6:	8b 45 08             	mov    0x8(%ebp),%eax
    efe9:	01 d0                	add    %edx,%eax
    efeb:	0f b6 00             	movzbl (%eax),%eax
    efee:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    eff1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    eff4:	8b 45 10             	mov    0x10(%ebp),%eax
    eff7:	01 d0                	add    %edx,%eax
    eff9:	0f b6 00             	movzbl (%eax),%eax
    effc:	88 45 e7             	mov    %al,-0x19(%ebp)
    efff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f002:	8d 50 01             	lea    0x1(%eax),%edx
    f005:	8b 45 10             	mov    0x10(%ebp),%eax
    f008:	01 d0                	add    %edx,%eax
    f00a:	0f b6 00             	movzbl (%eax),%eax
    f00d:	88 45 e6             	mov    %al,-0x1a(%ebp)
    f010:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f013:	8d 50 02             	lea    0x2(%eax),%edx
    f016:	8b 45 10             	mov    0x10(%ebp),%eax
    f019:	01 d0                	add    %edx,%eax
    f01b:	0f b6 00             	movzbl (%eax),%eax
    f01e:	88 45 e5             	mov    %al,-0x1b(%ebp)
    f021:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f024:	8d 50 03             	lea    0x3(%eax),%edx
    f027:	8b 45 10             	mov    0x10(%ebp),%eax
    f02a:	01 d0                	add    %edx,%eax
    f02c:	0f b6 00             	movzbl (%eax),%eax
    f02f:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    f032:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f035:	8b 45 10             	mov    0x10(%ebp),%eax
    f038:	01 d0                	add    %edx,%eax
    f03a:	0f b6 00             	movzbl (%eax),%eax
    f03d:	88 45 e3             	mov    %al,-0x1d(%ebp)
    f040:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f043:	8d 50 01             	lea    0x1(%eax),%edx
    f046:	8b 45 10             	mov    0x10(%ebp),%eax
    f049:	01 d0                	add    %edx,%eax
    f04b:	0f b6 00             	movzbl (%eax),%eax
    f04e:	88 45 e2             	mov    %al,-0x1e(%ebp)
    f051:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f054:	8d 50 02             	lea    0x2(%eax),%edx
    f057:	8b 45 10             	mov    0x10(%ebp),%eax
    f05a:	01 d0                	add    %edx,%eax
    f05c:	0f b6 00             	movzbl (%eax),%eax
    f05f:	88 45 e1             	mov    %al,-0x1f(%ebp)
    f062:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f065:	8d 50 03             	lea    0x3(%eax),%edx
    f068:	8b 45 10             	mov    0x10(%ebp),%eax
    f06b:	01 d0                	add    %edx,%eax
    f06d:	0f b6 00             	movzbl (%eax),%eax
    f070:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    f073:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f076:	8b 45 08             	mov    0x8(%ebp),%eax
    f079:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f07c:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    f080:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    f084:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    f088:	51                   	push   %ecx
    f089:	52                   	push   %edx
    f08a:	50                   	push   %eax
    f08b:	e8 3f f6 ff ff       	call   e6cf <paethPredictor>
    f090:	83 c4 0c             	add    $0xc,%esp
    f093:	89 c2                	mov    %eax,%edx
    f095:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    f099:	01 d0                	add    %edx,%eax
    f09b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    f09d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f0a0:	8d 50 01             	lea    0x1(%eax),%edx
    f0a3:	8b 45 08             	mov    0x8(%ebp),%eax
    f0a6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f0a9:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    f0ad:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    f0b1:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    f0b5:	51                   	push   %ecx
    f0b6:	52                   	push   %edx
    f0b7:	50                   	push   %eax
    f0b8:	e8 12 f6 ff ff       	call   e6cf <paethPredictor>
    f0bd:	83 c4 0c             	add    $0xc,%esp
    f0c0:	89 c2                	mov    %eax,%edx
    f0c2:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    f0c6:	01 d0                	add    %edx,%eax
    f0c8:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    f0ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f0cd:	8d 50 02             	lea    0x2(%eax),%edx
    f0d0:	8b 45 08             	mov    0x8(%ebp),%eax
    f0d3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f0d6:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    f0da:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    f0de:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    f0e2:	51                   	push   %ecx
    f0e3:	52                   	push   %edx
    f0e4:	50                   	push   %eax
    f0e5:	e8 e5 f5 ff ff       	call   e6cf <paethPredictor>
    f0ea:	83 c4 0c             	add    $0xc,%esp
    f0ed:	89 c2                	mov    %eax,%edx
    f0ef:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    f0f3:	01 d0                	add    %edx,%eax
    f0f5:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    f0f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f0fa:	8d 50 03             	lea    0x3(%eax),%edx
    f0fd:	8b 45 08             	mov    0x8(%ebp),%eax
    f100:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f103:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    f107:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    f10b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    f10f:	51                   	push   %ecx
    f110:	52                   	push   %edx
    f111:	50                   	push   %eax
    f112:	e8 b8 f5 ff ff       	call   e6cf <paethPredictor>
    f117:	83 c4 0c             	add    $0xc,%esp
    f11a:	89 c2                	mov    %eax,%edx
    f11c:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    f120:	01 d0                	add    %edx,%eax
    f122:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    f124:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    f128:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f12b:	83 c0 03             	add    $0x3,%eax
    f12e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f131:	0f 8c 2f fe ff ff    	jl     ef66 <unfilterScanline+0x282>
    f137:	e9 d3 02 00 00       	jmp    f40f <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    f13c:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    f140:	0f 8e 6a 01 00 00    	jle    f2b0 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    f146:	e9 51 01 00 00       	jmp    f29c <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    f14b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f14e:	2b 45 14             	sub    0x14(%ebp),%eax
    f151:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    f154:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f157:	8b 45 0c             	mov    0xc(%ebp),%eax
    f15a:	01 d0                	add    %edx,%eax
    f15c:	0f b6 00             	movzbl (%eax),%eax
    f15f:	88 45 db             	mov    %al,-0x25(%ebp)
    f162:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f165:	8d 50 01             	lea    0x1(%eax),%edx
    f168:	8b 45 0c             	mov    0xc(%ebp),%eax
    f16b:	01 d0                	add    %edx,%eax
    f16d:	0f b6 00             	movzbl (%eax),%eax
    f170:	88 45 da             	mov    %al,-0x26(%ebp)
    f173:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f176:	8d 50 02             	lea    0x2(%eax),%edx
    f179:	8b 45 0c             	mov    0xc(%ebp),%eax
    f17c:	01 d0                	add    %edx,%eax
    f17e:	0f b6 00             	movzbl (%eax),%eax
    f181:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    f184:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f187:	8b 45 08             	mov    0x8(%ebp),%eax
    f18a:	01 d0                	add    %edx,%eax
    f18c:	0f b6 00             	movzbl (%eax),%eax
    f18f:	88 45 d8             	mov    %al,-0x28(%ebp)
    f192:	8b 45 dc             	mov    -0x24(%ebp),%eax
    f195:	8d 50 01             	lea    0x1(%eax),%edx
    f198:	8b 45 08             	mov    0x8(%ebp),%eax
    f19b:	01 d0                	add    %edx,%eax
    f19d:	0f b6 00             	movzbl (%eax),%eax
    f1a0:	88 45 d7             	mov    %al,-0x29(%ebp)
    f1a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    f1a6:	8d 50 02             	lea    0x2(%eax),%edx
    f1a9:	8b 45 08             	mov    0x8(%ebp),%eax
    f1ac:	01 d0                	add    %edx,%eax
    f1ae:	0f b6 00             	movzbl (%eax),%eax
    f1b1:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    f1b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f1b7:	8b 45 10             	mov    0x10(%ebp),%eax
    f1ba:	01 d0                	add    %edx,%eax
    f1bc:	0f b6 00             	movzbl (%eax),%eax
    f1bf:	88 45 d5             	mov    %al,-0x2b(%ebp)
    f1c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f1c5:	8d 50 01             	lea    0x1(%eax),%edx
    f1c8:	8b 45 10             	mov    0x10(%ebp),%eax
    f1cb:	01 d0                	add    %edx,%eax
    f1cd:	0f b6 00             	movzbl (%eax),%eax
    f1d0:	88 45 d4             	mov    %al,-0x2c(%ebp)
    f1d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f1d6:	8d 50 02             	lea    0x2(%eax),%edx
    f1d9:	8b 45 10             	mov    0x10(%ebp),%eax
    f1dc:	01 d0                	add    %edx,%eax
    f1de:	0f b6 00             	movzbl (%eax),%eax
    f1e1:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    f1e4:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f1e7:	8b 45 10             	mov    0x10(%ebp),%eax
    f1ea:	01 d0                	add    %edx,%eax
    f1ec:	0f b6 00             	movzbl (%eax),%eax
    f1ef:	88 45 d2             	mov    %al,-0x2e(%ebp)
    f1f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    f1f5:	8d 50 01             	lea    0x1(%eax),%edx
    f1f8:	8b 45 10             	mov    0x10(%ebp),%eax
    f1fb:	01 d0                	add    %edx,%eax
    f1fd:	0f b6 00             	movzbl (%eax),%eax
    f200:	88 45 d1             	mov    %al,-0x2f(%ebp)
    f203:	8b 45 dc             	mov    -0x24(%ebp),%eax
    f206:	8d 50 02             	lea    0x2(%eax),%edx
    f209:	8b 45 10             	mov    0x10(%ebp),%eax
    f20c:	01 d0                	add    %edx,%eax
    f20e:	0f b6 00             	movzbl (%eax),%eax
    f211:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    f214:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f217:	8b 45 08             	mov    0x8(%ebp),%eax
    f21a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f21d:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    f221:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    f225:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    f229:	51                   	push   %ecx
    f22a:	52                   	push   %edx
    f22b:	50                   	push   %eax
    f22c:	e8 9e f4 ff ff       	call   e6cf <paethPredictor>
    f231:	83 c4 0c             	add    $0xc,%esp
    f234:	89 c2                	mov    %eax,%edx
    f236:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    f23a:	01 d0                	add    %edx,%eax
    f23c:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    f23e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f241:	8d 50 01             	lea    0x1(%eax),%edx
    f244:	8b 45 08             	mov    0x8(%ebp),%eax
    f247:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f24a:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    f24e:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    f252:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    f256:	51                   	push   %ecx
    f257:	52                   	push   %edx
    f258:	50                   	push   %eax
    f259:	e8 71 f4 ff ff       	call   e6cf <paethPredictor>
    f25e:	83 c4 0c             	add    $0xc,%esp
    f261:	89 c2                	mov    %eax,%edx
    f263:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    f267:	01 d0                	add    %edx,%eax
    f269:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    f26b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f26e:	8d 50 02             	lea    0x2(%eax),%edx
    f271:	8b 45 08             	mov    0x8(%ebp),%eax
    f274:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f277:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    f27b:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    f27f:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    f283:	51                   	push   %ecx
    f284:	52                   	push   %edx
    f285:	50                   	push   %eax
    f286:	e8 44 f4 ff ff       	call   e6cf <paethPredictor>
    f28b:	83 c4 0c             	add    $0xc,%esp
    f28e:	89 c2                	mov    %eax,%edx
    f290:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    f294:	01 d0                	add    %edx,%eax
    f296:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    f298:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    f29c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f29f:	83 c0 02             	add    $0x2,%eax
    f2a2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f2a5:	0f 8c a0 fe ff ff    	jl     f14b <unfilterScanline+0x467>
    f2ab:	e9 5f 01 00 00       	jmp    f40f <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    f2b0:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    f2b4:	0f 8e 55 01 00 00    	jle    f40f <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    f2ba:	e9 e0 00 00 00       	jmp    f39f <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    f2bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f2c2:	2b 45 14             	sub    0x14(%ebp),%eax
    f2c5:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    f2c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f2cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2ce:	01 d0                	add    %edx,%eax
    f2d0:	0f b6 00             	movzbl (%eax),%eax
    f2d3:	88 45 cb             	mov    %al,-0x35(%ebp)
    f2d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f2d9:	8d 50 01             	lea    0x1(%eax),%edx
    f2dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2df:	01 d0                	add    %edx,%eax
    f2e1:	0f b6 00             	movzbl (%eax),%eax
    f2e4:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    f2e7:	8b 55 cc             	mov    -0x34(%ebp),%edx
    f2ea:	8b 45 08             	mov    0x8(%ebp),%eax
    f2ed:	01 d0                	add    %edx,%eax
    f2ef:	0f b6 00             	movzbl (%eax),%eax
    f2f2:	88 45 c9             	mov    %al,-0x37(%ebp)
    f2f5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    f2f8:	8d 50 01             	lea    0x1(%eax),%edx
    f2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    f2fe:	01 d0                	add    %edx,%eax
    f300:	0f b6 00             	movzbl (%eax),%eax
    f303:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    f306:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f309:	8b 45 10             	mov    0x10(%ebp),%eax
    f30c:	01 d0                	add    %edx,%eax
    f30e:	0f b6 00             	movzbl (%eax),%eax
    f311:	88 45 c7             	mov    %al,-0x39(%ebp)
    f314:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f317:	8d 50 01             	lea    0x1(%eax),%edx
    f31a:	8b 45 10             	mov    0x10(%ebp),%eax
    f31d:	01 d0                	add    %edx,%eax
    f31f:	0f b6 00             	movzbl (%eax),%eax
    f322:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    f325:	8b 55 cc             	mov    -0x34(%ebp),%edx
    f328:	8b 45 10             	mov    0x10(%ebp),%eax
    f32b:	01 d0                	add    %edx,%eax
    f32d:	0f b6 00             	movzbl (%eax),%eax
    f330:	88 45 c5             	mov    %al,-0x3b(%ebp)
    f333:	8b 45 cc             	mov    -0x34(%ebp),%eax
    f336:	8d 50 01             	lea    0x1(%eax),%edx
    f339:	8b 45 10             	mov    0x10(%ebp),%eax
    f33c:	01 d0                	add    %edx,%eax
    f33e:	0f b6 00             	movzbl (%eax),%eax
    f341:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    f344:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f347:	8b 45 08             	mov    0x8(%ebp),%eax
    f34a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f34d:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    f351:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    f355:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    f359:	51                   	push   %ecx
    f35a:	52                   	push   %edx
    f35b:	50                   	push   %eax
    f35c:	e8 6e f3 ff ff       	call   e6cf <paethPredictor>
    f361:	83 c4 0c             	add    $0xc,%esp
    f364:	89 c2                	mov    %eax,%edx
    f366:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    f36a:	01 d0                	add    %edx,%eax
    f36c:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    f36e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f371:	8d 50 01             	lea    0x1(%eax),%edx
    f374:	8b 45 08             	mov    0x8(%ebp),%eax
    f377:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f37a:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    f37e:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    f382:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    f386:	51                   	push   %ecx
    f387:	52                   	push   %edx
    f388:	50                   	push   %eax
    f389:	e8 41 f3 ff ff       	call   e6cf <paethPredictor>
    f38e:	83 c4 0c             	add    $0xc,%esp
    f391:	89 c2                	mov    %eax,%edx
    f393:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    f397:	01 d0                	add    %edx,%eax
    f399:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    f39b:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    f39f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f3a2:	83 c0 01             	add    $0x1,%eax
    f3a5:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f3a8:	0f 8c 11 ff ff ff    	jl     f2bf <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    f3ae:	eb 5f                	jmp    f40f <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    f3b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f3b3:	8b 45 08             	mov    0x8(%ebp),%eax
    f3b6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    f3b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f3bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3bf:	01 d0                	add    %edx,%eax
    f3c1:	0f b6 00             	movzbl (%eax),%eax
    f3c4:	88 45 b7             	mov    %al,-0x49(%ebp)
    f3c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f3ca:	2b 45 14             	sub    0x14(%ebp),%eax
    f3cd:	89 c2                	mov    %eax,%edx
    f3cf:	8b 45 10             	mov    0x10(%ebp),%eax
    f3d2:	01 d0                	add    %edx,%eax
    f3d4:	0f b6 00             	movzbl (%eax),%eax
    f3d7:	0f b6 c8             	movzbl %al,%ecx
    f3da:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f3dd:	8b 45 10             	mov    0x10(%ebp),%eax
    f3e0:	01 d0                	add    %edx,%eax
    f3e2:	0f b6 00             	movzbl (%eax),%eax
    f3e5:	0f b6 d0             	movzbl %al,%edx
    f3e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f3eb:	2b 45 14             	sub    0x14(%ebp),%eax
    f3ee:	89 c6                	mov    %eax,%esi
    f3f0:	8b 45 08             	mov    0x8(%ebp),%eax
    f3f3:	01 f0                	add    %esi,%eax
    f3f5:	0f b6 00             	movzbl (%eax),%eax
    f3f8:	0f b6 c0             	movzbl %al,%eax
    f3fb:	51                   	push   %ecx
    f3fc:	52                   	push   %edx
    f3fd:	50                   	push   %eax
    f3fe:	e8 cc f2 ff ff       	call   e6cf <paethPredictor>
    f403:	83 c4 0c             	add    $0xc,%esp
    f406:	02 45 b7             	add    -0x49(%ebp),%al
    f409:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    f40b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f40f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f412:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f415:	75 99                	jne    f3b0 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    f417:	eb 6e                	jmp    f487 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    f419:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    f420:	eb 19                	jmp    f43b <unfilterScanline+0x757>
          recon[i] = scanline[i];
    f422:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f425:	8b 45 08             	mov    0x8(%ebp),%eax
    f428:	01 c2                	add    %eax,%edx
    f42a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    f42d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f430:	01 c8                	add    %ecx,%eax
    f432:	0f b6 00             	movzbl (%eax),%eax
    f435:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    f437:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f43b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f43e:	3b 45 14             	cmp    0x14(%ebp),%eax
    f441:	75 df                	jne    f422 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    f443:	8b 45 14             	mov    0x14(%ebp),%eax
    f446:	89 45 f4             	mov    %eax,-0xc(%ebp)
    f449:	eb 2b                	jmp    f476 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    f44b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f44e:	8b 45 08             	mov    0x8(%ebp),%eax
    f451:	01 c2                	add    %eax,%edx
    f453:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    f456:	8b 45 0c             	mov    0xc(%ebp),%eax
    f459:	01 c8                	add    %ecx,%eax
    f45b:	0f b6 08             	movzbl (%eax),%ecx
    f45e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f461:	2b 45 14             	sub    0x14(%ebp),%eax
    f464:	89 c3                	mov    %eax,%ebx
    f466:	8b 45 08             	mov    0x8(%ebp),%eax
    f469:	01 d8                	add    %ebx,%eax
    f46b:	0f b6 00             	movzbl (%eax),%eax
    f46e:	01 c8                	add    %ecx,%eax
    f470:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    f472:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f476:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f479:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f47c:	7c cd                	jl     f44b <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    f47e:	eb 07                	jmp    f487 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    f480:	b8 24 00 00 00       	mov    $0x24,%eax
    f485:	eb 05                	jmp    f48c <unfilterScanline+0x7a8>
  }
  return 0;
    f487:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f48c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f48f:	5b                   	pop    %ebx
    f490:	5e                   	pop    %esi
    f491:	5d                   	pop    %ebp
    f492:	c3                   	ret    

0000f493 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    f493:	55                   	push   %ebp
    f494:	89 e5                	mov    %esp,%ebp
    f496:	53                   	push   %ebx
    f497:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    f49a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    f4a1:	8b 45 18             	mov    0x18(%ebp),%eax
    f4a4:	83 c0 07             	add    $0x7,%eax
    f4a7:	c1 e8 03             	shr    $0x3,%eax
    f4aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    f4ad:	ff 75 18             	pushl  0x18(%ebp)
    f4b0:	6a 01                	push   $0x1
    f4b2:	ff 75 10             	pushl  0x10(%ebp)
    f4b5:	e8 d9 b1 ff ff       	call   a693 <lodepng_get_raw_size_idat>
    f4ba:	83 c4 0c             	add    $0xc,%esp
    f4bd:	83 e8 01             	sub    $0x1,%eax
    f4c0:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    f4c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f4ca:	eb 6d                	jmp    f539 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    f4cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f4cf:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    f4d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    f4d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f4d9:	83 c0 01             	add    $0x1,%eax
    f4dc:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    f4e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    f4e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f4e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4e9:	01 d0                	add    %edx,%eax
    f4eb:	0f b6 00             	movzbl (%eax),%eax
    f4ee:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    f4f1:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    f4f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f4f8:	8d 4a 01             	lea    0x1(%edx),%ecx
    f4fb:	8b 55 0c             	mov    0xc(%ebp),%edx
    f4fe:	01 d1                	add    %edx,%ecx
    f500:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f503:	8b 55 08             	mov    0x8(%ebp),%edx
    f506:	01 da                	add    %ebx,%edx
    f508:	ff 75 ec             	pushl  -0x14(%ebp)
    f50b:	50                   	push   %eax
    f50c:	ff 75 f0             	pushl  -0x10(%ebp)
    f50f:	ff 75 f4             	pushl  -0xc(%ebp)
    f512:	51                   	push   %ecx
    f513:	52                   	push   %edx
    f514:	e8 cb f7 ff ff       	call   ece4 <unfilterScanline>
    f519:	83 c4 18             	add    $0x18,%esp
    f51c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f51f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    f523:	74 05                	je     f52a <unfilter+0x97>
    f525:	8b 45 dc             	mov    -0x24(%ebp),%eax
    f528:	eb 1c                	jmp    f546 <unfilter+0xb3>

    prevline = &out[outindex];
    f52a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f52d:	8b 45 08             	mov    0x8(%ebp),%eax
    f530:	01 d0                	add    %edx,%eax
    f532:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    f535:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f539:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f53c:	3b 45 14             	cmp    0x14(%ebp),%eax
    f53f:	72 8b                	jb     f4cc <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    f541:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f546:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f549:	c9                   	leave  
    f54a:	c3                   	ret    

0000f54b <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    f54b:	55                   	push   %ebp
    f54c:	89 e5                	mov    %esp,%ebp
    f54e:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    f554:	ff 75 18             	pushl  0x18(%ebp)
    f557:	ff 75 14             	pushl  0x14(%ebp)
    f55a:	ff 75 10             	pushl  0x10(%ebp)
    f55d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    f563:	50                   	push   %eax
    f564:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    f56a:	50                   	push   %eax
    f56b:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    f571:	50                   	push   %eax
    f572:	8d 45 94             	lea    -0x6c(%ebp),%eax
    f575:	50                   	push   %eax
    f576:	8d 45 b0             	lea    -0x50(%ebp),%eax
    f579:	50                   	push   %eax
    f57a:	e8 e6 f1 ff ff       	call   e765 <Adam7_getpassvalues>
    f57f:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    f582:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    f586:	0f 86 0a 01 00 00    	jbe    f696 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    f58c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f593:	e9 ef 00 00 00       	jmp    f687 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    f598:	8b 45 18             	mov    0x18(%ebp),%eax
    f59b:	c1 e8 03             	shr    $0x3,%eax
    f59e:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    f5a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    f5a8:	e9 c6 00 00 00       	jmp    f673 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    f5ad:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f5b4:	e9 a6 00 00 00       	jmp    f65f <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    f5b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f5bc:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    f5c3:	89 c1                	mov    %eax,%ecx
    f5c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f5c8:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    f5cc:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    f5d0:	89 c2                	mov    %eax,%edx
    f5d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f5d5:	01 c2                	add    %eax,%edx
    f5d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f5da:	0f af c2             	imul   %edx,%eax
    f5dd:	01 c8                	add    %ecx,%eax
    f5df:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    f5e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f5e5:	8b 14 85 d8 b6 01 00 	mov    0x1b6d8(,%eax,4),%edx
    f5ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f5ef:	8b 04 85 10 b7 01 00 	mov    0x1b710(,%eax,4),%eax
    f5f6:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    f5fa:	01 d0                	add    %edx,%eax
    f5fc:	0f af 45 10          	imul   0x10(%ebp),%eax
    f600:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    f602:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f605:	8b 04 85 f4 b6 01 00 	mov    0x1b6f4(,%eax,4),%eax
    f60c:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    f610:	01 c2                	add    %eax,%edx
    f612:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f615:	8b 04 85 bc b6 01 00 	mov    0x1b6bc(,%eax,4),%eax
    f61c:	01 c2                	add    %eax,%edx
    f61e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f621:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    f624:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    f627:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f62e:	eb 23                	jmp    f653 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    f630:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f633:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f636:	01 c2                	add    %eax,%edx
    f638:	8b 45 08             	mov    0x8(%ebp),%eax
    f63b:	01 c2                	add    %eax,%edx
    f63d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    f640:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f643:	01 c1                	add    %eax,%ecx
    f645:	8b 45 0c             	mov    0xc(%ebp),%eax
    f648:	01 c8                	add    %ecx,%eax
    f64a:	0f b6 00             	movzbl (%eax),%eax
    f64d:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    f64f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f653:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f656:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f659:	72 d5                	jb     f630 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    f65b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f65f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f662:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    f666:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    f669:	0f 87 4a ff ff ff    	ja     f5b9 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    f66f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f673:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f676:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    f67a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    f67d:	0f 87 2a ff ff ff    	ja     f5ad <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    f683:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f687:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    f68b:	0f 85 07 ff ff ff    	jne    f598 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    f691:	e9 22 01 00 00       	jmp    f7b8 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    f696:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f69d:	e9 0c 01 00 00       	jmp    f7ae <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    f6a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f6a5:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    f6a9:	0f af 45 18          	imul   0x18(%ebp),%eax
    f6ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    f6b0:	8b 45 18             	mov    0x18(%ebp),%eax
    f6b3:	0f af 45 10          	imul   0x10(%ebp),%eax
    f6b7:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    f6ba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    f6c1:	e9 d4 00 00 00       	jmp    f79a <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    f6c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f6cd:	e9 b4 00 00 00       	jmp    f786 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    f6d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f6d5:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    f6dc:	c1 e0 03             	shl    $0x3,%eax
    f6df:	89 c1                	mov    %eax,%ecx
    f6e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6e4:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    f6e8:	89 c2                	mov    %eax,%edx
    f6ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f6ed:	0f af 45 18          	imul   0x18(%ebp),%eax
    f6f1:	01 d0                	add    %edx,%eax
    f6f3:	01 c8                	add    %ecx,%eax
    f6f5:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    f6fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f6fe:	8b 14 85 d8 b6 01 00 	mov    0x1b6d8(,%eax,4),%edx
    f705:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f708:	8b 04 85 10 b7 01 00 	mov    0x1b710(,%eax,4),%eax
    f70f:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    f713:	01 d0                	add    %edx,%eax
    f715:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    f719:	89 c2                	mov    %eax,%edx
    f71b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f71e:	8b 0c 85 bc b6 01 00 	mov    0x1b6bc(,%eax,4),%ecx
    f725:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f728:	8b 04 85 f4 b6 01 00 	mov    0x1b6f4(,%eax,4),%eax
    f72f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f733:	01 c8                	add    %ecx,%eax
    f735:	0f af 45 18          	imul   0x18(%ebp),%eax
    f739:	01 d0                	add    %edx,%eax
    f73b:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    f741:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    f748:	eb 30                	jmp    f77a <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    f74a:	ff 75 0c             	pushl  0xc(%ebp)
    f74d:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    f753:	50                   	push   %eax
    f754:	e8 1e a1 ff ff       	call   9877 <readBitFromReversedStream>
    f759:	83 c4 08             	add    $0x8,%esp
    f75c:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    f75f:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    f763:	50                   	push   %eax
    f764:	ff 75 08             	pushl  0x8(%ebp)
    f767:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    f76d:	50                   	push   %eax
    f76e:	e8 86 a1 ff ff       	call   98f9 <setBitOfReversedStream>
    f773:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    f776:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    f77a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f77d:	3b 45 18             	cmp    0x18(%ebp),%eax
    f780:	72 c8                	jb     f74a <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    f782:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f786:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f789:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    f78d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f790:	0f 87 3c ff ff ff    	ja     f6d2 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    f796:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    f79a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f79d:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    f7a1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    f7a4:	0f 87 1c ff ff ff    	ja     f6c6 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    f7aa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f7ae:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    f7b2:	0f 85 ea fe ff ff    	jne    f6a2 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    f7b8:	90                   	nop
    f7b9:	c9                   	leave  
    f7ba:	c3                   	ret    

0000f7bb <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    f7bb:	55                   	push   %ebp
    f7bc:	89 e5                	mov    %esp,%ebp
    f7be:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    f7c1:	8b 45 14             	mov    0x14(%ebp),%eax
    f7c4:	2b 45 10             	sub    0x10(%ebp),%eax
    f7c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    f7ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f7d1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    f7d8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f7df:	eb 4a                	jmp    f82b <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    f7e1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f7e8:	eb 2a                	jmp    f814 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    f7ea:	ff 75 0c             	pushl  0xc(%ebp)
    f7ed:	8d 45 ec             	lea    -0x14(%ebp),%eax
    f7f0:	50                   	push   %eax
    f7f1:	e8 81 a0 ff ff       	call   9877 <readBitFromReversedStream>
    f7f6:	83 c4 08             	add    $0x8,%esp
    f7f9:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    f7fc:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    f800:	50                   	push   %eax
    f801:	ff 75 08             	pushl  0x8(%ebp)
    f804:	8d 45 e8             	lea    -0x18(%ebp),%eax
    f807:	50                   	push   %eax
    f808:	e8 ec a0 ff ff       	call   98f9 <setBitOfReversedStream>
    f80d:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    f810:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f814:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f817:	3b 45 10             	cmp    0x10(%ebp),%eax
    f81a:	7c ce                	jl     f7ea <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    f81c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f81f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f822:	01 d0                	add    %edx,%eax
    f824:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    f827:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f82b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f82e:	3b 45 18             	cmp    0x18(%ebp),%eax
    f831:	72 ae                	jb     f7e1 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    f833:	90                   	nop
    f834:	c9                   	leave  
    f835:	c3                   	ret    

0000f836 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    f836:	55                   	push   %ebp
    f837:	89 e5                	mov    %esp,%ebp
    f839:	57                   	push   %edi
    f83a:	56                   	push   %esi
    f83b:	53                   	push   %ebx
    f83c:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    f842:	8b 45 18             	mov    0x18(%ebp),%eax
    f845:	83 c0 0c             	add    $0xc,%eax
    f848:	50                   	push   %eax
    f849:	e8 e6 ac ff ff       	call   a534 <lodepng_get_bpp>
    f84e:	83 c4 04             	add    $0x4,%esp
    f851:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    f854:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f858:	75 0a                	jne    f864 <postProcessScanlines+0x2e>
    f85a:	b8 1f 00 00 00       	mov    $0x1f,%eax
    f85f:	e9 c3 01 00 00       	jmp    fa27 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    f864:	8b 45 18             	mov    0x18(%ebp),%eax
    f867:	8b 40 08             	mov    0x8(%eax),%eax
    f86a:	85 c0                	test   %eax,%eax
    f86c:	0f 85 a8 00 00 00    	jne    f91a <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    f872:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    f876:	77 76                	ja     f8ee <postProcessScanlines+0xb8>
    f878:	8b 45 10             	mov    0x10(%ebp),%eax
    f87b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f87f:	89 c2                	mov    %eax,%edx
    f881:	8b 45 10             	mov    0x10(%ebp),%eax
    f884:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f888:	83 c0 07             	add    $0x7,%eax
    f88b:	c1 e8 03             	shr    $0x3,%eax
    f88e:	c1 e0 03             	shl    $0x3,%eax
    f891:	39 c2                	cmp    %eax,%edx
    f893:	74 59                	je     f8ee <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    f895:	ff 75 ec             	pushl  -0x14(%ebp)
    f898:	ff 75 14             	pushl  0x14(%ebp)
    f89b:	ff 75 10             	pushl  0x10(%ebp)
    f89e:	ff 75 0c             	pushl  0xc(%ebp)
    f8a1:	ff 75 0c             	pushl  0xc(%ebp)
    f8a4:	e8 ea fb ff ff       	call   f493 <unfilter>
    f8a9:	83 c4 14             	add    $0x14,%esp
    f8ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
    f8af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    f8b3:	74 08                	je     f8bd <postProcessScanlines+0x87>
    f8b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8b8:	e9 6a 01 00 00       	jmp    fa27 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    f8bd:	8b 45 10             	mov    0x10(%ebp),%eax
    f8c0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f8c4:	83 c0 07             	add    $0x7,%eax
    f8c7:	c1 e8 03             	shr    $0x3,%eax
    f8ca:	c1 e0 03             	shl    $0x3,%eax
    f8cd:	89 c2                	mov    %eax,%edx
    f8cf:	8b 45 10             	mov    0x10(%ebp),%eax
    f8d2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f8d6:	ff 75 14             	pushl  0x14(%ebp)
    f8d9:	52                   	push   %edx
    f8da:	50                   	push   %eax
    f8db:	ff 75 0c             	pushl  0xc(%ebp)
    f8de:	ff 75 08             	pushl  0x8(%ebp)
    f8e1:	e8 d5 fe ff ff       	call   f7bb <removePaddingBits>
    f8e6:	83 c4 14             	add    $0x14,%esp
    f8e9:	e9 34 01 00 00       	jmp    fa22 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    f8ee:	ff 75 ec             	pushl  -0x14(%ebp)
    f8f1:	ff 75 14             	pushl  0x14(%ebp)
    f8f4:	ff 75 10             	pushl  0x10(%ebp)
    f8f7:	ff 75 0c             	pushl  0xc(%ebp)
    f8fa:	ff 75 08             	pushl  0x8(%ebp)
    f8fd:	e8 91 fb ff ff       	call   f493 <unfilter>
    f902:	83 c4 14             	add    $0x14,%esp
    f905:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    f908:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    f90c:	0f 84 10 01 00 00    	je     fa22 <postProcessScanlines+0x1ec>
    f912:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f915:	e9 0d 01 00 00       	jmp    fa27 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    f91a:	ff 75 ec             	pushl  -0x14(%ebp)
    f91d:	ff 75 14             	pushl  0x14(%ebp)
    f920:	ff 75 10             	pushl  0x10(%ebp)
    f923:	8d 45 88             	lea    -0x78(%ebp),%eax
    f926:	50                   	push   %eax
    f927:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    f92d:	50                   	push   %eax
    f92e:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    f934:	50                   	push   %eax
    f935:	8d 45 a8             	lea    -0x58(%ebp),%eax
    f938:	50                   	push   %eax
    f939:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    f93c:	50                   	push   %eax
    f93d:	e8 23 ee ff ff       	call   e765 <Adam7_getpassvalues>
    f942:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    f945:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f94c:	e9 b0 00 00 00       	jmp    fa01 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    f951:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f954:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    f958:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f95b:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    f95f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    f962:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    f969:	89 cb                	mov    %ecx,%ebx
    f96b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f96e:	01 cb                	add    %ecx,%ebx
    f970:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    f973:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    f97a:	89 ce                	mov    %ecx,%esi
    f97c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f97f:	01 f1                	add    %esi,%ecx
    f981:	ff 75 ec             	pushl  -0x14(%ebp)
    f984:	52                   	push   %edx
    f985:	50                   	push   %eax
    f986:	53                   	push   %ebx
    f987:	51                   	push   %ecx
    f988:	e8 06 fb ff ff       	call   f493 <unfilter>
    f98d:	83 c4 14             	add    $0x14,%esp
    f990:	89 45 e0             	mov    %eax,-0x20(%ebp)
    f993:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    f997:	74 08                	je     f9a1 <postProcessScanlines+0x16b>
    f999:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f99c:	e9 86 00 00 00       	jmp    fa27 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    f9a1:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    f9a5:	77 56                	ja     f9fd <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    f9a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f9aa:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    f9ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9b1:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    f9b5:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    f9b9:	83 c2 07             	add    $0x7,%edx
    f9bc:	c1 ea 03             	shr    $0x3,%edx
    f9bf:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    f9c2:	89 d6                	mov    %edx,%esi
    f9c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9c7:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    f9cb:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    f9cf:	89 d3                	mov    %edx,%ebx
    f9d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9d4:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    f9db:	89 d1                	mov    %edx,%ecx
    f9dd:	8b 55 0c             	mov    0xc(%ebp),%edx
    f9e0:	01 d1                	add    %edx,%ecx
    f9e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9e5:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    f9e9:	89 d7                	mov    %edx,%edi
    f9eb:	8b 55 0c             	mov    0xc(%ebp),%edx
    f9ee:	01 fa                	add    %edi,%edx
    f9f0:	50                   	push   %eax
    f9f1:	56                   	push   %esi
    f9f2:	53                   	push   %ebx
    f9f3:	51                   	push   %ecx
    f9f4:	52                   	push   %edx
    f9f5:	e8 c1 fd ff ff       	call   f7bb <removePaddingBits>
    f9fa:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    f9fd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    fa01:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    fa05:	0f 85 46 ff ff ff    	jne    f951 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    fa0b:	ff 75 ec             	pushl  -0x14(%ebp)
    fa0e:	ff 75 14             	pushl  0x14(%ebp)
    fa11:	ff 75 10             	pushl  0x10(%ebp)
    fa14:	ff 75 0c             	pushl  0xc(%ebp)
    fa17:	ff 75 08             	pushl  0x8(%ebp)
    fa1a:	e8 2c fb ff ff       	call   f54b <Adam7_deinterlace>
    fa1f:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    fa22:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fa27:	8d 65 f4             	lea    -0xc(%ebp),%esp
    fa2a:	5b                   	pop    %ebx
    fa2b:	5e                   	pop    %esi
    fa2c:	5f                   	pop    %edi
    fa2d:	5d                   	pop    %ebp
    fa2e:	c3                   	ret    

0000fa2f <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    fa2f:	55                   	push   %ebp
    fa30:	89 e5                	mov    %esp,%ebp
    fa32:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    fa35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    fa3c:	8b 45 10             	mov    0x10(%ebp),%eax
    fa3f:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    fa44:	f7 e2                	mul    %edx
    fa46:	89 d0                	mov    %edx,%eax
    fa48:	d1 e8                	shr    %eax
    fa4a:	89 c2                	mov    %eax,%edx
    fa4c:	8b 45 08             	mov    0x8(%ebp),%eax
    fa4f:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    fa52:	8b 45 08             	mov    0x8(%ebp),%eax
    fa55:	8b 40 0c             	mov    0xc(%eax),%eax
    fa58:	85 c0                	test   %eax,%eax
    fa5a:	74 0d                	je     fa69 <readChunk_PLTE+0x3a>
    fa5c:	8b 45 08             	mov    0x8(%ebp),%eax
    fa5f:	8b 40 0c             	mov    0xc(%eax),%eax
    fa62:	3d 00 01 00 00       	cmp    $0x100,%eax
    fa67:	7e 0a                	jle    fa73 <readChunk_PLTE+0x44>
    fa69:	b8 26 00 00 00       	mov    $0x26,%eax
    fa6e:	e9 da 00 00 00       	jmp    fb4d <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    fa73:	83 ec 0c             	sub    $0xc,%esp
    fa76:	ff 75 08             	pushl  0x8(%ebp)
    fa79:	e8 02 a7 ff ff       	call   a180 <lodepng_color_mode_alloc_palette>
    fa7e:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    fa81:	8b 45 08             	mov    0x8(%ebp),%eax
    fa84:	8b 40 08             	mov    0x8(%eax),%eax
    fa87:	85 c0                	test   %eax,%eax
    fa89:	75 1e                	jne    faa9 <readChunk_PLTE+0x7a>
    fa8b:	8b 45 08             	mov    0x8(%ebp),%eax
    fa8e:	8b 40 0c             	mov    0xc(%eax),%eax
    fa91:	85 c0                	test   %eax,%eax
    fa93:	74 14                	je     faa9 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    fa95:	8b 45 08             	mov    0x8(%ebp),%eax
    fa98:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    fa9f:	b8 53 00 00 00       	mov    $0x53,%eax
    faa4:	e9 a4 00 00 00       	jmp    fb4d <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    faa9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    fab0:	e9 84 00 00 00       	jmp    fb39 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    fab5:	8b 45 08             	mov    0x8(%ebp),%eax
    fab8:	8b 40 08             	mov    0x8(%eax),%eax
    fabb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fabe:	c1 e2 02             	shl    $0x2,%edx
    fac1:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    fac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    fac7:	8d 50 01             	lea    0x1(%eax),%edx
    faca:	89 55 f4             	mov    %edx,-0xc(%ebp)
    facd:	8b 55 0c             	mov    0xc(%ebp),%edx
    fad0:	01 d0                	add    %edx,%eax
    fad2:	0f b6 00             	movzbl (%eax),%eax
    fad5:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    fad7:	8b 45 08             	mov    0x8(%ebp),%eax
    fada:	8b 40 08             	mov    0x8(%eax),%eax
    fadd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fae0:	c1 e2 02             	shl    $0x2,%edx
    fae3:	83 c2 01             	add    $0x1,%edx
    fae6:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    fae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    faec:	8d 50 01             	lea    0x1(%eax),%edx
    faef:	89 55 f4             	mov    %edx,-0xc(%ebp)
    faf2:	8b 55 0c             	mov    0xc(%ebp),%edx
    faf5:	01 d0                	add    %edx,%eax
    faf7:	0f b6 00             	movzbl (%eax),%eax
    fafa:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    fafc:	8b 45 08             	mov    0x8(%ebp),%eax
    faff:	8b 40 08             	mov    0x8(%eax),%eax
    fb02:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fb05:	c1 e2 02             	shl    $0x2,%edx
    fb08:	83 c2 02             	add    $0x2,%edx
    fb0b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    fb0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    fb11:	8d 50 01             	lea    0x1(%eax),%edx
    fb14:	89 55 f4             	mov    %edx,-0xc(%ebp)
    fb17:	8b 55 0c             	mov    0xc(%ebp),%edx
    fb1a:	01 d0                	add    %edx,%eax
    fb1c:	0f b6 00             	movzbl (%eax),%eax
    fb1f:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    fb21:	8b 45 08             	mov    0x8(%ebp),%eax
    fb24:	8b 40 08             	mov    0x8(%eax),%eax
    fb27:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fb2a:	c1 e2 02             	shl    $0x2,%edx
    fb2d:	83 c2 03             	add    $0x3,%edx
    fb30:	01 d0                	add    %edx,%eax
    fb32:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    fb35:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    fb39:	8b 45 08             	mov    0x8(%ebp),%eax
    fb3c:	8b 40 0c             	mov    0xc(%eax),%eax
    fb3f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    fb42:	0f 85 6d ff ff ff    	jne    fab5 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    fb48:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fb4d:	c9                   	leave  
    fb4e:	c3                   	ret    

0000fb4f <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    fb4f:	55                   	push   %ebp
    fb50:	89 e5                	mov    %esp,%ebp
    fb52:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    fb55:	8b 45 08             	mov    0x8(%ebp),%eax
    fb58:	8b 00                	mov    (%eax),%eax
    fb5a:	83 f8 03             	cmp    $0x3,%eax
    fb5d:	75 4d                	jne    fbac <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    fb5f:	8b 45 08             	mov    0x8(%ebp),%eax
    fb62:	8b 40 0c             	mov    0xc(%eax),%eax
    fb65:	3b 45 10             	cmp    0x10(%ebp),%eax
    fb68:	7d 0a                	jge    fb74 <readChunk_tRNS+0x25>
    fb6a:	b8 27 00 00 00       	mov    $0x27,%eax
    fb6f:	e9 3c 01 00 00       	jmp    fcb0 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    fb74:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    fb7b:	eb 22                	jmp    fb9f <readChunk_tRNS+0x50>
    fb7d:	8b 45 08             	mov    0x8(%ebp),%eax
    fb80:	8b 40 08             	mov    0x8(%eax),%eax
    fb83:	8b 55 fc             	mov    -0x4(%ebp),%edx
    fb86:	c1 e2 02             	shl    $0x2,%edx
    fb89:	83 c2 03             	add    $0x3,%edx
    fb8c:	01 c2                	add    %eax,%edx
    fb8e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    fb91:	8b 45 fc             	mov    -0x4(%ebp),%eax
    fb94:	01 c8                	add    %ecx,%eax
    fb96:	0f b6 00             	movzbl (%eax),%eax
    fb99:	88 02                	mov    %al,(%edx)
    fb9b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    fb9f:	8b 45 10             	mov    0x10(%ebp),%eax
    fba2:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    fba5:	75 d6                	jne    fb7d <readChunk_tRNS+0x2e>
    fba7:	e9 ff 00 00 00       	jmp    fcab <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    fbac:	8b 45 08             	mov    0x8(%ebp),%eax
    fbaf:	8b 00                	mov    (%eax),%eax
    fbb1:	85 c0                	test   %eax,%eax
    fbb3:	75 59                	jne    fc0e <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    fbb5:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    fbb9:	74 0a                	je     fbc5 <readChunk_tRNS+0x76>
    fbbb:	b8 1e 00 00 00       	mov    $0x1e,%eax
    fbc0:	e9 eb 00 00 00       	jmp    fcb0 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    fbc5:	8b 45 08             	mov    0x8(%ebp),%eax
    fbc8:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    fbcf:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbd2:	0f b6 00             	movzbl (%eax),%eax
    fbd5:	0f b6 c0             	movzbl %al,%eax
    fbd8:	c1 e0 08             	shl    $0x8,%eax
    fbdb:	89 c2                	mov    %eax,%edx
    fbdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbe0:	83 c0 01             	add    $0x1,%eax
    fbe3:	0f b6 00             	movzbl (%eax),%eax
    fbe6:	0f b6 c0             	movzbl %al,%eax
    fbe9:	01 c2                	add    %eax,%edx
    fbeb:	8b 45 08             	mov    0x8(%ebp),%eax
    fbee:	89 50 1c             	mov    %edx,0x1c(%eax)
    fbf1:	8b 45 08             	mov    0x8(%ebp),%eax
    fbf4:	8b 50 1c             	mov    0x1c(%eax),%edx
    fbf7:	8b 45 08             	mov    0x8(%ebp),%eax
    fbfa:	89 50 18             	mov    %edx,0x18(%eax)
    fbfd:	8b 45 08             	mov    0x8(%ebp),%eax
    fc00:	8b 50 18             	mov    0x18(%eax),%edx
    fc03:	8b 45 08             	mov    0x8(%ebp),%eax
    fc06:	89 50 14             	mov    %edx,0x14(%eax)
    fc09:	e9 9d 00 00 00       	jmp    fcab <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    fc0e:	8b 45 08             	mov    0x8(%ebp),%eax
    fc11:	8b 00                	mov    (%eax),%eax
    fc13:	83 f8 02             	cmp    $0x2,%eax
    fc16:	0f 85 88 00 00 00    	jne    fca4 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    fc1c:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    fc20:	74 0a                	je     fc2c <readChunk_tRNS+0xdd>
    fc22:	b8 29 00 00 00       	mov    $0x29,%eax
    fc27:	e9 84 00 00 00       	jmp    fcb0 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    fc2c:	8b 45 08             	mov    0x8(%ebp),%eax
    fc2f:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    fc36:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc39:	0f b6 00             	movzbl (%eax),%eax
    fc3c:	0f b6 c0             	movzbl %al,%eax
    fc3f:	c1 e0 08             	shl    $0x8,%eax
    fc42:	89 c2                	mov    %eax,%edx
    fc44:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc47:	83 c0 01             	add    $0x1,%eax
    fc4a:	0f b6 00             	movzbl (%eax),%eax
    fc4d:	0f b6 c0             	movzbl %al,%eax
    fc50:	01 c2                	add    %eax,%edx
    fc52:	8b 45 08             	mov    0x8(%ebp),%eax
    fc55:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    fc58:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc5b:	83 c0 02             	add    $0x2,%eax
    fc5e:	0f b6 00             	movzbl (%eax),%eax
    fc61:	0f b6 c0             	movzbl %al,%eax
    fc64:	c1 e0 08             	shl    $0x8,%eax
    fc67:	89 c2                	mov    %eax,%edx
    fc69:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc6c:	83 c0 03             	add    $0x3,%eax
    fc6f:	0f b6 00             	movzbl (%eax),%eax
    fc72:	0f b6 c0             	movzbl %al,%eax
    fc75:	01 c2                	add    %eax,%edx
    fc77:	8b 45 08             	mov    0x8(%ebp),%eax
    fc7a:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    fc7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc80:	83 c0 04             	add    $0x4,%eax
    fc83:	0f b6 00             	movzbl (%eax),%eax
    fc86:	0f b6 c0             	movzbl %al,%eax
    fc89:	c1 e0 08             	shl    $0x8,%eax
    fc8c:	89 c2                	mov    %eax,%edx
    fc8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc91:	83 c0 05             	add    $0x5,%eax
    fc94:	0f b6 00             	movzbl (%eax),%eax
    fc97:	0f b6 c0             	movzbl %al,%eax
    fc9a:	01 c2                	add    %eax,%edx
    fc9c:	8b 45 08             	mov    0x8(%ebp),%eax
    fc9f:	89 50 1c             	mov    %edx,0x1c(%eax)
    fca2:	eb 07                	jmp    fcab <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    fca4:	b8 2a 00 00 00       	mov    $0x2a,%eax
    fca9:	eb 05                	jmp    fcb0 <readChunk_tRNS+0x161>

  return 0; /* OK */
    fcab:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fcb0:	c9                   	leave  
    fcb1:	c3                   	ret    

0000fcb2 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    fcb2:	55                   	push   %ebp
    fcb3:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    fcb5:	8b 45 08             	mov    0x8(%ebp),%eax
    fcb8:	8b 40 0c             	mov    0xc(%eax),%eax
    fcbb:	83 f8 03             	cmp    $0x3,%eax
    fcbe:	75 63                	jne    fd23 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    fcc0:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    fcc4:	74 0a                	je     fcd0 <readChunk_bKGD+0x1e>
    fcc6:	b8 2b 00 00 00       	mov    $0x2b,%eax
    fccb:	e9 63 01 00 00       	jmp    fe33 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    fcd0:	8b 45 0c             	mov    0xc(%ebp),%eax
    fcd3:	0f b6 00             	movzbl (%eax),%eax
    fcd6:	0f b6 d0             	movzbl %al,%edx
    fcd9:	8b 45 08             	mov    0x8(%ebp),%eax
    fcdc:	8b 40 18             	mov    0x18(%eax),%eax
    fcdf:	39 c2                	cmp    %eax,%edx
    fce1:	7c 0a                	jl     fced <readChunk_bKGD+0x3b>
    fce3:	b8 67 00 00 00       	mov    $0x67,%eax
    fce8:	e9 46 01 00 00       	jmp    fe33 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    fced:	8b 45 08             	mov    0x8(%ebp),%eax
    fcf0:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    fcf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    fcfa:	0f b6 00             	movzbl (%eax),%eax
    fcfd:	0f b6 d0             	movzbl %al,%edx
    fd00:	8b 45 08             	mov    0x8(%ebp),%eax
    fd03:	89 50 38             	mov    %edx,0x38(%eax)
    fd06:	8b 45 08             	mov    0x8(%ebp),%eax
    fd09:	8b 50 38             	mov    0x38(%eax),%edx
    fd0c:	8b 45 08             	mov    0x8(%ebp),%eax
    fd0f:	89 50 34             	mov    %edx,0x34(%eax)
    fd12:	8b 45 08             	mov    0x8(%ebp),%eax
    fd15:	8b 50 34             	mov    0x34(%eax),%edx
    fd18:	8b 45 08             	mov    0x8(%ebp),%eax
    fd1b:	89 50 30             	mov    %edx,0x30(%eax)
    fd1e:	e9 0b 01 00 00       	jmp    fe2e <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    fd23:	8b 45 08             	mov    0x8(%ebp),%eax
    fd26:	8b 40 0c             	mov    0xc(%eax),%eax
    fd29:	85 c0                	test   %eax,%eax
    fd2b:	74 0b                	je     fd38 <readChunk_bKGD+0x86>
    fd2d:	8b 45 08             	mov    0x8(%ebp),%eax
    fd30:	8b 40 0c             	mov    0xc(%eax),%eax
    fd33:	83 f8 04             	cmp    $0x4,%eax
    fd36:	75 59                	jne    fd91 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    fd38:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    fd3c:	74 0a                	je     fd48 <readChunk_bKGD+0x96>
    fd3e:	b8 2c 00 00 00       	mov    $0x2c,%eax
    fd43:	e9 eb 00 00 00       	jmp    fe33 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    fd48:	8b 45 08             	mov    0x8(%ebp),%eax
    fd4b:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    fd52:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd55:	0f b6 00             	movzbl (%eax),%eax
    fd58:	0f b6 c0             	movzbl %al,%eax
    fd5b:	c1 e0 08             	shl    $0x8,%eax
    fd5e:	89 c2                	mov    %eax,%edx
    fd60:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd63:	83 c0 01             	add    $0x1,%eax
    fd66:	0f b6 00             	movzbl (%eax),%eax
    fd69:	0f b6 c0             	movzbl %al,%eax
    fd6c:	01 c2                	add    %eax,%edx
    fd6e:	8b 45 08             	mov    0x8(%ebp),%eax
    fd71:	89 50 38             	mov    %edx,0x38(%eax)
    fd74:	8b 45 08             	mov    0x8(%ebp),%eax
    fd77:	8b 50 38             	mov    0x38(%eax),%edx
    fd7a:	8b 45 08             	mov    0x8(%ebp),%eax
    fd7d:	89 50 34             	mov    %edx,0x34(%eax)
    fd80:	8b 45 08             	mov    0x8(%ebp),%eax
    fd83:	8b 50 34             	mov    0x34(%eax),%edx
    fd86:	8b 45 08             	mov    0x8(%ebp),%eax
    fd89:	89 50 30             	mov    %edx,0x30(%eax)
    fd8c:	e9 9d 00 00 00       	jmp    fe2e <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    fd91:	8b 45 08             	mov    0x8(%ebp),%eax
    fd94:	8b 40 0c             	mov    0xc(%eax),%eax
    fd97:	83 f8 02             	cmp    $0x2,%eax
    fd9a:	74 0f                	je     fdab <readChunk_bKGD+0xf9>
    fd9c:	8b 45 08             	mov    0x8(%ebp),%eax
    fd9f:	8b 40 0c             	mov    0xc(%eax),%eax
    fda2:	83 f8 06             	cmp    $0x6,%eax
    fda5:	0f 85 83 00 00 00    	jne    fe2e <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    fdab:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    fdaf:	74 07                	je     fdb8 <readChunk_bKGD+0x106>
    fdb1:	b8 2d 00 00 00       	mov    $0x2d,%eax
    fdb6:	eb 7b                	jmp    fe33 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    fdb8:	8b 45 08             	mov    0x8(%ebp),%eax
    fdbb:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    fdc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    fdc5:	0f b6 00             	movzbl (%eax),%eax
    fdc8:	0f b6 c0             	movzbl %al,%eax
    fdcb:	c1 e0 08             	shl    $0x8,%eax
    fdce:	89 c2                	mov    %eax,%edx
    fdd0:	8b 45 0c             	mov    0xc(%ebp),%eax
    fdd3:	83 c0 01             	add    $0x1,%eax
    fdd6:	0f b6 00             	movzbl (%eax),%eax
    fdd9:	0f b6 c0             	movzbl %al,%eax
    fddc:	01 c2                	add    %eax,%edx
    fdde:	8b 45 08             	mov    0x8(%ebp),%eax
    fde1:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    fde4:	8b 45 0c             	mov    0xc(%ebp),%eax
    fde7:	83 c0 02             	add    $0x2,%eax
    fdea:	0f b6 00             	movzbl (%eax),%eax
    fded:	0f b6 c0             	movzbl %al,%eax
    fdf0:	c1 e0 08             	shl    $0x8,%eax
    fdf3:	89 c2                	mov    %eax,%edx
    fdf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    fdf8:	83 c0 03             	add    $0x3,%eax
    fdfb:	0f b6 00             	movzbl (%eax),%eax
    fdfe:	0f b6 c0             	movzbl %al,%eax
    fe01:	01 c2                	add    %eax,%edx
    fe03:	8b 45 08             	mov    0x8(%ebp),%eax
    fe06:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    fe09:	8b 45 0c             	mov    0xc(%ebp),%eax
    fe0c:	83 c0 04             	add    $0x4,%eax
    fe0f:	0f b6 00             	movzbl (%eax),%eax
    fe12:	0f b6 c0             	movzbl %al,%eax
    fe15:	c1 e0 08             	shl    $0x8,%eax
    fe18:	89 c2                	mov    %eax,%edx
    fe1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    fe1d:	83 c0 05             	add    $0x5,%eax
    fe20:	0f b6 00             	movzbl (%eax),%eax
    fe23:	0f b6 c0             	movzbl %al,%eax
    fe26:	01 c2                	add    %eax,%edx
    fe28:	8b 45 08             	mov    0x8(%ebp),%eax
    fe2b:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    fe2e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fe33:	5d                   	pop    %ebp
    fe34:	c3                   	ret    

0000fe35 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    fe35:	55                   	push   %ebp
    fe36:	89 e5                	mov    %esp,%ebp
    fe38:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    fe3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    fe42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    fe49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    fe50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fe54:	0f 85 06 01 00 00    	jne    ff60 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    fe5a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    fe61:	eb 04                	jmp    fe67 <readChunk_tEXt+0x32>
    fe63:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    fe67:	8b 45 10             	mov    0x10(%ebp),%eax
    fe6a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    fe6d:	73 0f                	jae    fe7e <readChunk_tEXt+0x49>
    fe6f:	8b 55 0c             	mov    0xc(%ebp),%edx
    fe72:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fe75:	01 d0                	add    %edx,%eax
    fe77:	0f b6 00             	movzbl (%eax),%eax
    fe7a:	84 c0                	test   %al,%al
    fe7c:	75 e5                	jne    fe63 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    fe7e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    fe82:	74 06                	je     fe8a <readChunk_tEXt+0x55>
    fe84:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    fe88:	76 0c                	jbe    fe96 <readChunk_tEXt+0x61>
    fe8a:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    fe91:	e9 ca 00 00 00       	jmp    ff60 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    fe96:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fe99:	83 c0 01             	add    $0x1,%eax
    fe9c:	83 ec 0c             	sub    $0xc,%esp
    fe9f:	50                   	push   %eax
    fea0:	e8 73 4b ff ff       	call   4a18 <lodepng_malloc>
    fea5:	83 c4 10             	add    $0x10,%esp
    fea8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    feab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    feaf:	75 0c                	jne    febd <readChunk_tEXt+0x88>
    feb1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    feb8:	e9 a3 00 00 00       	jmp    ff60 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    febd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fec0:	83 ec 04             	sub    $0x4,%esp
    fec3:	50                   	push   %eax
    fec4:	ff 75 0c             	pushl  0xc(%ebp)
    fec7:	ff 75 f0             	pushl  -0x10(%ebp)
    feca:	e8 87 4b ff ff       	call   4a56 <lodepng_memcpy>
    fecf:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    fed2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fed5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fed8:	01 d0                	add    %edx,%eax
    feda:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    fedd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fee0:	83 c0 01             	add    $0x1,%eax
    fee3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    fee6:	8b 45 10             	mov    0x10(%ebp),%eax
    fee9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    feec:	72 08                	jb     fef6 <readChunk_tEXt+0xc1>
    feee:	8b 45 10             	mov    0x10(%ebp),%eax
    fef1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    fef4:	eb 05                	jmp    fefb <readChunk_tEXt+0xc6>
    fef6:	b8 00 00 00 00       	mov    $0x0,%eax
    fefb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    fefe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ff01:	83 c0 01             	add    $0x1,%eax
    ff04:	83 ec 0c             	sub    $0xc,%esp
    ff07:	50                   	push   %eax
    ff08:	e8 0b 4b ff ff       	call   4a18 <lodepng_malloc>
    ff0d:	83 c4 10             	add    $0x10,%esp
    ff10:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    ff13:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ff17:	75 09                	jne    ff22 <readChunk_tEXt+0xed>
    ff19:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ff20:	eb 3e                	jmp    ff60 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    ff22:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ff25:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ff28:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ff2b:	01 ca                	add    %ecx,%edx
    ff2d:	83 ec 04             	sub    $0x4,%esp
    ff30:	50                   	push   %eax
    ff31:	52                   	push   %edx
    ff32:	ff 75 ec             	pushl  -0x14(%ebp)
    ff35:	e8 1c 4b ff ff       	call   4a56 <lodepng_memcpy>
    ff3a:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    ff3d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ff40:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ff43:	01 d0                	add    %edx,%eax
    ff45:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    ff48:	83 ec 04             	sub    $0x4,%esp
    ff4b:	ff 75 ec             	pushl  -0x14(%ebp)
    ff4e:	ff 75 f0             	pushl  -0x10(%ebp)
    ff51:	ff 75 08             	pushl  0x8(%ebp)
    ff54:	e8 3f ac ff ff       	call   ab98 <lodepng_add_text>
    ff59:	83 c4 10             	add    $0x10,%esp
    ff5c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    ff5f:	90                   	nop
  }

  lodepng_free(key);
    ff60:	83 ec 0c             	sub    $0xc,%esp
    ff63:	ff 75 f0             	pushl  -0x10(%ebp)
    ff66:	e8 ce 4a ff ff       	call   4a39 <lodepng_free>
    ff6b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ff6e:	83 ec 0c             	sub    $0xc,%esp
    ff71:	ff 75 ec             	pushl  -0x14(%ebp)
    ff74:	e8 c0 4a ff ff       	call   4a39 <lodepng_free>
    ff79:	83 c4 10             	add    $0x10,%esp

  return error;
    ff7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ff7f:	c9                   	leave  
    ff80:	c3                   	ret    

0000ff81 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ff81:	55                   	push   %ebp
    ff82:	89 e5                	mov    %esp,%ebp
    ff84:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    ff87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ff8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff91:	8b 10                	mov    (%eax),%edx
    ff93:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ff96:	8b 50 04             	mov    0x4(%eax),%edx
    ff99:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    ff9c:	8b 50 08             	mov    0x8(%eax),%edx
    ff9f:	89 55 d8             	mov    %edx,-0x28(%ebp)
    ffa2:	8b 50 0c             	mov    0xc(%eax),%edx
    ffa5:	89 55 dc             	mov    %edx,-0x24(%ebp)
    ffa8:	8b 50 10             	mov    0x10(%eax),%edx
    ffab:	89 55 e0             	mov    %edx,-0x20(%ebp)
    ffae:	8b 40 14             	mov    0x14(%eax),%eax
    ffb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    ffb4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    ffbb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    ffc2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ffc9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ffcd:	0f 85 48 01 00 00    	jne    1011b <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ffd3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ffda:	eb 04                	jmp    ffe0 <readChunk_zTXt+0x5f>
    ffdc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ffe0:	8b 45 14             	mov    0x14(%ebp),%eax
    ffe3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ffe6:	73 0f                	jae    fff7 <readChunk_zTXt+0x76>
    ffe8:	8b 55 10             	mov    0x10(%ebp),%edx
    ffeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ffee:	01 d0                	add    %edx,%eax
    fff0:	0f b6 00             	movzbl (%eax),%eax
    fff3:	84 c0                	test   %al,%al
    fff5:	75 e5                	jne    ffdc <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    fff7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fffa:	8d 50 02             	lea    0x2(%eax),%edx
    fffd:	8b 45 14             	mov    0x14(%ebp),%eax
   10000:	39 c2                	cmp    %eax,%edx
   10002:	72 0c                	jb     10010 <readChunk_zTXt+0x8f>
   10004:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   1000b:	e9 0b 01 00 00       	jmp    1011b <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   10010:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10014:	74 06                	je     1001c <readChunk_zTXt+0x9b>
   10016:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   1001a:	76 0c                	jbe    10028 <readChunk_zTXt+0xa7>
   1001c:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   10023:	e9 f3 00 00 00       	jmp    1011b <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
   10028:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1002b:	83 c0 01             	add    $0x1,%eax
   1002e:	83 ec 0c             	sub    $0xc,%esp
   10031:	50                   	push   %eax
   10032:	e8 e1 49 ff ff       	call   4a18 <lodepng_malloc>
   10037:	83 c4 10             	add    $0x10,%esp
   1003a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   1003d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10041:	75 0c                	jne    1004f <readChunk_zTXt+0xce>
   10043:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   1004a:	e9 cc 00 00 00       	jmp    1011b <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
   1004f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10052:	83 ec 04             	sub    $0x4,%esp
   10055:	50                   	push   %eax
   10056:	ff 75 10             	pushl  0x10(%ebp)
   10059:	ff 75 ec             	pushl  -0x14(%ebp)
   1005c:	e8 f5 49 ff ff       	call   4a56 <lodepng_memcpy>
   10061:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   10064:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10067:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1006a:	01 d0                	add    %edx,%eax
   1006c:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
   1006f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10072:	8d 50 01             	lea    0x1(%eax),%edx
   10075:	8b 45 10             	mov    0x10(%ebp),%eax
   10078:	01 d0                	add    %edx,%eax
   1007a:	0f b6 00             	movzbl (%eax),%eax
   1007d:	84 c0                	test   %al,%al
   1007f:	74 0c                	je     1008d <readChunk_zTXt+0x10c>
   10081:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
   10088:	e9 8e 00 00 00       	jmp    1011b <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
   1008d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10090:	83 c0 02             	add    $0x2,%eax
   10093:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
   10096:	8b 45 14             	mov    0x14(%ebp),%eax
   10099:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   1009c:	76 09                	jbe    100a7 <readChunk_zTXt+0x126>
   1009e:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   100a5:	eb 74                	jmp    1011b <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
   100a7:	8b 45 14             	mov    0x14(%ebp),%eax
   100aa:	2b 45 e8             	sub    -0x18(%ebp),%eax
   100ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
   100b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   100b3:	8b 40 30             	mov    0x30(%eax),%eax
   100b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
   100b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   100bc:	8b 4d 10             	mov    0x10(%ebp),%ecx
   100bf:	8b 55 e8             	mov    -0x18(%ebp),%edx
   100c2:	01 d1                	add    %edx,%ecx
   100c4:	83 ec 08             	sub    $0x8,%esp
   100c7:	8d 55 d0             	lea    -0x30(%ebp),%edx
   100ca:	52                   	push   %edx
   100cb:	50                   	push   %eax
   100cc:	51                   	push   %ecx
   100cd:	6a 00                	push   $0x0
   100cf:	8d 45 c8             	lea    -0x38(%ebp),%eax
   100d2:	50                   	push   %eax
   100d3:	8d 45 cc             	lea    -0x34(%ebp),%eax
   100d6:	50                   	push   %eax
   100d7:	e8 f7 93 ff ff       	call   94d3 <zlib_decompress>
   100dc:	83 c4 20             	add    $0x20,%esp
   100df:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
   100e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   100e6:	74 11                	je     100f9 <readChunk_zTXt+0x178>
   100e8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   100eb:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100ee:	39 c2                	cmp    %eax,%edx
   100f0:	7d 07                	jge    100f9 <readChunk_zTXt+0x178>
   100f2:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
   100f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   100fd:	75 1b                	jne    1011a <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
   100ff:	8b 55 c8             	mov    -0x38(%ebp),%edx
   10102:	8b 45 cc             	mov    -0x34(%ebp),%eax
   10105:	52                   	push   %edx
   10106:	50                   	push   %eax
   10107:	ff 75 ec             	pushl  -0x14(%ebp)
   1010a:	ff 75 08             	pushl  0x8(%ebp)
   1010d:	e8 60 a9 ff ff       	call   aa72 <lodepng_add_text_sized>
   10112:	83 c4 10             	add    $0x10,%esp
   10115:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
   10118:	eb 01                	jmp    1011b <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
   1011a:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
   1011b:	83 ec 0c             	sub    $0xc,%esp
   1011e:	ff 75 ec             	pushl  -0x14(%ebp)
   10121:	e8 13 49 ff ff       	call   4a39 <lodepng_free>
   10126:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
   10129:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1012c:	83 ec 0c             	sub    $0xc,%esp
   1012f:	50                   	push   %eax
   10130:	e8 04 49 ff ff       	call   4a39 <lodepng_free>
   10135:	83 c4 10             	add    $0x10,%esp

  return error;
   10138:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1013b:	c9                   	leave  
   1013c:	c3                   	ret    

0001013d <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   1013d:	55                   	push   %ebp
   1013e:	89 e5                	mov    %esp,%ebp
   10140:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
   10143:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   1014a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1014d:	8b 10                	mov    (%eax),%edx
   1014f:	89 55 c0             	mov    %edx,-0x40(%ebp)
   10152:	8b 50 04             	mov    0x4(%eax),%edx
   10155:	89 55 c4             	mov    %edx,-0x3c(%ebp)
   10158:	8b 50 08             	mov    0x8(%eax),%edx
   1015b:	89 55 c8             	mov    %edx,-0x38(%ebp)
   1015e:	8b 50 0c             	mov    0xc(%eax),%edx
   10161:	89 55 cc             	mov    %edx,-0x34(%ebp)
   10164:	8b 50 10             	mov    0x10(%eax),%edx
   10167:	89 55 d0             	mov    %edx,-0x30(%ebp)
   1016a:	8b 40 14             	mov    0x14(%eax),%eax
   1016d:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
   10170:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10177:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1017e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
   10185:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10189:	0f 85 d5 02 00 00    	jne    10464 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
   1018f:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
   10193:	7f 0c                	jg     101a1 <readChunk_iTXt+0x64>
   10195:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
   1019c:	e9 c3 02 00 00       	jmp    10464 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   101a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   101a8:	eb 04                	jmp    101ae <readChunk_iTXt+0x71>
   101aa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   101ae:	8b 45 14             	mov    0x14(%ebp),%eax
   101b1:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   101b4:	73 0f                	jae    101c5 <readChunk_iTXt+0x88>
   101b6:	8b 55 10             	mov    0x10(%ebp),%edx
   101b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   101bc:	01 d0                	add    %edx,%eax
   101be:	0f b6 00             	movzbl (%eax),%eax
   101c1:	84 c0                	test   %al,%al
   101c3:	75 e5                	jne    101aa <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
   101c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   101c8:	8d 50 03             	lea    0x3(%eax),%edx
   101cb:	8b 45 14             	mov    0x14(%ebp),%eax
   101ce:	39 c2                	cmp    %eax,%edx
   101d0:	72 0c                	jb     101de <readChunk_iTXt+0xa1>
   101d2:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   101d9:	e9 86 02 00 00       	jmp    10464 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   101de:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   101e2:	74 06                	je     101ea <readChunk_iTXt+0xad>
   101e4:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   101e8:	76 0c                	jbe    101f6 <readChunk_iTXt+0xb9>
   101ea:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   101f1:	e9 6e 02 00 00       	jmp    10464 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
   101f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   101f9:	83 c0 01             	add    $0x1,%eax
   101fc:	83 ec 0c             	sub    $0xc,%esp
   101ff:	50                   	push   %eax
   10200:	e8 13 48 ff ff       	call   4a18 <lodepng_malloc>
   10205:	83 c4 10             	add    $0x10,%esp
   10208:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   1020b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1020f:	75 0c                	jne    1021d <readChunk_iTXt+0xe0>
   10211:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   10218:	e9 47 02 00 00       	jmp    10464 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
   1021d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10220:	83 ec 04             	sub    $0x4,%esp
   10223:	50                   	push   %eax
   10224:	ff 75 10             	pushl  0x10(%ebp)
   10227:	ff 75 e8             	pushl  -0x18(%ebp)
   1022a:	e8 27 48 ff ff       	call   4a56 <lodepng_memcpy>
   1022f:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   10232:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10235:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10238:	01 d0                	add    %edx,%eax
   1023a:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
   1023d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10240:	8d 50 01             	lea    0x1(%eax),%edx
   10243:	8b 45 10             	mov    0x10(%ebp),%eax
   10246:	01 d0                	add    %edx,%eax
   10248:	0f b6 00             	movzbl (%eax),%eax
   1024b:	0f b6 c0             	movzbl %al,%eax
   1024e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
   10251:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10254:	8d 50 02             	lea    0x2(%eax),%edx
   10257:	8b 45 10             	mov    0x10(%ebp),%eax
   1025a:	01 d0                	add    %edx,%eax
   1025c:	0f b6 00             	movzbl (%eax),%eax
   1025f:	84 c0                	test   %al,%al
   10261:	74 0c                	je     1026f <readChunk_iTXt+0x132>
   10263:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
   1026a:	e9 f5 01 00 00       	jmp    10464 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
   1026f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10272:	83 c0 03             	add    $0x3,%eax
   10275:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
   10278:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
   1027f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10282:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10285:	eb 08                	jmp    1028f <readChunk_iTXt+0x152>
   10287:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1028b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1028f:	8b 45 14             	mov    0x14(%ebp),%eax
   10292:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   10295:	73 0f                	jae    102a6 <readChunk_iTXt+0x169>
   10297:	8b 55 10             	mov    0x10(%ebp),%edx
   1029a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1029d:	01 d0                	add    %edx,%eax
   1029f:	0f b6 00             	movzbl (%eax),%eax
   102a2:	84 c0                	test   %al,%al
   102a4:	75 e1                	jne    10287 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
   102a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   102a9:	83 c0 01             	add    $0x1,%eax
   102ac:	83 ec 0c             	sub    $0xc,%esp
   102af:	50                   	push   %eax
   102b0:	e8 63 47 ff ff       	call   4a18 <lodepng_malloc>
   102b5:	83 c4 10             	add    $0x10,%esp
   102b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
   102bb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   102bf:	75 0c                	jne    102cd <readChunk_iTXt+0x190>
   102c1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   102c8:	e9 97 01 00 00       	jmp    10464 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
   102cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   102d0:	8b 4d 10             	mov    0x10(%ebp),%ecx
   102d3:	8b 55 d8             	mov    -0x28(%ebp),%edx
   102d6:	01 ca                	add    %ecx,%edx
   102d8:	83 ec 04             	sub    $0x4,%esp
   102db:	50                   	push   %eax
   102dc:	52                   	push   %edx
   102dd:	ff 75 e4             	pushl  -0x1c(%ebp)
   102e0:	e8 71 47 ff ff       	call   4a56 <lodepng_memcpy>
   102e5:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
   102e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   102eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   102ee:	01 d0                	add    %edx,%eax
   102f0:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
   102f3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   102f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   102f9:	01 d0                	add    %edx,%eax
   102fb:	83 c0 01             	add    $0x1,%eax
   102fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
   10301:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
   10308:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1030b:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1030e:	eb 08                	jmp    10318 <readChunk_iTXt+0x1db>
   10310:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   10314:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10318:	8b 45 14             	mov    0x14(%ebp),%eax
   1031b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1031e:	73 0f                	jae    1032f <readChunk_iTXt+0x1f2>
   10320:	8b 55 10             	mov    0x10(%ebp),%edx
   10323:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10326:	01 d0                	add    %edx,%eax
   10328:	0f b6 00             	movzbl (%eax),%eax
   1032b:	84 c0                	test   %al,%al
   1032d:	75 e1                	jne    10310 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
   1032f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10332:	83 c0 01             	add    $0x1,%eax
   10335:	83 ec 0c             	sub    $0xc,%esp
   10338:	50                   	push   %eax
   10339:	e8 da 46 ff ff       	call   4a18 <lodepng_malloc>
   1033e:	83 c4 10             	add    $0x10,%esp
   10341:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
   10344:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10348:	75 0c                	jne    10356 <readChunk_iTXt+0x219>
   1034a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   10351:	e9 0e 01 00 00       	jmp    10464 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
   10356:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10359:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1035c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1035f:	01 ca                	add    %ecx,%edx
   10361:	83 ec 04             	sub    $0x4,%esp
   10364:	50                   	push   %eax
   10365:	52                   	push   %edx
   10366:	ff 75 e0             	pushl  -0x20(%ebp)
   10369:	e8 e8 46 ff ff       	call   4a56 <lodepng_memcpy>
   1036e:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
   10371:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10374:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10377:	01 d0                	add    %edx,%eax
   10379:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
   1037c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1037f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10382:	01 d0                	add    %edx,%eax
   10384:	83 c0 01             	add    $0x1,%eax
   10387:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
   1038a:	8b 45 14             	mov    0x14(%ebp),%eax
   1038d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   10390:	72 08                	jb     1039a <readChunk_iTXt+0x25d>
   10392:	8b 45 14             	mov    0x14(%ebp),%eax
   10395:	2b 45 d8             	sub    -0x28(%ebp),%eax
   10398:	eb 05                	jmp    1039f <readChunk_iTXt+0x262>
   1039a:	b8 00 00 00 00       	mov    $0x0,%eax
   1039f:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
   103a2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   103a6:	0f 84 90 00 00 00    	je     1043c <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
   103ac:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
   103b3:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
   103ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   103bd:	8b 40 30             	mov    0x30(%eax),%eax
   103c0:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
   103c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   103c6:	8b 4d 10             	mov    0x10(%ebp),%ecx
   103c9:	8b 55 d8             	mov    -0x28(%ebp),%edx
   103cc:	01 d1                	add    %edx,%ecx
   103ce:	83 ec 08             	sub    $0x8,%esp
   103d1:	8d 55 c0             	lea    -0x40(%ebp),%edx
   103d4:	52                   	push   %edx
   103d5:	50                   	push   %eax
   103d6:	51                   	push   %ecx
   103d7:	6a 00                	push   $0x0
   103d9:	8d 45 b8             	lea    -0x48(%ebp),%eax
   103dc:	50                   	push   %eax
   103dd:	8d 45 bc             	lea    -0x44(%ebp),%eax
   103e0:	50                   	push   %eax
   103e1:	e8 ed 90 ff ff       	call   94d3 <zlib_decompress>
   103e6:	83 c4 20             	add    $0x20,%esp
   103e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
   103ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   103f0:	74 11                	je     10403 <readChunk_iTXt+0x2c6>
   103f2:	8b 55 c8             	mov    -0x38(%ebp),%edx
   103f5:	8b 45 b8             	mov    -0x48(%ebp),%eax
   103f8:	39 c2                	cmp    %eax,%edx
   103fa:	7d 07                	jge    10403 <readChunk_iTXt+0x2c6>
   103fc:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
   10403:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10407:	75 22                	jne    1042b <readChunk_iTXt+0x2ee>
   10409:	8b 55 b8             	mov    -0x48(%ebp),%edx
   1040c:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1040f:	83 ec 08             	sub    $0x8,%esp
   10412:	52                   	push   %edx
   10413:	50                   	push   %eax
   10414:	ff 75 e0             	pushl  -0x20(%ebp)
   10417:	ff 75 e4             	pushl  -0x1c(%ebp)
   1041a:	ff 75 e8             	pushl  -0x18(%ebp)
   1041d:	ff 75 08             	pushl  0x8(%ebp)
   10420:	e8 94 a9 ff ff       	call   adb9 <lodepng_add_itext_sized>
   10425:	83 c4 20             	add    $0x20,%esp
   10428:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
   1042b:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1042e:	83 ec 0c             	sub    $0xc,%esp
   10431:	50                   	push   %eax
   10432:	e8 02 46 ff ff       	call   4a39 <lodepng_free>
   10437:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
   1043a:	eb 27                	jmp    10463 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
   1043c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1043f:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10442:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10445:	01 ca                	add    %ecx,%edx
   10447:	83 ec 08             	sub    $0x8,%esp
   1044a:	50                   	push   %eax
   1044b:	52                   	push   %edx
   1044c:	ff 75 e0             	pushl  -0x20(%ebp)
   1044f:	ff 75 e4             	pushl  -0x1c(%ebp)
   10452:	ff 75 e8             	pushl  -0x18(%ebp)
   10455:	ff 75 08             	pushl  0x8(%ebp)
   10458:	e8 5c a9 ff ff       	call   adb9 <lodepng_add_itext_sized>
   1045d:	83 c4 20             	add    $0x20,%esp
   10460:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
   10463:	90                   	nop
  }

  lodepng_free(key);
   10464:	83 ec 0c             	sub    $0xc,%esp
   10467:	ff 75 e8             	pushl  -0x18(%ebp)
   1046a:	e8 ca 45 ff ff       	call   4a39 <lodepng_free>
   1046f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
   10472:	83 ec 0c             	sub    $0xc,%esp
   10475:	ff 75 e4             	pushl  -0x1c(%ebp)
   10478:	e8 bc 45 ff ff       	call   4a39 <lodepng_free>
   1047d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
   10480:	83 ec 0c             	sub    $0xc,%esp
   10483:	ff 75 e0             	pushl  -0x20(%ebp)
   10486:	e8 ae 45 ff ff       	call   4a39 <lodepng_free>
   1048b:	83 c4 10             	add    $0x10,%esp

  return error;
   1048e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10491:	c9                   	leave  
   10492:	c3                   	ret    

00010493 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   10493:	55                   	push   %ebp
   10494:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
   10496:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
   1049a:	74 0a                	je     104a6 <readChunk_tIME+0x13>
   1049c:	b8 49 00 00 00       	mov    $0x49,%eax
   104a1:	e9 8b 00 00 00       	jmp    10531 <readChunk_tIME+0x9e>

  info->time_defined = 1;
   104a6:	8b 45 08             	mov    0x8(%ebp),%eax
   104a9:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
   104b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   104b3:	0f b6 00             	movzbl (%eax),%eax
   104b6:	0f b6 c0             	movzbl %al,%eax
   104b9:	c1 e0 08             	shl    $0x8,%eax
   104bc:	89 c2                	mov    %eax,%edx
   104be:	8b 45 0c             	mov    0xc(%ebp),%eax
   104c1:	83 c0 01             	add    $0x1,%eax
   104c4:	0f b6 00             	movzbl (%eax),%eax
   104c7:	0f b6 c0             	movzbl %al,%eax
   104ca:	01 c2                	add    %eax,%edx
   104cc:	8b 45 08             	mov    0x8(%ebp),%eax
   104cf:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
   104d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   104d5:	83 c0 02             	add    $0x2,%eax
   104d8:	0f b6 00             	movzbl (%eax),%eax
   104db:	0f b6 d0             	movzbl %al,%edx
   104de:	8b 45 08             	mov    0x8(%ebp),%eax
   104e1:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
   104e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   104e7:	83 c0 03             	add    $0x3,%eax
   104ea:	0f b6 00             	movzbl (%eax),%eax
   104ed:	0f b6 d0             	movzbl %al,%edx
   104f0:	8b 45 08             	mov    0x8(%ebp),%eax
   104f3:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
   104f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   104f9:	83 c0 04             	add    $0x4,%eax
   104fc:	0f b6 00             	movzbl (%eax),%eax
   104ff:	0f b6 d0             	movzbl %al,%edx
   10502:	8b 45 08             	mov    0x8(%ebp),%eax
   10505:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
   10508:	8b 45 0c             	mov    0xc(%ebp),%eax
   1050b:	83 c0 05             	add    $0x5,%eax
   1050e:	0f b6 00             	movzbl (%eax),%eax
   10511:	0f b6 d0             	movzbl %al,%edx
   10514:	8b 45 08             	mov    0x8(%ebp),%eax
   10517:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
   1051a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1051d:	83 c0 06             	add    $0x6,%eax
   10520:	0f b6 00             	movzbl (%eax),%eax
   10523:	0f b6 d0             	movzbl %al,%edx
   10526:	8b 45 08             	mov    0x8(%ebp),%eax
   10529:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
   1052c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10531:	5d                   	pop    %ebp
   10532:	c3                   	ret    

00010533 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   10533:	55                   	push   %ebp
   10534:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
   10536:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
   1053a:	74 0a                	je     10546 <readChunk_pHYs+0x13>
   1053c:	b8 4a 00 00 00       	mov    $0x4a,%eax
   10541:	e9 ba 00 00 00       	jmp    10600 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
   10546:	8b 45 08             	mov    0x8(%ebp),%eax
   10549:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
   10550:	8b 45 0c             	mov    0xc(%ebp),%eax
   10553:	0f b6 00             	movzbl (%eax),%eax
   10556:	0f b6 c0             	movzbl %al,%eax
   10559:	c1 e0 08             	shl    $0x8,%eax
   1055c:	89 c2                	mov    %eax,%edx
   1055e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10561:	83 c0 01             	add    $0x1,%eax
   10564:	0f b6 00             	movzbl (%eax),%eax
   10567:	0f b6 c0             	movzbl %al,%eax
   1056a:	01 d0                	add    %edx,%eax
   1056c:	c1 e0 08             	shl    $0x8,%eax
   1056f:	89 c2                	mov    %eax,%edx
   10571:	8b 45 0c             	mov    0xc(%ebp),%eax
   10574:	83 c0 02             	add    $0x2,%eax
   10577:	0f b6 00             	movzbl (%eax),%eax
   1057a:	0f b6 c0             	movzbl %al,%eax
   1057d:	01 d0                	add    %edx,%eax
   1057f:	c1 e0 08             	shl    $0x8,%eax
   10582:	89 c2                	mov    %eax,%edx
   10584:	8b 45 0c             	mov    0xc(%ebp),%eax
   10587:	83 c0 03             	add    $0x3,%eax
   1058a:	0f b6 00             	movzbl (%eax),%eax
   1058d:	0f b6 c0             	movzbl %al,%eax
   10590:	01 c2                	add    %eax,%edx
   10592:	8b 45 08             	mov    0x8(%ebp),%eax
   10595:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
   10598:	8b 45 0c             	mov    0xc(%ebp),%eax
   1059b:	83 c0 04             	add    $0x4,%eax
   1059e:	0f b6 00             	movzbl (%eax),%eax
   105a1:	0f b6 c0             	movzbl %al,%eax
   105a4:	c1 e0 08             	shl    $0x8,%eax
   105a7:	89 c2                	mov    %eax,%edx
   105a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   105ac:	83 c0 05             	add    $0x5,%eax
   105af:	0f b6 00             	movzbl (%eax),%eax
   105b2:	0f b6 c0             	movzbl %al,%eax
   105b5:	01 d0                	add    %edx,%eax
   105b7:	c1 e0 08             	shl    $0x8,%eax
   105ba:	89 c2                	mov    %eax,%edx
   105bc:	8b 45 0c             	mov    0xc(%ebp),%eax
   105bf:	83 c0 06             	add    $0x6,%eax
   105c2:	0f b6 00             	movzbl (%eax),%eax
   105c5:	0f b6 c0             	movzbl %al,%eax
   105c8:	01 d0                	add    %edx,%eax
   105ca:	c1 e0 08             	shl    $0x8,%eax
   105cd:	89 c2                	mov    %eax,%edx
   105cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   105d2:	83 c0 07             	add    $0x7,%eax
   105d5:	0f b6 00             	movzbl (%eax),%eax
   105d8:	0f b6 c0             	movzbl %al,%eax
   105db:	01 c2                	add    %eax,%edx
   105dd:	8b 45 08             	mov    0x8(%ebp),%eax
   105e0:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
   105e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   105e9:	83 c0 08             	add    $0x8,%eax
   105ec:	0f b6 00             	movzbl (%eax),%eax
   105ef:	0f b6 d0             	movzbl %al,%edx
   105f2:	8b 45 08             	mov    0x8(%ebp),%eax
   105f5:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
   105fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10600:	5d                   	pop    %ebp
   10601:	c3                   	ret    

00010602 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   10602:	55                   	push   %ebp
   10603:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
   10605:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
   10609:	74 07                	je     10612 <readChunk_gAMA+0x10>
   1060b:	b8 60 00 00 00       	mov    $0x60,%eax
   10610:	eb 5d                	jmp    1066f <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
   10612:	8b 45 08             	mov    0x8(%ebp),%eax
   10615:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
   1061c:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
   1061f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10622:	0f b6 00             	movzbl (%eax),%eax
   10625:	0f b6 c0             	movzbl %al,%eax
   10628:	c1 e0 08             	shl    $0x8,%eax
   1062b:	89 c2                	mov    %eax,%edx
   1062d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10630:	83 c0 01             	add    $0x1,%eax
   10633:	0f b6 00             	movzbl (%eax),%eax
   10636:	0f b6 c0             	movzbl %al,%eax
   10639:	01 d0                	add    %edx,%eax
   1063b:	c1 e0 08             	shl    $0x8,%eax
   1063e:	89 c2                	mov    %eax,%edx
   10640:	8b 45 0c             	mov    0xc(%ebp),%eax
   10643:	83 c0 02             	add    $0x2,%eax
   10646:	0f b6 00             	movzbl (%eax),%eax
   10649:	0f b6 c0             	movzbl %al,%eax
   1064c:	01 d0                	add    %edx,%eax
   1064e:	c1 e0 08             	shl    $0x8,%eax
   10651:	89 c2                	mov    %eax,%edx
   10653:	8b 45 0c             	mov    0xc(%ebp),%eax
   10656:	83 c0 03             	add    $0x3,%eax
   10659:	0f b6 00             	movzbl (%eax),%eax
   1065c:	0f b6 c0             	movzbl %al,%eax
   1065f:	01 c2                	add    %eax,%edx
   10661:	8b 45 08             	mov    0x8(%ebp),%eax
   10664:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
   1066a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1066f:	5d                   	pop    %ebp
   10670:	c3                   	ret    

00010671 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   10671:	55                   	push   %ebp
   10672:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
   10674:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
   10678:	74 0a                	je     10684 <readChunk_cHRM+0x13>
   1067a:	b8 61 00 00 00       	mov    $0x61,%eax
   1067f:	e9 7f 02 00 00       	jmp    10903 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
   10684:	8b 45 08             	mov    0x8(%ebp),%eax
   10687:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   1068e:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
   10691:	8b 45 0c             	mov    0xc(%ebp),%eax
   10694:	0f b6 00             	movzbl (%eax),%eax
   10697:	0f b6 c0             	movzbl %al,%eax
   1069a:	c1 e0 08             	shl    $0x8,%eax
   1069d:	89 c2                	mov    %eax,%edx
   1069f:	8b 45 0c             	mov    0xc(%ebp),%eax
   106a2:	83 c0 01             	add    $0x1,%eax
   106a5:	0f b6 00             	movzbl (%eax),%eax
   106a8:	0f b6 c0             	movzbl %al,%eax
   106ab:	01 d0                	add    %edx,%eax
   106ad:	c1 e0 08             	shl    $0x8,%eax
   106b0:	89 c2                	mov    %eax,%edx
   106b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   106b5:	83 c0 02             	add    $0x2,%eax
   106b8:	0f b6 00             	movzbl (%eax),%eax
   106bb:	0f b6 c0             	movzbl %al,%eax
   106be:	01 d0                	add    %edx,%eax
   106c0:	c1 e0 08             	shl    $0x8,%eax
   106c3:	89 c2                	mov    %eax,%edx
   106c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   106c8:	83 c0 03             	add    $0x3,%eax
   106cb:	0f b6 00             	movzbl (%eax),%eax
   106ce:	0f b6 c0             	movzbl %al,%eax
   106d1:	01 c2                	add    %eax,%edx
   106d3:	8b 45 08             	mov    0x8(%ebp),%eax
   106d6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
   106dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   106df:	83 c0 04             	add    $0x4,%eax
   106e2:	0f b6 00             	movzbl (%eax),%eax
   106e5:	0f b6 c0             	movzbl %al,%eax
   106e8:	c1 e0 08             	shl    $0x8,%eax
   106eb:	89 c2                	mov    %eax,%edx
   106ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   106f0:	83 c0 05             	add    $0x5,%eax
   106f3:	0f b6 00             	movzbl (%eax),%eax
   106f6:	0f b6 c0             	movzbl %al,%eax
   106f9:	01 d0                	add    %edx,%eax
   106fb:	c1 e0 08             	shl    $0x8,%eax
   106fe:	89 c2                	mov    %eax,%edx
   10700:	8b 45 0c             	mov    0xc(%ebp),%eax
   10703:	83 c0 06             	add    $0x6,%eax
   10706:	0f b6 00             	movzbl (%eax),%eax
   10709:	0f b6 c0             	movzbl %al,%eax
   1070c:	01 d0                	add    %edx,%eax
   1070e:	c1 e0 08             	shl    $0x8,%eax
   10711:	89 c2                	mov    %eax,%edx
   10713:	8b 45 0c             	mov    0xc(%ebp),%eax
   10716:	83 c0 07             	add    $0x7,%eax
   10719:	0f b6 00             	movzbl (%eax),%eax
   1071c:	0f b6 c0             	movzbl %al,%eax
   1071f:	01 c2                	add    %eax,%edx
   10721:	8b 45 08             	mov    0x8(%ebp),%eax
   10724:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
   1072a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1072d:	83 c0 08             	add    $0x8,%eax
   10730:	0f b6 00             	movzbl (%eax),%eax
   10733:	0f b6 c0             	movzbl %al,%eax
   10736:	c1 e0 08             	shl    $0x8,%eax
   10739:	89 c2                	mov    %eax,%edx
   1073b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1073e:	83 c0 09             	add    $0x9,%eax
   10741:	0f b6 00             	movzbl (%eax),%eax
   10744:	0f b6 c0             	movzbl %al,%eax
   10747:	01 d0                	add    %edx,%eax
   10749:	c1 e0 08             	shl    $0x8,%eax
   1074c:	89 c2                	mov    %eax,%edx
   1074e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10751:	83 c0 0a             	add    $0xa,%eax
   10754:	0f b6 00             	movzbl (%eax),%eax
   10757:	0f b6 c0             	movzbl %al,%eax
   1075a:	01 d0                	add    %edx,%eax
   1075c:	c1 e0 08             	shl    $0x8,%eax
   1075f:	89 c2                	mov    %eax,%edx
   10761:	8b 45 0c             	mov    0xc(%ebp),%eax
   10764:	83 c0 0b             	add    $0xb,%eax
   10767:	0f b6 00             	movzbl (%eax),%eax
   1076a:	0f b6 c0             	movzbl %al,%eax
   1076d:	01 c2                	add    %eax,%edx
   1076f:	8b 45 08             	mov    0x8(%ebp),%eax
   10772:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
   10778:	8b 45 0c             	mov    0xc(%ebp),%eax
   1077b:	83 c0 0c             	add    $0xc,%eax
   1077e:	0f b6 00             	movzbl (%eax),%eax
   10781:	0f b6 c0             	movzbl %al,%eax
   10784:	c1 e0 08             	shl    $0x8,%eax
   10787:	89 c2                	mov    %eax,%edx
   10789:	8b 45 0c             	mov    0xc(%ebp),%eax
   1078c:	83 c0 0d             	add    $0xd,%eax
   1078f:	0f b6 00             	movzbl (%eax),%eax
   10792:	0f b6 c0             	movzbl %al,%eax
   10795:	01 d0                	add    %edx,%eax
   10797:	c1 e0 08             	shl    $0x8,%eax
   1079a:	89 c2                	mov    %eax,%edx
   1079c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1079f:	83 c0 0e             	add    $0xe,%eax
   107a2:	0f b6 00             	movzbl (%eax),%eax
   107a5:	0f b6 c0             	movzbl %al,%eax
   107a8:	01 d0                	add    %edx,%eax
   107aa:	c1 e0 08             	shl    $0x8,%eax
   107ad:	89 c2                	mov    %eax,%edx
   107af:	8b 45 0c             	mov    0xc(%ebp),%eax
   107b2:	83 c0 0f             	add    $0xf,%eax
   107b5:	0f b6 00             	movzbl (%eax),%eax
   107b8:	0f b6 c0             	movzbl %al,%eax
   107bb:	01 c2                	add    %eax,%edx
   107bd:	8b 45 08             	mov    0x8(%ebp),%eax
   107c0:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
   107c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   107c9:	83 c0 10             	add    $0x10,%eax
   107cc:	0f b6 00             	movzbl (%eax),%eax
   107cf:	0f b6 c0             	movzbl %al,%eax
   107d2:	c1 e0 08             	shl    $0x8,%eax
   107d5:	89 c2                	mov    %eax,%edx
   107d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   107da:	83 c0 11             	add    $0x11,%eax
   107dd:	0f b6 00             	movzbl (%eax),%eax
   107e0:	0f b6 c0             	movzbl %al,%eax
   107e3:	01 d0                	add    %edx,%eax
   107e5:	c1 e0 08             	shl    $0x8,%eax
   107e8:	89 c2                	mov    %eax,%edx
   107ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   107ed:	83 c0 12             	add    $0x12,%eax
   107f0:	0f b6 00             	movzbl (%eax),%eax
   107f3:	0f b6 c0             	movzbl %al,%eax
   107f6:	01 d0                	add    %edx,%eax
   107f8:	c1 e0 08             	shl    $0x8,%eax
   107fb:	89 c2                	mov    %eax,%edx
   107fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   10800:	83 c0 13             	add    $0x13,%eax
   10803:	0f b6 00             	movzbl (%eax),%eax
   10806:	0f b6 c0             	movzbl %al,%eax
   10809:	01 c2                	add    %eax,%edx
   1080b:	8b 45 08             	mov    0x8(%ebp),%eax
   1080e:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
   10814:	8b 45 0c             	mov    0xc(%ebp),%eax
   10817:	83 c0 14             	add    $0x14,%eax
   1081a:	0f b6 00             	movzbl (%eax),%eax
   1081d:	0f b6 c0             	movzbl %al,%eax
   10820:	c1 e0 08             	shl    $0x8,%eax
   10823:	89 c2                	mov    %eax,%edx
   10825:	8b 45 0c             	mov    0xc(%ebp),%eax
   10828:	83 c0 15             	add    $0x15,%eax
   1082b:	0f b6 00             	movzbl (%eax),%eax
   1082e:	0f b6 c0             	movzbl %al,%eax
   10831:	01 d0                	add    %edx,%eax
   10833:	c1 e0 08             	shl    $0x8,%eax
   10836:	89 c2                	mov    %eax,%edx
   10838:	8b 45 0c             	mov    0xc(%ebp),%eax
   1083b:	83 c0 16             	add    $0x16,%eax
   1083e:	0f b6 00             	movzbl (%eax),%eax
   10841:	0f b6 c0             	movzbl %al,%eax
   10844:	01 d0                	add    %edx,%eax
   10846:	c1 e0 08             	shl    $0x8,%eax
   10849:	89 c2                	mov    %eax,%edx
   1084b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1084e:	83 c0 17             	add    $0x17,%eax
   10851:	0f b6 00             	movzbl (%eax),%eax
   10854:	0f b6 c0             	movzbl %al,%eax
   10857:	01 c2                	add    %eax,%edx
   10859:	8b 45 08             	mov    0x8(%ebp),%eax
   1085c:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
   10862:	8b 45 0c             	mov    0xc(%ebp),%eax
   10865:	83 c0 18             	add    $0x18,%eax
   10868:	0f b6 00             	movzbl (%eax),%eax
   1086b:	0f b6 c0             	movzbl %al,%eax
   1086e:	c1 e0 08             	shl    $0x8,%eax
   10871:	89 c2                	mov    %eax,%edx
   10873:	8b 45 0c             	mov    0xc(%ebp),%eax
   10876:	83 c0 19             	add    $0x19,%eax
   10879:	0f b6 00             	movzbl (%eax),%eax
   1087c:	0f b6 c0             	movzbl %al,%eax
   1087f:	01 d0                	add    %edx,%eax
   10881:	c1 e0 08             	shl    $0x8,%eax
   10884:	89 c2                	mov    %eax,%edx
   10886:	8b 45 0c             	mov    0xc(%ebp),%eax
   10889:	83 c0 1a             	add    $0x1a,%eax
   1088c:	0f b6 00             	movzbl (%eax),%eax
   1088f:	0f b6 c0             	movzbl %al,%eax
   10892:	01 d0                	add    %edx,%eax
   10894:	c1 e0 08             	shl    $0x8,%eax
   10897:	89 c2                	mov    %eax,%edx
   10899:	8b 45 0c             	mov    0xc(%ebp),%eax
   1089c:	83 c0 1b             	add    $0x1b,%eax
   1089f:	0f b6 00             	movzbl (%eax),%eax
   108a2:	0f b6 c0             	movzbl %al,%eax
   108a5:	01 c2                	add    %eax,%edx
   108a7:	8b 45 08             	mov    0x8(%ebp),%eax
   108aa:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
   108b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   108b3:	83 c0 1c             	add    $0x1c,%eax
   108b6:	0f b6 00             	movzbl (%eax),%eax
   108b9:	0f b6 c0             	movzbl %al,%eax
   108bc:	c1 e0 08             	shl    $0x8,%eax
   108bf:	89 c2                	mov    %eax,%edx
   108c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   108c4:	83 c0 1d             	add    $0x1d,%eax
   108c7:	0f b6 00             	movzbl (%eax),%eax
   108ca:	0f b6 c0             	movzbl %al,%eax
   108cd:	01 d0                	add    %edx,%eax
   108cf:	c1 e0 08             	shl    $0x8,%eax
   108d2:	89 c2                	mov    %eax,%edx
   108d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   108d7:	83 c0 1e             	add    $0x1e,%eax
   108da:	0f b6 00             	movzbl (%eax),%eax
   108dd:	0f b6 c0             	movzbl %al,%eax
   108e0:	01 d0                	add    %edx,%eax
   108e2:	c1 e0 08             	shl    $0x8,%eax
   108e5:	89 c2                	mov    %eax,%edx
   108e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ea:	83 c0 1f             	add    $0x1f,%eax
   108ed:	0f b6 00             	movzbl (%eax),%eax
   108f0:	0f b6 c0             	movzbl %al,%eax
   108f3:	01 c2                	add    %eax,%edx
   108f5:	8b 45 08             	mov    0x8(%ebp),%eax
   108f8:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
   108fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10903:	5d                   	pop    %ebp
   10904:	c3                   	ret    

00010905 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   10905:	55                   	push   %ebp
   10906:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
   10908:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
   1090c:	74 07                	je     10915 <readChunk_sRGB+0x10>
   1090e:	b8 62 00 00 00       	mov    $0x62,%eax
   10913:	eb 24                	jmp    10939 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
   10915:	8b 45 08             	mov    0x8(%ebp),%eax
   10918:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
   1091f:	00 00 00 
  info->srgb_intent = data[0];
   10922:	8b 45 0c             	mov    0xc(%ebp),%eax
   10925:	0f b6 00             	movzbl (%eax),%eax
   10928:	0f b6 d0             	movzbl %al,%edx
   1092b:	8b 45 08             	mov    0x8(%ebp),%eax
   1092e:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
   10934:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10939:	5d                   	pop    %ebp
   1093a:	c3                   	ret    

0001093b <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   1093b:	55                   	push   %ebp
   1093c:	89 e5                	mov    %esp,%ebp
   1093e:	53                   	push   %ebx
   1093f:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10942:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
   10949:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   10950:	8b 45 0c             	mov    0xc(%ebp),%eax
   10953:	8b 10                	mov    (%eax),%edx
   10955:	89 55 cc             	mov    %edx,-0x34(%ebp)
   10958:	8b 50 04             	mov    0x4(%eax),%edx
   1095b:	89 55 d0             	mov    %edx,-0x30(%ebp)
   1095e:	8b 50 08             	mov    0x8(%eax),%edx
   10961:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   10964:	8b 50 0c             	mov    0xc(%eax),%edx
   10967:	89 55 d8             	mov    %edx,-0x28(%ebp)
   1096a:	8b 50 10             	mov    0x10(%eax),%edx
   1096d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10970:	8b 40 14             	mov    0x14(%eax),%eax
   10973:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
   10976:	8b 45 08             	mov    0x8(%ebp),%eax
   10979:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
   10980:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
   10983:	8b 45 08             	mov    0x8(%ebp),%eax
   10986:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1098c:	85 c0                	test   %eax,%eax
   1098e:	74 0e                	je     1099e <readChunk_iCCP+0x63>
   10990:	83 ec 0c             	sub    $0xc,%esp
   10993:	ff 75 08             	pushl  0x8(%ebp)
   10996:	e8 ca a6 ff ff       	call   b065 <lodepng_clear_icc>
   1099b:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   1099e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   109a5:	eb 04                	jmp    109ab <readChunk_iCCP+0x70>
   109a7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   109ab:	8b 45 14             	mov    0x14(%ebp),%eax
   109ae:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   109b1:	73 0f                	jae    109c2 <readChunk_iCCP+0x87>
   109b3:	8b 55 10             	mov    0x10(%ebp),%edx
   109b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   109b9:	01 d0                	add    %edx,%eax
   109bb:	0f b6 00             	movzbl (%eax),%eax
   109be:	84 c0                	test   %al,%al
   109c0:	75 e5                	jne    109a7 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
   109c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   109c5:	8d 50 02             	lea    0x2(%eax),%edx
   109c8:	8b 45 14             	mov    0x14(%ebp),%eax
   109cb:	39 c2                	cmp    %eax,%edx
   109cd:	72 0a                	jb     109d9 <readChunk_iCCP+0x9e>
   109cf:	b8 4b 00 00 00       	mov    $0x4b,%eax
   109d4:	e9 46 01 00 00       	jmp    10b1f <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
   109d9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   109dd:	74 06                	je     109e5 <readChunk_iCCP+0xaa>
   109df:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   109e3:	76 0a                	jbe    109ef <readChunk_iCCP+0xb4>
   109e5:	b8 59 00 00 00       	mov    $0x59,%eax
   109ea:	e9 30 01 00 00       	jmp    10b1f <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
   109ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
   109f2:	83 c0 01             	add    $0x1,%eax
   109f5:	83 ec 0c             	sub    $0xc,%esp
   109f8:	50                   	push   %eax
   109f9:	e8 1a 40 ff ff       	call   4a18 <lodepng_malloc>
   109fe:	83 c4 10             	add    $0x10,%esp
   10a01:	89 c2                	mov    %eax,%edx
   10a03:	8b 45 08             	mov    0x8(%ebp),%eax
   10a06:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
   10a0c:	8b 45 08             	mov    0x8(%ebp),%eax
   10a0f:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   10a15:	85 c0                	test   %eax,%eax
   10a17:	75 0a                	jne    10a23 <readChunk_iCCP+0xe8>
   10a19:	b8 53 00 00 00       	mov    $0x53,%eax
   10a1e:	e9 fc 00 00 00       	jmp    10b1f <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
   10a23:	8b 45 08             	mov    0x8(%ebp),%eax
   10a26:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   10a2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a2f:	01 d0                	add    %edx,%eax
   10a31:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
   10a34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10a3b:	eb 1f                	jmp    10a5c <readChunk_iCCP+0x121>
   10a3d:	8b 45 08             	mov    0x8(%ebp),%eax
   10a40:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   10a46:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a49:	01 d0                	add    %edx,%eax
   10a4b:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10a4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10a51:	01 ca                	add    %ecx,%edx
   10a53:	0f b6 12             	movzbl (%edx),%edx
   10a56:	88 10                	mov    %dl,(%eax)
   10a58:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10a5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a5f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   10a62:	75 d9                	jne    10a3d <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
   10a64:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a67:	8d 50 01             	lea    0x1(%eax),%edx
   10a6a:	8b 45 10             	mov    0x10(%ebp),%eax
   10a6d:	01 d0                	add    %edx,%eax
   10a6f:	0f b6 00             	movzbl (%eax),%eax
   10a72:	84 c0                	test   %al,%al
   10a74:	74 0a                	je     10a80 <readChunk_iCCP+0x145>
   10a76:	b8 48 00 00 00       	mov    $0x48,%eax
   10a7b:	e9 9f 00 00 00       	jmp    10b1f <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
   10a80:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a83:	83 c0 02             	add    $0x2,%eax
   10a86:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
   10a89:	8b 45 14             	mov    0x14(%ebp),%eax
   10a8c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   10a8f:	76 0a                	jbe    10a9b <readChunk_iCCP+0x160>
   10a91:	b8 4b 00 00 00       	mov    $0x4b,%eax
   10a96:	e9 84 00 00 00       	jmp    10b1f <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
   10a9b:	8b 45 14             	mov    0x14(%ebp),%eax
   10a9e:	2b 45 e8             	sub    -0x18(%ebp),%eax
   10aa1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
   10aa4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aa7:	8b 40 34             	mov    0x34(%eax),%eax
   10aaa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
   10aad:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ab0:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10ab3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10ab6:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
   10ab9:	8b 55 08             	mov    0x8(%ebp),%edx
   10abc:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
   10ac2:	83 ec 08             	sub    $0x8,%esp
   10ac5:	8d 55 cc             	lea    -0x34(%ebp),%edx
   10ac8:	52                   	push   %edx
   10ac9:	50                   	push   %eax
   10aca:	53                   	push   %ebx
   10acb:	6a 00                	push   $0x0
   10acd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10ad0:	50                   	push   %eax
   10ad1:	51                   	push   %ecx
   10ad2:	e8 fc 89 ff ff       	call   94d3 <zlib_decompress>
   10ad7:	83 c4 20             	add    $0x20,%esp
   10ada:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
   10add:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ae1:	74 11                	je     10af4 <readChunk_iCCP+0x1b9>
   10ae3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10ae6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ae9:	39 c2                	cmp    %eax,%edx
   10aeb:	7d 07                	jge    10af4 <readChunk_iCCP+0x1b9>
   10aed:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
   10af4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10af7:	89 c2                	mov    %eax,%edx
   10af9:	8b 45 08             	mov    0x8(%ebp),%eax
   10afc:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
   10b02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b06:	75 14                	jne    10b1c <readChunk_iCCP+0x1e1>
   10b08:	8b 45 08             	mov    0x8(%ebp),%eax
   10b0b:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
   10b11:	85 c0                	test   %eax,%eax
   10b13:	75 07                	jne    10b1c <readChunk_iCCP+0x1e1>
   10b15:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
   10b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10b22:	c9                   	leave  
   10b23:	c3                   	ret    

00010b24 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
   10b24:	55                   	push   %ebp
   10b25:	89 e5                	mov    %esp,%ebp
   10b27:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
   10b2a:	8b 55 0c             	mov    0xc(%ebp),%edx
   10b2d:	8b 45 10             	mov    0x10(%ebp),%eax
   10b30:	01 d0                	add    %edx,%eax
   10b32:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
   10b35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
   10b3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
   10b43:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b46:	83 c0 04             	add    $0x4,%eax
   10b49:	3b 45 14             	cmp    0x14(%ebp),%eax
   10b4c:	7e 0a                	jle    10b58 <lodepng_inspect_chunk+0x34>
   10b4e:	b8 1e 00 00 00       	mov    $0x1e,%eax
   10b53:	e9 43 03 00 00       	jmp    10e9b <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
   10b58:	ff 75 ec             	pushl  -0x14(%ebp)
   10b5b:	e8 3a 8e ff ff       	call   999a <lodepng_chunk_length>
   10b60:	83 c4 04             	add    $0x4,%esp
   10b63:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
   10b66:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b69:	85 c0                	test   %eax,%eax
   10b6b:	79 0a                	jns    10b77 <lodepng_inspect_chunk+0x53>
   10b6d:	b8 3f 00 00 00       	mov    $0x3f,%eax
   10b72:	e9 24 03 00 00       	jmp    10e9b <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
   10b77:	ff 75 ec             	pushl  -0x14(%ebp)
   10b7a:	e8 53 8f ff ff       	call   9ad2 <lodepng_chunk_data_const>
   10b7f:	83 c4 04             	add    $0x4,%esp
   10b82:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
   10b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b88:	8d 50 04             	lea    0x4(%eax),%edx
   10b8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10b8e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10b91:	8b 55 14             	mov    0x14(%ebp),%edx
   10b94:	8b 45 10             	mov    0x10(%ebp),%eax
   10b97:	01 d0                	add    %edx,%eax
   10b99:	39 c1                	cmp    %eax,%ecx
   10b9b:	76 0a                	jbe    10ba7 <lodepng_inspect_chunk+0x83>
   10b9d:	b8 1e 00 00 00       	mov    $0x1e,%eax
   10ba2:	e9 f4 02 00 00       	jmp    10e9b <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   10ba7:	68 48 b7 01 00       	push   $0x1b748
   10bac:	ff 75 ec             	pushl  -0x14(%ebp)
   10baf:	e8 33 8e ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10bb4:	83 c4 08             	add    $0x8,%esp
   10bb7:	84 c0                	test   %al,%al
   10bb9:	74 24                	je     10bdf <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   10bbb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bbe:	8b 55 08             	mov    0x8(%ebp),%edx
   10bc1:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   10bc7:	83 ec 04             	sub    $0x4,%esp
   10bca:	50                   	push   %eax
   10bcb:	ff 75 e4             	pushl  -0x1c(%ebp)
   10bce:	52                   	push   %edx
   10bcf:	e8 5b ee ff ff       	call   fa2f <readChunk_PLTE>
   10bd4:	83 c4 10             	add    $0x10,%esp
   10bd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10bda:	e9 8a 02 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   10bdf:	83 ec 08             	sub    $0x8,%esp
   10be2:	68 4d b7 01 00       	push   $0x1b74d
   10be7:	ff 75 ec             	pushl  -0x14(%ebp)
   10bea:	e8 f8 8d ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10bef:	83 c4 10             	add    $0x10,%esp
   10bf2:	84 c0                	test   %al,%al
   10bf4:	74 24                	je     10c1a <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   10bf6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bf9:	8b 55 08             	mov    0x8(%ebp),%edx
   10bfc:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   10c02:	83 ec 04             	sub    $0x4,%esp
   10c05:	50                   	push   %eax
   10c06:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c09:	52                   	push   %edx
   10c0a:	e8 40 ef ff ff       	call   fb4f <readChunk_tRNS>
   10c0f:	83 c4 10             	add    $0x10,%esp
   10c12:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10c15:	e9 4f 02 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   10c1a:	83 ec 08             	sub    $0x8,%esp
   10c1d:	68 52 b7 01 00       	push   $0x1b752
   10c22:	ff 75 ec             	pushl  -0x14(%ebp)
   10c25:	e8 bd 8d ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10c2a:	83 c4 10             	add    $0x10,%esp
   10c2d:	84 c0                	test   %al,%al
   10c2f:	74 24                	je     10c55 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
   10c31:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c34:	8b 55 08             	mov    0x8(%ebp),%edx
   10c37:	81 c2 98 00 00 00    	add    $0x98,%edx
   10c3d:	83 ec 04             	sub    $0x4,%esp
   10c40:	50                   	push   %eax
   10c41:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c44:	52                   	push   %edx
   10c45:	e8 68 f0 ff ff       	call   fcb2 <readChunk_bKGD>
   10c4a:	83 c4 10             	add    $0x10,%esp
   10c4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10c50:	e9 14 02 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   10c55:	83 ec 08             	sub    $0x8,%esp
   10c58:	68 57 b7 01 00       	push   $0x1b757
   10c5d:	ff 75 ec             	pushl  -0x14(%ebp)
   10c60:	e8 82 8d ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10c65:	83 c4 10             	add    $0x10,%esp
   10c68:	84 c0                	test   %al,%al
   10c6a:	74 24                	je     10c90 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
   10c6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c6f:	8b 55 08             	mov    0x8(%ebp),%edx
   10c72:	81 c2 98 00 00 00    	add    $0x98,%edx
   10c78:	83 ec 04             	sub    $0x4,%esp
   10c7b:	50                   	push   %eax
   10c7c:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c7f:	52                   	push   %edx
   10c80:	e8 b0 f1 ff ff       	call   fe35 <readChunk_tEXt>
   10c85:	83 c4 10             	add    $0x10,%esp
   10c88:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10c8b:	e9 d9 01 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   10c90:	83 ec 08             	sub    $0x8,%esp
   10c93:	68 5c b7 01 00       	push   $0x1b75c
   10c98:	ff 75 ec             	pushl  -0x14(%ebp)
   10c9b:	e8 47 8d ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10ca0:	83 c4 10             	add    $0x10,%esp
   10ca3:	84 c0                	test   %al,%al
   10ca5:	74 25                	je     10ccc <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   10ca7:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10caa:	8b 45 08             	mov    0x8(%ebp),%eax
   10cad:	8b 4d 08             	mov    0x8(%ebp),%ecx
   10cb0:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10cb6:	52                   	push   %edx
   10cb7:	ff 75 e4             	pushl  -0x1c(%ebp)
   10cba:	50                   	push   %eax
   10cbb:	51                   	push   %ecx
   10cbc:	e8 c0 f2 ff ff       	call   ff81 <readChunk_zTXt>
   10cc1:	83 c4 10             	add    $0x10,%esp
   10cc4:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10cc7:	e9 9d 01 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   10ccc:	83 ec 08             	sub    $0x8,%esp
   10ccf:	68 61 b7 01 00       	push   $0x1b761
   10cd4:	ff 75 ec             	pushl  -0x14(%ebp)
   10cd7:	e8 0b 8d ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10cdc:	83 c4 10             	add    $0x10,%esp
   10cdf:	84 c0                	test   %al,%al
   10ce1:	74 25                	je     10d08 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   10ce3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10ce6:	8b 45 08             	mov    0x8(%ebp),%eax
   10ce9:	8b 4d 08             	mov    0x8(%ebp),%ecx
   10cec:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10cf2:	52                   	push   %edx
   10cf3:	ff 75 e4             	pushl  -0x1c(%ebp)
   10cf6:	50                   	push   %eax
   10cf7:	51                   	push   %ecx
   10cf8:	e8 40 f4 ff ff       	call   1013d <readChunk_iTXt>
   10cfd:	83 c4 10             	add    $0x10,%esp
   10d00:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10d03:	e9 61 01 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   10d08:	83 ec 08             	sub    $0x8,%esp
   10d0b:	68 66 b7 01 00       	push   $0x1b766
   10d10:	ff 75 ec             	pushl  -0x14(%ebp)
   10d13:	e8 cf 8c ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10d18:	83 c4 10             	add    $0x10,%esp
   10d1b:	84 c0                	test   %al,%al
   10d1d:	74 24                	je     10d43 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
   10d1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d22:	8b 55 08             	mov    0x8(%ebp),%edx
   10d25:	81 c2 98 00 00 00    	add    $0x98,%edx
   10d2b:	83 ec 04             	sub    $0x4,%esp
   10d2e:	50                   	push   %eax
   10d2f:	ff 75 e4             	pushl  -0x1c(%ebp)
   10d32:	52                   	push   %edx
   10d33:	e8 5b f7 ff ff       	call   10493 <readChunk_tIME>
   10d38:	83 c4 10             	add    $0x10,%esp
   10d3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10d3e:	e9 26 01 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   10d43:	83 ec 08             	sub    $0x8,%esp
   10d46:	68 6b b7 01 00       	push   $0x1b76b
   10d4b:	ff 75 ec             	pushl  -0x14(%ebp)
   10d4e:	e8 94 8c ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10d53:	83 c4 10             	add    $0x10,%esp
   10d56:	84 c0                	test   %al,%al
   10d58:	74 24                	je     10d7e <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
   10d5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d5d:	8b 55 08             	mov    0x8(%ebp),%edx
   10d60:	81 c2 98 00 00 00    	add    $0x98,%edx
   10d66:	83 ec 04             	sub    $0x4,%esp
   10d69:	50                   	push   %eax
   10d6a:	ff 75 e4             	pushl  -0x1c(%ebp)
   10d6d:	52                   	push   %edx
   10d6e:	e8 c0 f7 ff ff       	call   10533 <readChunk_pHYs>
   10d73:	83 c4 10             	add    $0x10,%esp
   10d76:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10d79:	e9 eb 00 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   10d7e:	83 ec 08             	sub    $0x8,%esp
   10d81:	68 70 b7 01 00       	push   $0x1b770
   10d86:	ff 75 ec             	pushl  -0x14(%ebp)
   10d89:	e8 59 8c ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10d8e:	83 c4 10             	add    $0x10,%esp
   10d91:	84 c0                	test   %al,%al
   10d93:	74 24                	je     10db9 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
   10d95:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d98:	8b 55 08             	mov    0x8(%ebp),%edx
   10d9b:	81 c2 98 00 00 00    	add    $0x98,%edx
   10da1:	83 ec 04             	sub    $0x4,%esp
   10da4:	50                   	push   %eax
   10da5:	ff 75 e4             	pushl  -0x1c(%ebp)
   10da8:	52                   	push   %edx
   10da9:	e8 54 f8 ff ff       	call   10602 <readChunk_gAMA>
   10dae:	83 c4 10             	add    $0x10,%esp
   10db1:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10db4:	e9 b0 00 00 00       	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   10db9:	83 ec 08             	sub    $0x8,%esp
   10dbc:	68 75 b7 01 00       	push   $0x1b775
   10dc1:	ff 75 ec             	pushl  -0x14(%ebp)
   10dc4:	e8 1e 8c ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10dc9:	83 c4 10             	add    $0x10,%esp
   10dcc:	84 c0                	test   %al,%al
   10dce:	74 21                	je     10df1 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
   10dd0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10dd3:	8b 55 08             	mov    0x8(%ebp),%edx
   10dd6:	81 c2 98 00 00 00    	add    $0x98,%edx
   10ddc:	83 ec 04             	sub    $0x4,%esp
   10ddf:	50                   	push   %eax
   10de0:	ff 75 e4             	pushl  -0x1c(%ebp)
   10de3:	52                   	push   %edx
   10de4:	e8 88 f8 ff ff       	call   10671 <readChunk_cHRM>
   10de9:	83 c4 10             	add    $0x10,%esp
   10dec:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10def:	eb 78                	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   10df1:	83 ec 08             	sub    $0x8,%esp
   10df4:	68 7a b7 01 00       	push   $0x1b77a
   10df9:	ff 75 ec             	pushl  -0x14(%ebp)
   10dfc:	e8 e6 8b ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10e01:	83 c4 10             	add    $0x10,%esp
   10e04:	84 c0                	test   %al,%al
   10e06:	74 21                	je     10e29 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10e08:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e0b:	8b 55 08             	mov    0x8(%ebp),%edx
   10e0e:	81 c2 98 00 00 00    	add    $0x98,%edx
   10e14:	83 ec 04             	sub    $0x4,%esp
   10e17:	50                   	push   %eax
   10e18:	ff 75 e4             	pushl  -0x1c(%ebp)
   10e1b:	52                   	push   %edx
   10e1c:	e8 e4 fa ff ff       	call   10905 <readChunk_sRGB>
   10e21:	83 c4 10             	add    $0x10,%esp
   10e24:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10e27:	eb 40                	jmp    10e69 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   10e29:	83 ec 08             	sub    $0x8,%esp
   10e2c:	68 7f b7 01 00       	push   $0x1b77f
   10e31:	ff 75 ec             	pushl  -0x14(%ebp)
   10e34:	e8 ae 8b ff ff       	call   99e7 <lodepng_chunk_type_equals>
   10e39:	83 c4 10             	add    $0x10,%esp
   10e3c:	84 c0                	test   %al,%al
   10e3e:	74 22                	je     10e62 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   10e40:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10e43:	8b 45 08             	mov    0x8(%ebp),%eax
   10e46:	8b 4d 08             	mov    0x8(%ebp),%ecx
   10e49:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10e4f:	52                   	push   %edx
   10e50:	ff 75 e4             	pushl  -0x1c(%ebp)
   10e53:	50                   	push   %eax
   10e54:	51                   	push   %ecx
   10e55:	e8 e1 fa ff ff       	call   1093b <readChunk_iCCP>
   10e5a:	83 c4 10             	add    $0x10,%esp
   10e5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10e60:	eb 07                	jmp    10e69 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
   10e62:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
   10e69:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10e6d:	75 29                	jne    10e98 <lodepng_inspect_chunk+0x374>
   10e6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e73:	75 23                	jne    10e98 <lodepng_inspect_chunk+0x374>
   10e75:	8b 45 08             	mov    0x8(%ebp),%eax
   10e78:	8b 40 18             	mov    0x18(%eax),%eax
   10e7b:	85 c0                	test   %eax,%eax
   10e7d:	75 19                	jne    10e98 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
   10e7f:	83 ec 0c             	sub    $0xc,%esp
   10e82:	ff 75 ec             	pushl  -0x14(%ebp)
   10e85:	e8 53 8c ff ff       	call   9add <lodepng_chunk_check_crc>
   10e8a:	83 c4 10             	add    $0x10,%esp
   10e8d:	85 c0                	test   %eax,%eax
   10e8f:	74 07                	je     10e98 <lodepng_inspect_chunk+0x374>
   10e91:	b8 39 00 00 00       	mov    $0x39,%eax
   10e96:	eb 03                	jmp    10e9b <lodepng_inspect_chunk+0x377>
  }

  return error;
   10e98:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   10e9b:	c9                   	leave  
   10e9c:	c3                   	ret    

00010e9d <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
   10e9d:	55                   	push   %ebp
   10e9e:	89 e5                	mov    %esp,%ebp
   10ea0:	56                   	push   %esi
   10ea1:	53                   	push   %ebx
   10ea2:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
   10ea5:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
   10ea9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
   10eb0:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
   10eb7:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   10ebe:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
   10ec5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
   10ecc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
   10ed3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
   10eda:	8b 45 08             	mov    0x8(%ebp),%eax
   10edd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10ee3:	8b 45 10             	mov    0x10(%ebp),%eax
   10ee6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   10eec:	8b 45 10             	mov    0x10(%ebp),%eax
   10eef:	8b 10                	mov    (%eax),%edx
   10ef1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ef4:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
   10ef6:	83 ec 0c             	sub    $0xc,%esp
   10ef9:	ff 75 1c             	pushl  0x1c(%ebp)
   10efc:	ff 75 18             	pushl  0x18(%ebp)
   10eff:	ff 75 14             	pushl  0x14(%ebp)
   10f02:	ff 75 10             	pushl  0x10(%ebp)
   10f05:	ff 75 0c             	pushl  0xc(%ebp)
   10f08:	e8 d3 da ff ff       	call   e9e0 <lodepng_inspect>
   10f0d:	83 c4 20             	add    $0x20,%esp
   10f10:	89 c2                	mov    %eax,%edx
   10f12:	8b 45 14             	mov    0x14(%ebp),%eax
   10f15:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
   10f1b:	8b 45 14             	mov    0x14(%ebp),%eax
   10f1e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10f24:	85 c0                	test   %eax,%eax
   10f26:	0f 85 24 0a 00 00    	jne    11950 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
   10f2c:	8b 45 14             	mov    0x14(%ebp),%eax
   10f2f:	8d 58 78             	lea    0x78(%eax),%ebx
   10f32:	8b 45 14             	mov    0x14(%ebp),%eax
   10f35:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   10f3b:	8b 45 10             	mov    0x10(%ebp),%eax
   10f3e:	8b 10                	mov    (%eax),%edx
   10f40:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f43:	8b 00                	mov    (%eax),%eax
   10f45:	53                   	push   %ebx
   10f46:	51                   	push   %ecx
   10f47:	52                   	push   %edx
   10f48:	50                   	push   %eax
   10f49:	e8 76 97 ff ff       	call   a6c4 <lodepng_pixel_overflow>
   10f4e:	83 c4 10             	add    $0x10,%esp
   10f51:	85 c0                	test   %eax,%eax
   10f53:	74 12                	je     10f67 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
   10f55:	8b 45 14             	mov    0x14(%ebp),%eax
   10f58:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
   10f5f:	00 00 00 
   10f62:	e9 ea 09 00 00       	jmp    11951 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
   10f67:	83 ec 0c             	sub    $0xc,%esp
   10f6a:	ff 75 1c             	pushl  0x1c(%ebp)
   10f6d:	e8 a6 3a ff ff       	call   4a18 <lodepng_malloc>
   10f72:	83 c4 10             	add    $0x10,%esp
   10f75:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
   10f78:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   10f7c:	75 12                	jne    10f90 <decodeGeneric+0xf3>
   10f7e:	8b 45 14             	mov    0x14(%ebp),%eax
   10f81:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10f88:	00 00 00 
   10f8b:	e9 c1 09 00 00       	jmp    11951 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
   10f90:	8b 45 18             	mov    0x18(%ebp),%eax
   10f93:	83 c0 21             	add    $0x21,%eax
   10f96:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   10f99:	e9 81 06 00 00       	jmp    1161f <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
   10f9e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10fa1:	8b 45 18             	mov    0x18(%ebp),%eax
   10fa4:	29 c2                	sub    %eax,%edx
   10fa6:	89 d0                	mov    %edx,%eax
   10fa8:	83 c0 0c             	add    $0xc,%eax
   10fab:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   10fae:	7f 08                	jg     10fb8 <decodeGeneric+0x11b>
   10fb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fb3:	3b 45 18             	cmp    0x18(%ebp),%eax
   10fb6:	73 20                	jae    10fd8 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10fb8:	8b 45 14             	mov    0x14(%ebp),%eax
   10fbb:	8b 40 20             	mov    0x20(%eax),%eax
   10fbe:	85 c0                	test   %eax,%eax
   10fc0:	0f 85 72 06 00 00    	jne    11638 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
   10fc6:	8b 45 14             	mov    0x14(%ebp),%eax
   10fc9:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
   10fd0:	00 00 00 
   10fd3:	e9 6a 06 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
   10fd8:	83 ec 0c             	sub    $0xc,%esp
   10fdb:	ff 75 f0             	pushl  -0x10(%ebp)
   10fde:	e8 b7 89 ff ff       	call   999a <lodepng_chunk_length>
   10fe3:	83 c4 10             	add    $0x10,%esp
   10fe6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
   10fe9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10fec:	85 c0                	test   %eax,%eax
   10fee:	79 20                	jns    11010 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10ff0:	8b 45 14             	mov    0x14(%ebp),%eax
   10ff3:	8b 40 20             	mov    0x20(%eax),%eax
   10ff6:	85 c0                	test   %eax,%eax
   10ff8:	0f 85 3d 06 00 00    	jne    1163b <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
   10ffe:	8b 45 14             	mov    0x14(%ebp),%eax
   11001:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
   11008:	00 00 00 
   1100b:	e9 32 06 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
   11010:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11013:	8b 45 18             	mov    0x18(%ebp),%eax
   11016:	29 c2                	sub    %eax,%edx
   11018:	89 d0                	mov    %edx,%eax
   1101a:	89 c2                	mov    %eax,%edx
   1101c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1101f:	01 d0                	add    %edx,%eax
   11021:	83 c0 0c             	add    $0xc,%eax
   11024:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   11027:	7f 10                	jg     11039 <decodeGeneric+0x19c>
   11029:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1102c:	8d 50 0c             	lea    0xc(%eax),%edx
   1102f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11032:	01 d0                	add    %edx,%eax
   11034:	3b 45 18             	cmp    0x18(%ebp),%eax
   11037:	73 12                	jae    1104b <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
   11039:	8b 45 14             	mov    0x14(%ebp),%eax
   1103c:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
   11043:	00 00 00 
   11046:	e9 f7 05 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
   1104b:	83 ec 0c             	sub    $0xc,%esp
   1104e:	ff 75 f0             	pushl  -0x10(%ebp)
   11051:	e8 7c 8a ff ff       	call   9ad2 <lodepng_chunk_data_const>
   11056:	83 c4 10             	add    $0x10,%esp
   11059:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
   1105c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
   11063:	83 ec 08             	sub    $0x8,%esp
   11066:	68 84 b7 01 00       	push   $0x1b784
   1106b:	ff 75 f0             	pushl  -0x10(%ebp)
   1106e:	e8 74 89 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   11073:	83 c4 10             	add    $0x10,%esp
   11076:	84 c0                	test   %al,%al
   11078:	74 79                	je     110f3 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
   1107a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1107d:	83 ec 04             	sub    $0x4,%esp
   11080:	8d 55 bc             	lea    -0x44(%ebp),%edx
   11083:	52                   	push   %edx
   11084:	50                   	push   %eax
   11085:	ff 75 ec             	pushl  -0x14(%ebp)
   11088:	e8 4f 3a ff ff       	call   4adc <lodepng_addofl>
   1108d:	83 c4 10             	add    $0x10,%esp
   11090:	85 c0                	test   %eax,%eax
   11092:	74 12                	je     110a6 <decodeGeneric+0x209>
   11094:	8b 45 14             	mov    0x14(%ebp),%eax
   11097:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   1109e:	00 00 00 
   110a1:	e9 9c 05 00 00       	jmp    11642 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
   110a6:	8b 45 bc             	mov    -0x44(%ebp),%eax
   110a9:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   110ac:	7e 13                	jle    110c1 <decodeGeneric+0x224>
   110ae:	8b 45 14             	mov    0x14(%ebp),%eax
   110b1:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   110b8:	00 00 00 
   110bb:	90                   	nop
   110bc:	e9 81 05 00 00       	jmp    11642 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
   110c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   110c4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   110c7:	8b 55 d8             	mov    -0x28(%ebp),%edx
   110ca:	01 ca                	add    %ecx,%edx
   110cc:	83 ec 04             	sub    $0x4,%esp
   110cf:	50                   	push   %eax
   110d0:	ff 75 d0             	pushl  -0x30(%ebp)
   110d3:	52                   	push   %edx
   110d4:	e8 7d 39 ff ff       	call   4a56 <lodepng_memcpy>
   110d9:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
   110dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   110e2:	01 d0                	add    %edx,%eax
   110e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
   110e7:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
   110ee:	e9 db 04 00 00       	jmp    115ce <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
   110f3:	83 ec 08             	sub    $0x8,%esp
   110f6:	68 89 b7 01 00       	push   $0x1b789
   110fb:	ff 75 f0             	pushl  -0x10(%ebp)
   110fe:	e8 e4 88 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   11103:	83 c4 10             	add    $0x10,%esp
   11106:	84 c0                	test   %al,%al
   11108:	74 09                	je     11113 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
   1110a:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
   1110e:	e9 bb 04 00 00       	jmp    115ce <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   11113:	83 ec 08             	sub    $0x8,%esp
   11116:	68 48 b7 01 00       	push   $0x1b748
   1111b:	ff 75 f0             	pushl  -0x10(%ebp)
   1111e:	e8 c4 88 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   11123:	83 c4 10             	add    $0x10,%esp
   11126:	84 c0                	test   %al,%al
   11128:	74 44                	je     1116e <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   1112a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1112d:	8b 55 14             	mov    0x14(%ebp),%edx
   11130:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   11136:	83 ec 04             	sub    $0x4,%esp
   11139:	50                   	push   %eax
   1113a:	ff 75 d0             	pushl  -0x30(%ebp)
   1113d:	52                   	push   %edx
   1113e:	e8 ec e8 ff ff       	call   fa2f <readChunk_PLTE>
   11143:	83 c4 10             	add    $0x10,%esp
   11146:	89 c2                	mov    %eax,%edx
   11148:	8b 45 14             	mov    0x14(%ebp),%eax
   1114b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   11151:	8b 45 14             	mov    0x14(%ebp),%eax
   11154:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1115a:	85 c0                	test   %eax,%eax
   1115c:	0f 85 dc 04 00 00    	jne    1163e <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
   11162:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
   11169:	e9 60 04 00 00       	jmp    115ce <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   1116e:	83 ec 08             	sub    $0x8,%esp
   11171:	68 4d b7 01 00       	push   $0x1b74d
   11176:	ff 75 f0             	pushl  -0x10(%ebp)
   11179:	e8 69 88 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   1117e:	83 c4 10             	add    $0x10,%esp
   11181:	84 c0                	test   %al,%al
   11183:	74 3d                	je     111c2 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   11185:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11188:	8b 55 14             	mov    0x14(%ebp),%edx
   1118b:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   11191:	83 ec 04             	sub    $0x4,%esp
   11194:	50                   	push   %eax
   11195:	ff 75 d0             	pushl  -0x30(%ebp)
   11198:	52                   	push   %edx
   11199:	e8 b1 e9 ff ff       	call   fb4f <readChunk_tRNS>
   1119e:	83 c4 10             	add    $0x10,%esp
   111a1:	89 c2                	mov    %eax,%edx
   111a3:	8b 45 14             	mov    0x14(%ebp),%eax
   111a6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   111ac:	8b 45 14             	mov    0x14(%ebp),%eax
   111af:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   111b5:	85 c0                	test   %eax,%eax
   111b7:	0f 84 11 04 00 00    	je     115ce <decodeGeneric+0x731>
   111bd:	e9 80 04 00 00       	jmp    11642 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   111c2:	83 ec 08             	sub    $0x8,%esp
   111c5:	68 52 b7 01 00       	push   $0x1b752
   111ca:	ff 75 f0             	pushl  -0x10(%ebp)
   111cd:	e8 15 88 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   111d2:	83 c4 10             	add    $0x10,%esp
   111d5:	84 c0                	test   %al,%al
   111d7:	74 3d                	je     11216 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
   111d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   111dc:	8b 55 14             	mov    0x14(%ebp),%edx
   111df:	81 c2 98 00 00 00    	add    $0x98,%edx
   111e5:	83 ec 04             	sub    $0x4,%esp
   111e8:	50                   	push   %eax
   111e9:	ff 75 d0             	pushl  -0x30(%ebp)
   111ec:	52                   	push   %edx
   111ed:	e8 c0 ea ff ff       	call   fcb2 <readChunk_bKGD>
   111f2:	83 c4 10             	add    $0x10,%esp
   111f5:	89 c2                	mov    %eax,%edx
   111f7:	8b 45 14             	mov    0x14(%ebp),%eax
   111fa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   11200:	8b 45 14             	mov    0x14(%ebp),%eax
   11203:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11209:	85 c0                	test   %eax,%eax
   1120b:	0f 84 bd 03 00 00    	je     115ce <decodeGeneric+0x731>
   11211:	e9 2c 04 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   11216:	83 ec 08             	sub    $0x8,%esp
   11219:	68 57 b7 01 00       	push   $0x1b757
   1121e:	ff 75 f0             	pushl  -0x10(%ebp)
   11221:	e8 c1 87 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   11226:	83 c4 10             	add    $0x10,%esp
   11229:	84 c0                	test   %al,%al
   1122b:	74 4b                	je     11278 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
   1122d:	8b 45 14             	mov    0x14(%ebp),%eax
   11230:	8b 40 28             	mov    0x28(%eax),%eax
   11233:	85 c0                	test   %eax,%eax
   11235:	0f 84 93 03 00 00    	je     115ce <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
   1123b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1123e:	8b 55 14             	mov    0x14(%ebp),%edx
   11241:	81 c2 98 00 00 00    	add    $0x98,%edx
   11247:	83 ec 04             	sub    $0x4,%esp
   1124a:	50                   	push   %eax
   1124b:	ff 75 d0             	pushl  -0x30(%ebp)
   1124e:	52                   	push   %edx
   1124f:	e8 e1 eb ff ff       	call   fe35 <readChunk_tEXt>
   11254:	83 c4 10             	add    $0x10,%esp
   11257:	89 c2                	mov    %eax,%edx
   11259:	8b 45 14             	mov    0x14(%ebp),%eax
   1125c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   11262:	8b 45 14             	mov    0x14(%ebp),%eax
   11265:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1126b:	85 c0                	test   %eax,%eax
   1126d:	0f 84 5b 03 00 00    	je     115ce <decodeGeneric+0x731>
   11273:	e9 ca 03 00 00       	jmp    11642 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   11278:	83 ec 08             	sub    $0x8,%esp
   1127b:	68 5c b7 01 00       	push   $0x1b75c
   11280:	ff 75 f0             	pushl  -0x10(%ebp)
   11283:	e8 5f 87 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   11288:	83 c4 10             	add    $0x10,%esp
   1128b:	84 c0                	test   %al,%al
   1128d:	74 4c                	je     112db <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
   1128f:	8b 45 14             	mov    0x14(%ebp),%eax
   11292:	8b 40 28             	mov    0x28(%eax),%eax
   11295:	85 c0                	test   %eax,%eax
   11297:	0f 84 31 03 00 00    	je     115ce <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   1129d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   112a0:	8b 45 14             	mov    0x14(%ebp),%eax
   112a3:	8b 4d 14             	mov    0x14(%ebp),%ecx
   112a6:	81 c1 98 00 00 00    	add    $0x98,%ecx
   112ac:	52                   	push   %edx
   112ad:	ff 75 d0             	pushl  -0x30(%ebp)
   112b0:	50                   	push   %eax
   112b1:	51                   	push   %ecx
   112b2:	e8 ca ec ff ff       	call   ff81 <readChunk_zTXt>
   112b7:	83 c4 10             	add    $0x10,%esp
   112ba:	89 c2                	mov    %eax,%edx
   112bc:	8b 45 14             	mov    0x14(%ebp),%eax
   112bf:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   112c5:	8b 45 14             	mov    0x14(%ebp),%eax
   112c8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   112ce:	85 c0                	test   %eax,%eax
   112d0:	0f 84 f8 02 00 00    	je     115ce <decodeGeneric+0x731>
   112d6:	e9 67 03 00 00       	jmp    11642 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   112db:	83 ec 08             	sub    $0x8,%esp
   112de:	68 61 b7 01 00       	push   $0x1b761
   112e3:	ff 75 f0             	pushl  -0x10(%ebp)
   112e6:	e8 fc 86 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   112eb:	83 c4 10             	add    $0x10,%esp
   112ee:	84 c0                	test   %al,%al
   112f0:	74 4c                	je     1133e <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
   112f2:	8b 45 14             	mov    0x14(%ebp),%eax
   112f5:	8b 40 28             	mov    0x28(%eax),%eax
   112f8:	85 c0                	test   %eax,%eax
   112fa:	0f 84 ce 02 00 00    	je     115ce <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   11300:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   11303:	8b 45 14             	mov    0x14(%ebp),%eax
   11306:	8b 4d 14             	mov    0x14(%ebp),%ecx
   11309:	81 c1 98 00 00 00    	add    $0x98,%ecx
   1130f:	52                   	push   %edx
   11310:	ff 75 d0             	pushl  -0x30(%ebp)
   11313:	50                   	push   %eax
   11314:	51                   	push   %ecx
   11315:	e8 23 ee ff ff       	call   1013d <readChunk_iTXt>
   1131a:	83 c4 10             	add    $0x10,%esp
   1131d:	89 c2                	mov    %eax,%edx
   1131f:	8b 45 14             	mov    0x14(%ebp),%eax
   11322:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   11328:	8b 45 14             	mov    0x14(%ebp),%eax
   1132b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11331:	85 c0                	test   %eax,%eax
   11333:	0f 84 95 02 00 00    	je     115ce <decodeGeneric+0x731>
   11339:	e9 04 03 00 00       	jmp    11642 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   1133e:	83 ec 08             	sub    $0x8,%esp
   11341:	68 66 b7 01 00       	push   $0x1b766
   11346:	ff 75 f0             	pushl  -0x10(%ebp)
   11349:	e8 99 86 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   1134e:	83 c4 10             	add    $0x10,%esp
   11351:	84 c0                	test   %al,%al
   11353:	74 3d                	je     11392 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   11355:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11358:	8b 55 14             	mov    0x14(%ebp),%edx
   1135b:	81 c2 98 00 00 00    	add    $0x98,%edx
   11361:	83 ec 04             	sub    $0x4,%esp
   11364:	50                   	push   %eax
   11365:	ff 75 d0             	pushl  -0x30(%ebp)
   11368:	52                   	push   %edx
   11369:	e8 25 f1 ff ff       	call   10493 <readChunk_tIME>
   1136e:	83 c4 10             	add    $0x10,%esp
   11371:	89 c2                	mov    %eax,%edx
   11373:	8b 45 14             	mov    0x14(%ebp),%eax
   11376:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1137c:	8b 45 14             	mov    0x14(%ebp),%eax
   1137f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11385:	85 c0                	test   %eax,%eax
   11387:	0f 84 41 02 00 00    	je     115ce <decodeGeneric+0x731>
   1138d:	e9 b0 02 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   11392:	83 ec 08             	sub    $0x8,%esp
   11395:	68 6b b7 01 00       	push   $0x1b76b
   1139a:	ff 75 f0             	pushl  -0x10(%ebp)
   1139d:	e8 45 86 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   113a2:	83 c4 10             	add    $0x10,%esp
   113a5:	84 c0                	test   %al,%al
   113a7:	74 3d                	je     113e6 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   113a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   113ac:	8b 55 14             	mov    0x14(%ebp),%edx
   113af:	81 c2 98 00 00 00    	add    $0x98,%edx
   113b5:	83 ec 04             	sub    $0x4,%esp
   113b8:	50                   	push   %eax
   113b9:	ff 75 d0             	pushl  -0x30(%ebp)
   113bc:	52                   	push   %edx
   113bd:	e8 71 f1 ff ff       	call   10533 <readChunk_pHYs>
   113c2:	83 c4 10             	add    $0x10,%esp
   113c5:	89 c2                	mov    %eax,%edx
   113c7:	8b 45 14             	mov    0x14(%ebp),%eax
   113ca:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   113d0:	8b 45 14             	mov    0x14(%ebp),%eax
   113d3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   113d9:	85 c0                	test   %eax,%eax
   113db:	0f 84 ed 01 00 00    	je     115ce <decodeGeneric+0x731>
   113e1:	e9 5c 02 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   113e6:	83 ec 08             	sub    $0x8,%esp
   113e9:	68 70 b7 01 00       	push   $0x1b770
   113ee:	ff 75 f0             	pushl  -0x10(%ebp)
   113f1:	e8 f1 85 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   113f6:	83 c4 10             	add    $0x10,%esp
   113f9:	84 c0                	test   %al,%al
   113fb:	74 3d                	je     1143a <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   113fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11400:	8b 55 14             	mov    0x14(%ebp),%edx
   11403:	81 c2 98 00 00 00    	add    $0x98,%edx
   11409:	83 ec 04             	sub    $0x4,%esp
   1140c:	50                   	push   %eax
   1140d:	ff 75 d0             	pushl  -0x30(%ebp)
   11410:	52                   	push   %edx
   11411:	e8 ec f1 ff ff       	call   10602 <readChunk_gAMA>
   11416:	83 c4 10             	add    $0x10,%esp
   11419:	89 c2                	mov    %eax,%edx
   1141b:	8b 45 14             	mov    0x14(%ebp),%eax
   1141e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   11424:	8b 45 14             	mov    0x14(%ebp),%eax
   11427:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1142d:	85 c0                	test   %eax,%eax
   1142f:	0f 84 99 01 00 00    	je     115ce <decodeGeneric+0x731>
   11435:	e9 08 02 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   1143a:	83 ec 08             	sub    $0x8,%esp
   1143d:	68 75 b7 01 00       	push   $0x1b775
   11442:	ff 75 f0             	pushl  -0x10(%ebp)
   11445:	e8 9d 85 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   1144a:	83 c4 10             	add    $0x10,%esp
   1144d:	84 c0                	test   %al,%al
   1144f:	74 3d                	je     1148e <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   11451:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11454:	8b 55 14             	mov    0x14(%ebp),%edx
   11457:	81 c2 98 00 00 00    	add    $0x98,%edx
   1145d:	83 ec 04             	sub    $0x4,%esp
   11460:	50                   	push   %eax
   11461:	ff 75 d0             	pushl  -0x30(%ebp)
   11464:	52                   	push   %edx
   11465:	e8 07 f2 ff ff       	call   10671 <readChunk_cHRM>
   1146a:	83 c4 10             	add    $0x10,%esp
   1146d:	89 c2                	mov    %eax,%edx
   1146f:	8b 45 14             	mov    0x14(%ebp),%eax
   11472:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   11478:	8b 45 14             	mov    0x14(%ebp),%eax
   1147b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11481:	85 c0                	test   %eax,%eax
   11483:	0f 84 45 01 00 00    	je     115ce <decodeGeneric+0x731>
   11489:	e9 b4 01 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   1148e:	83 ec 08             	sub    $0x8,%esp
   11491:	68 7a b7 01 00       	push   $0x1b77a
   11496:	ff 75 f0             	pushl  -0x10(%ebp)
   11499:	e8 49 85 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   1149e:	83 c4 10             	add    $0x10,%esp
   114a1:	84 c0                	test   %al,%al
   114a3:	74 3d                	je     114e2 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   114a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   114a8:	8b 55 14             	mov    0x14(%ebp),%edx
   114ab:	81 c2 98 00 00 00    	add    $0x98,%edx
   114b1:	83 ec 04             	sub    $0x4,%esp
   114b4:	50                   	push   %eax
   114b5:	ff 75 d0             	pushl  -0x30(%ebp)
   114b8:	52                   	push   %edx
   114b9:	e8 47 f4 ff ff       	call   10905 <readChunk_sRGB>
   114be:	83 c4 10             	add    $0x10,%esp
   114c1:	89 c2                	mov    %eax,%edx
   114c3:	8b 45 14             	mov    0x14(%ebp),%eax
   114c6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   114cc:	8b 45 14             	mov    0x14(%ebp),%eax
   114cf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   114d5:	85 c0                	test   %eax,%eax
   114d7:	0f 84 f1 00 00 00    	je     115ce <decodeGeneric+0x731>
   114dd:	e9 60 01 00 00       	jmp    11642 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   114e2:	83 ec 08             	sub    $0x8,%esp
   114e5:	68 7f b7 01 00       	push   $0x1b77f
   114ea:	ff 75 f0             	pushl  -0x10(%ebp)
   114ed:	e8 f5 84 ff ff       	call   99e7 <lodepng_chunk_type_equals>
   114f2:	83 c4 10             	add    $0x10,%esp
   114f5:	84 c0                	test   %al,%al
   114f7:	74 3e                	je     11537 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   114f9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   114fc:	8b 45 14             	mov    0x14(%ebp),%eax
   114ff:	8b 4d 14             	mov    0x14(%ebp),%ecx
   11502:	81 c1 98 00 00 00    	add    $0x98,%ecx
   11508:	52                   	push   %edx
   11509:	ff 75 d0             	pushl  -0x30(%ebp)
   1150c:	50                   	push   %eax
   1150d:	51                   	push   %ecx
   1150e:	e8 28 f4 ff ff       	call   1093b <readChunk_iCCP>
   11513:	83 c4 10             	add    $0x10,%esp
   11516:	89 c2                	mov    %eax,%edx
   11518:	8b 45 14             	mov    0x14(%ebp),%eax
   1151b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   11521:	8b 45 14             	mov    0x14(%ebp),%eax
   11524:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1152a:	85 c0                	test   %eax,%eax
   1152c:	0f 84 9c 00 00 00    	je     115ce <decodeGeneric+0x731>
   11532:	e9 0b 01 00 00       	jmp    11642 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   11537:	8b 45 14             	mov    0x14(%ebp),%eax
   1153a:	8b 40 1c             	mov    0x1c(%eax),%eax
   1153d:	85 c0                	test   %eax,%eax
   1153f:	75 24                	jne    11565 <decodeGeneric+0x6c8>
   11541:	83 ec 0c             	sub    $0xc,%esp
   11544:	ff 75 f0             	pushl  -0x10(%ebp)
   11547:	e8 30 85 ff ff       	call   9a7c <lodepng_chunk_ancillary>
   1154c:	83 c4 10             	add    $0x10,%esp
   1154f:	84 c0                	test   %al,%al
   11551:	75 12                	jne    11565 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   11553:	8b 45 14             	mov    0x14(%ebp),%eax
   11556:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   1155d:	00 00 00 
   11560:	e9 dd 00 00 00       	jmp    11642 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   11565:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   1156c:	8b 45 14             	mov    0x14(%ebp),%eax
   1156f:	8b 40 2c             	mov    0x2c(%eax),%eax
   11572:	85 c0                	test   %eax,%eax
   11574:	74 58                	je     115ce <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   11576:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11579:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   1157c:	83 c0 58             	add    $0x58,%eax
   1157f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11586:	8b 45 14             	mov    0x14(%ebp),%eax
   11589:	01 d0                	add    %edx,%eax
   1158b:	8d 50 10             	lea    0x10(%eax),%edx
   1158e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11591:	83 e8 01             	sub    $0x1,%eax
   11594:	83 c0 54             	add    $0x54,%eax
   11597:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   1159e:	8b 45 14             	mov    0x14(%ebp),%eax
   115a1:	01 c8                	add    %ecx,%eax
   115a3:	83 c0 14             	add    $0x14,%eax
   115a6:	83 ec 04             	sub    $0x4,%esp
   115a9:	ff 75 f0             	pushl  -0x10(%ebp)
   115ac:	52                   	push   %edx
   115ad:	50                   	push   %eax
   115ae:	e8 15 88 ff ff       	call   9dc8 <lodepng_chunk_append>
   115b3:	83 c4 10             	add    $0x10,%esp
   115b6:	89 c2                	mov    %eax,%edx
   115b8:	8b 45 14             	mov    0x14(%ebp),%eax
   115bb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   115c1:	8b 45 14             	mov    0x14(%ebp),%eax
   115c4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   115ca:	85 c0                	test   %eax,%eax
   115cc:	75 73                	jne    11641 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   115ce:	8b 45 14             	mov    0x14(%ebp),%eax
   115d1:	8b 40 18             	mov    0x18(%eax),%eax
   115d4:	85 c0                	test   %eax,%eax
   115d6:	75 27                	jne    115ff <decodeGeneric+0x762>
   115d8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   115dc:	75 21                	jne    115ff <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   115de:	83 ec 0c             	sub    $0xc,%esp
   115e1:	ff 75 f0             	pushl  -0x10(%ebp)
   115e4:	e8 f4 84 ff ff       	call   9add <lodepng_chunk_check_crc>
   115e9:	83 c4 10             	add    $0x10,%esp
   115ec:	85 c0                	test   %eax,%eax
   115ee:	74 0f                	je     115ff <decodeGeneric+0x762>
   115f0:	8b 45 14             	mov    0x14(%ebp),%eax
   115f3:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   115fa:	00 00 00 
   115fd:	eb 43                	jmp    11642 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   115ff:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   11603:	75 1a                	jne    1161f <decodeGeneric+0x782>
   11605:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11608:	8b 45 18             	mov    0x18(%ebp),%eax
   1160b:	01 d0                	add    %edx,%eax
   1160d:	83 ec 08             	sub    $0x8,%esp
   11610:	50                   	push   %eax
   11611:	ff 75 f0             	pushl  -0x10(%ebp)
   11614:	e8 3f 86 ff ff       	call   9c58 <lodepng_chunk_next_const>
   11619:	83 c4 10             	add    $0x10,%esp
   1161c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   1161f:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   11623:	75 1d                	jne    11642 <decodeGeneric+0x7a5>
   11625:	8b 45 14             	mov    0x14(%ebp),%eax
   11628:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1162e:	85 c0                	test   %eax,%eax
   11630:	0f 84 68 f9 ff ff    	je     10f9e <decodeGeneric+0x101>
   11636:	eb 0a                	jmp    11642 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   11638:	90                   	nop
   11639:	eb 07                	jmp    11642 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   1163b:	90                   	nop
   1163c:	eb 04                	jmp    11642 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   1163e:	90                   	nop
   1163f:	eb 01                	jmp    11642 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   11641:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   11642:	8b 45 14             	mov    0x14(%ebp),%eax
   11645:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1164b:	85 c0                	test   %eax,%eax
   1164d:	75 28                	jne    11677 <decodeGeneric+0x7da>
   1164f:	8b 45 14             	mov    0x14(%ebp),%eax
   11652:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   11658:	83 f8 03             	cmp    $0x3,%eax
   1165b:	75 1a                	jne    11677 <decodeGeneric+0x7da>
   1165d:	8b 45 14             	mov    0x14(%ebp),%eax
   11660:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11666:	85 c0                	test   %eax,%eax
   11668:	75 0d                	jne    11677 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   1166a:	8b 45 14             	mov    0x14(%ebp),%eax
   1166d:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   11674:	00 00 00 
  }

  if(!state->error) {
   11677:	8b 45 14             	mov    0x14(%ebp),%eax
   1167a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11680:	85 c0                	test   %eax,%eax
   11682:	0f 85 d2 01 00 00    	jne    1185a <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   11688:	8b 45 14             	mov    0x14(%ebp),%eax
   1168b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11691:	85 c0                	test   %eax,%eax
   11693:	75 3a                	jne    116cf <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   11695:	8b 45 14             	mov    0x14(%ebp),%eax
   11698:	05 a4 00 00 00       	add    $0xa4,%eax
   1169d:	83 ec 0c             	sub    $0xc,%esp
   116a0:	50                   	push   %eax
   116a1:	e8 8e 8e ff ff       	call   a534 <lodepng_get_bpp>
   116a6:	83 c4 10             	add    $0x10,%esp
   116a9:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   116ac:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   116af:	8b 45 10             	mov    0x10(%ebp),%eax
   116b2:	8b 10                	mov    (%eax),%edx
   116b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   116b7:	8b 00                	mov    (%eax),%eax
   116b9:	83 ec 04             	sub    $0x4,%esp
   116bc:	51                   	push   %ecx
   116bd:	52                   	push   %edx
   116be:	50                   	push   %eax
   116bf:	e8 cf 8f ff ff       	call   a693 <lodepng_get_raw_size_idat>
   116c4:	83 c4 10             	add    $0x10,%esp
   116c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
   116ca:	e9 60 01 00 00       	jmp    1182f <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   116cf:	8b 45 14             	mov    0x14(%ebp),%eax
   116d2:	05 a4 00 00 00       	add    $0xa4,%eax
   116d7:	83 ec 0c             	sub    $0xc,%esp
   116da:	50                   	push   %eax
   116db:	e8 54 8e ff ff       	call   a534 <lodepng_get_bpp>
   116e0:	83 c4 10             	add    $0x10,%esp
   116e3:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   116e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   116ed:	8b 45 c8             	mov    -0x38(%ebp),%eax
   116f0:	8b 55 10             	mov    0x10(%ebp),%edx
   116f3:	8b 12                	mov    (%edx),%edx
   116f5:	83 c2 07             	add    $0x7,%edx
   116f8:	89 d1                	mov    %edx,%ecx
   116fa:	c1 e9 03             	shr    $0x3,%ecx
   116fd:	8b 55 0c             	mov    0xc(%ebp),%edx
   11700:	8b 12                	mov    (%edx),%edx
   11702:	83 c2 07             	add    $0x7,%edx
   11705:	c1 ea 03             	shr    $0x3,%edx
   11708:	83 ec 04             	sub    $0x4,%esp
   1170b:	50                   	push   %eax
   1170c:	51                   	push   %ecx
   1170d:	52                   	push   %edx
   1170e:	e8 80 8f ff ff       	call   a693 <lodepng_get_raw_size_idat>
   11713:	83 c4 10             	add    $0x10,%esp
   11716:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   11719:	8b 45 0c             	mov    0xc(%ebp),%eax
   1171c:	8b 00                	mov    (%eax),%eax
   1171e:	83 f8 04             	cmp    $0x4,%eax
   11721:	76 2c                	jbe    1174f <decodeGeneric+0x8b2>
   11723:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11726:	8b 55 10             	mov    0x10(%ebp),%edx
   11729:	8b 12                	mov    (%edx),%edx
   1172b:	83 c2 07             	add    $0x7,%edx
   1172e:	89 d1                	mov    %edx,%ecx
   11730:	c1 e9 03             	shr    $0x3,%ecx
   11733:	8b 55 0c             	mov    0xc(%ebp),%edx
   11736:	8b 12                	mov    (%edx),%edx
   11738:	83 c2 03             	add    $0x3,%edx
   1173b:	c1 ea 03             	shr    $0x3,%edx
   1173e:	83 ec 04             	sub    $0x4,%esp
   11741:	50                   	push   %eax
   11742:	51                   	push   %ecx
   11743:	52                   	push   %edx
   11744:	e8 4a 8f ff ff       	call   a693 <lodepng_get_raw_size_idat>
   11749:	83 c4 10             	add    $0x10,%esp
   1174c:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1174f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11752:	8b 55 10             	mov    0x10(%ebp),%edx
   11755:	8b 12                	mov    (%edx),%edx
   11757:	83 c2 03             	add    $0x3,%edx
   1175a:	89 d1                	mov    %edx,%ecx
   1175c:	c1 e9 03             	shr    $0x3,%ecx
   1175f:	8b 55 0c             	mov    0xc(%ebp),%edx
   11762:	8b 12                	mov    (%edx),%edx
   11764:	83 c2 03             	add    $0x3,%edx
   11767:	c1 ea 02             	shr    $0x2,%edx
   1176a:	83 ec 04             	sub    $0x4,%esp
   1176d:	50                   	push   %eax
   1176e:	51                   	push   %ecx
   1176f:	52                   	push   %edx
   11770:	e8 1e 8f ff ff       	call   a693 <lodepng_get_raw_size_idat>
   11775:	83 c4 10             	add    $0x10,%esp
   11778:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   1177b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1177e:	8b 00                	mov    (%eax),%eax
   11780:	83 f8 02             	cmp    $0x2,%eax
   11783:	76 2c                	jbe    117b1 <decodeGeneric+0x914>
   11785:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11788:	8b 55 10             	mov    0x10(%ebp),%edx
   1178b:	8b 12                	mov    (%edx),%edx
   1178d:	83 c2 03             	add    $0x3,%edx
   11790:	89 d1                	mov    %edx,%ecx
   11792:	c1 e9 02             	shr    $0x2,%ecx
   11795:	8b 55 0c             	mov    0xc(%ebp),%edx
   11798:	8b 12                	mov    (%edx),%edx
   1179a:	83 c2 01             	add    $0x1,%edx
   1179d:	c1 ea 02             	shr    $0x2,%edx
   117a0:	83 ec 04             	sub    $0x4,%esp
   117a3:	50                   	push   %eax
   117a4:	51                   	push   %ecx
   117a5:	52                   	push   %edx
   117a6:	e8 e8 8e ff ff       	call   a693 <lodepng_get_raw_size_idat>
   117ab:	83 c4 10             	add    $0x10,%esp
   117ae:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   117b1:	8b 45 c8             	mov    -0x38(%ebp),%eax
   117b4:	8b 55 10             	mov    0x10(%ebp),%edx
   117b7:	8b 12                	mov    (%edx),%edx
   117b9:	83 c2 01             	add    $0x1,%edx
   117bc:	89 d1                	mov    %edx,%ecx
   117be:	c1 e9 02             	shr    $0x2,%ecx
   117c1:	8b 55 0c             	mov    0xc(%ebp),%edx
   117c4:	8b 12                	mov    (%edx),%edx
   117c6:	83 c2 01             	add    $0x1,%edx
   117c9:	d1 ea                	shr    %edx
   117cb:	83 ec 04             	sub    $0x4,%esp
   117ce:	50                   	push   %eax
   117cf:	51                   	push   %ecx
   117d0:	52                   	push   %edx
   117d1:	e8 bd 8e ff ff       	call   a693 <lodepng_get_raw_size_idat>
   117d6:	83 c4 10             	add    $0x10,%esp
   117d9:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   117dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   117df:	8b 00                	mov    (%eax),%eax
   117e1:	83 f8 01             	cmp    $0x1,%eax
   117e4:	76 27                	jbe    1180d <decodeGeneric+0x970>
   117e6:	8b 45 c8             	mov    -0x38(%ebp),%eax
   117e9:	8b 55 10             	mov    0x10(%ebp),%edx
   117ec:	8b 12                	mov    (%edx),%edx
   117ee:	83 c2 01             	add    $0x1,%edx
   117f1:	89 d1                	mov    %edx,%ecx
   117f3:	d1 e9                	shr    %ecx
   117f5:	8b 55 0c             	mov    0xc(%ebp),%edx
   117f8:	8b 12                	mov    (%edx),%edx
   117fa:	d1 ea                	shr    %edx
   117fc:	83 ec 04             	sub    $0x4,%esp
   117ff:	50                   	push   %eax
   11800:	51                   	push   %ecx
   11801:	52                   	push   %edx
   11802:	e8 8c 8e ff ff       	call   a693 <lodepng_get_raw_size_idat>
   11807:	83 c4 10             	add    $0x10,%esp
   1180a:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   1180d:	8b 55 c8             	mov    -0x38(%ebp),%edx
   11810:	8b 45 10             	mov    0x10(%ebp),%eax
   11813:	8b 00                	mov    (%eax),%eax
   11815:	d1 e8                	shr    %eax
   11817:	89 c1                	mov    %eax,%ecx
   11819:	8b 45 0c             	mov    0xc(%ebp),%eax
   1181c:	8b 00                	mov    (%eax),%eax
   1181e:	83 ec 04             	sub    $0x4,%esp
   11821:	52                   	push   %edx
   11822:	51                   	push   %ecx
   11823:	50                   	push   %eax
   11824:	e8 6a 8e ff ff       	call   a693 <lodepng_get_raw_size_idat>
   11829:	83 c4 10             	add    $0x10,%esp
   1182c:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   1182f:	8b 45 14             	mov    0x14(%ebp),%eax
   11832:	83 ec 08             	sub    $0x8,%esp
   11835:	50                   	push   %eax
   11836:	ff 75 ec             	pushl  -0x14(%ebp)
   11839:	ff 75 d8             	pushl  -0x28(%ebp)
   1183c:	ff 75 e8             	pushl  -0x18(%ebp)
   1183f:	8d 45 c0             	lea    -0x40(%ebp),%eax
   11842:	50                   	push   %eax
   11843:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   11846:	50                   	push   %eax
   11847:	e8 87 7c ff ff       	call   94d3 <zlib_decompress>
   1184c:	83 c4 20             	add    $0x20,%esp
   1184f:	89 c2                	mov    %eax,%edx
   11851:	8b 45 14             	mov    0x14(%ebp),%eax
   11854:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   1185a:	8b 45 14             	mov    0x14(%ebp),%eax
   1185d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11863:	85 c0                	test   %eax,%eax
   11865:	75 15                	jne    1187c <decodeGeneric+0x9df>
   11867:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1186a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1186d:	74 0d                	je     1187c <decodeGeneric+0x9df>
   1186f:	8b 45 14             	mov    0x14(%ebp),%eax
   11872:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   11879:	00 00 00 
  lodepng_free(idat);
   1187c:	83 ec 0c             	sub    $0xc,%esp
   1187f:	ff 75 d8             	pushl  -0x28(%ebp)
   11882:	e8 b2 31 ff ff       	call   4a39 <lodepng_free>
   11887:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   1188a:	8b 45 14             	mov    0x14(%ebp),%eax
   1188d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11893:	85 c0                	test   %eax,%eax
   11895:	75 4f                	jne    118e6 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   11897:	8b 45 14             	mov    0x14(%ebp),%eax
   1189a:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   118a0:	8b 45 10             	mov    0x10(%ebp),%eax
   118a3:	8b 10                	mov    (%eax),%edx
   118a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   118a8:	8b 00                	mov    (%eax),%eax
   118aa:	83 ec 04             	sub    $0x4,%esp
   118ad:	51                   	push   %ecx
   118ae:	52                   	push   %edx
   118af:	50                   	push   %eax
   118b0:	e8 be 8d ff ff       	call   a673 <lodepng_get_raw_size>
   118b5:	83 c4 10             	add    $0x10,%esp
   118b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   118bb:	83 ec 0c             	sub    $0xc,%esp
   118be:	ff 75 e4             	pushl  -0x1c(%ebp)
   118c1:	e8 52 31 ff ff       	call   4a18 <lodepng_malloc>
   118c6:	83 c4 10             	add    $0x10,%esp
   118c9:	89 c2                	mov    %eax,%edx
   118cb:	8b 45 08             	mov    0x8(%ebp),%eax
   118ce:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   118d0:	8b 45 08             	mov    0x8(%ebp),%eax
   118d3:	8b 00                	mov    (%eax),%eax
   118d5:	85 c0                	test   %eax,%eax
   118d7:	75 0d                	jne    118e6 <decodeGeneric+0xa49>
   118d9:	8b 45 14             	mov    0x14(%ebp),%eax
   118dc:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   118e3:	00 00 00 
  }
  if(!state->error) {
   118e6:	8b 45 14             	mov    0x14(%ebp),%eax
   118e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   118ef:	85 c0                	test   %eax,%eax
   118f1:	75 4c                	jne    1193f <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   118f3:	8b 45 08             	mov    0x8(%ebp),%eax
   118f6:	8b 00                	mov    (%eax),%eax
   118f8:	83 ec 04             	sub    $0x4,%esp
   118fb:	ff 75 e4             	pushl  -0x1c(%ebp)
   118fe:	6a 00                	push   $0x0
   11900:	50                   	push   %eax
   11901:	e8 83 31 ff ff       	call   4a89 <lodepng_memset>
   11906:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   11909:	8b 45 14             	mov    0x14(%ebp),%eax
   1190c:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   11912:	8b 45 10             	mov    0x10(%ebp),%eax
   11915:	8b 18                	mov    (%eax),%ebx
   11917:	8b 45 0c             	mov    0xc(%ebp),%eax
   1191a:	8b 08                	mov    (%eax),%ecx
   1191c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1191f:	8b 45 08             	mov    0x8(%ebp),%eax
   11922:	8b 00                	mov    (%eax),%eax
   11924:	83 ec 0c             	sub    $0xc,%esp
   11927:	56                   	push   %esi
   11928:	53                   	push   %ebx
   11929:	51                   	push   %ecx
   1192a:	52                   	push   %edx
   1192b:	50                   	push   %eax
   1192c:	e8 05 df ff ff       	call   f836 <postProcessScanlines>
   11931:	83 c4 20             	add    $0x20,%esp
   11934:	89 c2                	mov    %eax,%edx
   11936:	8b 45 14             	mov    0x14(%ebp),%eax
   11939:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   1193f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   11942:	83 ec 0c             	sub    $0xc,%esp
   11945:	50                   	push   %eax
   11946:	e8 ee 30 ff ff       	call   4a39 <lodepng_free>
   1194b:	83 c4 10             	add    $0x10,%esp
   1194e:	eb 01                	jmp    11951 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   11950:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   11951:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11954:	5b                   	pop    %ebx
   11955:	5e                   	pop    %esi
   11956:	5d                   	pop    %ebp
   11957:	c3                   	ret    

00011958 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   11958:	55                   	push   %ebp
   11959:	89 e5                	mov    %esp,%ebp
   1195b:	56                   	push   %esi
   1195c:	53                   	push   %ebx
   1195d:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   11960:	8b 45 08             	mov    0x8(%ebp),%eax
   11963:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   11969:	83 ec 08             	sub    $0x8,%esp
   1196c:	ff 75 1c             	pushl  0x1c(%ebp)
   1196f:	ff 75 18             	pushl  0x18(%ebp)
   11972:	ff 75 14             	pushl  0x14(%ebp)
   11975:	ff 75 10             	pushl  0x10(%ebp)
   11978:	ff 75 0c             	pushl  0xc(%ebp)
   1197b:	ff 75 08             	pushl  0x8(%ebp)
   1197e:	e8 1a f5 ff ff       	call   10e9d <decodeGeneric>
   11983:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   11986:	8b 45 14             	mov    0x14(%ebp),%eax
   11989:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1198f:	85 c0                	test   %eax,%eax
   11991:	74 0e                	je     119a1 <lodepng_decode+0x49>
   11993:	8b 45 14             	mov    0x14(%ebp),%eax
   11996:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1199c:	e9 55 01 00 00       	jmp    11af6 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   119a1:	8b 45 14             	mov    0x14(%ebp),%eax
   119a4:	8b 40 24             	mov    0x24(%eax),%eax
   119a7:	85 c0                	test   %eax,%eax
   119a9:	74 20                	je     119cb <lodepng_decode+0x73>
   119ab:	8b 45 14             	mov    0x14(%ebp),%eax
   119ae:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   119b4:	8b 45 14             	mov    0x14(%ebp),%eax
   119b7:	83 c0 78             	add    $0x78,%eax
   119ba:	83 ec 08             	sub    $0x8,%esp
   119bd:	52                   	push   %edx
   119be:	50                   	push   %eax
   119bf:	e8 56 89 ff ff       	call   a31a <lodepng_color_mode_equal>
   119c4:	83 c4 10             	add    $0x10,%esp
   119c7:	85 c0                	test   %eax,%eax
   119c9:	74 54                	je     11a1f <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   119cb:	8b 45 14             	mov    0x14(%ebp),%eax
   119ce:	8b 40 24             	mov    0x24(%eax),%eax
   119d1:	85 c0                	test   %eax,%eax
   119d3:	0f 85 13 01 00 00    	jne    11aec <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   119d9:	8b 45 14             	mov    0x14(%ebp),%eax
   119dc:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   119e2:	8b 45 14             	mov    0x14(%ebp),%eax
   119e5:	83 c0 78             	add    $0x78,%eax
   119e8:	83 ec 08             	sub    $0x8,%esp
   119eb:	52                   	push   %edx
   119ec:	50                   	push   %eax
   119ed:	e8 3f 88 ff ff       	call   a231 <lodepng_color_mode_copy>
   119f2:	83 c4 10             	add    $0x10,%esp
   119f5:	89 c2                	mov    %eax,%edx
   119f7:	8b 45 14             	mov    0x14(%ebp),%eax
   119fa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   11a00:	8b 45 14             	mov    0x14(%ebp),%eax
   11a03:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11a09:	85 c0                	test   %eax,%eax
   11a0b:	0f 84 db 00 00 00    	je     11aec <lodepng_decode+0x194>
   11a11:	8b 45 14             	mov    0x14(%ebp),%eax
   11a14:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11a1a:	e9 d7 00 00 00       	jmp    11af6 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   11a1f:	8b 45 08             	mov    0x8(%ebp),%eax
   11a22:	8b 00                	mov    (%eax),%eax
   11a24:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   11a27:	8b 45 14             	mov    0x14(%ebp),%eax
   11a2a:	8b 40 78             	mov    0x78(%eax),%eax
   11a2d:	83 f8 02             	cmp    $0x2,%eax
   11a30:	74 20                	je     11a52 <lodepng_decode+0xfa>
   11a32:	8b 45 14             	mov    0x14(%ebp),%eax
   11a35:	8b 40 78             	mov    0x78(%eax),%eax
   11a38:	83 f8 06             	cmp    $0x6,%eax
   11a3b:	74 15                	je     11a52 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   11a3d:	8b 45 14             	mov    0x14(%ebp),%eax
   11a40:	8b 40 7c             	mov    0x7c(%eax),%eax
   11a43:	83 f8 08             	cmp    $0x8,%eax
   11a46:	74 0a                	je     11a52 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   11a48:	b8 38 00 00 00       	mov    $0x38,%eax
   11a4d:	e9 a4 00 00 00       	jmp    11af6 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   11a52:	8b 45 14             	mov    0x14(%ebp),%eax
   11a55:	8d 48 78             	lea    0x78(%eax),%ecx
   11a58:	8b 45 10             	mov    0x10(%ebp),%eax
   11a5b:	8b 10                	mov    (%eax),%edx
   11a5d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a60:	8b 00                	mov    (%eax),%eax
   11a62:	83 ec 04             	sub    $0x4,%esp
   11a65:	51                   	push   %ecx
   11a66:	52                   	push   %edx
   11a67:	50                   	push   %eax
   11a68:	e8 06 8c ff ff       	call   a673 <lodepng_get_raw_size>
   11a6d:	83 c4 10             	add    $0x10,%esp
   11a70:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   11a73:	83 ec 0c             	sub    $0xc,%esp
   11a76:	ff 75 f0             	pushl  -0x10(%ebp)
   11a79:	e8 9a 2f ff ff       	call   4a18 <lodepng_malloc>
   11a7e:	83 c4 10             	add    $0x10,%esp
   11a81:	89 c2                	mov    %eax,%edx
   11a83:	8b 45 08             	mov    0x8(%ebp),%eax
   11a86:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   11a88:	8b 45 08             	mov    0x8(%ebp),%eax
   11a8b:	8b 00                	mov    (%eax),%eax
   11a8d:	85 c0                	test   %eax,%eax
   11a8f:	75 0f                	jne    11aa0 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   11a91:	8b 45 14             	mov    0x14(%ebp),%eax
   11a94:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   11a9b:	00 00 00 
   11a9e:	eb 3c                	jmp    11adc <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   11aa0:	8b 45 10             	mov    0x10(%ebp),%eax
   11aa3:	8b 08                	mov    (%eax),%ecx
   11aa5:	8b 45 0c             	mov    0xc(%ebp),%eax
   11aa8:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   11aaa:	8b 45 14             	mov    0x14(%ebp),%eax
   11aad:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   11ab3:	8b 45 14             	mov    0x14(%ebp),%eax
   11ab6:	8d 58 78             	lea    0x78(%eax),%ebx
   11ab9:	8b 45 08             	mov    0x8(%ebp),%eax
   11abc:	8b 00                	mov    (%eax),%eax
   11abe:	83 ec 08             	sub    $0x8,%esp
   11ac1:	51                   	push   %ecx
   11ac2:	52                   	push   %edx
   11ac3:	56                   	push   %esi
   11ac4:	53                   	push   %ebx
   11ac5:	ff 75 f4             	pushl  -0xc(%ebp)
   11ac8:	50                   	push   %eax
   11ac9:	e8 51 b6 ff ff       	call   d11f <lodepng_convert>
   11ace:	83 c4 20             	add    $0x20,%esp
   11ad1:	89 c2                	mov    %eax,%edx
   11ad3:	8b 45 14             	mov    0x14(%ebp),%eax
   11ad6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   11adc:	83 ec 0c             	sub    $0xc,%esp
   11adf:	ff 75 f4             	pushl  -0xc(%ebp)
   11ae2:	e8 52 2f ff ff       	call   4a39 <lodepng_free>
   11ae7:	83 c4 10             	add    $0x10,%esp
   11aea:	eb 01                	jmp    11aed <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   11aec:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   11aed:	8b 45 14             	mov    0x14(%ebp),%eax
   11af0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   11af6:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11af9:	5b                   	pop    %ebx
   11afa:	5e                   	pop    %esi
   11afb:	5d                   	pop    %ebp
   11afc:	c3                   	ret    

00011afd <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   11afd:	55                   	push   %ebp
   11afe:	89 e5                	mov    %esp,%ebp
   11b00:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   11b06:	83 ec 0c             	sub    $0xc,%esp
   11b09:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   11b0f:	50                   	push   %eax
   11b10:	e8 d9 01 00 00       	call   11cee <lodepng_state_init>
   11b15:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   11b18:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11b1b:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   11b21:	8b 45 20             	mov    0x20(%ebp),%eax
   11b24:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   11b2a:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   11b31:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   11b34:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   11b3b:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   11b3e:	83 ec 08             	sub    $0x8,%esp
   11b41:	ff 75 18             	pushl  0x18(%ebp)
   11b44:	ff 75 14             	pushl  0x14(%ebp)
   11b47:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   11b4d:	50                   	push   %eax
   11b4e:	ff 75 10             	pushl  0x10(%ebp)
   11b51:	ff 75 0c             	pushl  0xc(%ebp)
   11b54:	ff 75 08             	pushl  0x8(%ebp)
   11b57:	e8 fc fd ff ff       	call   11958 <lodepng_decode>
   11b5c:	83 c4 20             	add    $0x20,%esp
   11b5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   11b62:	83 ec 0c             	sub    $0xc,%esp
   11b65:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   11b6b:	50                   	push   %eax
   11b6c:	e8 d7 01 00 00       	call   11d48 <lodepng_state_cleanup>
   11b71:	83 c4 10             	add    $0x10,%esp
  return error;
   11b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11b77:	c9                   	leave  
   11b78:	c3                   	ret    

00011b79 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   11b79:	55                   	push   %ebp
   11b7a:	89 e5                	mov    %esp,%ebp
   11b7c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   11b7f:	83 ec 04             	sub    $0x4,%esp
   11b82:	6a 08                	push   $0x8
   11b84:	6a 06                	push   $0x6
   11b86:	ff 75 18             	pushl  0x18(%ebp)
   11b89:	ff 75 14             	pushl  0x14(%ebp)
   11b8c:	ff 75 10             	pushl  0x10(%ebp)
   11b8f:	ff 75 0c             	pushl  0xc(%ebp)
   11b92:	ff 75 08             	pushl  0x8(%ebp)
   11b95:	e8 63 ff ff ff       	call   11afd <lodepng_decode_memory>
   11b9a:	83 c4 20             	add    $0x20,%esp
}
   11b9d:	c9                   	leave  
   11b9e:	c3                   	ret    

00011b9f <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   11b9f:	55                   	push   %ebp
   11ba0:	89 e5                	mov    %esp,%ebp
   11ba2:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   11ba5:	83 ec 04             	sub    $0x4,%esp
   11ba8:	6a 08                	push   $0x8
   11baa:	6a 02                	push   $0x2
   11bac:	ff 75 18             	pushl  0x18(%ebp)
   11baf:	ff 75 14             	pushl  0x14(%ebp)
   11bb2:	ff 75 10             	pushl  0x10(%ebp)
   11bb5:	ff 75 0c             	pushl  0xc(%ebp)
   11bb8:	ff 75 08             	pushl  0x8(%ebp)
   11bbb:	e8 3d ff ff ff       	call   11afd <lodepng_decode_memory>
   11bc0:	83 c4 20             	add    $0x20,%esp
}
   11bc3:	c9                   	leave  
   11bc4:	c3                   	ret    

00011bc5 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   11bc5:	55                   	push   %ebp
   11bc6:	89 e5                	mov    %esp,%ebp
   11bc8:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   11bcb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   11bd2:	8b 45 08             	mov    0x8(%ebp),%eax
   11bd5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   11bdb:	8b 45 10             	mov    0x10(%ebp),%eax
   11bde:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   11be4:	8b 45 10             	mov    0x10(%ebp),%eax
   11be7:	8b 10                	mov    (%eax),%edx
   11be9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bec:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   11bee:	83 ec 04             	sub    $0x4,%esp
   11bf1:	ff 75 14             	pushl  0x14(%ebp)
   11bf4:	8d 45 ec             	lea    -0x14(%ebp),%eax
   11bf7:	50                   	push   %eax
   11bf8:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11bfb:	50                   	push   %eax
   11bfc:	e8 70 32 ff ff       	call   4e71 <lodepng_load_file>
   11c01:	83 c4 10             	add    $0x10,%esp
   11c04:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   11c07:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11c0b:	75 25                	jne    11c32 <lodepng_decode_file+0x6d>
   11c0d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11c10:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c13:	83 ec 04             	sub    $0x4,%esp
   11c16:	ff 75 1c             	pushl  0x1c(%ebp)
   11c19:	ff 75 18             	pushl  0x18(%ebp)
   11c1c:	52                   	push   %edx
   11c1d:	50                   	push   %eax
   11c1e:	ff 75 10             	pushl  0x10(%ebp)
   11c21:	ff 75 0c             	pushl  0xc(%ebp)
   11c24:	ff 75 08             	pushl  0x8(%ebp)
   11c27:	e8 d1 fe ff ff       	call   11afd <lodepng_decode_memory>
   11c2c:	83 c4 20             	add    $0x20,%esp
   11c2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   11c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c35:	83 ec 0c             	sub    $0xc,%esp
   11c38:	50                   	push   %eax
   11c39:	e8 fb 2d ff ff       	call   4a39 <lodepng_free>
   11c3e:	83 c4 10             	add    $0x10,%esp
  return error;
   11c41:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11c44:	c9                   	leave  
   11c45:	c3                   	ret    

00011c46 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   11c46:	55                   	push   %ebp
   11c47:	89 e5                	mov    %esp,%ebp
   11c49:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   11c4c:	83 ec 08             	sub    $0x8,%esp
   11c4f:	6a 08                	push   $0x8
   11c51:	6a 06                	push   $0x6
   11c53:	ff 75 14             	pushl  0x14(%ebp)
   11c56:	ff 75 10             	pushl  0x10(%ebp)
   11c59:	ff 75 0c             	pushl  0xc(%ebp)
   11c5c:	ff 75 08             	pushl  0x8(%ebp)
   11c5f:	e8 61 ff ff ff       	call   11bc5 <lodepng_decode_file>
   11c64:	83 c4 20             	add    $0x20,%esp
}
   11c67:	c9                   	leave  
   11c68:	c3                   	ret    

00011c69 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   11c69:	55                   	push   %ebp
   11c6a:	89 e5                	mov    %esp,%ebp
   11c6c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   11c6f:	83 ec 08             	sub    $0x8,%esp
   11c72:	6a 08                	push   $0x8
   11c74:	6a 02                	push   $0x2
   11c76:	ff 75 14             	pushl  0x14(%ebp)
   11c79:	ff 75 10             	pushl  0x10(%ebp)
   11c7c:	ff 75 0c             	pushl  0xc(%ebp)
   11c7f:	ff 75 08             	pushl  0x8(%ebp)
   11c82:	e8 3e ff ff ff       	call   11bc5 <lodepng_decode_file>
   11c87:	83 c4 20             	add    $0x20,%esp
}
   11c8a:	c9                   	leave  
   11c8b:	c3                   	ret    

00011c8c <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   11c8c:	55                   	push   %ebp
   11c8d:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   11c8f:	8b 45 08             	mov    0x8(%ebp),%eax
   11c92:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   11c99:	8b 45 08             	mov    0x8(%ebp),%eax
   11c9c:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   11ca3:	8b 45 08             	mov    0x8(%ebp),%eax
   11ca6:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   11cad:	8b 45 08             	mov    0x8(%ebp),%eax
   11cb0:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   11cb7:	8b 45 08             	mov    0x8(%ebp),%eax
   11cba:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   11cc1:	8b 45 08             	mov    0x8(%ebp),%eax
   11cc4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   11ccb:	8b 45 08             	mov    0x8(%ebp),%eax
   11cce:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   11cd5:	8b 45 08             	mov    0x8(%ebp),%eax
   11cd8:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   11cdf:	8b 45 08             	mov    0x8(%ebp),%eax
   11ce2:	50                   	push   %eax
   11ce3:	e8 ff 7a ff ff       	call   97e7 <lodepng_decompress_settings_init>
   11ce8:	83 c4 04             	add    $0x4,%esp
}
   11ceb:	90                   	nop
   11cec:	c9                   	leave  
   11ced:	c3                   	ret    

00011cee <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   11cee:	55                   	push   %ebp
   11cef:	89 e5                	mov    %esp,%ebp
   11cf1:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   11cf4:	8b 45 08             	mov    0x8(%ebp),%eax
   11cf7:	50                   	push   %eax
   11cf8:	e8 8f ff ff ff       	call   11c8c <lodepng_decoder_settings_init>
   11cfd:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   11d00:	8b 45 08             	mov    0x8(%ebp),%eax
   11d03:	83 c0 38             	add    $0x38,%eax
   11d06:	83 ec 0c             	sub    $0xc,%esp
   11d09:	50                   	push   %eax
   11d0a:	e8 fc 30 00 00       	call   14e0b <lodepng_encoder_settings_init>
   11d0f:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   11d12:	8b 45 08             	mov    0x8(%ebp),%eax
   11d15:	83 c0 78             	add    $0x78,%eax
   11d18:	83 ec 0c             	sub    $0xc,%esp
   11d1b:	50                   	push   %eax
   11d1c:	e8 06 84 ff ff       	call   a127 <lodepng_color_mode_init>
   11d21:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   11d24:	8b 45 08             	mov    0x8(%ebp),%eax
   11d27:	05 98 00 00 00       	add    $0x98,%eax
   11d2c:	83 ec 0c             	sub    $0xc,%esp
   11d2f:	50                   	push   %eax
   11d30:	e8 89 93 ff ff       	call   b0be <lodepng_info_init>
   11d35:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   11d38:	8b 45 08             	mov    0x8(%ebp),%eax
   11d3b:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   11d42:	00 00 00 
}
   11d45:	90                   	nop
   11d46:	c9                   	leave  
   11d47:	c3                   	ret    

00011d48 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   11d48:	55                   	push   %ebp
   11d49:	89 e5                	mov    %esp,%ebp
   11d4b:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   11d4e:	8b 45 08             	mov    0x8(%ebp),%eax
   11d51:	83 c0 78             	add    $0x78,%eax
   11d54:	83 ec 0c             	sub    $0xc,%esp
   11d57:	50                   	push   %eax
   11d58:	e8 bd 84 ff ff       	call   a21a <lodepng_color_mode_cleanup>
   11d5d:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   11d60:	8b 45 08             	mov    0x8(%ebp),%eax
   11d63:	05 98 00 00 00       	add    $0x98,%eax
   11d68:	83 ec 0c             	sub    $0xc,%esp
   11d6b:	50                   	push   %eax
   11d6c:	e8 2e 94 ff ff       	call   b19f <lodepng_info_cleanup>
   11d71:	83 c4 10             	add    $0x10,%esp
}
   11d74:	90                   	nop
   11d75:	c9                   	leave  
   11d76:	c3                   	ret    

00011d77 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   11d77:	55                   	push   %ebp
   11d78:	89 e5                	mov    %esp,%ebp
   11d7a:	57                   	push   %edi
   11d7b:	56                   	push   %esi
   11d7c:	53                   	push   %ebx
   11d7d:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   11d80:	83 ec 0c             	sub    $0xc,%esp
   11d83:	ff 75 08             	pushl  0x8(%ebp)
   11d86:	e8 bd ff ff ff       	call   11d48 <lodepng_state_cleanup>
   11d8b:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   11d8e:	8b 55 08             	mov    0x8(%ebp),%edx
   11d91:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d94:	89 c3                	mov    %eax,%ebx
   11d96:	b8 60 00 00 00       	mov    $0x60,%eax
   11d9b:	89 d7                	mov    %edx,%edi
   11d9d:	89 de                	mov    %ebx,%esi
   11d9f:	89 c1                	mov    %eax,%ecx
   11da1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   11da3:	8b 45 08             	mov    0x8(%ebp),%eax
   11da6:	83 c0 78             	add    $0x78,%eax
   11da9:	83 ec 0c             	sub    $0xc,%esp
   11dac:	50                   	push   %eax
   11dad:	e8 75 83 ff ff       	call   a127 <lodepng_color_mode_init>
   11db2:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   11db5:	8b 45 08             	mov    0x8(%ebp),%eax
   11db8:	05 98 00 00 00       	add    $0x98,%eax
   11dbd:	83 ec 0c             	sub    $0xc,%esp
   11dc0:	50                   	push   %eax
   11dc1:	e8 f8 92 ff ff       	call   b0be <lodepng_info_init>
   11dc6:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   11dc9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11dcc:	8d 50 78             	lea    0x78(%eax),%edx
   11dcf:	8b 45 08             	mov    0x8(%ebp),%eax
   11dd2:	83 c0 78             	add    $0x78,%eax
   11dd5:	83 ec 08             	sub    $0x8,%esp
   11dd8:	52                   	push   %edx
   11dd9:	50                   	push   %eax
   11dda:	e8 52 84 ff ff       	call   a231 <lodepng_color_mode_copy>
   11ddf:	83 c4 10             	add    $0x10,%esp
   11de2:	89 c2                	mov    %eax,%edx
   11de4:	8b 45 08             	mov    0x8(%ebp),%eax
   11de7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   11ded:	8b 45 08             	mov    0x8(%ebp),%eax
   11df0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11df6:	85 c0                	test   %eax,%eax
   11df8:	75 36                	jne    11e30 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   11dfa:	8b 45 0c             	mov    0xc(%ebp),%eax
   11dfd:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   11e03:	8b 45 08             	mov    0x8(%ebp),%eax
   11e06:	05 98 00 00 00       	add    $0x98,%eax
   11e0b:	83 ec 08             	sub    $0x8,%esp
   11e0e:	52                   	push   %edx
   11e0f:	50                   	push   %eax
   11e10:	e8 dd 93 ff ff       	call   b1f2 <lodepng_info_copy>
   11e15:	83 c4 10             	add    $0x10,%esp
   11e18:	89 c2                	mov    %eax,%edx
   11e1a:	8b 45 08             	mov    0x8(%ebp),%eax
   11e1d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   11e23:	8b 45 08             	mov    0x8(%ebp),%eax
   11e26:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11e2c:	85 c0                	test   %eax,%eax
   11e2e:	eb 01                	jmp    11e31 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   11e30:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   11e31:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11e34:	5b                   	pop    %ebx
   11e35:	5e                   	pop    %esi
   11e36:	5f                   	pop    %edi
   11e37:	5d                   	pop    %ebp
   11e38:	c3                   	ret    

00011e39 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   11e39:	55                   	push   %ebp
   11e3a:	89 e5                	mov    %esp,%ebp
   11e3c:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   11e3f:	8b 45 08             	mov    0x8(%ebp),%eax
   11e42:	8b 40 04             	mov    0x4(%eax),%eax
   11e45:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   11e48:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   11e4c:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   11e50:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   11e54:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   11e58:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   11e5c:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   11e60:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   11e64:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   11e68:	8b 45 08             	mov    0x8(%ebp),%eax
   11e6b:	8b 40 04             	mov    0x4(%eax),%eax
   11e6e:	83 c0 08             	add    $0x8,%eax
   11e71:	50                   	push   %eax
   11e72:	ff 75 08             	pushl  0x8(%ebp)
   11e75:	e8 f8 2d ff ff       	call   4c72 <ucvector_resize>
   11e7a:	83 c4 08             	add    $0x8,%esp
   11e7d:	85 c0                	test   %eax,%eax
   11e7f:	75 07                	jne    11e88 <writeSignature+0x4f>
   11e81:	b8 53 00 00 00       	mov    $0x53,%eax
   11e86:	eb 1e                	jmp    11ea6 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   11e88:	8b 45 08             	mov    0x8(%ebp),%eax
   11e8b:	8b 10                	mov    (%eax),%edx
   11e8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11e90:	01 c2                	add    %eax,%edx
   11e92:	6a 08                	push   $0x8
   11e94:	8d 45 f4             	lea    -0xc(%ebp),%eax
   11e97:	50                   	push   %eax
   11e98:	52                   	push   %edx
   11e99:	e8 b8 2b ff ff       	call   4a56 <lodepng_memcpy>
   11e9e:	83 c4 0c             	add    $0xc,%esp
  return 0;
   11ea1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11ea6:	c9                   	leave  
   11ea7:	c3                   	ret    

00011ea8 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   11ea8:	55                   	push   %ebp
   11ea9:	89 e5                	mov    %esp,%ebp
   11eab:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   11eae:	68 2c b7 01 00       	push   $0x1b72c
   11eb3:	6a 0d                	push   $0xd
   11eb5:	ff 75 08             	pushl  0x8(%ebp)
   11eb8:	8d 45 f4             	lea    -0xc(%ebp),%eax
   11ebb:	50                   	push   %eax
   11ebc:	e8 cf 7f ff ff       	call   9e90 <lodepng_chunk_init>
   11ec1:	83 c4 10             	add    $0x10,%esp
   11ec4:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11ec7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11ecb:	74 05                	je     11ed2 <addChunk_IHDR+0x2a>
   11ecd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ed0:	eb 6d                	jmp    11f3f <addChunk_IHDR+0x97>
  data = chunk + 8;
   11ed2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ed5:	83 c0 08             	add    $0x8,%eax
   11ed8:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   11edb:	ff 75 0c             	pushl  0xc(%ebp)
   11ede:	ff 75 f8             	pushl  -0x8(%ebp)
   11ee1:	e8 f3 2e ff ff       	call   4dd9 <lodepng_set32bitInt>
   11ee6:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   11ee9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11eec:	83 c0 04             	add    $0x4,%eax
   11eef:	ff 75 10             	pushl  0x10(%ebp)
   11ef2:	50                   	push   %eax
   11ef3:	e8 e1 2e ff ff       	call   4dd9 <lodepng_set32bitInt>
   11ef8:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   11efb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11efe:	83 c0 08             	add    $0x8,%eax
   11f01:	8b 55 18             	mov    0x18(%ebp),%edx
   11f04:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   11f06:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f09:	83 c0 09             	add    $0x9,%eax
   11f0c:	8b 55 14             	mov    0x14(%ebp),%edx
   11f0f:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   11f11:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f14:	83 c0 0a             	add    $0xa,%eax
   11f17:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   11f1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f1d:	83 c0 0b             	add    $0xb,%eax
   11f20:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   11f23:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f26:	83 c0 0c             	add    $0xc,%eax
   11f29:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11f2c:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   11f2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f31:	50                   	push   %eax
   11f32:	e8 02 7c ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   11f37:	83 c4 04             	add    $0x4,%esp
  return 0;
   11f3a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11f3f:	c9                   	leave  
   11f40:	c3                   	ret    

00011f41 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   11f41:	55                   	push   %ebp
   11f42:	89 e5                	mov    %esp,%ebp
   11f44:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   11f47:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   11f4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f51:	8b 50 0c             	mov    0xc(%eax),%edx
   11f54:	89 d0                	mov    %edx,%eax
   11f56:	01 c0                	add    %eax,%eax
   11f58:	01 d0                	add    %edx,%eax
   11f5a:	68 48 b7 01 00       	push   $0x1b748
   11f5f:	50                   	push   %eax
   11f60:	ff 75 08             	pushl  0x8(%ebp)
   11f63:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11f66:	50                   	push   %eax
   11f67:	e8 24 7f ff ff       	call   9e90 <lodepng_chunk_init>
   11f6c:	83 c4 10             	add    $0x10,%esp
   11f6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11f72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11f76:	74 08                	je     11f80 <addChunk_PLTE+0x3f>
   11f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f7b:	e9 95 00 00 00       	jmp    12015 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   11f80:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   11f87:	eb 70                	jmp    11ff9 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   11f89:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11f8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f8f:	8d 50 01             	lea    0x1(%eax),%edx
   11f92:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11f95:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   11f98:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f9b:	8b 40 08             	mov    0x8(%eax),%eax
   11f9e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11fa1:	c1 e1 02             	shl    $0x2,%ecx
   11fa4:	01 c8                	add    %ecx,%eax
   11fa6:	0f b6 00             	movzbl (%eax),%eax
   11fa9:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   11fab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11fae:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11fb1:	8d 50 01             	lea    0x1(%eax),%edx
   11fb4:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11fb7:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   11fba:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fbd:	8b 40 08             	mov    0x8(%eax),%eax
   11fc0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11fc3:	c1 e1 02             	shl    $0x2,%ecx
   11fc6:	83 c1 01             	add    $0x1,%ecx
   11fc9:	01 c8                	add    %ecx,%eax
   11fcb:	0f b6 00             	movzbl (%eax),%eax
   11fce:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   11fd0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11fd3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11fd6:	8d 50 01             	lea    0x1(%eax),%edx
   11fd9:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11fdc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   11fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fe2:	8b 40 08             	mov    0x8(%eax),%eax
   11fe5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11fe8:	c1 e1 02             	shl    $0x2,%ecx
   11feb:	83 c1 02             	add    $0x2,%ecx
   11fee:	01 c8                	add    %ecx,%eax
   11ff0:	0f b6 00             	movzbl (%eax),%eax
   11ff3:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   11ff5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   11ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ffc:	8b 40 0c             	mov    0xc(%eax),%eax
   11fff:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   12002:	75 85                	jne    11f89 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   12004:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12007:	50                   	push   %eax
   12008:	e8 2c 7b ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   1200d:	83 c4 04             	add    $0x4,%esp
  return 0;
   12010:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12015:	c9                   	leave  
   12016:	c3                   	ret    

00012017 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   12017:	55                   	push   %ebp
   12018:	89 e5                	mov    %esp,%ebp
   1201a:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   1201d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   12024:	8b 45 0c             	mov    0xc(%ebp),%eax
   12027:	8b 00                	mov    (%eax),%eax
   12029:	83 f8 03             	cmp    $0x3,%eax
   1202c:	0f 85 ae 00 00 00    	jne    120e0 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   12032:	8b 45 0c             	mov    0xc(%ebp),%eax
   12035:	8b 40 0c             	mov    0xc(%eax),%eax
   12038:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   1203b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1203e:	8b 40 0c             	mov    0xc(%eax),%eax
   12041:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12044:	eb 23                	jmp    12069 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   12046:	8b 45 0c             	mov    0xc(%ebp),%eax
   12049:	8b 40 08             	mov    0x8(%eax),%eax
   1204c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1204f:	83 ea 01             	sub    $0x1,%edx
   12052:	c1 e2 02             	shl    $0x2,%edx
   12055:	83 c2 03             	add    $0x3,%edx
   12058:	01 d0                	add    %edx,%eax
   1205a:	0f b6 00             	movzbl (%eax),%eax
   1205d:	3c ff                	cmp    $0xff,%al
   1205f:	75 10                	jne    12071 <addChunk_tRNS+0x5a>
      --amount;
   12061:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   12065:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   12069:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1206d:	75 d7                	jne    12046 <addChunk_tRNS+0x2f>
   1206f:	eb 01                	jmp    12072 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   12071:	90                   	nop
      --amount;
    }
    if(amount) {
   12072:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12076:	0f 84 63 01 00 00    	je     121df <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   1207c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1207f:	68 4d b7 01 00       	push   $0x1b74d
   12084:	50                   	push   %eax
   12085:	ff 75 08             	pushl  0x8(%ebp)
   12088:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1208b:	50                   	push   %eax
   1208c:	e8 ff 7d ff ff       	call   9e90 <lodepng_chunk_init>
   12091:	83 c4 10             	add    $0x10,%esp
   12094:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12097:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1209b:	74 08                	je     120a5 <addChunk_tRNS+0x8e>
   1209d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120a0:	e9 52 01 00 00       	jmp    121f7 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   120a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   120ac:	eb 25                	jmp    120d3 <addChunk_tRNS+0xbc>
   120ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
   120b1:	8b 55 fc             	mov    -0x4(%ebp),%edx
   120b4:	83 c2 08             	add    $0x8,%edx
   120b7:	01 c2                	add    %eax,%edx
   120b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   120bc:	8b 40 08             	mov    0x8(%eax),%eax
   120bf:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   120c2:	c1 e1 02             	shl    $0x2,%ecx
   120c5:	83 c1 03             	add    $0x3,%ecx
   120c8:	01 c8                	add    %ecx,%eax
   120ca:	0f b6 00             	movzbl (%eax),%eax
   120cd:	88 02                	mov    %al,(%edx)
   120cf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   120d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   120d6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   120d9:	75 d3                	jne    120ae <addChunk_tRNS+0x97>
   120db:	e9 ff 00 00 00       	jmp    121df <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   120e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   120e3:	8b 00                	mov    (%eax),%eax
   120e5:	85 c0                	test   %eax,%eax
   120e7:	75 59                	jne    12142 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   120e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   120ec:	8b 40 10             	mov    0x10(%eax),%eax
   120ef:	85 c0                	test   %eax,%eax
   120f1:	0f 84 e8 00 00 00    	je     121df <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   120f7:	68 4d b7 01 00       	push   $0x1b74d
   120fc:	6a 02                	push   $0x2
   120fe:	ff 75 08             	pushl  0x8(%ebp)
   12101:	8d 45 e8             	lea    -0x18(%ebp),%eax
   12104:	50                   	push   %eax
   12105:	e8 86 7d ff ff       	call   9e90 <lodepng_chunk_init>
   1210a:	83 c4 10             	add    $0x10,%esp
   1210d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   12110:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12114:	74 08                	je     1211e <addChunk_tRNS+0x107>
   12116:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12119:	e9 d9 00 00 00       	jmp    121f7 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   1211e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12121:	8d 50 08             	lea    0x8(%eax),%edx
   12124:	8b 45 0c             	mov    0xc(%ebp),%eax
   12127:	8b 40 14             	mov    0x14(%eax),%eax
   1212a:	c1 e8 08             	shr    $0x8,%eax
   1212d:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   1212f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12132:	8d 50 09             	lea    0x9(%eax),%edx
   12135:	8b 45 0c             	mov    0xc(%ebp),%eax
   12138:	8b 40 14             	mov    0x14(%eax),%eax
   1213b:	88 02                	mov    %al,(%edx)
   1213d:	e9 9d 00 00 00       	jmp    121df <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   12142:	8b 45 0c             	mov    0xc(%ebp),%eax
   12145:	8b 00                	mov    (%eax),%eax
   12147:	83 f8 02             	cmp    $0x2,%eax
   1214a:	0f 85 8f 00 00 00    	jne    121df <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   12150:	8b 45 0c             	mov    0xc(%ebp),%eax
   12153:	8b 40 10             	mov    0x10(%eax),%eax
   12156:	85 c0                	test   %eax,%eax
   12158:	0f 84 81 00 00 00    	je     121df <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   1215e:	68 4d b7 01 00       	push   $0x1b74d
   12163:	6a 06                	push   $0x6
   12165:	ff 75 08             	pushl  0x8(%ebp)
   12168:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1216b:	50                   	push   %eax
   1216c:	e8 1f 7d ff ff       	call   9e90 <lodepng_chunk_init>
   12171:	83 c4 10             	add    $0x10,%esp
   12174:	89 45 ec             	mov    %eax,-0x14(%ebp)
   12177:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1217b:	74 05                	je     12182 <addChunk_tRNS+0x16b>
   1217d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12180:	eb 75                	jmp    121f7 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   12182:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12185:	8d 50 08             	lea    0x8(%eax),%edx
   12188:	8b 45 0c             	mov    0xc(%ebp),%eax
   1218b:	8b 40 14             	mov    0x14(%eax),%eax
   1218e:	c1 e8 08             	shr    $0x8,%eax
   12191:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   12193:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12196:	8d 50 09             	lea    0x9(%eax),%edx
   12199:	8b 45 0c             	mov    0xc(%ebp),%eax
   1219c:	8b 40 14             	mov    0x14(%eax),%eax
   1219f:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   121a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121a4:	8d 50 0a             	lea    0xa(%eax),%edx
   121a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   121aa:	8b 40 18             	mov    0x18(%eax),%eax
   121ad:	c1 e8 08             	shr    $0x8,%eax
   121b0:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   121b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121b5:	8d 50 0b             	lea    0xb(%eax),%edx
   121b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   121bb:	8b 40 18             	mov    0x18(%eax),%eax
   121be:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   121c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121c3:	8d 50 0c             	lea    0xc(%eax),%edx
   121c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   121c9:	8b 40 1c             	mov    0x1c(%eax),%eax
   121cc:	c1 e8 08             	shr    $0x8,%eax
   121cf:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   121d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121d4:	8d 50 0d             	lea    0xd(%eax),%edx
   121d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   121da:	8b 40 1c             	mov    0x1c(%eax),%eax
   121dd:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   121df:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121e2:	85 c0                	test   %eax,%eax
   121e4:	74 0c                	je     121f2 <addChunk_tRNS+0x1db>
   121e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121e9:	50                   	push   %eax
   121ea:	e8 4a 79 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   121ef:	83 c4 04             	add    $0x4,%esp
  return 0;
   121f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   121f7:	c9                   	leave  
   121f8:	c3                   	ret    

000121f9 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   121f9:	55                   	push   %ebp
   121fa:	89 e5                	mov    %esp,%ebp
   121fc:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   121ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   12206:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   1220d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   12214:	83 ec 0c             	sub    $0xc,%esp
   12217:	ff 75 14             	pushl  0x14(%ebp)
   1221a:	ff 75 10             	pushl  0x10(%ebp)
   1221d:	ff 75 0c             	pushl  0xc(%ebp)
   12220:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12223:	50                   	push   %eax
   12224:	8d 45 f0             	lea    -0x10(%ebp),%eax
   12227:	50                   	push   %eax
   12228:	e8 fb 74 ff ff       	call   9728 <zlib_compress>
   1222d:	83 c4 20             	add    $0x20,%esp
   12230:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   12233:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12237:	75 1b                	jne    12254 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   12239:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1223c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1223f:	50                   	push   %eax
   12240:	68 84 b7 01 00       	push   $0x1b784
   12245:	52                   	push   %edx
   12246:	ff 75 08             	pushl  0x8(%ebp)
   12249:	e8 ea 7c ff ff       	call   9f38 <lodepng_chunk_createv>
   1224e:	83 c4 10             	add    $0x10,%esp
   12251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   12254:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12257:	83 ec 0c             	sub    $0xc,%esp
   1225a:	50                   	push   %eax
   1225b:	e8 d9 27 ff ff       	call   4a39 <lodepng_free>
   12260:	83 c4 10             	add    $0x10,%esp
  return error;
   12263:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   12266:	c9                   	leave  
   12267:	c3                   	ret    

00012268 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   12268:	55                   	push   %ebp
   12269:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   1226b:	6a 00                	push   $0x0
   1226d:	68 89 b7 01 00       	push   $0x1b789
   12272:	6a 00                	push   $0x0
   12274:	ff 75 08             	pushl  0x8(%ebp)
   12277:	e8 bc 7c ff ff       	call   9f38 <lodepng_chunk_createv>
   1227c:	83 c4 10             	add    $0x10,%esp
}
   1227f:	c9                   	leave  
   12280:	c3                   	ret    

00012281 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   12281:	55                   	push   %ebp
   12282:	89 e5                	mov    %esp,%ebp
   12284:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   12287:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   1228e:	ff 75 0c             	pushl  0xc(%ebp)
   12291:	e8 1e 28 ff ff       	call   4ab4 <lodepng_strlen>
   12296:	83 c4 04             	add    $0x4,%esp
   12299:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1229c:	ff 75 10             	pushl  0x10(%ebp)
   1229f:	e8 10 28 ff ff       	call   4ab4 <lodepng_strlen>
   122a4:	83 c4 04             	add    $0x4,%esp
   122a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   122aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122ad:	8d 50 01             	lea    0x1(%eax),%edx
   122b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   122b3:	01 d0                	add    %edx,%eax
   122b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   122b8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   122bc:	7e 06                	jle    122c4 <addChunk_tEXt+0x43>
   122be:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   122c2:	7e 07                	jle    122cb <addChunk_tEXt+0x4a>
   122c4:	b8 59 00 00 00       	mov    $0x59,%eax
   122c9:	eb 74                	jmp    1233f <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   122cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122ce:	68 57 b7 01 00       	push   $0x1b757
   122d3:	50                   	push   %eax
   122d4:	ff 75 08             	pushl  0x8(%ebp)
   122d7:	8d 45 ec             	lea    -0x14(%ebp),%eax
   122da:	50                   	push   %eax
   122db:	e8 b0 7b ff ff       	call   9e90 <lodepng_chunk_init>
   122e0:	83 c4 10             	add    $0x10,%esp
   122e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
   122e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   122ea:	74 05                	je     122f1 <addChunk_tEXt+0x70>
   122ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122ef:	eb 4e                	jmp    1233f <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   122f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   122f4:	83 c0 08             	add    $0x8,%eax
   122f7:	ff 75 fc             	pushl  -0x4(%ebp)
   122fa:	ff 75 0c             	pushl  0xc(%ebp)
   122fd:	50                   	push   %eax
   122fe:	e8 53 27 ff ff       	call   4a56 <lodepng_memcpy>
   12303:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   12306:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12309:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1230c:	83 c2 08             	add    $0x8,%edx
   1230f:	01 d0                	add    %edx,%eax
   12311:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   12314:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12317:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1231a:	83 c2 09             	add    $0x9,%edx
   1231d:	01 d0                	add    %edx,%eax
   1231f:	ff 75 f8             	pushl  -0x8(%ebp)
   12322:	ff 75 10             	pushl  0x10(%ebp)
   12325:	50                   	push   %eax
   12326:	e8 2b 27 ff ff       	call   4a56 <lodepng_memcpy>
   1232b:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   1232e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12331:	50                   	push   %eax
   12332:	e8 02 78 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   12337:	83 c4 04             	add    $0x4,%esp
  return 0;
   1233a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1233f:	c9                   	leave  
   12340:	c3                   	ret    

00012341 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   12341:	55                   	push   %ebp
   12342:	89 e5                	mov    %esp,%ebp
   12344:	53                   	push   %ebx
   12345:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   12348:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   1234f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   12356:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   1235d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   12364:	ff 75 10             	pushl  0x10(%ebp)
   12367:	e8 48 27 ff ff       	call   4ab4 <lodepng_strlen>
   1236c:	83 c4 04             	add    $0x4,%esp
   1236f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   12372:	ff 75 0c             	pushl  0xc(%ebp)
   12375:	e8 3a 27 ff ff       	call   4ab4 <lodepng_strlen>
   1237a:	83 c4 04             	add    $0x4,%esp
   1237d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   12380:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12384:	7e 06                	jle    1238c <addChunk_zTXt+0x4b>
   12386:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1238a:	7e 0a                	jle    12396 <addChunk_zTXt+0x55>
   1238c:	b8 59 00 00 00       	mov    $0x59,%eax
   12391:	e9 c8 00 00 00       	jmp    1245e <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   12396:	83 ec 0c             	sub    $0xc,%esp
   12399:	ff 75 14             	pushl  0x14(%ebp)
   1239c:	ff 75 f0             	pushl  -0x10(%ebp)
   1239f:	ff 75 10             	pushl  0x10(%ebp)
   123a2:	8d 45 dc             	lea    -0x24(%ebp),%eax
   123a5:	50                   	push   %eax
   123a6:	8d 45 e0             	lea    -0x20(%ebp),%eax
   123a9:	50                   	push   %eax
   123aa:	e8 79 73 ff ff       	call   9728 <zlib_compress>
   123af:	83 c4 20             	add    $0x20,%esp
   123b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   123b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   123b9:	75 29                	jne    123e4 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   123bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   123be:	8d 50 02             	lea    0x2(%eax),%edx
   123c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   123c4:	01 d0                	add    %edx,%eax
   123c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   123c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123cc:	68 5c b7 01 00       	push   $0x1b75c
   123d1:	50                   	push   %eax
   123d2:	ff 75 08             	pushl  0x8(%ebp)
   123d5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   123d8:	50                   	push   %eax
   123d9:	e8 b2 7a ff ff       	call   9e90 <lodepng_chunk_init>
   123de:	83 c4 10             	add    $0x10,%esp
   123e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   123e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   123e8:	75 62                	jne    1244c <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   123ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   123ed:	83 c0 08             	add    $0x8,%eax
   123f0:	83 ec 04             	sub    $0x4,%esp
   123f3:	ff 75 ec             	pushl  -0x14(%ebp)
   123f6:	ff 75 0c             	pushl  0xc(%ebp)
   123f9:	50                   	push   %eax
   123fa:	e8 57 26 ff ff       	call   4a56 <lodepng_memcpy>
   123ff:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   12402:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12405:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12408:	83 c2 08             	add    $0x8,%edx
   1240b:	01 d0                	add    %edx,%eax
   1240d:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   12410:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12413:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12416:	83 c2 09             	add    $0x9,%edx
   12419:	01 d0                	add    %edx,%eax
   1241b:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   1241e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   12421:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12424:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   12427:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   1242a:	83 c3 0a             	add    $0xa,%ebx
   1242d:	01 d9                	add    %ebx,%ecx
   1242f:	83 ec 04             	sub    $0x4,%esp
   12432:	52                   	push   %edx
   12433:	50                   	push   %eax
   12434:	51                   	push   %ecx
   12435:	e8 1c 26 ff ff       	call   4a56 <lodepng_memcpy>
   1243a:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   1243d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12440:	83 ec 0c             	sub    $0xc,%esp
   12443:	50                   	push   %eax
   12444:	e8 f0 76 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   12449:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1244c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1244f:	83 ec 0c             	sub    $0xc,%esp
   12452:	50                   	push   %eax
   12453:	e8 e1 25 ff ff       	call   4a39 <lodepng_free>
   12458:	83 c4 10             	add    $0x10,%esp
  return error;
   1245b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1245e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12461:	c9                   	leave  
   12462:	c3                   	ret    

00012463 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   12463:	55                   	push   %ebp
   12464:	89 e5                	mov    %esp,%ebp
   12466:	53                   	push   %ebx
   12467:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   1246a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   12471:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   12478:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   1247f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   12486:	ff 75 1c             	pushl  0x1c(%ebp)
   12489:	e8 26 26 ff ff       	call   4ab4 <lodepng_strlen>
   1248e:	83 c4 04             	add    $0x4,%esp
   12491:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   12494:	ff 75 10             	pushl  0x10(%ebp)
   12497:	e8 18 26 ff ff       	call   4ab4 <lodepng_strlen>
   1249c:	83 c4 04             	add    $0x4,%esp
   1249f:	89 45 ec             	mov    %eax,-0x14(%ebp)
   124a2:	ff 75 14             	pushl  0x14(%ebp)
   124a5:	e8 0a 26 ff ff       	call   4ab4 <lodepng_strlen>
   124aa:	83 c4 04             	add    $0x4,%esp
   124ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
   124b0:	ff 75 18             	pushl  0x18(%ebp)
   124b3:	e8 fc 25 ff ff       	call   4ab4 <lodepng_strlen>
   124b8:	83 c4 04             	add    $0x4,%esp
   124bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   124be:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   124c2:	7e 06                	jle    124ca <addChunk_iTXt+0x67>
   124c4:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   124c8:	7e 0a                	jle    124d4 <addChunk_iTXt+0x71>
   124ca:	b8 59 00 00 00       	mov    $0x59,%eax
   124cf:	e9 9a 01 00 00       	jmp    1266e <addChunk_iTXt+0x20b>

  if(compress) {
   124d4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   124d8:	74 1f                	je     124f9 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   124da:	83 ec 0c             	sub    $0xc,%esp
   124dd:	ff 75 20             	pushl  0x20(%ebp)
   124e0:	ff 75 f0             	pushl  -0x10(%ebp)
   124e3:	ff 75 1c             	pushl  0x1c(%ebp)
   124e6:	8d 45 d0             	lea    -0x30(%ebp),%eax
   124e9:	50                   	push   %eax
   124ea:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   124ed:	50                   	push   %eax
   124ee:	e8 35 72 ff ff       	call   9728 <zlib_compress>
   124f3:	83 c4 20             	add    $0x20,%esp
   124f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   124f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   124fd:	75 44                	jne    12543 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   124ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12502:	8d 50 03             	lea    0x3(%eax),%edx
   12505:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12508:	01 d0                	add    %edx,%eax
   1250a:	8d 50 01             	lea    0x1(%eax),%edx
   1250d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12510:	01 d0                	add    %edx,%eax
   12512:	8d 50 01             	lea    0x1(%eax),%edx
   12515:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12519:	74 05                	je     12520 <addChunk_iTXt+0xbd>
   1251b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1251e:	eb 03                	jmp    12523 <addChunk_iTXt+0xc0>
   12520:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12523:	01 d0                	add    %edx,%eax
   12525:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   12528:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1252b:	68 61 b7 01 00       	push   $0x1b761
   12530:	50                   	push   %eax
   12531:	ff 75 08             	pushl  0x8(%ebp)
   12534:	8d 45 d8             	lea    -0x28(%ebp),%eax
   12537:	50                   	push   %eax
   12538:	e8 53 79 ff ff       	call   9e90 <lodepng_chunk_init>
   1253d:	83 c4 10             	add    $0x10,%esp
   12540:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   12543:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12547:	0f 85 0f 01 00 00    	jne    1265c <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   1254d:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   12554:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12557:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1255a:	01 d0                	add    %edx,%eax
   1255c:	83 ec 04             	sub    $0x4,%esp
   1255f:	ff 75 ec             	pushl  -0x14(%ebp)
   12562:	ff 75 10             	pushl  0x10(%ebp)
   12565:	50                   	push   %eax
   12566:	e8 eb 24 ff ff       	call   4a56 <lodepng_memcpy>
   1256b:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   1256e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12571:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   12574:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   12577:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1257a:	8d 50 01             	lea    0x1(%eax),%edx
   1257d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12580:	01 c8                	add    %ecx,%eax
   12582:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   12585:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   12588:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1258b:	8d 50 01             	lea    0x1(%eax),%edx
   1258e:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12591:	01 c8                	add    %ecx,%eax
   12593:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12597:	0f 95 c2             	setne  %dl
   1259a:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   1259c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1259f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   125a2:	8d 50 01             	lea    0x1(%eax),%edx
   125a5:	89 55 dc             	mov    %edx,-0x24(%ebp)
   125a8:	01 c8                	add    %ecx,%eax
   125aa:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   125ad:	8b 55 d8             	mov    -0x28(%ebp),%edx
   125b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   125b3:	01 d0                	add    %edx,%eax
   125b5:	83 ec 04             	sub    $0x4,%esp
   125b8:	ff 75 e8             	pushl  -0x18(%ebp)
   125bb:	ff 75 14             	pushl  0x14(%ebp)
   125be:	50                   	push   %eax
   125bf:	e8 92 24 ff ff       	call   4a56 <lodepng_memcpy>
   125c4:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   125c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   125ca:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   125cd:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   125d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   125d3:	8d 50 01             	lea    0x1(%eax),%edx
   125d6:	89 55 dc             	mov    %edx,-0x24(%ebp)
   125d9:	01 c8                	add    %ecx,%eax
   125db:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   125de:	8b 55 d8             	mov    -0x28(%ebp),%edx
   125e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   125e4:	01 d0                	add    %edx,%eax
   125e6:	83 ec 04             	sub    $0x4,%esp
   125e9:	ff 75 e4             	pushl  -0x1c(%ebp)
   125ec:	ff 75 18             	pushl  0x18(%ebp)
   125ef:	50                   	push   %eax
   125f0:	e8 61 24 ff ff       	call   4a56 <lodepng_memcpy>
   125f5:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   125f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   125fb:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   125fe:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   12601:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12604:	8d 50 01             	lea    0x1(%eax),%edx
   12607:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1260a:	01 c8                	add    %ecx,%eax
   1260c:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   1260f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12613:	74 1e                	je     12633 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   12615:	8b 55 d0             	mov    -0x30(%ebp),%edx
   12618:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1261b:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   1261e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12621:	01 d9                	add    %ebx,%ecx
   12623:	83 ec 04             	sub    $0x4,%esp
   12626:	52                   	push   %edx
   12627:	50                   	push   %eax
   12628:	51                   	push   %ecx
   12629:	e8 28 24 ff ff       	call   4a56 <lodepng_memcpy>
   1262e:	83 c4 10             	add    $0x10,%esp
   12631:	eb 1a                	jmp    1264d <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   12633:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12636:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12639:	01 d0                	add    %edx,%eax
   1263b:	83 ec 04             	sub    $0x4,%esp
   1263e:	ff 75 f0             	pushl  -0x10(%ebp)
   12641:	ff 75 1c             	pushl  0x1c(%ebp)
   12644:	50                   	push   %eax
   12645:	e8 0c 24 ff ff       	call   4a56 <lodepng_memcpy>
   1264a:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   1264d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12650:	83 ec 0c             	sub    $0xc,%esp
   12653:	50                   	push   %eax
   12654:	e8 e0 74 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   12659:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1265c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1265f:	83 ec 0c             	sub    $0xc,%esp
   12662:	50                   	push   %eax
   12663:	e8 d1 23 ff ff       	call   4a39 <lodepng_free>
   12668:	83 c4 10             	add    $0x10,%esp
  return error;
   1266b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1266e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12671:	c9                   	leave  
   12672:	c3                   	ret    

00012673 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   12673:	55                   	push   %ebp
   12674:	89 e5                	mov    %esp,%ebp
   12676:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   12679:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   12680:	8b 45 0c             	mov    0xc(%ebp),%eax
   12683:	8b 40 0c             	mov    0xc(%eax),%eax
   12686:	85 c0                	test   %eax,%eax
   12688:	74 0b                	je     12695 <addChunk_bKGD+0x22>
   1268a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1268d:	8b 40 0c             	mov    0xc(%eax),%eax
   12690:	83 f8 04             	cmp    $0x4,%eax
   12693:	75 4b                	jne    126e0 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   12695:	68 52 b7 01 00       	push   $0x1b752
   1269a:	6a 02                	push   $0x2
   1269c:	ff 75 08             	pushl  0x8(%ebp)
   1269f:	8d 45 f0             	lea    -0x10(%ebp),%eax
   126a2:	50                   	push   %eax
   126a3:	e8 e8 77 ff ff       	call   9e90 <lodepng_chunk_init>
   126a8:	83 c4 10             	add    $0x10,%esp
   126ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
   126ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   126b2:	74 08                	je     126bc <addChunk_bKGD+0x49>
   126b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   126b7:	e9 19 01 00 00       	jmp    127d5 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   126bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   126bf:	8d 50 08             	lea    0x8(%eax),%edx
   126c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   126c5:	8b 40 30             	mov    0x30(%eax),%eax
   126c8:	c1 e8 08             	shr    $0x8,%eax
   126cb:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   126cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   126d0:	8d 50 09             	lea    0x9(%eax),%edx
   126d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   126d6:	8b 40 30             	mov    0x30(%eax),%eax
   126d9:	88 02                	mov    %al,(%edx)
   126db:	e9 dd 00 00 00       	jmp    127bd <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   126e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   126e3:	8b 40 0c             	mov    0xc(%eax),%eax
   126e6:	83 f8 02             	cmp    $0x2,%eax
   126e9:	74 0f                	je     126fa <addChunk_bKGD+0x87>
   126eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   126ee:	8b 40 0c             	mov    0xc(%eax),%eax
   126f1:	83 f8 06             	cmp    $0x6,%eax
   126f4:	0f 85 86 00 00 00    	jne    12780 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   126fa:	68 52 b7 01 00       	push   $0x1b752
   126ff:	6a 06                	push   $0x6
   12701:	ff 75 08             	pushl  0x8(%ebp)
   12704:	8d 45 f0             	lea    -0x10(%ebp),%eax
   12707:	50                   	push   %eax
   12708:	e8 83 77 ff ff       	call   9e90 <lodepng_chunk_init>
   1270d:	83 c4 10             	add    $0x10,%esp
   12710:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12713:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12717:	74 08                	je     12721 <addChunk_bKGD+0xae>
   12719:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1271c:	e9 b4 00 00 00       	jmp    127d5 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   12721:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12724:	8d 50 08             	lea    0x8(%eax),%edx
   12727:	8b 45 0c             	mov    0xc(%ebp),%eax
   1272a:	8b 40 30             	mov    0x30(%eax),%eax
   1272d:	c1 e8 08             	shr    $0x8,%eax
   12730:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   12732:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12735:	8d 50 09             	lea    0x9(%eax),%edx
   12738:	8b 45 0c             	mov    0xc(%ebp),%eax
   1273b:	8b 40 30             	mov    0x30(%eax),%eax
   1273e:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   12740:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12743:	8d 50 0a             	lea    0xa(%eax),%edx
   12746:	8b 45 0c             	mov    0xc(%ebp),%eax
   12749:	8b 40 34             	mov    0x34(%eax),%eax
   1274c:	c1 e8 08             	shr    $0x8,%eax
   1274f:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   12751:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12754:	8d 50 0b             	lea    0xb(%eax),%edx
   12757:	8b 45 0c             	mov    0xc(%ebp),%eax
   1275a:	8b 40 34             	mov    0x34(%eax),%eax
   1275d:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1275f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12762:	8d 50 0c             	lea    0xc(%eax),%edx
   12765:	8b 45 0c             	mov    0xc(%ebp),%eax
   12768:	8b 40 38             	mov    0x38(%eax),%eax
   1276b:	c1 e8 08             	shr    $0x8,%eax
   1276e:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   12770:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12773:	8d 50 0d             	lea    0xd(%eax),%edx
   12776:	8b 45 0c             	mov    0xc(%ebp),%eax
   12779:	8b 40 38             	mov    0x38(%eax),%eax
   1277c:	88 02                	mov    %al,(%edx)
   1277e:	eb 3d                	jmp    127bd <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   12780:	8b 45 0c             	mov    0xc(%ebp),%eax
   12783:	8b 40 0c             	mov    0xc(%eax),%eax
   12786:	83 f8 03             	cmp    $0x3,%eax
   12789:	75 32                	jne    127bd <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   1278b:	68 52 b7 01 00       	push   $0x1b752
   12790:	6a 01                	push   $0x1
   12792:	ff 75 08             	pushl  0x8(%ebp)
   12795:	8d 45 f0             	lea    -0x10(%ebp),%eax
   12798:	50                   	push   %eax
   12799:	e8 f2 76 ff ff       	call   9e90 <lodepng_chunk_init>
   1279e:	83 c4 10             	add    $0x10,%esp
   127a1:	89 45 fc             	mov    %eax,-0x4(%ebp)
   127a4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   127a8:	74 05                	je     127af <addChunk_bKGD+0x13c>
   127aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   127ad:	eb 26                	jmp    127d5 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   127af:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127b2:	8d 50 08             	lea    0x8(%eax),%edx
   127b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   127b8:	8b 40 30             	mov    0x30(%eax),%eax
   127bb:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   127bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127c0:	85 c0                	test   %eax,%eax
   127c2:	74 0c                	je     127d0 <addChunk_bKGD+0x15d>
   127c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127c7:	50                   	push   %eax
   127c8:	e8 6c 73 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   127cd:	83 c4 04             	add    $0x4,%esp
  return 0;
   127d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127d5:	c9                   	leave  
   127d6:	c3                   	ret    

000127d7 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   127d7:	55                   	push   %ebp
   127d8:	89 e5                	mov    %esp,%ebp
   127da:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   127dd:	68 66 b7 01 00       	push   $0x1b766
   127e2:	6a 07                	push   $0x7
   127e4:	ff 75 08             	pushl  0x8(%ebp)
   127e7:	8d 45 f8             	lea    -0x8(%ebp),%eax
   127ea:	50                   	push   %eax
   127eb:	e8 a0 76 ff ff       	call   9e90 <lodepng_chunk_init>
   127f0:	83 c4 10             	add    $0x10,%esp
   127f3:	89 45 fc             	mov    %eax,-0x4(%ebp)
   127f6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   127fa:	74 05                	je     12801 <addChunk_tIME+0x2a>
   127fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   127ff:	eb 74                	jmp    12875 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   12801:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12804:	8d 50 08             	lea    0x8(%eax),%edx
   12807:	8b 45 0c             	mov    0xc(%ebp),%eax
   1280a:	8b 00                	mov    (%eax),%eax
   1280c:	c1 e8 08             	shr    $0x8,%eax
   1280f:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   12811:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12814:	8d 50 09             	lea    0x9(%eax),%edx
   12817:	8b 45 0c             	mov    0xc(%ebp),%eax
   1281a:	8b 00                	mov    (%eax),%eax
   1281c:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   1281e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12821:	8d 50 0a             	lea    0xa(%eax),%edx
   12824:	8b 45 0c             	mov    0xc(%ebp),%eax
   12827:	8b 40 04             	mov    0x4(%eax),%eax
   1282a:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   1282c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1282f:	8d 50 0b             	lea    0xb(%eax),%edx
   12832:	8b 45 0c             	mov    0xc(%ebp),%eax
   12835:	8b 40 08             	mov    0x8(%eax),%eax
   12838:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   1283a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1283d:	8d 50 0c             	lea    0xc(%eax),%edx
   12840:	8b 45 0c             	mov    0xc(%ebp),%eax
   12843:	8b 40 0c             	mov    0xc(%eax),%eax
   12846:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   12848:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1284b:	8d 50 0d             	lea    0xd(%eax),%edx
   1284e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12851:	8b 40 10             	mov    0x10(%eax),%eax
   12854:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   12856:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12859:	8d 50 0e             	lea    0xe(%eax),%edx
   1285c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1285f:	8b 40 14             	mov    0x14(%eax),%eax
   12862:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   12864:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12867:	50                   	push   %eax
   12868:	e8 cc 72 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   1286d:	83 c4 04             	add    $0x4,%esp
  return 0;
   12870:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12875:	c9                   	leave  
   12876:	c3                   	ret    

00012877 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   12877:	55                   	push   %ebp
   12878:	89 e5                	mov    %esp,%ebp
   1287a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   1287d:	68 6b b7 01 00       	push   $0x1b76b
   12882:	6a 09                	push   $0x9
   12884:	ff 75 08             	pushl  0x8(%ebp)
   12887:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1288a:	50                   	push   %eax
   1288b:	e8 00 76 ff ff       	call   9e90 <lodepng_chunk_init>
   12890:	83 c4 10             	add    $0x10,%esp
   12893:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12896:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1289a:	74 05                	je     128a1 <addChunk_pHYs+0x2a>
   1289c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1289f:	eb 51                	jmp    128f2 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   128a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   128a4:	8b 40 7c             	mov    0x7c(%eax),%eax
   128a7:	8b 55 f8             	mov    -0x8(%ebp),%edx
   128aa:	83 c2 08             	add    $0x8,%edx
   128ad:	50                   	push   %eax
   128ae:	52                   	push   %edx
   128af:	e8 25 25 ff ff       	call   4dd9 <lodepng_set32bitInt>
   128b4:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   128b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   128ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   128c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
   128c3:	83 c2 0c             	add    $0xc,%edx
   128c6:	50                   	push   %eax
   128c7:	52                   	push   %edx
   128c8:	e8 0c 25 ff ff       	call   4dd9 <lodepng_set32bitInt>
   128cd:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   128d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   128d3:	8d 50 10             	lea    0x10(%eax),%edx
   128d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   128d9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   128df:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   128e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   128e4:	50                   	push   %eax
   128e5:	e8 4f 72 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   128ea:	83 c4 04             	add    $0x4,%esp
  return 0;
   128ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
   128f2:	c9                   	leave  
   128f3:	c3                   	ret    

000128f4 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   128f4:	55                   	push   %ebp
   128f5:	89 e5                	mov    %esp,%ebp
   128f7:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   128fa:	68 70 b7 01 00       	push   $0x1b770
   128ff:	6a 04                	push   $0x4
   12901:	ff 75 08             	pushl  0x8(%ebp)
   12904:	8d 45 f8             	lea    -0x8(%ebp),%eax
   12907:	50                   	push   %eax
   12908:	e8 83 75 ff ff       	call   9e90 <lodepng_chunk_init>
   1290d:	83 c4 10             	add    $0x10,%esp
   12910:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12913:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   12917:	74 05                	je     1291e <addChunk_gAMA+0x2a>
   12919:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1291c:	eb 2a                	jmp    12948 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   1291e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12921:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   12927:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1292a:	83 c2 08             	add    $0x8,%edx
   1292d:	50                   	push   %eax
   1292e:	52                   	push   %edx
   1292f:	e8 a5 24 ff ff       	call   4dd9 <lodepng_set32bitInt>
   12934:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   12937:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1293a:	50                   	push   %eax
   1293b:	e8 f9 71 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   12940:	83 c4 04             	add    $0x4,%esp
  return 0;
   12943:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12948:	c9                   	leave  
   12949:	c3                   	ret    

0001294a <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   1294a:	55                   	push   %ebp
   1294b:	89 e5                	mov    %esp,%ebp
   1294d:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   12950:	68 75 b7 01 00       	push   $0x1b775
   12955:	6a 20                	push   $0x20
   12957:	ff 75 08             	pushl  0x8(%ebp)
   1295a:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1295d:	50                   	push   %eax
   1295e:	e8 2d 75 ff ff       	call   9e90 <lodepng_chunk_init>
   12963:	83 c4 10             	add    $0x10,%esp
   12966:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12969:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1296d:	74 08                	je     12977 <addChunk_cHRM+0x2d>
   1296f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12972:	e9 d9 00 00 00       	jmp    12a50 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   12977:	8b 45 0c             	mov    0xc(%ebp),%eax
   1297a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   12980:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12983:	83 c2 08             	add    $0x8,%edx
   12986:	50                   	push   %eax
   12987:	52                   	push   %edx
   12988:	e8 4c 24 ff ff       	call   4dd9 <lodepng_set32bitInt>
   1298d:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   12990:	8b 45 0c             	mov    0xc(%ebp),%eax
   12993:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   12999:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1299c:	83 c2 0c             	add    $0xc,%edx
   1299f:	50                   	push   %eax
   129a0:	52                   	push   %edx
   129a1:	e8 33 24 ff ff       	call   4dd9 <lodepng_set32bitInt>
   129a6:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   129a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   129ac:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   129b2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   129b5:	83 c2 10             	add    $0x10,%edx
   129b8:	50                   	push   %eax
   129b9:	52                   	push   %edx
   129ba:	e8 1a 24 ff ff       	call   4dd9 <lodepng_set32bitInt>
   129bf:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   129c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   129c5:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   129cb:	8b 55 f8             	mov    -0x8(%ebp),%edx
   129ce:	83 c2 14             	add    $0x14,%edx
   129d1:	50                   	push   %eax
   129d2:	52                   	push   %edx
   129d3:	e8 01 24 ff ff       	call   4dd9 <lodepng_set32bitInt>
   129d8:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   129db:	8b 45 0c             	mov    0xc(%ebp),%eax
   129de:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   129e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   129e7:	83 c2 18             	add    $0x18,%edx
   129ea:	50                   	push   %eax
   129eb:	52                   	push   %edx
   129ec:	e8 e8 23 ff ff       	call   4dd9 <lodepng_set32bitInt>
   129f1:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   129f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   129f7:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   129fd:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12a00:	83 c2 1c             	add    $0x1c,%edx
   12a03:	50                   	push   %eax
   12a04:	52                   	push   %edx
   12a05:	e8 cf 23 ff ff       	call   4dd9 <lodepng_set32bitInt>
   12a0a:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   12a0d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a10:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   12a16:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12a19:	83 c2 20             	add    $0x20,%edx
   12a1c:	50                   	push   %eax
   12a1d:	52                   	push   %edx
   12a1e:	e8 b6 23 ff ff       	call   4dd9 <lodepng_set32bitInt>
   12a23:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   12a26:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a29:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   12a2f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12a32:	83 c2 24             	add    $0x24,%edx
   12a35:	50                   	push   %eax
   12a36:	52                   	push   %edx
   12a37:	e8 9d 23 ff ff       	call   4dd9 <lodepng_set32bitInt>
   12a3c:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   12a3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12a42:	50                   	push   %eax
   12a43:	e8 f1 70 ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   12a48:	83 c4 04             	add    $0x4,%esp
  return 0;
   12a4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12a50:	c9                   	leave  
   12a51:	c3                   	ret    

00012a52 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   12a52:	55                   	push   %ebp
   12a53:	89 e5                	mov    %esp,%ebp
   12a55:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   12a58:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a5b:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   12a61:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   12a64:	8d 45 ff             	lea    -0x1(%ebp),%eax
   12a67:	50                   	push   %eax
   12a68:	68 7a b7 01 00       	push   $0x1b77a
   12a6d:	6a 01                	push   $0x1
   12a6f:	ff 75 08             	pushl  0x8(%ebp)
   12a72:	e8 c1 74 ff ff       	call   9f38 <lodepng_chunk_createv>
   12a77:	83 c4 10             	add    $0x10,%esp
}
   12a7a:	c9                   	leave  
   12a7b:	c3                   	ret    

00012a7c <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   12a7c:	55                   	push   %ebp
   12a7d:	89 e5                	mov    %esp,%ebp
   12a7f:	53                   	push   %ebx
   12a80:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   12a83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   12a8a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   12a91:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   12a98:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   12a9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12aa2:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   12aa8:	50                   	push   %eax
   12aa9:	e8 06 20 ff ff       	call   4ab4 <lodepng_strlen>
   12aae:	83 c4 04             	add    $0x4,%esp
   12ab1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   12ab4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12ab8:	7e 06                	jle    12ac0 <addChunk_iCCP+0x44>
   12aba:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   12abe:	7e 0a                	jle    12aca <addChunk_iCCP+0x4e>
   12ac0:	b8 59 00 00 00       	mov    $0x59,%eax
   12ac5:	e9 df 00 00 00       	jmp    12ba9 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   12aca:	8b 45 0c             	mov    0xc(%ebp),%eax
   12acd:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   12ad3:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   12ad5:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ad8:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   12ade:	83 ec 0c             	sub    $0xc,%esp
   12ae1:	ff 75 10             	pushl  0x10(%ebp)
   12ae4:	52                   	push   %edx
   12ae5:	50                   	push   %eax
   12ae6:	8d 45 e0             	lea    -0x20(%ebp),%eax
   12ae9:	50                   	push   %eax
   12aea:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   12aed:	50                   	push   %eax
   12aee:	e8 35 6c ff ff       	call   9728 <zlib_compress>
   12af3:	83 c4 20             	add    $0x20,%esp
   12af6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   12af9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12afd:	75 29                	jne    12b28 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   12aff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12b02:	8d 50 02             	lea    0x2(%eax),%edx
   12b05:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12b08:	01 d0                	add    %edx,%eax
   12b0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   12b0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12b10:	68 7f b7 01 00       	push   $0x1b77f
   12b15:	50                   	push   %eax
   12b16:	ff 75 08             	pushl  0x8(%ebp)
   12b19:	8d 45 e8             	lea    -0x18(%ebp),%eax
   12b1c:	50                   	push   %eax
   12b1d:	e8 6e 73 ff ff       	call   9e90 <lodepng_chunk_init>
   12b22:	83 c4 10             	add    $0x10,%esp
   12b25:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   12b28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12b2c:	75 69                	jne    12b97 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   12b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b31:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   12b37:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12b3a:	83 c2 08             	add    $0x8,%edx
   12b3d:	83 ec 04             	sub    $0x4,%esp
   12b40:	ff 75 f0             	pushl  -0x10(%ebp)
   12b43:	50                   	push   %eax
   12b44:	52                   	push   %edx
   12b45:	e8 0c 1f ff ff       	call   4a56 <lodepng_memcpy>
   12b4a:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   12b4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12b50:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12b53:	83 c2 08             	add    $0x8,%edx
   12b56:	01 d0                	add    %edx,%eax
   12b58:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   12b5b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12b5e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12b61:	83 c2 09             	add    $0x9,%edx
   12b64:	01 d0                	add    %edx,%eax
   12b66:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   12b69:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12b6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12b6f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   12b72:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   12b75:	83 c3 0a             	add    $0xa,%ebx
   12b78:	01 d9                	add    %ebx,%ecx
   12b7a:	83 ec 04             	sub    $0x4,%esp
   12b7d:	52                   	push   %edx
   12b7e:	50                   	push   %eax
   12b7f:	51                   	push   %ecx
   12b80:	e8 d1 1e ff ff       	call   4a56 <lodepng_memcpy>
   12b85:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   12b88:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12b8b:	83 ec 0c             	sub    $0xc,%esp
   12b8e:	50                   	push   %eax
   12b8f:	e8 a5 6f ff ff       	call   9b39 <lodepng_chunk_generate_crc>
   12b94:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   12b97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12b9a:	83 ec 0c             	sub    $0xc,%esp
   12b9d:	50                   	push   %eax
   12b9e:	e8 96 1e ff ff       	call   4a39 <lodepng_free>
   12ba3:	83 c4 10             	add    $0x10,%esp
  return error;
   12ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   12ba9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12bac:	c9                   	leave  
   12bad:	c3                   	ret    

00012bae <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   12bae:	55                   	push   %ebp
   12baf:	89 e5                	mov    %esp,%ebp
   12bb1:	56                   	push   %esi
   12bb2:	53                   	push   %ebx
   12bb3:	83 ec 14             	sub    $0x14,%esp
   12bb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bb9:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   12bbc:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   12bc0:	83 f8 04             	cmp    $0x4,%eax
   12bc3:	0f 87 41 03 00 00    	ja     12f0a <filterScanline+0x35c>
   12bc9:	8b 04 85 90 b7 01 00 	mov    0x1b790(,%eax,4),%eax
   12bd0:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   12bd2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12bd9:	eb 19                	jmp    12bf4 <filterScanline+0x46>
   12bdb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12bde:	8b 45 08             	mov    0x8(%ebp),%eax
   12be1:	01 c2                	add    %eax,%edx
   12be3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12be6:	8b 45 0c             	mov    0xc(%ebp),%eax
   12be9:	01 c8                	add    %ecx,%eax
   12beb:	0f b6 00             	movzbl (%eax),%eax
   12bee:	88 02                	mov    %al,(%edx)
   12bf0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12bf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12bf7:	3b 45 14             	cmp    0x14(%ebp),%eax
   12bfa:	75 df                	jne    12bdb <filterScanline+0x2d>
      break;
   12bfc:	e9 0a 03 00 00       	jmp    12f0b <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   12c01:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12c08:	eb 19                	jmp    12c23 <filterScanline+0x75>
   12c0a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12c0d:	8b 45 08             	mov    0x8(%ebp),%eax
   12c10:	01 c2                	add    %eax,%edx
   12c12:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12c15:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c18:	01 c8                	add    %ecx,%eax
   12c1a:	0f b6 00             	movzbl (%eax),%eax
   12c1d:	88 02                	mov    %al,(%edx)
   12c1f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12c23:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12c26:	3b 45 18             	cmp    0x18(%ebp),%eax
   12c29:	75 df                	jne    12c0a <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   12c2b:	8b 45 18             	mov    0x18(%ebp),%eax
   12c2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12c31:	eb 2d                	jmp    12c60 <filterScanline+0xb2>
   12c33:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12c36:	8b 45 08             	mov    0x8(%ebp),%eax
   12c39:	01 c2                	add    %eax,%edx
   12c3b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12c3e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c41:	01 c8                	add    %ecx,%eax
   12c43:	0f b6 08             	movzbl (%eax),%ecx
   12c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12c49:	2b 45 18             	sub    0x18(%ebp),%eax
   12c4c:	89 c3                	mov    %eax,%ebx
   12c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c51:	01 d8                	add    %ebx,%eax
   12c53:	0f b6 00             	movzbl (%eax),%eax
   12c56:	29 c1                	sub    %eax,%ecx
   12c58:	89 c8                	mov    %ecx,%eax
   12c5a:	88 02                	mov    %al,(%edx)
   12c5c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12c60:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12c63:	3b 45 14             	cmp    0x14(%ebp),%eax
   12c66:	7c cb                	jl     12c33 <filterScanline+0x85>
      break;
   12c68:	e9 9e 02 00 00       	jmp    12f0b <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   12c6d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12c71:	74 3e                	je     12cb1 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   12c73:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12c7a:	eb 28                	jmp    12ca4 <filterScanline+0xf6>
   12c7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12c7f:	8b 45 08             	mov    0x8(%ebp),%eax
   12c82:	01 d0                	add    %edx,%eax
   12c84:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12c87:	8b 55 0c             	mov    0xc(%ebp),%edx
   12c8a:	01 ca                	add    %ecx,%edx
   12c8c:	0f b6 0a             	movzbl (%edx),%ecx
   12c8f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   12c92:	8b 55 10             	mov    0x10(%ebp),%edx
   12c95:	01 da                	add    %ebx,%edx
   12c97:	0f b6 12             	movzbl (%edx),%edx
   12c9a:	29 d1                	sub    %edx,%ecx
   12c9c:	89 ca                	mov    %ecx,%edx
   12c9e:	88 10                	mov    %dl,(%eax)
   12ca0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12ca7:	3b 45 14             	cmp    0x14(%ebp),%eax
   12caa:	75 d0                	jne    12c7c <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   12cac:	e9 5a 02 00 00       	jmp    12f0b <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   12cb1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12cb8:	eb 19                	jmp    12cd3 <filterScanline+0x125>
   12cba:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12cbd:	8b 45 08             	mov    0x8(%ebp),%eax
   12cc0:	01 c2                	add    %eax,%edx
   12cc2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12cc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cc8:	01 c8                	add    %ecx,%eax
   12cca:	0f b6 00             	movzbl (%eax),%eax
   12ccd:	88 02                	mov    %al,(%edx)
   12ccf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12cd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12cd6:	3b 45 14             	cmp    0x14(%ebp),%eax
   12cd9:	75 df                	jne    12cba <filterScanline+0x10c>
      }
      break;
   12cdb:	e9 2b 02 00 00       	jmp    12f0b <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   12ce0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12ce4:	0f 84 90 00 00 00    	je     12d7a <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   12cea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12cf1:	eb 28                	jmp    12d1b <filterScanline+0x16d>
   12cf3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12cf6:	8b 45 08             	mov    0x8(%ebp),%eax
   12cf9:	01 d0                	add    %edx,%eax
   12cfb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12cfe:	8b 55 0c             	mov    0xc(%ebp),%edx
   12d01:	01 ca                	add    %ecx,%edx
   12d03:	0f b6 12             	movzbl (%edx),%edx
   12d06:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   12d09:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12d0c:	01 d9                	add    %ebx,%ecx
   12d0e:	0f b6 09             	movzbl (%ecx),%ecx
   12d11:	d0 e9                	shr    %cl
   12d13:	29 ca                	sub    %ecx,%edx
   12d15:	88 10                	mov    %dl,(%eax)
   12d17:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12d1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12d1e:	3b 45 18             	cmp    0x18(%ebp),%eax
   12d21:	75 d0                	jne    12cf3 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   12d23:	8b 45 18             	mov    0x18(%ebp),%eax
   12d26:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12d29:	eb 42                	jmp    12d6d <filterScanline+0x1bf>
   12d2b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12d2e:	8b 45 08             	mov    0x8(%ebp),%eax
   12d31:	01 c2                	add    %eax,%edx
   12d33:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12d36:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d39:	01 c8                	add    %ecx,%eax
   12d3b:	0f b6 08             	movzbl (%eax),%ecx
   12d3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12d41:	2b 45 18             	sub    0x18(%ebp),%eax
   12d44:	89 c3                	mov    %eax,%ebx
   12d46:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d49:	01 d8                	add    %ebx,%eax
   12d4b:	0f b6 00             	movzbl (%eax),%eax
   12d4e:	0f b6 d8             	movzbl %al,%ebx
   12d51:	8b 75 f4             	mov    -0xc(%ebp),%esi
   12d54:	8b 45 10             	mov    0x10(%ebp),%eax
   12d57:	01 f0                	add    %esi,%eax
   12d59:	0f b6 00             	movzbl (%eax),%eax
   12d5c:	0f b6 c0             	movzbl %al,%eax
   12d5f:	01 d8                	add    %ebx,%eax
   12d61:	d1 f8                	sar    %eax
   12d63:	29 c1                	sub    %eax,%ecx
   12d65:	89 c8                	mov    %ecx,%eax
   12d67:	88 02                	mov    %al,(%edx)
   12d69:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12d6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12d70:	3b 45 14             	cmp    0x14(%ebp),%eax
   12d73:	7c b6                	jl     12d2b <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   12d75:	e9 91 01 00 00       	jmp    12f0b <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   12d7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12d81:	eb 19                	jmp    12d9c <filterScanline+0x1ee>
   12d83:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12d86:	8b 45 08             	mov    0x8(%ebp),%eax
   12d89:	01 c2                	add    %eax,%edx
   12d8b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12d8e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d91:	01 c8                	add    %ecx,%eax
   12d93:	0f b6 00             	movzbl (%eax),%eax
   12d96:	88 02                	mov    %al,(%edx)
   12d98:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12d9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12d9f:	3b 45 18             	cmp    0x18(%ebp),%eax
   12da2:	75 df                	jne    12d83 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   12da4:	8b 45 18             	mov    0x18(%ebp),%eax
   12da7:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12daa:	eb 2f                	jmp    12ddb <filterScanline+0x22d>
   12dac:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12daf:	8b 45 08             	mov    0x8(%ebp),%eax
   12db2:	01 c2                	add    %eax,%edx
   12db4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12db7:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dba:	01 c8                	add    %ecx,%eax
   12dbc:	0f b6 08             	movzbl (%eax),%ecx
   12dbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12dc2:	2b 45 18             	sub    0x18(%ebp),%eax
   12dc5:	89 c3                	mov    %eax,%ebx
   12dc7:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dca:	01 d8                	add    %ebx,%eax
   12dcc:	0f b6 00             	movzbl (%eax),%eax
   12dcf:	d0 e8                	shr    %al
   12dd1:	29 c1                	sub    %eax,%ecx
   12dd3:	89 c8                	mov    %ecx,%eax
   12dd5:	88 02                	mov    %al,(%edx)
   12dd7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12ddb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12dde:	3b 45 14             	cmp    0x14(%ebp),%eax
   12de1:	7c c9                	jl     12dac <filterScanline+0x1fe>
      }
      break;
   12de3:	e9 23 01 00 00       	jmp    12f0b <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   12de8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12dec:	0f 84 af 00 00 00    	je     12ea1 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   12df2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12df9:	eb 28                	jmp    12e23 <filterScanline+0x275>
   12dfb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12dfe:	8b 45 08             	mov    0x8(%ebp),%eax
   12e01:	01 d0                	add    %edx,%eax
   12e03:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12e06:	8b 55 0c             	mov    0xc(%ebp),%edx
   12e09:	01 ca                	add    %ecx,%edx
   12e0b:	0f b6 0a             	movzbl (%edx),%ecx
   12e0e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   12e11:	8b 55 10             	mov    0x10(%ebp),%edx
   12e14:	01 da                	add    %ebx,%edx
   12e16:	0f b6 12             	movzbl (%edx),%edx
   12e19:	29 d1                	sub    %edx,%ecx
   12e1b:	89 ca                	mov    %ecx,%edx
   12e1d:	88 10                	mov    %dl,(%eax)
   12e1f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12e23:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12e26:	3b 45 18             	cmp    0x18(%ebp),%eax
   12e29:	75 d0                	jne    12dfb <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   12e2b:	8b 45 18             	mov    0x18(%ebp),%eax
   12e2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12e31:	eb 64                	jmp    12e97 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   12e33:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12e36:	8b 45 08             	mov    0x8(%ebp),%eax
   12e39:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   12e3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12e3f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e42:	01 d0                	add    %edx,%eax
   12e44:	0f b6 00             	movzbl (%eax),%eax
   12e47:	88 45 e7             	mov    %al,-0x19(%ebp)
   12e4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12e4d:	2b 45 18             	sub    0x18(%ebp),%eax
   12e50:	89 c2                	mov    %eax,%edx
   12e52:	8b 45 10             	mov    0x10(%ebp),%eax
   12e55:	01 d0                	add    %edx,%eax
   12e57:	0f b6 00             	movzbl (%eax),%eax
   12e5a:	0f b6 c8             	movzbl %al,%ecx
   12e5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12e60:	8b 45 10             	mov    0x10(%ebp),%eax
   12e63:	01 d0                	add    %edx,%eax
   12e65:	0f b6 00             	movzbl (%eax),%eax
   12e68:	0f b6 d0             	movzbl %al,%edx
   12e6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12e6e:	2b 45 18             	sub    0x18(%ebp),%eax
   12e71:	89 c6                	mov    %eax,%esi
   12e73:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e76:	01 f0                	add    %esi,%eax
   12e78:	0f b6 00             	movzbl (%eax),%eax
   12e7b:	0f b6 c0             	movzbl %al,%eax
   12e7e:	51                   	push   %ecx
   12e7f:	52                   	push   %edx
   12e80:	50                   	push   %eax
   12e81:	e8 49 b8 ff ff       	call   e6cf <paethPredictor>
   12e86:	83 c4 0c             	add    $0xc,%esp
   12e89:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   12e8d:	29 c1                	sub    %eax,%ecx
   12e8f:	89 c8                	mov    %ecx,%eax
   12e91:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   12e93:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12e97:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12e9a:	3b 45 14             	cmp    0x14(%ebp),%eax
   12e9d:	7c 94                	jl     12e33 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   12e9f:	eb 6a                	jmp    12f0b <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   12ea1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12ea8:	eb 19                	jmp    12ec3 <filterScanline+0x315>
   12eaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12ead:	8b 45 08             	mov    0x8(%ebp),%eax
   12eb0:	01 c2                	add    %eax,%edx
   12eb2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12eb5:	8b 45 0c             	mov    0xc(%ebp),%eax
   12eb8:	01 c8                	add    %ecx,%eax
   12eba:	0f b6 00             	movzbl (%eax),%eax
   12ebd:	88 02                	mov    %al,(%edx)
   12ebf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12ec3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12ec6:	3b 45 18             	cmp    0x18(%ebp),%eax
   12ec9:	75 df                	jne    12eaa <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   12ecb:	8b 45 18             	mov    0x18(%ebp),%eax
   12ece:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12ed1:	eb 2d                	jmp    12f00 <filterScanline+0x352>
   12ed3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12ed6:	8b 45 08             	mov    0x8(%ebp),%eax
   12ed9:	01 c2                	add    %eax,%edx
   12edb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12ede:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ee1:	01 c8                	add    %ecx,%eax
   12ee3:	0f b6 08             	movzbl (%eax),%ecx
   12ee6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12ee9:	2b 45 18             	sub    0x18(%ebp),%eax
   12eec:	89 c3                	mov    %eax,%ebx
   12eee:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ef1:	01 d8                	add    %ebx,%eax
   12ef3:	0f b6 00             	movzbl (%eax),%eax
   12ef6:	29 c1                	sub    %eax,%ecx
   12ef8:	89 c8                	mov    %ecx,%eax
   12efa:	88 02                	mov    %al,(%edx)
   12efc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12f00:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12f03:	3b 45 14             	cmp    0x14(%ebp),%eax
   12f06:	7c cb                	jl     12ed3 <filterScanline+0x325>
      }
      break;
   12f08:	eb 01                	jmp    12f0b <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   12f0a:	90                   	nop
  }
}
   12f0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   12f0e:	5b                   	pop    %ebx
   12f0f:	5e                   	pop    %esi
   12f10:	5d                   	pop    %ebp
   12f11:	c3                   	ret    

00012f12 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   12f12:	55                   	push   %ebp
   12f13:	89 e5                	mov    %esp,%ebp
   12f15:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   12f18:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   12f1f:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   12f26:	7e 08                	jle    12f30 <ilog2+0x1e>
   12f28:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   12f2c:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   12f30:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   12f37:	7e 08                	jle    12f41 <ilog2+0x2f>
   12f39:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   12f3d:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   12f41:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   12f45:	7e 08                	jle    12f4f <ilog2+0x3d>
   12f47:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   12f4b:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   12f4f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   12f53:	7e 08                	jle    12f5d <ilog2+0x4b>
   12f55:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   12f59:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   12f5d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   12f61:	7e 04                	jle    12f67 <ilog2+0x55>
   12f63:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   12f67:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12f6a:	c9                   	leave  
   12f6b:	c3                   	ret    

00012f6c <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   12f6c:	55                   	push   %ebp
   12f6d:	89 e5                	mov    %esp,%ebp
   12f6f:	56                   	push   %esi
   12f70:	53                   	push   %ebx
   12f71:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   12f74:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   12f78:	75 07                	jne    12f81 <ilog2i+0x15>
   12f7a:	b8 00 00 00 00       	mov    $0x0,%eax
   12f7f:	eb 30                	jmp    12fb1 <ilog2i+0x45>
  l = ilog2(i);
   12f81:	ff 75 08             	pushl  0x8(%ebp)
   12f84:	e8 89 ff ff ff       	call   12f12 <ilog2>
   12f89:	83 c4 04             	add    $0x4,%esp
   12f8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   12f8f:	8b 45 08             	mov    0x8(%ebp),%eax
   12f92:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12f96:	89 c3                	mov    %eax,%ebx
   12f98:	8b 55 08             	mov    0x8(%ebp),%edx
   12f9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12f9e:	be 01 00 00 00       	mov    $0x1,%esi
   12fa3:	89 c1                	mov    %eax,%ecx
   12fa5:	d3 e6                	shl    %cl,%esi
   12fa7:	89 f0                	mov    %esi,%eax
   12fa9:	29 c2                	sub    %eax,%edx
   12fab:	89 d0                	mov    %edx,%eax
   12fad:	01 c0                	add    %eax,%eax
   12faf:	01 d8                	add    %ebx,%eax
}
   12fb1:	8d 65 f8             	lea    -0x8(%ebp),%esp
   12fb4:	5b                   	pop    %ebx
   12fb5:	5e                   	pop    %esi
   12fb6:	5d                   	pop    %ebp
   12fb7:	c3                   	ret    

00012fb8 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   12fb8:	55                   	push   %ebp
   12fb9:	89 e5                	mov    %esp,%ebp
   12fbb:	53                   	push   %ebx
   12fbc:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   12fc2:	ff 75 18             	pushl  0x18(%ebp)
   12fc5:	e8 6a 75 ff ff       	call   a534 <lodepng_get_bpp>
   12fca:	83 c4 04             	add    $0x4,%esp
   12fcd:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   12fd0:	ff 75 b8             	pushl  -0x48(%ebp)
   12fd3:	6a 01                	push   $0x1
   12fd5:	ff 75 10             	pushl  0x10(%ebp)
   12fd8:	e8 b6 76 ff ff       	call   a693 <lodepng_get_raw_size_idat>
   12fdd:	83 c4 0c             	add    $0xc,%esp
   12fe0:	83 e8 01             	sub    $0x1,%eax
   12fe3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   12fe6:	8b 45 b8             	mov    -0x48(%ebp),%eax
   12fe9:	83 c0 07             	add    $0x7,%eax
   12fec:	c1 e8 03             	shr    $0x3,%eax
   12fef:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   12ff2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   12ff9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   13000:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13003:	8b 40 2c             	mov    0x2c(%eax),%eax
   13006:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   13009:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1300c:	8b 40 28             	mov    0x28(%eax),%eax
   1300f:	85 c0                	test   %eax,%eax
   13011:	74 1c                	je     1302f <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   13013:	8b 45 18             	mov    0x18(%ebp),%eax
   13016:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   13018:	83 f8 03             	cmp    $0x3,%eax
   1301b:	74 0b                	je     13028 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   1301d:	8b 45 18             	mov    0x18(%ebp),%eax
   13020:	8b 40 04             	mov    0x4(%eax),%eax
   13023:	83 f8 07             	cmp    $0x7,%eax
   13026:	77 07                	ja     1302f <filter+0x77>
   13028:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   1302f:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   13033:	75 0a                	jne    1303f <filter+0x87>
   13035:	b8 1f 00 00 00       	mov    $0x1f,%eax
   1303a:	e9 5b 07 00 00       	jmp    1379a <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   1303f:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   13043:	77 7b                	ja     130c0 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   13045:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13048:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   1304b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   13052:	eb 5f                	jmp    130b3 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   13054:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13057:	83 c0 01             	add    $0x1,%eax
   1305a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1305e:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   13061:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13064:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13068:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   1306b:	8b 55 9c             	mov    -0x64(%ebp),%edx
   1306e:	8b 45 08             	mov    0x8(%ebp),%eax
   13071:	01 c2                	add    %eax,%edx
   13073:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   13077:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   13079:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   1307d:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   13080:	8b 55 0c             	mov    0xc(%ebp),%edx
   13083:	01 d1                	add    %edx,%ecx
   13085:	8b 55 9c             	mov    -0x64(%ebp),%edx
   13088:	8d 5a 01             	lea    0x1(%edx),%ebx
   1308b:	8b 55 08             	mov    0x8(%ebp),%edx
   1308e:	01 da                	add    %ebx,%edx
   13090:	50                   	push   %eax
   13091:	ff 75 b0             	pushl  -0x50(%ebp)
   13094:	ff 75 b4             	pushl  -0x4c(%ebp)
   13097:	ff 75 f4             	pushl  -0xc(%ebp)
   1309a:	51                   	push   %ecx
   1309b:	52                   	push   %edx
   1309c:	e8 0d fb ff ff       	call   12bae <filterScanline>
   130a1:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   130a4:	8b 55 98             	mov    -0x68(%ebp),%edx
   130a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   130aa:	01 d0                	add    %edx,%eax
   130ac:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   130af:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   130b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   130b6:	3b 45 14             	cmp    0x14(%ebp),%eax
   130b9:	75 99                	jne    13054 <filter+0x9c>
   130bb:	e9 d7 06 00 00       	jmp    13797 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   130c0:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   130c4:	0f 85 e3 01 00 00    	jne    132ad <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   130ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   130d1:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   130d5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   130d9:	eb 2d                	jmp    13108 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   130db:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   130df:	83 ec 0c             	sub    $0xc,%esp
   130e2:	ff 75 b4             	pushl  -0x4c(%ebp)
   130e5:	e8 2e 19 ff ff       	call   4a18 <lodepng_malloc>
   130ea:	83 c4 10             	add    $0x10,%esp
   130ed:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   130f1:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   130f5:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   130f9:	85 c0                	test   %eax,%eax
   130fb:	75 07                	jne    13104 <filter+0x14c>
   130fd:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   13104:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   13108:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   1310c:	75 cd                	jne    130db <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   1310e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   13112:	0f 85 6c 01 00 00    	jne    13284 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   13118:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1311f:	e9 54 01 00 00       	jmp    13278 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   13124:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   13128:	e9 d5 00 00 00       	jmp    13202 <filter+0x24a>
          size_t sum = 0;
   1312d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   13134:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   13138:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1313b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1313f:	89 c1                	mov    %eax,%ecx
   13141:	8b 45 0c             	mov    0xc(%ebp),%eax
   13144:	01 c1                	add    %eax,%ecx
   13146:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1314a:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   1314e:	83 ec 08             	sub    $0x8,%esp
   13151:	52                   	push   %edx
   13152:	ff 75 b0             	pushl  -0x50(%ebp)
   13155:	ff 75 b4             	pushl  -0x4c(%ebp)
   13158:	ff 75 f4             	pushl  -0xc(%ebp)
   1315b:	51                   	push   %ecx
   1315c:	50                   	push   %eax
   1315d:	e8 4c fa ff ff       	call   12bae <filterScanline>
   13162:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   13165:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   13169:	75 2d                	jne    13198 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   1316b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13172:	eb 1a                	jmp    1318e <filter+0x1d6>
   13174:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   13178:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   1317c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1317f:	01 d0                	add    %edx,%eax
   13181:	0f b6 00             	movzbl (%eax),%eax
   13184:	0f b6 c0             	movzbl %al,%eax
   13187:	01 45 d8             	add    %eax,-0x28(%ebp)
   1318a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1318e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13191:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   13194:	75 de                	jne    13174 <filter+0x1bc>
   13196:	eb 4b                	jmp    131e3 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   13198:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1319f:	eb 3a                	jmp    131db <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   131a1:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   131a5:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   131a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131ac:	01 d0                	add    %edx,%eax
   131ae:	0f b6 00             	movzbl (%eax),%eax
   131b1:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   131b4:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   131b8:	84 c0                	test   %al,%al
   131ba:	78 06                	js     131c2 <filter+0x20a>
   131bc:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   131c0:	eb 0d                	jmp    131cf <filter+0x217>
   131c2:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   131c6:	ba ff 00 00 00       	mov    $0xff,%edx
   131cb:	29 c2                	sub    %eax,%edx
   131cd:	89 d0                	mov    %edx,%eax
   131cf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   131d2:	01 d0                	add    %edx,%eax
   131d4:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   131d7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   131db:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   131de:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   131e1:	75 be                	jne    131a1 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   131e3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   131e7:	74 08                	je     131f1 <filter+0x239>
   131e9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   131ec:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   131ef:	7d 0d                	jge    131fe <filter+0x246>
            bestType = type;
   131f1:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   131f5:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   131f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   131fb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   131fe:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   13202:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   13206:	0f 85 21 ff ff ff    	jne    1312d <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   1320c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1320f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13213:	89 c2                	mov    %eax,%edx
   13215:	8b 45 0c             	mov    0xc(%ebp),%eax
   13218:	01 d0                	add    %edx,%eax
   1321a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   1321d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13220:	83 c0 01             	add    $0x1,%eax
   13223:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13227:	89 c2                	mov    %eax,%edx
   13229:	8b 45 08             	mov    0x8(%ebp),%eax
   1322c:	01 c2                	add    %eax,%edx
   1322e:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   13232:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   13234:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1323b:	eb 2f                	jmp    1326c <filter+0x2b4>
   1323d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13240:	83 c0 01             	add    $0x1,%eax
   13243:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13247:	89 c2                	mov    %eax,%edx
   13249:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1324c:	01 d0                	add    %edx,%eax
   1324e:	8d 50 01             	lea    0x1(%eax),%edx
   13251:	8b 45 08             	mov    0x8(%ebp),%eax
   13254:	01 c2                	add    %eax,%edx
   13256:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   1325a:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   1325e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13261:	01 c8                	add    %ecx,%eax
   13263:	0f b6 00             	movzbl (%eax),%eax
   13266:	88 02                	mov    %al,(%edx)
   13268:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1326c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1326f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   13272:	75 c9                	jne    1323d <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   13274:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   13278:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1327b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1327e:	0f 85 a0 fe ff ff    	jne    13124 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   13284:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   13288:	eb 18                	jmp    132a2 <filter+0x2ea>
   1328a:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1328e:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   13292:	83 ec 0c             	sub    $0xc,%esp
   13295:	50                   	push   %eax
   13296:	e8 9e 17 ff ff       	call   4a39 <lodepng_free>
   1329b:	83 c4 10             	add    $0x10,%esp
   1329e:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   132a2:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   132a6:	75 e2                	jne    1328a <filter+0x2d2>
   132a8:	e9 ea 04 00 00       	jmp    13797 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   132ad:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   132b1:	0f 85 17 02 00 00    	jne    134ce <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   132b7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   132be:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   132c5:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   132cc:	eb 33                	jmp    13301 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   132ce:	83 ec 0c             	sub    $0xc,%esp
   132d1:	ff 75 b4             	pushl  -0x4c(%ebp)
   132d4:	e8 3f 17 ff ff       	call   4a18 <lodepng_malloc>
   132d9:	83 c4 10             	add    $0x10,%esp
   132dc:	89 c2                	mov    %eax,%edx
   132de:	8b 45 d0             	mov    -0x30(%ebp),%eax
   132e1:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   132e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   132eb:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   132f2:	85 c0                	test   %eax,%eax
   132f4:	75 07                	jne    132fd <filter+0x345>
   132f6:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   132fd:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   13301:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   13305:	75 c7                	jne    132ce <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   13307:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1330b:	0f 85 8f 01 00 00    	jne    134a0 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   13311:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   13318:	e9 77 01 00 00       	jmp    13494 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   1331d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   13324:	e9 f4 00 00 00       	jmp    1341d <filter+0x465>
          size_t sum = 0;
   13329:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   13330:	8b 45 d0             	mov    -0x30(%ebp),%eax
   13333:	0f b6 d0             	movzbl %al,%edx
   13336:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13339:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1333d:	89 c1                	mov    %eax,%ecx
   1333f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13342:	01 c1                	add    %eax,%ecx
   13344:	8b 45 d0             	mov    -0x30(%ebp),%eax
   13347:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   1334e:	83 ec 08             	sub    $0x8,%esp
   13351:	52                   	push   %edx
   13352:	ff 75 b0             	pushl  -0x50(%ebp)
   13355:	ff 75 b4             	pushl  -0x4c(%ebp)
   13358:	ff 75 f4             	pushl  -0xc(%ebp)
   1335b:	51                   	push   %ecx
   1335c:	50                   	push   %eax
   1335d:	e8 4c f8 ff ff       	call   12bae <filterScanline>
   13362:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   13365:	83 ec 04             	sub    $0x4,%esp
   13368:	68 00 04 00 00       	push   $0x400
   1336d:	6a 00                	push   $0x0
   1336f:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   13375:	50                   	push   %eax
   13376:	e8 0e 17 ff ff       	call   4a89 <lodepng_memset>
   1337b:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   1337e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13385:	eb 2a                	jmp    133b1 <filter+0x3f9>
   13387:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1338a:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   13391:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13394:	01 d0                	add    %edx,%eax
   13396:	0f b6 00             	movzbl (%eax),%eax
   13399:	0f b6 c0             	movzbl %al,%eax
   1339c:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   133a3:	83 c2 01             	add    $0x1,%edx
   133a6:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   133ad:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   133b1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   133b4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   133b7:	75 ce                	jne    13387 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   133b9:	8b 45 d0             	mov    -0x30(%ebp),%eax
   133bc:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   133c3:	8d 50 01             	lea    0x1(%eax),%edx
   133c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
   133c9:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   133d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   133d7:	eb 1d                	jmp    133f6 <filter+0x43e>
            sum += ilog2i(count[x]);
   133d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   133dc:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   133e3:	83 ec 0c             	sub    $0xc,%esp
   133e6:	50                   	push   %eax
   133e7:	e8 80 fb ff ff       	call   12f6c <ilog2i>
   133ec:	83 c4 10             	add    $0x10,%esp
   133ef:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   133f2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   133f6:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   133fd:	75 da                	jne    133d9 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   133ff:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   13403:	74 08                	je     1340d <filter+0x455>
   13405:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13408:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   1340b:	7e 0c                	jle    13419 <filter+0x461>
            bestType = type;
   1340d:	8b 45 d0             	mov    -0x30(%ebp),%eax
   13410:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   13413:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13416:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   13419:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   1341d:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   13421:	0f 85 02 ff ff ff    	jne    13329 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   13427:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1342a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1342e:	89 c2                	mov    %eax,%edx
   13430:	8b 45 0c             	mov    0xc(%ebp),%eax
   13433:	01 d0                	add    %edx,%eax
   13435:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   13438:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1343b:	83 c0 01             	add    $0x1,%eax
   1343e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13442:	89 c2                	mov    %eax,%edx
   13444:	8b 45 08             	mov    0x8(%ebp),%eax
   13447:	01 d0                	add    %edx,%eax
   13449:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1344c:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1344e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13455:	eb 31                	jmp    13488 <filter+0x4d0>
   13457:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1345a:	83 c0 01             	add    $0x1,%eax
   1345d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13461:	89 c2                	mov    %eax,%edx
   13463:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13466:	01 d0                	add    %edx,%eax
   13468:	8d 50 01             	lea    0x1(%eax),%edx
   1346b:	8b 45 08             	mov    0x8(%ebp),%eax
   1346e:	01 c2                	add    %eax,%edx
   13470:	8b 45 cc             	mov    -0x34(%ebp),%eax
   13473:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   1347a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1347d:	01 c8                	add    %ecx,%eax
   1347f:	0f b6 00             	movzbl (%eax),%eax
   13482:	88 02                	mov    %al,(%edx)
   13484:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13488:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1348b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1348e:	75 c7                	jne    13457 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   13490:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   13494:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13497:	3b 45 14             	cmp    0x14(%ebp),%eax
   1349a:	0f 85 7d fe ff ff    	jne    1331d <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   134a0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   134a7:	eb 1a                	jmp    134c3 <filter+0x50b>
   134a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
   134ac:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   134b3:	83 ec 0c             	sub    $0xc,%esp
   134b6:	50                   	push   %eax
   134b7:	e8 7d 15 ff ff       	call   4a39 <lodepng_free>
   134bc:	83 c4 10             	add    $0x10,%esp
   134bf:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   134c3:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   134c7:	75 e0                	jne    134a9 <filter+0x4f1>
   134c9:	e9 c9 02 00 00       	jmp    13797 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   134ce:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   134d2:	0f 85 89 00 00 00    	jne    13561 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   134d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   134df:	eb 73                	jmp    13554 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   134e1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   134e4:	83 c0 01             	add    $0x1,%eax
   134e7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   134eb:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   134ee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   134f1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   134f5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   134f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134fb:	8b 50 30             	mov    0x30(%eax),%edx
   134fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13501:	01 d0                	add    %edx,%eax
   13503:	0f b6 00             	movzbl (%eax),%eax
   13506:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   13509:	8b 55 a8             	mov    -0x58(%ebp),%edx
   1350c:	8b 45 08             	mov    0x8(%ebp),%eax
   1350f:	01 c2                	add    %eax,%edx
   13511:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   13515:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   13517:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   1351b:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   1351e:	8b 55 0c             	mov    0xc(%ebp),%edx
   13521:	01 d1                	add    %edx,%ecx
   13523:	8b 55 a8             	mov    -0x58(%ebp),%edx
   13526:	8d 5a 01             	lea    0x1(%edx),%ebx
   13529:	8b 55 08             	mov    0x8(%ebp),%edx
   1352c:	01 da                	add    %ebx,%edx
   1352e:	83 ec 08             	sub    $0x8,%esp
   13531:	50                   	push   %eax
   13532:	ff 75 b0             	pushl  -0x50(%ebp)
   13535:	ff 75 b4             	pushl  -0x4c(%ebp)
   13538:	ff 75 f4             	pushl  -0xc(%ebp)
   1353b:	51                   	push   %ecx
   1353c:	52                   	push   %edx
   1353d:	e8 6c f6 ff ff       	call   12bae <filterScanline>
   13542:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   13545:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   13548:	8b 45 0c             	mov    0xc(%ebp),%eax
   1354b:	01 d0                	add    %edx,%eax
   1354d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   13550:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   13554:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13557:	3b 45 14             	cmp    0x14(%ebp),%eax
   1355a:	75 85                	jne    134e1 <filter+0x529>
   1355c:	e9 36 02 00 00       	jmp    13797 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   13561:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   13565:	0f 85 25 02 00 00    	jne    13790 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   1356b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   13572:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   13579:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   13580:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13583:	83 ec 04             	sub    $0x4,%esp
   13586:	6a 24                	push   $0x24
   13588:	50                   	push   %eax
   13589:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   1358f:	50                   	push   %eax
   13590:	e8 c1 14 ff ff       	call   4a56 <lodepng_memcpy>
   13595:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   13598:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   1359f:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   135a2:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   135a9:	00 00 00 
    zlibsettings.custom_deflate = 0;
   135ac:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   135b3:	00 00 00 
    for(type = 0; type != 5; ++type) {
   135b6:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   135bd:	eb 33                	jmp    135f2 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   135bf:	83 ec 0c             	sub    $0xc,%esp
   135c2:	ff 75 b4             	pushl  -0x4c(%ebp)
   135c5:	e8 4e 14 ff ff       	call   4a18 <lodepng_malloc>
   135ca:	83 c4 10             	add    $0x10,%esp
   135cd:	89 c2                	mov    %eax,%edx
   135cf:	8b 45 c0             	mov    -0x40(%ebp),%eax
   135d2:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   135d9:	8b 45 c0             	mov    -0x40(%ebp),%eax
   135dc:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   135e3:	85 c0                	test   %eax,%eax
   135e5:	75 07                	jne    135ee <filter+0x636>
   135e7:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   135ee:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   135f2:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   135f6:	75 c7                	jne    135bf <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   135f8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   135fc:	0f 85 63 01 00 00    	jne    13765 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   13602:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   13609:	e9 4b 01 00 00       	jmp    13759 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   1360e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   13615:	e9 c8 00 00 00       	jmp    136e2 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   1361a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1361d:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   13620:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13623:	0f b6 d0             	movzbl %al,%edx
   13626:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13629:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1362d:	89 c1                	mov    %eax,%ecx
   1362f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13632:	01 c1                	add    %eax,%ecx
   13634:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13637:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1363e:	83 ec 08             	sub    $0x8,%esp
   13641:	52                   	push   %edx
   13642:	ff 75 b0             	pushl  -0x50(%ebp)
   13645:	ff 75 b4             	pushl  -0x4c(%ebp)
   13648:	ff 75 f4             	pushl  -0xc(%ebp)
   1364b:	51                   	push   %ecx
   1364c:	50                   	push   %eax
   1364d:	e8 5c f5 ff ff       	call   12bae <filterScanline>
   13652:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   13655:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13658:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   1365f:	00 00 00 00 
          dummy = 0;
   13663:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   1366a:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   1366d:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13670:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13673:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1367a:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   13680:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   13683:	c1 e3 02             	shl    $0x2,%ebx
   13686:	01 cb                	add    %ecx,%ebx
   13688:	83 ec 0c             	sub    $0xc,%esp
   1368b:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   13691:	51                   	push   %ecx
   13692:	52                   	push   %edx
   13693:	50                   	push   %eax
   13694:	53                   	push   %ebx
   13695:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   1369b:	50                   	push   %eax
   1369c:	e8 87 60 ff ff       	call   9728 <zlib_compress>
   136a1:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   136a4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   136aa:	83 ec 0c             	sub    $0xc,%esp
   136ad:	50                   	push   %eax
   136ae:	e8 86 13 ff ff       	call   4a39 <lodepng_free>
   136b3:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   136b6:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   136ba:	74 0f                	je     136cb <filter+0x713>
   136bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   136bf:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   136c6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   136c9:	7d 13                	jge    136de <filter+0x726>
            bestType = type;
   136cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
   136ce:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   136d1:	8b 45 c0             	mov    -0x40(%ebp),%eax
   136d4:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   136db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   136de:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   136e2:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   136e6:	0f 85 2e ff ff ff    	jne    1361a <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   136ec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   136ef:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   136f3:	89 c2                	mov    %eax,%edx
   136f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   136f8:	01 d0                	add    %edx,%eax
   136fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   136fd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13700:	83 c0 01             	add    $0x1,%eax
   13703:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13707:	89 c2                	mov    %eax,%edx
   13709:	8b 45 08             	mov    0x8(%ebp),%eax
   1370c:	01 d0                	add    %edx,%eax
   1370e:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13711:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   13713:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1371a:	eb 31                	jmp    1374d <filter+0x795>
   1371c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1371f:	83 c0 01             	add    $0x1,%eax
   13722:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13726:	89 c2                	mov    %eax,%edx
   13728:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1372b:	01 d0                	add    %edx,%eax
   1372d:	8d 50 01             	lea    0x1(%eax),%edx
   13730:	8b 45 08             	mov    0x8(%ebp),%eax
   13733:	01 c2                	add    %eax,%edx
   13735:	8b 45 bc             	mov    -0x44(%ebp),%eax
   13738:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   1373f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13742:	01 c8                	add    %ecx,%eax
   13744:	0f b6 00             	movzbl (%eax),%eax
   13747:	88 02                	mov    %al,(%edx)
   13749:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1374d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13750:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   13753:	75 c7                	jne    1371c <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   13755:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   13759:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1375c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1375f:	0f 85 a9 fe ff ff    	jne    1360e <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   13765:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1376c:	eb 1a                	jmp    13788 <filter+0x7d0>
   1376e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13771:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   13778:	83 ec 0c             	sub    $0xc,%esp
   1377b:	50                   	push   %eax
   1377c:	e8 b8 12 ff ff       	call   4a39 <lodepng_free>
   13781:	83 c4 10             	add    $0x10,%esp
   13784:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   13788:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1378c:	75 e0                	jne    1376e <filter+0x7b6>
   1378e:	eb 07                	jmp    13797 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   13790:	b8 58 00 00 00       	mov    $0x58,%eax
   13795:	eb 03                	jmp    1379a <filter+0x7e2>

  return error;
   13797:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   1379a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1379d:	c9                   	leave  
   1379e:	c3                   	ret    

0001379f <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   1379f:	55                   	push   %ebp
   137a0:	89 e5                	mov    %esp,%ebp
   137a2:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   137a5:	8b 45 10             	mov    0x10(%ebp),%eax
   137a8:	2b 45 14             	sub    0x14(%ebp),%eax
   137ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   137ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   137b5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   137bc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   137c3:	eb 65                	jmp    1382a <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   137c5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   137cc:	eb 2a                	jmp    137f8 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   137ce:	ff 75 0c             	pushl  0xc(%ebp)
   137d1:	8d 45 e8             	lea    -0x18(%ebp),%eax
   137d4:	50                   	push   %eax
   137d5:	e8 9d 60 ff ff       	call   9877 <readBitFromReversedStream>
   137da:	83 c4 08             	add    $0x8,%esp
   137dd:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   137e0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   137e4:	50                   	push   %eax
   137e5:	ff 75 08             	pushl  0x8(%ebp)
   137e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
   137eb:	50                   	push   %eax
   137ec:	e8 08 61 ff ff       	call   98f9 <setBitOfReversedStream>
   137f1:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   137f4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   137f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   137fb:	3b 45 14             	cmp    0x14(%ebp),%eax
   137fe:	7c ce                	jl     137ce <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   13800:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13807:	eb 15                	jmp    1381e <addPaddingBits+0x7f>
   13809:	6a 00                	push   $0x0
   1380b:	ff 75 08             	pushl  0x8(%ebp)
   1380e:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13811:	50                   	push   %eax
   13812:	e8 e2 60 ff ff       	call   98f9 <setBitOfReversedStream>
   13817:	83 c4 0c             	add    $0xc,%esp
   1381a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1381e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13821:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   13824:	75 e3                	jne    13809 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   13826:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1382a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1382d:	3b 45 18             	cmp    0x18(%ebp),%eax
   13830:	75 93                	jne    137c5 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   13832:	90                   	nop
   13833:	c9                   	leave  
   13834:	c3                   	ret    

00013835 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   13835:	55                   	push   %ebp
   13836:	89 e5                	mov    %esp,%ebp
   13838:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1383e:	ff 75 18             	pushl  0x18(%ebp)
   13841:	ff 75 14             	pushl  0x14(%ebp)
   13844:	ff 75 10             	pushl  0x10(%ebp)
   13847:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   1384d:	50                   	push   %eax
   1384e:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   13854:	50                   	push   %eax
   13855:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   1385b:	50                   	push   %eax
   1385c:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1385f:	50                   	push   %eax
   13860:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13863:	50                   	push   %eax
   13864:	e8 fc ae ff ff       	call   e765 <Adam7_getpassvalues>
   13869:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   1386c:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   13870:	0f 86 0a 01 00 00    	jbe    13980 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   13876:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1387d:	e9 ef 00 00 00       	jmp    13971 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   13882:	8b 45 18             	mov    0x18(%ebp),%eax
   13885:	c1 e8 03             	shr    $0x3,%eax
   13888:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   1388b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13892:	e9 c6 00 00 00       	jmp    1395d <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   13897:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1389e:	e9 a6 00 00 00       	jmp    13949 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   138a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138a6:	8b 14 85 d8 b6 01 00 	mov    0x1b6d8(,%eax,4),%edx
   138ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138b0:	8b 04 85 10 b7 01 00 	mov    0x1b710(,%eax,4),%eax
   138b7:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   138bb:	01 d0                	add    %edx,%eax
   138bd:	0f af 45 10          	imul   0x10(%ebp),%eax
   138c1:	89 c2                	mov    %eax,%edx
   138c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138c6:	8b 04 85 f4 b6 01 00 	mov    0x1b6f4(,%eax,4),%eax
   138cd:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   138d1:	01 c2                	add    %eax,%edx
   138d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138d6:	8b 04 85 bc b6 01 00 	mov    0x1b6bc(,%eax,4),%eax
   138dd:	01 c2                	add    %eax,%edx
   138df:	8b 45 e0             	mov    -0x20(%ebp),%eax
   138e2:	0f af c2             	imul   %edx,%eax
   138e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   138e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138eb:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   138f2:	89 c1                	mov    %eax,%ecx
   138f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138f7:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   138fb:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   138ff:	89 c2                	mov    %eax,%edx
   13901:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13904:	01 c2                	add    %eax,%edx
   13906:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13909:	0f af c2             	imul   %edx,%eax
   1390c:	01 c8                	add    %ecx,%eax
   1390e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   13911:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13918:	eb 23                	jmp    1393d <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   1391a:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1391d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13920:	01 c2                	add    %eax,%edx
   13922:	8b 45 08             	mov    0x8(%ebp),%eax
   13925:	01 c2                	add    %eax,%edx
   13927:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1392a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1392d:	01 c1                	add    %eax,%ecx
   1392f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13932:	01 c8                	add    %ecx,%eax
   13934:	0f b6 00             	movzbl (%eax),%eax
   13937:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   13939:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1393d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13940:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   13943:	72 d5                	jb     1391a <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   13945:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   13949:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1394c:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   13950:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   13953:	0f 87 4a ff ff ff    	ja     138a3 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   13959:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1395d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13960:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   13964:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   13967:	0f 87 2a ff ff ff    	ja     13897 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   1396d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13971:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   13975:	0f 85 07 ff ff ff    	jne    13882 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1397b:	e9 22 01 00 00       	jmp    13aa2 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   13980:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13987:	e9 0c 01 00 00       	jmp    13a98 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   1398c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1398f:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   13993:	0f af 45 18          	imul   0x18(%ebp),%eax
   13997:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   1399a:	8b 45 18             	mov    0x18(%ebp),%eax
   1399d:	0f af 45 10          	imul   0x10(%ebp),%eax
   139a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   139a4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   139ab:	e9 d4 00 00 00       	jmp    13a84 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   139b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   139b7:	e9 b4 00 00 00       	jmp    13a70 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   139bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139bf:	8b 14 85 d8 b6 01 00 	mov    0x1b6d8(,%eax,4),%edx
   139c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139c9:	8b 04 85 10 b7 01 00 	mov    0x1b710(,%eax,4),%eax
   139d0:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   139d4:	01 d0                	add    %edx,%eax
   139d6:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   139da:	89 c2                	mov    %eax,%edx
   139dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139df:	8b 0c 85 bc b6 01 00 	mov    0x1b6bc(,%eax,4),%ecx
   139e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139e9:	8b 04 85 f4 b6 01 00 	mov    0x1b6f4(,%eax,4),%eax
   139f0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   139f4:	01 c8                	add    %ecx,%eax
   139f6:	0f af 45 18          	imul   0x18(%ebp),%eax
   139fa:	01 d0                	add    %edx,%eax
   139fc:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   13a02:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13a05:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   13a0c:	c1 e0 03             	shl    $0x3,%eax
   13a0f:	89 c1                	mov    %eax,%ecx
   13a11:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13a14:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   13a18:	89 c2                	mov    %eax,%edx
   13a1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13a1d:	0f af 45 18          	imul   0x18(%ebp),%eax
   13a21:	01 d0                	add    %edx,%eax
   13a23:	01 c8                	add    %ecx,%eax
   13a25:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   13a2b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13a32:	eb 30                	jmp    13a64 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   13a34:	ff 75 0c             	pushl  0xc(%ebp)
   13a37:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   13a3d:	50                   	push   %eax
   13a3e:	e8 34 5e ff ff       	call   9877 <readBitFromReversedStream>
   13a43:	83 c4 08             	add    $0x8,%esp
   13a46:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   13a49:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   13a4d:	50                   	push   %eax
   13a4e:	ff 75 08             	pushl  0x8(%ebp)
   13a51:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   13a57:	50                   	push   %eax
   13a58:	e8 9c 5e ff ff       	call   98f9 <setBitOfReversedStream>
   13a5d:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   13a60:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13a64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13a67:	3b 45 18             	cmp    0x18(%ebp),%eax
   13a6a:	72 c8                	jb     13a34 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   13a6c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   13a70:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13a73:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   13a77:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   13a7a:	0f 87 3c ff ff ff    	ja     139bc <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   13a80:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   13a84:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13a87:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   13a8b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   13a8e:	0f 87 1c ff ff ff    	ja     139b0 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   13a94:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13a98:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   13a9c:	0f 85 ea fe ff ff    	jne    1398c <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   13aa2:	90                   	nop
   13aa3:	c9                   	leave  
   13aa4:	c3                   	ret    

00013aa5 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   13aa5:	55                   	push   %ebp
   13aa6:	89 e5                	mov    %esp,%ebp
   13aa8:	57                   	push   %edi
   13aa9:	56                   	push   %esi
   13aaa:	53                   	push   %ebx
   13aab:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   13ab1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ab4:	83 c0 0c             	add    $0xc,%eax
   13ab7:	50                   	push   %eax
   13ab8:	e8 77 6a ff ff       	call   a534 <lodepng_get_bpp>
   13abd:	83 c4 04             	add    $0x4,%esp
   13ac0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   13ac3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   13aca:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13acd:	8b 40 08             	mov    0x8(%eax),%eax
   13ad0:	85 c0                	test   %eax,%eax
   13ad2:	0f 85 49 01 00 00    	jne    13c21 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   13ad8:	8b 45 14             	mov    0x14(%ebp),%eax
   13adb:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13adf:	83 c0 07             	add    $0x7,%eax
   13ae2:	c1 e8 03             	shr    $0x3,%eax
   13ae5:	83 c0 01             	add    $0x1,%eax
   13ae8:	0f af 45 18          	imul   0x18(%ebp),%eax
   13aec:	89 c2                	mov    %eax,%edx
   13aee:	8b 45 0c             	mov    0xc(%ebp),%eax
   13af1:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   13af3:	8b 45 0c             	mov    0xc(%ebp),%eax
   13af6:	8b 00                	mov    (%eax),%eax
   13af8:	83 ec 0c             	sub    $0xc,%esp
   13afb:	50                   	push   %eax
   13afc:	e8 17 0f ff ff       	call   4a18 <lodepng_malloc>
   13b01:	83 c4 10             	add    $0x10,%esp
   13b04:	89 c2                	mov    %eax,%edx
   13b06:	8b 45 08             	mov    0x8(%ebp),%eax
   13b09:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   13b0b:	8b 45 08             	mov    0x8(%ebp),%eax
   13b0e:	8b 00                	mov    (%eax),%eax
   13b10:	85 c0                	test   %eax,%eax
   13b12:	75 10                	jne    13b24 <preProcessScanlines+0x7f>
   13b14:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b17:	8b 00                	mov    (%eax),%eax
   13b19:	85 c0                	test   %eax,%eax
   13b1b:	74 07                	je     13b24 <preProcessScanlines+0x7f>
   13b1d:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   13b24:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13b28:	0f 85 fb 02 00 00    	jne    13e29 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   13b2e:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   13b32:	0f 87 bd 00 00 00    	ja     13bf5 <preProcessScanlines+0x150>
   13b38:	8b 45 14             	mov    0x14(%ebp),%eax
   13b3b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13b3f:	89 c2                	mov    %eax,%edx
   13b41:	8b 45 14             	mov    0x14(%ebp),%eax
   13b44:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13b48:	83 c0 07             	add    $0x7,%eax
   13b4b:	c1 e8 03             	shr    $0x3,%eax
   13b4e:	c1 e0 03             	shl    $0x3,%eax
   13b51:	39 c2                	cmp    %eax,%edx
   13b53:	0f 84 9c 00 00 00    	je     13bf5 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   13b59:	8b 45 14             	mov    0x14(%ebp),%eax
   13b5c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13b60:	83 c0 07             	add    $0x7,%eax
   13b63:	c1 e8 03             	shr    $0x3,%eax
   13b66:	0f af 45 18          	imul   0x18(%ebp),%eax
   13b6a:	83 ec 0c             	sub    $0xc,%esp
   13b6d:	50                   	push   %eax
   13b6e:	e8 a5 0e ff ff       	call   4a18 <lodepng_malloc>
   13b73:	83 c4 10             	add    $0x10,%esp
   13b76:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   13b79:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   13b7d:	75 07                	jne    13b86 <preProcessScanlines+0xe1>
   13b7f:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   13b86:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13b8a:	75 56                	jne    13be2 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   13b8c:	8b 45 14             	mov    0x14(%ebp),%eax
   13b8f:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13b93:	89 c2                	mov    %eax,%edx
   13b95:	8b 45 14             	mov    0x14(%ebp),%eax
   13b98:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13b9c:	83 c0 07             	add    $0x7,%eax
   13b9f:	c1 e8 03             	shr    $0x3,%eax
   13ba2:	c1 e0 03             	shl    $0x3,%eax
   13ba5:	83 ec 0c             	sub    $0xc,%esp
   13ba8:	ff 75 18             	pushl  0x18(%ebp)
   13bab:	52                   	push   %edx
   13bac:	50                   	push   %eax
   13bad:	ff 75 10             	pushl  0x10(%ebp)
   13bb0:	ff 75 d8             	pushl  -0x28(%ebp)
   13bb3:	e8 e7 fb ff ff       	call   1379f <addPaddingBits>
   13bb8:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   13bbb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bbe:	8d 50 0c             	lea    0xc(%eax),%edx
   13bc1:	8b 45 08             	mov    0x8(%ebp),%eax
   13bc4:	8b 00                	mov    (%eax),%eax
   13bc6:	83 ec 08             	sub    $0x8,%esp
   13bc9:	ff 75 20             	pushl  0x20(%ebp)
   13bcc:	52                   	push   %edx
   13bcd:	ff 75 18             	pushl  0x18(%ebp)
   13bd0:	ff 75 14             	pushl  0x14(%ebp)
   13bd3:	ff 75 d8             	pushl  -0x28(%ebp)
   13bd6:	50                   	push   %eax
   13bd7:	e8 dc f3 ff ff       	call   12fb8 <filter>
   13bdc:	83 c4 20             	add    $0x20,%esp
   13bdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   13be2:	83 ec 0c             	sub    $0xc,%esp
   13be5:	ff 75 d8             	pushl  -0x28(%ebp)
   13be8:	e8 4c 0e ff ff       	call   4a39 <lodepng_free>
   13bed:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   13bf0:	e9 34 02 00 00       	jmp    13e29 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   13bf5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bf8:	8d 50 0c             	lea    0xc(%eax),%edx
   13bfb:	8b 45 08             	mov    0x8(%ebp),%eax
   13bfe:	8b 00                	mov    (%eax),%eax
   13c00:	83 ec 08             	sub    $0x8,%esp
   13c03:	ff 75 20             	pushl  0x20(%ebp)
   13c06:	52                   	push   %edx
   13c07:	ff 75 18             	pushl  0x18(%ebp)
   13c0a:	ff 75 14             	pushl  0x14(%ebp)
   13c0d:	ff 75 10             	pushl  0x10(%ebp)
   13c10:	50                   	push   %eax
   13c11:	e8 a2 f3 ff ff       	call   12fb8 <filter>
   13c16:	83 c4 20             	add    $0x20,%esp
   13c19:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   13c1c:	e9 08 02 00 00       	jmp    13e29 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   13c21:	ff 75 dc             	pushl  -0x24(%ebp)
   13c24:	ff 75 18             	pushl  0x18(%ebp)
   13c27:	ff 75 14             	pushl  0x14(%ebp)
   13c2a:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   13c30:	50                   	push   %eax
   13c31:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   13c37:	50                   	push   %eax
   13c38:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   13c3e:	50                   	push   %eax
   13c3f:	8d 45 98             	lea    -0x68(%ebp),%eax
   13c42:	50                   	push   %eax
   13c43:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   13c46:	50                   	push   %eax
   13c47:	e8 19 ab ff ff       	call   e765 <Adam7_getpassvalues>
   13c4c:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   13c4f:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   13c55:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c58:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   13c5a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c5d:	8b 00                	mov    (%eax),%eax
   13c5f:	83 ec 0c             	sub    $0xc,%esp
   13c62:	50                   	push   %eax
   13c63:	e8 b0 0d ff ff       	call   4a18 <lodepng_malloc>
   13c68:	83 c4 10             	add    $0x10,%esp
   13c6b:	89 c2                	mov    %eax,%edx
   13c6d:	8b 45 08             	mov    0x8(%ebp),%eax
   13c70:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   13c72:	8b 45 08             	mov    0x8(%ebp),%eax
   13c75:	8b 00                	mov    (%eax),%eax
   13c77:	85 c0                	test   %eax,%eax
   13c79:	75 07                	jne    13c82 <preProcessScanlines+0x1dd>
   13c7b:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   13c82:	8b 45 94             	mov    -0x6c(%ebp),%eax
   13c85:	83 ec 0c             	sub    $0xc,%esp
   13c88:	50                   	push   %eax
   13c89:	e8 8a 0d ff ff       	call   4a18 <lodepng_malloc>
   13c8e:	83 c4 10             	add    $0x10,%esp
   13c91:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   13c94:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   13c98:	75 0e                	jne    13ca8 <preProcessScanlines+0x203>
   13c9a:	8b 45 94             	mov    -0x6c(%ebp),%eax
   13c9d:	85 c0                	test   %eax,%eax
   13c9f:	74 07                	je     13ca8 <preProcessScanlines+0x203>
   13ca1:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   13ca8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13cac:	0f 85 69 01 00 00    	jne    13e1b <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   13cb2:	83 ec 0c             	sub    $0xc,%esp
   13cb5:	ff 75 dc             	pushl  -0x24(%ebp)
   13cb8:	ff 75 18             	pushl  0x18(%ebp)
   13cbb:	ff 75 14             	pushl  0x14(%ebp)
   13cbe:	ff 75 10             	pushl  0x10(%ebp)
   13cc1:	ff 75 d4             	pushl  -0x2c(%ebp)
   13cc4:	e8 6c fb ff ff       	call   13835 <Adam7_interlace>
   13cc9:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   13ccc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   13cd3:	e9 36 01 00 00       	jmp    13e0e <preProcessScanlines+0x369>
        if(bpp < 8) {
   13cd8:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   13cdc:	0f 87 d6 00 00 00    	ja     13db8 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   13ce2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13ce5:	83 c0 01             	add    $0x1,%eax
   13ce8:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   13cef:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13cf2:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   13cf9:	29 c2                	sub    %eax,%edx
   13cfb:	89 d0                	mov    %edx,%eax
   13cfd:	83 ec 0c             	sub    $0xc,%esp
   13d00:	50                   	push   %eax
   13d01:	e8 12 0d ff ff       	call   4a18 <lodepng_malloc>
   13d06:	83 c4 10             	add    $0x10,%esp
   13d09:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   13d0c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   13d10:	75 0c                	jne    13d1e <preProcessScanlines+0x279>
   13d12:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   13d19:	e9 fd 00 00 00       	jmp    13e1b <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   13d1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13d21:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   13d25:	8b 55 e0             	mov    -0x20(%ebp),%edx
   13d28:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   13d2c:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   13d30:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   13d32:	8b 55 e0             	mov    -0x20(%ebp),%edx
   13d35:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   13d39:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   13d3d:	83 c2 07             	add    $0x7,%edx
   13d40:	c1 ea 03             	shr    $0x3,%edx
   13d43:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   13d46:	89 d1                	mov    %edx,%ecx
   13d48:	8b 55 e0             	mov    -0x20(%ebp),%edx
   13d4b:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   13d52:	89 d6                	mov    %edx,%esi
   13d54:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   13d57:	01 f2                	add    %esi,%edx
   13d59:	83 ec 0c             	sub    $0xc,%esp
   13d5c:	50                   	push   %eax
   13d5d:	53                   	push   %ebx
   13d5e:	51                   	push   %ecx
   13d5f:	52                   	push   %edx
   13d60:	ff 75 d0             	pushl  -0x30(%ebp)
   13d63:	e8 37 fa ff ff       	call   1379f <addPaddingBits>
   13d68:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   13d6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d6e:	8d 58 0c             	lea    0xc(%eax),%ebx
   13d71:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13d74:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   13d78:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13d7b:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   13d7f:	8b 4d 08             	mov    0x8(%ebp),%ecx
   13d82:	8b 31                	mov    (%ecx),%esi
   13d84:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   13d87:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   13d8e:	01 f1                	add    %esi,%ecx
   13d90:	83 ec 08             	sub    $0x8,%esp
   13d93:	ff 75 20             	pushl  0x20(%ebp)
   13d96:	53                   	push   %ebx
   13d97:	52                   	push   %edx
   13d98:	50                   	push   %eax
   13d99:	ff 75 d0             	pushl  -0x30(%ebp)
   13d9c:	51                   	push   %ecx
   13d9d:	e8 16 f2 ff ff       	call   12fb8 <filter>
   13da2:	83 c4 20             	add    $0x20,%esp
   13da5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   13da8:	83 ec 0c             	sub    $0xc,%esp
   13dab:	ff 75 d0             	pushl  -0x30(%ebp)
   13dae:	e8 86 0c ff ff       	call   4a39 <lodepng_free>
   13db3:	83 c4 10             	add    $0x10,%esp
   13db6:	eb 4c                	jmp    13e04 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   13db8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13dbb:	8d 70 0c             	lea    0xc(%eax),%esi
   13dbe:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13dc1:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   13dc5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13dc8:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   13dcc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   13dcf:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   13dd6:	89 cb                	mov    %ecx,%ebx
   13dd8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   13ddb:	01 cb                	add    %ecx,%ebx
   13ddd:	8b 4d 08             	mov    0x8(%ebp),%ecx
   13de0:	8b 39                	mov    (%ecx),%edi
   13de2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   13de5:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   13dec:	01 f9                	add    %edi,%ecx
   13dee:	83 ec 08             	sub    $0x8,%esp
   13df1:	ff 75 20             	pushl  0x20(%ebp)
   13df4:	56                   	push   %esi
   13df5:	52                   	push   %edx
   13df6:	50                   	push   %eax
   13df7:	53                   	push   %ebx
   13df8:	51                   	push   %ecx
   13df9:	e8 ba f1 ff ff       	call   12fb8 <filter>
   13dfe:	83 c4 20             	add    $0x20,%esp
   13e01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   13e04:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13e08:	75 10                	jne    13e1a <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   13e0a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   13e0e:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   13e12:	0f 85 c0 fe ff ff    	jne    13cd8 <preProcessScanlines+0x233>
   13e18:	eb 01                	jmp    13e1b <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   13e1a:	90                   	nop
      }
    }

    lodepng_free(adam7);
   13e1b:	83 ec 0c             	sub    $0xc,%esp
   13e1e:	ff 75 d4             	pushl  -0x2c(%ebp)
   13e21:	e8 13 0c ff ff       	call   4a39 <lodepng_free>
   13e26:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   13e29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   13e2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13e2f:	5b                   	pop    %ebx
   13e30:	5e                   	pop    %esi
   13e31:	5f                   	pop    %edi
   13e32:	5d                   	pop    %ebp
   13e33:	c3                   	ret    

00013e34 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   13e34:	55                   	push   %ebp
   13e35:	89 e5                	mov    %esp,%ebp
   13e37:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   13e3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   13e40:	eb 47                	jmp    13e89 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   13e42:	8b 45 08             	mov    0x8(%ebp),%eax
   13e45:	8d 50 04             	lea    0x4(%eax),%edx
   13e48:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4b:	ff 75 fc             	pushl  -0x4(%ebp)
   13e4e:	52                   	push   %edx
   13e4f:	50                   	push   %eax
   13e50:	e8 73 5f ff ff       	call   9dc8 <lodepng_chunk_append>
   13e55:	83 c4 0c             	add    $0xc,%esp
   13e58:	89 45 f8             	mov    %eax,-0x8(%ebp)
   13e5b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   13e5f:	74 05                	je     13e66 <addUnknownChunks+0x32>
   13e61:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13e64:	eb 37                	jmp    13e9d <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   13e66:	8b 45 08             	mov    0x8(%ebp),%eax
   13e69:	8b 50 04             	mov    0x4(%eax),%edx
   13e6c:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6f:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   13e72:	8b 55 10             	mov    0x10(%ebp),%edx
   13e75:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e78:	01 d0                	add    %edx,%eax
   13e7a:	50                   	push   %eax
   13e7b:	ff 75 fc             	pushl  -0x4(%ebp)
   13e7e:	e8 ff 5c ff ff       	call   9b82 <lodepng_chunk_next>
   13e83:	83 c4 08             	add    $0x8,%esp
   13e86:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   13e89:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13e8c:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e8f:	29 c2                	sub    %eax,%edx
   13e91:	89 d0                	mov    %edx,%eax
   13e93:	3b 45 10             	cmp    0x10(%ebp),%eax
   13e96:	7c aa                	jl     13e42 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   13e98:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13e9d:	c9                   	leave  
   13e9e:	c3                   	ret    

00013e9f <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   13e9f:	55                   	push   %ebp
   13ea0:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   13ea2:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   13ea6:	77 07                	ja     13eaf <isGrayICCProfile+0x10>
   13ea8:	b8 00 00 00 00       	mov    $0x0,%eax
   13ead:	eb 40                	jmp    13eef <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   13eaf:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb2:	83 c0 10             	add    $0x10,%eax
   13eb5:	0f b6 00             	movzbl (%eax),%eax
   13eb8:	3c 47                	cmp    $0x47,%al
   13eba:	75 2e                	jne    13eea <isGrayICCProfile+0x4b>
   13ebc:	8b 45 08             	mov    0x8(%ebp),%eax
   13ebf:	83 c0 11             	add    $0x11,%eax
   13ec2:	0f b6 00             	movzbl (%eax),%eax
   13ec5:	3c 52                	cmp    $0x52,%al
   13ec7:	75 21                	jne    13eea <isGrayICCProfile+0x4b>
   13ec9:	8b 45 08             	mov    0x8(%ebp),%eax
   13ecc:	83 c0 12             	add    $0x12,%eax
   13ecf:	0f b6 00             	movzbl (%eax),%eax
   13ed2:	3c 41                	cmp    $0x41,%al
   13ed4:	75 14                	jne    13eea <isGrayICCProfile+0x4b>
   13ed6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed9:	83 c0 13             	add    $0x13,%eax
   13edc:	0f b6 00             	movzbl (%eax),%eax
   13edf:	3c 59                	cmp    $0x59,%al
   13ee1:	75 07                	jne    13eea <isGrayICCProfile+0x4b>
   13ee3:	b8 01 00 00 00       	mov    $0x1,%eax
   13ee8:	eb 05                	jmp    13eef <isGrayICCProfile+0x50>
   13eea:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13eef:	5d                   	pop    %ebp
   13ef0:	c3                   	ret    

00013ef1 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   13ef1:	55                   	push   %ebp
   13ef2:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   13ef4:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   13ef8:	77 07                	ja     13f01 <isRGBICCProfile+0x10>
   13efa:	b8 00 00 00 00       	mov    $0x0,%eax
   13eff:	eb 40                	jmp    13f41 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   13f01:	8b 45 08             	mov    0x8(%ebp),%eax
   13f04:	83 c0 10             	add    $0x10,%eax
   13f07:	0f b6 00             	movzbl (%eax),%eax
   13f0a:	3c 52                	cmp    $0x52,%al
   13f0c:	75 2e                	jne    13f3c <isRGBICCProfile+0x4b>
   13f0e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f11:	83 c0 11             	add    $0x11,%eax
   13f14:	0f b6 00             	movzbl (%eax),%eax
   13f17:	3c 47                	cmp    $0x47,%al
   13f19:	75 21                	jne    13f3c <isRGBICCProfile+0x4b>
   13f1b:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1e:	83 c0 12             	add    $0x12,%eax
   13f21:	0f b6 00             	movzbl (%eax),%eax
   13f24:	3c 42                	cmp    $0x42,%al
   13f26:	75 14                	jne    13f3c <isRGBICCProfile+0x4b>
   13f28:	8b 45 08             	mov    0x8(%ebp),%eax
   13f2b:	83 c0 13             	add    $0x13,%eax
   13f2e:	0f b6 00             	movzbl (%eax),%eax
   13f31:	3c 20                	cmp    $0x20,%al
   13f33:	75 07                	jne    13f3c <isRGBICCProfile+0x4b>
   13f35:	b8 01 00 00 00       	mov    $0x1,%eax
   13f3a:	eb 05                	jmp    13f41 <isRGBICCProfile+0x50>
   13f3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13f41:	5d                   	pop    %ebp
   13f42:	c3                   	ret    

00013f43 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   13f43:	55                   	push   %ebp
   13f44:	89 e5                	mov    %esp,%ebp
   13f46:	57                   	push   %edi
   13f47:	56                   	push   %esi
   13f48:	53                   	push   %ebx
   13f49:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   13f4f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   13f56:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   13f5d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13f60:	6a 00                	push   $0x0
   13f62:	6a 00                	push   $0x0
   13f64:	50                   	push   %eax
   13f65:	e8 6f 0d ff ff       	call   4cd9 <ucvector_init>
   13f6a:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   13f6d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f70:	05 98 00 00 00       	add    $0x98,%eax
   13f75:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   13f78:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13f7e:	50                   	push   %eax
   13f7f:	e8 3a 71 ff ff       	call   b0be <lodepng_info_init>
   13f84:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   13f87:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   13f90:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f93:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   13f99:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f9c:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   13fa3:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   13fa6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13fa9:	8b 40 0c             	mov    0xc(%eax),%eax
   13fac:	83 f8 03             	cmp    $0x3,%eax
   13faf:	74 0a                	je     13fbb <lodepng_encode+0x78>
   13fb1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fb4:	8b 40 6c             	mov    0x6c(%eax),%eax
   13fb7:	85 c0                	test   %eax,%eax
   13fb9:	74 29                	je     13fe4 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   13fbb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13fbe:	8b 40 18             	mov    0x18(%eax),%eax
   13fc1:	85 c0                	test   %eax,%eax
   13fc3:	74 0d                	je     13fd2 <lodepng_encode+0x8f>
   13fc5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13fc8:	8b 40 18             	mov    0x18(%eax),%eax
   13fcb:	3d 00 01 00 00       	cmp    $0x100,%eax
   13fd0:	7e 12                	jle    13fe4 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   13fd2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fd5:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   13fdc:	00 00 00 
    goto cleanup;
   13fdf:	e9 78 0c 00 00       	jmp    14c5c <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   13fe4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fe7:	8b 40 38             	mov    0x38(%eax),%eax
   13fea:	83 f8 02             	cmp    $0x2,%eax
   13fed:	76 12                	jbe    14001 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   13fef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ff2:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   13ff9:	00 00 00 
    goto cleanup;
   13ffc:	e9 5b 0c 00 00       	jmp    14c5c <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   14001:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14004:	8b 40 08             	mov    0x8(%eax),%eax
   14007:	83 f8 01             	cmp    $0x1,%eax
   1400a:	76 12                	jbe    1401e <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   1400c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1400f:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   14016:	00 00 00 
    goto cleanup;
   14019:	e9 3e 0c 00 00       	jmp    14c5c <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   1401e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14021:	8b 50 10             	mov    0x10(%eax),%edx
   14024:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14027:	8b 40 0c             	mov    0xc(%eax),%eax
   1402a:	52                   	push   %edx
   1402b:	50                   	push   %eax
   1402c:	e8 a4 5f ff ff       	call   9fd5 <checkColorValidity>
   14031:	83 c4 08             	add    $0x8,%esp
   14034:	89 c2                	mov    %eax,%edx
   14036:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14039:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1403f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14042:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14048:	85 c0                	test   %eax,%eax
   1404a:	0f 85 c6 0b 00 00    	jne    14c16 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   14050:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14053:	8b 50 7c             	mov    0x7c(%eax),%edx
   14056:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14059:	8b 40 78             	mov    0x78(%eax),%eax
   1405c:	52                   	push   %edx
   1405d:	50                   	push   %eax
   1405e:	e8 72 5f ff ff       	call   9fd5 <checkColorValidity>
   14063:	83 c4 08             	add    $0x8,%esp
   14066:	89 c2                	mov    %eax,%edx
   14068:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1406b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   14071:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14074:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1407a:	85 c0                	test   %eax,%eax
   1407c:	0f 85 97 0b 00 00    	jne    14c19 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   14082:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14085:	05 98 00 00 00       	add    $0x98,%eax
   1408a:	83 ec 08             	sub    $0x8,%esp
   1408d:	50                   	push   %eax
   1408e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14094:	50                   	push   %eax
   14095:	e8 58 71 ff ff       	call   b1f2 <lodepng_info_copy>
   1409a:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   1409d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   140a0:	8b 40 5c             	mov    0x5c(%eax),%eax
   140a3:	85 c0                	test   %eax,%eax
   140a5:	0f 84 3c 02 00 00    	je     142e7 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   140ab:	83 ec 0c             	sub    $0xc,%esp
   140ae:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   140b4:	50                   	push   %eax
   140b5:	e8 5f 96 ff ff       	call   d719 <lodepng_color_stats_init>
   140ba:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   140bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   140c0:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   140c6:	85 c0                	test   %eax,%eax
   140c8:	74 2d                	je     140f7 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   140ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
   140cd:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   140d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   140d6:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   140dc:	83 ec 08             	sub    $0x8,%esp
   140df:	52                   	push   %edx
   140e0:	50                   	push   %eax
   140e1:	e8 b9 fd ff ff       	call   13e9f <isGrayICCProfile>
   140e6:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   140e9:	85 c0                	test   %eax,%eax
   140eb:	74 0a                	je     140f7 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   140ed:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   140f4:	00 00 00 
    }
    if(info_png->iccp_defined &&
   140f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   140fa:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   14100:	85 c0                	test   %eax,%eax
   14102:	74 2d                	je     14131 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   14104:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14107:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   1410d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14110:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   14116:	83 ec 08             	sub    $0x8,%esp
   14119:	52                   	push   %edx
   1411a:	50                   	push   %eax
   1411b:	e8 d1 fd ff ff       	call   13ef1 <isRGBICCProfile>
   14120:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   14123:	85 c0                	test   %eax,%eax
   14125:	74 0a                	je     14131 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   14127:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   1412e:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   14131:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14134:	83 c0 78             	add    $0x78,%eax
   14137:	83 ec 0c             	sub    $0xc,%esp
   1413a:	50                   	push   %eax
   1413b:	ff 75 18             	pushl  0x18(%ebp)
   1413e:	ff 75 14             	pushl  0x14(%ebp)
   14141:	ff 75 10             	pushl  0x10(%ebp)
   14144:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   1414a:	50                   	push   %eax
   1414b:	e8 e0 96 ff ff       	call   d830 <lodepng_compute_color_stats>
   14150:	83 c4 20             	add    $0x20,%esp
   14153:	89 c2                	mov    %eax,%edx
   14155:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14158:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1415e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14161:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14167:	85 c0                	test   %eax,%eax
   14169:	0f 85 ad 0a 00 00    	jne    14c1c <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   1416f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14172:	8b 40 2c             	mov    0x2c(%eax),%eax
   14175:	85 c0                	test   %eax,%eax
   14177:	0f 84 be 00 00 00    	je     1423b <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   1417d:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   14184:	00 00 00 
   14187:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   1418e:	00 00 00 
   14191:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   14198:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   1419b:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   141a1:	83 ec 04             	sub    $0x4,%esp
   141a4:	6a 10                	push   $0x10
   141a6:	6a 02                	push   $0x2
   141a8:	50                   	push   %eax
   141a9:	e8 15 61 ff ff       	call   a2c3 <lodepng_color_mode_make>
   141ae:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   141b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   141b4:	8d 58 0c             	lea    0xc(%eax),%ebx
   141b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   141ba:	8b 48 38             	mov    0x38(%eax),%ecx
   141bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   141c0:	8b 50 34             	mov    0x34(%eax),%edx
   141c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   141c6:	8b 40 30             	mov    0x30(%eax),%eax
   141c9:	53                   	push   %ebx
   141ca:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   141d0:	53                   	push   %ebx
   141d1:	51                   	push   %ecx
   141d2:	52                   	push   %edx
   141d3:	50                   	push   %eax
   141d4:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   141da:	50                   	push   %eax
   141db:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   141e1:	50                   	push   %eax
   141e2:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   141e8:	50                   	push   %eax
   141e9:	e8 8a 92 ff ff       	call   d478 <lodepng_convert_rgb>
   141ee:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   141f1:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   141f7:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   141fd:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   14203:	83 ec 0c             	sub    $0xc,%esp
   14206:	68 ff ff 00 00       	push   $0xffff
   1420b:	51                   	push   %ecx
   1420c:	52                   	push   %edx
   1420d:	50                   	push   %eax
   1420e:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   14214:	50                   	push   %eax
   14215:	e8 26 a1 ff ff       	call   e340 <lodepng_color_stats_add>
   1421a:	83 c4 20             	add    $0x20,%esp
   1421d:	89 c2                	mov    %eax,%edx
   1421f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14222:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14228:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1422b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14231:	85 c0                	test   %eax,%eax
   14233:	74 06                	je     1423b <lodepng_encode+0x2f8>
   14235:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   14236:	e9 e1 09 00 00       	jmp    14c1c <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   1423b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1423e:	8d 50 78             	lea    0x78(%eax),%edx
   14241:	83 ec 04             	sub    $0x4,%esp
   14244:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   1424a:	50                   	push   %eax
   1424b:	52                   	push   %edx
   1424c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14252:	83 c0 0c             	add    $0xc,%eax
   14255:	50                   	push   %eax
   14256:	e8 79 a1 ff ff       	call   e3d4 <auto_choose_color>
   1425b:	83 c4 10             	add    $0x10,%esp
   1425e:	89 c2                	mov    %eax,%edx
   14260:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14263:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   14269:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1426c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14272:	85 c0                	test   %eax,%eax
   14274:	0f 85 a5 09 00 00    	jne    14c1f <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   1427a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1427d:	8b 40 2c             	mov    0x2c(%eax),%eax
   14280:	85 c0                	test   %eax,%eax
   14282:	74 63                	je     142e7 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   14284:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14287:	8d 58 0c             	lea    0xc(%eax),%ebx
   1428a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1428d:	8b 48 38             	mov    0x38(%eax),%ecx
   14290:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14293:	8b 50 34             	mov    0x34(%eax),%edx
   14296:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14299:	8b 40 30             	mov    0x30(%eax),%eax
   1429c:	53                   	push   %ebx
   1429d:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   142a3:	83 c3 0c             	add    $0xc,%ebx
   142a6:	53                   	push   %ebx
   142a7:	51                   	push   %ecx
   142a8:	52                   	push   %edx
   142a9:	50                   	push   %eax
   142aa:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   142b0:	83 c0 38             	add    $0x38,%eax
   142b3:	50                   	push   %eax
   142b4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   142ba:	83 c0 34             	add    $0x34,%eax
   142bd:	50                   	push   %eax
   142be:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   142c4:	83 c0 30             	add    $0x30,%eax
   142c7:	50                   	push   %eax
   142c8:	e8 ab 91 ff ff       	call   d478 <lodepng_convert_rgb>
   142cd:	83 c4 20             	add    $0x20,%esp
   142d0:	85 c0                	test   %eax,%eax
   142d2:	74 13                	je     142e7 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   142d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   142d7:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   142de:	00 00 00 
        goto cleanup;
   142e1:	90                   	nop
   142e2:	e9 75 09 00 00       	jmp    14c5c <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   142e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   142ea:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   142f0:	85 c0                	test   %eax,%eax
   142f2:	0f 84 b2 00 00 00    	je     143aa <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   142f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   142fb:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   14301:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14304:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1430a:	83 ec 08             	sub    $0x8,%esp
   1430d:	52                   	push   %edx
   1430e:	50                   	push   %eax
   1430f:	e8 8b fb ff ff       	call   13e9f <isGrayICCProfile>
   14314:	83 c4 10             	add    $0x10,%esp
   14317:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   1431a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1431d:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   14323:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14326:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1432c:	83 ec 08             	sub    $0x8,%esp
   1432f:	52                   	push   %edx
   14330:	50                   	push   %eax
   14331:	e8 bb fb ff ff       	call   13ef1 <isRGBICCProfile>
   14336:	83 c4 10             	add    $0x10,%esp
   14339:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   1433c:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   14342:	85 c0                	test   %eax,%eax
   14344:	74 0b                	je     14351 <lodepng_encode+0x40e>
   14346:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1434c:	83 f8 04             	cmp    $0x4,%eax
   1434f:	75 07                	jne    14358 <lodepng_encode+0x415>
   14351:	b8 01 00 00 00       	mov    $0x1,%eax
   14356:	eb 05                	jmp    1435d <lodepng_encode+0x41a>
   14358:	b8 00 00 00 00       	mov    $0x0,%eax
   1435d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   14360:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   14364:	75 18                	jne    1437e <lodepng_encode+0x43b>
   14366:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   1436a:	75 12                	jne    1437e <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   1436c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1436f:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   14376:	00 00 00 
      goto cleanup;
   14379:	e9 de 08 00 00       	jmp    14c5c <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   1437e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14381:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   14384:	74 24                	je     143aa <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   14386:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14389:	8b 40 5c             	mov    0x5c(%eax),%eax
   1438c:	85 c0                	test   %eax,%eax
   1438e:	74 07                	je     14397 <lodepng_encode+0x454>
   14390:	ba 66 00 00 00       	mov    $0x66,%edx
   14395:	eb 05                	jmp    1439c <lodepng_encode+0x459>
   14397:	ba 65 00 00 00       	mov    $0x65,%edx
   1439c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1439f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   143a5:	e9 b2 08 00 00       	jmp    14c5c <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   143aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   143ad:	83 c0 78             	add    $0x78,%eax
   143b0:	83 ec 08             	sub    $0x8,%esp
   143b3:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   143b9:	83 c2 0c             	add    $0xc,%edx
   143bc:	52                   	push   %edx
   143bd:	50                   	push   %eax
   143be:	e8 57 5f ff ff       	call   a31a <lodepng_color_mode_equal>
   143c3:	83 c4 10             	add    $0x10,%esp
   143c6:	85 c0                	test   %eax,%eax
   143c8:	0f 85 f8 00 00 00    	jne    144c6 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   143ce:	8b 55 14             	mov    0x14(%ebp),%edx
   143d1:	8b 45 18             	mov    0x18(%ebp),%eax
   143d4:	89 d3                	mov    %edx,%ebx
   143d6:	0f af d8             	imul   %eax,%ebx
   143d9:	83 ec 0c             	sub    $0xc,%esp
   143dc:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   143e2:	83 c0 0c             	add    $0xc,%eax
   143e5:	50                   	push   %eax
   143e6:	e8 49 61 ff ff       	call   a534 <lodepng_get_bpp>
   143eb:	83 c4 10             	add    $0x10,%esp
   143ee:	0f af c3             	imul   %ebx,%eax
   143f1:	83 c0 07             	add    $0x7,%eax
   143f4:	c1 e8 03             	shr    $0x3,%eax
   143f7:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   143fa:	83 ec 0c             	sub    $0xc,%esp
   143fd:	ff 75 cc             	pushl  -0x34(%ebp)
   14400:	e8 13 06 ff ff       	call   4a18 <lodepng_malloc>
   14405:	83 c4 10             	add    $0x10,%esp
   14408:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   1440b:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   1440f:	75 13                	jne    14424 <lodepng_encode+0x4e1>
   14411:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   14415:	74 0d                	je     14424 <lodepng_encode+0x4e1>
   14417:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1441a:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   14421:	00 00 00 
    if(!state->error) {
   14424:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14427:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1442d:	85 c0                	test   %eax,%eax
   1442f:	75 33                	jne    14464 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   14431:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14434:	83 c0 78             	add    $0x78,%eax
   14437:	83 ec 08             	sub    $0x8,%esp
   1443a:	ff 75 18             	pushl  0x18(%ebp)
   1443d:	ff 75 14             	pushl  0x14(%ebp)
   14440:	50                   	push   %eax
   14441:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14447:	83 c0 0c             	add    $0xc,%eax
   1444a:	50                   	push   %eax
   1444b:	ff 75 10             	pushl  0x10(%ebp)
   1444e:	ff 75 c8             	pushl  -0x38(%ebp)
   14451:	e8 c9 8c ff ff       	call   d11f <lodepng_convert>
   14456:	83 c4 20             	add    $0x20,%esp
   14459:	89 c2                	mov    %eax,%edx
   1445b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1445e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   14464:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14467:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1446d:	85 c0                	test   %eax,%eax
   1446f:	75 35                	jne    144a6 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   14471:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14474:	83 c0 38             	add    $0x38,%eax
   14477:	83 ec 04             	sub    $0x4,%esp
   1447a:	50                   	push   %eax
   1447b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14481:	50                   	push   %eax
   14482:	ff 75 18             	pushl  0x18(%ebp)
   14485:	ff 75 14             	pushl  0x14(%ebp)
   14488:	ff 75 c8             	pushl  -0x38(%ebp)
   1448b:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1448e:	50                   	push   %eax
   1448f:	8d 45 c0             	lea    -0x40(%ebp),%eax
   14492:	50                   	push   %eax
   14493:	e8 0d f6 ff ff       	call   13aa5 <preProcessScanlines>
   14498:	83 c4 20             	add    $0x20,%esp
   1449b:	89 c2                	mov    %eax,%edx
   1449d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   144a0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   144a6:	83 ec 0c             	sub    $0xc,%esp
   144a9:	ff 75 c8             	pushl  -0x38(%ebp)
   144ac:	e8 88 05 ff ff       	call   4a39 <lodepng_free>
   144b1:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   144b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   144b7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   144bd:	85 c0                	test   %eax,%eax
   144bf:	74 4b                	je     1450c <lodepng_encode+0x5c9>
   144c1:	e9 96 07 00 00       	jmp    14c5c <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   144c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   144c9:	83 c0 38             	add    $0x38,%eax
   144cc:	83 ec 04             	sub    $0x4,%esp
   144cf:	50                   	push   %eax
   144d0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   144d6:	50                   	push   %eax
   144d7:	ff 75 18             	pushl  0x18(%ebp)
   144da:	ff 75 14             	pushl  0x14(%ebp)
   144dd:	ff 75 10             	pushl  0x10(%ebp)
   144e0:	8d 45 bc             	lea    -0x44(%ebp),%eax
   144e3:	50                   	push   %eax
   144e4:	8d 45 c0             	lea    -0x40(%ebp),%eax
   144e7:	50                   	push   %eax
   144e8:	e8 b8 f5 ff ff       	call   13aa5 <preProcessScanlines>
   144ed:	83 c4 20             	add    $0x20,%esp
   144f0:	89 c2                	mov    %eax,%edx
   144f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   144f5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   144fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   144fe:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14504:	85 c0                	test   %eax,%eax
   14506:	0f 85 16 07 00 00    	jne    14c22 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   1450c:	83 ec 0c             	sub    $0xc,%esp
   1450f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14512:	50                   	push   %eax
   14513:	e8 21 d9 ff ff       	call   11e39 <writeSignature>
   14518:	83 c4 10             	add    $0x10,%esp
   1451b:	89 c2                	mov    %eax,%edx
   1451d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14520:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   14526:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14529:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1452f:	85 c0                	test   %eax,%eax
   14531:	0f 85 ee 06 00 00    	jne    14c25 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   14537:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   1453d:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   14543:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   14549:	83 ec 08             	sub    $0x8,%esp
   1454c:	51                   	push   %ecx
   1454d:	52                   	push   %edx
   1454e:	50                   	push   %eax
   1454f:	ff 75 18             	pushl  0x18(%ebp)
   14552:	ff 75 14             	pushl  0x14(%ebp)
   14555:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14558:	50                   	push   %eax
   14559:	e8 4a d9 ff ff       	call   11ea8 <addChunk_IHDR>
   1455e:	83 c4 20             	add    $0x20,%esp
   14561:	89 c2                	mov    %eax,%edx
   14563:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14566:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1456c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1456f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14575:	85 c0                	test   %eax,%eax
   14577:	0f 85 ab 06 00 00    	jne    14c28 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   1457d:	8b 45 98             	mov    -0x68(%ebp),%eax
   14580:	85 c0                	test   %eax,%eax
   14582:	74 33                	je     145b7 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   14584:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   14587:	8b 45 98             	mov    -0x68(%ebp),%eax
   1458a:	83 ec 04             	sub    $0x4,%esp
   1458d:	52                   	push   %edx
   1458e:	50                   	push   %eax
   1458f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14592:	50                   	push   %eax
   14593:	e8 9c f8 ff ff       	call   13e34 <addUnknownChunks>
   14598:	83 c4 10             	add    $0x10,%esp
   1459b:	89 c2                	mov    %eax,%edx
   1459d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145a0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   145a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145a9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   145af:	85 c0                	test   %eax,%eax
   145b1:	0f 85 74 06 00 00    	jne    14c2b <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   145b7:	8b 45 88             	mov    -0x78(%ebp),%eax
   145ba:	85 c0                	test   %eax,%eax
   145bc:	74 39                	je     145f7 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   145be:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145c1:	83 c0 38             	add    $0x38,%eax
   145c4:	83 ec 04             	sub    $0x4,%esp
   145c7:	50                   	push   %eax
   145c8:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   145ce:	50                   	push   %eax
   145cf:	8d 45 b0             	lea    -0x50(%ebp),%eax
   145d2:	50                   	push   %eax
   145d3:	e8 a4 e4 ff ff       	call   12a7c <addChunk_iCCP>
   145d8:	83 c4 10             	add    $0x10,%esp
   145db:	89 c2                	mov    %eax,%edx
   145dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145e0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   145e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   145ef:	85 c0                	test   %eax,%eax
   145f1:	0f 85 37 06 00 00    	jne    14c2e <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   145f7:	8b 45 80             	mov    -0x80(%ebp),%eax
   145fa:	85 c0                	test   %eax,%eax
   145fc:	74 32                	je     14630 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   145fe:	83 ec 08             	sub    $0x8,%esp
   14601:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14607:	50                   	push   %eax
   14608:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1460b:	50                   	push   %eax
   1460c:	e8 41 e4 ff ff       	call   12a52 <addChunk_sRGB>
   14611:	83 c4 10             	add    $0x10,%esp
   14614:	89 c2                	mov    %eax,%edx
   14616:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14619:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1461f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14622:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14628:	85 c0                	test   %eax,%eax
   1462a:	0f 85 01 06 00 00    	jne    14c31 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   14630:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   14636:	85 c0                	test   %eax,%eax
   14638:	74 32                	je     1466c <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   1463a:	83 ec 08             	sub    $0x8,%esp
   1463d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14643:	50                   	push   %eax
   14644:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14647:	50                   	push   %eax
   14648:	e8 a7 e2 ff ff       	call   128f4 <addChunk_gAMA>
   1464d:	83 c4 10             	add    $0x10,%esp
   14650:	89 c2                	mov    %eax,%edx
   14652:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14655:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1465b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1465e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14664:	85 c0                	test   %eax,%eax
   14666:	0f 85 c8 05 00 00    	jne    14c34 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   1466c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   14672:	85 c0                	test   %eax,%eax
   14674:	74 32                	je     146a8 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   14676:	83 ec 08             	sub    $0x8,%esp
   14679:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1467f:	50                   	push   %eax
   14680:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14683:	50                   	push   %eax
   14684:	e8 c1 e2 ff ff       	call   1294a <addChunk_cHRM>
   14689:	83 c4 10             	add    $0x10,%esp
   1468c:	89 c2                	mov    %eax,%edx
   1468e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14691:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14697:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1469a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   146a0:	85 c0                	test   %eax,%eax
   146a2:	0f 85 8f 05 00 00    	jne    14c37 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   146a8:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   146ae:	83 f8 03             	cmp    $0x3,%eax
   146b1:	75 35                	jne    146e8 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   146b3:	83 ec 08             	sub    $0x8,%esp
   146b6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   146bc:	83 c0 0c             	add    $0xc,%eax
   146bf:	50                   	push   %eax
   146c0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   146c3:	50                   	push   %eax
   146c4:	e8 78 d8 ff ff       	call   11f41 <addChunk_PLTE>
   146c9:	83 c4 10             	add    $0x10,%esp
   146cc:	89 c2                	mov    %eax,%edx
   146ce:	8b 45 1c             	mov    0x1c(%ebp),%eax
   146d1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   146d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   146da:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   146e0:	85 c0                	test   %eax,%eax
   146e2:	0f 85 52 05 00 00    	jne    14c3a <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   146e8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   146eb:	8b 40 6c             	mov    0x6c(%eax),%eax
   146ee:	85 c0                	test   %eax,%eax
   146f0:	74 4b                	je     1473d <lodepng_encode+0x7fa>
   146f2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   146f8:	83 f8 02             	cmp    $0x2,%eax
   146fb:	74 0b                	je     14708 <lodepng_encode+0x7c5>
   146fd:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   14703:	83 f8 06             	cmp    $0x6,%eax
   14706:	75 35                	jne    1473d <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   14708:	83 ec 08             	sub    $0x8,%esp
   1470b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14711:	83 c0 0c             	add    $0xc,%eax
   14714:	50                   	push   %eax
   14715:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14718:	50                   	push   %eax
   14719:	e8 23 d8 ff ff       	call   11f41 <addChunk_PLTE>
   1471e:	83 c4 10             	add    $0x10,%esp
   14721:	89 c2                	mov    %eax,%edx
   14723:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14726:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1472c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1472f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14735:	85 c0                	test   %eax,%eax
   14737:	0f 85 00 05 00 00    	jne    14c3d <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   1473d:	83 ec 08             	sub    $0x8,%esp
   14740:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14746:	83 c0 0c             	add    $0xc,%eax
   14749:	50                   	push   %eax
   1474a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1474d:	50                   	push   %eax
   1474e:	e8 c4 d8 ff ff       	call   12017 <addChunk_tRNS>
   14753:	83 c4 10             	add    $0x10,%esp
   14756:	89 c2                	mov    %eax,%edx
   14758:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1475b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   14761:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14764:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1476a:	85 c0                	test   %eax,%eax
   1476c:	0f 85 ce 04 00 00    	jne    14c40 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   14772:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   14778:	85 c0                	test   %eax,%eax
   1477a:	74 32                	je     147ae <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   1477c:	83 ec 08             	sub    $0x8,%esp
   1477f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14785:	50                   	push   %eax
   14786:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14789:	50                   	push   %eax
   1478a:	e8 e4 de ff ff       	call   12673 <addChunk_bKGD>
   1478f:	83 c4 10             	add    $0x10,%esp
   14792:	89 c2                	mov    %eax,%edx
   14794:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14797:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1479d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   147a0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   147a6:	85 c0                	test   %eax,%eax
   147a8:	0f 85 95 04 00 00    	jne    14c43 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   147ae:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   147b4:	85 c0                	test   %eax,%eax
   147b6:	74 32                	je     147ea <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   147b8:	83 ec 08             	sub    $0x8,%esp
   147bb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   147c1:	50                   	push   %eax
   147c2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   147c5:	50                   	push   %eax
   147c6:	e8 ac e0 ff ff       	call   12877 <addChunk_pHYs>
   147cb:	83 c4 10             	add    $0x10,%esp
   147ce:	89 c2                	mov    %eax,%edx
   147d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   147d3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   147d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   147dc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   147e2:	85 c0                	test   %eax,%eax
   147e4:	0f 85 5c 04 00 00    	jne    14c46 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   147ea:	8b 45 9c             	mov    -0x64(%ebp),%eax
   147ed:	85 c0                	test   %eax,%eax
   147ef:	74 33                	je     14824 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   147f1:	8b 55 a8             	mov    -0x58(%ebp),%edx
   147f4:	8b 45 9c             	mov    -0x64(%ebp),%eax
   147f7:	83 ec 04             	sub    $0x4,%esp
   147fa:	52                   	push   %edx
   147fb:	50                   	push   %eax
   147fc:	8d 45 b0             	lea    -0x50(%ebp),%eax
   147ff:	50                   	push   %eax
   14800:	e8 2f f6 ff ff       	call   13e34 <addUnknownChunks>
   14805:	83 c4 10             	add    $0x10,%esp
   14808:	89 c2                	mov    %eax,%edx
   1480a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1480d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14813:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14816:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1481c:	85 c0                	test   %eax,%eax
   1481e:	0f 85 25 04 00 00    	jne    14c49 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   14824:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14827:	8d 48 38             	lea    0x38(%eax),%ecx
   1482a:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1482d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   14830:	51                   	push   %ecx
   14831:	52                   	push   %edx
   14832:	50                   	push   %eax
   14833:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14836:	50                   	push   %eax
   14837:	e8 bd d9 ff ff       	call   121f9 <addChunk_IDAT>
   1483c:	83 c4 10             	add    $0x10,%esp
   1483f:	89 c2                	mov    %eax,%edx
   14841:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14844:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1484a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1484d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14853:	85 c0                	test   %eax,%eax
   14855:	0f 85 f1 03 00 00    	jne    14c4c <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   1485b:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   14861:	85 c0                	test   %eax,%eax
   14863:	74 35                	je     1489a <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   14865:	83 ec 08             	sub    $0x8,%esp
   14868:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1486e:	83 c0 60             	add    $0x60,%eax
   14871:	50                   	push   %eax
   14872:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14875:	50                   	push   %eax
   14876:	e8 5c df ff ff       	call   127d7 <addChunk_tIME>
   1487b:	83 c4 10             	add    $0x10,%esp
   1487e:	89 c2                	mov    %eax,%edx
   14880:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14883:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14889:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1488c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14892:	85 c0                	test   %eax,%eax
   14894:	0f 85 b5 03 00 00    	jne    14c4f <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   1489a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   148a1:	e9 12 01 00 00       	jmp    149b8 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   148a6:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   148ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   148af:	c1 e2 02             	shl    $0x2,%edx
   148b2:	01 d0                	add    %edx,%eax
   148b4:	8b 00                	mov    (%eax),%eax
   148b6:	83 ec 0c             	sub    $0xc,%esp
   148b9:	50                   	push   %eax
   148ba:	e8 f5 01 ff ff       	call   4ab4 <lodepng_strlen>
   148bf:	83 c4 10             	add    $0x10,%esp
   148c2:	83 f8 4f             	cmp    $0x4f,%eax
   148c5:	7e 12                	jle    148d9 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   148c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   148ca:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   148d1:	00 00 00 
        goto cleanup;
   148d4:	e9 83 03 00 00       	jmp    14c5c <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   148d9:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   148df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   148e2:	c1 e2 02             	shl    $0x2,%edx
   148e5:	01 d0                	add    %edx,%eax
   148e7:	8b 00                	mov    (%eax),%eax
   148e9:	83 ec 0c             	sub    $0xc,%esp
   148ec:	50                   	push   %eax
   148ed:	e8 c2 01 ff ff       	call   4ab4 <lodepng_strlen>
   148f2:	83 c4 10             	add    $0x10,%esp
   148f5:	85 c0                	test   %eax,%eax
   148f7:	7f 12                	jg     1490b <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   148f9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   148fc:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   14903:	00 00 00 
        goto cleanup;
   14906:	e9 51 03 00 00       	jmp    14c5c <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   1490b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1490e:	8b 40 74             	mov    0x74(%eax),%eax
   14911:	85 c0                	test   %eax,%eax
   14913:	74 52                	je     14967 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   14915:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14918:	8d 48 38             	lea    0x38(%eax),%ecx
   1491b:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   14921:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14924:	c1 e2 02             	shl    $0x2,%edx
   14927:	01 d0                	add    %edx,%eax
   14929:	8b 10                	mov    (%eax),%edx
   1492b:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   14931:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   14934:	c1 e3 02             	shl    $0x2,%ebx
   14937:	01 d8                	add    %ebx,%eax
   14939:	8b 00                	mov    (%eax),%eax
   1493b:	51                   	push   %ecx
   1493c:	52                   	push   %edx
   1493d:	50                   	push   %eax
   1493e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14941:	50                   	push   %eax
   14942:	e8 fa d9 ff ff       	call   12341 <addChunk_zTXt>
   14947:	83 c4 10             	add    $0x10,%esp
   1494a:	89 c2                	mov    %eax,%edx
   1494c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1494f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   14955:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14958:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1495e:	85 c0                	test   %eax,%eax
   14960:	74 52                	je     149b4 <lodepng_encode+0xa71>
   14962:	e9 f5 02 00 00       	jmp    14c5c <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   14967:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1496d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14970:	c1 e2 02             	shl    $0x2,%edx
   14973:	01 d0                	add    %edx,%eax
   14975:	8b 10                	mov    (%eax),%edx
   14977:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1497d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   14980:	c1 e1 02             	shl    $0x2,%ecx
   14983:	01 c8                	add    %ecx,%eax
   14985:	8b 00                	mov    (%eax),%eax
   14987:	83 ec 04             	sub    $0x4,%esp
   1498a:	52                   	push   %edx
   1498b:	50                   	push   %eax
   1498c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1498f:	50                   	push   %eax
   14990:	e8 ec d8 ff ff       	call   12281 <addChunk_tEXt>
   14995:	83 c4 10             	add    $0x10,%esp
   14998:	89 c2                	mov    %eax,%edx
   1499a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1499d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   149a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   149a6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   149ac:	85 c0                	test   %eax,%eax
   149ae:	0f 85 9e 02 00 00    	jne    14c52 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   149b4:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   149b8:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   149be:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   149c1:	0f 85 df fe ff ff    	jne    148a6 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   149c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   149ca:	8b 40 70             	mov    0x70(%eax),%eax
   149cd:	85 c0                	test   %eax,%eax
   149cf:	0f 84 e3 00 00 00    	je     14ab8 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   149d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   149dc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   149e3:	e9 85 00 00 00       	jmp    14a6d <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   149e8:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   149ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   149f1:	c1 e2 02             	shl    $0x2,%edx
   149f4:	01 d0                	add    %edx,%eax
   149f6:	8b 00                	mov    (%eax),%eax
   149f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   149fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   149fe:	0f b6 00             	movzbl (%eax),%eax
   14a01:	3c 4c                	cmp    $0x4c,%al
   14a03:	75 64                	jne    14a69 <lodepng_encode+0xb26>
   14a05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14a08:	83 c0 01             	add    $0x1,%eax
   14a0b:	0f b6 00             	movzbl (%eax),%eax
   14a0e:	3c 6f                	cmp    $0x6f,%al
   14a10:	75 57                	jne    14a69 <lodepng_encode+0xb26>
   14a12:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14a15:	83 c0 02             	add    $0x2,%eax
   14a18:	0f b6 00             	movzbl (%eax),%eax
   14a1b:	3c 64                	cmp    $0x64,%al
   14a1d:	75 4a                	jne    14a69 <lodepng_encode+0xb26>
   14a1f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14a22:	83 c0 03             	add    $0x3,%eax
   14a25:	0f b6 00             	movzbl (%eax),%eax
   14a28:	3c 65                	cmp    $0x65,%al
   14a2a:	75 3d                	jne    14a69 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   14a2c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14a2f:	83 c0 04             	add    $0x4,%eax
   14a32:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   14a35:	3c 50                	cmp    $0x50,%al
   14a37:	75 30                	jne    14a69 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   14a39:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14a3c:	83 c0 05             	add    $0x5,%eax
   14a3f:	0f b6 00             	movzbl (%eax),%eax
   14a42:	3c 4e                	cmp    $0x4e,%al
   14a44:	75 23                	jne    14a69 <lodepng_encode+0xb26>
   14a46:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14a49:	83 c0 06             	add    $0x6,%eax
   14a4c:	0f b6 00             	movzbl (%eax),%eax
   14a4f:	3c 47                	cmp    $0x47,%al
   14a51:	75 16                	jne    14a69 <lodepng_encode+0xb26>
   14a53:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14a56:	83 c0 07             	add    $0x7,%eax
   14a59:	0f b6 00             	movzbl (%eax),%eax
   14a5c:	84 c0                	test   %al,%al
   14a5e:	75 09                	jne    14a69 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   14a60:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   14a67:	eb 13                	jmp    14a7c <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   14a69:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14a6d:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   14a73:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14a76:	0f 85 6c ff ff ff    	jne    149e8 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   14a7c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14a80:	75 36                	jne    14ab8 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   14a82:	a1 c0 f8 01 00       	mov    0x1f8c0,%eax
   14a87:	83 ec 04             	sub    $0x4,%esp
   14a8a:	50                   	push   %eax
   14a8b:	68 a4 b7 01 00       	push   $0x1b7a4
   14a90:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14a93:	50                   	push   %eax
   14a94:	e8 e8 d7 ff ff       	call   12281 <addChunk_tEXt>
   14a99:	83 c4 10             	add    $0x10,%esp
   14a9c:	89 c2                	mov    %eax,%edx
   14a9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14aa1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   14aa7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14aaa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14ab0:	85 c0                	test   %eax,%eax
   14ab2:	0f 85 9d 01 00 00    	jne    14c55 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   14ab8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14abf:	e9 e6 00 00 00       	jmp    14baa <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   14ac4:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   14aca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14acd:	c1 e2 02             	shl    $0x2,%edx
   14ad0:	01 d0                	add    %edx,%eax
   14ad2:	8b 00                	mov    (%eax),%eax
   14ad4:	83 ec 0c             	sub    $0xc,%esp
   14ad7:	50                   	push   %eax
   14ad8:	e8 d7 ff fe ff       	call   4ab4 <lodepng_strlen>
   14add:	83 c4 10             	add    $0x10,%esp
   14ae0:	83 f8 4f             	cmp    $0x4f,%eax
   14ae3:	7e 12                	jle    14af7 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   14ae5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14ae8:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   14aef:	00 00 00 
        goto cleanup;
   14af2:	e9 65 01 00 00       	jmp    14c5c <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   14af7:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   14afd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14b00:	c1 e2 02             	shl    $0x2,%edx
   14b03:	01 d0                	add    %edx,%eax
   14b05:	8b 00                	mov    (%eax),%eax
   14b07:	83 ec 0c             	sub    $0xc,%esp
   14b0a:	50                   	push   %eax
   14b0b:	e8 a4 ff fe ff       	call   4ab4 <lodepng_strlen>
   14b10:	83 c4 10             	add    $0x10,%esp
   14b13:	85 c0                	test   %eax,%eax
   14b15:	7f 12                	jg     14b29 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   14b17:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14b1a:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   14b21:	00 00 00 
        goto cleanup;
   14b24:	e9 33 01 00 00       	jmp    14c5c <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   14b29:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14b2c:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14b2f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   14b35:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14b38:	c1 e2 02             	shl    $0x2,%edx
   14b3b:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14b3d:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14b3f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   14b45:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14b48:	c1 e2 02             	shl    $0x2,%edx
   14b4b:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14b4d:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14b4f:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   14b55:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14b58:	c1 e2 02             	shl    $0x2,%edx
   14b5b:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14b5d:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14b5f:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   14b65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14b68:	c1 e2 02             	shl    $0x2,%edx
   14b6b:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14b6d:	8b 10                	mov    (%eax),%edx
   14b6f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14b72:	8b 40 74             	mov    0x74(%eax),%eax
   14b75:	83 ec 04             	sub    $0x4,%esp
   14b78:	57                   	push   %edi
   14b79:	56                   	push   %esi
   14b7a:	53                   	push   %ebx
   14b7b:	51                   	push   %ecx
   14b7c:	52                   	push   %edx
   14b7d:	50                   	push   %eax
   14b7e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14b81:	50                   	push   %eax
   14b82:	e8 dc d8 ff ff       	call   12463 <addChunk_iTXt>
   14b87:	83 c4 20             	add    $0x20,%esp
   14b8a:	89 c2                	mov    %eax,%edx
   14b8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14b8f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   14b95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14b98:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14b9e:	85 c0                	test   %eax,%eax
   14ba0:	0f 85 b2 00 00 00    	jne    14c58 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   14ba6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14baa:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   14bb0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14bb3:	0f 85 0b ff ff ff    	jne    14ac4 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   14bb9:	8b 45 a0             	mov    -0x60(%ebp),%eax
   14bbc:	85 c0                	test   %eax,%eax
   14bbe:	74 2f                	je     14bef <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   14bc0:	8b 55 ac             	mov    -0x54(%ebp),%edx
   14bc3:	8b 45 a0             	mov    -0x60(%ebp),%eax
   14bc6:	83 ec 04             	sub    $0x4,%esp
   14bc9:	52                   	push   %edx
   14bca:	50                   	push   %eax
   14bcb:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14bce:	50                   	push   %eax
   14bcf:	e8 60 f2 ff ff       	call   13e34 <addUnknownChunks>
   14bd4:	83 c4 10             	add    $0x10,%esp
   14bd7:	89 c2                	mov    %eax,%edx
   14bd9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14bdc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14be2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14be5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14beb:	85 c0                	test   %eax,%eax
   14bed:	75 6c                	jne    14c5b <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   14bef:	83 ec 0c             	sub    $0xc,%esp
   14bf2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14bf5:	50                   	push   %eax
   14bf6:	e8 6d d6 ff ff       	call   12268 <addChunk_IEND>
   14bfb:	83 c4 10             	add    $0x10,%esp
   14bfe:	89 c2                	mov    %eax,%edx
   14c00:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14c03:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   14c09:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14c0c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14c12:	85 c0                	test   %eax,%eax
   14c14:	eb 46                	jmp    14c5c <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   14c16:	90                   	nop
   14c17:	eb 43                	jmp    14c5c <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   14c19:	90                   	nop
   14c1a:	eb 40                	jmp    14c5c <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   14c1c:	90                   	nop
   14c1d:	eb 3d                	jmp    14c5c <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   14c1f:	90                   	nop
   14c20:	eb 3a                	jmp    14c5c <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   14c22:	90                   	nop
   14c23:	eb 37                	jmp    14c5c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   14c25:	90                   	nop
   14c26:	eb 34                	jmp    14c5c <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   14c28:	90                   	nop
   14c29:	eb 31                	jmp    14c5c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   14c2b:	90                   	nop
   14c2c:	eb 2e                	jmp    14c5c <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   14c2e:	90                   	nop
   14c2f:	eb 2b                	jmp    14c5c <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   14c31:	90                   	nop
   14c32:	eb 28                	jmp    14c5c <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   14c34:	90                   	nop
   14c35:	eb 25                	jmp    14c5c <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   14c37:	90                   	nop
   14c38:	eb 22                	jmp    14c5c <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   14c3a:	90                   	nop
   14c3b:	eb 1f                	jmp    14c5c <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   14c3d:	90                   	nop
   14c3e:	eb 1c                	jmp    14c5c <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   14c40:	90                   	nop
   14c41:	eb 19                	jmp    14c5c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   14c43:	90                   	nop
   14c44:	eb 16                	jmp    14c5c <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   14c46:	90                   	nop
   14c47:	eb 13                	jmp    14c5c <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   14c49:	90                   	nop
   14c4a:	eb 10                	jmp    14c5c <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   14c4c:	90                   	nop
   14c4d:	eb 0d                	jmp    14c5c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   14c4f:	90                   	nop
   14c50:	eb 0a                	jmp    14c5c <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   14c52:	90                   	nop
   14c53:	eb 07                	jmp    14c5c <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   14c55:	90                   	nop
   14c56:	eb 04                	jmp    14c5c <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   14c58:	90                   	nop
   14c59:	eb 01                	jmp    14c5c <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   14c5b:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   14c5c:	83 ec 0c             	sub    $0xc,%esp
   14c5f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14c65:	50                   	push   %eax
   14c66:	e8 34 65 ff ff       	call   b19f <lodepng_info_cleanup>
   14c6b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   14c6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   14c71:	83 ec 0c             	sub    $0xc,%esp
   14c74:	50                   	push   %eax
   14c75:	e8 bf fd fe ff       	call   4a39 <lodepng_free>
   14c7a:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   14c7d:	8b 55 b0             	mov    -0x50(%ebp),%edx
   14c80:	8b 45 08             	mov    0x8(%ebp),%eax
   14c83:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   14c85:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   14c88:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c8b:	89 10                	mov    %edx,(%eax)

  return state->error;
   14c8d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14c90:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   14c96:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14c99:	5b                   	pop    %ebx
   14c9a:	5e                   	pop    %esi
   14c9b:	5f                   	pop    %edi
   14c9c:	5d                   	pop    %ebp
   14c9d:	c3                   	ret    

00014c9e <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   14c9e:	55                   	push   %ebp
   14c9f:	89 e5                	mov    %esp,%ebp
   14ca1:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   14ca7:	83 ec 0c             	sub    $0xc,%esp
   14caa:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   14cb0:	50                   	push   %eax
   14cb1:	e8 38 d0 ff ff       	call   11cee <lodepng_state_init>
   14cb6:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   14cb9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14cbc:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   14cc2:	8b 45 20             	mov    0x20(%ebp),%eax
   14cc5:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   14ccb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14cce:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   14cd4:	8b 45 20             	mov    0x20(%ebp),%eax
   14cd7:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   14cdd:	83 ec 08             	sub    $0x8,%esp
   14ce0:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   14ce6:	50                   	push   %eax
   14ce7:	ff 75 18             	pushl  0x18(%ebp)
   14cea:	ff 75 14             	pushl  0x14(%ebp)
   14ced:	ff 75 10             	pushl  0x10(%ebp)
   14cf0:	ff 75 0c             	pushl  0xc(%ebp)
   14cf3:	ff 75 08             	pushl  0x8(%ebp)
   14cf6:	e8 48 f2 ff ff       	call   13f43 <lodepng_encode>
   14cfb:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   14cfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d01:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   14d04:	83 ec 0c             	sub    $0xc,%esp
   14d07:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   14d0d:	50                   	push   %eax
   14d0e:	e8 35 d0 ff ff       	call   11d48 <lodepng_state_cleanup>
   14d13:	83 c4 10             	add    $0x10,%esp
  return error;
   14d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14d19:	c9                   	leave  
   14d1a:	c3                   	ret    

00014d1b <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   14d1b:	55                   	push   %ebp
   14d1c:	89 e5                	mov    %esp,%ebp
   14d1e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   14d21:	83 ec 04             	sub    $0x4,%esp
   14d24:	6a 08                	push   $0x8
   14d26:	6a 06                	push   $0x6
   14d28:	ff 75 18             	pushl  0x18(%ebp)
   14d2b:	ff 75 14             	pushl  0x14(%ebp)
   14d2e:	ff 75 10             	pushl  0x10(%ebp)
   14d31:	ff 75 0c             	pushl  0xc(%ebp)
   14d34:	ff 75 08             	pushl  0x8(%ebp)
   14d37:	e8 62 ff ff ff       	call   14c9e <lodepng_encode_memory>
   14d3c:	83 c4 20             	add    $0x20,%esp
}
   14d3f:	c9                   	leave  
   14d40:	c3                   	ret    

00014d41 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   14d41:	55                   	push   %ebp
   14d42:	89 e5                	mov    %esp,%ebp
   14d44:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   14d47:	83 ec 04             	sub    $0x4,%esp
   14d4a:	6a 08                	push   $0x8
   14d4c:	6a 02                	push   $0x2
   14d4e:	ff 75 18             	pushl  0x18(%ebp)
   14d51:	ff 75 14             	pushl  0x14(%ebp)
   14d54:	ff 75 10             	pushl  0x10(%ebp)
   14d57:	ff 75 0c             	pushl  0xc(%ebp)
   14d5a:	ff 75 08             	pushl  0x8(%ebp)
   14d5d:	e8 3c ff ff ff       	call   14c9e <lodepng_encode_memory>
   14d62:	83 c4 20             	add    $0x20,%esp
}
   14d65:	c9                   	leave  
   14d66:	c3                   	ret    

00014d67 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   14d67:	55                   	push   %ebp
   14d68:	89 e5                	mov    %esp,%ebp
   14d6a:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   14d6d:	83 ec 04             	sub    $0x4,%esp
   14d70:	ff 75 1c             	pushl  0x1c(%ebp)
   14d73:	ff 75 18             	pushl  0x18(%ebp)
   14d76:	ff 75 14             	pushl  0x14(%ebp)
   14d79:	ff 75 10             	pushl  0x10(%ebp)
   14d7c:	ff 75 0c             	pushl  0xc(%ebp)
   14d7f:	8d 45 ec             	lea    -0x14(%ebp),%eax
   14d82:	50                   	push   %eax
   14d83:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14d86:	50                   	push   %eax
   14d87:	e8 12 ff ff ff       	call   14c9e <lodepng_encode_memory>
   14d8c:	83 c4 20             	add    $0x20,%esp
   14d8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   14d92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14d96:	75 19                	jne    14db1 <lodepng_encode_file+0x4a>
   14d98:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14d9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d9e:	83 ec 04             	sub    $0x4,%esp
   14da1:	ff 75 08             	pushl  0x8(%ebp)
   14da4:	52                   	push   %edx
   14da5:	50                   	push   %eax
   14da6:	e8 36 01 ff ff       	call   4ee1 <lodepng_save_file>
   14dab:	83 c4 10             	add    $0x10,%esp
   14dae:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   14db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14db4:	83 ec 0c             	sub    $0xc,%esp
   14db7:	50                   	push   %eax
   14db8:	e8 7c fc fe ff       	call   4a39 <lodepng_free>
   14dbd:	83 c4 10             	add    $0x10,%esp
  return error;
   14dc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14dc3:	c9                   	leave  
   14dc4:	c3                   	ret    

00014dc5 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   14dc5:	55                   	push   %ebp
   14dc6:	89 e5                	mov    %esp,%ebp
   14dc8:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   14dcb:	83 ec 08             	sub    $0x8,%esp
   14dce:	6a 08                	push   $0x8
   14dd0:	6a 06                	push   $0x6
   14dd2:	ff 75 14             	pushl  0x14(%ebp)
   14dd5:	ff 75 10             	pushl  0x10(%ebp)
   14dd8:	ff 75 0c             	pushl  0xc(%ebp)
   14ddb:	ff 75 08             	pushl  0x8(%ebp)
   14dde:	e8 84 ff ff ff       	call   14d67 <lodepng_encode_file>
   14de3:	83 c4 20             	add    $0x20,%esp
}
   14de6:	c9                   	leave  
   14de7:	c3                   	ret    

00014de8 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   14de8:	55                   	push   %ebp
   14de9:	89 e5                	mov    %esp,%ebp
   14deb:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   14dee:	83 ec 08             	sub    $0x8,%esp
   14df1:	6a 08                	push   $0x8
   14df3:	6a 02                	push   $0x2
   14df5:	ff 75 14             	pushl  0x14(%ebp)
   14df8:	ff 75 10             	pushl  0x10(%ebp)
   14dfb:	ff 75 0c             	pushl  0xc(%ebp)
   14dfe:	ff 75 08             	pushl  0x8(%ebp)
   14e01:	e8 61 ff ff ff       	call   14d67 <lodepng_encode_file>
   14e06:	83 c4 20             	add    $0x20,%esp
}
   14e09:	c9                   	leave  
   14e0a:	c3                   	ret    

00014e0b <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   14e0b:	55                   	push   %ebp
   14e0c:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   14e0e:	8b 45 08             	mov    0x8(%ebp),%eax
   14e11:	50                   	push   %eax
   14e12:	e8 71 49 ff ff       	call   9788 <lodepng_compress_settings_init>
   14e17:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   14e1a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e1d:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   14e24:	8b 45 08             	mov    0x8(%ebp),%eax
   14e27:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   14e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   14e31:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   14e38:	8b 45 08             	mov    0x8(%ebp),%eax
   14e3b:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   14e42:	8b 45 08             	mov    0x8(%ebp),%eax
   14e45:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   14e4c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e4f:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   14e56:	8b 45 08             	mov    0x8(%ebp),%eax
   14e59:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   14e60:	90                   	nop
   14e61:	c9                   	leave  
   14e62:	c3                   	ret    

00014e63 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   14e63:	55                   	push   %ebp
   14e64:	89 e5                	mov    %esp,%ebp
  switch(code) {
   14e66:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   14e6a:	0f 87 c1 03 00 00    	ja     15231 <lodepng_error_text+0x3ce>
   14e70:	8b 45 08             	mov    0x8(%ebp),%eax
   14e73:	c1 e0 02             	shl    $0x2,%eax
   14e76:	05 e0 ca 01 00       	add    $0x1cae0,%eax
   14e7b:	8b 00                	mov    (%eax),%eax
   14e7d:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   14e7f:	b8 ac b7 01 00       	mov    $0x1b7ac,%eax
   14e84:	e9 ad 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   14e89:	b8 c9 b7 01 00       	mov    $0x1b7c9,%eax
   14e8e:	e9 a3 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   14e93:	b8 dc b7 01 00       	mov    $0x1b7dc,%eax
   14e98:	e9 99 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   14e9d:	b8 14 b8 01 00       	mov    $0x1b814,%eax
   14ea2:	e9 8f 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   14ea7:	b8 4c b8 01 00       	mov    $0x1b84c,%eax
   14eac:	e9 85 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   14eb1:	b8 4c b8 01 00       	mov    $0x1b84c,%eax
   14eb6:	e9 7b 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   14ebb:	b8 4c b8 01 00       	mov    $0x1b84c,%eax
   14ec0:	e9 71 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   14ec5:	b8 7c b8 01 00       	mov    $0x1b87c,%eax
   14eca:	e9 67 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   14ecf:	b8 b0 b8 01 00       	mov    $0x1b8b0,%eax
   14ed4:	e9 5d 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   14ed9:	b8 e4 b8 01 00       	mov    $0x1b8e4,%eax
   14ede:	e9 53 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   14ee3:	b8 b0 b8 01 00       	mov    $0x1b8b0,%eax
   14ee8:	e9 49 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   14eed:	b8 0c b9 01 00       	mov    $0x1b90c,%eax
   14ef2:	e9 3f 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   14ef7:	b8 44 b9 01 00       	mov    $0x1b944,%eax
   14efc:	e9 35 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   14f01:	b8 b0 b8 01 00       	mov    $0x1b8b0,%eax
   14f06:	e9 2b 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   14f0b:	b8 7c b9 01 00       	mov    $0x1b97c,%eax
   14f10:	e9 21 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   14f15:	b8 ac b9 01 00       	mov    $0x1b9ac,%eax
   14f1a:	e9 17 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   14f1f:	b8 cc b9 01 00       	mov    $0x1b9cc,%eax
   14f24:	e9 0d 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   14f29:	b8 f8 b9 01 00       	mov    $0x1b9f8,%eax
   14f2e:	e9 03 03 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   14f33:	b8 38 ba 01 00       	mov    $0x1ba38,%eax
   14f38:	e9 f9 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   14f3d:	b8 60 ba 01 00       	mov    $0x1ba60,%eax
   14f42:	e9 ef 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   14f47:	b8 94 ba 01 00       	mov    $0x1ba94,%eax
   14f4c:	e9 e5 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   14f51:	b8 b8 ba 01 00       	mov    $0x1bab8,%eax
   14f56:	e9 db 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   14f5b:	b8 f0 ba 01 00       	mov    $0x1baf0,%eax
   14f60:	e9 d1 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   14f65:	b8 10 bb 01 00       	mov    $0x1bb10,%eax
   14f6a:	e9 c7 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   14f6f:	b8 2f bb 01 00       	mov    $0x1bb2f,%eax
   14f74:	e9 bd 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   14f79:	b8 49 bb 01 00       	mov    $0x1bb49,%eax
   14f7e:	e9 b3 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   14f83:	b8 68 bb 01 00       	mov    $0x1bb68,%eax
   14f88:	e9 a9 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   14f8d:	b8 a4 bb 01 00       	mov    $0x1bba4,%eax
   14f92:	e9 9f 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   14f97:	b8 c8 bb 01 00       	mov    $0x1bbc8,%eax
   14f9c:	e9 95 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   14fa1:	b8 f4 bb 01 00       	mov    $0x1bbf4,%eax
   14fa6:	e9 8b 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   14fab:	b8 18 bc 01 00       	mov    $0x1bc18,%eax
   14fb0:	e9 81 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   14fb5:	b8 58 bc 01 00       	mov    $0x1bc58,%eax
   14fba:	e9 77 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   14fbf:	b8 88 bc 01 00       	mov    $0x1bc88,%eax
   14fc4:	e9 6d 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   14fc9:	b8 b0 bc 01 00       	mov    $0x1bcb0,%eax
   14fce:	e9 63 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   14fd3:	b8 f4 bc 01 00       	mov    $0x1bcf4,%eax
   14fd8:	e9 59 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   14fdd:	b8 20 bd 01 00       	mov    $0x1bd20,%eax
   14fe2:	e9 4f 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   14fe7:	b8 50 bd 01 00       	mov    $0x1bd50,%eax
   14fec:	e9 45 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   14ff1:	b8 78 bd 01 00       	mov    $0x1bd78,%eax
   14ff6:	e9 3b 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   14ffb:	b8 c0 bd 01 00       	mov    $0x1bdc0,%eax
   15000:	e9 31 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   15005:	b8 c0 bd 01 00       	mov    $0x1bdc0,%eax
   1500a:	e9 27 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   1500f:	b8 fc bd 01 00       	mov    $0x1bdfc,%eax
   15014:	e9 1d 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   15019:	b8 30 be 01 00       	mov    $0x1be30,%eax
   1501e:	e9 13 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   15023:	b8 53 be 01 00       	mov    $0x1be53,%eax
   15028:	e9 09 02 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   1502d:	b8 70 be 01 00       	mov    $0x1be70,%eax
   15032:	e9 ff 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   15037:	b8 ac be 01 00       	mov    $0x1beac,%eax
   1503c:	e9 f5 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   15041:	b8 dc be 01 00       	mov    $0x1bedc,%eax
   15046:	e9 eb 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   1504b:	b8 28 bf 01 00       	mov    $0x1bf28,%eax
   15050:	e9 e1 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   15055:	b8 60 bf 01 00       	mov    $0x1bf60,%eax
   1505a:	e9 d7 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   1505f:	b8 a0 bf 01 00       	mov    $0x1bfa0,%eax
   15064:	e9 cd 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   15069:	b8 cc bf 01 00       	mov    $0x1bfcc,%eax
   1506e:	e9 c3 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   15073:	b8 18 c0 01 00       	mov    $0x1c018,%eax
   15078:	e9 b9 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   1507d:	b8 6c c0 01 00       	mov    $0x1c06c,%eax
   15082:	e9 af 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   15087:	b8 a0 c0 01 00       	mov    $0x1c0a0,%eax
   1508c:	e9 a5 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   15091:	b8 f0 c0 01 00       	mov    $0x1c0f0,%eax
   15096:	e9 9b 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   1509b:	b8 2c c1 01 00       	mov    $0x1c12c,%eax
   150a0:	e9 91 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   150a5:	b8 8c c1 01 00       	mov    $0x1c18c,%eax
   150aa:	e9 87 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   150af:	b8 ec c1 01 00       	mov    $0x1c1ec,%eax
   150b4:	e9 7d 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   150b9:	b8 48 c2 01 00       	mov    $0x1c248,%eax
   150be:	e9 73 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   150c3:	b8 8c c2 01 00       	mov    $0x1c28c,%eax
   150c8:	e9 69 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   150cd:	b8 c8 c2 01 00       	mov    $0x1c2c8,%eax
   150d2:	e9 5f 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   150d7:	b8 25 c3 01 00       	mov    $0x1c325,%eax
   150dc:	e9 55 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   150e1:	b8 3d c3 01 00       	mov    $0x1c33d,%eax
   150e6:	e9 4b 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   150eb:	b8 58 c3 01 00       	mov    $0x1c358,%eax
   150f0:	e9 41 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   150f5:	b8 94 c3 01 00       	mov    $0x1c394,%eax
   150fa:	e9 37 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   150ff:	b8 c4 c3 01 00       	mov    $0x1c3c4,%eax
   15104:	e9 2d 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   15109:	b8 e4 c3 01 00       	mov    $0x1c3e4,%eax
   1510e:	e9 23 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   15113:	b8 04 c4 01 00       	mov    $0x1c404,%eax
   15118:	e9 19 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   1511d:	b8 24 c4 01 00       	mov    $0x1c424,%eax
   15122:	e9 0f 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   15127:	b8 48 c4 01 00       	mov    $0x1c448,%eax
   1512c:	e9 05 01 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   15131:	b8 70 c4 01 00       	mov    $0x1c470,%eax
   15136:	e9 fb 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   1513b:	b8 cd c4 01 00       	mov    $0x1c4cd,%eax
   15140:	e9 f1 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   15145:	b8 e8 c4 01 00       	mov    $0x1c4e8,%eax
   1514a:	e9 e7 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   1514f:	b8 24 c5 01 00       	mov    $0x1c524,%eax
   15154:	e9 dd 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   15159:	b8 58 c5 01 00       	mov    $0x1c558,%eax
   1515e:	e9 d3 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   15163:	b8 ac c5 01 00       	mov    $0x1c5ac,%eax
   15168:	e9 c9 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   1516d:	b8 f8 c5 01 00       	mov    $0x1c5f8,%eax
   15172:	e9 bf 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   15177:	b8 34 c6 01 00       	mov    $0x1c634,%eax
   1517c:	e9 b5 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   15181:	b8 58 c6 01 00       	mov    $0x1c658,%eax
   15186:	e9 ab 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   1518b:	b8 78 c6 01 00       	mov    $0x1c678,%eax
   15190:	e9 a1 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   15195:	b8 a0 c6 01 00       	mov    $0x1c6a0,%eax
   1519a:	e9 97 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   1519f:	b8 c0 c6 01 00       	mov    $0x1c6c0,%eax
   151a4:	e9 8d 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   151a9:	b8 ec c6 01 00       	mov    $0x1c6ec,%eax
   151ae:	e9 83 00 00 00       	jmp    15236 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   151b3:	b8 1b c7 01 00       	mov    $0x1c71b,%eax
   151b8:	eb 7c                	jmp    15236 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   151ba:	b8 33 c7 01 00       	mov    $0x1c733,%eax
   151bf:	eb 75                	jmp    15236 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   151c1:	b8 4b c7 01 00       	mov    $0x1c74b,%eax
   151c6:	eb 6e                	jmp    15236 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   151c8:	b8 63 c7 01 00       	mov    $0x1c763,%eax
   151cd:	eb 67                	jmp    15236 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   151cf:	b8 84 c7 01 00       	mov    $0x1c784,%eax
   151d4:	eb 60                	jmp    15236 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   151d6:	b8 d4 c7 01 00       	mov    $0x1c7d4,%eax
   151db:	eb 59                	jmp    15236 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   151dd:	b8 28 c8 01 00       	mov    $0x1c828,%eax
   151e2:	eb 52                	jmp    15236 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   151e4:	b8 7c c8 01 00       	mov    $0x1c87c,%eax
   151e9:	eb 4b                	jmp    15236 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   151eb:	b8 c4 c8 01 00       	mov    $0x1c8c4,%eax
   151f0:	eb 44                	jmp    15236 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   151f2:	b8 08 c9 01 00       	mov    $0x1c908,%eax
   151f7:	eb 3d                	jmp    15236 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   151f9:	b8 24 c9 01 00       	mov    $0x1c924,%eax
   151fe:	eb 36                	jmp    15236 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   15200:	b8 5c c9 01 00       	mov    $0x1c95c,%eax
   15205:	eb 2f                	jmp    15236 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   15207:	b8 b0 c9 01 00       	mov    $0x1c9b0,%eax
   1520c:	eb 28                	jmp    15236 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   1520e:	b8 e0 c9 01 00       	mov    $0x1c9e0,%eax
   15213:	eb 21                	jmp    15236 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   15215:	b8 30 ca 01 00       	mov    $0x1ca30,%eax
   1521a:	eb 1a                	jmp    15236 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   1521c:	b8 5c ca 01 00       	mov    $0x1ca5c,%eax
   15221:	eb 13                	jmp    15236 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   15223:	b8 88 ca 01 00       	mov    $0x1ca88,%eax
   15228:	eb 0c                	jmp    15236 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   1522a:	b8 ac ca 01 00       	mov    $0x1caac,%eax
   1522f:	eb 05                	jmp    15236 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   15231:	b8 cb ca 01 00       	mov    $0x1cacb,%eax
}
   15236:	5d                   	pop    %ebp
   15237:	c3                   	ret    

00015238 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   15238:	55                   	push   %ebp
   15239:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   1523b:	8b 45 08             	mov    0x8(%ebp),%eax
   1523e:	8b 40 28             	mov    0x28(%eax),%eax
   15241:	83 f8 01             	cmp    $0x1,%eax
   15244:	75 08                	jne    1524e <GetImage+0x16>
   15246:	8b 45 08             	mov    0x8(%ebp),%eax
   15249:	8b 40 54             	mov    0x54(%eax),%eax
   1524c:	eb 09                	jmp    15257 <GetImage+0x1f>
   1524e:	8b 45 08             	mov    0x8(%ebp),%eax
   15251:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   15257:	5d                   	pop    %ebp
   15258:	c3                   	ret    

00015259 <GetWidth>:

int GetWidth(Context* ctx){
   15259:	55                   	push   %ebp
   1525a:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   1525c:	8b 45 08             	mov    0x8(%ebp),%eax
   1525f:	8b 40 10             	mov    0x10(%eax),%eax
}
   15262:	5d                   	pop    %ebp
   15263:	c3                   	ret    

00015264 <GetHeight>:

int GetHeight(Context* ctx){
   15264:	55                   	push   %ebp
   15265:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   15267:	8b 45 08             	mov    0x8(%ebp),%eax
   1526a:	8b 40 14             	mov    0x14(%eax),%eax
}
   1526d:	5d                   	pop    %ebp
   1526e:	c3                   	ret    

0001526f <GetImageSize>:

uint GetImageSize(Context* ctx){
   1526f:	55                   	push   %ebp
   15270:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   15272:	8b 45 08             	mov    0x8(%ebp),%eax
   15275:	8b 50 10             	mov    0x10(%eax),%edx
   15278:	8b 45 08             	mov    0x8(%ebp),%eax
   1527b:	8b 40 14             	mov    0x14(%eax),%eax
   1527e:	0f af d0             	imul   %eax,%edx
   15281:	8b 45 08             	mov    0x8(%ebp),%eax
   15284:	8b 40 28             	mov    0x28(%eax),%eax
   15287:	0f af c2             	imul   %edx,%eax
}
   1528a:	5d                   	pop    %ebp
   1528b:	c3                   	ret    

0001528c <_Clip>:

uchar _Clip(const int x){
   1528c:	55                   	push   %ebp
   1528d:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   1528f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   15293:	78 15                	js     152aa <_Clip+0x1e>
   15295:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   1529c:	7f 05                	jg     152a3 <_Clip+0x17>
   1529e:	8b 45 08             	mov    0x8(%ebp),%eax
   152a1:	eb 0c                	jmp    152af <_Clip+0x23>
   152a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   152a8:	eb 05                	jmp    152af <_Clip+0x23>
   152aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   152af:	5d                   	pop    %ebp
   152b0:	c3                   	ret    

000152b1 <_Skip>:

void _Skip(Context* ctx, int c){
   152b1:	55                   	push   %ebp
   152b2:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   152b4:	8b 45 08             	mov    0x8(%ebp),%eax
   152b7:	8b 50 04             	mov    0x4(%eax),%edx
   152ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   152bd:	01 c2                	add    %eax,%edx
   152bf:	8b 45 08             	mov    0x8(%ebp),%eax
   152c2:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   152c5:	8b 45 08             	mov    0x8(%ebp),%eax
   152c8:	8b 40 08             	mov    0x8(%eax),%eax
   152cb:	2b 45 0c             	sub    0xc(%ebp),%eax
   152ce:	89 c2                	mov    %eax,%edx
   152d0:	8b 45 08             	mov    0x8(%ebp),%eax
   152d3:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   152d6:	8b 45 08             	mov    0x8(%ebp),%eax
   152d9:	8b 40 0c             	mov    0xc(%eax),%eax
   152dc:	2b 45 0c             	sub    0xc(%ebp),%eax
   152df:	89 c2                	mov    %eax,%edx
   152e1:	8b 45 08             	mov    0x8(%ebp),%eax
   152e4:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   152e7:	8b 45 08             	mov    0x8(%ebp),%eax
   152ea:	8b 40 08             	mov    0x8(%eax),%eax
   152ed:	85 c0                	test   %eax,%eax
   152ef:	79 09                	jns    152fa <_Skip+0x49>
   152f1:	8b 45 08             	mov    0x8(%ebp),%eax
   152f4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   152fa:	90                   	nop
   152fb:	5d                   	pop    %ebp
   152fc:	c3                   	ret    

000152fd <_DecodeLength>:

void _DecodeLength(Context* ctx){
   152fd:	55                   	push   %ebp
   152fe:	89 e5                	mov    %esp,%ebp
   15300:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   15303:	8b 45 08             	mov    0x8(%ebp),%eax
   15306:	8b 40 08             	mov    0x8(%eax),%eax
   15309:	83 f8 01             	cmp    $0x1,%eax
   1530c:	7f 0b                	jg     15319 <_DecodeLength+0x1c>
   1530e:	8b 45 08             	mov    0x8(%ebp),%eax
   15311:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15317:	eb 45                	jmp    1535e <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   15319:	8b 45 08             	mov    0x8(%ebp),%eax
   1531c:	8b 40 04             	mov    0x4(%eax),%eax
   1531f:	83 ec 0c             	sub    $0xc,%esp
   15322:	50                   	push   %eax
   15323:	e8 38 00 00 00       	call   15360 <_Decode2Bytes>
   15328:	83 c4 10             	add    $0x10,%esp
   1532b:	89 c2                	mov    %eax,%edx
   1532d:	8b 45 08             	mov    0x8(%ebp),%eax
   15330:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   15333:	8b 45 08             	mov    0x8(%ebp),%eax
   15336:	8b 50 0c             	mov    0xc(%eax),%edx
   15339:	8b 45 08             	mov    0x8(%ebp),%eax
   1533c:	8b 40 08             	mov    0x8(%eax),%eax
   1533f:	39 c2                	cmp    %eax,%edx
   15341:	7e 0b                	jle    1534e <_DecodeLength+0x51>
   15343:	8b 45 08             	mov    0x8(%ebp),%eax
   15346:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1534c:	eb 10                	jmp    1535e <_DecodeLength+0x61>
    _Skip(ctx, 2);
   1534e:	83 ec 08             	sub    $0x8,%esp
   15351:	6a 02                	push   $0x2
   15353:	ff 75 08             	pushl  0x8(%ebp)
   15356:	e8 56 ff ff ff       	call   152b1 <_Skip>
   1535b:	83 c4 10             	add    $0x10,%esp
}
   1535e:	c9                   	leave  
   1535f:	c3                   	ret    

00015360 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   15360:	55                   	push   %ebp
   15361:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   15363:	8b 45 08             	mov    0x8(%ebp),%eax
   15366:	0f b6 00             	movzbl (%eax),%eax
   15369:	0f b6 c0             	movzbl %al,%eax
   1536c:	c1 e0 08             	shl    $0x8,%eax
   1536f:	89 c2                	mov    %eax,%edx
   15371:	8b 45 08             	mov    0x8(%ebp),%eax
   15374:	83 c0 01             	add    $0x1,%eax
   15377:	0f b6 00             	movzbl (%eax),%eax
   1537a:	0f b6 c0             	movzbl %al,%eax
   1537d:	09 d0                	or     %edx,%eax
}
   1537f:	5d                   	pop    %ebp
   15380:	c3                   	ret    

00015381 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   15381:	55                   	push   %ebp
   15382:	89 e5                	mov    %esp,%ebp
   15384:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   15387:	8b 45 08             	mov    0x8(%ebp),%eax
   1538a:	8b 55 10             	mov    0x10(%ebp),%edx
   1538d:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   15390:	8b 45 14             	mov    0x14(%ebp),%eax
   15393:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   15398:	89 c2                	mov    %eax,%edx
   1539a:	8b 45 08             	mov    0x8(%ebp),%eax
   1539d:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   153a0:	8b 45 08             	mov    0x8(%ebp),%eax
   153a3:	8b 40 08             	mov    0x8(%eax),%eax
   153a6:	83 f8 01             	cmp    $0x1,%eax
   153a9:	7e 1d                	jle    153c8 <_DecodeJPEG+0x47>
   153ab:	8b 45 08             	mov    0x8(%ebp),%eax
   153ae:	8b 40 04             	mov    0x4(%eax),%eax
   153b1:	0f b6 00             	movzbl (%eax),%eax
   153b4:	3c ff                	cmp    $0xff,%al
   153b6:	75 10                	jne    153c8 <_DecodeJPEG+0x47>
   153b8:	8b 45 08             	mov    0x8(%ebp),%eax
   153bb:	8b 40 04             	mov    0x4(%eax),%eax
   153be:	83 c0 01             	add    $0x1,%eax
   153c1:	0f b6 00             	movzbl (%eax),%eax
   153c4:	3c d8                	cmp    $0xd8,%al
   153c6:	74 0a                	je     153d2 <_DecodeJPEG+0x51>
   153c8:	b8 01 00 00 00       	mov    $0x1,%eax
   153cd:	e9 56 01 00 00       	jmp    15528 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   153d2:	6a 02                	push   $0x2
   153d4:	ff 75 08             	pushl  0x8(%ebp)
   153d7:	e8 d5 fe ff ff       	call   152b1 <_Skip>
   153dc:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   153df:	e9 0a 01 00 00       	jmp    154ee <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   153e4:	8b 45 08             	mov    0x8(%ebp),%eax
   153e7:	8b 40 08             	mov    0x8(%eax),%eax
   153ea:	85 c0                	test   %eax,%eax
   153ec:	78 0d                	js     153fb <_DecodeJPEG+0x7a>
   153ee:	8b 45 08             	mov    0x8(%ebp),%eax
   153f1:	8b 40 04             	mov    0x4(%eax),%eax
   153f4:	0f b6 00             	movzbl (%eax),%eax
   153f7:	3c ff                	cmp    $0xff,%al
   153f9:	74 0a                	je     15405 <_DecodeJPEG+0x84>
   153fb:	b8 05 00 00 00       	mov    $0x5,%eax
   15400:	e9 23 01 00 00       	jmp    15528 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   15405:	6a 02                	push   $0x2
   15407:	ff 75 08             	pushl  0x8(%ebp)
   1540a:	e8 a2 fe ff ff       	call   152b1 <_Skip>
   1540f:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   15412:	8b 45 08             	mov    0x8(%ebp),%eax
   15415:	8b 40 04             	mov    0x4(%eax),%eax
   15418:	83 e8 01             	sub    $0x1,%eax
   1541b:	0f b6 00             	movzbl (%eax),%eax
   1541e:	0f b6 c0             	movzbl %al,%eax
   15421:	3d da 00 00 00       	cmp    $0xda,%eax
   15426:	74 71                	je     15499 <_DecodeJPEG+0x118>
   15428:	3d da 00 00 00       	cmp    $0xda,%eax
   1542d:	7f 10                	jg     1543f <_DecodeJPEG+0xbe>
   1542f:	3d c0 00 00 00       	cmp    $0xc0,%eax
   15434:	74 20                	je     15456 <_DecodeJPEG+0xd5>
   15436:	3d c4 00 00 00       	cmp    $0xc4,%eax
   1543b:	74 2c                	je     15469 <_DecodeJPEG+0xe8>
   1543d:	eb 7d                	jmp    154bc <_DecodeJPEG+0x13b>
   1543f:	3d dd 00 00 00       	cmp    $0xdd,%eax
   15444:	74 43                	je     15489 <_DecodeJPEG+0x108>
   15446:	3d fe 00 00 00       	cmp    $0xfe,%eax
   1544b:	74 5f                	je     154ac <_DecodeJPEG+0x12b>
   1544d:	3d db 00 00 00       	cmp    $0xdb,%eax
   15452:	74 25                	je     15479 <_DecodeJPEG+0xf8>
   15454:	eb 66                	jmp    154bc <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   15456:	83 ec 0c             	sub    $0xc,%esp
   15459:	ff 75 08             	pushl  0x8(%ebp)
   1545c:	e8 c9 00 00 00       	call   1552a <_DecodeSOF>
   15461:	83 c4 10             	add    $0x10,%esp
   15464:	e9 85 00 00 00       	jmp    154ee <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   15469:	83 ec 0c             	sub    $0xc,%esp
   1546c:	ff 75 08             	pushl  0x8(%ebp)
   1546f:	e8 28 05 00 00       	call   1599c <_DecodeDHT>
   15474:	83 c4 10             	add    $0x10,%esp
   15477:	eb 75                	jmp    154ee <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   15479:	83 ec 0c             	sub    $0xc,%esp
   1547c:	ff 75 08             	pushl  0x8(%ebp)
   1547f:	e8 05 07 00 00       	call   15b89 <_DecodeDQT>
   15484:	83 c4 10             	add    $0x10,%esp
   15487:	eb 65                	jmp    154ee <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   15489:	83 ec 0c             	sub    $0xc,%esp
   1548c:	ff 75 08             	pushl  0x8(%ebp)
   1548f:	e8 ff 07 00 00       	call   15c93 <_DecodeDRI>
   15494:	83 c4 10             	add    $0x10,%esp
   15497:	eb 55                	jmp    154ee <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   15499:	83 ec 08             	sub    $0x8,%esp
   1549c:	ff 75 0c             	pushl  0xc(%ebp)
   1549f:	ff 75 08             	pushl  0x8(%ebp)
   154a2:	e8 56 08 00 00       	call   15cfd <_DecodeSOS>
   154a7:	83 c4 10             	add    $0x10,%esp
   154aa:	eb 42                	jmp    154ee <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   154ac:	83 ec 0c             	sub    $0xc,%esp
   154af:	ff 75 08             	pushl  0x8(%ebp)
   154b2:	e8 a8 15 00 00       	call   16a5f <_SkipMarker>
   154b7:	83 c4 10             	add    $0x10,%esp
   154ba:	eb 32                	jmp    154ee <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   154bc:	8b 45 08             	mov    0x8(%ebp),%eax
   154bf:	8b 40 04             	mov    0x4(%eax),%eax
   154c2:	83 e8 01             	sub    $0x1,%eax
   154c5:	0f b6 00             	movzbl (%eax),%eax
   154c8:	0f b6 c0             	movzbl %al,%eax
   154cb:	25 f0 00 00 00       	and    $0xf0,%eax
   154d0:	3d e0 00 00 00       	cmp    $0xe0,%eax
   154d5:	75 10                	jne    154e7 <_DecodeJPEG+0x166>
   154d7:	83 ec 0c             	sub    $0xc,%esp
   154da:	ff 75 08             	pushl  0x8(%ebp)
   154dd:	e8 7d 15 00 00       	call   16a5f <_SkipMarker>
   154e2:	83 c4 10             	add    $0x10,%esp
   154e5:	eb 07                	jmp    154ee <_DecodeJPEG+0x16d>
                else return Unsupported;
   154e7:	b8 02 00 00 00       	mov    $0x2,%eax
   154ec:	eb 3a                	jmp    15528 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   154ee:	8b 45 08             	mov    0x8(%ebp),%eax
   154f1:	8b 00                	mov    (%eax),%eax
   154f3:	85 c0                	test   %eax,%eax
   154f5:	0f 84 e9 fe ff ff    	je     153e4 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   154fb:	8b 45 08             	mov    0x8(%ebp),%eax
   154fe:	8b 00                	mov    (%eax),%eax
   15500:	83 f8 06             	cmp    $0x6,%eax
   15503:	74 07                	je     1550c <_DecodeJPEG+0x18b>
   15505:	8b 45 08             	mov    0x8(%ebp),%eax
   15508:	8b 00                	mov    (%eax),%eax
   1550a:	eb 1c                	jmp    15528 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   1550c:	8b 45 08             	mov    0x8(%ebp),%eax
   1550f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   15515:	83 ec 0c             	sub    $0xc,%esp
   15518:	ff 75 08             	pushl  0x8(%ebp)
   1551b:	e8 6b 15 00 00       	call   16a8b <_Convert>
   15520:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   15523:	8b 45 08             	mov    0x8(%ebp),%eax
   15526:	8b 00                	mov    (%eax),%eax
 }
   15528:	c9                   	leave  
   15529:	c3                   	ret    

0001552a <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   1552a:	55                   	push   %ebp
   1552b:	89 e5                	mov    %esp,%ebp
   1552d:	53                   	push   %ebx
   1552e:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   15531:	83 ec 0c             	sub    $0xc,%esp
   15534:	ff 75 08             	pushl  0x8(%ebp)
   15537:	e8 c1 fd ff ff       	call   152fd <_DecodeLength>
   1553c:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   1553f:	8b 45 08             	mov    0x8(%ebp),%eax
   15542:	8b 00                	mov    (%eax),%eax
   15544:	85 c0                	test   %eax,%eax
   15546:	0f 85 4a 04 00 00    	jne    15996 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   1554c:	8b 45 08             	mov    0x8(%ebp),%eax
   1554f:	8b 40 0c             	mov    0xc(%eax),%eax
   15552:	83 f8 08             	cmp    $0x8,%eax
   15555:	7f 0e                	jg     15565 <_DecodeSOF+0x3b>
   15557:	8b 45 08             	mov    0x8(%ebp),%eax
   1555a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15560:	e9 32 04 00 00       	jmp    15997 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   15565:	8b 45 08             	mov    0x8(%ebp),%eax
   15568:	8b 40 04             	mov    0x4(%eax),%eax
   1556b:	0f b6 00             	movzbl (%eax),%eax
   1556e:	3c 08                	cmp    $0x8,%al
   15570:	74 0e                	je     15580 <_DecodeSOF+0x56>
   15572:	8b 45 08             	mov    0x8(%ebp),%eax
   15575:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1557b:	e9 17 04 00 00       	jmp    15997 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   15580:	8b 45 08             	mov    0x8(%ebp),%eax
   15583:	8b 40 04             	mov    0x4(%eax),%eax
   15586:	83 c0 01             	add    $0x1,%eax
   15589:	83 ec 0c             	sub    $0xc,%esp
   1558c:	50                   	push   %eax
   1558d:	e8 ce fd ff ff       	call   15360 <_Decode2Bytes>
   15592:	83 c4 10             	add    $0x10,%esp
   15595:	89 c2                	mov    %eax,%edx
   15597:	8b 45 08             	mov    0x8(%ebp),%eax
   1559a:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   1559d:	8b 45 08             	mov    0x8(%ebp),%eax
   155a0:	8b 40 04             	mov    0x4(%eax),%eax
   155a3:	83 c0 03             	add    $0x3,%eax
   155a6:	83 ec 0c             	sub    $0xc,%esp
   155a9:	50                   	push   %eax
   155aa:	e8 b1 fd ff ff       	call   15360 <_Decode2Bytes>
   155af:	83 c4 10             	add    $0x10,%esp
   155b2:	89 c2                	mov    %eax,%edx
   155b4:	8b 45 08             	mov    0x8(%ebp),%eax
   155b7:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   155ba:	8b 45 08             	mov    0x8(%ebp),%eax
   155bd:	8b 40 04             	mov    0x4(%eax),%eax
   155c0:	83 c0 05             	add    $0x5,%eax
   155c3:	0f b6 00             	movzbl (%eax),%eax
   155c6:	0f b6 d0             	movzbl %al,%edx
   155c9:	8b 45 08             	mov    0x8(%ebp),%eax
   155cc:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   155cf:	83 ec 08             	sub    $0x8,%esp
   155d2:	6a 06                	push   $0x6
   155d4:	ff 75 08             	pushl  0x8(%ebp)
   155d7:	e8 d5 fc ff ff       	call   152b1 <_Skip>
   155dc:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   155df:	8b 45 08             	mov    0x8(%ebp),%eax
   155e2:	8b 40 28             	mov    0x28(%eax),%eax
   155e5:	83 f8 01             	cmp    $0x1,%eax
   155e8:	74 13                	je     155fd <_DecodeSOF+0xd3>
   155ea:	83 f8 03             	cmp    $0x3,%eax
   155ed:	74 0e                	je     155fd <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   155ef:	8b 45 08             	mov    0x8(%ebp),%eax
   155f2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   155f8:	e9 9a 03 00 00       	jmp    15997 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   155fd:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   155fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15601:	8b 48 0c             	mov    0xc(%eax),%ecx
   15604:	8b 45 08             	mov    0x8(%ebp),%eax
   15607:	8b 50 28             	mov    0x28(%eax),%edx
   1560a:	89 d0                	mov    %edx,%eax
   1560c:	01 c0                	add    %eax,%eax
   1560e:	01 d0                	add    %edx,%eax
   15610:	39 c1                	cmp    %eax,%ecx
   15612:	7d 0e                	jge    15622 <_DecodeSOF+0xf8>
   15614:	8b 45 08             	mov    0x8(%ebp),%eax
   15617:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1561d:	e9 75 03 00 00       	jmp    15997 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   15622:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15629:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15630:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15637:	8b 45 08             	mov    0x8(%ebp),%eax
   1563a:	83 c0 2c             	add    $0x2c,%eax
   1563d:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15640:	e9 50 01 00 00       	jmp    15795 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   15645:	8b 45 08             	mov    0x8(%ebp),%eax
   15648:	8b 40 04             	mov    0x4(%eax),%eax
   1564b:	0f b6 00             	movzbl (%eax),%eax
   1564e:	0f b6 d0             	movzbl %al,%edx
   15651:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15654:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   15656:	8b 45 08             	mov    0x8(%ebp),%eax
   15659:	8b 40 04             	mov    0x4(%eax),%eax
   1565c:	83 c0 01             	add    $0x1,%eax
   1565f:	0f b6 00             	movzbl (%eax),%eax
   15662:	c0 e8 04             	shr    $0x4,%al
   15665:	0f b6 d0             	movzbl %al,%edx
   15668:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1566b:	89 50 04             	mov    %edx,0x4(%eax)
   1566e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15671:	8b 40 04             	mov    0x4(%eax),%eax
   15674:	85 c0                	test   %eax,%eax
   15676:	75 0e                	jne    15686 <_DecodeSOF+0x15c>
   15678:	8b 45 08             	mov    0x8(%ebp),%eax
   1567b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15681:	e9 11 03 00 00       	jmp    15997 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   15686:	8b 45 08             	mov    0x8(%ebp),%eax
   15689:	8b 40 04             	mov    0x4(%eax),%eax
   1568c:	83 c0 01             	add    $0x1,%eax
   1568f:	0f b6 00             	movzbl (%eax),%eax
   15692:	0f b6 c0             	movzbl %al,%eax
   15695:	83 e0 0f             	and    $0xf,%eax
   15698:	89 c2                	mov    %eax,%edx
   1569a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1569d:	89 50 08             	mov    %edx,0x8(%eax)
   156a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   156a3:	8b 40 08             	mov    0x8(%eax),%eax
   156a6:	85 c0                	test   %eax,%eax
   156a8:	75 0e                	jne    156b8 <_DecodeSOF+0x18e>
   156aa:	8b 45 08             	mov    0x8(%ebp),%eax
   156ad:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   156b3:	e9 df 02 00 00       	jmp    15997 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   156b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   156bb:	8b 50 04             	mov    0x4(%eax),%edx
   156be:	8b 45 e8             	mov    -0x18(%ebp),%eax
   156c1:	8b 40 04             	mov    0x4(%eax),%eax
   156c4:	83 e8 01             	sub    $0x1,%eax
   156c7:	21 d0                	and    %edx,%eax
   156c9:	85 c0                	test   %eax,%eax
   156cb:	74 0e                	je     156db <_DecodeSOF+0x1b1>
   156cd:	8b 45 08             	mov    0x8(%ebp),%eax
   156d0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   156d6:	e9 bc 02 00 00       	jmp    15997 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   156db:	8b 45 e8             	mov    -0x18(%ebp),%eax
   156de:	8b 50 08             	mov    0x8(%eax),%edx
   156e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   156e4:	8b 40 08             	mov    0x8(%eax),%eax
   156e7:	83 e8 01             	sub    $0x1,%eax
   156ea:	21 d0                	and    %edx,%eax
   156ec:	85 c0                	test   %eax,%eax
   156ee:	74 0e                	je     156fe <_DecodeSOF+0x1d4>
   156f0:	8b 45 08             	mov    0x8(%ebp),%eax
   156f3:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   156f9:	e9 99 02 00 00       	jmp    15997 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   156fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15701:	8b 40 04             	mov    0x4(%eax),%eax
   15704:	83 c0 02             	add    $0x2,%eax
   15707:	0f b6 00             	movzbl (%eax),%eax
   1570a:	0f b6 d0             	movzbl %al,%edx
   1570d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15710:	89 50 18             	mov    %edx,0x18(%eax)
   15713:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15716:	8b 40 18             	mov    0x18(%eax),%eax
   15719:	25 fc 00 00 00       	and    $0xfc,%eax
   1571e:	85 c0                	test   %eax,%eax
   15720:	74 0e                	je     15730 <_DecodeSOF+0x206>
   15722:	8b 45 08             	mov    0x8(%ebp),%eax
   15725:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1572b:	e9 67 02 00 00       	jmp    15997 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   15730:	83 ec 08             	sub    $0x8,%esp
   15733:	6a 03                	push   $0x3
   15735:	ff 75 08             	pushl  0x8(%ebp)
   15738:	e8 74 fb ff ff       	call   152b1 <_Skip>
   1573d:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   15740:	8b 45 08             	mov    0x8(%ebp),%eax
   15743:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   15749:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1574c:	8b 40 18             	mov    0x18(%eax),%eax
   1574f:	bb 01 00 00 00       	mov    $0x1,%ebx
   15754:	89 c1                	mov    %eax,%ecx
   15756:	d3 e3                	shl    %cl,%ebx
   15758:	89 d8                	mov    %ebx,%eax
   1575a:	09 c2                	or     %eax,%edx
   1575c:	8b 45 08             	mov    0x8(%ebp),%eax
   1575f:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   15765:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15768:	8b 40 04             	mov    0x4(%eax),%eax
   1576b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1576e:	7e 09                	jle    15779 <_DecodeSOF+0x24f>
   15770:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15773:	8b 40 04             	mov    0x4(%eax),%eax
   15776:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   15779:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1577c:	8b 40 08             	mov    0x8(%eax),%eax
   1577f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   15782:	7e 09                	jle    1578d <_DecodeSOF+0x263>
   15784:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15787:	8b 40 08             	mov    0x8(%eax),%eax
   1578a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1578d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15791:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   15795:	8b 45 08             	mov    0x8(%ebp),%eax
   15798:	8b 40 28             	mov    0x28(%eax),%eax
   1579b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1579e:	0f 8f a1 fe ff ff    	jg     15645 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   157a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157a7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   157ae:	8b 45 08             	mov    0x8(%ebp),%eax
   157b1:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   157b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157b7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   157be:	8b 45 08             	mov    0x8(%ebp),%eax
   157c1:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   157c4:	8b 45 08             	mov    0x8(%ebp),%eax
   157c7:	8b 50 10             	mov    0x10(%eax),%edx
   157ca:	8b 45 08             	mov    0x8(%ebp),%eax
   157cd:	8b 40 20             	mov    0x20(%eax),%eax
   157d0:	01 d0                	add    %edx,%eax
   157d2:	8d 48 ff             	lea    -0x1(%eax),%ecx
   157d5:	8b 45 08             	mov    0x8(%ebp),%eax
   157d8:	8b 58 20             	mov    0x20(%eax),%ebx
   157db:	89 c8                	mov    %ecx,%eax
   157dd:	99                   	cltd   
   157de:	f7 fb                	idiv   %ebx
   157e0:	89 c2                	mov    %eax,%edx
   157e2:	8b 45 08             	mov    0x8(%ebp),%eax
   157e5:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   157e8:	8b 45 08             	mov    0x8(%ebp),%eax
   157eb:	8b 50 14             	mov    0x14(%eax),%edx
   157ee:	8b 45 08             	mov    0x8(%ebp),%eax
   157f1:	8b 40 24             	mov    0x24(%eax),%eax
   157f4:	01 d0                	add    %edx,%eax
   157f6:	8d 48 ff             	lea    -0x1(%eax),%ecx
   157f9:	8b 45 08             	mov    0x8(%ebp),%eax
   157fc:	8b 58 24             	mov    0x24(%eax),%ebx
   157ff:	89 c8                	mov    %ecx,%eax
   15801:	99                   	cltd   
   15802:	f7 fb                	idiv   %ebx
   15804:	89 c2                	mov    %eax,%edx
   15806:	8b 45 08             	mov    0x8(%ebp),%eax
   15809:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1580c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15813:	8b 45 08             	mov    0x8(%ebp),%eax
   15816:	83 c0 2c             	add    $0x2c,%eax
   15819:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1581c:	e9 fd 00 00 00       	jmp    1591e <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   15821:	8b 45 08             	mov    0x8(%ebp),%eax
   15824:	8b 50 10             	mov    0x10(%eax),%edx
   15827:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1582a:	8b 40 04             	mov    0x4(%eax),%eax
   1582d:	0f af d0             	imul   %eax,%edx
   15830:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15833:	01 d0                	add    %edx,%eax
   15835:	83 e8 01             	sub    $0x1,%eax
   15838:	99                   	cltd   
   15839:	f7 7d ec             	idivl  -0x14(%ebp)
   1583c:	89 c2                	mov    %eax,%edx
   1583e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15841:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   15844:	8b 45 08             	mov    0x8(%ebp),%eax
   15847:	8b 50 14             	mov    0x14(%eax),%edx
   1584a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1584d:	8b 40 08             	mov    0x8(%eax),%eax
   15850:	0f af d0             	imul   %eax,%edx
   15853:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15856:	01 d0                	add    %edx,%eax
   15858:	83 e8 01             	sub    $0x1,%eax
   1585b:	99                   	cltd   
   1585c:	f7 7d f0             	idivl  -0x10(%ebp)
   1585f:	89 c2                	mov    %eax,%edx
   15861:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15864:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   15867:	8b 45 08             	mov    0x8(%ebp),%eax
   1586a:	8b 50 18             	mov    0x18(%eax),%edx
   1586d:	8b 45 08             	mov    0x8(%ebp),%eax
   15870:	8b 40 20             	mov    0x20(%eax),%eax
   15873:	0f af d0             	imul   %eax,%edx
   15876:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15879:	8b 40 04             	mov    0x4(%eax),%eax
   1587c:	0f af c2             	imul   %edx,%eax
   1587f:	99                   	cltd   
   15880:	f7 7d ec             	idivl  -0x14(%ebp)
   15883:	89 c2                	mov    %eax,%edx
   15885:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15888:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   1588b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1588e:	8b 40 0c             	mov    0xc(%eax),%eax
   15891:	83 f8 02             	cmp    $0x2,%eax
   15894:	7f 0b                	jg     158a1 <_DecodeSOF+0x377>
   15896:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15899:	8b 40 04             	mov    0x4(%eax),%eax
   1589c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1589f:	75 16                	jne    158b7 <_DecodeSOF+0x38d>
   158a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   158a4:	8b 40 10             	mov    0x10(%eax),%eax
   158a7:	83 f8 02             	cmp    $0x2,%eax
   158aa:	7f 19                	jg     158c5 <_DecodeSOF+0x39b>
   158ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
   158af:	8b 40 08             	mov    0x8(%eax),%eax
   158b2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   158b5:	74 0e                	je     158c5 <_DecodeSOF+0x39b>
   158b7:	8b 45 08             	mov    0x8(%ebp),%eax
   158ba:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   158c0:	e9 d2 00 00 00       	jmp    15997 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   158c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   158c8:	8b 48 14             	mov    0x14(%eax),%ecx
   158cb:	8b 45 08             	mov    0x8(%ebp),%eax
   158ce:	8b 50 1c             	mov    0x1c(%eax),%edx
   158d1:	8b 45 08             	mov    0x8(%ebp),%eax
   158d4:	8b 40 24             	mov    0x24(%eax),%eax
   158d7:	0f af d0             	imul   %eax,%edx
   158da:	8b 45 e8             	mov    -0x18(%ebp),%eax
   158dd:	8b 40 08             	mov    0x8(%eax),%eax
   158e0:	0f af c2             	imul   %edx,%eax
   158e3:	99                   	cltd   
   158e4:	f7 7d f0             	idivl  -0x10(%ebp)
   158e7:	0f af c1             	imul   %ecx,%eax
   158ea:	83 ec 0c             	sub    $0xc,%esp
   158ed:	50                   	push   %eax
   158ee:	e8 45 c5 fe ff       	call   1e38 <malloc>
   158f3:	83 c4 10             	add    $0x10,%esp
   158f6:	89 c2                	mov    %eax,%edx
   158f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   158fb:	89 50 28             	mov    %edx,0x28(%eax)
   158fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15901:	8b 40 28             	mov    0x28(%eax),%eax
   15904:	85 c0                	test   %eax,%eax
   15906:	75 0e                	jne    15916 <_DecodeSOF+0x3ec>
   15908:	8b 45 08             	mov    0x8(%ebp),%eax
   1590b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15911:	e9 81 00 00 00       	jmp    15997 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   15916:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1591a:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1591e:	8b 45 08             	mov    0x8(%ebp),%eax
   15921:	8b 40 28             	mov    0x28(%eax),%eax
   15924:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15927:	0f 8f f4 fe ff ff    	jg     15821 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   1592d:	8b 45 08             	mov    0x8(%ebp),%eax
   15930:	8b 40 28             	mov    0x28(%eax),%eax
   15933:	83 f8 03             	cmp    $0x3,%eax
   15936:	75 47                	jne    1597f <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   15938:	8b 45 08             	mov    0x8(%ebp),%eax
   1593b:	8b 50 10             	mov    0x10(%eax),%edx
   1593e:	8b 45 08             	mov    0x8(%ebp),%eax
   15941:	8b 40 14             	mov    0x14(%eax),%eax
   15944:	0f af d0             	imul   %eax,%edx
   15947:	8b 45 08             	mov    0x8(%ebp),%eax
   1594a:	8b 40 28             	mov    0x28(%eax),%eax
   1594d:	0f af c2             	imul   %edx,%eax
   15950:	83 ec 0c             	sub    $0xc,%esp
   15953:	50                   	push   %eax
   15954:	e8 df c4 fe ff       	call   1e38 <malloc>
   15959:	83 c4 10             	add    $0x10,%esp
   1595c:	89 c2                	mov    %eax,%edx
   1595e:	8b 45 08             	mov    0x8(%ebp),%eax
   15961:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   15967:	8b 45 08             	mov    0x8(%ebp),%eax
   1596a:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15970:	85 c0                	test   %eax,%eax
   15972:	75 0b                	jne    1597f <_DecodeSOF+0x455>
   15974:	8b 45 08             	mov    0x8(%ebp),%eax
   15977:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1597d:	eb 18                	jmp    15997 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1597f:	8b 45 08             	mov    0x8(%ebp),%eax
   15982:	8b 40 0c             	mov    0xc(%eax),%eax
   15985:	83 ec 08             	sub    $0x8,%esp
   15988:	50                   	push   %eax
   15989:	ff 75 08             	pushl  0x8(%ebp)
   1598c:	e8 20 f9 ff ff       	call   152b1 <_Skip>
   15991:	83 c4 10             	add    $0x10,%esp
   15994:	eb 01                	jmp    15997 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   15996:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   15997:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1599a:	c9                   	leave  
   1599b:	c3                   	ret    

0001599c <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   1599c:	55                   	push   %ebp
   1599d:	89 e5                	mov    %esp,%ebp
   1599f:	53                   	push   %ebx
   159a0:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   159a3:	83 ec 0c             	sub    $0xc,%esp
   159a6:	ff 75 08             	pushl  0x8(%ebp)
   159a9:	e8 4f f9 ff ff       	call   152fd <_DecodeLength>
   159ae:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   159b1:	8b 45 08             	mov    0x8(%ebp),%eax
   159b4:	8b 00                	mov    (%eax),%eax
   159b6:	85 c0                	test   %eax,%eax
   159b8:	0f 85 c5 01 00 00    	jne    15b83 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   159be:	e9 9c 01 00 00       	jmp    15b5f <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   159c3:	8b 45 08             	mov    0x8(%ebp),%eax
   159c6:	8b 40 04             	mov    0x4(%eax),%eax
   159c9:	0f b6 00             	movzbl (%eax),%eax
   159cc:	0f b6 c0             	movzbl %al,%eax
   159cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   159d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159d5:	25 ec 00 00 00       	and    $0xec,%eax
   159da:	85 c0                	test   %eax,%eax
   159dc:	74 0e                	je     159ec <_DecodeDHT+0x50>
   159de:	8b 45 08             	mov    0x8(%ebp),%eax
   159e1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   159e7:	e9 98 01 00 00       	jmp    15b84 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   159ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159ef:	83 e0 02             	and    $0x2,%eax
   159f2:	85 c0                	test   %eax,%eax
   159f4:	74 0e                	je     15a04 <_DecodeDHT+0x68>
   159f6:	8b 45 08             	mov    0x8(%ebp),%eax
   159f9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   159ff:	e9 80 01 00 00       	jmp    15b84 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   15a04:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a07:	c1 f8 03             	sar    $0x3,%eax
   15a0a:	0b 45 f4             	or     -0xc(%ebp),%eax
   15a0d:	83 e0 03             	and    $0x3,%eax
   15a10:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   15a13:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   15a1a:	eb 1c                	jmp    15a38 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   15a1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a1f:	8d 50 ff             	lea    -0x1(%eax),%edx
   15a22:	8b 45 08             	mov    0x8(%ebp),%eax
   15a25:	8b 48 04             	mov    0x4(%eax),%ecx
   15a28:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a2b:	01 c8                	add    %ecx,%eax
   15a2d:	0f b6 00             	movzbl (%eax),%eax
   15a30:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   15a34:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15a38:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   15a3c:	7e de                	jle    15a1c <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   15a3e:	83 ec 08             	sub    $0x8,%esp
   15a41:	6a 11                	push   $0x11
   15a43:	ff 75 08             	pushl  0x8(%ebp)
   15a46:	e8 66 f8 ff ff       	call   152b1 <_Skip>
   15a4b:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   15a4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a51:	c1 e0 11             	shl    $0x11,%eax
   15a54:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   15a5a:	8b 45 08             	mov    0x8(%ebp),%eax
   15a5d:	01 d0                	add    %edx,%eax
   15a5f:	83 c0 08             	add    $0x8,%eax
   15a62:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   15a65:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   15a6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15a6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   15a72:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   15a79:	e9 be 00 00 00       	jmp    15b3c <_DecodeDHT+0x1a0>
            spread >>= 1;
   15a7e:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   15a81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a84:	83 e8 01             	sub    $0x1,%eax
   15a87:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   15a8c:	0f b6 c0             	movzbl %al,%eax
   15a8f:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   15a92:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15a96:	0f 84 9b 00 00 00    	je     15b37 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   15a9c:	8b 45 08             	mov    0x8(%ebp),%eax
   15a9f:	8b 40 0c             	mov    0xc(%eax),%eax
   15aa2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   15aa5:	7d 0e                	jge    15ab5 <_DecodeDHT+0x119>
   15aa7:	8b 45 08             	mov    0x8(%ebp),%eax
   15aaa:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15ab0:	e9 cf 00 00 00       	jmp    15b84 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   15ab5:	b8 10 00 00 00       	mov    $0x10,%eax
   15aba:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15abd:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ac0:	89 c1                	mov    %eax,%ecx
   15ac2:	d3 e2                	shl    %cl,%edx
   15ac4:	89 d0                	mov    %edx,%eax
   15ac6:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   15ac9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15acd:	79 0e                	jns    15add <_DecodeDHT+0x141>
   15acf:	8b 45 08             	mov    0x8(%ebp),%eax
   15ad2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15ad8:	e9 a7 00 00 00       	jmp    15b84 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   15add:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15ae4:	eb 36                	jmp    15b1c <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   15ae6:	8b 45 08             	mov    0x8(%ebp),%eax
   15ae9:	8b 50 04             	mov    0x4(%eax),%edx
   15aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aef:	01 d0                	add    %edx,%eax
   15af1:	0f b6 00             	movzbl (%eax),%eax
   15af4:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   15af6:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   15af9:	eb 14                	jmp    15b0f <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   15afb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15afe:	89 c2                	mov    %eax,%edx
   15b00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b03:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   15b05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b08:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   15b0b:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   15b0f:	89 d8                	mov    %ebx,%eax
   15b11:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15b14:	85 c0                	test   %eax,%eax
   15b16:	75 e3                	jne    15afb <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   15b18:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b1f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   15b22:	7c c2                	jl     15ae6 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   15b24:	83 ec 08             	sub    $0x8,%esp
   15b27:	ff 75 e0             	pushl  -0x20(%ebp)
   15b2a:	ff 75 08             	pushl  0x8(%ebp)
   15b2d:	e8 7f f7 ff ff       	call   152b1 <_Skip>
   15b32:	83 c4 10             	add    $0x10,%esp
   15b35:	eb 01                	jmp    15b38 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   15b37:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   15b38:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15b3c:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   15b40:	0f 8e 38 ff ff ff    	jle    15a7e <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   15b46:	eb 0a                	jmp    15b52 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   15b48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b4b:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   15b4e:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   15b52:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b55:	8d 50 ff             	lea    -0x1(%eax),%edx
   15b58:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15b5b:	85 c0                	test   %eax,%eax
   15b5d:	75 e9                	jne    15b48 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   15b5f:	8b 45 08             	mov    0x8(%ebp),%eax
   15b62:	8b 40 0c             	mov    0xc(%eax),%eax
   15b65:	83 f8 10             	cmp    $0x10,%eax
   15b68:	0f 8f 55 fe ff ff    	jg     159c3 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   15b6e:	8b 45 08             	mov    0x8(%ebp),%eax
   15b71:	8b 40 0c             	mov    0xc(%eax),%eax
   15b74:	85 c0                	test   %eax,%eax
   15b76:	74 0c                	je     15b84 <_DecodeDHT+0x1e8>
   15b78:	8b 45 08             	mov    0x8(%ebp),%eax
   15b7b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15b81:	eb 01                	jmp    15b84 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   15b83:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   15b84:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15b87:	c9                   	leave  
   15b88:	c3                   	ret    

00015b89 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   15b89:	55                   	push   %ebp
   15b8a:	89 e5                	mov    %esp,%ebp
   15b8c:	53                   	push   %ebx
   15b8d:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   15b90:	83 ec 0c             	sub    $0xc,%esp
   15b93:	ff 75 08             	pushl  0x8(%ebp)
   15b96:	e8 62 f7 ff ff       	call   152fd <_DecodeLength>
   15b9b:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   15b9e:	8b 45 08             	mov    0x8(%ebp),%eax
   15ba1:	8b 00                	mov    (%eax),%eax
   15ba3:	85 c0                	test   %eax,%eax
   15ba5:	0f 85 e2 00 00 00    	jne    15c8d <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   15bab:	e9 b8 00 00 00       	jmp    15c68 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   15bb0:	8b 45 08             	mov    0x8(%ebp),%eax
   15bb3:	8b 40 04             	mov    0x4(%eax),%eax
   15bb6:	0f b6 00             	movzbl (%eax),%eax
   15bb9:	0f b6 c0             	movzbl %al,%eax
   15bbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   15bbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bc2:	25 ec 00 00 00       	and    $0xec,%eax
   15bc7:	85 c0                	test   %eax,%eax
   15bc9:	74 0e                	je     15bd9 <_DecodeDQT+0x50>
   15bcb:	8b 45 08             	mov    0x8(%ebp),%eax
   15bce:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15bd4:	e9 b5 00 00 00       	jmp    15c8e <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   15bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bdc:	83 e0 10             	and    $0x10,%eax
   15bdf:	85 c0                	test   %eax,%eax
   15be1:	74 0e                	je     15bf1 <_DecodeDQT+0x68>
   15be3:	8b 45 08             	mov    0x8(%ebp),%eax
   15be6:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   15bec:	e9 9d 00 00 00       	jmp    15c8e <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   15bf1:	8b 45 08             	mov    0x8(%ebp),%eax
   15bf4:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   15bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bfd:	bb 01 00 00 00       	mov    $0x1,%ebx
   15c02:	89 c1                	mov    %eax,%ecx
   15c04:	d3 e3                	shl    %cl,%ebx
   15c06:	89 d8                	mov    %ebx,%eax
   15c08:	09 c2                	or     %eax,%edx
   15c0a:	8b 45 08             	mov    0x8(%ebp),%eax
   15c0d:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   15c13:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c16:	c1 e0 06             	shl    $0x6,%eax
   15c19:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   15c1f:	8b 45 08             	mov    0x8(%ebp),%eax
   15c22:	01 d0                	add    %edx,%eax
   15c24:	83 c0 08             	add    $0x8,%eax
   15c27:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   15c2a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15c31:	eb 1f                	jmp    15c52 <_DecodeDQT+0xc9>
   15c33:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15c36:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c39:	01 c2                	add    %eax,%edx
   15c3b:	8b 45 08             	mov    0x8(%ebp),%eax
   15c3e:	8b 40 04             	mov    0x4(%eax),%eax
   15c41:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15c44:	83 c1 01             	add    $0x1,%ecx
   15c47:	01 c8                	add    %ecx,%eax
   15c49:	0f b6 00             	movzbl (%eax),%eax
   15c4c:	88 02                	mov    %al,(%edx)
   15c4e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15c52:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   15c56:	7e db                	jle    15c33 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   15c58:	83 ec 08             	sub    $0x8,%esp
   15c5b:	6a 41                	push   $0x41
   15c5d:	ff 75 08             	pushl  0x8(%ebp)
   15c60:	e8 4c f6 ff ff       	call   152b1 <_Skip>
   15c65:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   15c68:	8b 45 08             	mov    0x8(%ebp),%eax
   15c6b:	8b 40 0c             	mov    0xc(%eax),%eax
   15c6e:	83 f8 40             	cmp    $0x40,%eax
   15c71:	0f 8f 39 ff ff ff    	jg     15bb0 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   15c77:	8b 45 08             	mov    0x8(%ebp),%eax
   15c7a:	8b 40 0c             	mov    0xc(%eax),%eax
   15c7d:	85 c0                	test   %eax,%eax
   15c7f:	74 0d                	je     15c8e <_DecodeDQT+0x105>
   15c81:	8b 45 08             	mov    0x8(%ebp),%eax
   15c84:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15c8a:	90                   	nop
   15c8b:	eb 01                	jmp    15c8e <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   15c8d:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   15c8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15c91:	c9                   	leave  
   15c92:	c3                   	ret    

00015c93 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   15c93:	55                   	push   %ebp
   15c94:	89 e5                	mov    %esp,%ebp
   15c96:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15c99:	83 ec 0c             	sub    $0xc,%esp
   15c9c:	ff 75 08             	pushl  0x8(%ebp)
   15c9f:	e8 59 f6 ff ff       	call   152fd <_DecodeLength>
   15ca4:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   15ca7:	8b 45 08             	mov    0x8(%ebp),%eax
   15caa:	8b 00                	mov    (%eax),%eax
   15cac:	85 c0                	test   %eax,%eax
   15cae:	75 4a                	jne    15cfa <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   15cb0:	8b 45 08             	mov    0x8(%ebp),%eax
   15cb3:	8b 40 0c             	mov    0xc(%eax),%eax
   15cb6:	83 f8 01             	cmp    $0x1,%eax
   15cb9:	7f 0b                	jg     15cc6 <_DecodeDRI+0x33>
   15cbb:	8b 45 08             	mov    0x8(%ebp),%eax
   15cbe:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15cc4:	eb 35                	jmp    15cfb <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   15cc6:	8b 45 08             	mov    0x8(%ebp),%eax
   15cc9:	8b 40 04             	mov    0x4(%eax),%eax
   15ccc:	83 ec 0c             	sub    $0xc,%esp
   15ccf:	50                   	push   %eax
   15cd0:	e8 8b f6 ff ff       	call   15360 <_Decode2Bytes>
   15cd5:	83 c4 10             	add    $0x10,%esp
   15cd8:	89 c2                	mov    %eax,%edx
   15cda:	8b 45 08             	mov    0x8(%ebp),%eax
   15cdd:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   15ce3:	8b 45 08             	mov    0x8(%ebp),%eax
   15ce6:	8b 40 0c             	mov    0xc(%eax),%eax
   15ce9:	83 ec 08             	sub    $0x8,%esp
   15cec:	50                   	push   %eax
   15ced:	ff 75 08             	pushl  0x8(%ebp)
   15cf0:	e8 bc f5 ff ff       	call   152b1 <_Skip>
   15cf5:	83 c4 10             	add    $0x10,%esp
   15cf8:	eb 01                	jmp    15cfb <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   15cfa:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   15cfb:	c9                   	leave  
   15cfc:	c3                   	ret    

00015cfd <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   15cfd:	55                   	push   %ebp
   15cfe:	89 e5                	mov    %esp,%ebp
   15d00:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   15d03:	8b 45 08             	mov    0x8(%ebp),%eax
   15d06:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   15d0c:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15d0f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   15d16:	83 ec 0c             	sub    $0xc,%esp
   15d19:	ff 75 08             	pushl  0x8(%ebp)
   15d1c:	e8 dc f5 ff ff       	call   152fd <_DecodeLength>
   15d21:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   15d24:	8b 45 08             	mov    0x8(%ebp),%eax
   15d27:	8b 00                	mov    (%eax),%eax
   15d29:	85 c0                	test   %eax,%eax
   15d2b:	0f 85 c2 02 00 00    	jne    15ff3 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   15d31:	8b 45 08             	mov    0x8(%ebp),%eax
   15d34:	8b 50 0c             	mov    0xc(%eax),%edx
   15d37:	8b 45 08             	mov    0x8(%ebp),%eax
   15d3a:	8b 40 28             	mov    0x28(%eax),%eax
   15d3d:	83 c0 02             	add    $0x2,%eax
   15d40:	01 c0                	add    %eax,%eax
   15d42:	39 c2                	cmp    %eax,%edx
   15d44:	7c 16                	jl     15d5c <_DecodeSOS+0x5f>
   15d46:	8b 45 08             	mov    0x8(%ebp),%eax
   15d49:	8b 40 04             	mov    0x4(%eax),%eax
   15d4c:	0f b6 00             	movzbl (%eax),%eax
   15d4f:	0f b6 d0             	movzbl %al,%edx
   15d52:	8b 45 08             	mov    0x8(%ebp),%eax
   15d55:	8b 40 28             	mov    0x28(%eax),%eax
   15d58:	39 c2                	cmp    %eax,%edx
   15d5a:	74 0e                	je     15d6a <_DecodeSOS+0x6d>
   15d5c:	8b 45 08             	mov    0x8(%ebp),%eax
   15d5f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15d65:	e9 8d 02 00 00       	jmp    15ff7 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   15d6a:	83 ec 08             	sub    $0x8,%esp
   15d6d:	6a 01                	push   $0x1
   15d6f:	ff 75 08             	pushl  0x8(%ebp)
   15d72:	e8 3a f5 ff ff       	call   152b1 <_Skip>
   15d77:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15d7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15d81:	8b 45 08             	mov    0x8(%ebp),%eax
   15d84:	83 c0 2c             	add    $0x2c,%eax
   15d87:	89 45 dc             	mov    %eax,-0x24(%ebp)
   15d8a:	e9 ba 00 00 00       	jmp    15e49 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   15d8f:	8b 45 08             	mov    0x8(%ebp),%eax
   15d92:	8b 40 04             	mov    0x4(%eax),%eax
   15d95:	0f b6 00             	movzbl (%eax),%eax
   15d98:	0f b6 d0             	movzbl %al,%edx
   15d9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15d9e:	8b 00                	mov    (%eax),%eax
   15da0:	39 c2                	cmp    %eax,%edx
   15da2:	74 0e                	je     15db2 <_DecodeSOS+0xb5>
   15da4:	8b 45 08             	mov    0x8(%ebp),%eax
   15da7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15dad:	e9 45 02 00 00       	jmp    15ff7 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   15db2:	8b 45 08             	mov    0x8(%ebp),%eax
   15db5:	8b 40 04             	mov    0x4(%eax),%eax
   15db8:	83 c0 01             	add    $0x1,%eax
   15dbb:	0f b6 00             	movzbl (%eax),%eax
   15dbe:	0f b6 c0             	movzbl %al,%eax
   15dc1:	25 ec 00 00 00       	and    $0xec,%eax
   15dc6:	85 c0                	test   %eax,%eax
   15dc8:	74 0e                	je     15dd8 <_DecodeSOS+0xdb>
   15dca:	8b 45 08             	mov    0x8(%ebp),%eax
   15dcd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15dd3:	e9 1f 02 00 00       	jmp    15ff7 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   15dd8:	8b 45 08             	mov    0x8(%ebp),%eax
   15ddb:	8b 40 04             	mov    0x4(%eax),%eax
   15dde:	83 c0 01             	add    $0x1,%eax
   15de1:	0f b6 00             	movzbl (%eax),%eax
   15de4:	0f b6 c0             	movzbl %al,%eax
   15de7:	83 e0 02             	and    $0x2,%eax
   15dea:	85 c0                	test   %eax,%eax
   15dec:	74 0e                	je     15dfc <_DecodeSOS+0xff>
   15dee:	8b 45 08             	mov    0x8(%ebp),%eax
   15df1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   15df7:	e9 fb 01 00 00       	jmp    15ff7 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   15dfc:	8b 45 08             	mov    0x8(%ebp),%eax
   15dff:	8b 40 04             	mov    0x4(%eax),%eax
   15e02:	83 c0 01             	add    $0x1,%eax
   15e05:	0f b6 00             	movzbl (%eax),%eax
   15e08:	c0 e8 04             	shr    $0x4,%al
   15e0b:	0f b6 d0             	movzbl %al,%edx
   15e0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15e11:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   15e14:	8b 45 08             	mov    0x8(%ebp),%eax
   15e17:	8b 40 04             	mov    0x4(%eax),%eax
   15e1a:	83 c0 01             	add    $0x1,%eax
   15e1d:	0f b6 00             	movzbl (%eax),%eax
   15e20:	0f b6 c0             	movzbl %al,%eax
   15e23:	83 e0 01             	and    $0x1,%eax
   15e26:	83 c8 02             	or     $0x2,%eax
   15e29:	89 c2                	mov    %eax,%edx
   15e2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15e2e:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   15e31:	83 ec 08             	sub    $0x8,%esp
   15e34:	6a 02                	push   $0x2
   15e36:	ff 75 08             	pushl  0x8(%ebp)
   15e39:	e8 73 f4 ff ff       	call   152b1 <_Skip>
   15e3e:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15e41:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15e45:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   15e49:	8b 45 08             	mov    0x8(%ebp),%eax
   15e4c:	8b 40 28             	mov    0x28(%eax),%eax
   15e4f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15e52:	0f 8f 37 ff ff ff    	jg     15d8f <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   15e58:	8b 45 08             	mov    0x8(%ebp),%eax
   15e5b:	8b 40 04             	mov    0x4(%eax),%eax
   15e5e:	0f b6 00             	movzbl (%eax),%eax
   15e61:	84 c0                	test   %al,%al
   15e63:	75 10                	jne    15e75 <_DecodeSOS+0x178>
   15e65:	8b 45 08             	mov    0x8(%ebp),%eax
   15e68:	8b 40 04             	mov    0x4(%eax),%eax
   15e6b:	83 c0 01             	add    $0x1,%eax
   15e6e:	0f b6 00             	movzbl (%eax),%eax
   15e71:	3c 3f                	cmp    $0x3f,%al
   15e73:	74 0e                	je     15e83 <_DecodeSOS+0x186>
   15e75:	8b 45 08             	mov    0x8(%ebp),%eax
   15e78:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15e7e:	e9 74 01 00 00       	jmp    15ff7 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   15e83:	8b 45 08             	mov    0x8(%ebp),%eax
   15e86:	8b 40 04             	mov    0x4(%eax),%eax
   15e89:	83 c0 02             	add    $0x2,%eax
   15e8c:	0f b6 00             	movzbl (%eax),%eax
   15e8f:	84 c0                	test   %al,%al
   15e91:	74 0e                	je     15ea1 <_DecodeSOS+0x1a4>
   15e93:	8b 45 08             	mov    0x8(%ebp),%eax
   15e96:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   15e9c:	e9 56 01 00 00       	jmp    15ff7 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   15ea1:	8b 45 08             	mov    0x8(%ebp),%eax
   15ea4:	8b 40 0c             	mov    0xc(%eax),%eax
   15ea7:	83 ec 08             	sub    $0x8,%esp
   15eaa:	50                   	push   %eax
   15eab:	ff 75 08             	pushl  0x8(%ebp)
   15eae:	e8 fe f3 ff ff       	call   152b1 <_Skip>
   15eb3:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   15eb6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15ebd:	e9 17 01 00 00       	jmp    15fd9 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   15ec2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15ec9:	e9 f8 00 00 00       	jmp    15fc6 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   15ece:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15ed5:	8b 45 08             	mov    0x8(%ebp),%eax
   15ed8:	83 c0 2c             	add    $0x2c,%eax
   15edb:	89 45 dc             	mov    %eax,-0x24(%ebp)
   15ede:	e9 8d 00 00 00       	jmp    15f70 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   15ee3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15eea:	eb 71                	jmp    15f5d <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   15eec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   15ef3:	eb 59                	jmp    15f4e <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   15ef5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ef8:	8b 50 28             	mov    0x28(%eax),%edx
   15efb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15efe:	8b 40 08             	mov    0x8(%eax),%eax
   15f01:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15f05:	89 c1                	mov    %eax,%ecx
   15f07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15f0a:	01 c1                	add    %eax,%ecx
   15f0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15f0f:	8b 40 14             	mov    0x14(%eax),%eax
   15f12:	0f af c8             	imul   %eax,%ecx
   15f15:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15f18:	8b 40 04             	mov    0x4(%eax),%eax
   15f1b:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   15f1f:	01 c1                	add    %eax,%ecx
   15f21:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f24:	01 c8                	add    %ecx,%eax
   15f26:	c1 e0 03             	shl    $0x3,%eax
   15f29:	01 d0                	add    %edx,%eax
   15f2b:	50                   	push   %eax
   15f2c:	ff 75 dc             	pushl  -0x24(%ebp)
   15f2f:	ff 75 0c             	pushl  0xc(%ebp)
   15f32:	ff 75 08             	pushl  0x8(%ebp)
   15f35:	e8 bf 00 00 00       	call   15ff9 <_DecodeBlock>
   15f3a:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   15f3d:	8b 45 08             	mov    0x8(%ebp),%eax
   15f40:	8b 00                	mov    (%eax),%eax
   15f42:	85 c0                	test   %eax,%eax
   15f44:	0f 85 ac 00 00 00    	jne    15ff6 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   15f4a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   15f4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15f51:	8b 40 04             	mov    0x4(%eax),%eax
   15f54:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   15f57:	7f 9c                	jg     15ef5 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   15f59:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15f5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15f60:	8b 40 08             	mov    0x8(%eax),%eax
   15f63:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15f66:	7f 84                	jg     15eec <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   15f68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15f6c:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   15f70:	8b 45 08             	mov    0x8(%ebp),%eax
   15f73:	8b 40 28             	mov    0x28(%eax),%eax
   15f76:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15f79:	0f 8f 64 ff ff ff    	jg     15ee3 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   15f7f:	8b 45 08             	mov    0x8(%ebp),%eax
   15f82:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   15f88:	85 c0                	test   %eax,%eax
   15f8a:	74 36                	je     15fc2 <_DecodeSOS+0x2c5>
   15f8c:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   15f90:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15f94:	75 2c                	jne    15fc2 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   15f96:	83 ec 0c             	sub    $0xc,%esp
   15f99:	ff 75 08             	pushl  0x8(%ebp)
   15f9c:	e8 9f 0a 00 00       	call   16a40 <_ByteAlign>
   15fa1:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   15fa4:	83 ec 08             	sub    $0x8,%esp
   15fa7:	6a 10                	push   $0x10
   15fa9:	ff 75 08             	pushl  0x8(%ebp)
   15fac:	e8 ce 04 00 00       	call   1647f <_GetBits>
   15fb1:	83 c4 10             	add    $0x10,%esp
   15fb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   15fb7:	8b 45 08             	mov    0x8(%ebp),%eax
   15fba:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15fc0:	eb 35                	jmp    15ff7 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   15fc2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15fc6:	8b 45 08             	mov    0x8(%ebp),%eax
   15fc9:	8b 40 18             	mov    0x18(%eax),%eax
   15fcc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   15fcf:	0f 8f f9 fe ff ff    	jg     15ece <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   15fd5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15fd9:	8b 45 08             	mov    0x8(%ebp),%eax
   15fdc:	8b 40 1c             	mov    0x1c(%eax),%eax
   15fdf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15fe2:	0f 8f da fe ff ff    	jg     15ec2 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   15fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   15feb:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   15ff1:	eb 04                	jmp    15ff7 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   15ff3:	90                   	nop
   15ff4:	eb 01                	jmp    15ff7 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   15ff6:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   15ff7:	c9                   	leave  
   15ff8:	c3                   	ret    

00015ff9 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   15ff9:	55                   	push   %ebp
   15ffa:	89 e5                	mov    %esp,%ebp
   15ffc:	53                   	push   %ebx
   15ffd:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   16000:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   16007:	8b 45 08             	mov    0x8(%ebp),%eax
   1600a:	05 c0 01 08 00       	add    $0x801c0,%eax
   1600f:	83 ec 04             	sub    $0x4,%esp
   16012:	68 00 01 00 00       	push   $0x100
   16017:	6a 00                	push   $0x0
   16019:	50                   	push   %eax
   1601a:	e8 04 b8 fe ff       	call   1823 <memset>
   1601f:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   16022:	8b 45 10             	mov    0x10(%ebp),%eax
   16025:	8b 40 20             	mov    0x20(%eax),%eax
   16028:	c1 e0 11             	shl    $0x11,%eax
   1602b:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   16031:	8b 45 08             	mov    0x8(%ebp),%eax
   16034:	01 d0                	add    %edx,%eax
   16036:	83 c0 08             	add    $0x8,%eax
   16039:	83 ec 04             	sub    $0x4,%esp
   1603c:	6a 00                	push   $0x0
   1603e:	50                   	push   %eax
   1603f:	ff 75 08             	pushl  0x8(%ebp)
   16042:	e8 86 01 00 00       	call   161cd <_GetVLC>
   16047:	83 c4 10             	add    $0x10,%esp
   1604a:	89 c2                	mov    %eax,%edx
   1604c:	8b 45 10             	mov    0x10(%ebp),%eax
   1604f:	8b 40 24             	mov    0x24(%eax),%eax
   16052:	01 c2                	add    %eax,%edx
   16054:	8b 45 10             	mov    0x10(%ebp),%eax
   16057:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   1605a:	8b 45 10             	mov    0x10(%ebp),%eax
   1605d:	8b 50 24             	mov    0x24(%eax),%edx
   16060:	8b 45 10             	mov    0x10(%ebp),%eax
   16063:	8b 48 18             	mov    0x18(%eax),%ecx
   16066:	8b 45 08             	mov    0x8(%ebp),%eax
   16069:	c1 e1 06             	shl    $0x6,%ecx
   1606c:	01 c8                	add    %ecx,%eax
   1606e:	05 b8 00 00 00       	add    $0xb8,%eax
   16073:	0f b6 00             	movzbl (%eax),%eax
   16076:	0f b6 c0             	movzbl %al,%eax
   16079:	0f af d0             	imul   %eax,%edx
   1607c:	8b 45 08             	mov    0x8(%ebp),%eax
   1607f:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   16085:	8b 45 10             	mov    0x10(%ebp),%eax
   16088:	8b 40 1c             	mov    0x1c(%eax),%eax
   1608b:	c1 e0 11             	shl    $0x11,%eax
   1608e:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   16094:	8b 45 08             	mov    0x8(%ebp),%eax
   16097:	01 d0                	add    %edx,%eax
   16099:	8d 50 08             	lea    0x8(%eax),%edx
   1609c:	83 ec 04             	sub    $0x4,%esp
   1609f:	8d 45 ef             	lea    -0x11(%ebp),%eax
   160a2:	50                   	push   %eax
   160a3:	52                   	push   %edx
   160a4:	ff 75 08             	pushl  0x8(%ebp)
   160a7:	e8 21 01 00 00       	call   161cd <_GetVLC>
   160ac:	83 c4 10             	add    $0x10,%esp
   160af:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   160b2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   160b6:	84 c0                	test   %al,%al
   160b8:	0f 84 92 00 00 00    	je     16150 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   160be:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   160c2:	0f b6 c0             	movzbl %al,%eax
   160c5:	83 e0 0f             	and    $0xf,%eax
   160c8:	85 c0                	test   %eax,%eax
   160ca:	75 16                	jne    160e2 <_DecodeBlock+0xe9>
   160cc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   160d0:	3c f0                	cmp    $0xf0,%al
   160d2:	74 0e                	je     160e2 <_DecodeBlock+0xe9>
   160d4:	8b 45 08             	mov    0x8(%ebp),%eax
   160d7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   160dd:	e9 e6 00 00 00       	jmp    161c8 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   160e2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   160e6:	c0 e8 04             	shr    $0x4,%al
   160e9:	0f b6 c0             	movzbl %al,%eax
   160ec:	83 c0 01             	add    $0x1,%eax
   160ef:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   160f2:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   160f6:	7e 0e                	jle    16106 <_DecodeBlock+0x10d>
   160f8:	8b 45 08             	mov    0x8(%ebp),%eax
   160fb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   16101:	e9 c2 00 00 00       	jmp    161c8 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   16106:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16109:	8b 45 0c             	mov    0xc(%ebp),%eax
   1610c:	01 d0                	add    %edx,%eax
   1610e:	0f b6 00             	movzbl (%eax),%eax
   16111:	0f be c8             	movsbl %al,%ecx
   16114:	8b 45 10             	mov    0x10(%ebp),%eax
   16117:	8b 50 18             	mov    0x18(%eax),%edx
   1611a:	8b 45 08             	mov    0x8(%ebp),%eax
   1611d:	c1 e2 06             	shl    $0x6,%edx
   16120:	01 c2                	add    %eax,%edx
   16122:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16125:	01 d0                	add    %edx,%eax
   16127:	05 b8 00 00 00       	add    $0xb8,%eax
   1612c:	0f b6 00             	movzbl (%eax),%eax
   1612f:	0f b6 c0             	movzbl %al,%eax
   16132:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   16136:	89 c2                	mov    %eax,%edx
   16138:	8b 45 08             	mov    0x8(%ebp),%eax
   1613b:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   16141:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   16144:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   16148:	0f 8e 37 ff ff ff    	jle    16085 <_DecodeBlock+0x8c>
   1614e:	eb 01                	jmp    16151 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   16150:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   16151:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   16158:	eb 24                	jmp    1617e <_DecodeBlock+0x185>
   1615a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1615d:	05 70 00 02 00       	add    $0x20070,%eax
   16162:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   16169:	8b 45 08             	mov    0x8(%ebp),%eax
   1616c:	01 d0                	add    %edx,%eax
   1616e:	83 ec 0c             	sub    $0xc,%esp
   16171:	50                   	push   %eax
   16172:	e8 32 03 00 00       	call   164a9 <_RowIDCT>
   16177:	83 c4 10             	add    $0x10,%esp
   1617a:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   1617e:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   16182:	7e d6                	jle    1615a <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   16184:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1618b:	eb 35                	jmp    161c2 <_DecodeBlock+0x1c9>
   1618d:	8b 45 10             	mov    0x10(%ebp),%eax
   16190:	8b 40 14             	mov    0x14(%eax),%eax
   16193:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   16196:	8b 55 14             	mov    0x14(%ebp),%edx
   16199:	01 d1                	add    %edx,%ecx
   1619b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1619e:	81 c2 70 00 02 00    	add    $0x20070,%edx
   161a4:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   161ab:	8b 55 08             	mov    0x8(%ebp),%edx
   161ae:	01 da                	add    %ebx,%edx
   161b0:	83 ec 04             	sub    $0x4,%esp
   161b3:	50                   	push   %eax
   161b4:	51                   	push   %ecx
   161b5:	52                   	push   %edx
   161b6:	e8 7b 05 00 00       	call   16736 <_ColIDCT>
   161bb:	83 c4 10             	add    $0x10,%esp
   161be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   161c2:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   161c6:	7e c5                	jle    1618d <_DecodeBlock+0x194>
}
   161c8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   161cb:	c9                   	leave  
   161cc:	c3                   	ret    

000161cd <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   161cd:	55                   	push   %ebp
   161ce:	89 e5                	mov    %esp,%ebp
   161d0:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   161d3:	83 ec 08             	sub    $0x8,%esp
   161d6:	6a 10                	push   $0x10
   161d8:	ff 75 08             	pushl  0x8(%ebp)
   161db:	e8 c2 00 00 00       	call   162a2 <_ShowBits>
   161e0:	83 c4 10             	add    $0x10,%esp
   161e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   161e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   161e9:	8d 14 00             	lea    (%eax,%eax,1),%edx
   161ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   161ef:	01 d0                	add    %edx,%eax
   161f1:	0f b6 00             	movzbl (%eax),%eax
   161f4:	0f b6 c0             	movzbl %al,%eax
   161f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   161fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   161fe:	75 13                	jne    16213 <_GetVLC+0x46>
   16200:	8b 45 08             	mov    0x8(%ebp),%eax
   16203:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   16209:	b8 00 00 00 00       	mov    $0x0,%eax
   1620e:	e9 8d 00 00 00       	jmp    162a0 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   16213:	83 ec 08             	sub    $0x8,%esp
   16216:	ff 75 f0             	pushl  -0x10(%ebp)
   16219:	ff 75 08             	pushl  0x8(%ebp)
   1621c:	e8 25 02 00 00       	call   16446 <_SkipBits>
   16221:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   16224:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16227:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1622a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1622d:	01 d0                	add    %edx,%eax
   1622f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   16233:	0f b6 c0             	movzbl %al,%eax
   16236:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   16239:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1623d:	74 0a                	je     16249 <_GetVLC+0x7c>
   1623f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16242:	89 c2                	mov    %eax,%edx
   16244:	8b 45 10             	mov    0x10(%ebp),%eax
   16247:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   16249:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1624c:	83 e0 0f             	and    $0xf,%eax
   1624f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   16252:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16256:	75 07                	jne    1625f <_GetVLC+0x92>
   16258:	b8 00 00 00 00       	mov    $0x0,%eax
   1625d:	eb 41                	jmp    162a0 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   1625f:	83 ec 08             	sub    $0x8,%esp
   16262:	ff 75 f0             	pushl  -0x10(%ebp)
   16265:	ff 75 08             	pushl  0x8(%ebp)
   16268:	e8 12 02 00 00       	call   1647f <_GetBits>
   1626d:	83 c4 10             	add    $0x10,%esp
   16270:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   16273:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16276:	83 e8 01             	sub    $0x1,%eax
   16279:	ba 01 00 00 00       	mov    $0x1,%edx
   1627e:	89 c1                	mov    %eax,%ecx
   16280:	d3 e2                	shl    %cl,%edx
   16282:	89 d0                	mov    %edx,%eax
   16284:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   16287:	7e 14                	jle    1629d <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   16289:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1628c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   16291:	89 c1                	mov    %eax,%ecx
   16293:	d3 e2                	shl    %cl,%edx
   16295:	89 d0                	mov    %edx,%eax
   16297:	83 c0 01             	add    $0x1,%eax
   1629a:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   1629d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   162a0:	c9                   	leave  
   162a1:	c3                   	ret    

000162a2 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   162a2:	55                   	push   %ebp
   162a3:	89 e5                	mov    %esp,%ebp
   162a5:	53                   	push   %ebx
   162a6:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   162a9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   162ad:	0f 85 4f 01 00 00    	jne    16402 <_ShowBits+0x160>
   162b3:	b8 00 00 00 00       	mov    $0x0,%eax
   162b8:	e9 83 01 00 00       	jmp    16440 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   162bd:	8b 45 08             	mov    0x8(%ebp),%eax
   162c0:	8b 40 08             	mov    0x8(%eax),%eax
   162c3:	85 c0                	test   %eax,%eax
   162c5:	7f 33                	jg     162fa <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   162c7:	8b 45 08             	mov    0x8(%ebp),%eax
   162ca:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   162d0:	c1 e0 08             	shl    $0x8,%eax
   162d3:	0c ff                	or     $0xff,%al
   162d5:	89 c2                	mov    %eax,%edx
   162d7:	8b 45 08             	mov    0x8(%ebp),%eax
   162da:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   162e0:	8b 45 08             	mov    0x8(%ebp),%eax
   162e3:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   162e9:	8d 50 08             	lea    0x8(%eax),%edx
   162ec:	8b 45 08             	mov    0x8(%ebp),%eax
   162ef:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   162f5:	e9 08 01 00 00       	jmp    16402 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   162fa:	8b 45 08             	mov    0x8(%ebp),%eax
   162fd:	8b 40 04             	mov    0x4(%eax),%eax
   16300:	8d 48 01             	lea    0x1(%eax),%ecx
   16303:	8b 55 08             	mov    0x8(%ebp),%edx
   16306:	89 4a 04             	mov    %ecx,0x4(%edx)
   16309:	0f b6 00             	movzbl (%eax),%eax
   1630c:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   1630f:	8b 45 08             	mov    0x8(%ebp),%eax
   16312:	8b 40 08             	mov    0x8(%eax),%eax
   16315:	8d 50 ff             	lea    -0x1(%eax),%edx
   16318:	8b 45 08             	mov    0x8(%ebp),%eax
   1631b:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   1631e:	8b 45 08             	mov    0x8(%ebp),%eax
   16321:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   16327:	8d 50 08             	lea    0x8(%eax),%edx
   1632a:	8b 45 08             	mov    0x8(%ebp),%eax
   1632d:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   16333:	8b 45 08             	mov    0x8(%ebp),%eax
   16336:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1633c:	c1 e0 08             	shl    $0x8,%eax
   1633f:	89 c2                	mov    %eax,%edx
   16341:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   16345:	09 c2                	or     %eax,%edx
   16347:	8b 45 08             	mov    0x8(%ebp),%eax
   1634a:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   16350:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   16354:	0f 85 a8 00 00 00    	jne    16402 <_ShowBits+0x160>
            if(ctx->size){
   1635a:	8b 45 08             	mov    0x8(%ebp),%eax
   1635d:	8b 40 08             	mov    0x8(%eax),%eax
   16360:	85 c0                	test   %eax,%eax
   16362:	0f 84 91 00 00 00    	je     163f9 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   16368:	8b 45 08             	mov    0x8(%ebp),%eax
   1636b:	8b 40 04             	mov    0x4(%eax),%eax
   1636e:	8d 48 01             	lea    0x1(%eax),%ecx
   16371:	8b 55 08             	mov    0x8(%ebp),%edx
   16374:	89 4a 04             	mov    %ecx,0x4(%edx)
   16377:	0f b6 00             	movzbl (%eax),%eax
   1637a:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   1637d:	8b 45 08             	mov    0x8(%ebp),%eax
   16380:	8b 40 08             	mov    0x8(%eax),%eax
   16383:	8d 50 ff             	lea    -0x1(%eax),%edx
   16386:	8b 45 08             	mov    0x8(%ebp),%eax
   16389:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   1638c:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   16390:	85 c0                	test   %eax,%eax
   16392:	74 62                	je     163f6 <_ShowBits+0x154>
   16394:	3d d9 00 00 00       	cmp    $0xd9,%eax
   16399:	75 0c                	jne    163a7 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   1639b:	8b 45 08             	mov    0x8(%ebp),%eax
   1639e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   163a5:	eb 5b                	jmp    16402 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   163a7:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   163ab:	25 f8 00 00 00       	and    $0xf8,%eax
   163b0:	3d d0 00 00 00       	cmp    $0xd0,%eax
   163b5:	74 0b                	je     163c2 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   163b7:	8b 45 08             	mov    0x8(%ebp),%eax
   163ba:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   163c0:	eb 40                	jmp    16402 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   163c2:	8b 45 08             	mov    0x8(%ebp),%eax
   163c5:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   163cb:	c1 e0 08             	shl    $0x8,%eax
   163ce:	89 c2                	mov    %eax,%edx
   163d0:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   163d4:	09 c2                	or     %eax,%edx
   163d6:	8b 45 08             	mov    0x8(%ebp),%eax
   163d9:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   163df:	8b 45 08             	mov    0x8(%ebp),%eax
   163e2:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   163e8:	8d 50 08             	lea    0x8(%eax),%edx
   163eb:	8b 45 08             	mov    0x8(%ebp),%eax
   163ee:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   163f4:	eb 0c                	jmp    16402 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   163f6:	90                   	nop
   163f7:	eb 09                	jmp    16402 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   163f9:	8b 45 08             	mov    0x8(%ebp),%eax
   163fc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   16402:	8b 45 08             	mov    0x8(%ebp),%eax
   16405:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1640b:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1640e:	0f 8c a9 fe ff ff    	jl     162bd <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   16414:	8b 45 08             	mov    0x8(%ebp),%eax
   16417:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   1641d:	8b 45 08             	mov    0x8(%ebp),%eax
   16420:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   16426:	2b 45 0c             	sub    0xc(%ebp),%eax
   16429:	89 c1                	mov    %eax,%ecx
   1642b:	d3 fa                	sar    %cl,%edx
   1642d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16430:	bb 01 00 00 00       	mov    $0x1,%ebx
   16435:	89 c1                	mov    %eax,%ecx
   16437:	d3 e3                	shl    %cl,%ebx
   16439:	89 d8                	mov    %ebx,%eax
   1643b:	83 e8 01             	sub    $0x1,%eax
   1643e:	21 d0                	and    %edx,%eax
}
   16440:	83 c4 10             	add    $0x10,%esp
   16443:	5b                   	pop    %ebx
   16444:	5d                   	pop    %ebp
   16445:	c3                   	ret    

00016446 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   16446:	55                   	push   %ebp
   16447:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   16449:	8b 45 08             	mov    0x8(%ebp),%eax
   1644c:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   16452:	3b 45 0c             	cmp    0xc(%ebp),%eax
   16455:	7d 0e                	jge    16465 <_SkipBits+0x1f>
   16457:	ff 75 0c             	pushl  0xc(%ebp)
   1645a:	ff 75 08             	pushl  0x8(%ebp)
   1645d:	e8 40 fe ff ff       	call   162a2 <_ShowBits>
   16462:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   16465:	8b 45 08             	mov    0x8(%ebp),%eax
   16468:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1646e:	2b 45 0c             	sub    0xc(%ebp),%eax
   16471:	89 c2                	mov    %eax,%edx
   16473:	8b 45 08             	mov    0x8(%ebp),%eax
   16476:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1647c:	90                   	nop
   1647d:	c9                   	leave  
   1647e:	c3                   	ret    

0001647f <_GetBits>:

int _GetBits(Context* ctx, int bits){
   1647f:	55                   	push   %ebp
   16480:	89 e5                	mov    %esp,%ebp
   16482:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   16485:	ff 75 0c             	pushl  0xc(%ebp)
   16488:	ff 75 08             	pushl  0x8(%ebp)
   1648b:	e8 12 fe ff ff       	call   162a2 <_ShowBits>
   16490:	83 c4 08             	add    $0x8,%esp
   16493:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   16496:	ff 75 0c             	pushl  0xc(%ebp)
   16499:	ff 75 08             	pushl  0x8(%ebp)
   1649c:	e8 a5 ff ff ff       	call   16446 <_SkipBits>
   164a1:	83 c4 08             	add    $0x8,%esp
    return res;
   164a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   164a7:	c9                   	leave  
   164a8:	c3                   	ret    

000164a9 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   164a9:	55                   	push   %ebp
   164aa:	89 e5                	mov    %esp,%ebp
   164ac:	57                   	push   %edi
   164ad:	56                   	push   %esi
   164ae:	53                   	push   %ebx
   164af:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   164b2:	8b 45 08             	mov    0x8(%ebp),%eax
   164b5:	83 c0 10             	add    $0x10,%eax
   164b8:	8b 00                	mov    (%eax),%eax
   164ba:	c1 e0 0b             	shl    $0xb,%eax
   164bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   164c0:	8b 45 08             	mov    0x8(%ebp),%eax
   164c3:	8b 40 18             	mov    0x18(%eax),%eax
   164c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
   164c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   164cc:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   164cf:	8b 55 08             	mov    0x8(%ebp),%edx
   164d2:	8b 52 08             	mov    0x8(%edx),%edx
   164d5:	89 55 e8             	mov    %edx,-0x18(%ebp)
   164d8:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   164db:	8b 55 08             	mov    0x8(%ebp),%edx
   164de:	8b 52 04             	mov    0x4(%edx),%edx
   164e1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   164e4:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   164e7:	8b 55 08             	mov    0x8(%ebp),%edx
   164ea:	8b 52 1c             	mov    0x1c(%edx),%edx
   164ed:	89 55 e0             	mov    %edx,-0x20(%ebp)
   164f0:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   164f3:	8b 55 08             	mov    0x8(%ebp),%edx
   164f6:	8b 52 14             	mov    0x14(%edx),%edx
   164f9:	89 55 dc             	mov    %edx,-0x24(%ebp)
   164fc:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   164ff:	8b 55 08             	mov    0x8(%ebp),%edx
   16502:	8b 52 0c             	mov    0xc(%edx),%edx
   16505:	89 55 d8             	mov    %edx,-0x28(%ebp)
   16508:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   1650b:	85 c0                	test   %eax,%eax
   1650d:	75 68                	jne    16577 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   1650f:	8b 45 08             	mov    0x8(%ebp),%eax
   16512:	8d 48 04             	lea    0x4(%eax),%ecx
   16515:	8b 45 08             	mov    0x8(%ebp),%eax
   16518:	8d 58 08             	lea    0x8(%eax),%ebx
   1651b:	8b 45 08             	mov    0x8(%ebp),%eax
   1651e:	8d 70 0c             	lea    0xc(%eax),%esi
   16521:	8b 45 08             	mov    0x8(%ebp),%eax
   16524:	8d 78 10             	lea    0x10(%eax),%edi
   16527:	8b 45 08             	mov    0x8(%ebp),%eax
   1652a:	83 c0 14             	add    $0x14,%eax
   1652d:	89 45 c0             	mov    %eax,-0x40(%ebp)
   16530:	8b 45 08             	mov    0x8(%ebp),%eax
   16533:	83 c0 18             	add    $0x18,%eax
   16536:	89 45 bc             	mov    %eax,-0x44(%ebp)
   16539:	8b 45 08             	mov    0x8(%ebp),%eax
   1653c:	8d 50 1c             	lea    0x1c(%eax),%edx
   1653f:	8b 45 08             	mov    0x8(%ebp),%eax
   16542:	8b 00                	mov    (%eax),%eax
   16544:	c1 e0 03             	shl    $0x3,%eax
   16547:	89 02                	mov    %eax,(%edx)
   16549:	8b 02                	mov    (%edx),%eax
   1654b:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1654e:	89 02                	mov    %eax,(%edx)
   16550:	89 d0                	mov    %edx,%eax
   16552:	8b 00                	mov    (%eax),%eax
   16554:	8b 55 c0             	mov    -0x40(%ebp),%edx
   16557:	89 02                	mov    %eax,(%edx)
   16559:	89 d0                	mov    %edx,%eax
   1655b:	8b 00                	mov    (%eax),%eax
   1655d:	89 07                	mov    %eax,(%edi)
   1655f:	8b 07                	mov    (%edi),%eax
   16561:	89 06                	mov    %eax,(%esi)
   16563:	8b 06                	mov    (%esi),%eax
   16565:	89 03                	mov    %eax,(%ebx)
   16567:	8b 03                	mov    (%ebx),%eax
   16569:	89 01                	mov    %eax,(%ecx)
   1656b:	8b 11                	mov    (%ecx),%edx
   1656d:	8b 45 08             	mov    0x8(%ebp),%eax
   16570:	89 10                	mov    %edx,(%eax)
        return;
   16572:	e9 b7 01 00 00       	jmp    1672e <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   16577:	8b 45 08             	mov    0x8(%ebp),%eax
   1657a:	8b 00                	mov    (%eax),%eax
   1657c:	c1 e0 0b             	shl    $0xb,%eax
   1657f:	83 e8 80             	sub    $0xffffff80,%eax
   16582:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   16585:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16588:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1658b:	01 d0                	add    %edx,%eax
   1658d:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   16593:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   16596:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16599:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1659f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   165a2:	01 d0                	add    %edx,%eax
   165a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   165a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   165aa:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   165b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   165b3:	01 d0                	add    %edx,%eax
   165b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   165b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
   165bb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   165be:	01 d0                	add    %edx,%eax
   165c0:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   165c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   165c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   165cc:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   165d2:	8b 45 d0             	mov    -0x30(%ebp),%eax
   165d5:	01 d0                	add    %edx,%eax
   165d7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   165da:	8b 45 d8             	mov    -0x28(%ebp),%eax
   165dd:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   165e3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   165e6:	01 d0                	add    %edx,%eax
   165e8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   165eb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   165ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   165f1:	01 d0                	add    %edx,%eax
   165f3:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   165f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   165f9:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   165fc:	8b 55 e8             	mov    -0x18(%ebp),%edx
   165ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16602:	01 d0                	add    %edx,%eax
   16604:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1660a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   1660d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16610:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   16616:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16619:	01 d0                	add    %edx,%eax
   1661b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   1661e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16621:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   16627:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1662a:	01 d0                	add    %edx,%eax
   1662c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   1662f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16632:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16635:	01 d0                	add    %edx,%eax
   16637:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   1663a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1663d:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   16640:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16643:	8b 45 d8             	mov    -0x28(%ebp),%eax
   16646:	01 d0                	add    %edx,%eax
   16648:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   1664b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1664e:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   16651:	8b 55 d0             	mov    -0x30(%ebp),%edx
   16654:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16657:	01 d0                	add    %edx,%eax
   16659:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   1665c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1665f:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   16662:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   16665:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16668:	01 d0                	add    %edx,%eax
   1666a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   1666d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16670:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   16673:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16676:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16679:	01 d0                	add    %edx,%eax
   1667b:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   16681:	83 e8 80             	sub    $0xffffff80,%eax
   16684:	c1 f8 08             	sar    $0x8,%eax
   16687:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   1668a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1668d:	2b 45 e0             	sub    -0x20(%ebp),%eax
   16690:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   16696:	83 e8 80             	sub    $0xffffff80,%eax
   16699:	c1 f8 08             	sar    $0x8,%eax
   1669c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   1669f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   166a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   166a5:	01 d0                	add    %edx,%eax
   166a7:	c1 f8 08             	sar    $0x8,%eax
   166aa:	89 c2                	mov    %eax,%edx
   166ac:	8b 45 08             	mov    0x8(%ebp),%eax
   166af:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   166b1:	8b 45 08             	mov    0x8(%ebp),%eax
   166b4:	83 c0 04             	add    $0x4,%eax
   166b7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   166ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
   166bd:	01 ca                	add    %ecx,%edx
   166bf:	c1 fa 08             	sar    $0x8,%edx
   166c2:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   166c4:	8b 45 08             	mov    0x8(%ebp),%eax
   166c7:	83 c0 08             	add    $0x8,%eax
   166ca:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   166cd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   166d0:	01 ca                	add    %ecx,%edx
   166d2:	c1 fa 08             	sar    $0x8,%edx
   166d5:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   166d7:	8b 45 08             	mov    0x8(%ebp),%eax
   166da:	83 c0 0c             	add    $0xc,%eax
   166dd:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   166e0:	8b 55 dc             	mov    -0x24(%ebp),%edx
   166e3:	01 ca                	add    %ecx,%edx
   166e5:	c1 fa 08             	sar    $0x8,%edx
   166e8:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   166ea:	8b 45 08             	mov    0x8(%ebp),%eax
   166ed:	8d 50 10             	lea    0x10(%eax),%edx
   166f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   166f3:	2b 45 dc             	sub    -0x24(%ebp),%eax
   166f6:	c1 f8 08             	sar    $0x8,%eax
   166f9:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   166fb:	8b 45 08             	mov    0x8(%ebp),%eax
   166fe:	8d 50 14             	lea    0x14(%eax),%edx
   16701:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16704:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   16707:	c1 f8 08             	sar    $0x8,%eax
   1670a:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   1670c:	8b 45 08             	mov    0x8(%ebp),%eax
   1670f:	8d 50 18             	lea    0x18(%eax),%edx
   16712:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16715:	2b 45 ec             	sub    -0x14(%ebp),%eax
   16718:	c1 f8 08             	sar    $0x8,%eax
   1671b:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   1671d:	8b 45 08             	mov    0x8(%ebp),%eax
   16720:	8d 50 1c             	lea    0x1c(%eax),%edx
   16723:	8b 45 d8             	mov    -0x28(%ebp),%eax
   16726:	2b 45 f0             	sub    -0x10(%ebp),%eax
   16729:	c1 f8 08             	sar    $0x8,%eax
   1672c:	89 02                	mov    %eax,(%edx)
}
   1672e:	83 c4 38             	add    $0x38,%esp
   16731:	5b                   	pop    %ebx
   16732:	5e                   	pop    %esi
   16733:	5f                   	pop    %edi
   16734:	5d                   	pop    %ebp
   16735:	c3                   	ret    

00016736 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   16736:	55                   	push   %ebp
   16737:	89 e5                	mov    %esp,%ebp
   16739:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1673c:	8b 45 08             	mov    0x8(%ebp),%eax
   1673f:	83 e8 80             	sub    $0xffffff80,%eax
   16742:	8b 00                	mov    (%eax),%eax
   16744:	c1 e0 08             	shl    $0x8,%eax
   16747:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   1674a:	8b 45 08             	mov    0x8(%ebp),%eax
   1674d:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   16753:	89 45 f4             	mov    %eax,-0xc(%ebp)
   16756:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16759:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   1675c:	8b 55 08             	mov    0x8(%ebp),%edx
   1675f:	8b 52 40             	mov    0x40(%edx),%edx
   16762:	89 55 f0             	mov    %edx,-0x10(%ebp)
   16765:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   16768:	8b 55 08             	mov    0x8(%ebp),%edx
   1676b:	8b 52 20             	mov    0x20(%edx),%edx
   1676e:	89 55 ec             	mov    %edx,-0x14(%ebp)
   16771:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   16774:	8b 55 08             	mov    0x8(%ebp),%edx
   16777:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   1677d:	89 55 e8             	mov    %edx,-0x18(%ebp)
   16780:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   16783:	8b 55 08             	mov    0x8(%ebp),%edx
   16786:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   1678c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1678f:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   16792:	8b 55 08             	mov    0x8(%ebp),%edx
   16795:	8b 52 60             	mov    0x60(%edx),%edx
   16798:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1679b:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1679e:	85 c0                	test   %eax,%eax
   167a0:	75 45                	jne    167e7 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   167a2:	8b 45 08             	mov    0x8(%ebp),%eax
   167a5:	8b 00                	mov    (%eax),%eax
   167a7:	83 c0 20             	add    $0x20,%eax
   167aa:	c1 f8 06             	sar    $0x6,%eax
   167ad:	83 e8 80             	sub    $0xffffff80,%eax
   167b0:	50                   	push   %eax
   167b1:	e8 d6 ea ff ff       	call   1528c <_Clip>
   167b6:	83 c4 04             	add    $0x4,%esp
   167b9:	0f b6 c0             	movzbl %al,%eax
   167bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   167bf:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   167c6:	eb 14                	jmp    167dc <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   167c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   167cb:	89 c2                	mov    %eax,%edx
   167cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   167d0:	88 10                	mov    %dl,(%eax)
            out += stride;
   167d2:	8b 45 10             	mov    0x10(%ebp),%eax
   167d5:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   167d8:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   167dc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   167e0:	75 e6                	jne    167c8 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   167e2:	e9 57 02 00 00       	jmp    16a3e <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   167e7:	8b 45 08             	mov    0x8(%ebp),%eax
   167ea:	8b 00                	mov    (%eax),%eax
   167ec:	c1 e0 08             	shl    $0x8,%eax
   167ef:	05 00 20 00 00       	add    $0x2000,%eax
   167f4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   167f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   167fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   167fd:	01 d0                	add    %edx,%eax
   167ff:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   16805:	83 c0 04             	add    $0x4,%eax
   16808:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   1680b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1680e:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   16814:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16817:	01 d0                	add    %edx,%eax
   16819:	c1 f8 03             	sar    $0x3,%eax
   1681c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   1681f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16822:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   16828:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1682b:	01 d0                	add    %edx,%eax
   1682d:	c1 f8 03             	sar    $0x3,%eax
   16830:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   16833:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16836:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16839:	01 d0                	add    %edx,%eax
   1683b:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   16841:	83 c0 04             	add    $0x4,%eax
   16844:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   16847:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1684a:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   16850:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16853:	01 d0                	add    %edx,%eax
   16855:	c1 f8 03             	sar    $0x3,%eax
   16858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   1685b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1685e:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   16864:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16867:	01 d0                	add    %edx,%eax
   16869:	c1 f8 03             	sar    $0x3,%eax
   1686c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1686f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   16872:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16875:	01 d0                	add    %edx,%eax
   16877:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   1687a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1687d:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   16880:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16883:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16886:	01 d0                	add    %edx,%eax
   16888:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1688e:	83 c0 04             	add    $0x4,%eax
   16891:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   16894:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16897:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1689d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   168a0:	01 d0                	add    %edx,%eax
   168a2:	c1 f8 03             	sar    $0x3,%eax
   168a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   168a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   168ab:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   168b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   168b4:	01 d0                	add    %edx,%eax
   168b6:	c1 f8 03             	sar    $0x3,%eax
   168b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   168bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
   168bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   168c2:	01 d0                	add    %edx,%eax
   168c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   168c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   168ca:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   168cd:	8b 55 e8             	mov    -0x18(%ebp),%edx
   168d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   168d3:	01 d0                	add    %edx,%eax
   168d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   168d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   168db:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   168de:	8b 55 dc             	mov    -0x24(%ebp),%edx
   168e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   168e4:	01 d0                	add    %edx,%eax
   168e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   168e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   168ec:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   168ef:	8b 55 fc             	mov    -0x4(%ebp),%edx
   168f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   168f5:	01 d0                	add    %edx,%eax
   168f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   168fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   168fd:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   16900:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16903:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16906:	01 d0                	add    %edx,%eax
   16908:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1690e:	83 e8 80             	sub    $0xffffff80,%eax
   16911:	c1 f8 08             	sar    $0x8,%eax
   16914:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   16917:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1691a:	2b 45 e8             	sub    -0x18(%ebp),%eax
   1691d:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   16923:	83 e8 80             	sub    $0xffffff80,%eax
   16926:	c1 f8 08             	sar    $0x8,%eax
   16929:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   1692c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1692f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16932:	01 d0                	add    %edx,%eax
   16934:	c1 f8 0e             	sar    $0xe,%eax
   16937:	83 e8 80             	sub    $0xffffff80,%eax
   1693a:	50                   	push   %eax
   1693b:	e8 4c e9 ff ff       	call   1528c <_Clip>
   16940:	83 c4 04             	add    $0x4,%esp
   16943:	89 c2                	mov    %eax,%edx
   16945:	8b 45 0c             	mov    0xc(%ebp),%eax
   16948:	88 10                	mov    %dl,(%eax)
   1694a:	8b 45 10             	mov    0x10(%ebp),%eax
   1694d:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   16950:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16953:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16956:	01 d0                	add    %edx,%eax
   16958:	c1 f8 0e             	sar    $0xe,%eax
   1695b:	83 e8 80             	sub    $0xffffff80,%eax
   1695e:	50                   	push   %eax
   1695f:	e8 28 e9 ff ff       	call   1528c <_Clip>
   16964:	83 c4 04             	add    $0x4,%esp
   16967:	89 c2                	mov    %eax,%edx
   16969:	8b 45 0c             	mov    0xc(%ebp),%eax
   1696c:	88 10                	mov    %dl,(%eax)
   1696e:	8b 45 10             	mov    0x10(%ebp),%eax
   16971:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   16974:	8b 55 fc             	mov    -0x4(%ebp),%edx
   16977:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1697a:	01 d0                	add    %edx,%eax
   1697c:	c1 f8 0e             	sar    $0xe,%eax
   1697f:	83 e8 80             	sub    $0xffffff80,%eax
   16982:	50                   	push   %eax
   16983:	e8 04 e9 ff ff       	call   1528c <_Clip>
   16988:	83 c4 04             	add    $0x4,%esp
   1698b:	89 c2                	mov    %eax,%edx
   1698d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16990:	88 10                	mov    %dl,(%eax)
   16992:	8b 45 10             	mov    0x10(%ebp),%eax
   16995:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   16998:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1699b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1699e:	01 d0                	add    %edx,%eax
   169a0:	c1 f8 0e             	sar    $0xe,%eax
   169a3:	83 e8 80             	sub    $0xffffff80,%eax
   169a6:	50                   	push   %eax
   169a7:	e8 e0 e8 ff ff       	call   1528c <_Clip>
   169ac:	83 c4 04             	add    $0x4,%esp
   169af:	89 c2                	mov    %eax,%edx
   169b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   169b4:	88 10                	mov    %dl,(%eax)
   169b6:	8b 45 10             	mov    0x10(%ebp),%eax
   169b9:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   169bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   169bf:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   169c2:	c1 f8 0e             	sar    $0xe,%eax
   169c5:	83 e8 80             	sub    $0xffffff80,%eax
   169c8:	50                   	push   %eax
   169c9:	e8 be e8 ff ff       	call   1528c <_Clip>
   169ce:	83 c4 04             	add    $0x4,%esp
   169d1:	89 c2                	mov    %eax,%edx
   169d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   169d6:	88 10                	mov    %dl,(%eax)
   169d8:	8b 45 10             	mov    0x10(%ebp),%eax
   169db:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   169de:	8b 45 fc             	mov    -0x4(%ebp),%eax
   169e1:	2b 45 ec             	sub    -0x14(%ebp),%eax
   169e4:	c1 f8 0e             	sar    $0xe,%eax
   169e7:	83 e8 80             	sub    $0xffffff80,%eax
   169ea:	50                   	push   %eax
   169eb:	e8 9c e8 ff ff       	call   1528c <_Clip>
   169f0:	83 c4 04             	add    $0x4,%esp
   169f3:	89 c2                	mov    %eax,%edx
   169f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   169f8:	88 10                	mov    %dl,(%eax)
   169fa:	8b 45 10             	mov    0x10(%ebp),%eax
   169fd:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   16a00:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16a03:	2b 45 f4             	sub    -0xc(%ebp),%eax
   16a06:	c1 f8 0e             	sar    $0xe,%eax
   16a09:	83 e8 80             	sub    $0xffffff80,%eax
   16a0c:	50                   	push   %eax
   16a0d:	e8 7a e8 ff ff       	call   1528c <_Clip>
   16a12:	83 c4 04             	add    $0x4,%esp
   16a15:	89 c2                	mov    %eax,%edx
   16a17:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a1a:	88 10                	mov    %dl,(%eax)
   16a1c:	8b 45 10             	mov    0x10(%ebp),%eax
   16a1f:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   16a22:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16a25:	2b 45 f8             	sub    -0x8(%ebp),%eax
   16a28:	c1 f8 0e             	sar    $0xe,%eax
   16a2b:	83 e8 80             	sub    $0xffffff80,%eax
   16a2e:	50                   	push   %eax
   16a2f:	e8 58 e8 ff ff       	call   1528c <_Clip>
   16a34:	83 c4 04             	add    $0x4,%esp
   16a37:	89 c2                	mov    %eax,%edx
   16a39:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a3c:	88 10                	mov    %dl,(%eax)
}
   16a3e:	c9                   	leave  
   16a3f:	c3                   	ret    

00016a40 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   16a40:	55                   	push   %ebp
   16a41:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   16a43:	8b 45 08             	mov    0x8(%ebp),%eax
   16a46:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   16a4c:	25 f8 00 00 00       	and    $0xf8,%eax
   16a51:	89 c2                	mov    %eax,%edx
   16a53:	8b 45 08             	mov    0x8(%ebp),%eax
   16a56:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   16a5c:	90                   	nop
   16a5d:	5d                   	pop    %ebp
   16a5e:	c3                   	ret    

00016a5f <_SkipMarker>:

void _SkipMarker(Context* ctx){
   16a5f:	55                   	push   %ebp
   16a60:	89 e5                	mov    %esp,%ebp
   16a62:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   16a65:	83 ec 0c             	sub    $0xc,%esp
   16a68:	ff 75 08             	pushl  0x8(%ebp)
   16a6b:	e8 8d e8 ff ff       	call   152fd <_DecodeLength>
   16a70:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   16a73:	8b 45 08             	mov    0x8(%ebp),%eax
   16a76:	8b 40 0c             	mov    0xc(%eax),%eax
   16a79:	83 ec 08             	sub    $0x8,%esp
   16a7c:	50                   	push   %eax
   16a7d:	ff 75 08             	pushl  0x8(%ebp)
   16a80:	e8 2c e8 ff ff       	call   152b1 <_Skip>
   16a85:	83 c4 10             	add    $0x10,%esp
}
   16a88:	90                   	nop
   16a89:	c9                   	leave  
   16a8a:	c3                   	ret    

00016a8b <_Convert>:

void _Convert(Context* ctx){
   16a8b:	55                   	push   %ebp
   16a8c:	89 e5                	mov    %esp,%ebp
   16a8e:	57                   	push   %edi
   16a8f:	56                   	push   %esi
   16a90:	53                   	push   %ebx
   16a91:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   16a94:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   16a9b:	8b 45 08             	mov    0x8(%ebp),%eax
   16a9e:	83 c0 2c             	add    $0x2c,%eax
   16aa1:	89 45 e0             	mov    %eax,-0x20(%ebp)
   16aa4:	e9 b2 00 00 00       	jmp    16b5b <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   16aa9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16aac:	8b 50 0c             	mov    0xc(%eax),%edx
   16aaf:	8b 45 08             	mov    0x8(%ebp),%eax
   16ab2:	8b 40 10             	mov    0x10(%eax),%eax
   16ab5:	39 c2                	cmp    %eax,%edx
   16ab7:	7d 11                	jge    16aca <_Convert+0x3f>
   16ab9:	83 ec 08             	sub    $0x8,%esp
   16abc:	ff 75 e0             	pushl  -0x20(%ebp)
   16abf:	ff 75 08             	pushl  0x8(%ebp)
   16ac2:	e8 79 02 00 00       	call   16d40 <_UpsampleH>
   16ac7:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   16aca:	8b 45 08             	mov    0x8(%ebp),%eax
   16acd:	8b 00                	mov    (%eax),%eax
   16acf:	85 c0                	test   %eax,%eax
   16ad1:	0f 85 5d 02 00 00    	jne    16d34 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   16ad7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16ada:	8b 50 10             	mov    0x10(%eax),%edx
   16add:	8b 45 08             	mov    0x8(%ebp),%eax
   16ae0:	8b 40 14             	mov    0x14(%eax),%eax
   16ae3:	39 c2                	cmp    %eax,%edx
   16ae5:	7d 11                	jge    16af8 <_Convert+0x6d>
   16ae7:	83 ec 08             	sub    $0x8,%esp
   16aea:	ff 75 e0             	pushl  -0x20(%ebp)
   16aed:	ff 75 08             	pushl  0x8(%ebp)
   16af0:	e8 db 05 00 00       	call   170d0 <_UpsampleV>
   16af5:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   16af8:	8b 45 08             	mov    0x8(%ebp),%eax
   16afb:	8b 00                	mov    (%eax),%eax
   16afd:	85 c0                	test   %eax,%eax
   16aff:	0f 85 32 02 00 00    	jne    16d37 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   16b05:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16b08:	8b 50 0c             	mov    0xc(%eax),%edx
   16b0b:	8b 45 08             	mov    0x8(%ebp),%eax
   16b0e:	8b 40 10             	mov    0x10(%eax),%eax
   16b11:	39 c2                	cmp    %eax,%edx
   16b13:	7c 94                	jl     16aa9 <_Convert+0x1e>
   16b15:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16b18:	8b 50 10             	mov    0x10(%eax),%edx
   16b1b:	8b 45 08             	mov    0x8(%ebp),%eax
   16b1e:	8b 40 14             	mov    0x14(%eax),%eax
   16b21:	39 c2                	cmp    %eax,%edx
   16b23:	7c 84                	jl     16aa9 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   16b25:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16b28:	8b 50 0c             	mov    0xc(%eax),%edx
   16b2b:	8b 45 08             	mov    0x8(%ebp),%eax
   16b2e:	8b 40 10             	mov    0x10(%eax),%eax
   16b31:	39 c2                	cmp    %eax,%edx
   16b33:	7c 10                	jl     16b45 <_Convert+0xba>
   16b35:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16b38:	8b 50 10             	mov    0x10(%eax),%edx
   16b3b:	8b 45 08             	mov    0x8(%ebp),%eax
   16b3e:	8b 40 14             	mov    0x14(%eax),%eax
   16b41:	39 c2                	cmp    %eax,%edx
   16b43:	7d 0e                	jge    16b53 <_Convert+0xc8>
   16b45:	8b 45 08             	mov    0x8(%ebp),%eax
   16b48:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   16b4e:	e9 e5 01 00 00       	jmp    16d38 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   16b53:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   16b57:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   16b5b:	8b 45 08             	mov    0x8(%ebp),%eax
   16b5e:	8b 40 28             	mov    0x28(%eax),%eax
   16b61:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16b64:	7f 9f                	jg     16b05 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   16b66:	8b 45 08             	mov    0x8(%ebp),%eax
   16b69:	8b 40 28             	mov    0x28(%eax),%eax
   16b6c:	83 f8 03             	cmp    $0x3,%eax
   16b6f:	0f 85 3d 01 00 00    	jne    16cb2 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   16b75:	8b 45 08             	mov    0x8(%ebp),%eax
   16b78:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   16b7e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   16b81:	8b 45 08             	mov    0x8(%ebp),%eax
   16b84:	8b 40 54             	mov    0x54(%eax),%eax
   16b87:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   16b8a:	8b 45 08             	mov    0x8(%ebp),%eax
   16b8d:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   16b93:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   16b96:	8b 45 08             	mov    0x8(%ebp),%eax
   16b99:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   16b9f:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   16ba2:	8b 45 08             	mov    0x8(%ebp),%eax
   16ba5:	8b 40 14             	mov    0x14(%eax),%eax
   16ba8:	89 45 d8             	mov    %eax,-0x28(%ebp)
   16bab:	e9 f3 00 00 00       	jmp    16ca3 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   16bb0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   16bb7:	e9 b6 00 00 00       	jmp    16c72 <_Convert+0x1e7>
                register int y = py[x] << 8;
   16bbc:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16bbf:	8b 45 d0             	mov    -0x30(%ebp),%eax
   16bc2:	01 d0                	add    %edx,%eax
   16bc4:	0f b6 00             	movzbl (%eax),%eax
   16bc7:	0f b6 c0             	movzbl %al,%eax
   16bca:	c1 e0 08             	shl    $0x8,%eax
   16bcd:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   16bcf:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16bd2:	8b 45 cc             	mov    -0x34(%ebp),%eax
   16bd5:	01 d0                	add    %edx,%eax
   16bd7:	0f b6 00             	movzbl (%eax),%eax
   16bda:	0f b6 c0             	movzbl %al,%eax
   16bdd:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   16be0:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16be3:	8b 45 c8             	mov    -0x38(%ebp),%eax
   16be6:	01 d0                	add    %edx,%eax
   16be8:	0f b6 00             	movzbl (%eax),%eax
   16beb:	0f b6 c0             	movzbl %al,%eax
   16bee:	83 c0 80             	add    $0xffffff80,%eax
   16bf1:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   16bf3:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   16bf6:	8d 46 01             	lea    0x1(%esi),%eax
   16bf9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   16bfc:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   16bff:	89 c8                	mov    %ecx,%eax
   16c01:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   16c07:	01 d8                	add    %ebx,%eax
   16c09:	83 e8 80             	sub    $0xffffff80,%eax
   16c0c:	c1 f8 08             	sar    $0x8,%eax
   16c0f:	83 ec 0c             	sub    $0xc,%esp
   16c12:	50                   	push   %eax
   16c13:	e8 74 e6 ff ff       	call   1528c <_Clip>
   16c18:	83 c4 10             	add    $0x10,%esp
   16c1b:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   16c1d:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   16c20:	8d 46 01             	lea    0x1(%esi),%eax
   16c23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   16c26:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   16c29:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   16c2c:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   16c33:	01 d0                	add    %edx,%eax
   16c35:	83 e8 80             	sub    $0xffffff80,%eax
   16c38:	c1 f8 08             	sar    $0x8,%eax
   16c3b:	83 ec 0c             	sub    $0xc,%esp
   16c3e:	50                   	push   %eax
   16c3f:	e8 48 e6 ff ff       	call   1528c <_Clip>
   16c44:	83 c4 10             	add    $0x10,%esp
   16c47:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   16c49:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   16c4c:	8d 46 01             	lea    0x1(%esi),%eax
   16c4f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   16c52:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   16c58:	01 d8                	add    %ebx,%eax
   16c5a:	83 e8 80             	sub    $0xffffff80,%eax
   16c5d:	c1 f8 08             	sar    $0x8,%eax
   16c60:	83 ec 0c             	sub    $0xc,%esp
   16c63:	50                   	push   %eax
   16c64:	e8 23 e6 ff ff       	call   1528c <_Clip>
   16c69:	83 c4 10             	add    $0x10,%esp
   16c6c:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   16c6e:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   16c72:	8b 45 08             	mov    0x8(%ebp),%eax
   16c75:	8b 40 10             	mov    0x10(%eax),%eax
   16c78:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   16c7b:	0f 8f 3b ff ff ff    	jg     16bbc <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   16c81:	8b 45 08             	mov    0x8(%ebp),%eax
   16c84:	8b 40 40             	mov    0x40(%eax),%eax
   16c87:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   16c8a:	8b 45 08             	mov    0x8(%ebp),%eax
   16c8d:	8b 40 6c             	mov    0x6c(%eax),%eax
   16c90:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   16c93:	8b 45 08             	mov    0x8(%ebp),%eax
   16c96:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   16c9c:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   16c9f:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   16ca3:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   16ca7:	0f 85 03 ff ff ff    	jne    16bb0 <_Convert+0x125>
   16cad:	e9 86 00 00 00       	jmp    16d38 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   16cb2:	8b 45 08             	mov    0x8(%ebp),%eax
   16cb5:	8b 50 38             	mov    0x38(%eax),%edx
   16cb8:	8b 45 08             	mov    0x8(%ebp),%eax
   16cbb:	8b 40 40             	mov    0x40(%eax),%eax
   16cbe:	39 c2                	cmp    %eax,%edx
   16cc0:	74 76                	je     16d38 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   16cc2:	8b 45 08             	mov    0x8(%ebp),%eax
   16cc5:	8b 50 54             	mov    0x54(%eax),%edx
   16cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   16ccb:	8b 40 40             	mov    0x40(%eax),%eax
   16cce:	01 d0                	add    %edx,%eax
   16cd0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   16cd3:	8b 45 08             	mov    0x8(%ebp),%eax
   16cd6:	8b 50 54             	mov    0x54(%eax),%edx
   16cd9:	8b 45 08             	mov    0x8(%ebp),%eax
   16cdc:	8b 40 38             	mov    0x38(%eax),%eax
   16cdf:	01 d0                	add    %edx,%eax
   16ce1:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   16ce4:	8b 45 08             	mov    0x8(%ebp),%eax
   16ce7:	8b 40 3c             	mov    0x3c(%eax),%eax
   16cea:	83 e8 01             	sub    $0x1,%eax
   16ced:	89 45 bc             	mov    %eax,-0x44(%ebp)
   16cf0:	eb 2e                	jmp    16d20 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   16cf2:	8b 45 08             	mov    0x8(%ebp),%eax
   16cf5:	8b 40 38             	mov    0x38(%eax),%eax
   16cf8:	83 ec 04             	sub    $0x4,%esp
   16cfb:	50                   	push   %eax
   16cfc:	ff 75 c4             	pushl  -0x3c(%ebp)
   16cff:	ff 75 c0             	pushl  -0x40(%ebp)
   16d02:	e8 72 ac fe ff       	call   1979 <memmove>
   16d07:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   16d0a:	8b 45 08             	mov    0x8(%ebp),%eax
   16d0d:	8b 40 40             	mov    0x40(%eax),%eax
   16d10:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   16d13:	8b 45 08             	mov    0x8(%ebp),%eax
   16d16:	8b 40 38             	mov    0x38(%eax),%eax
   16d19:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   16d1c:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   16d20:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   16d24:	75 cc                	jne    16cf2 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   16d26:	8b 45 08             	mov    0x8(%ebp),%eax
   16d29:	8b 50 38             	mov    0x38(%eax),%edx
   16d2c:	8b 45 08             	mov    0x8(%ebp),%eax
   16d2f:	89 50 40             	mov    %edx,0x40(%eax)
   16d32:	eb 04                	jmp    16d38 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   16d34:	90                   	nop
   16d35:	eb 01                	jmp    16d38 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   16d37:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   16d38:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16d3b:	5b                   	pop    %ebx
   16d3c:	5e                   	pop    %esi
   16d3d:	5f                   	pop    %edi
   16d3e:	5d                   	pop    %ebp
   16d3f:	c3                   	ret    

00016d40 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   16d40:	55                   	push   %ebp
   16d41:	89 e5                	mov    %esp,%ebp
   16d43:	53                   	push   %ebx
   16d44:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   16d47:	8b 45 0c             	mov    0xc(%ebp),%eax
   16d4a:	8b 40 0c             	mov    0xc(%eax),%eax
   16d4d:	83 e8 03             	sub    $0x3,%eax
   16d50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   16d53:	8b 45 0c             	mov    0xc(%ebp),%eax
   16d56:	8b 50 0c             	mov    0xc(%eax),%edx
   16d59:	8b 45 0c             	mov    0xc(%ebp),%eax
   16d5c:	8b 40 10             	mov    0x10(%eax),%eax
   16d5f:	0f af c2             	imul   %edx,%eax
   16d62:	01 c0                	add    %eax,%eax
   16d64:	83 ec 0c             	sub    $0xc,%esp
   16d67:	50                   	push   %eax
   16d68:	e8 cb b0 fe ff       	call   1e38 <malloc>
   16d6d:	83 c4 10             	add    $0x10,%esp
   16d70:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   16d73:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   16d77:	75 0e                	jne    16d87 <_UpsampleH+0x47>
   16d79:	8b 45 08             	mov    0x8(%ebp),%eax
   16d7c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   16d82:	e9 44 03 00 00       	jmp    170cb <_UpsampleH+0x38b>
    lin = c->pixels;
   16d87:	8b 45 0c             	mov    0xc(%ebp),%eax
   16d8a:	8b 40 28             	mov    0x28(%eax),%eax
   16d8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   16d90:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16d93:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   16d96:	8b 45 0c             	mov    0xc(%ebp),%eax
   16d99:	8b 40 10             	mov    0x10(%eax),%eax
   16d9c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   16d9f:	e9 e0 02 00 00       	jmp    17084 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   16da4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16da7:	0f b6 00             	movzbl (%eax),%eax
   16daa:	0f b6 c0             	movzbl %al,%eax
   16dad:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   16db3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16db6:	83 c0 01             	add    $0x1,%eax
   16db9:	0f b6 00             	movzbl (%eax),%eax
   16dbc:	0f b6 c0             	movzbl %al,%eax
   16dbf:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16dc2:	01 d0                	add    %edx,%eax
   16dc4:	83 ec 0c             	sub    $0xc,%esp
   16dc7:	50                   	push   %eax
   16dc8:	e8 c4 06 00 00       	call   17491 <CF>
   16dcd:	83 c4 10             	add    $0x10,%esp
   16dd0:	89 c2                	mov    %eax,%edx
   16dd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16dd5:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   16dd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16dda:	8d 58 01             	lea    0x1(%eax),%ebx
   16ddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16de0:	0f b6 00             	movzbl (%eax),%eax
   16de3:	0f b6 c0             	movzbl %al,%eax
   16de6:	6b c8 68             	imul   $0x68,%eax,%ecx
   16de9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16dec:	83 c0 01             	add    $0x1,%eax
   16def:	0f b6 00             	movzbl (%eax),%eax
   16df2:	0f b6 d0             	movzbl %al,%edx
   16df5:	89 d0                	mov    %edx,%eax
   16df7:	01 c0                	add    %eax,%eax
   16df9:	01 d0                	add    %edx,%eax
   16dfb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16e02:	01 d0                	add    %edx,%eax
   16e04:	01 c1                	add    %eax,%ecx
   16e06:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e09:	83 c0 02             	add    $0x2,%eax
   16e0c:	0f b6 00             	movzbl (%eax),%eax
   16e0f:	0f b6 d0             	movzbl %al,%edx
   16e12:	89 d0                	mov    %edx,%eax
   16e14:	01 c0                	add    %eax,%eax
   16e16:	01 d0                	add    %edx,%eax
   16e18:	f7 d8                	neg    %eax
   16e1a:	01 c8                	add    %ecx,%eax
   16e1c:	83 ec 0c             	sub    $0xc,%esp
   16e1f:	50                   	push   %eax
   16e20:	e8 6c 06 00 00       	call   17491 <CF>
   16e25:	83 c4 10             	add    $0x10,%esp
   16e28:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   16e2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16e2d:	8d 58 02             	lea    0x2(%eax),%ebx
   16e30:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e33:	0f b6 00             	movzbl (%eax),%eax
   16e36:	0f b6 c0             	movzbl %al,%eax
   16e39:	c1 e0 02             	shl    $0x2,%eax
   16e3c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16e43:	29 c2                	sub    %eax,%edx
   16e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e48:	83 c0 01             	add    $0x1,%eax
   16e4b:	0f b6 00             	movzbl (%eax),%eax
   16e4e:	0f b6 c0             	movzbl %al,%eax
   16e51:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16e54:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e5a:	83 c0 02             	add    $0x2,%eax
   16e5d:	0f b6 00             	movzbl (%eax),%eax
   16e60:	0f b6 d0             	movzbl %al,%edx
   16e63:	89 d0                	mov    %edx,%eax
   16e65:	c1 e0 03             	shl    $0x3,%eax
   16e68:	01 d0                	add    %edx,%eax
   16e6a:	f7 d8                	neg    %eax
   16e6c:	01 c8                	add    %ecx,%eax
   16e6e:	83 ec 0c             	sub    $0xc,%esp
   16e71:	50                   	push   %eax
   16e72:	e8 1a 06 00 00       	call   17491 <CF>
   16e77:	83 c4 10             	add    $0x10,%esp
   16e7a:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   16e7c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   16e83:	e9 fa 00 00 00       	jmp    16f82 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   16e88:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16e8b:	01 c0                	add    %eax,%eax
   16e8d:	8d 50 03             	lea    0x3(%eax),%edx
   16e90:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16e93:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   16e96:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e9c:	01 d0                	add    %edx,%eax
   16e9e:	0f b6 00             	movzbl (%eax),%eax
   16ea1:	0f b6 d0             	movzbl %al,%edx
   16ea4:	89 d0                	mov    %edx,%eax
   16ea6:	c1 e0 03             	shl    $0x3,%eax
   16ea9:	01 d0                	add    %edx,%eax
   16eab:	f7 d8                	neg    %eax
   16ead:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16eb0:	8d 4a 01             	lea    0x1(%edx),%ecx
   16eb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16eb6:	01 ca                	add    %ecx,%edx
   16eb8:	0f b6 12             	movzbl (%edx),%edx
   16ebb:	0f b6 d2             	movzbl %dl,%edx
   16ebe:	6b d2 6f             	imul   $0x6f,%edx,%edx
   16ec1:	01 c2                	add    %eax,%edx
   16ec3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16ec6:	8d 48 02             	lea    0x2(%eax),%ecx
   16ec9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ecc:	01 c8                	add    %ecx,%eax
   16ece:	0f b6 00             	movzbl (%eax),%eax
   16ed1:	0f b6 c0             	movzbl %al,%eax
   16ed4:	6b c0 1d             	imul   $0x1d,%eax,%eax
   16ed7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16eda:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16edd:	8d 50 03             	lea    0x3(%eax),%edx
   16ee0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ee3:	01 d0                	add    %edx,%eax
   16ee5:	0f b6 00             	movzbl (%eax),%eax
   16ee8:	0f b6 d0             	movzbl %al,%edx
   16eeb:	89 d0                	mov    %edx,%eax
   16eed:	01 c0                	add    %eax,%eax
   16eef:	01 d0                	add    %edx,%eax
   16ef1:	f7 d8                	neg    %eax
   16ef3:	01 c8                	add    %ecx,%eax
   16ef5:	83 ec 0c             	sub    $0xc,%esp
   16ef8:	50                   	push   %eax
   16ef9:	e8 93 05 00 00       	call   17491 <CF>
   16efe:	83 c4 10             	add    $0x10,%esp
   16f01:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   16f03:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16f06:	01 c0                	add    %eax,%eax
   16f08:	8d 50 04             	lea    0x4(%eax),%edx
   16f0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16f0e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   16f11:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16f14:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16f17:	01 d0                	add    %edx,%eax
   16f19:	0f b6 00             	movzbl (%eax),%eax
   16f1c:	0f b6 d0             	movzbl %al,%edx
   16f1f:	89 d0                	mov    %edx,%eax
   16f21:	01 c0                	add    %eax,%eax
   16f23:	01 d0                	add    %edx,%eax
   16f25:	f7 d8                	neg    %eax
   16f27:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16f2a:	8d 4a 01             	lea    0x1(%edx),%ecx
   16f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16f30:	01 ca                	add    %ecx,%edx
   16f32:	0f b6 12             	movzbl (%edx),%edx
   16f35:	0f b6 d2             	movzbl %dl,%edx
   16f38:	6b d2 1d             	imul   $0x1d,%edx,%edx
   16f3b:	01 c2                	add    %eax,%edx
   16f3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16f40:	8d 48 02             	lea    0x2(%eax),%ecx
   16f43:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16f46:	01 c8                	add    %ecx,%eax
   16f48:	0f b6 00             	movzbl (%eax),%eax
   16f4b:	0f b6 c0             	movzbl %al,%eax
   16f4e:	6b c0 6f             	imul   $0x6f,%eax,%eax
   16f51:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16f54:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16f57:	8d 50 03             	lea    0x3(%eax),%edx
   16f5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16f5d:	01 d0                	add    %edx,%eax
   16f5f:	0f b6 00             	movzbl (%eax),%eax
   16f62:	0f b6 d0             	movzbl %al,%edx
   16f65:	89 d0                	mov    %edx,%eax
   16f67:	c1 e0 03             	shl    $0x3,%eax
   16f6a:	01 d0                	add    %edx,%eax
   16f6c:	f7 d8                	neg    %eax
   16f6e:	01 c8                	add    %ecx,%eax
   16f70:	83 ec 0c             	sub    $0xc,%esp
   16f73:	50                   	push   %eax
   16f74:	e8 18 05 00 00       	call   17491 <CF>
   16f79:	83 c4 10             	add    $0x10,%esp
   16f7c:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   16f7e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   16f82:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16f85:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16f88:	0f 8c fa fe ff ff    	jl     16e88 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   16f8e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f91:	8b 40 14             	mov    0x14(%eax),%eax
   16f94:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   16f97:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f9a:	8b 40 0c             	mov    0xc(%eax),%eax
   16f9d:	01 c0                	add    %eax,%eax
   16f9f:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   16fa2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16fa5:	8d 58 fd             	lea    -0x3(%eax),%ebx
   16fa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16fab:	83 e8 01             	sub    $0x1,%eax
   16fae:	0f b6 00             	movzbl (%eax),%eax
   16fb1:	0f b6 c0             	movzbl %al,%eax
   16fb4:	c1 e0 02             	shl    $0x2,%eax
   16fb7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16fbe:	29 c2                	sub    %eax,%edx
   16fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16fc3:	83 e8 02             	sub    $0x2,%eax
   16fc6:	0f b6 00             	movzbl (%eax),%eax
   16fc9:	0f b6 c0             	movzbl %al,%eax
   16fcc:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16fcf:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16fd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16fd5:	83 e8 03             	sub    $0x3,%eax
   16fd8:	0f b6 00             	movzbl (%eax),%eax
   16fdb:	0f b6 d0             	movzbl %al,%edx
   16fde:	89 d0                	mov    %edx,%eax
   16fe0:	c1 e0 03             	shl    $0x3,%eax
   16fe3:	01 d0                	add    %edx,%eax
   16fe5:	f7 d8                	neg    %eax
   16fe7:	01 c8                	add    %ecx,%eax
   16fe9:	83 ec 0c             	sub    $0xc,%esp
   16fec:	50                   	push   %eax
   16fed:	e8 9f 04 00 00       	call   17491 <CF>
   16ff2:	83 c4 10             	add    $0x10,%esp
   16ff5:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   16ff7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16ffa:	8d 58 fe             	lea    -0x2(%eax),%ebx
   16ffd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17000:	83 e8 01             	sub    $0x1,%eax
   17003:	0f b6 00             	movzbl (%eax),%eax
   17006:	0f b6 c0             	movzbl %al,%eax
   17009:	6b c8 68             	imul   $0x68,%eax,%ecx
   1700c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1700f:	83 e8 02             	sub    $0x2,%eax
   17012:	0f b6 00             	movzbl (%eax),%eax
   17015:	0f b6 d0             	movzbl %al,%edx
   17018:	89 d0                	mov    %edx,%eax
   1701a:	01 c0                	add    %eax,%eax
   1701c:	01 d0                	add    %edx,%eax
   1701e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   17025:	01 d0                	add    %edx,%eax
   17027:	01 c1                	add    %eax,%ecx
   17029:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1702c:	83 e8 03             	sub    $0x3,%eax
   1702f:	0f b6 00             	movzbl (%eax),%eax
   17032:	0f b6 d0             	movzbl %al,%edx
   17035:	89 d0                	mov    %edx,%eax
   17037:	01 c0                	add    %eax,%eax
   17039:	01 d0                	add    %edx,%eax
   1703b:	f7 d8                	neg    %eax
   1703d:	01 c8                	add    %ecx,%eax
   1703f:	83 ec 0c             	sub    $0xc,%esp
   17042:	50                   	push   %eax
   17043:	e8 49 04 00 00       	call   17491 <CF>
   17048:	83 c4 10             	add    $0x10,%esp
   1704b:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   1704d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17050:	8d 58 ff             	lea    -0x1(%eax),%ebx
   17053:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17056:	83 e8 01             	sub    $0x1,%eax
   17059:	0f b6 00             	movzbl (%eax),%eax
   1705c:	0f b6 c0             	movzbl %al,%eax
   1705f:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   17065:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17068:	83 e8 02             	sub    $0x2,%eax
   1706b:	0f b6 00             	movzbl (%eax),%eax
   1706e:	0f b6 c0             	movzbl %al,%eax
   17071:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   17074:	01 d0                	add    %edx,%eax
   17076:	83 ec 0c             	sub    $0xc,%esp
   17079:	50                   	push   %eax
   1707a:	e8 12 04 00 00       	call   17491 <CF>
   1707f:	83 c4 10             	add    $0x10,%esp
   17082:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   17084:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17087:	8d 50 ff             	lea    -0x1(%eax),%edx
   1708a:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1708d:	85 c0                	test   %eax,%eax
   1708f:	0f 85 0f fd ff ff    	jne    16da4 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   17095:	8b 45 0c             	mov    0xc(%ebp),%eax
   17098:	8b 40 0c             	mov    0xc(%eax),%eax
   1709b:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1709e:	8b 45 0c             	mov    0xc(%ebp),%eax
   170a1:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   170a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   170a7:	8b 50 0c             	mov    0xc(%eax),%edx
   170aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   170ad:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   170b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   170b3:	8b 40 28             	mov    0x28(%eax),%eax
   170b6:	83 ec 0c             	sub    $0xc,%esp
   170b9:	50                   	push   %eax
   170ba:	e8 37 ac fe ff       	call   1cf6 <free>
   170bf:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   170c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   170c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   170c8:	89 50 28             	mov    %edx,0x28(%eax)
}
   170cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   170ce:	c9                   	leave  
   170cf:	c3                   	ret    

000170d0 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   170d0:	55                   	push   %ebp
   170d1:	89 e5                	mov    %esp,%ebp
   170d3:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   170d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   170d9:	8b 40 0c             	mov    0xc(%eax),%eax
   170dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   170df:	8b 45 0c             	mov    0xc(%ebp),%eax
   170e2:	8b 40 14             	mov    0x14(%eax),%eax
   170e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
   170e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   170eb:	01 c0                	add    %eax,%eax
   170ed:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   170f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   170f3:	8b 50 0c             	mov    0xc(%eax),%edx
   170f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   170f9:	8b 40 10             	mov    0x10(%eax),%eax
   170fc:	0f af c2             	imul   %edx,%eax
   170ff:	01 c0                	add    %eax,%eax
   17101:	83 ec 0c             	sub    $0xc,%esp
   17104:	50                   	push   %eax
   17105:	e8 2e ad fe ff       	call   1e38 <malloc>
   1710a:	83 c4 10             	add    $0x10,%esp
   1710d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   17110:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   17114:	75 0e                	jne    17124 <_UpsampleV+0x54>
   17116:	8b 45 08             	mov    0x8(%ebp),%eax
   17119:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1711f:	e9 6b 03 00 00       	jmp    1748f <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   17124:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1712b:	e9 1d 03 00 00       	jmp    1744d <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   17130:	8b 45 0c             	mov    0xc(%ebp),%eax
   17133:	8b 50 28             	mov    0x28(%eax),%edx
   17136:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17139:	01 d0                	add    %edx,%eax
   1713b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   1713e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   17141:	8b 45 d8             	mov    -0x28(%ebp),%eax
   17144:	01 d0                	add    %edx,%eax
   17146:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   17149:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1714c:	0f b6 00             	movzbl (%eax),%eax
   1714f:	0f b6 c0             	movzbl %al,%eax
   17152:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   17158:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1715b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1715e:	01 c8                	add    %ecx,%eax
   17160:	0f b6 00             	movzbl (%eax),%eax
   17163:	0f b6 c0             	movzbl %al,%eax
   17166:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   17169:	01 d0                	add    %edx,%eax
   1716b:	83 ec 0c             	sub    $0xc,%esp
   1716e:	50                   	push   %eax
   1716f:	e8 1d 03 00 00       	call   17491 <CF>
   17174:	83 c4 10             	add    $0x10,%esp
   17177:	89 c2                	mov    %eax,%edx
   17179:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1717c:	88 10                	mov    %dl,(%eax)
   1717e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17181:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   17184:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17187:	0f b6 00             	movzbl (%eax),%eax
   1718a:	0f b6 c0             	movzbl %al,%eax
   1718d:	6b c8 68             	imul   $0x68,%eax,%ecx
   17190:	8b 55 e0             	mov    -0x20(%ebp),%edx
   17193:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17196:	01 d0                	add    %edx,%eax
   17198:	0f b6 00             	movzbl (%eax),%eax
   1719b:	0f b6 d0             	movzbl %al,%edx
   1719e:	89 d0                	mov    %edx,%eax
   171a0:	01 c0                	add    %eax,%eax
   171a2:	01 d0                	add    %edx,%eax
   171a4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   171ab:	01 d0                	add    %edx,%eax
   171ad:	01 c1                	add    %eax,%ecx
   171af:	8b 55 dc             	mov    -0x24(%ebp),%edx
   171b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   171b5:	01 d0                	add    %edx,%eax
   171b7:	0f b6 00             	movzbl (%eax),%eax
   171ba:	0f b6 d0             	movzbl %al,%edx
   171bd:	89 d0                	mov    %edx,%eax
   171bf:	01 c0                	add    %eax,%eax
   171c1:	01 d0                	add    %edx,%eax
   171c3:	f7 d8                	neg    %eax
   171c5:	01 c8                	add    %ecx,%eax
   171c7:	83 ec 0c             	sub    $0xc,%esp
   171ca:	50                   	push   %eax
   171cb:	e8 c1 02 00 00       	call   17491 <CF>
   171d0:	83 c4 10             	add    $0x10,%esp
   171d3:	89 c2                	mov    %eax,%edx
   171d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   171d8:	88 10                	mov    %dl,(%eax)
   171da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   171dd:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   171e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   171e3:	0f b6 00             	movzbl (%eax),%eax
   171e6:	0f b6 c0             	movzbl %al,%eax
   171e9:	c1 e0 02             	shl    $0x2,%eax
   171ec:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   171f3:	89 d1                	mov    %edx,%ecx
   171f5:	29 c1                	sub    %eax,%ecx
   171f7:	8b 55 e0             	mov    -0x20(%ebp),%edx
   171fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   171fd:	01 d0                	add    %edx,%eax
   171ff:	0f b6 00             	movzbl (%eax),%eax
   17202:	0f b6 c0             	movzbl %al,%eax
   17205:	6b c0 6d             	imul   $0x6d,%eax,%eax
   17208:	01 c1                	add    %eax,%ecx
   1720a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1720d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17210:	01 d0                	add    %edx,%eax
   17212:	0f b6 00             	movzbl (%eax),%eax
   17215:	0f b6 d0             	movzbl %al,%edx
   17218:	89 d0                	mov    %edx,%eax
   1721a:	c1 e0 03             	shl    $0x3,%eax
   1721d:	01 d0                	add    %edx,%eax
   1721f:	f7 d8                	neg    %eax
   17221:	01 c8                	add    %ecx,%eax
   17223:	83 ec 0c             	sub    $0xc,%esp
   17226:	50                   	push   %eax
   17227:	e8 65 02 00 00       	call   17491 <CF>
   1722c:	83 c4 10             	add    $0x10,%esp
   1722f:	89 c2                	mov    %eax,%edx
   17231:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17234:	88 10                	mov    %dl,(%eax)
   17236:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17239:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   1723c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1723f:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   17242:	8b 45 0c             	mov    0xc(%ebp),%eax
   17245:	8b 40 10             	mov    0x10(%eax),%eax
   17248:	83 e8 03             	sub    $0x3,%eax
   1724b:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1724e:	e9 e6 00 00 00       	jmp    17339 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   17253:	8b 45 e0             	mov    -0x20(%ebp),%eax
   17256:	f7 d8                	neg    %eax
   17258:	89 c2                	mov    %eax,%edx
   1725a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1725d:	01 d0                	add    %edx,%eax
   1725f:	0f b6 00             	movzbl (%eax),%eax
   17262:	0f b6 d0             	movzbl %al,%edx
   17265:	89 d0                	mov    %edx,%eax
   17267:	c1 e0 03             	shl    $0x3,%eax
   1726a:	01 d0                	add    %edx,%eax
   1726c:	f7 d8                	neg    %eax
   1726e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17271:	0f b6 12             	movzbl (%edx),%edx
   17274:	0f b6 d2             	movzbl %dl,%edx
   17277:	6b d2 6f             	imul   $0x6f,%edx,%edx
   1727a:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1727d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   17280:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17283:	01 d0                	add    %edx,%eax
   17285:	0f b6 00             	movzbl (%eax),%eax
   17288:	0f b6 c0             	movzbl %al,%eax
   1728b:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1728e:	01 c1                	add    %eax,%ecx
   17290:	8b 55 dc             	mov    -0x24(%ebp),%edx
   17293:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17296:	01 d0                	add    %edx,%eax
   17298:	0f b6 00             	movzbl (%eax),%eax
   1729b:	0f b6 d0             	movzbl %al,%edx
   1729e:	89 d0                	mov    %edx,%eax
   172a0:	01 c0                	add    %eax,%eax
   172a2:	01 d0                	add    %edx,%eax
   172a4:	f7 d8                	neg    %eax
   172a6:	01 c8                	add    %ecx,%eax
   172a8:	83 ec 0c             	sub    $0xc,%esp
   172ab:	50                   	push   %eax
   172ac:	e8 e0 01 00 00       	call   17491 <CF>
   172b1:	83 c4 10             	add    $0x10,%esp
   172b4:	89 c2                	mov    %eax,%edx
   172b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   172b9:	88 10                	mov    %dl,(%eax)
   172bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   172be:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   172c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   172c4:	f7 d8                	neg    %eax
   172c6:	89 c2                	mov    %eax,%edx
   172c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   172cb:	01 d0                	add    %edx,%eax
   172cd:	0f b6 00             	movzbl (%eax),%eax
   172d0:	0f b6 d0             	movzbl %al,%edx
   172d3:	89 d0                	mov    %edx,%eax
   172d5:	01 c0                	add    %eax,%eax
   172d7:	01 d0                	add    %edx,%eax
   172d9:	f7 d8                	neg    %eax
   172db:	8b 55 f4             	mov    -0xc(%ebp),%edx
   172de:	0f b6 12             	movzbl (%edx),%edx
   172e1:	0f b6 d2             	movzbl %dl,%edx
   172e4:	6b d2 1d             	imul   $0x1d,%edx,%edx
   172e7:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   172ea:	8b 55 e0             	mov    -0x20(%ebp),%edx
   172ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   172f0:	01 d0                	add    %edx,%eax
   172f2:	0f b6 00             	movzbl (%eax),%eax
   172f5:	0f b6 c0             	movzbl %al,%eax
   172f8:	6b c0 6f             	imul   $0x6f,%eax,%eax
   172fb:	01 c1                	add    %eax,%ecx
   172fd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   17300:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17303:	01 d0                	add    %edx,%eax
   17305:	0f b6 00             	movzbl (%eax),%eax
   17308:	0f b6 d0             	movzbl %al,%edx
   1730b:	89 d0                	mov    %edx,%eax
   1730d:	c1 e0 03             	shl    $0x3,%eax
   17310:	01 d0                	add    %edx,%eax
   17312:	f7 d8                	neg    %eax
   17314:	01 c8                	add    %ecx,%eax
   17316:	83 ec 0c             	sub    $0xc,%esp
   17319:	50                   	push   %eax
   1731a:	e8 72 01 00 00       	call   17491 <CF>
   1731f:	83 c4 10             	add    $0x10,%esp
   17322:	89 c2                	mov    %eax,%edx
   17324:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17327:	88 10                	mov    %dl,(%eax)
   17329:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1732c:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   1732f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   17332:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   17335:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   17339:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1733d:	0f 85 10 ff ff ff    	jne    17253 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   17343:	8b 45 e0             	mov    -0x20(%ebp),%eax
   17346:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   17349:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1734c:	0f b6 00             	movzbl (%eax),%eax
   1734f:	0f b6 c0             	movzbl %al,%eax
   17352:	c1 e0 02             	shl    $0x2,%eax
   17355:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1735c:	29 c2                	sub    %eax,%edx
   1735e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   17361:	f7 d8                	neg    %eax
   17363:	89 c1                	mov    %eax,%ecx
   17365:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17368:	01 c8                	add    %ecx,%eax
   1736a:	0f b6 00             	movzbl (%eax),%eax
   1736d:	0f b6 c0             	movzbl %al,%eax
   17370:	6b c0 6d             	imul   $0x6d,%eax,%eax
   17373:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   17376:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17379:	f7 d8                	neg    %eax
   1737b:	89 c2                	mov    %eax,%edx
   1737d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17380:	01 d0                	add    %edx,%eax
   17382:	0f b6 00             	movzbl (%eax),%eax
   17385:	0f b6 d0             	movzbl %al,%edx
   17388:	89 d0                	mov    %edx,%eax
   1738a:	c1 e0 03             	shl    $0x3,%eax
   1738d:	01 d0                	add    %edx,%eax
   1738f:	f7 d8                	neg    %eax
   17391:	01 c8                	add    %ecx,%eax
   17393:	83 ec 0c             	sub    $0xc,%esp
   17396:	50                   	push   %eax
   17397:	e8 f5 00 00 00       	call   17491 <CF>
   1739c:	83 c4 10             	add    $0x10,%esp
   1739f:	89 c2                	mov    %eax,%edx
   173a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   173a4:	88 10                	mov    %dl,(%eax)
   173a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   173a9:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   173ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   173af:	0f b6 00             	movzbl (%eax),%eax
   173b2:	0f b6 c0             	movzbl %al,%eax
   173b5:	6b c8 68             	imul   $0x68,%eax,%ecx
   173b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   173bb:	f7 d8                	neg    %eax
   173bd:	89 c2                	mov    %eax,%edx
   173bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   173c2:	01 d0                	add    %edx,%eax
   173c4:	0f b6 00             	movzbl (%eax),%eax
   173c7:	0f b6 d0             	movzbl %al,%edx
   173ca:	89 d0                	mov    %edx,%eax
   173cc:	01 c0                	add    %eax,%eax
   173ce:	01 d0                	add    %edx,%eax
   173d0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   173d7:	01 d0                	add    %edx,%eax
   173d9:	01 c1                	add    %eax,%ecx
   173db:	8b 45 dc             	mov    -0x24(%ebp),%eax
   173de:	f7 d8                	neg    %eax
   173e0:	89 c2                	mov    %eax,%edx
   173e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   173e5:	01 d0                	add    %edx,%eax
   173e7:	0f b6 00             	movzbl (%eax),%eax
   173ea:	0f b6 d0             	movzbl %al,%edx
   173ed:	89 d0                	mov    %edx,%eax
   173ef:	01 c0                	add    %eax,%eax
   173f1:	01 d0                	add    %edx,%eax
   173f3:	f7 d8                	neg    %eax
   173f5:	01 c8                	add    %ecx,%eax
   173f7:	83 ec 0c             	sub    $0xc,%esp
   173fa:	50                   	push   %eax
   173fb:	e8 91 00 00 00       	call   17491 <CF>
   17400:	83 c4 10             	add    $0x10,%esp
   17403:	89 c2                	mov    %eax,%edx
   17405:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17408:	88 10                	mov    %dl,(%eax)
   1740a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1740d:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   17410:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17413:	0f b6 00             	movzbl (%eax),%eax
   17416:	0f b6 c0             	movzbl %al,%eax
   17419:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1741f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   17422:	f7 d8                	neg    %eax
   17424:	89 c1                	mov    %eax,%ecx
   17426:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17429:	01 c8                	add    %ecx,%eax
   1742b:	0f b6 00             	movzbl (%eax),%eax
   1742e:	0f b6 c0             	movzbl %al,%eax
   17431:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   17434:	01 d0                	add    %edx,%eax
   17436:	83 ec 0c             	sub    $0xc,%esp
   17439:	50                   	push   %eax
   1743a:	e8 52 00 00 00       	call   17491 <CF>
   1743f:	83 c4 10             	add    $0x10,%esp
   17442:	89 c2                	mov    %eax,%edx
   17444:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17447:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   17449:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1744d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17450:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   17453:	0f 8c d7 fc ff ff    	jl     17130 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   17459:	8b 45 0c             	mov    0xc(%ebp),%eax
   1745c:	8b 40 10             	mov    0x10(%eax),%eax
   1745f:	8d 14 00             	lea    (%eax,%eax,1),%edx
   17462:	8b 45 0c             	mov    0xc(%ebp),%eax
   17465:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   17468:	8b 45 0c             	mov    0xc(%ebp),%eax
   1746b:	8b 50 0c             	mov    0xc(%eax),%edx
   1746e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17471:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   17474:	8b 45 0c             	mov    0xc(%ebp),%eax
   17477:	8b 40 28             	mov    0x28(%eax),%eax
   1747a:	83 ec 0c             	sub    $0xc,%esp
   1747d:	50                   	push   %eax
   1747e:	e8 73 a8 fe ff       	call   1cf6 <free>
   17483:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   17486:	8b 45 0c             	mov    0xc(%ebp),%eax
   17489:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1748c:	89 50 28             	mov    %edx,0x28(%eax)
}
   1748f:	c9                   	leave  
   17490:	c3                   	ret    

00017491 <CF>:

uchar CF(const int x){
   17491:	55                   	push   %ebp
   17492:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   17494:	8b 45 08             	mov    0x8(%ebp),%eax
   17497:	83 c0 40             	add    $0x40,%eax
   1749a:	c1 f8 07             	sar    $0x7,%eax
   1749d:	50                   	push   %eax
   1749e:	e8 e9 dd ff ff       	call   1528c <_Clip>
   174a3:	83 c4 04             	add    $0x4,%esp
}
   174a6:	c9                   	leave  
   174a7:	c3                   	ret    
