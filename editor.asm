
_editor：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <MsgProc>:
#define CHARWIDTH 10
#define CHARHEIGHT 20
#define SCREENWIDTH 400
#define SCREENHEIGHT 300 
void MsgProc(struct message * msg)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	81 ec d8 01 00 00    	sub    $0x1d8,%esp
    switch(msg->msg_type)
       9:	8b 45 08             	mov    0x8(%ebp),%eax
       c:	8b 00                	mov    (%eax),%eax
       e:	83 f8 02             	cmp    $0x2,%eax
      11:	74 24                	je     37 <MsgProc+0x37>
      13:	83 f8 02             	cmp    $0x2,%eax
      16:	7f 08                	jg     20 <MsgProc+0x20>
      18:	83 f8 01             	cmp    $0x1,%eax
                    api_repaint(&wnd);
                }
            }
            break;
        case M_KEY_UP:
            break;
      1b:	e9 67 0f 00 00       	jmp    f87 <MsgProc+0xf87>
#define CHARHEIGHT 20
#define SCREENWIDTH 400
#define SCREENHEIGHT 300 
void MsgProc(struct message * msg)
{
    switch(msg->msg_type)
      20:	83 f8 06             	cmp    $0x6,%eax
      23:	0f 84 c9 0a 00 00    	je     af2 <MsgProc+0xaf2>
      29:	83 f8 0a             	cmp    $0xa,%eax
      2c:	0f 84 2e 0f 00 00    	je     f60 <MsgProc+0xf60>
        case M_CLOSE_WINDOW:
            free(background);
            api_destroywindow(&wnd);
            break;
    }
}
      32:	e9 50 0f 00 00       	jmp    f87 <MsgProc+0xf87>
void MsgProc(struct message * msg)
{
    switch(msg->msg_type)
    {
        case M_KEY_DOWN:
            if (msg->params[0]==226)
      37:	8b 45 08             	mov    0x8(%ebp),%eax
      3a:	8b 40 04             	mov    0x4(%eax),%eax
      3d:	3d e2 00 00 00       	cmp    $0xe2,%eax
      42:	75 48                	jne    8c <MsgProc+0x8c>
            {
                if (pos_y!=40)
      44:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
      49:	83 f8 28             	cmp    $0x28,%eax
      4c:	0f 84 f3 08 00 00    	je     945 <MsgProc+0x945>
                {
                    pos_y-=CHARHEIGHT;
      52:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
      57:	83 e8 14             	sub    $0x14,%eax
      5a:	a3 c0 f6 01 00       	mov    %eax,0x1f6c0
                    if (page==0)
      5f:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
      64:	85 c0                	test   %eax,%eax
      66:	75 12                	jne    7a <MsgProc+0x7a>
                    {
                        first-=39;
      68:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
      6d:	83 e8 27             	sub    $0x27,%eax
      70:	a3 d0 fc 01 00       	mov    %eax,0x1fcd0
      75:	e9 cb 08 00 00       	jmp    945 <MsgProc+0x945>
                    }
                    else
                    {
                        second-=39;    
      7a:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
      7f:	83 e8 27             	sub    $0x27,%eax
      82:	a3 d4 fc 01 00       	mov    %eax,0x1fcd4
      87:	e9 b9 08 00 00       	jmp    945 <MsgProc+0x945>
                    }
                }
            }
            else if (msg->params[0]==227)
      8c:	8b 45 08             	mov    0x8(%ebp),%eax
      8f:	8b 40 04             	mov    0x4(%eax),%eax
      92:	3d e3 00 00 00       	cmp    $0xe3,%eax
      97:	75 4a                	jne    e3 <MsgProc+0xe3>
            {
                if(pos_y!=SCREENHEIGHT-CHARHEIGHT)
      99:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
      9e:	3d 18 01 00 00       	cmp    $0x118,%eax
      a3:	0f 84 9c 08 00 00    	je     945 <MsgProc+0x945>
                {
                    pos_y+=CHARHEIGHT;
      a9:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
      ae:	83 c0 14             	add    $0x14,%eax
      b1:	a3 c0 f6 01 00       	mov    %eax,0x1f6c0
                    if (page==0)
      b6:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
      bb:	85 c0                	test   %eax,%eax
      bd:	75 12                	jne    d1 <MsgProc+0xd1>
                    {
                        first+=39;
      bf:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
      c4:	83 c0 27             	add    $0x27,%eax
      c7:	a3 d0 fc 01 00       	mov    %eax,0x1fcd0
      cc:	e9 74 08 00 00       	jmp    945 <MsgProc+0x945>
                    }
                    else
                    {
                        second+=39;    
      d1:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
      d6:	83 c0 27             	add    $0x27,%eax
      d9:	a3 d4 fc 01 00       	mov    %eax,0x1fcd4
      de:	e9 62 08 00 00       	jmp    945 <MsgProc+0x945>
                    }
                }
            }
            else if (msg->params[0]==228)
      e3:	8b 45 08             	mov    0x8(%ebp),%eax
      e6:	8b 40 04             	mov    0x4(%eax),%eax
      e9:	3d e4 00 00 00       	cmp    $0xe4,%eax
      ee:	0f 85 29 05 00 00    	jne    61d <MsgProc+0x61d>
            {
                if (msg->params[1]==1)
      f4:	8b 45 08             	mov    0x8(%ebp),%eax
      f7:	8b 40 08             	mov    0x8(%eax),%eax
      fa:	83 f8 01             	cmp    $0x1,%eax
      fd:	0f 85 d3 04 00 00    	jne    5d6 <MsgProc+0x5d6>
                {
                    if (page==0)
     103:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     108:	85 c0                	test   %eax,%eax
     10a:	0f 85 5c 02 00 00    	jne    36c <MsgProc+0x36c>
                    {
                        page = 1;
     110:	c7 05 d8 fc 01 00 01 	movl   $0x1,0x1fcd8
     117:	00 00 00 
                        pos_x=0;
     11a:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     121:	00 00 00 
                        pos_y=40;
     124:	c7 05 c0 f6 01 00 28 	movl   $0x28,0x1f6c0
     12b:	00 00 00 
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
     12e:	c7 85 28 fe ff ff 2c 	movl   $0x12c,-0x1d8(%ebp)
     135:	01 00 00 
     138:	c7 85 2c fe ff ff 90 	movl   $0x190,-0x1d4(%ebp)
     13f:	01 00 00 
     142:	c7 85 30 fe ff ff 2c 	movl   $0x12c,-0x1d0(%ebp)
     149:	01 00 00 
     14c:	c7 85 34 fe ff ff 90 	movl   $0x190,-0x1cc(%ebp)
     153:	01 00 00 
     156:	c7 85 38 fe ff ff 00 	movl   $0x0,-0x1c8(%ebp)
     15d:	00 00 00 
     160:	c7 85 3c fe ff ff 00 	movl   $0x0,-0x1c4(%ebp)
     167:	00 00 00 
     16a:	c7 85 40 fe ff ff 00 	movl   $0x0,-0x1c0(%ebp)
     171:	00 00 00 
     174:	c7 85 44 fe ff ff 00 	movl   $0x0,-0x1bc(%ebp)
     17b:	00 00 00 
     17e:	a1 a0 fe 01 00       	mov    0x1fea0,%eax
     183:	83 ec 08             	sub    $0x8,%esp
     186:	ff b5 2c fe ff ff    	pushl  -0x1d4(%ebp)
     18c:	ff b5 28 fe ff ff    	pushl  -0x1d8(%ebp)
     192:	ff b5 34 fe ff ff    	pushl  -0x1cc(%ebp)
     198:	ff b5 30 fe ff ff    	pushl  -0x1d0(%ebp)
     19e:	ff b5 3c fe ff ff    	pushl  -0x1c4(%ebp)
     1a4:	ff b5 38 fe ff ff    	pushl  -0x1c8(%ebp)
     1aa:	ff b5 44 fe ff ff    	pushl  -0x1bc(%ebp)
     1b0:	ff b5 40 fe ff ff    	pushl  -0x1c0(%ebp)
     1b6:	50                   	push   %eax
     1b7:	68 c0 fe 01 00       	push   $0x1fec0
     1bc:	e8 bb 21 00 00       	call   237c <api_paint24BitmapToContent>
     1c1:	83 c4 30             	add    $0x30,%esp
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
     1c4:	c7 85 48 fe ff ff 1e 	movl   $0x1e,-0x1b8(%ebp)
     1cb:	00 00 00 
     1ce:	c7 85 4c fe ff ff 32 	movl   $0x32,-0x1b4(%ebp)
     1d5:	00 00 00 
     1d8:	c7 85 50 fe ff ff 00 	movl   $0x0,-0x1b0(%ebp)
     1df:	00 00 00 
     1e2:	c7 85 54 fe ff ff 00 	movl   $0x0,-0x1ac(%ebp)
     1e9:	00 00 00 
     1ec:	83 ec 08             	sub    $0x8,%esp
     1ef:	68 d0 f6 01 00       	push   $0x1f6d0
     1f4:	ff b5 4c fe ff ff    	pushl  -0x1b4(%ebp)
     1fa:	ff b5 48 fe ff ff    	pushl  -0x1b8(%ebp)
     200:	ff b5 54 fe ff ff    	pushl  -0x1ac(%ebp)
     206:	ff b5 50 fe ff ff    	pushl  -0x1b0(%ebp)
     20c:	68 c0 fe 01 00       	push   $0x1fec0
     211:	e8 5f 23 00 00       	call   2575 <api_drawButton>
     216:	83 c4 20             	add    $0x20,%esp
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
     219:	c7 85 58 fe ff ff 1e 	movl   $0x1e,-0x1a8(%ebp)
     220:	00 00 00 
     223:	c7 85 5c fe ff ff 32 	movl   $0x32,-0x1a4(%ebp)
     22a:	00 00 00 
     22d:	c7 85 60 fe ff ff 3c 	movl   $0x3c,-0x1a0(%ebp)
     234:	00 00 00 
     237:	c7 85 64 fe ff ff 00 	movl   $0x0,-0x19c(%ebp)
     23e:	00 00 00 
     241:	83 ec 08             	sub    $0x8,%esp
     244:	68 d8 f6 01 00       	push   $0x1f6d8
     249:	ff b5 5c fe ff ff    	pushl  -0x1a4(%ebp)
     24f:	ff b5 58 fe ff ff    	pushl  -0x1a8(%ebp)
     255:	ff b5 64 fe ff ff    	pushl  -0x19c(%ebp)
     25b:	ff b5 60 fe ff ff    	pushl  -0x1a0(%ebp)
     261:	68 c0 fe 01 00       	push   $0x1fec0
     266:	e8 0a 23 00 00       	call   2575 <api_drawButton>
     26b:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
     26e:	83 ec 0c             	sub    $0xc,%esp
     271:	68 c0 fe 01 00       	push   $0x1fec0
     276:	e8 81 21 00 00       	call   23fc <api_repaint>
     27b:	83 c4 10             	add    $0x10,%esp
                        int i = 0;
     27e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        for (i=0;i<=second;i++)
     285:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     28c:	e9 bb 00 00 00       	jmp    34c <MsgProc+0x34c>
                        {
                             api_drawCharacter(&wnd,pos_x,pos_y,secondPage[i],black);
     291:	8b 45 f4             	mov    -0xc(%ebp),%eax
     294:	05 e0 fc 01 00       	add    $0x1fce0,%eax
     299:	0f b6 00             	movzbl (%eax),%eax
     29c:	0f be c8             	movsbl %al,%ecx
     29f:	8b 15 c0 f6 01 00    	mov    0x1f6c0,%edx
     2a5:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     2aa:	83 ec 0c             	sub    $0xc,%esp
     2ad:	ff 35 c4 f6 01 00    	pushl  0x1f6c4
     2b3:	51                   	push   %ecx
     2b4:	52                   	push   %edx
     2b5:	50                   	push   %eax
     2b6:	68 c0 fe 01 00       	push   $0x1fec0
     2bb:	e8 2d 22 00 00       	call   24ed <api_drawCharacter>
     2c0:	83 c4 20             	add    $0x20,%esp
                             pos_x+=CHARWIDTH;
     2c3:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     2c8:	83 c0 0a             	add    $0xa,%eax
     2cb:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                             api_update(&wnd,(Rect){pos_x-CHARWIDTH,pos_y,CHARWIDTH,CHARHEIGHT});
     2d0:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     2d5:	83 e8 0a             	sub    $0xa,%eax
     2d8:	89 85 68 fe ff ff    	mov    %eax,-0x198(%ebp)
     2de:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     2e3:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
     2e9:	c7 85 70 fe ff ff 0a 	movl   $0xa,-0x190(%ebp)
     2f0:	00 00 00 
     2f3:	c7 85 74 fe ff ff 14 	movl   $0x14,-0x18c(%ebp)
     2fa:	00 00 00 
     2fd:	83 ec 0c             	sub    $0xc,%esp
     300:	ff b5 74 fe ff ff    	pushl  -0x18c(%ebp)
     306:	ff b5 70 fe ff ff    	pushl  -0x190(%ebp)
     30c:	ff b5 6c fe ff ff    	pushl  -0x194(%ebp)
     312:	ff b5 68 fe ff ff    	pushl  -0x198(%ebp)
     318:	68 c0 fe 01 00       	push   $0x1fec0
     31d:	e8 f8 20 00 00       	call   241a <api_update>
     322:	83 c4 20             	add    $0x20,%esp
                             if (pos_x==39*CHARWIDTH)
     325:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     32a:	3d 86 01 00 00       	cmp    $0x186,%eax
     32f:	75 17                	jne    348 <MsgProc+0x348>
                             {
                                 pos_x=0;
     331:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     338:	00 00 00 
                                 pos_y+=CHARHEIGHT;
     33b:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     340:	83 c0 14             	add    $0x14,%eax
     343:	a3 c0 f6 01 00       	mov    %eax,0x1f6c0
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
                        api_repaint(&wnd);
                        int i = 0;
                        for (i=0;i<=second;i++)
     348:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     34c:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     351:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     354:	0f 8e 37 ff ff ff    	jle    291 <MsgProc+0x291>
                             {
                                 pos_x=0;
                                 pos_y+=CHARHEIGHT;
                             }
                        }
                        pos_x-=CHARWIDTH;
     35a:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     35f:	83 e8 0a             	sub    $0xa,%eax
     362:	a3 20 fb 01 00       	mov    %eax,0x1fb20
     367:	e9 d9 05 00 00       	jmp    945 <MsgProc+0x945>
                    }
                    else if (page==1)
     36c:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     371:	83 f8 01             	cmp    $0x1,%eax
     374:	0f 85 cb 05 00 00    	jne    945 <MsgProc+0x945>
                    {
                        page = 0;
     37a:	c7 05 d8 fc 01 00 00 	movl   $0x0,0x1fcd8
     381:	00 00 00 
                        pos_x=0;
     384:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     38b:	00 00 00 
                        pos_y=40;
     38e:	c7 05 c0 f6 01 00 28 	movl   $0x28,0x1f6c0
     395:	00 00 00 
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
     398:	c7 85 78 fe ff ff 2c 	movl   $0x12c,-0x188(%ebp)
     39f:	01 00 00 
     3a2:	c7 85 7c fe ff ff 90 	movl   $0x190,-0x184(%ebp)
     3a9:	01 00 00 
     3ac:	c7 85 80 fe ff ff 2c 	movl   $0x12c,-0x180(%ebp)
     3b3:	01 00 00 
     3b6:	c7 85 84 fe ff ff 90 	movl   $0x190,-0x17c(%ebp)
     3bd:	01 00 00 
     3c0:	c7 85 88 fe ff ff 00 	movl   $0x0,-0x178(%ebp)
     3c7:	00 00 00 
     3ca:	c7 85 8c fe ff ff 00 	movl   $0x0,-0x174(%ebp)
     3d1:	00 00 00 
     3d4:	c7 85 90 fe ff ff 00 	movl   $0x0,-0x170(%ebp)
     3db:	00 00 00 
     3de:	c7 85 94 fe ff ff 00 	movl   $0x0,-0x16c(%ebp)
     3e5:	00 00 00 
     3e8:	a1 a0 fe 01 00       	mov    0x1fea0,%eax
     3ed:	83 ec 08             	sub    $0x8,%esp
     3f0:	ff b5 7c fe ff ff    	pushl  -0x184(%ebp)
     3f6:	ff b5 78 fe ff ff    	pushl  -0x188(%ebp)
     3fc:	ff b5 84 fe ff ff    	pushl  -0x17c(%ebp)
     402:	ff b5 80 fe ff ff    	pushl  -0x180(%ebp)
     408:	ff b5 8c fe ff ff    	pushl  -0x174(%ebp)
     40e:	ff b5 88 fe ff ff    	pushl  -0x178(%ebp)
     414:	ff b5 94 fe ff ff    	pushl  -0x16c(%ebp)
     41a:	ff b5 90 fe ff ff    	pushl  -0x170(%ebp)
     420:	50                   	push   %eax
     421:	68 c0 fe 01 00       	push   $0x1fec0
     426:	e8 51 1f 00 00       	call   237c <api_paint24BitmapToContent>
     42b:	83 c4 30             	add    $0x30,%esp
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
     42e:	c7 85 98 fe ff ff 1e 	movl   $0x1e,-0x168(%ebp)
     435:	00 00 00 
     438:	c7 85 9c fe ff ff 32 	movl   $0x32,-0x164(%ebp)
     43f:	00 00 00 
     442:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
     449:	00 00 00 
     44c:	c7 85 a4 fe ff ff 00 	movl   $0x0,-0x15c(%ebp)
     453:	00 00 00 
     456:	83 ec 08             	sub    $0x8,%esp
     459:	68 d0 f6 01 00       	push   $0x1f6d0
     45e:	ff b5 9c fe ff ff    	pushl  -0x164(%ebp)
     464:	ff b5 98 fe ff ff    	pushl  -0x168(%ebp)
     46a:	ff b5 a4 fe ff ff    	pushl  -0x15c(%ebp)
     470:	ff b5 a0 fe ff ff    	pushl  -0x160(%ebp)
     476:	68 c0 fe 01 00       	push   $0x1fec0
     47b:	e8 f5 20 00 00       	call   2575 <api_drawButton>
     480:	83 c4 20             	add    $0x20,%esp
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
     483:	c7 85 a8 fe ff ff 1e 	movl   $0x1e,-0x158(%ebp)
     48a:	00 00 00 
     48d:	c7 85 ac fe ff ff 32 	movl   $0x32,-0x154(%ebp)
     494:	00 00 00 
     497:	c7 85 b0 fe ff ff 3c 	movl   $0x3c,-0x150(%ebp)
     49e:	00 00 00 
     4a1:	c7 85 b4 fe ff ff 00 	movl   $0x0,-0x14c(%ebp)
     4a8:	00 00 00 
     4ab:	83 ec 08             	sub    $0x8,%esp
     4ae:	68 d8 f6 01 00       	push   $0x1f6d8
     4b3:	ff b5 ac fe ff ff    	pushl  -0x154(%ebp)
     4b9:	ff b5 a8 fe ff ff    	pushl  -0x158(%ebp)
     4bf:	ff b5 b4 fe ff ff    	pushl  -0x14c(%ebp)
     4c5:	ff b5 b0 fe ff ff    	pushl  -0x150(%ebp)
     4cb:	68 c0 fe 01 00       	push   $0x1fec0
     4d0:	e8 a0 20 00 00       	call   2575 <api_drawButton>
     4d5:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
     4d8:	83 ec 0c             	sub    $0xc,%esp
     4db:	68 c0 fe 01 00       	push   $0x1fec0
     4e0:	e8 17 1f 00 00       	call   23fc <api_repaint>
     4e5:	83 c4 10             	add    $0x10,%esp
                        int i = 0;
     4e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
                        for (i=0;i<=first;i++)
     4ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     4f6:	e9 bb 00 00 00       	jmp    5b6 <MsgProc+0x5b6>
                        {
                             api_drawCharacter(&wnd,pos_x,pos_y,firstPage[i],black);
     4fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
     4fe:	05 40 fb 01 00       	add    $0x1fb40,%eax
     503:	0f b6 00             	movzbl (%eax),%eax
     506:	0f be c8             	movsbl %al,%ecx
     509:	8b 15 c0 f6 01 00    	mov    0x1f6c0,%edx
     50f:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     514:	83 ec 0c             	sub    $0xc,%esp
     517:	ff 35 c4 f6 01 00    	pushl  0x1f6c4
     51d:	51                   	push   %ecx
     51e:	52                   	push   %edx
     51f:	50                   	push   %eax
     520:	68 c0 fe 01 00       	push   $0x1fec0
     525:	e8 c3 1f 00 00       	call   24ed <api_drawCharacter>
     52a:	83 c4 20             	add    $0x20,%esp
                             pos_x+=CHARWIDTH;
     52d:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     532:	83 c0 0a             	add    $0xa,%eax
     535:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                             api_update(&wnd,(Rect){pos_x-CHARWIDTH,pos_y,CHARWIDTH,CHARHEIGHT});
     53a:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     53f:	83 e8 0a             	sub    $0xa,%eax
     542:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
     548:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     54d:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)
     553:	c7 85 c0 fe ff ff 0a 	movl   $0xa,-0x140(%ebp)
     55a:	00 00 00 
     55d:	c7 85 c4 fe ff ff 14 	movl   $0x14,-0x13c(%ebp)
     564:	00 00 00 
     567:	83 ec 0c             	sub    $0xc,%esp
     56a:	ff b5 c4 fe ff ff    	pushl  -0x13c(%ebp)
     570:	ff b5 c0 fe ff ff    	pushl  -0x140(%ebp)
     576:	ff b5 bc fe ff ff    	pushl  -0x144(%ebp)
     57c:	ff b5 b8 fe ff ff    	pushl  -0x148(%ebp)
     582:	68 c0 fe 01 00       	push   $0x1fec0
     587:	e8 8e 1e 00 00       	call   241a <api_update>
     58c:	83 c4 20             	add    $0x20,%esp
                             if (pos_x==39*CHARWIDTH)
     58f:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     594:	3d 86 01 00 00       	cmp    $0x186,%eax
     599:	75 17                	jne    5b2 <MsgProc+0x5b2>
                             {
                                 pos_x=0;
     59b:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     5a2:	00 00 00 
                                 pos_y+=CHARHEIGHT;
     5a5:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     5aa:	83 c0 14             	add    $0x14,%eax
     5ad:	a3 c0 f6 01 00       	mov    %eax,0x1f6c0
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
                        api_repaint(&wnd);
                        int i = 0;
                        for (i=0;i<=first;i++)
     5b2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     5b6:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     5bb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
     5be:	0f 8e 37 ff ff ff    	jle    4fb <MsgProc+0x4fb>
                             {
                                 pos_x=0;
                                 pos_y+=CHARHEIGHT;
                             }
                        }
                        pos_x-=CHARWIDTH;
     5c4:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     5c9:	83 e8 0a             	sub    $0xa,%eax
     5cc:	a3 20 fb 01 00       	mov    %eax,0x1fb20
     5d1:	e9 6f 03 00 00       	jmp    945 <MsgProc+0x945>
                    }
                }
                else if (pos_x!=0)
     5d6:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     5db:	85 c0                	test   %eax,%eax
     5dd:	0f 84 62 03 00 00    	je     945 <MsgProc+0x945>
                {
                    pos_x-=CHARWIDTH;
     5e3:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     5e8:	83 e8 0a             	sub    $0xa,%eax
     5eb:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                    if (page==0)
     5f0:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     5f5:	85 c0                	test   %eax,%eax
     5f7:	75 12                	jne    60b <MsgProc+0x60b>
                    {
                        first-=1;
     5f9:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     5fe:	83 e8 01             	sub    $0x1,%eax
     601:	a3 d0 fc 01 00       	mov    %eax,0x1fcd0
     606:	e9 3a 03 00 00       	jmp    945 <MsgProc+0x945>
                    }
                    else
                    {
                        second-=1;    
     60b:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     610:	83 e8 01             	sub    $0x1,%eax
     613:	a3 d4 fc 01 00       	mov    %eax,0x1fcd4
     618:	e9 28 03 00 00       	jmp    945 <MsgProc+0x945>
                    }
                }
            }
            else if (msg->params[0]==229)
     61d:	8b 45 08             	mov    0x8(%ebp),%eax
     620:	8b 40 04             	mov    0x4(%eax),%eax
     623:	3d e5 00 00 00       	cmp    $0xe5,%eax
     628:	75 4a                	jne    674 <MsgProc+0x674>
            {
                if (pos_x!=SCREENWIDTH-CHARWIDTH)
     62a:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     62f:	3d 86 01 00 00       	cmp    $0x186,%eax
     634:	0f 84 0b 03 00 00    	je     945 <MsgProc+0x945>
                {
                    pos_x+=CHARWIDTH;
     63a:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     63f:	83 c0 0a             	add    $0xa,%eax
     642:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                    if (page==0)
     647:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     64c:	85 c0                	test   %eax,%eax
     64e:	75 12                	jne    662 <MsgProc+0x662>
                    {
                        first+=1;
     650:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     655:	83 c0 01             	add    $0x1,%eax
     658:	a3 d0 fc 01 00       	mov    %eax,0x1fcd0
     65d:	e9 e3 02 00 00       	jmp    945 <MsgProc+0x945>
                    }
                    else
                    {
                        second+=1;    
     662:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     667:	83 c0 01             	add    $0x1,%eax
     66a:	a3 d4 fc 01 00       	mov    %eax,0x1fcd4
     66f:	e9 d1 02 00 00       	jmp    945 <MsgProc+0x945>
                    }
                }
            }
            else if(msg->params[1]==1)
     674:	8b 45 08             	mov    0x8(%ebp),%eax
     677:	8b 40 08             	mov    0x8(%eax),%eax
     67a:	83 f8 01             	cmp    $0x1,%eax
     67d:	0f 85 68 01 00 00    	jne    7eb <MsgProc+0x7eb>
            {
                if (msg->params[0]>31)
     683:	8b 45 08             	mov    0x8(%ebp),%eax
     686:	8b 40 04             	mov    0x4(%eax),%eax
     689:	83 f8 1f             	cmp    $0x1f,%eax
     68c:	0f 8e b3 02 00 00    	jle    945 <MsgProc+0x945>
                {
                    api_drawRect(&wnd,(Point){pos_x,pos_y},(Size){SCREENHEIGHT,SCREENWIDTH},white);
     692:	c7 85 c8 fe ff ff 2c 	movl   $0x12c,-0x138(%ebp)
     699:	01 00 00 
     69c:	c7 85 cc fe ff ff 90 	movl   $0x190,-0x134(%ebp)
     6a3:	01 00 00 
     6a6:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     6ab:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
     6b1:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     6b6:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
     6bc:	83 ec 08             	sub    $0x8,%esp
     6bf:	83 ec 04             	sub    $0x4,%esp
     6c2:	89 e0                	mov    %esp,%eax
     6c4:	0f b7 15 c8 f6 01 00 	movzwl 0x1f6c8,%edx
     6cb:	66 89 10             	mov    %dx,(%eax)
     6ce:	0f b6 15 ca f6 01 00 	movzbl 0x1f6ca,%edx
     6d5:	88 50 02             	mov    %dl,0x2(%eax)
     6d8:	ff b5 cc fe ff ff    	pushl  -0x134(%ebp)
     6de:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
     6e4:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
     6ea:	ff b5 d0 fe ff ff    	pushl  -0x130(%ebp)
     6f0:	68 c0 fe 01 00       	push   $0x1fec0
     6f5:	e8 af 1d 00 00       	call   24a9 <api_drawRect>
     6fa:	83 c4 20             	add    $0x20,%esp
                    api_drawCharacter(&wnd,pos_x,pos_y,(char)(msg->params[0]-32),black);
     6fd:	8b 45 08             	mov    0x8(%ebp),%eax
     700:	8b 40 04             	mov    0x4(%eax),%eax
     703:	83 e8 20             	sub    $0x20,%eax
     706:	0f be c8             	movsbl %al,%ecx
     709:	8b 15 c0 f6 01 00    	mov    0x1f6c0,%edx
     70f:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     714:	83 ec 0c             	sub    $0xc,%esp
     717:	ff 35 c4 f6 01 00    	pushl  0x1f6c4
     71d:	51                   	push   %ecx
     71e:	52                   	push   %edx
     71f:	50                   	push   %eax
     720:	68 c0 fe 01 00       	push   $0x1fec0
     725:	e8 c3 1d 00 00       	call   24ed <api_drawCharacter>
     72a:	83 c4 20             	add    $0x20,%esp
                    pos_x+=CHARWIDTH;
     72d:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     732:	83 c0 0a             	add    $0xa,%eax
     735:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                    if (page==0)
     73a:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     73f:	85 c0                	test   %eax,%eax
     741:	75 23                	jne    766 <MsgProc+0x766>
                    {
                        firstPage[first]=(char)(msg->params[0]-32);
     743:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     748:	8b 55 08             	mov    0x8(%ebp),%edx
     74b:	8b 52 04             	mov    0x4(%edx),%edx
     74e:	83 ea 20             	sub    $0x20,%edx
     751:	88 90 40 fb 01 00    	mov    %dl,0x1fb40(%eax)
                        first++;
     757:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     75c:	83 c0 01             	add    $0x1,%eax
     75f:	a3 d0 fc 01 00       	mov    %eax,0x1fcd0
     764:	eb 2b                	jmp    791 <MsgProc+0x791>
                    }
                    else if (page == 1)
     766:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     76b:	83 f8 01             	cmp    $0x1,%eax
     76e:	75 21                	jne    791 <MsgProc+0x791>
                    {
                        secondPage[second]=(char)(msg->params[0]-32);
     770:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     775:	8b 55 08             	mov    0x8(%ebp),%edx
     778:	8b 52 04             	mov    0x4(%edx),%edx
     77b:	83 ea 20             	sub    $0x20,%edx
     77e:	88 90 e0 fc 01 00    	mov    %dl,0x1fce0(%eax)
                        second++;
     784:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     789:	83 c0 01             	add    $0x1,%eax
     78c:	a3 d4 fc 01 00       	mov    %eax,0x1fcd4
                    }
                    api_update(&wnd,(Rect){pos_x-CHARWIDTH,pos_y,CHARWIDTH,CHARHEIGHT});
     791:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     796:	83 e8 0a             	sub    $0xa,%eax
     799:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
     79f:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     7a4:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
     7aa:	c7 85 e0 fe ff ff 0a 	movl   $0xa,-0x120(%ebp)
     7b1:	00 00 00 
     7b4:	c7 85 e4 fe ff ff 14 	movl   $0x14,-0x11c(%ebp)
     7bb:	00 00 00 
     7be:	83 ec 0c             	sub    $0xc,%esp
     7c1:	ff b5 e4 fe ff ff    	pushl  -0x11c(%ebp)
     7c7:	ff b5 e0 fe ff ff    	pushl  -0x120(%ebp)
     7cd:	ff b5 dc fe ff ff    	pushl  -0x124(%ebp)
     7d3:	ff b5 d8 fe ff ff    	pushl  -0x128(%ebp)
     7d9:	68 c0 fe 01 00       	push   $0x1fec0
     7de:	e8 37 1c 00 00       	call   241a <api_update>
     7e3:	83 c4 20             	add    $0x20,%esp
     7e6:	e9 5a 01 00 00       	jmp    945 <MsgProc+0x945>
                }
            }
            else 
            {
                if (msg->params[0]>31)
     7eb:	8b 45 08             	mov    0x8(%ebp),%eax
     7ee:	8b 40 04             	mov    0x4(%eax),%eax
     7f1:	83 f8 1f             	cmp    $0x1f,%eax
     7f4:	0f 8e 4b 01 00 00    	jle    945 <MsgProc+0x945>
                {
                    api_drawRect(&wnd,(Point){pos_x,pos_y},(Size){SCREENHEIGHT,SCREENWIDTH},white);
     7fa:	c7 85 e8 fe ff ff 2c 	movl   $0x12c,-0x118(%ebp)
     801:	01 00 00 
     804:	c7 85 ec fe ff ff 90 	movl   $0x190,-0x114(%ebp)
     80b:	01 00 00 
     80e:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     813:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
     819:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     81e:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
     824:	83 ec 08             	sub    $0x8,%esp
     827:	83 ec 04             	sub    $0x4,%esp
     82a:	89 e0                	mov    %esp,%eax
     82c:	0f b7 15 c8 f6 01 00 	movzwl 0x1f6c8,%edx
     833:	66 89 10             	mov    %dx,(%eax)
     836:	0f b6 15 ca f6 01 00 	movzbl 0x1f6ca,%edx
     83d:	88 50 02             	mov    %dl,0x2(%eax)
     840:	ff b5 ec fe ff ff    	pushl  -0x114(%ebp)
     846:	ff b5 e8 fe ff ff    	pushl  -0x118(%ebp)
     84c:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
     852:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
     858:	68 c0 fe 01 00       	push   $0x1fec0
     85d:	e8 47 1c 00 00       	call   24a9 <api_drawRect>
     862:	83 c4 20             	add    $0x20,%esp
                    api_drawCharacter(&wnd,pos_x,pos_y,(char)msg->params[0],black);
     865:	8b 45 08             	mov    0x8(%ebp),%eax
     868:	8b 40 04             	mov    0x4(%eax),%eax
     86b:	0f be c8             	movsbl %al,%ecx
     86e:	8b 15 c0 f6 01 00    	mov    0x1f6c0,%edx
     874:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     879:	83 ec 0c             	sub    $0xc,%esp
     87c:	ff 35 c4 f6 01 00    	pushl  0x1f6c4
     882:	51                   	push   %ecx
     883:	52                   	push   %edx
     884:	50                   	push   %eax
     885:	68 c0 fe 01 00       	push   $0x1fec0
     88a:	e8 5e 1c 00 00       	call   24ed <api_drawCharacter>
     88f:	83 c4 20             	add    $0x20,%esp
                    pos_x+=CHARWIDTH;
     892:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     897:	83 c0 0a             	add    $0xa,%eax
     89a:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                    if (page==0)
     89f:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     8a4:	85 c0                	test   %eax,%eax
     8a6:	75 20                	jne    8c8 <MsgProc+0x8c8>
                    {
                        firstPage[first]=(char)(msg->params[0]);
     8a8:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     8ad:	8b 55 08             	mov    0x8(%ebp),%edx
     8b0:	8b 52 04             	mov    0x4(%edx),%edx
     8b3:	88 90 40 fb 01 00    	mov    %dl,0x1fb40(%eax)
                        first++;
     8b9:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     8be:	83 c0 01             	add    $0x1,%eax
     8c1:	a3 d0 fc 01 00       	mov    %eax,0x1fcd0
     8c6:	eb 28                	jmp    8f0 <MsgProc+0x8f0>
                    }
                    else if (page == 1)
     8c8:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     8cd:	83 f8 01             	cmp    $0x1,%eax
     8d0:	75 1e                	jne    8f0 <MsgProc+0x8f0>
                    {
                        secondPage[second]=(char)(msg->params[0]);
     8d2:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     8d7:	8b 55 08             	mov    0x8(%ebp),%edx
     8da:	8b 52 04             	mov    0x4(%edx),%edx
     8dd:	88 90 e0 fc 01 00    	mov    %dl,0x1fce0(%eax)
                        second++;
     8e3:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     8e8:	83 c0 01             	add    $0x1,%eax
     8eb:	a3 d4 fc 01 00       	mov    %eax,0x1fcd4
                    }
                    api_update(&wnd,(Rect){pos_x-CHARWIDTH,pos_y,CHARWIDTH,CHARHEIGHT});
     8f0:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     8f5:	83 e8 0a             	sub    $0xa,%eax
     8f8:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
     8fe:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     903:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
     909:	c7 85 00 ff ff ff 0a 	movl   $0xa,-0x100(%ebp)
     910:	00 00 00 
     913:	c7 85 04 ff ff ff 14 	movl   $0x14,-0xfc(%ebp)
     91a:	00 00 00 
     91d:	83 ec 0c             	sub    $0xc,%esp
     920:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
     926:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
     92c:	ff b5 fc fe ff ff    	pushl  -0x104(%ebp)
     932:	ff b5 f8 fe ff ff    	pushl  -0x108(%ebp)
     938:	68 c0 fe 01 00       	push   $0x1fec0
     93d:	e8 d8 1a 00 00       	call   241a <api_update>
     942:	83 c4 20             	add    $0x20,%esp
                }
            }
            if (pos_x>SCREENWIDTH-2*CHARWIDTH)
     945:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     94a:	3d 7c 01 00 00       	cmp    $0x17c,%eax
     94f:	0f 8e 2e 06 00 00    	jle    f83 <MsgProc+0xf83>
            {
                pos_x=0;
     955:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     95c:	00 00 00 
                pos_y+=CHARHEIGHT;
     95f:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     964:	83 c0 14             	add    $0x14,%eax
     967:	a3 c0 f6 01 00       	mov    %eax,0x1f6c0
                if(pos_y == SCREENHEIGHT-CHARHEIGHT)
     96c:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     971:	3d 18 01 00 00       	cmp    $0x118,%eax
     976:	0f 85 07 06 00 00    	jne    f83 <MsgProc+0xf83>
                {
                    page+=1;
     97c:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     981:	83 c0 01             	add    $0x1,%eax
     984:	a3 d8 fc 01 00       	mov    %eax,0x1fcd8
                    pos_x=0;
     989:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     990:	00 00 00 
                    pos_y=40;
     993:	c7 05 c0 f6 01 00 28 	movl   $0x28,0x1f6c0
     99a:	00 00 00 
                    api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
     99d:	c7 85 08 ff ff ff 2c 	movl   $0x12c,-0xf8(%ebp)
     9a4:	01 00 00 
     9a7:	c7 85 0c ff ff ff 90 	movl   $0x190,-0xf4(%ebp)
     9ae:	01 00 00 
     9b1:	c7 85 10 ff ff ff 2c 	movl   $0x12c,-0xf0(%ebp)
     9b8:	01 00 00 
     9bb:	c7 85 14 ff ff ff 90 	movl   $0x190,-0xec(%ebp)
     9c2:	01 00 00 
     9c5:	c7 85 18 ff ff ff 00 	movl   $0x0,-0xe8(%ebp)
     9cc:	00 00 00 
     9cf:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%ebp)
     9d6:	00 00 00 
     9d9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
     9e0:	00 00 00 
     9e3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
     9ea:	00 00 00 
     9ed:	a1 a0 fe 01 00       	mov    0x1fea0,%eax
     9f2:	83 ec 08             	sub    $0x8,%esp
     9f5:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
     9fb:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
     a01:	ff b5 14 ff ff ff    	pushl  -0xec(%ebp)
     a07:	ff b5 10 ff ff ff    	pushl  -0xf0(%ebp)
     a0d:	ff b5 1c ff ff ff    	pushl  -0xe4(%ebp)
     a13:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
     a19:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
     a1f:	ff b5 20 ff ff ff    	pushl  -0xe0(%ebp)
     a25:	50                   	push   %eax
     a26:	68 c0 fe 01 00       	push   $0x1fec0
     a2b:	e8 4c 19 00 00       	call   237c <api_paint24BitmapToContent>
     a30:	83 c4 30             	add    $0x30,%esp
                    api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
     a33:	c7 85 28 ff ff ff 1e 	movl   $0x1e,-0xd8(%ebp)
     a3a:	00 00 00 
     a3d:	c7 85 2c ff ff ff 32 	movl   $0x32,-0xd4(%ebp)
     a44:	00 00 00 
     a47:	c7 85 30 ff ff ff 00 	movl   $0x0,-0xd0(%ebp)
     a4e:	00 00 00 
     a51:	c7 85 34 ff ff ff 00 	movl   $0x0,-0xcc(%ebp)
     a58:	00 00 00 
     a5b:	83 ec 08             	sub    $0x8,%esp
     a5e:	68 d0 f6 01 00       	push   $0x1f6d0
     a63:	ff b5 2c ff ff ff    	pushl  -0xd4(%ebp)
     a69:	ff b5 28 ff ff ff    	pushl  -0xd8(%ebp)
     a6f:	ff b5 34 ff ff ff    	pushl  -0xcc(%ebp)
     a75:	ff b5 30 ff ff ff    	pushl  -0xd0(%ebp)
     a7b:	68 c0 fe 01 00       	push   $0x1fec0
     a80:	e8 f0 1a 00 00       	call   2575 <api_drawButton>
     a85:	83 c4 20             	add    $0x20,%esp
                    api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
     a88:	c7 85 38 ff ff ff 1e 	movl   $0x1e,-0xc8(%ebp)
     a8f:	00 00 00 
     a92:	c7 85 3c ff ff ff 32 	movl   $0x32,-0xc4(%ebp)
     a99:	00 00 00 
     a9c:	c7 85 40 ff ff ff 3c 	movl   $0x3c,-0xc0(%ebp)
     aa3:	00 00 00 
     aa6:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
     aad:	00 00 00 
     ab0:	83 ec 08             	sub    $0x8,%esp
     ab3:	68 d8 f6 01 00       	push   $0x1f6d8
     ab8:	ff b5 3c ff ff ff    	pushl  -0xc4(%ebp)
     abe:	ff b5 38 ff ff ff    	pushl  -0xc8(%ebp)
     ac4:	ff b5 44 ff ff ff    	pushl  -0xbc(%ebp)
     aca:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
     ad0:	68 c0 fe 01 00       	push   $0x1fec0
     ad5:	e8 9b 1a 00 00       	call   2575 <api_drawButton>
     ada:	83 c4 20             	add    $0x20,%esp
                    api_repaint(&wnd);
     add:	83 ec 0c             	sub    $0xc,%esp
     ae0:	68 c0 fe 01 00       	push   $0x1fec0
     ae5:	e8 12 19 00 00       	call   23fc <api_repaint>
     aea:	83 c4 10             	add    $0x10,%esp
                }
            }
            break;
     aed:	e9 91 04 00 00       	jmp    f83 <MsgProc+0xf83>
        case M_KEY_UP:
            break;
        case M_MOUSE_LEFT_CLICK:
            if ((msg->params[0]<5*CHARWIDTH)&&(msg->params[0]>0)&&(msg->params[1]>0)&&(msg->params[1]<20))
     af2:	8b 45 08             	mov    0x8(%ebp),%eax
     af5:	8b 40 04             	mov    0x4(%eax),%eax
     af8:	83 f8 31             	cmp    $0x31,%eax
     afb:	0f 8f 85 04 00 00    	jg     f86 <MsgProc+0xf86>
     b01:	8b 45 08             	mov    0x8(%ebp),%eax
     b04:	8b 40 04             	mov    0x4(%eax),%eax
     b07:	85 c0                	test   %eax,%eax
     b09:	0f 8e 77 04 00 00    	jle    f86 <MsgProc+0xf86>
     b0f:	8b 45 08             	mov    0x8(%ebp),%eax
     b12:	8b 40 08             	mov    0x8(%eax),%eax
     b15:	85 c0                	test   %eax,%eax
     b17:	0f 8e 69 04 00 00    	jle    f86 <MsgProc+0xf86>
     b1d:	8b 45 08             	mov    0x8(%ebp),%eax
     b20:	8b 40 08             	mov    0x8(%eax),%eax
     b23:	83 f8 13             	cmp    $0x13,%eax
     b26:	0f 8f 5a 04 00 00    	jg     f86 <MsgProc+0xf86>
            {
                if (page==0)
     b2c:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     b31:	85 c0                	test   %eax,%eax
     b33:	0f 85 38 02 00 00    	jne    d71 <MsgProc+0xd71>
                    {
                        page = 1;
     b39:	c7 05 d8 fc 01 00 01 	movl   $0x1,0x1fcd8
     b40:	00 00 00 
                        pos_x=0;
     b43:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     b4a:	00 00 00 
                        pos_y=40;
     b4d:	c7 05 c0 f6 01 00 28 	movl   $0x28,0x1f6c0
     b54:	00 00 00 
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
     b57:	c7 85 48 ff ff ff 2c 	movl   $0x12c,-0xb8(%ebp)
     b5e:	01 00 00 
     b61:	c7 85 4c ff ff ff 90 	movl   $0x190,-0xb4(%ebp)
     b68:	01 00 00 
     b6b:	c7 85 50 ff ff ff 2c 	movl   $0x12c,-0xb0(%ebp)
     b72:	01 00 00 
     b75:	c7 85 54 ff ff ff 90 	movl   $0x190,-0xac(%ebp)
     b7c:	01 00 00 
     b7f:	c7 85 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebp)
     b86:	00 00 00 
     b89:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
     b90:	00 00 00 
     b93:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
     b9a:	00 00 00 
     b9d:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
     ba4:	00 00 00 
     ba7:	a1 a0 fe 01 00       	mov    0x1fea0,%eax
     bac:	83 ec 08             	sub    $0x8,%esp
     baf:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
     bb5:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
     bbb:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
     bc1:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
     bc7:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
     bcd:	ff b5 58 ff ff ff    	pushl  -0xa8(%ebp)
     bd3:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
     bd9:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
     bdf:	50                   	push   %eax
     be0:	68 c0 fe 01 00       	push   $0x1fec0
     be5:	e8 92 17 00 00       	call   237c <api_paint24BitmapToContent>
     bea:	83 c4 30             	add    $0x30,%esp
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
     bed:	c7 85 68 ff ff ff 1e 	movl   $0x1e,-0x98(%ebp)
     bf4:	00 00 00 
     bf7:	c7 85 6c ff ff ff 32 	movl   $0x32,-0x94(%ebp)
     bfe:	00 00 00 
     c01:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
     c08:	00 00 00 
     c0b:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
     c12:	00 00 00 
     c15:	83 ec 08             	sub    $0x8,%esp
     c18:	68 d0 f6 01 00       	push   $0x1f6d0
     c1d:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
     c23:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
     c29:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
     c2f:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
     c35:	68 c0 fe 01 00       	push   $0x1fec0
     c3a:	e8 36 19 00 00       	call   2575 <api_drawButton>
     c3f:	83 c4 20             	add    $0x20,%esp
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
     c42:	c7 85 78 ff ff ff 1e 	movl   $0x1e,-0x88(%ebp)
     c49:	00 00 00 
     c4c:	c7 85 7c ff ff ff 32 	movl   $0x32,-0x84(%ebp)
     c53:	00 00 00 
     c56:	c7 45 80 3c 00 00 00 	movl   $0x3c,-0x80(%ebp)
     c5d:	c7 45 84 00 00 00 00 	movl   $0x0,-0x7c(%ebp)
     c64:	83 ec 08             	sub    $0x8,%esp
     c67:	68 d8 f6 01 00       	push   $0x1f6d8
     c6c:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
     c72:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
     c78:	ff 75 84             	pushl  -0x7c(%ebp)
     c7b:	ff 75 80             	pushl  -0x80(%ebp)
     c7e:	68 c0 fe 01 00       	push   $0x1fec0
     c83:	e8 ed 18 00 00       	call   2575 <api_drawButton>
     c88:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
     c8b:	83 ec 0c             	sub    $0xc,%esp
     c8e:	68 c0 fe 01 00       	push   $0x1fec0
     c93:	e8 64 17 00 00       	call   23fc <api_repaint>
     c98:	83 c4 10             	add    $0x10,%esp
                        int i = 0;
     c9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                        for (i=0;i<=second;i++)
     ca2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     ca9:	e9 a3 00 00 00       	jmp    d51 <MsgProc+0xd51>
                        {
                             api_drawCharacter(&wnd,pos_x,pos_y,secondPage[i],black);
     cae:	8b 45 ec             	mov    -0x14(%ebp),%eax
     cb1:	05 e0 fc 01 00       	add    $0x1fce0,%eax
     cb6:	0f b6 00             	movzbl (%eax),%eax
     cb9:	0f be c8             	movsbl %al,%ecx
     cbc:	8b 15 c0 f6 01 00    	mov    0x1f6c0,%edx
     cc2:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     cc7:	83 ec 0c             	sub    $0xc,%esp
     cca:	ff 35 c4 f6 01 00    	pushl  0x1f6c4
     cd0:	51                   	push   %ecx
     cd1:	52                   	push   %edx
     cd2:	50                   	push   %eax
     cd3:	68 c0 fe 01 00       	push   $0x1fec0
     cd8:	e8 10 18 00 00       	call   24ed <api_drawCharacter>
     cdd:	83 c4 20             	add    $0x20,%esp
                             pos_x+=CHARWIDTH;
     ce0:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     ce5:	83 c0 0a             	add    $0xa,%eax
     ce8:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                             api_update(&wnd,(Rect){pos_x-CHARWIDTH,pos_y,CHARWIDTH,CHARHEIGHT});
     ced:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     cf2:	83 e8 0a             	sub    $0xa,%eax
     cf5:	89 45 88             	mov    %eax,-0x78(%ebp)
     cf8:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     cfd:	89 45 8c             	mov    %eax,-0x74(%ebp)
     d00:	c7 45 90 0a 00 00 00 	movl   $0xa,-0x70(%ebp)
     d07:	c7 45 94 14 00 00 00 	movl   $0x14,-0x6c(%ebp)
     d0e:	83 ec 0c             	sub    $0xc,%esp
     d11:	ff 75 94             	pushl  -0x6c(%ebp)
     d14:	ff 75 90             	pushl  -0x70(%ebp)
     d17:	ff 75 8c             	pushl  -0x74(%ebp)
     d1a:	ff 75 88             	pushl  -0x78(%ebp)
     d1d:	68 c0 fe 01 00       	push   $0x1fec0
     d22:	e8 f3 16 00 00       	call   241a <api_update>
     d27:	83 c4 20             	add    $0x20,%esp
                             if (pos_x==39*CHARWIDTH)
     d2a:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     d2f:	3d 86 01 00 00       	cmp    $0x186,%eax
     d34:	75 17                	jne    d4d <MsgProc+0xd4d>
                             {
                                 pos_x=0;
     d36:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     d3d:	00 00 00 
                                 pos_y+=CHARHEIGHT;
     d40:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     d45:	83 c0 14             	add    $0x14,%eax
     d48:	a3 c0 f6 01 00       	mov    %eax,0x1f6c0
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
                        api_repaint(&wnd);
                        int i = 0;
                        for (i=0;i<=second;i++)
     d4d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
     d51:	a1 d4 fc 01 00       	mov    0x1fcd4,%eax
     d56:	39 45 ec             	cmp    %eax,-0x14(%ebp)
     d59:	0f 8e 4f ff ff ff    	jle    cae <MsgProc+0xcae>
                             {
                                 pos_x=0;
                                 pos_y+=CHARHEIGHT;
                             }
                        }
                        pos_x-=CHARWIDTH;
     d5f:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     d64:	83 e8 0a             	sub    $0xa,%eax
     d67:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                             }
                        }
                        pos_x-=CHARWIDTH;
                    }
            }
            break;
     d6c:	e9 15 02 00 00       	jmp    f86 <MsgProc+0xf86>
                                 pos_y+=CHARHEIGHT;
                             }
                        }
                        pos_x-=CHARWIDTH;
                    }
                    else if (page==1)
     d71:	a1 d8 fc 01 00       	mov    0x1fcd8,%eax
     d76:	83 f8 01             	cmp    $0x1,%eax
     d79:	0f 85 07 02 00 00    	jne    f86 <MsgProc+0xf86>
                    {
                        page = 0;
     d7f:	c7 05 d8 fc 01 00 00 	movl   $0x0,0x1fcd8
     d86:	00 00 00 
                        pos_x=0;
     d89:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     d90:	00 00 00 
                        pos_y=40;
     d93:	c7 05 c0 f6 01 00 28 	movl   $0x28,0x1f6c0
     d9a:	00 00 00 
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
     d9d:	c7 45 98 2c 01 00 00 	movl   $0x12c,-0x68(%ebp)
     da4:	c7 45 9c 90 01 00 00 	movl   $0x190,-0x64(%ebp)
     dab:	c7 45 a0 2c 01 00 00 	movl   $0x12c,-0x60(%ebp)
     db2:	c7 45 a4 90 01 00 00 	movl   $0x190,-0x5c(%ebp)
     db9:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
     dc0:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
     dc7:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
     dce:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
     dd5:	a1 a0 fe 01 00       	mov    0x1fea0,%eax
     dda:	83 ec 08             	sub    $0x8,%esp
     ddd:	ff 75 9c             	pushl  -0x64(%ebp)
     de0:	ff 75 98             	pushl  -0x68(%ebp)
     de3:	ff 75 a4             	pushl  -0x5c(%ebp)
     de6:	ff 75 a0             	pushl  -0x60(%ebp)
     de9:	ff 75 ac             	pushl  -0x54(%ebp)
     dec:	ff 75 a8             	pushl  -0x58(%ebp)
     def:	ff 75 b4             	pushl  -0x4c(%ebp)
     df2:	ff 75 b0             	pushl  -0x50(%ebp)
     df5:	50                   	push   %eax
     df6:	68 c0 fe 01 00       	push   $0x1fec0
     dfb:	e8 7c 15 00 00       	call   237c <api_paint24BitmapToContent>
     e00:	83 c4 30             	add    $0x30,%esp
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
     e03:	c7 45 b8 1e 00 00 00 	movl   $0x1e,-0x48(%ebp)
     e0a:	c7 45 bc 32 00 00 00 	movl   $0x32,-0x44(%ebp)
     e11:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
     e18:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
     e1f:	83 ec 08             	sub    $0x8,%esp
     e22:	68 d0 f6 01 00       	push   $0x1f6d0
     e27:	ff 75 bc             	pushl  -0x44(%ebp)
     e2a:	ff 75 b8             	pushl  -0x48(%ebp)
     e2d:	ff 75 c4             	pushl  -0x3c(%ebp)
     e30:	ff 75 c0             	pushl  -0x40(%ebp)
     e33:	68 c0 fe 01 00       	push   $0x1fec0
     e38:	e8 38 17 00 00       	call   2575 <api_drawButton>
     e3d:	83 c4 20             	add    $0x20,%esp
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
     e40:	c7 45 c8 1e 00 00 00 	movl   $0x1e,-0x38(%ebp)
     e47:	c7 45 cc 32 00 00 00 	movl   $0x32,-0x34(%ebp)
     e4e:	c7 45 d0 3c 00 00 00 	movl   $0x3c,-0x30(%ebp)
     e55:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
     e5c:	83 ec 08             	sub    $0x8,%esp
     e5f:	68 d8 f6 01 00       	push   $0x1f6d8
     e64:	ff 75 cc             	pushl  -0x34(%ebp)
     e67:	ff 75 c8             	pushl  -0x38(%ebp)
     e6a:	ff 75 d4             	pushl  -0x2c(%ebp)
     e6d:	ff 75 d0             	pushl  -0x30(%ebp)
     e70:	68 c0 fe 01 00       	push   $0x1fec0
     e75:	e8 fb 16 00 00       	call   2575 <api_drawButton>
     e7a:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
     e7d:	83 ec 0c             	sub    $0xc,%esp
     e80:	68 c0 fe 01 00       	push   $0x1fec0
     e85:	e8 72 15 00 00       	call   23fc <api_repaint>
     e8a:	83 c4 10             	add    $0x10,%esp
                        int i = 0;
     e8d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
                        for (i=0;i<=first;i++)
     e94:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
     e9b:	e9 a3 00 00 00       	jmp    f43 <MsgProc+0xf43>
                        {
                             api_drawCharacter(&wnd,pos_x,pos_y,firstPage[i],black);
     ea0:	8b 45 e8             	mov    -0x18(%ebp),%eax
     ea3:	05 40 fb 01 00       	add    $0x1fb40,%eax
     ea8:	0f b6 00             	movzbl (%eax),%eax
     eab:	0f be c8             	movsbl %al,%ecx
     eae:	8b 15 c0 f6 01 00    	mov    0x1f6c0,%edx
     eb4:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     eb9:	83 ec 0c             	sub    $0xc,%esp
     ebc:	ff 35 c4 f6 01 00    	pushl  0x1f6c4
     ec2:	51                   	push   %ecx
     ec3:	52                   	push   %edx
     ec4:	50                   	push   %eax
     ec5:	68 c0 fe 01 00       	push   $0x1fec0
     eca:	e8 1e 16 00 00       	call   24ed <api_drawCharacter>
     ecf:	83 c4 20             	add    $0x20,%esp
                             pos_x+=CHARWIDTH;
     ed2:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     ed7:	83 c0 0a             	add    $0xa,%eax
     eda:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                             api_update(&wnd,(Rect){pos_x-CHARWIDTH,pos_y,CHARWIDTH,CHARHEIGHT});
     edf:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     ee4:	83 e8 0a             	sub    $0xa,%eax
     ee7:	89 45 d8             	mov    %eax,-0x28(%ebp)
     eea:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     eef:	89 45 dc             	mov    %eax,-0x24(%ebp)
     ef2:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
     ef9:	c7 45 e4 14 00 00 00 	movl   $0x14,-0x1c(%ebp)
     f00:	83 ec 0c             	sub    $0xc,%esp
     f03:	ff 75 e4             	pushl  -0x1c(%ebp)
     f06:	ff 75 e0             	pushl  -0x20(%ebp)
     f09:	ff 75 dc             	pushl  -0x24(%ebp)
     f0c:	ff 75 d8             	pushl  -0x28(%ebp)
     f0f:	68 c0 fe 01 00       	push   $0x1fec0
     f14:	e8 01 15 00 00       	call   241a <api_update>
     f19:	83 c4 20             	add    $0x20,%esp
                             if (pos_x==39*CHARWIDTH)
     f1c:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     f21:	3d 86 01 00 00       	cmp    $0x186,%eax
     f26:	75 17                	jne    f3f <MsgProc+0xf3f>
                             {
                                 pos_x=0;
     f28:	c7 05 20 fb 01 00 00 	movl   $0x0,0x1fb20
     f2f:	00 00 00 
                                 pos_y+=CHARHEIGHT;
     f32:	a1 c0 f6 01 00       	mov    0x1f6c0,%eax
     f37:	83 c0 14             	add    $0x14,%eax
     f3a:	a3 c0 f6 01 00       	mov    %eax,0x1f6c0
                        api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
                        api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
                        api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
                        api_repaint(&wnd);
                        int i = 0;
                        for (i=0;i<=first;i++)
     f3f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
     f43:	a1 d0 fc 01 00       	mov    0x1fcd0,%eax
     f48:	39 45 e8             	cmp    %eax,-0x18(%ebp)
     f4b:	0f 8e 4f ff ff ff    	jle    ea0 <MsgProc+0xea0>
                             {
                                 pos_x=0;
                                 pos_y+=CHARHEIGHT;
                             }
                        }
                        pos_x-=CHARWIDTH;
     f51:	a1 20 fb 01 00       	mov    0x1fb20,%eax
     f56:	83 e8 0a             	sub    $0xa,%eax
     f59:	a3 20 fb 01 00       	mov    %eax,0x1fb20
                    }
            }
            break;
     f5e:	eb 26                	jmp    f86 <MsgProc+0xf86>
        case M_CLOSE_WINDOW:
            free(background);
     f60:	a1 a0 fe 01 00       	mov    0x1fea0,%eax
     f65:	83 ec 0c             	sub    $0xc,%esp
     f68:	50                   	push   %eax
     f69:	e8 80 07 00 00       	call   16ee <free>
     f6e:	83 c4 10             	add    $0x10,%esp
            api_destroywindow(&wnd);
     f71:	83 ec 0c             	sub    $0xc,%esp
     f74:	68 c0 fe 01 00       	push   $0x1fec0
     f79:	e8 21 17 00 00       	call   269f <api_destroywindow>
     f7e:	83 c4 10             	add    $0x10,%esp
            break;
     f81:	eb 04                	jmp    f87 <MsgProc+0xf87>
                    api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
                    api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
                    api_repaint(&wnd);
                }
            }
            break;
     f83:	90                   	nop
     f84:	eb 01                	jmp    f87 <MsgProc+0xf87>
                             }
                        }
                        pos_x-=CHARWIDTH;
                    }
            }
            break;
     f86:	90                   	nop
        case M_CLOSE_WINDOW:
            free(background);
            api_destroywindow(&wnd);
            break;
    }
}
     f87:	90                   	nop
     f88:	c9                   	leave  
     f89:	c3                   	ret    

00000f8a <main>:
int 
main(void)
{
     f8a:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     f8e:	83 e4 f0             	and    $0xfffffff0,%esp
     f91:	ff 71 fc             	pushl  -0x4(%ecx)
     f94:	55                   	push   %ebp
     f95:	89 e5                	mov    %esp,%ebp
     f97:	51                   	push   %ecx
     f98:	83 ec 54             	sub    $0x54,%esp
    wnd.pos.x = 200;
     f9b:	c7 05 c4 fe 01 00 c8 	movl   $0xc8,0x1fec4
     fa2:	00 00 00 
    wnd.pos.y = 150;
     fa5:	c7 05 c8 fe 01 00 96 	movl   $0x96,0x1fec8
     fac:	00 00 00 
    wnd.size.w = 400;
     faf:	c7 05 d0 fe 01 00 90 	movl   $0x190,0x1fed0
     fb6:	01 00 00 
    wnd.size.h = 300;
     fb9:	c7 05 cc fe 01 00 2c 	movl   $0x12c,0x1fecc
     fc0:	01 00 00 
    wnd.title = "Editor";
     fc3:	c7 05 d4 fe 01 00 a0 	movl   $0x16ea0,0x1fed4
     fca:	6e 01 00 
    api_createwindow(&wnd);
     fcd:	83 ec 0c             	sub    $0xc,%esp
     fd0:	68 c0 fe 01 00       	push   $0x1fec0
     fd5:	e8 90 12 00 00       	call   226a <api_createwindow>
     fda:	83 c4 10             	add    $0x10,%esp
    background = malloc(400*300*3);
     fdd:	83 ec 0c             	sub    $0xc,%esp
     fe0:	68 40 7e 05 00       	push   $0x57e40
     fe5:	e8 46 08 00 00       	call   1830 <malloc>
     fea:	83 c4 10             	add    $0x10,%esp
     fed:	a3 a0 fe 01 00       	mov    %eax,0x1fea0
    int i = 0;
     ff2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (i = 0; i < 400*300;i++)
     ff9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1000:	eb 42                	jmp    1044 <main+0xba>
    {
        background[i].R = 255;
    1002:	8b 0d a0 fe 01 00    	mov    0x1fea0,%ecx
    1008:	8b 55 f4             	mov    -0xc(%ebp),%edx
    100b:	89 d0                	mov    %edx,%eax
    100d:	01 c0                	add    %eax,%eax
    100f:	01 d0                	add    %edx,%eax
    1011:	01 c8                	add    %ecx,%eax
    1013:	c6 40 02 ff          	movb   $0xff,0x2(%eax)
        background[i].G = 255;
    1017:	8b 0d a0 fe 01 00    	mov    0x1fea0,%ecx
    101d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    1020:	89 d0                	mov    %edx,%eax
    1022:	01 c0                	add    %eax,%eax
    1024:	01 d0                	add    %edx,%eax
    1026:	01 c8                	add    %ecx,%eax
    1028:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
        background[i].B = 255;
    102c:	8b 0d a0 fe 01 00    	mov    0x1fea0,%ecx
    1032:	8b 55 f4             	mov    -0xc(%ebp),%edx
    1035:	89 d0                	mov    %edx,%eax
    1037:	01 c0                	add    %eax,%eax
    1039:	01 d0                	add    %edx,%eax
    103b:	01 c8                	add    %ecx,%eax
    103d:	c6 00 ff             	movb   $0xff,(%eax)
    wnd.size.h = 300;
    wnd.title = "Editor";
    api_createwindow(&wnd);
    background = malloc(400*300*3);
    int i = 0;
    for (i = 0; i < 400*300;i++)
    1040:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1044:	81 7d f4 bf d4 01 00 	cmpl   $0x1d4bf,-0xc(%ebp)
    104b:	7e b5                	jle    1002 <main+0x78>
    {
        background[i].R = 255;
        background[i].G = 255;
        background[i].B = 255;
    }
    api_paint24BitmapToContent(&wnd, background, (Point){0,0}, (Point){0,0},(Size){300,400},(Size){300,400});
    104d:	c7 45 b4 2c 01 00 00 	movl   $0x12c,-0x4c(%ebp)
    1054:	c7 45 b8 90 01 00 00 	movl   $0x190,-0x48(%ebp)
    105b:	c7 45 bc 2c 01 00 00 	movl   $0x12c,-0x44(%ebp)
    1062:	c7 45 c0 90 01 00 00 	movl   $0x190,-0x40(%ebp)
    1069:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    1070:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    1077:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    107e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    1085:	a1 a0 fe 01 00       	mov    0x1fea0,%eax
    108a:	83 ec 08             	sub    $0x8,%esp
    108d:	ff 75 b8             	pushl  -0x48(%ebp)
    1090:	ff 75 b4             	pushl  -0x4c(%ebp)
    1093:	ff 75 c0             	pushl  -0x40(%ebp)
    1096:	ff 75 bc             	pushl  -0x44(%ebp)
    1099:	ff 75 c8             	pushl  -0x38(%ebp)
    109c:	ff 75 c4             	pushl  -0x3c(%ebp)
    109f:	ff 75 d0             	pushl  -0x30(%ebp)
    10a2:	ff 75 cc             	pushl  -0x34(%ebp)
    10a5:	50                   	push   %eax
    10a6:	68 c0 fe 01 00       	push   $0x1fec0
    10ab:	e8 cc 12 00 00       	call   237c <api_paint24BitmapToContent>
    10b0:	83 c4 30             	add    $0x30,%esp
    //api_drawButton(&wnd,(Point){0,0},(Size){20,SCREENWIDTH},null);
    api_drawButton(&wnd,(Point){0,0},(Size){30,5*CHARWIDTH},pgdn);
    10b3:	c7 45 d4 1e 00 00 00 	movl   $0x1e,-0x2c(%ebp)
    10ba:	c7 45 d8 32 00 00 00 	movl   $0x32,-0x28(%ebp)
    10c1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    10c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    10cf:	83 ec 08             	sub    $0x8,%esp
    10d2:	68 d0 f6 01 00       	push   $0x1f6d0
    10d7:	ff 75 d8             	pushl  -0x28(%ebp)
    10da:	ff 75 d4             	pushl  -0x2c(%ebp)
    10dd:	ff 75 e0             	pushl  -0x20(%ebp)
    10e0:	ff 75 dc             	pushl  -0x24(%ebp)
    10e3:	68 c0 fe 01 00       	push   $0x1fec0
    10e8:	e8 88 14 00 00       	call   2575 <api_drawButton>
    10ed:	83 c4 20             	add    $0x20,%esp
    api_drawButton(&wnd,(Point){6*CHARWIDTH,0},(Size){30,5*CHARWIDTH},save);
    10f0:	c7 45 e4 1e 00 00 00 	movl   $0x1e,-0x1c(%ebp)
    10f7:	c7 45 e8 32 00 00 00 	movl   $0x32,-0x18(%ebp)
    10fe:	c7 45 ec 3c 00 00 00 	movl   $0x3c,-0x14(%ebp)
    1105:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    110c:	83 ec 08             	sub    $0x8,%esp
    110f:	68 d8 f6 01 00       	push   $0x1f6d8
    1114:	ff 75 e8             	pushl  -0x18(%ebp)
    1117:	ff 75 e4             	pushl  -0x1c(%ebp)
    111a:	ff 75 f0             	pushl  -0x10(%ebp)
    111d:	ff 75 ec             	pushl  -0x14(%ebp)
    1120:	68 c0 fe 01 00       	push   $0x1fec0
    1125:	e8 4b 14 00 00       	call   2575 <api_drawButton>
    112a:	83 c4 20             	add    $0x20,%esp
    api_repaint(&wnd);
    112d:	83 ec 0c             	sub    $0xc,%esp
    1130:	68 c0 fe 01 00       	push   $0x1fec0
    1135:	e8 c2 12 00 00       	call   23fc <api_repaint>
    113a:	83 c4 10             	add    $0x10,%esp
    api_exec(&wnd,&MsgProc);
    113d:	83 ec 08             	sub    $0x8,%esp
    1140:	68 00 00 00 00       	push   $0x0
    1145:	68 c0 fe 01 00       	push   $0x1fec0
    114a:	e8 fd 12 00 00       	call   244c <api_exec>
    114f:	83 c4 10             	add    $0x10,%esp
    return 0;
    1152:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1157:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    115a:	c9                   	leave  
    115b:	8d 61 fc             	lea    -0x4(%ecx),%esp
    115e:	c3                   	ret    

0000115f <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
    115f:	55                   	push   %ebp
    1160:	89 e5                	mov    %esp,%ebp
    1162:	57                   	push   %edi
    1163:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
    1164:	8b 4d 08             	mov    0x8(%ebp),%ecx
    1167:	8b 55 10             	mov    0x10(%ebp),%edx
    116a:	8b 45 0c             	mov    0xc(%ebp),%eax
    116d:	89 cb                	mov    %ecx,%ebx
    116f:	89 df                	mov    %ebx,%edi
    1171:	89 d1                	mov    %edx,%ecx
    1173:	fc                   	cld    
    1174:	f3 aa                	rep stos %al,%es:(%edi)
    1176:	89 ca                	mov    %ecx,%edx
    1178:	89 fb                	mov    %edi,%ebx
    117a:	89 5d 08             	mov    %ebx,0x8(%ebp)
    117d:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
    1180:	90                   	nop
    1181:	5b                   	pop    %ebx
    1182:	5f                   	pop    %edi
    1183:	5d                   	pop    %ebp
    1184:	c3                   	ret    

00001185 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
    1185:	55                   	push   %ebp
    1186:	89 e5                	mov    %esp,%ebp
    1188:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
    118b:	8b 45 08             	mov    0x8(%ebp),%eax
    118e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
    1191:	90                   	nop
    1192:	8b 45 08             	mov    0x8(%ebp),%eax
    1195:	8d 50 01             	lea    0x1(%eax),%edx
    1198:	89 55 08             	mov    %edx,0x8(%ebp)
    119b:	8b 55 0c             	mov    0xc(%ebp),%edx
    119e:	8d 4a 01             	lea    0x1(%edx),%ecx
    11a1:	89 4d 0c             	mov    %ecx,0xc(%ebp)
    11a4:	0f b6 12             	movzbl (%edx),%edx
    11a7:	88 10                	mov    %dl,(%eax)
    11a9:	0f b6 00             	movzbl (%eax),%eax
    11ac:	84 c0                	test   %al,%al
    11ae:	75 e2                	jne    1192 <strcpy+0xd>
    ;
  return os;
    11b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    11b3:	c9                   	leave  
    11b4:	c3                   	ret    

000011b5 <strcmp>:

int
strcmp(const char *p, const char *q)
{
    11b5:	55                   	push   %ebp
    11b6:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
    11b8:	eb 08                	jmp    11c2 <strcmp+0xd>
    p++, q++;
    11ba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    11be:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
    11c2:	8b 45 08             	mov    0x8(%ebp),%eax
    11c5:	0f b6 00             	movzbl (%eax),%eax
    11c8:	84 c0                	test   %al,%al
    11ca:	74 10                	je     11dc <strcmp+0x27>
    11cc:	8b 45 08             	mov    0x8(%ebp),%eax
    11cf:	0f b6 10             	movzbl (%eax),%edx
    11d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    11d5:	0f b6 00             	movzbl (%eax),%eax
    11d8:	38 c2                	cmp    %al,%dl
    11da:	74 de                	je     11ba <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
    11dc:	8b 45 08             	mov    0x8(%ebp),%eax
    11df:	0f b6 00             	movzbl (%eax),%eax
    11e2:	0f b6 d0             	movzbl %al,%edx
    11e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    11e8:	0f b6 00             	movzbl (%eax),%eax
    11eb:	0f b6 c0             	movzbl %al,%eax
    11ee:	29 c2                	sub    %eax,%edx
    11f0:	89 d0                	mov    %edx,%eax
}
    11f2:	5d                   	pop    %ebp
    11f3:	c3                   	ret    

000011f4 <strlen>:

uint
strlen(char *s)
{
    11f4:	55                   	push   %ebp
    11f5:	89 e5                	mov    %esp,%ebp
    11f7:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
    11fa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1201:	eb 04                	jmp    1207 <strlen+0x13>
    1203:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1207:	8b 55 fc             	mov    -0x4(%ebp),%edx
    120a:	8b 45 08             	mov    0x8(%ebp),%eax
    120d:	01 d0                	add    %edx,%eax
    120f:	0f b6 00             	movzbl (%eax),%eax
    1212:	84 c0                	test   %al,%al
    1214:	75 ed                	jne    1203 <strlen+0xf>
    ;
  return n;
    1216:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    1219:	c9                   	leave  
    121a:	c3                   	ret    

0000121b <memset>:

void*
memset(void *dst, int c, uint n)
{
    121b:	55                   	push   %ebp
    121c:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
    121e:	8b 45 10             	mov    0x10(%ebp),%eax
    1221:	50                   	push   %eax
    1222:	ff 75 0c             	pushl  0xc(%ebp)
    1225:	ff 75 08             	pushl  0x8(%ebp)
    1228:	e8 32 ff ff ff       	call   115f <stosb>
    122d:	83 c4 0c             	add    $0xc,%esp
  return dst;
    1230:	8b 45 08             	mov    0x8(%ebp),%eax
}
    1233:	c9                   	leave  
    1234:	c3                   	ret    

00001235 <strchr>:

char*
strchr(const char *s, char c)
{
    1235:	55                   	push   %ebp
    1236:	89 e5                	mov    %esp,%ebp
    1238:	83 ec 04             	sub    $0x4,%esp
    123b:	8b 45 0c             	mov    0xc(%ebp),%eax
    123e:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
    1241:	eb 14                	jmp    1257 <strchr+0x22>
    if(*s == c)
    1243:	8b 45 08             	mov    0x8(%ebp),%eax
    1246:	0f b6 00             	movzbl (%eax),%eax
    1249:	3a 45 fc             	cmp    -0x4(%ebp),%al
    124c:	75 05                	jne    1253 <strchr+0x1e>
      return (char*)s;
    124e:	8b 45 08             	mov    0x8(%ebp),%eax
    1251:	eb 13                	jmp    1266 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
    1253:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    1257:	8b 45 08             	mov    0x8(%ebp),%eax
    125a:	0f b6 00             	movzbl (%eax),%eax
    125d:	84 c0                	test   %al,%al
    125f:	75 e2                	jne    1243 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
    1261:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1266:	c9                   	leave  
    1267:	c3                   	ret    

00001268 <gets>:

char*
gets(char *buf, int max)
{
    1268:	55                   	push   %ebp
    1269:	89 e5                	mov    %esp,%ebp
    126b:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    126e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1275:	eb 42                	jmp    12b9 <gets+0x51>
    cc = read(0, &c, 1);
    1277:	83 ec 04             	sub    $0x4,%esp
    127a:	6a 01                	push   $0x1
    127c:	8d 45 ef             	lea    -0x11(%ebp),%eax
    127f:	50                   	push   %eax
    1280:	6a 00                	push   $0x0
    1282:	e8 47 01 00 00       	call   13ce <read>
    1287:	83 c4 10             	add    $0x10,%esp
    128a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
    128d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    1291:	7e 33                	jle    12c6 <gets+0x5e>
      break;
    buf[i++] = c;
    1293:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1296:	8d 50 01             	lea    0x1(%eax),%edx
    1299:	89 55 f4             	mov    %edx,-0xc(%ebp)
    129c:	89 c2                	mov    %eax,%edx
    129e:	8b 45 08             	mov    0x8(%ebp),%eax
    12a1:	01 c2                	add    %eax,%edx
    12a3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    12a7:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
    12a9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    12ad:	3c 0a                	cmp    $0xa,%al
    12af:	74 16                	je     12c7 <gets+0x5f>
    12b1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    12b5:	3c 0d                	cmp    $0xd,%al
    12b7:	74 0e                	je     12c7 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    12b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    12bc:	83 c0 01             	add    $0x1,%eax
    12bf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    12c2:	7c b3                	jl     1277 <gets+0xf>
    12c4:	eb 01                	jmp    12c7 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
    12c6:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
    12c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    12ca:	8b 45 08             	mov    0x8(%ebp),%eax
    12cd:	01 d0                	add    %edx,%eax
    12cf:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
    12d2:	8b 45 08             	mov    0x8(%ebp),%eax
}
    12d5:	c9                   	leave  
    12d6:	c3                   	ret    

000012d7 <stat>:

int
stat(char *n, struct stat *st)
{
    12d7:	55                   	push   %ebp
    12d8:	89 e5                	mov    %esp,%ebp
    12da:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
    12dd:	83 ec 08             	sub    $0x8,%esp
    12e0:	6a 00                	push   $0x0
    12e2:	ff 75 08             	pushl  0x8(%ebp)
    12e5:	e8 0c 01 00 00       	call   13f6 <open>
    12ea:	83 c4 10             	add    $0x10,%esp
    12ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
    12f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    12f4:	79 07                	jns    12fd <stat+0x26>
    return -1;
    12f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    12fb:	eb 25                	jmp    1322 <stat+0x4b>
  r = fstat(fd, st);
    12fd:	83 ec 08             	sub    $0x8,%esp
    1300:	ff 75 0c             	pushl  0xc(%ebp)
    1303:	ff 75 f4             	pushl  -0xc(%ebp)
    1306:	e8 03 01 00 00       	call   140e <fstat>
    130b:	83 c4 10             	add    $0x10,%esp
    130e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
    1311:	83 ec 0c             	sub    $0xc,%esp
    1314:	ff 75 f4             	pushl  -0xc(%ebp)
    1317:	e8 c2 00 00 00       	call   13de <close>
    131c:	83 c4 10             	add    $0x10,%esp
  return r;
    131f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    1322:	c9                   	leave  
    1323:	c3                   	ret    

00001324 <atoi>:

int
atoi(const char *s)
{
    1324:	55                   	push   %ebp
    1325:	89 e5                	mov    %esp,%ebp
    1327:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
    132a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
    1331:	eb 25                	jmp    1358 <atoi+0x34>
    n = n*10 + *s++ - '0';
    1333:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1336:	89 d0                	mov    %edx,%eax
    1338:	c1 e0 02             	shl    $0x2,%eax
    133b:	01 d0                	add    %edx,%eax
    133d:	01 c0                	add    %eax,%eax
    133f:	89 c1                	mov    %eax,%ecx
    1341:	8b 45 08             	mov    0x8(%ebp),%eax
    1344:	8d 50 01             	lea    0x1(%eax),%edx
    1347:	89 55 08             	mov    %edx,0x8(%ebp)
    134a:	0f b6 00             	movzbl (%eax),%eax
    134d:	0f be c0             	movsbl %al,%eax
    1350:	01 c8                	add    %ecx,%eax
    1352:	83 e8 30             	sub    $0x30,%eax
    1355:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
    1358:	8b 45 08             	mov    0x8(%ebp),%eax
    135b:	0f b6 00             	movzbl (%eax),%eax
    135e:	3c 2f                	cmp    $0x2f,%al
    1360:	7e 0a                	jle    136c <atoi+0x48>
    1362:	8b 45 08             	mov    0x8(%ebp),%eax
    1365:	0f b6 00             	movzbl (%eax),%eax
    1368:	3c 39                	cmp    $0x39,%al
    136a:	7e c7                	jle    1333 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
    136c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    136f:	c9                   	leave  
    1370:	c3                   	ret    

00001371 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
    1371:	55                   	push   %ebp
    1372:	89 e5                	mov    %esp,%ebp
    1374:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
    1377:	8b 45 08             	mov    0x8(%ebp),%eax
    137a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
    137d:	8b 45 0c             	mov    0xc(%ebp),%eax
    1380:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
    1383:	eb 17                	jmp    139c <memmove+0x2b>
    *dst++ = *src++;
    1385:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1388:	8d 50 01             	lea    0x1(%eax),%edx
    138b:	89 55 fc             	mov    %edx,-0x4(%ebp)
    138e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    1391:	8d 4a 01             	lea    0x1(%edx),%ecx
    1394:	89 4d f8             	mov    %ecx,-0x8(%ebp)
    1397:	0f b6 12             	movzbl (%edx),%edx
    139a:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
    139c:	8b 45 10             	mov    0x10(%ebp),%eax
    139f:	8d 50 ff             	lea    -0x1(%eax),%edx
    13a2:	89 55 10             	mov    %edx,0x10(%ebp)
    13a5:	85 c0                	test   %eax,%eax
    13a7:	7f dc                	jg     1385 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
    13a9:	8b 45 08             	mov    0x8(%ebp),%eax
}
    13ac:	c9                   	leave  
    13ad:	c3                   	ret    

000013ae <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
    13ae:	b8 01 00 00 00       	mov    $0x1,%eax
    13b3:	cd 40                	int    $0x40
    13b5:	c3                   	ret    

000013b6 <exit>:
SYSCALL(exit)
    13b6:	b8 02 00 00 00       	mov    $0x2,%eax
    13bb:	cd 40                	int    $0x40
    13bd:	c3                   	ret    

000013be <wait>:
SYSCALL(wait)
    13be:	b8 03 00 00 00       	mov    $0x3,%eax
    13c3:	cd 40                	int    $0x40
    13c5:	c3                   	ret    

000013c6 <pipe>:
SYSCALL(pipe)
    13c6:	b8 04 00 00 00       	mov    $0x4,%eax
    13cb:	cd 40                	int    $0x40
    13cd:	c3                   	ret    

000013ce <read>:
SYSCALL(read)
    13ce:	b8 05 00 00 00       	mov    $0x5,%eax
    13d3:	cd 40                	int    $0x40
    13d5:	c3                   	ret    

000013d6 <write>:
SYSCALL(write)
    13d6:	b8 10 00 00 00       	mov    $0x10,%eax
    13db:	cd 40                	int    $0x40
    13dd:	c3                   	ret    

000013de <close>:
SYSCALL(close)
    13de:	b8 15 00 00 00       	mov    $0x15,%eax
    13e3:	cd 40                	int    $0x40
    13e5:	c3                   	ret    

000013e6 <kill>:
SYSCALL(kill)
    13e6:	b8 06 00 00 00       	mov    $0x6,%eax
    13eb:	cd 40                	int    $0x40
    13ed:	c3                   	ret    

000013ee <exec>:
SYSCALL(exec)
    13ee:	b8 07 00 00 00       	mov    $0x7,%eax
    13f3:	cd 40                	int    $0x40
    13f5:	c3                   	ret    

000013f6 <open>:
SYSCALL(open)
    13f6:	b8 0f 00 00 00       	mov    $0xf,%eax
    13fb:	cd 40                	int    $0x40
    13fd:	c3                   	ret    

000013fe <mknod>:
SYSCALL(mknod)
    13fe:	b8 11 00 00 00       	mov    $0x11,%eax
    1403:	cd 40                	int    $0x40
    1405:	c3                   	ret    

00001406 <unlink>:
SYSCALL(unlink)
    1406:	b8 12 00 00 00       	mov    $0x12,%eax
    140b:	cd 40                	int    $0x40
    140d:	c3                   	ret    

0000140e <fstat>:
SYSCALL(fstat)
    140e:	b8 08 00 00 00       	mov    $0x8,%eax
    1413:	cd 40                	int    $0x40
    1415:	c3                   	ret    

00001416 <link>:
SYSCALL(link)
    1416:	b8 13 00 00 00       	mov    $0x13,%eax
    141b:	cd 40                	int    $0x40
    141d:	c3                   	ret    

0000141e <mkdir>:
SYSCALL(mkdir)
    141e:	b8 14 00 00 00       	mov    $0x14,%eax
    1423:	cd 40                	int    $0x40
    1425:	c3                   	ret    

00001426 <chdir>:
SYSCALL(chdir)
    1426:	b8 09 00 00 00       	mov    $0x9,%eax
    142b:	cd 40                	int    $0x40
    142d:	c3                   	ret    

0000142e <dup>:
SYSCALL(dup)
    142e:	b8 0a 00 00 00       	mov    $0xa,%eax
    1433:	cd 40                	int    $0x40
    1435:	c3                   	ret    

00001436 <getpid>:
SYSCALL(getpid)
    1436:	b8 0b 00 00 00       	mov    $0xb,%eax
    143b:	cd 40                	int    $0x40
    143d:	c3                   	ret    

0000143e <sbrk>:
SYSCALL(sbrk)
    143e:	b8 0c 00 00 00       	mov    $0xc,%eax
    1443:	cd 40                	int    $0x40
    1445:	c3                   	ret    

00001446 <sleep>:
SYSCALL(sleep)
    1446:	b8 0d 00 00 00       	mov    $0xd,%eax
    144b:	cd 40                	int    $0x40
    144d:	c3                   	ret    

0000144e <uptime>:
SYSCALL(uptime)
    144e:	b8 0e 00 00 00       	mov    $0xe,%eax
    1453:	cd 40                	int    $0x40
    1455:	c3                   	ret    

00001456 <createwindow>:
SYSCALL(createwindow)
    1456:	b8 16 00 00 00       	mov    $0x16,%eax
    145b:	cd 40                	int    $0x40
    145d:	c3                   	ret    

0000145e <repaintwindow>:
SYSCALL(repaintwindow)
    145e:	b8 17 00 00 00       	mov    $0x17,%eax
    1463:	cd 40                	int    $0x40
    1465:	c3                   	ret    

00001466 <getmessage>:
SYSCALL(getmessage)
    1466:	b8 18 00 00 00       	mov    $0x18,%eax
    146b:	cd 40                	int    $0x40
    146d:	c3                   	ret    

0000146e <settimer>:
SYSCALL(settimer)
    146e:	b8 19 00 00 00       	mov    $0x19,%eax
    1473:	cd 40                	int    $0x40
    1475:	c3                   	ret    

00001476 <updatewindow>:
SYSCALL(updatewindow)
    1476:	b8 1a 00 00 00       	mov    $0x1a,%eax
    147b:	cd 40                	int    $0x40
    147d:	c3                   	ret    

0000147e <destroywindow>:
SYSCALL(destroywindow)
    147e:	b8 1b 00 00 00       	mov    $0x1b,%eax
    1483:	cd 40                	int    $0x40
    1485:	c3                   	ret    

00001486 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
    1486:	55                   	push   %ebp
    1487:	89 e5                	mov    %esp,%ebp
    1489:	83 ec 18             	sub    $0x18,%esp
    148c:	8b 45 0c             	mov    0xc(%ebp),%eax
    148f:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
    1492:	83 ec 04             	sub    $0x4,%esp
    1495:	6a 01                	push   $0x1
    1497:	8d 45 f4             	lea    -0xc(%ebp),%eax
    149a:	50                   	push   %eax
    149b:	ff 75 08             	pushl  0x8(%ebp)
    149e:	e8 33 ff ff ff       	call   13d6 <write>
    14a3:	83 c4 10             	add    $0x10,%esp
}
    14a6:	90                   	nop
    14a7:	c9                   	leave  
    14a8:	c3                   	ret    

000014a9 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
    14a9:	55                   	push   %ebp
    14aa:	89 e5                	mov    %esp,%ebp
    14ac:	53                   	push   %ebx
    14ad:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
    14b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
    14b7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    14bb:	74 17                	je     14d4 <printint+0x2b>
    14bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    14c1:	79 11                	jns    14d4 <printint+0x2b>
    neg = 1;
    14c3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
    14ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    14cd:	f7 d8                	neg    %eax
    14cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    14d2:	eb 06                	jmp    14da <printint+0x31>
  } else {
    x = xx;
    14d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    14d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
    14da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
    14e1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    14e4:	8d 41 01             	lea    0x1(%ecx),%eax
    14e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    14ea:	8b 5d 10             	mov    0x10(%ebp),%ebx
    14ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    14f0:	ba 00 00 00 00       	mov    $0x0,%edx
    14f5:	f7 f3                	div    %ebx
    14f7:	89 d0                	mov    %edx,%eax
    14f9:	0f b6 80 e0 f6 01 00 	movzbl 0x1f6e0(%eax),%eax
    1500:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
    1504:	8b 5d 10             	mov    0x10(%ebp),%ebx
    1507:	8b 45 ec             	mov    -0x14(%ebp),%eax
    150a:	ba 00 00 00 00       	mov    $0x0,%edx
    150f:	f7 f3                	div    %ebx
    1511:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1514:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1518:	75 c7                	jne    14e1 <printint+0x38>
  if(neg)
    151a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    151e:	74 2d                	je     154d <printint+0xa4>
    buf[i++] = '-';
    1520:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1523:	8d 50 01             	lea    0x1(%eax),%edx
    1526:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1529:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
    152e:	eb 1d                	jmp    154d <printint+0xa4>
    putc(fd, buf[i]);
    1530:	8d 55 dc             	lea    -0x24(%ebp),%edx
    1533:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1536:	01 d0                	add    %edx,%eax
    1538:	0f b6 00             	movzbl (%eax),%eax
    153b:	0f be c0             	movsbl %al,%eax
    153e:	83 ec 08             	sub    $0x8,%esp
    1541:	50                   	push   %eax
    1542:	ff 75 08             	pushl  0x8(%ebp)
    1545:	e8 3c ff ff ff       	call   1486 <putc>
    154a:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
    154d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1551:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1555:	79 d9                	jns    1530 <printint+0x87>
    putc(fd, buf[i]);
}
    1557:	90                   	nop
    1558:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    155b:	c9                   	leave  
    155c:	c3                   	ret    

0000155d <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
    155d:	55                   	push   %ebp
    155e:	89 e5                	mov    %esp,%ebp
    1560:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
    1563:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
    156a:	8d 45 0c             	lea    0xc(%ebp),%eax
    156d:	83 c0 04             	add    $0x4,%eax
    1570:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
    1573:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    157a:	e9 59 01 00 00       	jmp    16d8 <printf+0x17b>
    c = fmt[i] & 0xff;
    157f:	8b 55 0c             	mov    0xc(%ebp),%edx
    1582:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1585:	01 d0                	add    %edx,%eax
    1587:	0f b6 00             	movzbl (%eax),%eax
    158a:	0f be c0             	movsbl %al,%eax
    158d:	25 ff 00 00 00       	and    $0xff,%eax
    1592:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
    1595:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1599:	75 2c                	jne    15c7 <printf+0x6a>
      if(c == '%'){
    159b:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    159f:	75 0c                	jne    15ad <printf+0x50>
        state = '%';
    15a1:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
    15a8:	e9 27 01 00 00       	jmp    16d4 <printf+0x177>
      } else {
        putc(fd, c);
    15ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    15b0:	0f be c0             	movsbl %al,%eax
    15b3:	83 ec 08             	sub    $0x8,%esp
    15b6:	50                   	push   %eax
    15b7:	ff 75 08             	pushl  0x8(%ebp)
    15ba:	e8 c7 fe ff ff       	call   1486 <putc>
    15bf:	83 c4 10             	add    $0x10,%esp
    15c2:	e9 0d 01 00 00       	jmp    16d4 <printf+0x177>
      }
    } else if(state == '%'){
    15c7:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
    15cb:	0f 85 03 01 00 00    	jne    16d4 <printf+0x177>
      if(c == 'd'){
    15d1:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
    15d5:	75 1e                	jne    15f5 <printf+0x98>
        printint(fd, *ap, 10, 1);
    15d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    15da:	8b 00                	mov    (%eax),%eax
    15dc:	6a 01                	push   $0x1
    15de:	6a 0a                	push   $0xa
    15e0:	50                   	push   %eax
    15e1:	ff 75 08             	pushl  0x8(%ebp)
    15e4:	e8 c0 fe ff ff       	call   14a9 <printint>
    15e9:	83 c4 10             	add    $0x10,%esp
        ap++;
    15ec:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    15f0:	e9 d8 00 00 00       	jmp    16cd <printf+0x170>
      } else if(c == 'x' || c == 'p'){
    15f5:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
    15f9:	74 06                	je     1601 <printf+0xa4>
    15fb:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
    15ff:	75 1e                	jne    161f <printf+0xc2>
        printint(fd, *ap, 16, 0);
    1601:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1604:	8b 00                	mov    (%eax),%eax
    1606:	6a 00                	push   $0x0
    1608:	6a 10                	push   $0x10
    160a:	50                   	push   %eax
    160b:	ff 75 08             	pushl  0x8(%ebp)
    160e:	e8 96 fe ff ff       	call   14a9 <printint>
    1613:	83 c4 10             	add    $0x10,%esp
        ap++;
    1616:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    161a:	e9 ae 00 00 00       	jmp    16cd <printf+0x170>
      } else if(c == 's'){
    161f:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
    1623:	75 43                	jne    1668 <printf+0x10b>
        s = (char*)*ap;
    1625:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1628:	8b 00                	mov    (%eax),%eax
    162a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
    162d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
    1631:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1635:	75 25                	jne    165c <printf+0xff>
          s = "(null)";
    1637:	c7 45 f4 a7 6e 01 00 	movl   $0x16ea7,-0xc(%ebp)
        while(*s != 0){
    163e:	eb 1c                	jmp    165c <printf+0xff>
          putc(fd, *s);
    1640:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1643:	0f b6 00             	movzbl (%eax),%eax
    1646:	0f be c0             	movsbl %al,%eax
    1649:	83 ec 08             	sub    $0x8,%esp
    164c:	50                   	push   %eax
    164d:	ff 75 08             	pushl  0x8(%ebp)
    1650:	e8 31 fe ff ff       	call   1486 <putc>
    1655:	83 c4 10             	add    $0x10,%esp
          s++;
    1658:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
    165c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    165f:	0f b6 00             	movzbl (%eax),%eax
    1662:	84 c0                	test   %al,%al
    1664:	75 da                	jne    1640 <printf+0xe3>
    1666:	eb 65                	jmp    16cd <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
    1668:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
    166c:	75 1d                	jne    168b <printf+0x12e>
        putc(fd, *ap);
    166e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1671:	8b 00                	mov    (%eax),%eax
    1673:	0f be c0             	movsbl %al,%eax
    1676:	83 ec 08             	sub    $0x8,%esp
    1679:	50                   	push   %eax
    167a:	ff 75 08             	pushl  0x8(%ebp)
    167d:	e8 04 fe ff ff       	call   1486 <putc>
    1682:	83 c4 10             	add    $0x10,%esp
        ap++;
    1685:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    1689:	eb 42                	jmp    16cd <printf+0x170>
      } else if(c == '%'){
    168b:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    168f:	75 17                	jne    16a8 <printf+0x14b>
        putc(fd, c);
    1691:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1694:	0f be c0             	movsbl %al,%eax
    1697:	83 ec 08             	sub    $0x8,%esp
    169a:	50                   	push   %eax
    169b:	ff 75 08             	pushl  0x8(%ebp)
    169e:	e8 e3 fd ff ff       	call   1486 <putc>
    16a3:	83 c4 10             	add    $0x10,%esp
    16a6:	eb 25                	jmp    16cd <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
    16a8:	83 ec 08             	sub    $0x8,%esp
    16ab:	6a 25                	push   $0x25
    16ad:	ff 75 08             	pushl  0x8(%ebp)
    16b0:	e8 d1 fd ff ff       	call   1486 <putc>
    16b5:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
    16b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    16bb:	0f be c0             	movsbl %al,%eax
    16be:	83 ec 08             	sub    $0x8,%esp
    16c1:	50                   	push   %eax
    16c2:	ff 75 08             	pushl  0x8(%ebp)
    16c5:	e8 bc fd ff ff       	call   1486 <putc>
    16ca:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
    16cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
    16d4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    16d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    16db:	8b 45 f0             	mov    -0x10(%ebp),%eax
    16de:	01 d0                	add    %edx,%eax
    16e0:	0f b6 00             	movzbl (%eax),%eax
    16e3:	84 c0                	test   %al,%al
    16e5:	0f 85 94 fe ff ff    	jne    157f <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
    16eb:	90                   	nop
    16ec:	c9                   	leave  
    16ed:	c3                   	ret    

000016ee <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
    16ee:	55                   	push   %ebp
    16ef:	89 e5                	mov    %esp,%ebp
    16f1:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
    16f4:	8b 45 08             	mov    0x8(%ebp),%eax
    16f7:	83 e8 08             	sub    $0x8,%eax
    16fa:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    16fd:	a1 78 fe 01 00       	mov    0x1fe78,%eax
    1702:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1705:	eb 24                	jmp    172b <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
    1707:	8b 45 fc             	mov    -0x4(%ebp),%eax
    170a:	8b 00                	mov    (%eax),%eax
    170c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    170f:	77 12                	ja     1723 <free+0x35>
    1711:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1714:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1717:	77 24                	ja     173d <free+0x4f>
    1719:	8b 45 fc             	mov    -0x4(%ebp),%eax
    171c:	8b 00                	mov    (%eax),%eax
    171e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1721:	77 1a                	ja     173d <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    1723:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1726:	8b 00                	mov    (%eax),%eax
    1728:	89 45 fc             	mov    %eax,-0x4(%ebp)
    172b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    172e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1731:	76 d4                	jbe    1707 <free+0x19>
    1733:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1736:	8b 00                	mov    (%eax),%eax
    1738:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    173b:	76 ca                	jbe    1707 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
    173d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1740:	8b 40 04             	mov    0x4(%eax),%eax
    1743:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    174a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    174d:	01 c2                	add    %eax,%edx
    174f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1752:	8b 00                	mov    (%eax),%eax
    1754:	39 c2                	cmp    %eax,%edx
    1756:	75 24                	jne    177c <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
    1758:	8b 45 f8             	mov    -0x8(%ebp),%eax
    175b:	8b 50 04             	mov    0x4(%eax),%edx
    175e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1761:	8b 00                	mov    (%eax),%eax
    1763:	8b 40 04             	mov    0x4(%eax),%eax
    1766:	01 c2                	add    %eax,%edx
    1768:	8b 45 f8             	mov    -0x8(%ebp),%eax
    176b:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
    176e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1771:	8b 00                	mov    (%eax),%eax
    1773:	8b 10                	mov    (%eax),%edx
    1775:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1778:	89 10                	mov    %edx,(%eax)
    177a:	eb 0a                	jmp    1786 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
    177c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    177f:	8b 10                	mov    (%eax),%edx
    1781:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1784:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
    1786:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1789:	8b 40 04             	mov    0x4(%eax),%eax
    178c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    1793:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1796:	01 d0                	add    %edx,%eax
    1798:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    179b:	75 20                	jne    17bd <free+0xcf>
    p->s.size += bp->s.size;
    179d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17a0:	8b 50 04             	mov    0x4(%eax),%edx
    17a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17a6:	8b 40 04             	mov    0x4(%eax),%eax
    17a9:	01 c2                	add    %eax,%edx
    17ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17ae:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
    17b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17b4:	8b 10                	mov    (%eax),%edx
    17b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17b9:	89 10                	mov    %edx,(%eax)
    17bb:	eb 08                	jmp    17c5 <free+0xd7>
  } else
    p->s.ptr = bp;
    17bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    17c3:	89 10                	mov    %edx,(%eax)
  freep = p;
    17c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17c8:	a3 78 fe 01 00       	mov    %eax,0x1fe78
}
    17cd:	90                   	nop
    17ce:	c9                   	leave  
    17cf:	c3                   	ret    

000017d0 <morecore>:

static Header*
morecore(uint nu)
{
    17d0:	55                   	push   %ebp
    17d1:	89 e5                	mov    %esp,%ebp
    17d3:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
    17d6:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
    17dd:	77 07                	ja     17e6 <morecore+0x16>
    nu = 4096;
    17df:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
    17e6:	8b 45 08             	mov    0x8(%ebp),%eax
    17e9:	c1 e0 03             	shl    $0x3,%eax
    17ec:	83 ec 0c             	sub    $0xc,%esp
    17ef:	50                   	push   %eax
    17f0:	e8 49 fc ff ff       	call   143e <sbrk>
    17f5:	83 c4 10             	add    $0x10,%esp
    17f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
    17fb:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
    17ff:	75 07                	jne    1808 <morecore+0x38>
    return 0;
    1801:	b8 00 00 00 00       	mov    $0x0,%eax
    1806:	eb 26                	jmp    182e <morecore+0x5e>
  hp = (Header*)p;
    1808:	8b 45 f4             	mov    -0xc(%ebp),%eax
    180b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
    180e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1811:	8b 55 08             	mov    0x8(%ebp),%edx
    1814:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
    1817:	8b 45 f0             	mov    -0x10(%ebp),%eax
    181a:	83 c0 08             	add    $0x8,%eax
    181d:	83 ec 0c             	sub    $0xc,%esp
    1820:	50                   	push   %eax
    1821:	e8 c8 fe ff ff       	call   16ee <free>
    1826:	83 c4 10             	add    $0x10,%esp
  return freep;
    1829:	a1 78 fe 01 00       	mov    0x1fe78,%eax
}
    182e:	c9                   	leave  
    182f:	c3                   	ret    

00001830 <malloc>:

void*
malloc(uint nbytes)
{
    1830:	55                   	push   %ebp
    1831:	89 e5                	mov    %esp,%ebp
    1833:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
    1836:	8b 45 08             	mov    0x8(%ebp),%eax
    1839:	83 c0 07             	add    $0x7,%eax
    183c:	c1 e8 03             	shr    $0x3,%eax
    183f:	83 c0 01             	add    $0x1,%eax
    1842:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
    1845:	a1 78 fe 01 00       	mov    0x1fe78,%eax
    184a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    184d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    1851:	75 23                	jne    1876 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
    1853:	c7 45 f0 70 fe 01 00 	movl   $0x1fe70,-0x10(%ebp)
    185a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    185d:	a3 78 fe 01 00       	mov    %eax,0x1fe78
    1862:	a1 78 fe 01 00       	mov    0x1fe78,%eax
    1867:	a3 70 fe 01 00       	mov    %eax,0x1fe70
    base.s.size = 0;
    186c:	c7 05 74 fe 01 00 00 	movl   $0x0,0x1fe74
    1873:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    1876:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1879:	8b 00                	mov    (%eax),%eax
    187b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
    187e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1881:	8b 40 04             	mov    0x4(%eax),%eax
    1884:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    1887:	72 4d                	jb     18d6 <malloc+0xa6>
      if(p->s.size == nunits)
    1889:	8b 45 f4             	mov    -0xc(%ebp),%eax
    188c:	8b 40 04             	mov    0x4(%eax),%eax
    188f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    1892:	75 0c                	jne    18a0 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
    1894:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1897:	8b 10                	mov    (%eax),%edx
    1899:	8b 45 f0             	mov    -0x10(%ebp),%eax
    189c:	89 10                	mov    %edx,(%eax)
    189e:	eb 26                	jmp    18c6 <malloc+0x96>
      else {
        p->s.size -= nunits;
    18a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18a3:	8b 40 04             	mov    0x4(%eax),%eax
    18a6:	2b 45 ec             	sub    -0x14(%ebp),%eax
    18a9:	89 c2                	mov    %eax,%edx
    18ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18ae:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
    18b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18b4:	8b 40 04             	mov    0x4(%eax),%eax
    18b7:	c1 e0 03             	shl    $0x3,%eax
    18ba:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
    18bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18c0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    18c3:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
    18c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    18c9:	a3 78 fe 01 00       	mov    %eax,0x1fe78
      return (void*)(p + 1);
    18ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18d1:	83 c0 08             	add    $0x8,%eax
    18d4:	eb 3b                	jmp    1911 <malloc+0xe1>
    }
    if(p == freep)
    18d6:	a1 78 fe 01 00       	mov    0x1fe78,%eax
    18db:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    18de:	75 1e                	jne    18fe <malloc+0xce>
      if((p = morecore(nunits)) == 0)
    18e0:	83 ec 0c             	sub    $0xc,%esp
    18e3:	ff 75 ec             	pushl  -0x14(%ebp)
    18e6:	e8 e5 fe ff ff       	call   17d0 <morecore>
    18eb:	83 c4 10             	add    $0x10,%esp
    18ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    18f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    18f5:	75 07                	jne    18fe <malloc+0xce>
        return 0;
    18f7:	b8 00 00 00 00       	mov    $0x0,%eax
    18fc:	eb 13                	jmp    1911 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    18fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1901:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1904:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1907:	8b 00                	mov    (%eax),%eax
    1909:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
    190c:	e9 6d ff ff ff       	jmp    187e <malloc+0x4e>
}
    1911:	c9                   	leave  
    1912:	c3                   	ret    

00001913 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
    1913:	55                   	push   %ebp
    1914:	89 e5                	mov    %esp,%ebp
    ++g_seed;
    1916:	a1 7c fe 01 00       	mov    0x1fe7c,%eax
    191b:	83 c0 01             	add    $0x1,%eax
    191e:	a3 7c fe 01 00       	mov    %eax,0x1fe7c
    g_seed = (214013*g_seed+2531011);
    1923:	a1 7c fe 01 00       	mov    0x1fe7c,%eax
    1928:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
    192e:	05 c3 9e 26 00       	add    $0x269ec3,%eax
    1933:	a3 7c fe 01 00       	mov    %eax,0x1fe7c
    return (g_seed>>16)&0x7FFF;
    1938:	a1 7c fe 01 00       	mov    0x1fe7c,%eax
    193d:	c1 e8 10             	shr    $0x10,%eax
    1940:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
    1945:	5d                   	pop    %ebp
    1946:	c3                   	ret    

00001947 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
    1947:	55                   	push   %ebp
    1948:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
    194a:	d9 45 08             	flds   0x8(%ebp)
    194d:	d9 ee                	fldz   
    194f:	d9 c9                	fxch   %st(1)
    1951:	df e9                	fucomip %st(1),%st
    1953:	dd d8                	fstp   %st(0)
    1955:	76 05                	jbe    195c <abs+0x15>
    1957:	d9 45 08             	flds   0x8(%ebp)
    195a:	eb 05                	jmp    1961 <abs+0x1a>
	return -x;
    195c:	d9 45 08             	flds   0x8(%ebp)
    195f:	d9 e0                	fchs   
}
    1961:	5d                   	pop    %ebp
    1962:	c3                   	ret    

00001963 <pow>:

float pow(float a, int b)
{
    1963:	55                   	push   %ebp
    1964:	89 e5                	mov    %esp,%ebp
    1966:	83 ec 10             	sub    $0x10,%esp
	float r = a;
    1969:	d9 45 08             	flds   0x8(%ebp)
    196c:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
    196f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1973:	7e 17                	jle    198c <pow+0x29>
		while (--b)
    1975:	eb 09                	jmp    1980 <pow+0x1d>
			r *= a;
    1977:	d9 45 fc             	flds   -0x4(%ebp)
    197a:	d8 4d 08             	fmuls  0x8(%ebp)
    197d:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
    1980:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    1984:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1988:	75 ed                	jne    1977 <pow+0x14>
    198a:	eb 2a                	jmp    19b6 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
    198c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1990:	79 1f                	jns    19b1 <pow+0x4e>
		while (++b)
    1992:	eb 09                	jmp    199d <pow+0x3a>
			r *= a;
    1994:	d9 45 fc             	flds   -0x4(%ebp)
    1997:	d8 4d 08             	fmuls  0x8(%ebp)
    199a:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
    199d:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    19a1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    19a5:	75 ed                	jne    1994 <pow+0x31>
			r *= a;
		r = 1.0 / r;
    19a7:	d9 e8                	fld1   
    19a9:	d8 75 fc             	fdivs  -0x4(%ebp)
    19ac:	d9 5d fc             	fstps  -0x4(%ebp)
    19af:	eb 05                	jmp    19b6 <pow+0x53>
	}
	else r = 0;
    19b1:	d9 ee                	fldz   
    19b3:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
    19b6:	d9 45 fc             	flds   -0x4(%ebp)
}
    19b9:	c9                   	leave  
    19ba:	c3                   	ret    

000019bb <sqrt>:

float sqrt(float number) {
    19bb:	55                   	push   %ebp
    19bc:	89 e5                	mov    %esp,%ebp
    19be:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
    19c1:	d9 ee                	fldz   
    19c3:	d9 45 08             	flds   0x8(%ebp)
    19c6:	d9 c9                	fxch   %st(1)
    19c8:	df e9                	fucomip %st(1),%st
    19ca:	dd d8                	fstp   %st(0)
    19cc:	76 06                	jbe    19d4 <sqrt+0x19>
		return -1;
    19ce:	d9 e8                	fld1   
    19d0:	d9 e0                	fchs   
    19d2:	eb 3a                	jmp    1a0e <sqrt+0x53>
	}

	new_guess = 1;
    19d4:	d9 e8                	fld1   
    19d6:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
    19d9:	d9 45 fc             	flds   -0x4(%ebp)
    19dc:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
    19df:	d9 45 08             	flds   0x8(%ebp)
    19e2:	d8 75 f8             	fdivs  -0x8(%ebp)
    19e5:	d8 45 f8             	fadds  -0x8(%ebp)
    19e8:	d9 05 b0 6e 01 00    	flds   0x16eb0
    19ee:	de f9                	fdivrp %st,%st(1)
    19f0:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
    19f3:	d9 45 fc             	flds   -0x4(%ebp)
    19f6:	d9 45 f8             	flds   -0x8(%ebp)
    19f9:	df e9                	fucomip %st(1),%st
    19fb:	dd d8                	fstp   %st(0)
    19fd:	7a da                	jp     19d9 <sqrt+0x1e>
    19ff:	d9 45 fc             	flds   -0x4(%ebp)
    1a02:	d9 45 f8             	flds   -0x8(%ebp)
    1a05:	df e9                	fucomip %st(1),%st
    1a07:	dd d8                	fstp   %st(0)
    1a09:	75 ce                	jne    19d9 <sqrt+0x1e>

	return new_guess;
    1a0b:	d9 45 fc             	flds   -0x4(%ebp)
}
    1a0e:	c9                   	leave  
    1a0f:	c3                   	ret    

00001a10 <cos>:

float cos(float x)
{
    1a10:	55                   	push   %ebp
    1a11:	89 e5                	mov    %esp,%ebp
    1a13:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    1a16:	d9 e8                	fld1   
    1a18:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    1a1b:	d9 45 08             	flds   0x8(%ebp)
    1a1e:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1a24:	d9 c9                	fxch   %st(1)
    1a26:	df e9                	fucomip %st(1),%st
    1a28:	dd d8                	fstp   %st(0)
    1a2a:	77 0f                	ja     1a3b <cos+0x2b>
    1a2c:	d9 45 08             	flds   0x8(%ebp)
    1a2f:	dd 05 c0 6e 01 00    	fldl   0x16ec0
    1a35:	df e9                	fucomip %st(1),%st
    1a37:	dd d8                	fstp   %st(0)
    1a39:	76 3c                	jbe    1a77 <cos+0x67>
    1a3b:	d9 45 08             	flds   0x8(%ebp)
    1a3e:	d9 45 08             	flds   0x8(%ebp)
    1a41:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1a47:	de f9                	fdivrp %st,%st(1)
    1a49:	d9 7d e2             	fnstcw -0x1e(%ebp)
    1a4c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    1a50:	b4 0c                	mov    $0xc,%ah
    1a52:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    1a56:	d9 6d e0             	fldcw  -0x20(%ebp)
    1a59:	db 5d dc             	fistpl -0x24(%ebp)
    1a5c:	d9 6d e2             	fldcw  -0x1e(%ebp)
    1a5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1a62:	01 c0                	add    %eax,%eax
    1a64:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1a67:	db 45 d8             	fildl  -0x28(%ebp)
    1a6a:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1a70:	de c9                	fmulp  %st,%st(1)
    1a72:	de e9                	fsubrp %st,%st(1)
    1a74:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    1a77:	d9 45 08             	flds   0x8(%ebp)
    1a7a:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1a80:	d9 c9                	fxch   %st(1)
    1a82:	df e9                	fucomip %st(1),%st
    1a84:	dd d8                	fstp   %st(0)
    1a86:	76 0e                	jbe    1a96 <cos+0x86>
    1a88:	d9 45 08             	flds   0x8(%ebp)
    1a8b:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1a91:	de e9                	fsubrp %st,%st(1)
    1a93:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    1a96:	d9 45 08             	flds   0x8(%ebp)
    1a99:	dd 05 d0 6e 01 00    	fldl   0x16ed0
    1a9f:	df e9                	fucomip %st(1),%st
    1aa1:	dd d8                	fstp   %st(0)
    1aa3:	76 0e                	jbe    1ab3 <cos+0xa3>
    1aa5:	d9 45 08             	flds   0x8(%ebp)
    1aa8:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1aae:	de c1                	faddp  %st,%st(1)
    1ab0:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    1ab3:	d9 45 08             	flds   0x8(%ebp)
    1ab6:	dd 05 d8 6e 01 00    	fldl   0x16ed8
    1abc:	d9 c9                	fxch   %st(1)
    1abe:	df e9                	fucomip %st(1),%st
    1ac0:	dd d8                	fstp   %st(0)
    1ac2:	76 16                	jbe    1ada <cos+0xca>
    {
        x -= PI;
    1ac4:	d9 45 08             	flds   0x8(%ebp)
    1ac7:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1acd:	de e9                	fsubrp %st,%st(1)
    1acf:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1ad2:	d9 45 f4             	flds   -0xc(%ebp)
    1ad5:	d9 e0                	fchs   
    1ad7:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    1ada:	d9 45 08             	flds   0x8(%ebp)
    1add:	dd 05 e0 6e 01 00    	fldl   0x16ee0
    1ae3:	df e9                	fucomip %st(1),%st
    1ae5:	dd d8                	fstp   %st(0)
    1ae7:	76 16                	jbe    1aff <cos+0xef>
    {
        x += PI;
    1ae9:	d9 45 08             	flds   0x8(%ebp)
    1aec:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1af2:	de c1                	faddp  %st,%st(1)
    1af4:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1af7:	d9 45 f4             	flds   -0xc(%ebp)
    1afa:	d9 e0                	fchs   
    1afc:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
    1aff:	d9 45 08             	flds   0x8(%ebp)
    1b02:	dd 05 e8 6e 01 00    	fldl   0x16ee8
    1b08:	d9 c9                	fxch   %st(1)
    1b0a:	df e9                	fucomip %st(1),%st
    1b0c:	dd d8                	fstp   %st(0)
    1b0e:	76 28                	jbe    1b38 <cos+0x128>
    1b10:	d9 45 08             	flds   0x8(%ebp)
    1b13:	dd 05 d8 6e 01 00    	fldl   0x16ed8
    1b19:	de e1                	fsubp  %st,%st(1)
    1b1b:	d9 5d e4             	fstps  -0x1c(%ebp)
    1b1e:	d9 45 e4             	flds   -0x1c(%ebp)
    1b21:	83 ec 0c             	sub    $0xc,%esp
    1b24:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    1b28:	d9 1c 24             	fstps  (%esp)
    1b2b:	e8 83 00 00 00       	call   1bb3 <sin>
    1b30:	83 c4 10             	add    $0x10,%esp
    1b33:	d8 4d f4             	fmuls  -0xc(%ebp)
    1b36:	eb 79                	jmp    1bb1 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
    1b38:	83 ec 08             	sub    $0x8,%esp
    1b3b:	6a 02                	push   $0x2
    1b3d:	ff 75 08             	pushl  0x8(%ebp)
    1b40:	e8 1e fe ff ff       	call   1963 <pow>
    1b45:	83 c4 10             	add    $0x10,%esp
    1b48:	d9 05 b0 6e 01 00    	flds   0x16eb0
    1b4e:	de f9                	fdivrp %st,%st(1)
    1b50:	d9 e8                	fld1   
    1b52:	de e1                	fsubp  %st,%st(1)
    1b54:	d9 5d d8             	fstps  -0x28(%ebp)
    1b57:	83 ec 08             	sub    $0x8,%esp
    1b5a:	6a 04                	push   $0x4
    1b5c:	ff 75 08             	pushl  0x8(%ebp)
    1b5f:	e8 ff fd ff ff       	call   1963 <pow>
    1b64:	83 c4 10             	add    $0x10,%esp
    1b67:	d9 05 f0 6e 01 00    	flds   0x16ef0
    1b6d:	de f9                	fdivrp %st,%st(1)
    1b6f:	d8 45 d8             	fadds  -0x28(%ebp)
    1b72:	d9 5d d8             	fstps  -0x28(%ebp)
    1b75:	83 ec 08             	sub    $0x8,%esp
    1b78:	6a 06                	push   $0x6
    1b7a:	ff 75 08             	pushl  0x8(%ebp)
    1b7d:	e8 e1 fd ff ff       	call   1963 <pow>
    1b82:	83 c4 10             	add    $0x10,%esp
    1b85:	d9 05 f4 6e 01 00    	flds   0x16ef4
    1b8b:	de f9                	fdivrp %st,%st(1)
    1b8d:	d8 6d d8             	fsubrs -0x28(%ebp)
    1b90:	d9 5d d8             	fstps  -0x28(%ebp)
    1b93:	83 ec 08             	sub    $0x8,%esp
    1b96:	6a 08                	push   $0x8
    1b98:	ff 75 08             	pushl  0x8(%ebp)
    1b9b:	e8 c3 fd ff ff       	call   1963 <pow>
    1ba0:	83 c4 10             	add    $0x10,%esp
    1ba3:	d9 05 f8 6e 01 00    	flds   0x16ef8
    1ba9:	de f9                	fdivrp %st,%st(1)
    1bab:	d8 45 d8             	fadds  -0x28(%ebp)
    1bae:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    1bb1:	c9                   	leave  
    1bb2:	c3                   	ret    

00001bb3 <sin>:

float sin(float x)
{
    1bb3:	55                   	push   %ebp
    1bb4:	89 e5                	mov    %esp,%ebp
    1bb6:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    1bb9:	d9 e8                	fld1   
    1bbb:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    1bbe:	d9 45 08             	flds   0x8(%ebp)
    1bc1:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1bc7:	d9 c9                	fxch   %st(1)
    1bc9:	df e9                	fucomip %st(1),%st
    1bcb:	dd d8                	fstp   %st(0)
    1bcd:	77 0f                	ja     1bde <sin+0x2b>
    1bcf:	d9 45 08             	flds   0x8(%ebp)
    1bd2:	dd 05 c0 6e 01 00    	fldl   0x16ec0
    1bd8:	df e9                	fucomip %st(1),%st
    1bda:	dd d8                	fstp   %st(0)
    1bdc:	76 3c                	jbe    1c1a <sin+0x67>
    1bde:	d9 45 08             	flds   0x8(%ebp)
    1be1:	d9 45 08             	flds   0x8(%ebp)
    1be4:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1bea:	de f9                	fdivrp %st,%st(1)
    1bec:	d9 7d e2             	fnstcw -0x1e(%ebp)
    1bef:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    1bf3:	b4 0c                	mov    $0xc,%ah
    1bf5:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    1bf9:	d9 6d e0             	fldcw  -0x20(%ebp)
    1bfc:	db 5d dc             	fistpl -0x24(%ebp)
    1bff:	d9 6d e2             	fldcw  -0x1e(%ebp)
    1c02:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1c05:	01 c0                	add    %eax,%eax
    1c07:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1c0a:	db 45 d8             	fildl  -0x28(%ebp)
    1c0d:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1c13:	de c9                	fmulp  %st,%st(1)
    1c15:	de e9                	fsubrp %st,%st(1)
    1c17:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    1c1a:	d9 45 08             	flds   0x8(%ebp)
    1c1d:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1c23:	d9 c9                	fxch   %st(1)
    1c25:	df e9                	fucomip %st(1),%st
    1c27:	dd d8                	fstp   %st(0)
    1c29:	76 0e                	jbe    1c39 <sin+0x86>
    1c2b:	d9 45 08             	flds   0x8(%ebp)
    1c2e:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1c34:	de e9                	fsubrp %st,%st(1)
    1c36:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    1c39:	d9 45 08             	flds   0x8(%ebp)
    1c3c:	dd 05 d0 6e 01 00    	fldl   0x16ed0
    1c42:	df e9                	fucomip %st(1),%st
    1c44:	dd d8                	fstp   %st(0)
    1c46:	76 0e                	jbe    1c56 <sin+0xa3>
    1c48:	d9 45 08             	flds   0x8(%ebp)
    1c4b:	dd 05 b8 6e 01 00    	fldl   0x16eb8
    1c51:	de c1                	faddp  %st,%st(1)
    1c53:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    1c56:	d9 45 08             	flds   0x8(%ebp)
    1c59:	dd 05 d8 6e 01 00    	fldl   0x16ed8
    1c5f:	d9 c9                	fxch   %st(1)
    1c61:	df e9                	fucomip %st(1),%st
    1c63:	dd d8                	fstp   %st(0)
    1c65:	76 16                	jbe    1c7d <sin+0xca>
    {
        x -= PI;
    1c67:	d9 45 08             	flds   0x8(%ebp)
    1c6a:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1c70:	de e9                	fsubrp %st,%st(1)
    1c72:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1c75:	d9 45 f4             	flds   -0xc(%ebp)
    1c78:	d9 e0                	fchs   
    1c7a:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    1c7d:	d9 45 08             	flds   0x8(%ebp)
    1c80:	dd 05 e0 6e 01 00    	fldl   0x16ee0
    1c86:	df e9                	fucomip %st(1),%st
    1c88:	dd d8                	fstp   %st(0)
    1c8a:	76 16                	jbe    1ca2 <sin+0xef>
    {
        x += PI;
    1c8c:	d9 45 08             	flds   0x8(%ebp)
    1c8f:	dd 05 c8 6e 01 00    	fldl   0x16ec8
    1c95:	de c1                	faddp  %st,%st(1)
    1c97:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1c9a:	d9 45 f4             	flds   -0xc(%ebp)
    1c9d:	d9 e0                	fchs   
    1c9f:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
    1ca2:	d9 ee                	fldz   
    1ca4:	d9 45 08             	flds   0x8(%ebp)
    1ca7:	d9 c9                	fxch   %st(1)
    1ca9:	df e9                	fucomip %st(1),%st
    1cab:	dd d8                	fstp   %st(0)
    1cad:	76 10                	jbe    1cbf <sin+0x10c>
    {
        x *= -1;
    1caf:	d9 45 08             	flds   0x8(%ebp)
    1cb2:	d9 e0                	fchs   
    1cb4:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1cb7:	d9 45 f4             	flds   -0xc(%ebp)
    1cba:	d9 e0                	fchs   
    1cbc:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
    1cbf:	d9 45 08             	flds   0x8(%ebp)
    1cc2:	dd 05 e8 6e 01 00    	fldl   0x16ee8
    1cc8:	d9 c9                	fxch   %st(1)
    1cca:	df e9                	fucomip %st(1),%st
    1ccc:	dd d8                	fstp   %st(0)
    1cce:	76 28                	jbe    1cf8 <sin+0x145>
    1cd0:	d9 45 08             	flds   0x8(%ebp)
    1cd3:	dd 05 d8 6e 01 00    	fldl   0x16ed8
    1cd9:	de e1                	fsubp  %st,%st(1)
    1cdb:	d9 5d e4             	fstps  -0x1c(%ebp)
    1cde:	d9 45 e4             	flds   -0x1c(%ebp)
    1ce1:	83 ec 0c             	sub    $0xc,%esp
    1ce4:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    1ce8:	d9 1c 24             	fstps  (%esp)
    1ceb:	e8 20 fd ff ff       	call   1a10 <cos>
    1cf0:	83 c4 10             	add    $0x10,%esp
    1cf3:	d8 4d f4             	fmuls  -0xc(%ebp)
    1cf6:	eb 7a                	jmp    1d72 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
    1cf8:	83 ec 08             	sub    $0x8,%esp
    1cfb:	6a 03                	push   $0x3
    1cfd:	ff 75 08             	pushl  0x8(%ebp)
    1d00:	e8 5e fc ff ff       	call   1963 <pow>
    1d05:	83 c4 10             	add    $0x10,%esp
    1d08:	d9 05 fc 6e 01 00    	flds   0x16efc
    1d0e:	de f9                	fdivrp %st,%st(1)
    1d10:	d9 45 08             	flds   0x8(%ebp)
    1d13:	de e1                	fsubp  %st,%st(1)
    1d15:	d9 5d d8             	fstps  -0x28(%ebp)
    1d18:	83 ec 08             	sub    $0x8,%esp
    1d1b:	6a 05                	push   $0x5
    1d1d:	ff 75 08             	pushl  0x8(%ebp)
    1d20:	e8 3e fc ff ff       	call   1963 <pow>
    1d25:	83 c4 10             	add    $0x10,%esp
    1d28:	d9 05 00 6f 01 00    	flds   0x16f00
    1d2e:	de f9                	fdivrp %st,%st(1)
    1d30:	d8 45 d8             	fadds  -0x28(%ebp)
    1d33:	d9 5d d8             	fstps  -0x28(%ebp)
    1d36:	83 ec 08             	sub    $0x8,%esp
    1d39:	6a 07                	push   $0x7
    1d3b:	ff 75 08             	pushl  0x8(%ebp)
    1d3e:	e8 20 fc ff ff       	call   1963 <pow>
    1d43:	83 c4 10             	add    $0x10,%esp
    1d46:	d9 05 04 6f 01 00    	flds   0x16f04
    1d4c:	de f9                	fdivrp %st,%st(1)
    1d4e:	d8 6d d8             	fsubrs -0x28(%ebp)
    1d51:	d9 5d d8             	fstps  -0x28(%ebp)
    1d54:	83 ec 08             	sub    $0x8,%esp
    1d57:	6a 09                	push   $0x9
    1d59:	ff 75 08             	pushl  0x8(%ebp)
    1d5c:	e8 02 fc ff ff       	call   1963 <pow>
    1d61:	83 c4 10             	add    $0x10,%esp
    1d64:	d9 05 08 6f 01 00    	flds   0x16f08
    1d6a:	de f9                	fdivrp %st,%st(1)
    1d6c:	d8 45 d8             	fadds  -0x28(%ebp)
    1d6f:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    1d72:	c9                   	leave  
    1d73:	c3                   	ret    

00001d74 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    1d74:	55                   	push   %ebp
    1d75:	89 e5                	mov    %esp,%ebp
    1d77:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1d7a:	83 ec 04             	sub    $0x4,%esp
    1d7d:	6a 0e                	push   $0xe
    1d7f:	ff 75 0c             	pushl  0xc(%ebp)
    1d82:	ff 75 08             	pushl  0x8(%ebp)
    1d85:	e8 44 f6 ff ff       	call   13ce <read>
    1d8a:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1d8d:	83 ec 04             	sub    $0x4,%esp
    1d90:	6a 28                	push   $0x28
    1d92:	ff 75 10             	pushl  0x10(%ebp)
    1d95:	ff 75 08             	pushl  0x8(%ebp)
    1d98:	e8 31 f6 ff ff       	call   13ce <read>
    1d9d:	83 c4 10             	add    $0x10,%esp
}
    1da0:	90                   	nop
    1da1:	c9                   	leave  
    1da2:	c3                   	ret    

00001da3 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    1da3:	55                   	push   %ebp
    1da4:	89 e5                	mov    %esp,%ebp
    1da6:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    1dac:	83 ec 08             	sub    $0x8,%esp
    1daf:	6a 00                	push   $0x0
    1db1:	ff 75 08             	pushl  0x8(%ebp)
    1db4:	e8 3d f6 ff ff       	call   13f6 <open>
    1db9:	83 c4 10             	add    $0x10,%esp
    1dbc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1dbf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1dc3:	79 0a                	jns    1dcf <readBitmapFile+0x2c>
        return -1;
    1dc5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1dca:	e9 6e 01 00 00       	jmp    1f3d <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1dcf:	83 ec 04             	sub    $0x4,%esp
    1dd2:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1dd5:	50                   	push   %eax
    1dd6:	8d 45 ca             	lea    -0x36(%ebp),%eax
    1dd9:	50                   	push   %eax
    1dda:	ff 75 ec             	pushl  -0x14(%ebp)
    1ddd:	e8 92 ff ff ff       	call   1d74 <readBitmapHeader>
    1de2:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1de5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1de8:	83 e8 36             	sub    $0x36,%eax
    1deb:	83 ec 04             	sub    $0x4,%esp
    1dee:	50                   	push   %eax
    1def:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1df5:	50                   	push   %eax
    1df6:	ff 75 ec             	pushl  -0x14(%ebp)
    1df9:	e8 d0 f5 ff ff       	call   13ce <read>
    1dfe:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1e01:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1e04:	8b 45 14             	mov    0x14(%ebp),%eax
    1e07:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    1e09:	8b 55 aa             	mov    -0x56(%ebp),%edx
    1e0c:	8b 45 10             	mov    0x10(%ebp),%eax
    1e0f:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    1e11:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1e14:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    1e17:	8b 45 aa             	mov    -0x56(%ebp),%eax
    1e1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    1e1d:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    1e21:	0f b7 c0             	movzwl %ax,%eax
    1e24:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    1e27:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1e2a:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    1e2e:	8d 50 07             	lea    0x7(%eax),%edx
    1e31:	85 c0                	test   %eax,%eax
    1e33:	0f 48 c2             	cmovs  %edx,%eax
    1e36:	c1 f8 03             	sar    $0x3,%eax
    1e39:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1e3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e3f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1e42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1e45:	83 e8 01             	sub    $0x1,%eax
    1e48:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1e4b:	e9 d0 00 00 00       	jmp    1f20 <readBitmapFile+0x17d>
        if (bits == 32) {
    1e50:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    1e54:	75 22                	jne    1e78 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    1e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e59:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    1e5d:	89 c2                	mov    %eax,%edx
    1e5f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1e62:	01 d0                	add    %edx,%eax
    1e64:	83 ec 04             	sub    $0x4,%esp
    1e67:	ff 75 dc             	pushl  -0x24(%ebp)
    1e6a:	50                   	push   %eax
    1e6b:	ff 75 ec             	pushl  -0x14(%ebp)
    1e6e:	e8 5b f5 ff ff       	call   13ce <read>
    1e73:	83 c4 10             	add    $0x10,%esp
    1e76:	eb 65                	jmp    1edd <readBitmapFile+0x13a>
        } else {
            int j = 0;
    1e78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1e7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1e86:	eb 4d                	jmp    1ed5 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    1e88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e8b:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1e8f:	c1 e0 02             	shl    $0x2,%eax
    1e92:	89 c2                	mov    %eax,%edx
    1e94:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e97:	c1 e0 02             	shl    $0x2,%eax
    1e9a:	01 c2                	add    %eax,%edx
    1e9c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1e9f:	01 d0                	add    %edx,%eax
    1ea1:	83 ec 04             	sub    $0x4,%esp
    1ea4:	6a 03                	push   $0x3
    1ea6:	50                   	push   %eax
    1ea7:	ff 75 ec             	pushl  -0x14(%ebp)
    1eaa:	e8 1f f5 ff ff       	call   13ce <read>
    1eaf:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    1eb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1eb5:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1eb9:	c1 e0 02             	shl    $0x2,%eax
    1ebc:	89 c2                	mov    %eax,%edx
    1ebe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ec1:	c1 e0 02             	shl    $0x2,%eax
    1ec4:	01 d0                	add    %edx,%eax
    1ec6:	8d 50 03             	lea    0x3(%eax),%edx
    1ec9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1ecc:	01 d0                	add    %edx,%eax
    1ece:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1ed1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1ed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ed8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1edb:	7c ab                	jl     1e88 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    1edd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1ee0:	99                   	cltd   
    1ee1:	c1 ea 1e             	shr    $0x1e,%edx
    1ee4:	01 d0                	add    %edx,%eax
    1ee6:	83 e0 03             	and    $0x3,%eax
    1ee9:	29 d0                	sub    %edx,%eax
    1eeb:	85 c0                	test   %eax,%eax
    1eed:	7e 2d                	jle    1f1c <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1eef:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1ef2:	99                   	cltd   
    1ef3:	c1 ea 1e             	shr    $0x1e,%edx
    1ef6:	01 d0                	add    %edx,%eax
    1ef8:	83 e0 03             	and    $0x3,%eax
    1efb:	29 d0                	sub    %edx,%eax
    1efd:	ba 04 00 00 00       	mov    $0x4,%edx
    1f02:	29 c2                	sub    %eax,%edx
    1f04:	89 d0                	mov    %edx,%eax
    1f06:	83 ec 04             	sub    $0x4,%esp
    1f09:	50                   	push   %eax
    1f0a:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1f10:	50                   	push   %eax
    1f11:	ff 75 ec             	pushl  -0x14(%ebp)
    1f14:	e8 b5 f4 ff ff       	call   13ce <read>
    1f19:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1f1c:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1f20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1f24:	0f 89 26 ff ff ff    	jns    1e50 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1f2a:	83 ec 0c             	sub    $0xc,%esp
    1f2d:	ff 75 ec             	pushl  -0x14(%ebp)
    1f30:	e8 a9 f4 ff ff       	call   13de <close>
    1f35:	83 c4 10             	add    $0x10,%esp
    return 0;
    1f38:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1f3d:	c9                   	leave  
    1f3e:	c3                   	ret    

00001f3f <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    1f3f:	55                   	push   %ebp
    1f40:	89 e5                	mov    %esp,%ebp
    1f42:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    1f48:	83 ec 08             	sub    $0x8,%esp
    1f4b:	6a 00                	push   $0x0
    1f4d:	ff 75 08             	pushl  0x8(%ebp)
    1f50:	e8 a1 f4 ff ff       	call   13f6 <open>
    1f55:	83 c4 10             	add    $0x10,%esp
    1f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1f5b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1f5f:	79 0a                	jns    1f6b <read24BitmapFile+0x2c>
        return -1;
    1f61:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1f66:	e9 66 01 00 00       	jmp    20d1 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1f6b:	83 ec 04             	sub    $0x4,%esp
    1f6e:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1f71:	50                   	push   %eax
    1f72:	8d 45 ca             	lea    -0x36(%ebp),%eax
    1f75:	50                   	push   %eax
    1f76:	ff 75 ec             	pushl  -0x14(%ebp)
    1f79:	e8 f6 fd ff ff       	call   1d74 <readBitmapHeader>
    1f7e:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1f81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1f84:	83 e8 36             	sub    $0x36,%eax
    1f87:	83 ec 04             	sub    $0x4,%esp
    1f8a:	50                   	push   %eax
    1f8b:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1f91:	50                   	push   %eax
    1f92:	ff 75 ec             	pushl  -0x14(%ebp)
    1f95:	e8 34 f4 ff ff       	call   13ce <read>
    1f9a:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1f9d:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1fa0:	8b 45 14             	mov    0x14(%ebp),%eax
    1fa3:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    1fa5:	8b 55 aa             	mov    -0x56(%ebp),%edx
    1fa8:	8b 45 10             	mov    0x10(%ebp),%eax
    1fab:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    1fad:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1fb0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    1fb3:	8b 45 aa             	mov    -0x56(%ebp),%eax
    1fb6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    1fb9:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    1fbd:	0f b7 c0             	movzwl %ax,%eax
    1fc0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    1fc3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1fc6:	89 d0                	mov    %edx,%eax
    1fc8:	01 c0                	add    %eax,%eax
    1fca:	01 d0                	add    %edx,%eax
    1fcc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1fcf:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fd2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1fd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1fd8:	83 e8 01             	sub    $0x1,%eax
    1fdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1fde:	e9 d1 00 00 00       	jmp    20b4 <read24BitmapFile+0x175>
        if (bits == 24) {
    1fe3:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    1fe7:	75 22                	jne    200b <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    1fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1fec:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    1ff0:	89 c2                	mov    %eax,%edx
    1ff2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1ff5:	01 d0                	add    %edx,%eax
    1ff7:	83 ec 04             	sub    $0x4,%esp
    1ffa:	ff 75 dc             	pushl  -0x24(%ebp)
    1ffd:	50                   	push   %eax
    1ffe:	ff 75 ec             	pushl  -0x14(%ebp)
    2001:	e8 c8 f3 ff ff       	call   13ce <read>
    2006:	83 c4 10             	add    $0x10,%esp
    2009:	eb 66                	jmp    2071 <read24BitmapFile+0x132>
        } else {
            int j = 0;
    200b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    2012:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2019:	eb 4e                	jmp    2069 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    201b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    201e:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2022:	89 c2                	mov    %eax,%edx
    2024:	89 d0                	mov    %edx,%eax
    2026:	01 c0                	add    %eax,%eax
    2028:	01 d0                	add    %edx,%eax
    202a:	89 c1                	mov    %eax,%ecx
    202c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    202f:	89 d0                	mov    %edx,%eax
    2031:	01 c0                	add    %eax,%eax
    2033:	01 d0                	add    %edx,%eax
    2035:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    2038:	8b 45 d8             	mov    -0x28(%ebp),%eax
    203b:	01 d0                	add    %edx,%eax
    203d:	83 ec 04             	sub    $0x4,%esp
    2040:	6a 03                	push   $0x3
    2042:	50                   	push   %eax
    2043:	ff 75 ec             	pushl  -0x14(%ebp)
    2046:	e8 83 f3 ff ff       	call   13ce <read>
    204b:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    204e:	83 ec 04             	sub    $0x4,%esp
    2051:	6a 01                	push   $0x1
    2053:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    2059:	50                   	push   %eax
    205a:	ff 75 ec             	pushl  -0x14(%ebp)
    205d:	e8 6c f3 ff ff       	call   13ce <read>
    2062:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    2065:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2069:	8b 45 f0             	mov    -0x10(%ebp),%eax
    206c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    206f:	7c aa                	jl     201b <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    2071:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2074:	99                   	cltd   
    2075:	c1 ea 1e             	shr    $0x1e,%edx
    2078:	01 d0                	add    %edx,%eax
    207a:	83 e0 03             	and    $0x3,%eax
    207d:	29 d0                	sub    %edx,%eax
    207f:	85 c0                	test   %eax,%eax
    2081:	7e 2d                	jle    20b0 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    2083:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2086:	99                   	cltd   
    2087:	c1 ea 1e             	shr    $0x1e,%edx
    208a:	01 d0                	add    %edx,%eax
    208c:	83 e0 03             	and    $0x3,%eax
    208f:	29 d0                	sub    %edx,%eax
    2091:	ba 04 00 00 00       	mov    $0x4,%edx
    2096:	29 c2                	sub    %eax,%edx
    2098:	89 d0                	mov    %edx,%eax
    209a:	83 ec 04             	sub    $0x4,%esp
    209d:	50                   	push   %eax
    209e:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    20a4:	50                   	push   %eax
    20a5:	ff 75 ec             	pushl  -0x14(%ebp)
    20a8:	e8 21 f3 ff ff       	call   13ce <read>
    20ad:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    20b0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    20b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    20b8:	0f 89 25 ff ff ff    	jns    1fe3 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    20be:	83 ec 0c             	sub    $0xc,%esp
    20c1:	ff 75 ec             	pushl  -0x14(%ebp)
    20c4:	e8 15 f3 ff ff       	call   13de <close>
    20c9:	83 c4 10             	add    $0x10,%esp
    return 0;
    20cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    20d1:	c9                   	leave  
    20d2:	c3                   	ret    

000020d3 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    20d3:	55                   	push   %ebp
    20d4:	89 e5                	mov    %esp,%ebp
    20d6:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    20d9:	8b 55 10             	mov    0x10(%ebp),%edx
    20dc:	89 d0                	mov    %edx,%eax
    20de:	01 c0                	add    %eax,%eax
    20e0:	01 d0                	add    %edx,%eax
    20e2:	c1 e0 03             	shl    $0x3,%eax
    20e5:	83 c0 1f             	add    $0x1f,%eax
    20e8:	8d 50 1f             	lea    0x1f(%eax),%edx
    20eb:	85 c0                	test   %eax,%eax
    20ed:	0f 48 c2             	cmovs  %edx,%eax
    20f0:	c1 f8 05             	sar    $0x5,%eax
    20f3:	c1 e0 02             	shl    $0x2,%eax
    20f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    20f9:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    20ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2102:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2106:	83 c0 36             	add    $0x36,%eax
    2109:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    210c:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    2112:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    2118:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    211f:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    2126:	8b 45 10             	mov    0x10(%ebp),%eax
    2129:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    212c:	8b 45 0c             	mov    0xc(%ebp),%eax
    212f:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    2132:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    2138:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    213e:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    2145:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2148:	0f af 45 0c          	imul   0xc(%ebp),%eax
    214c:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    214f:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    2156:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    215d:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    2164:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    216b:	83 ec 04             	sub    $0x4,%esp
    216e:	6a 0e                	push   $0xe
    2170:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    2173:	50                   	push   %eax
    2174:	ff 75 08             	pushl  0x8(%ebp)
    2177:	e8 5a f2 ff ff       	call   13d6 <write>
    217c:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    217f:	83 ec 04             	sub    $0x4,%esp
    2182:	6a 28                	push   $0x28
    2184:	8d 45 be             	lea    -0x42(%ebp),%eax
    2187:	50                   	push   %eax
    2188:	ff 75 08             	pushl  0x8(%ebp)
    218b:	e8 46 f2 ff ff       	call   13d6 <write>
    2190:	83 c4 10             	add    $0x10,%esp
}
    2193:	90                   	nop
    2194:	c9                   	leave  
    2195:	c3                   	ret    

00002196 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    2196:	55                   	push   %ebp
    2197:	89 e5                	mov    %esp,%ebp
    2199:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    219c:	83 ec 08             	sub    $0x8,%esp
    219f:	68 02 02 00 00       	push   $0x202
    21a4:	ff 75 08             	pushl  0x8(%ebp)
    21a7:	e8 4a f2 ff ff       	call   13f6 <open>
    21ac:	83 c4 10             	add    $0x10,%esp
    21af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    21b2:	8b 55 14             	mov    0x14(%ebp),%edx
    21b5:	89 d0                	mov    %edx,%eax
    21b7:	01 c0                	add    %eax,%eax
    21b9:	01 d0                	add    %edx,%eax
    21bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    21be:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    21c2:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    21c6:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    21ca:	83 ec 04             	sub    $0x4,%esp
    21cd:	ff 75 14             	pushl  0x14(%ebp)
    21d0:	ff 75 10             	pushl  0x10(%ebp)
    21d3:	ff 75 f0             	pushl  -0x10(%ebp)
    21d6:	e8 f8 fe ff ff       	call   20d3 <write24BitmapFileHeader>
    21db:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    21de:	8b 45 10             	mov    0x10(%ebp),%eax
    21e1:	83 e8 01             	sub    $0x1,%eax
    21e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    21e7:	eb 66                	jmp    224f <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    21e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21ec:	0f af 45 14          	imul   0x14(%ebp),%eax
    21f0:	89 c2                	mov    %eax,%edx
    21f2:	89 d0                	mov    %edx,%eax
    21f4:	01 c0                	add    %eax,%eax
    21f6:	01 c2                	add    %eax,%edx
    21f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    21fb:	01 d0                	add    %edx,%eax
    21fd:	83 ec 04             	sub    $0x4,%esp
    2200:	ff 75 ec             	pushl  -0x14(%ebp)
    2203:	50                   	push   %eax
    2204:	ff 75 f0             	pushl  -0x10(%ebp)
    2207:	e8 ca f1 ff ff       	call   13d6 <write>
    220c:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    220f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2212:	99                   	cltd   
    2213:	c1 ea 1e             	shr    $0x1e,%edx
    2216:	01 d0                	add    %edx,%eax
    2218:	83 e0 03             	and    $0x3,%eax
    221b:	29 d0                	sub    %edx,%eax
    221d:	85 c0                	test   %eax,%eax
    221f:	7e 2a                	jle    224b <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    2221:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2224:	99                   	cltd   
    2225:	c1 ea 1e             	shr    $0x1e,%edx
    2228:	01 d0                	add    %edx,%eax
    222a:	83 e0 03             	and    $0x3,%eax
    222d:	29 d0                	sub    %edx,%eax
    222f:	ba 04 00 00 00       	mov    $0x4,%edx
    2234:	29 c2                	sub    %eax,%edx
    2236:	89 d0                	mov    %edx,%eax
    2238:	83 ec 04             	sub    $0x4,%esp
    223b:	50                   	push   %eax
    223c:	8d 45 e9             	lea    -0x17(%ebp),%eax
    223f:	50                   	push   %eax
    2240:	ff 75 f0             	pushl  -0x10(%ebp)
    2243:	e8 8e f1 ff ff       	call   13d6 <write>
    2248:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    224b:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    224f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2253:	79 94                	jns    21e9 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    2255:	83 ec 0c             	sub    $0xc,%esp
    2258:	ff 75 f0             	pushl  -0x10(%ebp)
    225b:	e8 7e f1 ff ff       	call   13de <close>
    2260:	83 c4 10             	add    $0x10,%esp
    return 0;
    2263:	b8 00 00 00 00       	mov    $0x0,%eax
    2268:	c9                   	leave  
    2269:	c3                   	ret    

0000226a <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    226a:	55                   	push   %ebp
    226b:	89 e5                	mov    %esp,%ebp
    226d:	57                   	push   %edi
    226e:	56                   	push   %esi
    226f:	53                   	push   %ebx
    2270:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    2273:	8b 45 08             	mov    0x8(%ebp),%eax
    2276:	8b 50 10             	mov    0x10(%eax),%edx
    2279:	8b 40 0c             	mov    0xc(%eax),%eax
    227c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    227f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    2282:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2285:	8b 55 e0             	mov    -0x20(%ebp),%edx
    2288:	83 c2 1e             	add    $0x1e,%edx
    228b:	0f af d0             	imul   %eax,%edx
    228e:	89 d0                	mov    %edx,%eax
    2290:	01 c0                	add    %eax,%eax
    2292:	01 d0                	add    %edx,%eax
    2294:	83 ec 0c             	sub    $0xc,%esp
    2297:	50                   	push   %eax
    2298:	e8 93 f5 ff ff       	call   1830 <malloc>
    229d:	83 c4 10             	add    $0x10,%esp
    22a0:	89 c2                	mov    %eax,%edx
    22a2:	8b 45 08             	mov    0x8(%ebp),%eax
    22a5:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    22a8:	8b 45 08             	mov    0x8(%ebp),%eax
    22ab:	8b 40 1c             	mov    0x1c(%eax),%eax
    22ae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    22b1:	6b d2 5a             	imul   $0x5a,%edx,%edx
    22b4:	01 c2                	add    %eax,%edx
    22b6:	8b 45 08             	mov    0x8(%ebp),%eax
    22b9:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    22bc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    22bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
    22c2:	0f af d0             	imul   %eax,%edx
    22c5:	89 d0                	mov    %edx,%eax
    22c7:	01 c0                	add    %eax,%eax
    22c9:	01 d0                	add    %edx,%eax
    22cb:	89 c2                	mov    %eax,%edx
    22cd:	8b 45 08             	mov    0x8(%ebp),%eax
    22d0:	8b 40 18             	mov    0x18(%eax),%eax
    22d3:	83 ec 04             	sub    $0x4,%esp
    22d6:	52                   	push   %edx
    22d7:	68 ff 00 00 00       	push   $0xff
    22dc:	50                   	push   %eax
    22dd:	e8 39 ef ff ff       	call   121b <memset>
    22e2:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    22e5:	8b 45 08             	mov    0x8(%ebp),%eax
    22e8:	8b 78 1c             	mov    0x1c(%eax),%edi
    22eb:	8b 45 08             	mov    0x8(%ebp),%eax
    22ee:	8b 70 14             	mov    0x14(%eax),%esi
    22f1:	8b 45 08             	mov    0x8(%ebp),%eax
    22f4:	8b 58 0c             	mov    0xc(%eax),%ebx
    22f7:	8b 45 08             	mov    0x8(%ebp),%eax
    22fa:	8b 48 10             	mov    0x10(%eax),%ecx
    22fd:	8b 45 08             	mov    0x8(%ebp),%eax
    2300:	8b 50 08             	mov    0x8(%eax),%edx
    2303:	8b 45 08             	mov    0x8(%ebp),%eax
    2306:	8b 40 04             	mov    0x4(%eax),%eax
    2309:	83 ec 08             	sub    $0x8,%esp
    230c:	57                   	push   %edi
    230d:	56                   	push   %esi
    230e:	53                   	push   %ebx
    230f:	51                   	push   %ecx
    2310:	52                   	push   %edx
    2311:	50                   	push   %eax
    2312:	e8 3f f1 ff ff       	call   1456 <createwindow>
    2317:	83 c4 20             	add    $0x20,%esp
    231a:	89 c2                	mov    %eax,%edx
    231c:	8b 45 08             	mov    0x8(%ebp),%eax
    231f:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    2321:	8b 45 08             	mov    0x8(%ebp),%eax
    2324:	8b 00                	mov    (%eax),%eax
}
    2326:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2329:	5b                   	pop    %ebx
    232a:	5e                   	pop    %esi
    232b:	5f                   	pop    %edi
    232c:	5d                   	pop    %ebp
    232d:	c3                   	ret    

0000232e <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    232e:	55                   	push   %ebp
    232f:	89 e5                	mov    %esp,%ebp
    2331:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    2334:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    233b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2342:	8b 45 08             	mov    0x8(%ebp),%eax
    2345:	8b 40 18             	mov    0x18(%eax),%eax
    2348:	ff 75 1c             	pushl  0x1c(%ebp)
    234b:	ff 75 18             	pushl  0x18(%ebp)
    234e:	ff 75 1c             	pushl  0x1c(%ebp)
    2351:	ff 75 18             	pushl  0x18(%ebp)
    2354:	8b 55 08             	mov    0x8(%ebp),%edx
    2357:	ff 72 10             	pushl  0x10(%edx)
    235a:	ff 72 0c             	pushl  0xc(%edx)
    235d:	ff 75 f4             	pushl  -0xc(%ebp)
    2360:	ff 75 f0             	pushl  -0x10(%ebp)
    2363:	ff 75 14             	pushl  0x14(%ebp)
    2366:	ff 75 10             	pushl  0x10(%ebp)
    2369:	ff 75 0c             	pushl  0xc(%ebp)
    236c:	50                   	push   %eax
    236d:	e8 d5 07 00 00       	call   2b47 <drawBitmap>
    2372:	83 c4 30             	add    $0x30,%esp
    return 0;
    2375:	b8 00 00 00 00       	mov    $0x0,%eax
}
    237a:	c9                   	leave  
    237b:	c3                   	ret    

0000237c <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    237c:	55                   	push   %ebp
    237d:	89 e5                	mov    %esp,%ebp
    237f:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    2382:	8b 45 08             	mov    0x8(%ebp),%eax
    2385:	8b 40 18             	mov    0x18(%eax),%eax
    2388:	ff 75 2c             	pushl  0x2c(%ebp)
    238b:	ff 75 28             	pushl  0x28(%ebp)
    238e:	ff 75 24             	pushl  0x24(%ebp)
    2391:	ff 75 20             	pushl  0x20(%ebp)
    2394:	8b 55 08             	mov    0x8(%ebp),%edx
    2397:	ff 72 10             	pushl  0x10(%edx)
    239a:	ff 72 0c             	pushl  0xc(%edx)
    239d:	ff 75 1c             	pushl  0x1c(%ebp)
    23a0:	ff 75 18             	pushl  0x18(%ebp)
    23a3:	ff 75 14             	pushl  0x14(%ebp)
    23a6:	ff 75 10             	pushl  0x10(%ebp)
    23a9:	ff 75 0c             	pushl  0xc(%ebp)
    23ac:	50                   	push   %eax
    23ad:	e8 95 07 00 00       	call   2b47 <drawBitmap>
    23b2:	83 c4 30             	add    $0x30,%esp
    return 0;
    23b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    23ba:	c9                   	leave  
    23bb:	c3                   	ret    

000023bc <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    23bc:	55                   	push   %ebp
    23bd:	89 e5                	mov    %esp,%ebp
    23bf:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    23c2:	8b 45 08             	mov    0x8(%ebp),%eax
    23c5:	8b 40 18             	mov    0x18(%eax),%eax
    23c8:	ff 75 2c             	pushl  0x2c(%ebp)
    23cb:	ff 75 28             	pushl  0x28(%ebp)
    23ce:	ff 75 24             	pushl  0x24(%ebp)
    23d1:	ff 75 20             	pushl  0x20(%ebp)
    23d4:	8b 55 08             	mov    0x8(%ebp),%edx
    23d7:	ff 72 10             	pushl  0x10(%edx)
    23da:	ff 72 0c             	pushl  0xc(%edx)
    23dd:	ff 75 1c             	pushl  0x1c(%ebp)
    23e0:	ff 75 18             	pushl  0x18(%ebp)
    23e3:	ff 75 14             	pushl  0x14(%ebp)
    23e6:	ff 75 10             	pushl  0x10(%ebp)
    23e9:	ff 75 0c             	pushl  0xc(%ebp)
    23ec:	50                   	push   %eax
    23ed:	e8 75 08 00 00       	call   2c67 <drawTransparentBitmap>
    23f2:	83 c4 30             	add    $0x30,%esp
    return 0;
    23f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    23fa:	c9                   	leave  
    23fb:	c3                   	ret    

000023fc <api_repaint>:

int api_repaint(Window* wnd)
{
    23fc:	55                   	push   %ebp
    23fd:	89 e5                	mov    %esp,%ebp
    23ff:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    2402:	8b 45 08             	mov    0x8(%ebp),%eax
    2405:	8b 00                	mov    (%eax),%eax
    2407:	83 ec 0c             	sub    $0xc,%esp
    240a:	50                   	push   %eax
    240b:	e8 4e f0 ff ff       	call   145e <repaintwindow>
    2410:	83 c4 10             	add    $0x10,%esp
    return 0;
    2413:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2418:	c9                   	leave  
    2419:	c3                   	ret    

0000241a <api_update>:

int api_update(Window* wnd, Rect rect)
{
    241a:	55                   	push   %ebp
    241b:	89 e5                	mov    %esp,%ebp
    241d:	56                   	push   %esi
    241e:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    241f:	8b 75 18             	mov    0x18(%ebp),%esi
    2422:	8b 5d 14             	mov    0x14(%ebp),%ebx
    2425:	8b 4d 10             	mov    0x10(%ebp),%ecx
    2428:	8b 55 0c             	mov    0xc(%ebp),%edx
    242b:	8b 45 08             	mov    0x8(%ebp),%eax
    242e:	8b 00                	mov    (%eax),%eax
    2430:	83 ec 0c             	sub    $0xc,%esp
    2433:	56                   	push   %esi
    2434:	53                   	push   %ebx
    2435:	51                   	push   %ecx
    2436:	52                   	push   %edx
    2437:	50                   	push   %eax
    2438:	e8 39 f0 ff ff       	call   1476 <updatewindow>
    243d:	83 c4 20             	add    $0x20,%esp
    return 0;
    2440:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2445:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2448:	5b                   	pop    %ebx
    2449:	5e                   	pop    %esi
    244a:	5d                   	pop    %ebp
    244b:	c3                   	ret    

0000244c <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    244c:	55                   	push   %ebp
    244d:	89 e5                	mov    %esp,%ebp
    244f:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    2452:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    2459:	8b 45 08             	mov    0x8(%ebp),%eax
    245c:	8b 00                	mov    (%eax),%eax
    245e:	83 ec 08             	sub    $0x8,%esp
    2461:	8d 55 c8             	lea    -0x38(%ebp),%edx
    2464:	52                   	push   %edx
    2465:	50                   	push   %eax
    2466:	e8 fb ef ff ff       	call   1466 <getmessage>
    246b:	83 c4 10             	add    $0x10,%esp
    246e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    2471:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2475:	74 e2                	je     2459 <api_exec+0xd>
        {
            pf(&msg);
    2477:	83 ec 0c             	sub    $0xc,%esp
    247a:	8d 45 c8             	lea    -0x38(%ebp),%eax
    247d:	50                   	push   %eax
    247e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2481:	ff d0                	call   *%eax
    2483:	83 c4 10             	add    $0x10,%esp
        }
    }
    2486:	eb d1                	jmp    2459 <api_exec+0xd>

00002488 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    2488:	55                   	push   %ebp
    2489:	89 e5                	mov    %esp,%ebp
    248b:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    248e:	8b 45 08             	mov    0x8(%ebp),%eax
    2491:	8b 00                	mov    (%eax),%eax
    2493:	83 ec 08             	sub    $0x8,%esp
    2496:	ff 75 0c             	pushl  0xc(%ebp)
    2499:	50                   	push   %eax
    249a:	e8 cf ef ff ff       	call   146e <settimer>
    249f:	83 c4 10             	add    $0x10,%esp
    return 0;
    24a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    24a7:	c9                   	leave  
    24a8:	c3                   	ret    

000024a9 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    24a9:	55                   	push   %ebp
    24aa:	89 e5                	mov    %esp,%ebp
    24ac:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    24af:	8b 45 08             	mov    0x8(%ebp),%eax
    24b2:	8b 50 18             	mov    0x18(%eax),%edx
    24b5:	ff 75 18             	pushl  0x18(%ebp)
    24b8:	ff 75 14             	pushl  0x14(%ebp)
    24bb:	83 ec 04             	sub    $0x4,%esp
    24be:	89 e0                	mov    %esp,%eax
    24c0:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    24c4:	66 89 08             	mov    %cx,(%eax)
    24c7:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    24cb:	88 48 02             	mov    %cl,0x2(%eax)
    24ce:	8b 45 08             	mov    0x8(%ebp),%eax
    24d1:	ff 70 10             	pushl  0x10(%eax)
    24d4:	ff 70 0c             	pushl  0xc(%eax)
    24d7:	ff 75 10             	pushl  0x10(%ebp)
    24da:	ff 75 0c             	pushl  0xc(%ebp)
    24dd:	52                   	push   %edx
    24de:	e8 6f 04 00 00       	call   2952 <drawRect>
    24e3:	83 c4 20             	add    $0x20,%esp
    return 0;
    24e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    24eb:	c9                   	leave  
    24ec:	c3                   	ret    

000024ed <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    24ed:	55                   	push   %ebp
    24ee:	89 e5                	mov    %esp,%ebp
    24f0:	83 ec 28             	sub    $0x28,%esp
    24f3:	8b 45 14             	mov    0x14(%ebp),%eax
    24f6:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    24f9:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    24fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    2500:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2503:	8b 45 10             	mov    0x10(%ebp),%eax
    2506:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2509:	8b 45 08             	mov    0x8(%ebp),%eax
    250c:	8b 40 18             	mov    0x18(%eax),%eax
    250f:	83 ec 04             	sub    $0x4,%esp
    2512:	ff 75 18             	pushl  0x18(%ebp)
    2515:	52                   	push   %edx
    2516:	8b 55 08             	mov    0x8(%ebp),%edx
    2519:	ff 72 10             	pushl  0x10(%edx)
    251c:	ff 72 0c             	pushl  0xc(%edx)
    251f:	ff 75 f4             	pushl  -0xc(%ebp)
    2522:	ff 75 f0             	pushl  -0x10(%ebp)
    2525:	50                   	push   %eax
    2526:	e8 d4 02 00 00       	call   27ff <drawCharacter>
    252b:	83 c4 20             	add    $0x20,%esp
    return 0;
    252e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2533:	c9                   	leave  
    2534:	c3                   	ret    

00002535 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    2535:	55                   	push   %ebp
    2536:	89 e5                	mov    %esp,%ebp
    2538:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    253b:	8b 45 0c             	mov    0xc(%ebp),%eax
    253e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2541:	8b 45 10             	mov    0x10(%ebp),%eax
    2544:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2547:	8b 45 08             	mov    0x8(%ebp),%eax
    254a:	8b 40 18             	mov    0x18(%eax),%eax
    254d:	83 ec 04             	sub    $0x4,%esp
    2550:	ff 75 18             	pushl  0x18(%ebp)
    2553:	ff 75 14             	pushl  0x14(%ebp)
    2556:	8b 55 08             	mov    0x8(%ebp),%edx
    2559:	ff 72 10             	pushl  0x10(%edx)
    255c:	ff 72 0c             	pushl  0xc(%edx)
    255f:	ff 75 f4             	pushl  -0xc(%ebp)
    2562:	ff 75 f0             	pushl  -0x10(%ebp)
    2565:	50                   	push   %eax
    2566:	e8 8e 03 00 00       	call   28f9 <drawString>
    256b:	83 c4 20             	add    $0x20,%esp
    return 0;
    256e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2573:	c9                   	leave  
    2574:	c3                   	ret    

00002575 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    2575:	55                   	push   %ebp
    2576:	89 e5                	mov    %esp,%ebp
    2578:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    257b:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    257f:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    2583:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    2587:	83 ec 08             	sub    $0x8,%esp
    258a:	83 ec 04             	sub    $0x4,%esp
    258d:	89 e0                	mov    %esp,%eax
    258f:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    2593:	66 89 10             	mov    %dx,(%eax)
    2596:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    259a:	88 50 02             	mov    %dl,0x2(%eax)
    259d:	ff 75 18             	pushl  0x18(%ebp)
    25a0:	ff 75 14             	pushl  0x14(%ebp)
    25a3:	ff 75 10             	pushl  0x10(%ebp)
    25a6:	ff 75 0c             	pushl  0xc(%ebp)
    25a9:	ff 75 08             	pushl  0x8(%ebp)
    25ac:	e8 f8 fe ff ff       	call   24a9 <api_drawRect>
    25b1:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    25b4:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    25b8:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    25bc:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    25c0:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    25c4:	8b 45 10             	mov    0x10(%ebp),%eax
    25c7:	8d 50 0a             	lea    0xa(%eax),%edx
    25ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    25cd:	83 c0 0a             	add    $0xa,%eax
    25d0:	83 ec 0c             	sub    $0xc,%esp
    25d3:	ff 75 f4             	pushl  -0xc(%ebp)
    25d6:	ff 75 1c             	pushl  0x1c(%ebp)
    25d9:	52                   	push   %edx
    25da:	50                   	push   %eax
    25db:	ff 75 08             	pushl  0x8(%ebp)
    25de:	e8 52 ff ff ff       	call   2535 <api_drawString>
    25e3:	83 c4 20             	add    $0x20,%esp
    return 0;
    25e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    25eb:	c9                   	leave  
    25ec:	c3                   	ret    

000025ed <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    25ed:	55                   	push   %ebp
    25ee:	89 e5                	mov    %esp,%ebp
    25f0:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    25f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    25fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2601:	8b 45 08             	mov    0x8(%ebp),%eax
    2604:	8b 40 18             	mov    0x18(%eax),%eax
    2607:	ff 75 1c             	pushl  0x1c(%ebp)
    260a:	ff 75 18             	pushl  0x18(%ebp)
    260d:	ff 75 1c             	pushl  0x1c(%ebp)
    2610:	ff 75 18             	pushl  0x18(%ebp)
    2613:	8b 55 08             	mov    0x8(%ebp),%edx
    2616:	ff 72 10             	pushl  0x10(%edx)
    2619:	ff 72 0c             	pushl  0xc(%edx)
    261c:	ff 75 f4             	pushl  -0xc(%ebp)
    261f:	ff 75 f0             	pushl  -0x10(%ebp)
    2622:	ff 75 14             	pushl  0x14(%ebp)
    2625:	ff 75 10             	pushl  0x10(%ebp)
    2628:	ff 75 0c             	pushl  0xc(%ebp)
    262b:	50                   	push   %eax
    262c:	e8 16 05 00 00       	call   2b47 <drawBitmap>
    2631:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    2634:	8b 45 08             	mov    0x8(%ebp),%eax
    2637:	8b 40 18             	mov    0x18(%eax),%eax
    263a:	ff 75 28             	pushl  0x28(%ebp)
    263d:	ff 75 1c             	pushl  0x1c(%ebp)
    2640:	ff 75 18             	pushl  0x18(%ebp)
    2643:	8b 55 08             	mov    0x8(%ebp),%edx
    2646:	ff 72 10             	pushl  0x10(%edx)
    2649:	ff 72 0c             	pushl  0xc(%edx)
    264c:	ff 75 14             	pushl  0x14(%ebp)
    264f:	ff 75 10             	pushl  0x10(%ebp)
    2652:	50                   	push   %eax
    2653:	e8 99 07 00 00       	call   2df1 <colorShift>
    2658:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    265b:	8b 45 08             	mov    0x8(%ebp),%eax
    265e:	8b 50 18             	mov    0x18(%eax),%edx
    2661:	83 ec 0c             	sub    $0xc,%esp
    2664:	ff 75 20             	pushl  0x20(%ebp)
    2667:	ff 75 1c             	pushl  0x1c(%ebp)
    266a:	ff 75 18             	pushl  0x18(%ebp)
    266d:	83 ec 04             	sub    $0x4,%esp
    2670:	89 e0                	mov    %esp,%eax
    2672:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    2676:	66 89 08             	mov    %cx,(%eax)
    2679:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    267d:	88 48 02             	mov    %cl,0x2(%eax)
    2680:	8b 45 08             	mov    0x8(%ebp),%eax
    2683:	ff 70 10             	pushl  0x10(%eax)
    2686:	ff 70 0c             	pushl  0xc(%eax)
    2689:	ff 75 14             	pushl  0x14(%ebp)
    268c:	ff 75 10             	pushl  0x10(%ebp)
    268f:	52                   	push   %edx
    2690:	e8 6d 03 00 00       	call   2a02 <drawBorder>
    2695:	83 c4 30             	add    $0x30,%esp
    return 0;
    2698:	b8 00 00 00 00       	mov    $0x0,%eax
}
    269d:	c9                   	leave  
    269e:	c3                   	ret    

0000269f <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    269f:	55                   	push   %ebp
    26a0:	89 e5                	mov    %esp,%ebp
    26a2:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    26a5:	8b 45 08             	mov    0x8(%ebp),%eax
    26a8:	8b 00                	mov    (%eax),%eax
    26aa:	83 ec 0c             	sub    $0xc,%esp
    26ad:	50                   	push   %eax
    26ae:	e8 cb ed ff ff       	call   147e <destroywindow>
    26b3:	83 c4 10             	add    $0x10,%esp
    return 0;
    26b6:	b8 00 00 00 00       	mov    $0x0,%eax
    26bb:	c9                   	leave  
    26bc:	c3                   	ret    

000026bd <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    26bd:	55                   	push   %ebp
    26be:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    26c0:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    26c4:	8b 45 08             	mov    0x8(%ebp),%eax
    26c7:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    26ca:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    26ce:	8b 45 08             	mov    0x8(%ebp),%eax
    26d1:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    26d4:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    26d8:	8b 45 08             	mov    0x8(%ebp),%eax
    26db:	88 10                	mov    %dl,(%eax)
}
    26dd:	90                   	nop
    26de:	5d                   	pop    %ebp
    26df:	c3                   	ret    

000026e0 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    26e0:	55                   	push   %ebp
    26e1:	89 e5                	mov    %esp,%ebp
    26e3:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    26e6:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    26ea:	3c ff                	cmp    $0xff,%al
    26ec:	75 22                	jne    2710 <drawPointAlpha+0x30>
        color->R = origin.R;
    26ee:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    26f2:	8b 45 08             	mov    0x8(%ebp),%eax
    26f5:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    26f8:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    26fc:	8b 45 08             	mov    0x8(%ebp),%eax
    26ff:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    2702:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    2706:	8b 45 08             	mov    0x8(%ebp),%eax
    2709:	88 10                	mov    %dl,(%eax)
        return;
    270b:	e9 ed 00 00 00       	jmp    27fd <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    2710:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    2714:	84 c0                	test   %al,%al
    2716:	0f 84 e0 00 00 00    	je     27fc <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    271c:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    2720:	0f b6 c0             	movzbl %al,%eax
    2723:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2727:	df 45 e4             	fild   -0x1c(%ebp)
    272a:	d9 05 60 ad 01 00    	flds   0x1ad60
    2730:	de f9                	fdivrp %st,%st(1)
    2732:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    2735:	8b 45 08             	mov    0x8(%ebp),%eax
    2738:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    273c:	0f b6 c0             	movzbl %al,%eax
    273f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2742:	db 45 e4             	fildl  -0x1c(%ebp)
    2745:	d9 e8                	fld1   
    2747:	d8 65 fc             	fsubs  -0x4(%ebp)
    274a:	de c9                	fmulp  %st,%st(1)
    274c:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    2750:	0f b6 c0             	movzbl %al,%eax
    2753:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2756:	db 45 e4             	fildl  -0x1c(%ebp)
    2759:	d8 4d fc             	fmuls  -0x4(%ebp)
    275c:	de c1                	faddp  %st,%st(1)
    275e:	d9 7d ee             	fnstcw -0x12(%ebp)
    2761:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2765:	b4 0c                	mov    $0xc,%ah
    2767:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    276b:	d9 6d ec             	fldcw  -0x14(%ebp)
    276e:	df 5d ea             	fistp  -0x16(%ebp)
    2771:	d9 6d ee             	fldcw  -0x12(%ebp)
    2774:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    2778:	89 c2                	mov    %eax,%edx
    277a:	8b 45 08             	mov    0x8(%ebp),%eax
    277d:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    2780:	8b 45 08             	mov    0x8(%ebp),%eax
    2783:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2787:	0f b6 c0             	movzbl %al,%eax
    278a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    278d:	db 45 e4             	fildl  -0x1c(%ebp)
    2790:	d9 e8                	fld1   
    2792:	d8 65 fc             	fsubs  -0x4(%ebp)
    2795:	de c9                	fmulp  %st,%st(1)
    2797:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    279b:	0f b6 c0             	movzbl %al,%eax
    279e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    27a1:	db 45 e4             	fildl  -0x1c(%ebp)
    27a4:	d8 4d fc             	fmuls  -0x4(%ebp)
    27a7:	de c1                	faddp  %st,%st(1)
    27a9:	d9 6d ec             	fldcw  -0x14(%ebp)
    27ac:	df 5d ea             	fistp  -0x16(%ebp)
    27af:	d9 6d ee             	fldcw  -0x12(%ebp)
    27b2:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    27b6:	89 c2                	mov    %eax,%edx
    27b8:	8b 45 08             	mov    0x8(%ebp),%eax
    27bb:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    27be:	8b 45 08             	mov    0x8(%ebp),%eax
    27c1:	0f b6 00             	movzbl (%eax),%eax
    27c4:	0f b6 c0             	movzbl %al,%eax
    27c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    27ca:	db 45 e4             	fildl  -0x1c(%ebp)
    27cd:	d9 e8                	fld1   
    27cf:	d8 65 fc             	fsubs  -0x4(%ebp)
    27d2:	de c9                	fmulp  %st,%st(1)
    27d4:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    27d8:	0f b6 c0             	movzbl %al,%eax
    27db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    27de:	db 45 e4             	fildl  -0x1c(%ebp)
    27e1:	d8 4d fc             	fmuls  -0x4(%ebp)
    27e4:	de c1                	faddp  %st,%st(1)
    27e6:	d9 6d ec             	fldcw  -0x14(%ebp)
    27e9:	df 5d ea             	fistp  -0x16(%ebp)
    27ec:	d9 6d ee             	fldcw  -0x12(%ebp)
    27ef:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    27f3:	89 c2                	mov    %eax,%edx
    27f5:	8b 45 08             	mov    0x8(%ebp),%eax
    27f8:	88 10                	mov    %dl,(%eax)
    27fa:	eb 01                	jmp    27fd <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    27fc:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    27fd:	c9                   	leave  
    27fe:	c3                   	ret    

000027ff <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    27ff:	55                   	push   %ebp
    2800:	89 e5                	mov    %esp,%ebp
    2802:	83 ec 14             	sub    $0x14,%esp
    2805:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2808:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    280b:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    280f:	83 e8 20             	sub    $0x20,%eax
    2812:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    2815:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2819:	0f 88 d7 00 00 00    	js     28f6 <drawCharacter+0xf7>
    281f:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    2823:	0f 8f cd 00 00 00    	jg     28f6 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    2829:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2830:	e9 b5 00 00 00       	jmp    28ea <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    2835:	8b 55 10             	mov    0x10(%ebp),%edx
    2838:	8b 45 fc             	mov    -0x4(%ebp),%eax
    283b:	01 c2                	add    %eax,%edx
    283d:	8b 45 14             	mov    0x14(%ebp),%eax
    2840:	39 c2                	cmp    %eax,%edx
    2842:	0f 8f af 00 00 00    	jg     28f7 <drawCharacter+0xf8>
    2848:	8b 55 10             	mov    0x10(%ebp),%edx
    284b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    284e:	01 d0                	add    %edx,%eax
    2850:	85 c0                	test   %eax,%eax
    2852:	0f 88 9f 00 00 00    	js     28f7 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    2858:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    285f:	eb 7b                	jmp    28dc <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    2861:	8b 55 fc             	mov    -0x4(%ebp),%edx
    2864:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    2867:	89 d0                	mov    %edx,%eax
    2869:	c1 e0 03             	shl    $0x3,%eax
    286c:	01 d0                	add    %edx,%eax
    286e:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    2874:	01 c2                	add    %eax,%edx
    2876:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2879:	01 d0                	add    %edx,%eax
    287b:	05 40 71 01 00       	add    $0x17140,%eax
    2880:	0f b6 00             	movzbl (%eax),%eax
    2883:	3c 01                	cmp    $0x1,%al
    2885:	75 51                	jne    28d8 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    2887:	8b 55 0c             	mov    0xc(%ebp),%edx
    288a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    288d:	01 c2                	add    %eax,%edx
    288f:	8b 45 18             	mov    0x18(%ebp),%eax
    2892:	39 c2                	cmp    %eax,%edx
    2894:	7f 50                	jg     28e6 <drawCharacter+0xe7>
    2896:	8b 55 0c             	mov    0xc(%ebp),%edx
    2899:	8b 45 f8             	mov    -0x8(%ebp),%eax
    289c:	01 d0                	add    %edx,%eax
    289e:	85 c0                	test   %eax,%eax
    28a0:	78 44                	js     28e6 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    28a2:	8b 55 10             	mov    0x10(%ebp),%edx
    28a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    28a8:	01 c2                	add    %eax,%edx
    28aa:	8b 45 18             	mov    0x18(%ebp),%eax
    28ad:	0f af c2             	imul   %edx,%eax
    28b0:	89 c2                	mov    %eax,%edx
    28b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    28b5:	01 c2                	add    %eax,%edx
    28b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    28ba:	01 c2                	add    %eax,%edx
    28bc:	89 d0                	mov    %edx,%eax
    28be:	01 c0                	add    %eax,%eax
    28c0:	01 c2                	add    %eax,%edx
    28c2:	8b 45 08             	mov    0x8(%ebp),%eax
    28c5:	01 d0                	add    %edx,%eax
    28c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    28ca:	ff 75 20             	pushl  0x20(%ebp)
    28cd:	ff 75 f0             	pushl  -0x10(%ebp)
    28d0:	e8 0b fe ff ff       	call   26e0 <drawPointAlpha>
    28d5:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    28d8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    28dc:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    28e0:	0f 8e 7b ff ff ff    	jle    2861 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    28e6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    28ea:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    28ee:	0f 8e 41 ff ff ff    	jle    2835 <drawCharacter+0x36>
    28f4:	eb 01                	jmp    28f7 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    28f6:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    28f7:	c9                   	leave  
    28f8:	c3                   	ret    

000028f9 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    28f9:	55                   	push   %ebp
    28fa:	89 e5                	mov    %esp,%ebp
    28fc:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    28ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    2906:	eb 3d                	jmp    2945 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    2908:	8b 45 1c             	mov    0x1c(%ebp),%eax
    290b:	0f b6 00             	movzbl (%eax),%eax
    290e:	0f be c0             	movsbl %al,%eax
    2911:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2914:	8b 55 fc             	mov    -0x4(%ebp),%edx
    2917:	01 ca                	add    %ecx,%edx
    2919:	89 55 f4             	mov    %edx,-0xc(%ebp)
    291c:	8b 55 10             	mov    0x10(%ebp),%edx
    291f:	89 55 f8             	mov    %edx,-0x8(%ebp)
    2922:	ff 75 20             	pushl  0x20(%ebp)
    2925:	50                   	push   %eax
    2926:	ff 75 18             	pushl  0x18(%ebp)
    2929:	ff 75 14             	pushl  0x14(%ebp)
    292c:	ff 75 f8             	pushl  -0x8(%ebp)
    292f:	ff 75 f4             	pushl  -0xc(%ebp)
    2932:	ff 75 08             	pushl  0x8(%ebp)
    2935:	e8 c5 fe ff ff       	call   27ff <drawCharacter>
    293a:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    293d:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    2941:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    2945:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2948:	0f b6 00             	movzbl (%eax),%eax
    294b:	84 c0                	test   %al,%al
    294d:	75 b9                	jne    2908 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    294f:	90                   	nop
    2950:	c9                   	leave  
    2951:	c3                   	ret    

00002952 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    2952:	55                   	push   %ebp
    2953:	89 e5                	mov    %esp,%ebp
    2955:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    2958:	8b 45 20             	mov    0x20(%ebp),%eax
    295b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    295e:	8b 45 24             	mov    0x24(%ebp),%eax
    2961:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    2964:	8b 55 14             	mov    0x14(%ebp),%edx
    2967:	8b 45 10             	mov    0x10(%ebp),%eax
    296a:	29 c2                	sub    %eax,%edx
    296c:	89 d0                	mov    %edx,%eax
    296e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2971:	7d 0d                	jge    2980 <drawRect+0x2e>
        draw_h = s.h - p.y;
    2973:	8b 55 14             	mov    0x14(%ebp),%edx
    2976:	8b 45 10             	mov    0x10(%ebp),%eax
    2979:	29 c2                	sub    %eax,%edx
    297b:	89 d0                	mov    %edx,%eax
    297d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    2980:	8b 55 18             	mov    0x18(%ebp),%edx
    2983:	8b 45 0c             	mov    0xc(%ebp),%eax
    2986:	29 c2                	sub    %eax,%edx
    2988:	89 d0                	mov    %edx,%eax
    298a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    298d:	7d 0d                	jge    299c <drawRect+0x4a>
        draw_w = s.w - p.x;
    298f:	8b 55 18             	mov    0x18(%ebp),%edx
    2992:	8b 45 0c             	mov    0xc(%ebp),%eax
    2995:	29 c2                	sub    %eax,%edx
    2997:	89 d0                	mov    %edx,%eax
    2999:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    299c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    29a3:	eb 52                	jmp    29f7 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    29a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    29ac:	eb 3d                	jmp    29eb <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    29ae:	8b 55 10             	mov    0x10(%ebp),%edx
    29b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    29b4:	01 c2                	add    %eax,%edx
    29b6:	8b 45 18             	mov    0x18(%ebp),%eax
    29b9:	0f af c2             	imul   %edx,%eax
    29bc:	89 c2                	mov    %eax,%edx
    29be:	8b 45 0c             	mov    0xc(%ebp),%eax
    29c1:	01 c2                	add    %eax,%edx
    29c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    29c6:	01 c2                	add    %eax,%edx
    29c8:	89 d0                	mov    %edx,%eax
    29ca:	01 c0                	add    %eax,%eax
    29cc:	01 c2                	add    %eax,%edx
    29ce:	8b 45 08             	mov    0x8(%ebp),%eax
    29d1:	01 d0                	add    %edx,%eax
    29d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    29d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    29d9:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    29dd:	66 89 10             	mov    %dx,(%eax)
    29e0:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    29e4:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    29e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    29eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    29ee:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    29f1:	7c bb                	jl     29ae <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    29f3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    29f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    29fa:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    29fd:	7c a6                	jl     29a5 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    29ff:	90                   	nop
    2a00:	c9                   	leave  
    2a01:	c3                   	ret    

00002a02 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    2a02:	55                   	push   %ebp
    2a03:	89 e5                	mov    %esp,%ebp
    2a05:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    2a08:	8b 45 28             	mov    0x28(%ebp),%eax
    2a0b:	89 45 c8             	mov    %eax,-0x38(%ebp)
    2a0e:	8b 45 24             	mov    0x24(%ebp),%eax
    2a11:	89 45 cc             	mov    %eax,-0x34(%ebp)
    2a14:	ff 75 cc             	pushl  -0x34(%ebp)
    2a17:	ff 75 c8             	pushl  -0x38(%ebp)
    2a1a:	83 ec 04             	sub    $0x4,%esp
    2a1d:	89 e0                	mov    %esp,%eax
    2a1f:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2a23:	66 89 10             	mov    %dx,(%eax)
    2a26:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2a2a:	88 50 02             	mov    %dl,0x2(%eax)
    2a2d:	ff 75 18             	pushl  0x18(%ebp)
    2a30:	ff 75 14             	pushl  0x14(%ebp)
    2a33:	ff 75 10             	pushl  0x10(%ebp)
    2a36:	ff 75 0c             	pushl  0xc(%ebp)
    2a39:	ff 75 08             	pushl  0x8(%ebp)
    2a3c:	e8 11 ff ff ff       	call   2952 <drawRect>
    2a41:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    2a44:	8b 45 28             	mov    0x28(%ebp),%eax
    2a47:	89 45 d0             	mov    %eax,-0x30(%ebp)
    2a4a:	8b 45 24             	mov    0x24(%ebp),%eax
    2a4d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    2a50:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a53:	89 45 d8             	mov    %eax,-0x28(%ebp)
    2a56:	8b 55 10             	mov    0x10(%ebp),%edx
    2a59:	8b 45 20             	mov    0x20(%ebp),%eax
    2a5c:	01 d0                	add    %edx,%eax
    2a5e:	2b 45 28             	sub    0x28(%ebp),%eax
    2a61:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2a64:	ff 75 d4             	pushl  -0x2c(%ebp)
    2a67:	ff 75 d0             	pushl  -0x30(%ebp)
    2a6a:	83 ec 04             	sub    $0x4,%esp
    2a6d:	89 e0                	mov    %esp,%eax
    2a6f:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2a73:	66 89 10             	mov    %dx,(%eax)
    2a76:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2a7a:	88 50 02             	mov    %dl,0x2(%eax)
    2a7d:	ff 75 18             	pushl  0x18(%ebp)
    2a80:	ff 75 14             	pushl  0x14(%ebp)
    2a83:	ff 75 dc             	pushl  -0x24(%ebp)
    2a86:	ff 75 d8             	pushl  -0x28(%ebp)
    2a89:	ff 75 08             	pushl  0x8(%ebp)
    2a8c:	e8 c1 fe ff ff       	call   2952 <drawRect>
    2a91:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    2a94:	8b 45 20             	mov    0x20(%ebp),%eax
    2a97:	8b 55 28             	mov    0x28(%ebp),%edx
    2a9a:	01 d2                	add    %edx,%edx
    2a9c:	29 d0                	sub    %edx,%eax
    2a9e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2aa1:	8b 45 28             	mov    0x28(%ebp),%eax
    2aa4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2aa7:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
    2aad:	8b 55 10             	mov    0x10(%ebp),%edx
    2ab0:	8b 45 28             	mov    0x28(%ebp),%eax
    2ab3:	01 d0                	add    %edx,%eax
    2ab5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2ab8:	ff 75 e4             	pushl  -0x1c(%ebp)
    2abb:	ff 75 e0             	pushl  -0x20(%ebp)
    2abe:	83 ec 04             	sub    $0x4,%esp
    2ac1:	89 e0                	mov    %esp,%eax
    2ac3:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2ac7:	66 89 10             	mov    %dx,(%eax)
    2aca:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2ace:	88 50 02             	mov    %dl,0x2(%eax)
    2ad1:	ff 75 18             	pushl  0x18(%ebp)
    2ad4:	ff 75 14             	pushl  0x14(%ebp)
    2ad7:	ff 75 ec             	pushl  -0x14(%ebp)
    2ada:	ff 75 e8             	pushl  -0x18(%ebp)
    2add:	ff 75 08             	pushl  0x8(%ebp)
    2ae0:	e8 6d fe ff ff       	call   2952 <drawRect>
    2ae5:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    2ae8:	8b 45 20             	mov    0x20(%ebp),%eax
    2aeb:	8b 55 28             	mov    0x28(%ebp),%edx
    2aee:	01 d2                	add    %edx,%edx
    2af0:	29 d0                	sub    %edx,%eax
    2af2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2af5:	8b 45 28             	mov    0x28(%ebp),%eax
    2af8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2afb:	8b 55 0c             	mov    0xc(%ebp),%edx
    2afe:	8b 45 24             	mov    0x24(%ebp),%eax
    2b01:	01 d0                	add    %edx,%eax
    2b03:	2b 45 28             	sub    0x28(%ebp),%eax
    2b06:	89 45 f8             	mov    %eax,-0x8(%ebp)
    2b09:	8b 55 10             	mov    0x10(%ebp),%edx
    2b0c:	8b 45 28             	mov    0x28(%ebp),%eax
    2b0f:	01 d0                	add    %edx,%eax
    2b11:	89 45 fc             	mov    %eax,-0x4(%ebp)
    2b14:	ff 75 f4             	pushl  -0xc(%ebp)
    2b17:	ff 75 f0             	pushl  -0x10(%ebp)
    2b1a:	83 ec 04             	sub    $0x4,%esp
    2b1d:	89 e0                	mov    %esp,%eax
    2b1f:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2b23:	66 89 10             	mov    %dx,(%eax)
    2b26:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2b2a:	88 50 02             	mov    %dl,0x2(%eax)
    2b2d:	ff 75 18             	pushl  0x18(%ebp)
    2b30:	ff 75 14             	pushl  0x14(%ebp)
    2b33:	ff 75 fc             	pushl  -0x4(%ebp)
    2b36:	ff 75 f8             	pushl  -0x8(%ebp)
    2b39:	ff 75 08             	pushl  0x8(%ebp)
    2b3c:	e8 11 fe ff ff       	call   2952 <drawRect>
    2b41:	83 c4 20             	add    $0x20,%esp
}
    2b44:	90                   	nop
    2b45:	c9                   	leave  
    2b46:	c3                   	ret    

00002b47 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    2b47:	55                   	push   %ebp
    2b48:	89 e5                	mov    %esp,%ebp
    2b4a:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    2b4d:	8b 45 30             	mov    0x30(%ebp),%eax
    2b50:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    2b53:	8b 45 34             	mov    0x34(%ebp),%eax
    2b56:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    2b59:	8b 55 20             	mov    0x20(%ebp),%edx
    2b5c:	8b 45 14             	mov    0x14(%ebp),%eax
    2b5f:	29 c2                	sub    %eax,%edx
    2b61:	89 d0                	mov    %edx,%eax
    2b63:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2b66:	7d 0d                	jge    2b75 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    2b68:	8b 55 20             	mov    0x20(%ebp),%edx
    2b6b:	8b 45 14             	mov    0x14(%ebp),%eax
    2b6e:	29 c2                	sub    %eax,%edx
    2b70:	89 d0                	mov    %edx,%eax
    2b72:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    2b75:	8b 55 28             	mov    0x28(%ebp),%edx
    2b78:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2b7b:	29 c2                	sub    %eax,%edx
    2b7d:	89 d0                	mov    %edx,%eax
    2b7f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2b82:	7d 0d                	jge    2b91 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    2b84:	8b 55 28             	mov    0x28(%ebp),%edx
    2b87:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2b8a:	29 c2                	sub    %eax,%edx
    2b8c:	89 d0                	mov    %edx,%eax
    2b8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    2b91:	8b 55 24             	mov    0x24(%ebp),%edx
    2b94:	8b 45 10             	mov    0x10(%ebp),%eax
    2b97:	29 c2                	sub    %eax,%edx
    2b99:	89 d0                	mov    %edx,%eax
    2b9b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2b9e:	7d 0d                	jge    2bad <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    2ba0:	8b 55 24             	mov    0x24(%ebp),%edx
    2ba3:	8b 45 10             	mov    0x10(%ebp),%eax
    2ba6:	29 c2                	sub    %eax,%edx
    2ba8:	89 d0                	mov    %edx,%eax
    2baa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    2bad:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2bb0:	8b 45 18             	mov    0x18(%ebp),%eax
    2bb3:	29 c2                	sub    %eax,%edx
    2bb5:	89 d0                	mov    %edx,%eax
    2bb7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2bba:	7d 0d                	jge    2bc9 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    2bbc:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2bbf:	8b 45 18             	mov    0x18(%ebp),%eax
    2bc2:	29 c2                	sub    %eax,%edx
    2bc4:	89 d0                	mov    %edx,%eax
    2bc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2bc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2bd0:	e9 83 00 00 00       	jmp    2c58 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    2bd5:	8b 55 14             	mov    0x14(%ebp),%edx
    2bd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2bdb:	01 d0                	add    %edx,%eax
    2bdd:	85 c0                	test   %eax,%eax
    2bdf:	78 72                	js     2c53 <drawBitmap+0x10c>
    2be1:	8b 55 14             	mov    0x14(%ebp),%edx
    2be4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2be7:	01 c2                	add    %eax,%edx
    2be9:	8b 45 20             	mov    0x20(%ebp),%eax
    2bec:	39 c2                	cmp    %eax,%edx
    2bee:	7d 63                	jge    2c53 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    2bf0:	8b 55 14             	mov    0x14(%ebp),%edx
    2bf3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2bf6:	01 c2                	add    %eax,%edx
    2bf8:	8b 45 24             	mov    0x24(%ebp),%eax
    2bfb:	0f af c2             	imul   %edx,%eax
    2bfe:	89 c2                	mov    %eax,%edx
    2c00:	8b 45 10             	mov    0x10(%ebp),%eax
    2c03:	01 c2                	add    %eax,%edx
    2c05:	89 d0                	mov    %edx,%eax
    2c07:	01 c0                	add    %eax,%eax
    2c09:	01 c2                	add    %eax,%edx
    2c0b:	8b 45 08             	mov    0x8(%ebp),%eax
    2c0e:	01 d0                	add    %edx,%eax
    2c10:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    2c13:	8b 55 1c             	mov    0x1c(%ebp),%edx
    2c16:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2c19:	01 c2                	add    %eax,%edx
    2c1b:	8b 45 2c             	mov    0x2c(%ebp),%eax
    2c1e:	0f af c2             	imul   %edx,%eax
    2c21:	89 c2                	mov    %eax,%edx
    2c23:	8b 45 18             	mov    0x18(%ebp),%eax
    2c26:	01 c2                	add    %eax,%edx
    2c28:	89 d0                	mov    %edx,%eax
    2c2a:	01 c0                	add    %eax,%eax
    2c2c:	01 c2                	add    %eax,%edx
    2c2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c31:	01 d0                	add    %edx,%eax
    2c33:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    2c36:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2c39:	89 d0                	mov    %edx,%eax
    2c3b:	01 c0                	add    %eax,%eax
    2c3d:	01 d0                	add    %edx,%eax
    2c3f:	83 ec 04             	sub    $0x4,%esp
    2c42:	50                   	push   %eax
    2c43:	ff 75 e4             	pushl  -0x1c(%ebp)
    2c46:	ff 75 e8             	pushl  -0x18(%ebp)
    2c49:	e8 23 e7 ff ff       	call   1371 <memmove>
    2c4e:	83 c4 10             	add    $0x10,%esp
    2c51:	eb 01                	jmp    2c54 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    2c53:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2c54:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2c58:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2c5b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2c5e:	0f 8c 71 ff ff ff    	jl     2bd5 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    2c64:	90                   	nop
    2c65:	c9                   	leave  
    2c66:	c3                   	ret    

00002c67 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    2c67:	55                   	push   %ebp
    2c68:	89 e5                	mov    %esp,%ebp
    2c6a:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    2c6d:	8b 45 30             	mov    0x30(%ebp),%eax
    2c70:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    2c73:	8b 45 34             	mov    0x34(%ebp),%eax
    2c76:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    2c79:	8b 55 20             	mov    0x20(%ebp),%edx
    2c7c:	8b 45 14             	mov    0x14(%ebp),%eax
    2c7f:	29 c2                	sub    %eax,%edx
    2c81:	89 d0                	mov    %edx,%eax
    2c83:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2c86:	7d 0d                	jge    2c95 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    2c88:	8b 55 20             	mov    0x20(%ebp),%edx
    2c8b:	8b 45 14             	mov    0x14(%ebp),%eax
    2c8e:	29 c2                	sub    %eax,%edx
    2c90:	89 d0                	mov    %edx,%eax
    2c92:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    2c95:	8b 55 28             	mov    0x28(%ebp),%edx
    2c98:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2c9b:	29 c2                	sub    %eax,%edx
    2c9d:	89 d0                	mov    %edx,%eax
    2c9f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2ca2:	7d 0d                	jge    2cb1 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    2ca4:	8b 55 28             	mov    0x28(%ebp),%edx
    2ca7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2caa:	29 c2                	sub    %eax,%edx
    2cac:	89 d0                	mov    %edx,%eax
    2cae:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    2cb1:	8b 55 24             	mov    0x24(%ebp),%edx
    2cb4:	8b 45 10             	mov    0x10(%ebp),%eax
    2cb7:	29 c2                	sub    %eax,%edx
    2cb9:	89 d0                	mov    %edx,%eax
    2cbb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2cbe:	7d 0d                	jge    2ccd <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    2cc0:	8b 55 24             	mov    0x24(%ebp),%edx
    2cc3:	8b 45 10             	mov    0x10(%ebp),%eax
    2cc6:	29 c2                	sub    %eax,%edx
    2cc8:	89 d0                	mov    %edx,%eax
    2cca:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    2ccd:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2cd0:	8b 45 18             	mov    0x18(%ebp),%eax
    2cd3:	29 c2                	sub    %eax,%edx
    2cd5:	89 d0                	mov    %edx,%eax
    2cd7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2cda:	7d 0d                	jge    2ce9 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    2cdc:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2cdf:	8b 45 18             	mov    0x18(%ebp),%eax
    2ce2:	29 c2                	sub    %eax,%edx
    2ce4:	89 d0                	mov    %edx,%eax
    2ce6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    2ce9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2cf0:	e9 b8 00 00 00       	jmp    2dad <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    2cf5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2cfc:	e9 9c 00 00 00       	jmp    2d9d <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    2d01:	8b 55 14             	mov    0x14(%ebp),%edx
    2d04:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d07:	01 c2                	add    %eax,%edx
    2d09:	8b 45 24             	mov    0x24(%ebp),%eax
    2d0c:	0f af c2             	imul   %edx,%eax
    2d0f:	89 c2                	mov    %eax,%edx
    2d11:	8b 45 10             	mov    0x10(%ebp),%eax
    2d14:	01 c2                	add    %eax,%edx
    2d16:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2d19:	01 c2                	add    %eax,%edx
    2d1b:	89 d0                	mov    %edx,%eax
    2d1d:	01 c0                	add    %eax,%eax
    2d1f:	01 c2                	add    %eax,%edx
    2d21:	8b 45 08             	mov    0x8(%ebp),%eax
    2d24:	01 d0                	add    %edx,%eax
    2d26:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    2d29:	8b 55 1c             	mov    0x1c(%ebp),%edx
    2d2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d2f:	01 c2                	add    %eax,%edx
    2d31:	8b 45 2c             	mov    0x2c(%ebp),%eax
    2d34:	0f af c2             	imul   %edx,%eax
    2d37:	89 c2                	mov    %eax,%edx
    2d39:	8b 45 18             	mov    0x18(%ebp),%eax
    2d3c:	01 c2                	add    %eax,%edx
    2d3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2d41:	01 c2                	add    %eax,%edx
    2d43:	89 d0                	mov    %edx,%eax
    2d45:	01 c0                	add    %eax,%eax
    2d47:	01 c2                	add    %eax,%edx
    2d49:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d4c:	01 d0                	add    %edx,%eax
    2d4e:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    2d51:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d54:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2d58:	3c ff                	cmp    $0xff,%al
    2d5a:	75 15                	jne    2d71 <drawTransparentBitmap+0x10a>
    2d5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d5f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2d63:	3c ff                	cmp    $0xff,%al
    2d65:	75 0a                	jne    2d71 <drawTransparentBitmap+0x10a>
    2d67:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d6a:	0f b6 00             	movzbl (%eax),%eax
    2d6d:	3c ff                	cmp    $0xff,%al
    2d6f:	74 27                	je     2d98 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    2d71:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d74:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2d78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2d7b:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    2d7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d81:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2d85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2d88:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    2d8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d8e:	0f b6 10             	movzbl (%eax),%edx
    2d91:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2d94:	88 10                	mov    %dl,(%eax)
    2d96:	eb 01                	jmp    2d99 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    2d98:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    2d99:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2d9d:	8b 45 34             	mov    0x34(%ebp),%eax
    2da0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2da3:	0f 8f 58 ff ff ff    	jg     2d01 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    2da9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2dad:	8b 45 30             	mov    0x30(%ebp),%eax
    2db0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2db3:	0f 8f 3c ff ff ff    	jg     2cf5 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    2db9:	90                   	nop
    2dba:	c9                   	leave  
    2dbb:	c3                   	ret    

00002dbc <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    2dbc:	55                   	push   %ebp
    2dbd:	89 e5                	mov    %esp,%ebp
    2dbf:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    2dc2:	ff 75 24             	pushl  0x24(%ebp)
    2dc5:	ff 75 20             	pushl  0x20(%ebp)
    2dc8:	ff 75 1c             	pushl  0x1c(%ebp)
    2dcb:	ff 75 18             	pushl  0x18(%ebp)
    2dce:	ff 75 1c             	pushl  0x1c(%ebp)
    2dd1:	ff 75 18             	pushl  0x18(%ebp)
    2dd4:	ff 75 14             	pushl  0x14(%ebp)
    2dd7:	ff 75 10             	pushl  0x10(%ebp)
    2dda:	ff 75 14             	pushl  0x14(%ebp)
    2ddd:	ff 75 10             	pushl  0x10(%ebp)
    2de0:	ff 75 0c             	pushl  0xc(%ebp)
    2de3:	ff 75 08             	pushl  0x8(%ebp)
    2de6:	e8 5c fd ff ff       	call   2b47 <drawBitmap>
    2deb:	83 c4 30             	add    $0x30,%esp
}
    2dee:	90                   	nop
    2def:	c9                   	leave  
    2df0:	c3                   	ret    

00002df1 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    2df1:	55                   	push   %ebp
    2df2:	89 e5                	mov    %esp,%ebp
    2df4:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    2df7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2dfa:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    2dfd:	8b 45 20             	mov    0x20(%ebp),%eax
    2e00:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    2e03:	8b 55 14             	mov    0x14(%ebp),%edx
    2e06:	8b 45 10             	mov    0x10(%ebp),%eax
    2e09:	29 c2                	sub    %eax,%edx
    2e0b:	89 d0                	mov    %edx,%eax
    2e0d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2e10:	7d 0d                	jge    2e1f <colorShift+0x2e>
        draw_h = s.h - p.y;
    2e12:	8b 55 14             	mov    0x14(%ebp),%edx
    2e15:	8b 45 10             	mov    0x10(%ebp),%eax
    2e18:	29 c2                	sub    %eax,%edx
    2e1a:	89 d0                	mov    %edx,%eax
    2e1c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    2e1f:	8b 55 18             	mov    0x18(%ebp),%edx
    2e22:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e25:	29 c2                	sub    %eax,%edx
    2e27:	89 d0                	mov    %edx,%eax
    2e29:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2e2c:	7d 0d                	jge    2e3b <colorShift+0x4a>
        draw_w = s.w - p.x;
    2e2e:	8b 55 18             	mov    0x18(%ebp),%edx
    2e31:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e34:	29 c2                	sub    %eax,%edx
    2e36:	89 d0                	mov    %edx,%eax
    2e38:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2e3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2e42:	e9 fc 00 00 00       	jmp    2f43 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    2e47:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2e4e:	e9 e0 00 00 00       	jmp    2f33 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    2e53:	8b 55 10             	mov    0x10(%ebp),%edx
    2e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e59:	01 c2                	add    %eax,%edx
    2e5b:	8b 45 18             	mov    0x18(%ebp),%eax
    2e5e:	0f af c2             	imul   %edx,%eax
    2e61:	89 c2                	mov    %eax,%edx
    2e63:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e66:	01 c2                	add    %eax,%edx
    2e68:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e6b:	01 c2                	add    %eax,%edx
    2e6d:	89 d0                	mov    %edx,%eax
    2e6f:	01 c0                	add    %eax,%eax
    2e71:	01 c2                	add    %eax,%edx
    2e73:	8b 45 08             	mov    0x8(%ebp),%eax
    2e76:	01 d0                	add    %edx,%eax
    2e78:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    2e7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2e7e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2e82:	3c c8                	cmp    $0xc8,%al
    2e84:	0f 86 a5 00 00 00    	jbe    2f2f <colorShift+0x13e>
    2e8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2e8d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2e91:	3c c8                	cmp    $0xc8,%al
    2e93:	0f 86 96 00 00 00    	jbe    2f2f <colorShift+0x13e>
    2e99:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2e9c:	0f b6 00             	movzbl (%eax),%eax
    2e9f:	3c c8                	cmp    $0xc8,%al
    2ea1:	0f 86 88 00 00 00    	jbe    2f2f <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    2ea7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2eaa:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2eae:	0f b6 d0             	movzbl %al,%edx
    2eb1:	8b 45 24             	mov    0x24(%ebp),%eax
    2eb4:	01 d0                	add    %edx,%eax
    2eb6:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2ebc:	89 d0                	mov    %edx,%eax
    2ebe:	c1 f8 1f             	sar    $0x1f,%eax
    2ec1:	c1 e8 18             	shr    $0x18,%eax
    2ec4:	01 c2                	add    %eax,%edx
    2ec6:	0f b6 d2             	movzbl %dl,%edx
    2ec9:	29 c2                	sub    %eax,%edx
    2ecb:	89 d0                	mov    %edx,%eax
    2ecd:	89 c2                	mov    %eax,%edx
    2ecf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2ed2:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    2ed5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2ed8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2edc:	0f b6 d0             	movzbl %al,%edx
    2edf:	8b 45 24             	mov    0x24(%ebp),%eax
    2ee2:	01 d0                	add    %edx,%eax
    2ee4:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2eea:	89 d0                	mov    %edx,%eax
    2eec:	c1 f8 1f             	sar    $0x1f,%eax
    2eef:	c1 e8 18             	shr    $0x18,%eax
    2ef2:	01 c2                	add    %eax,%edx
    2ef4:	0f b6 d2             	movzbl %dl,%edx
    2ef7:	29 c2                	sub    %eax,%edx
    2ef9:	89 d0                	mov    %edx,%eax
    2efb:	89 c2                	mov    %eax,%edx
    2efd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2f00:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    2f03:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2f06:	0f b6 00             	movzbl (%eax),%eax
    2f09:	0f b6 d0             	movzbl %al,%edx
    2f0c:	8b 45 24             	mov    0x24(%ebp),%eax
    2f0f:	01 d0                	add    %edx,%eax
    2f11:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2f17:	89 d0                	mov    %edx,%eax
    2f19:	c1 f8 1f             	sar    $0x1f,%eax
    2f1c:	c1 e8 18             	shr    $0x18,%eax
    2f1f:	01 c2                	add    %eax,%edx
    2f21:	0f b6 d2             	movzbl %dl,%edx
    2f24:	29 c2                	sub    %eax,%edx
    2f26:	89 d0                	mov    %edx,%eax
    2f28:	89 c2                	mov    %eax,%edx
    2f2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2f2d:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    2f2f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f36:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2f39:	0f 8c 14 ff ff ff    	jl     2e53 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2f3f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2f43:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f46:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2f49:	0f 8c f8 fe ff ff    	jl     2e47 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    2f4f:	90                   	nop
    2f50:	c9                   	leave  
    2f51:	c3                   	ret    

00002f52 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    2f52:	55                   	push   %ebp
    2f53:	89 e5                	mov    %esp,%ebp
    2f55:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2f58:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2f5f:	e9 fb 00 00 00       	jmp    305f <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    2f64:	8b 55 14             	mov    0x14(%ebp),%edx
    2f67:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2f6a:	01 c2                	add    %eax,%edx
    2f6c:	0f b7 05 a6 fe 01 00 	movzwl 0x1fea6,%eax
    2f73:	0f b7 c0             	movzwl %ax,%eax
    2f76:	39 c2                	cmp    %eax,%edx
    2f78:	0f 8f eb 00 00 00    	jg     3069 <drawMouse+0x117>
    2f7e:	8b 55 14             	mov    0x14(%ebp),%edx
    2f81:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2f84:	01 d0                	add    %edx,%eax
    2f86:	85 c0                	test   %eax,%eax
    2f88:	0f 88 db 00 00 00    	js     3069 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2f8e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2f95:	e9 b7 00 00 00       	jmp    3051 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    2f9a:	8b 55 10             	mov    0x10(%ebp),%edx
    2f9d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2fa0:	01 c2                	add    %eax,%edx
    2fa2:	0f b7 05 a4 fe 01 00 	movzwl 0x1fea4,%eax
    2fa9:	0f b7 c0             	movzwl %ax,%eax
    2fac:	39 c2                	cmp    %eax,%edx
    2fae:	0f 8f a7 00 00 00    	jg     305b <drawMouse+0x109>
    2fb4:	8b 55 10             	mov    0x10(%ebp),%edx
    2fb7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2fba:	01 d0                	add    %edx,%eax
    2fbc:	85 c0                	test   %eax,%eax
    2fbe:	0f 88 97 00 00 00    	js     305b <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    2fc4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    2fc7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2fca:	89 d0                	mov    %edx,%eax
    2fcc:	c1 e0 04             	shl    $0x4,%eax
    2fcf:	29 d0                	sub    %edx,%eax
    2fd1:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    2fd7:	01 c2                	add    %eax,%edx
    2fd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2fdc:	01 d0                	add    %edx,%eax
    2fde:	05 20 6f 01 00       	add    $0x16f20,%eax
    2fe3:	0f b6 00             	movzbl (%eax),%eax
    2fe6:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    2fe9:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    2fed:	74 5e                	je     304d <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    2fef:	8b 55 14             	mov    0x14(%ebp),%edx
    2ff2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2ff5:	01 c2                	add    %eax,%edx
    2ff7:	0f b7 05 a4 fe 01 00 	movzwl 0x1fea4,%eax
    2ffe:	0f b7 c0             	movzwl %ax,%eax
    3001:	0f af c2             	imul   %edx,%eax
    3004:	89 c2                	mov    %eax,%edx
    3006:	8b 45 10             	mov    0x10(%ebp),%eax
    3009:	01 c2                	add    %eax,%edx
    300b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    300e:	01 c2                	add    %eax,%edx
    3010:	89 d0                	mov    %edx,%eax
    3012:	01 c0                	add    %eax,%eax
    3014:	01 c2                	add    %eax,%edx
    3016:	8b 45 08             	mov    0x8(%ebp),%eax
    3019:	01 d0                	add    %edx,%eax
    301b:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    301e:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    3022:	8d 50 ff             	lea    -0x1(%eax),%edx
    3025:	89 d0                	mov    %edx,%eax
    3027:	01 c0                	add    %eax,%eax
    3029:	01 d0                	add    %edx,%eax
    302b:	05 e4 fe 01 00       	add    $0x1fee4,%eax
    3030:	83 ec 04             	sub    $0x4,%esp
    3033:	89 e2                	mov    %esp,%edx
    3035:	0f b7 08             	movzwl (%eax),%ecx
    3038:	66 89 0a             	mov    %cx,(%edx)
    303b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    303f:	88 42 02             	mov    %al,0x2(%edx)
    3042:	ff 75 f0             	pushl  -0x10(%ebp)
    3045:	e8 73 f6 ff ff       	call   26bd <drawPoint>
    304a:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    304d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3051:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    3055:	0f 8e 3f ff ff ff    	jle    2f9a <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    305b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    305f:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    3063:	0f 8e fb fe ff ff    	jle    2f64 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    3069:	90                   	nop
    306a:	c9                   	leave  
    306b:	c3                   	ret    

0000306c <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    306c:	55                   	push   %ebp
    306d:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    306f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    3073:	78 1b                	js     3090 <getColor+0x24>
    3075:	8b 45 08             	mov    0x8(%ebp),%eax
    3078:	8b 40 04             	mov    0x4(%eax),%eax
    307b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    307e:	7c 10                	jl     3090 <getColor+0x24>
    3080:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    3084:	78 0a                	js     3090 <getColor+0x24>
    3086:	8b 45 08             	mov    0x8(%ebp),%eax
    3089:	8b 00                	mov    (%eax),%eax
    308b:	3b 45 10             	cmp    0x10(%ebp),%eax
    308e:	7d 10                	jge    30a0 <getColor+0x34>
    {
        *isInPic = 1;
    3090:	8b 45 14             	mov    0x14(%ebp),%eax
    3093:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    3099:	b8 f1 f6 01 00       	mov    $0x1f6f1,%eax
    309e:	eb 44                	jmp    30e4 <getColor+0x78>
    }

    if (y == pic->height)
    30a0:	8b 45 08             	mov    0x8(%ebp),%eax
    30a3:	8b 40 04             	mov    0x4(%eax),%eax
    30a6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    30a9:	75 04                	jne    30af <getColor+0x43>
        y--;
    30ab:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    30af:	8b 45 08             	mov    0x8(%ebp),%eax
    30b2:	8b 00                	mov    (%eax),%eax
    30b4:	3b 45 10             	cmp    0x10(%ebp),%eax
    30b7:	75 04                	jne    30bd <getColor+0x51>
        x--;
    30b9:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    30bd:	8b 45 14             	mov    0x14(%ebp),%eax
    30c0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    30c6:	8b 45 08             	mov    0x8(%ebp),%eax
    30c9:	8b 48 08             	mov    0x8(%eax),%ecx
    30cc:	8b 45 08             	mov    0x8(%ebp),%eax
    30cf:	8b 00                	mov    (%eax),%eax
    30d1:	0f af 45 0c          	imul   0xc(%ebp),%eax
    30d5:	89 c2                	mov    %eax,%edx
    30d7:	8b 45 10             	mov    0x10(%ebp),%eax
    30da:	01 c2                	add    %eax,%edx
    30dc:	89 d0                	mov    %edx,%eax
    30de:	01 c0                	add    %eax,%eax
    30e0:	01 d0                	add    %edx,%eax
    30e2:	01 c8                	add    %ecx,%eax
}
    30e4:	5d                   	pop    %ebp
    30e5:	c3                   	ret    

000030e6 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    30e6:	55                   	push   %ebp
    30e7:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    30e9:	8b 45 08             	mov    0x8(%ebp),%eax
    30ec:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    30f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    30f3:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    30f6:	8b 45 08             	mov    0x8(%ebp),%eax
    30f9:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    30fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    3100:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    3103:	8b 45 08             	mov    0x8(%ebp),%eax
    3106:	0f b6 10             	movzbl (%eax),%edx
    3109:	8b 45 0c             	mov    0xc(%ebp),%eax
    310c:	88 10                	mov    %dl,(%eax)

    return 1;
    310e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3113:	5d                   	pop    %ebp
    3114:	c3                   	ret    

00003115 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    3115:	55                   	push   %ebp
    3116:	89 e5                	mov    %esp,%ebp
    3118:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    311b:	d9 45 10             	flds   0x10(%ebp)
    311e:	d9 7d be             	fnstcw -0x42(%ebp)
    3121:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    3125:	b4 0c                	mov    $0xc,%ah
    3127:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    312b:	d9 6d bc             	fldcw  -0x44(%ebp)
    312e:	db 5d fc             	fistpl -0x4(%ebp)
    3131:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    3134:	d9 45 0c             	flds   0xc(%ebp)
    3137:	d9 6d bc             	fldcw  -0x44(%ebp)
    313a:	db 5d f8             	fistpl -0x8(%ebp)
    313d:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    3140:	db 45 fc             	fildl  -0x4(%ebp)
    3143:	d9 45 10             	flds   0x10(%ebp)
    3146:	d9 c9                	fxch   %st(1)
    3148:	df e9                	fucomip %st(1),%st
    314a:	dd d8                	fstp   %st(0)
    314c:	76 04                	jbe    3152 <mixColor+0x3d>
        x--;
    314e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    3152:	db 45 f8             	fildl  -0x8(%ebp)
    3155:	d9 45 0c             	flds   0xc(%ebp)
    3158:	d9 c9                	fxch   %st(1)
    315a:	df e9                	fucomip %st(1),%st
    315c:	dd d8                	fstp   %st(0)
    315e:	76 04                	jbe    3164 <mixColor+0x4f>
        y--;
    3160:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    3164:	8d 45 c0             	lea    -0x40(%ebp),%eax
    3167:	50                   	push   %eax
    3168:	ff 75 fc             	pushl  -0x4(%ebp)
    316b:	ff 75 f8             	pushl  -0x8(%ebp)
    316e:	ff 75 08             	pushl  0x8(%ebp)
    3171:	e8 f6 fe ff ff       	call   306c <getColor>
    3176:	83 c4 10             	add    $0x10,%esp
    3179:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    317c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    317f:	83 c0 01             	add    $0x1,%eax
    3182:	8d 55 c0             	lea    -0x40(%ebp),%edx
    3185:	83 c2 04             	add    $0x4,%edx
    3188:	52                   	push   %edx
    3189:	ff 75 fc             	pushl  -0x4(%ebp)
    318c:	50                   	push   %eax
    318d:	ff 75 08             	pushl  0x8(%ebp)
    3190:	e8 d7 fe ff ff       	call   306c <getColor>
    3195:	83 c4 10             	add    $0x10,%esp
    3198:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    319b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    319e:	83 c0 01             	add    $0x1,%eax
    31a1:	8d 55 c0             	lea    -0x40(%ebp),%edx
    31a4:	83 c2 08             	add    $0x8,%edx
    31a7:	52                   	push   %edx
    31a8:	50                   	push   %eax
    31a9:	ff 75 f8             	pushl  -0x8(%ebp)
    31ac:	ff 75 08             	pushl  0x8(%ebp)
    31af:	e8 b8 fe ff ff       	call   306c <getColor>
    31b4:	83 c4 10             	add    $0x10,%esp
    31b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    31ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    31bd:	8d 50 01             	lea    0x1(%eax),%edx
    31c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    31c3:	83 c0 01             	add    $0x1,%eax
    31c6:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    31c9:	83 c1 0c             	add    $0xc,%ecx
    31cc:	51                   	push   %ecx
    31cd:	52                   	push   %edx
    31ce:	50                   	push   %eax
    31cf:	ff 75 08             	pushl  0x8(%ebp)
    31d2:	e8 95 fe ff ff       	call   306c <getColor>
    31d7:	83 c4 10             	add    $0x10,%esp
    31da:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    31dd:	db 45 fc             	fildl  -0x4(%ebp)
    31e0:	d9 45 10             	flds   0x10(%ebp)
    31e3:	de e1                	fsubp  %st,%st(1)
    31e5:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    31e8:	db 45 f8             	fildl  -0x8(%ebp)
    31eb:	d9 45 0c             	flds   0xc(%ebp)
    31ee:	de e1                	fsubp  %st,%st(1)
    31f0:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    31f3:	d9 45 e4             	flds   -0x1c(%ebp)
    31f6:	d8 4d e0             	fmuls  -0x20(%ebp)
    31f9:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    31fc:	d9 e8                	fld1   
    31fe:	d8 65 e0             	fsubs  -0x20(%ebp)
    3201:	d8 4d e4             	fmuls  -0x1c(%ebp)
    3204:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    3207:	d9 e8                	fld1   
    3209:	d8 65 e4             	fsubs  -0x1c(%ebp)
    320c:	d8 4d e0             	fmuls  -0x20(%ebp)
    320f:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    3212:	d9 e8                	fld1   
    3214:	d8 65 e4             	fsubs  -0x1c(%ebp)
    3217:	d9 e8                	fld1   
    3219:	d8 65 e0             	fsubs  -0x20(%ebp)
    321c:	de c9                	fmulp  %st,%st(1)
    321e:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    3221:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3224:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3228:	0f b6 c0             	movzbl %al,%eax
    322b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    322e:	db 45 b4             	fildl  -0x4c(%ebp)
    3231:	d8 4d d0             	fmuls  -0x30(%ebp)
    3234:	8b 45 c0             	mov    -0x40(%ebp),%eax
    3237:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    323a:	db 45 b4             	fildl  -0x4c(%ebp)
    323d:	de c9                	fmulp  %st,%st(1)
    323f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3242:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3246:	0f b6 c0             	movzbl %al,%eax
    3249:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    324c:	db 45 b4             	fildl  -0x4c(%ebp)
    324f:	d8 4d d4             	fmuls  -0x2c(%ebp)
    3252:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3255:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3258:	db 45 b4             	fildl  -0x4c(%ebp)
    325b:	de c9                	fmulp  %st,%st(1)
    325d:	de c1                	faddp  %st,%st(1)
    325f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3262:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3266:	0f b6 c0             	movzbl %al,%eax
    3269:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    326c:	db 45 b4             	fildl  -0x4c(%ebp)
    326f:	d8 4d d8             	fmuls  -0x28(%ebp)
    3272:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3275:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3278:	db 45 b4             	fildl  -0x4c(%ebp)
    327b:	de c9                	fmulp  %st,%st(1)
    327d:	de c1                	faddp  %st,%st(1)
    327f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3282:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3286:	0f b6 c0             	movzbl %al,%eax
    3289:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    328c:	db 45 b4             	fildl  -0x4c(%ebp)
    328f:	d8 4d dc             	fmuls  -0x24(%ebp)
    3292:	8b 45 cc             	mov    -0x34(%ebp),%eax
    3295:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3298:	db 45 b4             	fildl  -0x4c(%ebp)
    329b:	de c9                	fmulp  %st,%st(1)
    329d:	de c1                	faddp  %st,%st(1)
    329f:	d9 7d be             	fnstcw -0x42(%ebp)
    32a2:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    32a6:	b4 0c                	mov    $0xc,%ah
    32a8:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    32ac:	d9 6d bc             	fldcw  -0x44(%ebp)
    32af:	db 5d b8             	fistpl -0x48(%ebp)
    32b2:	d9 6d be             	fldcw  -0x42(%ebp)
    32b5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    32b8:	89 c2                	mov    %eax,%edx
    32ba:	8b 45 14             	mov    0x14(%ebp),%eax
    32bd:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    32c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32c3:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    32c7:	0f b6 c0             	movzbl %al,%eax
    32ca:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    32cd:	db 45 b4             	fildl  -0x4c(%ebp)
    32d0:	d8 4d d0             	fmuls  -0x30(%ebp)
    32d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
    32d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    32d9:	db 45 b4             	fildl  -0x4c(%ebp)
    32dc:	de c9                	fmulp  %st,%st(1)
    32de:	8b 45 f0             	mov    -0x10(%ebp),%eax
    32e1:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    32e5:	0f b6 c0             	movzbl %al,%eax
    32e8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    32eb:	db 45 b4             	fildl  -0x4c(%ebp)
    32ee:	d8 4d d4             	fmuls  -0x2c(%ebp)
    32f1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    32f4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    32f7:	db 45 b4             	fildl  -0x4c(%ebp)
    32fa:	de c9                	fmulp  %st,%st(1)
    32fc:	de c1                	faddp  %st,%st(1)
    32fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3301:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3305:	0f b6 c0             	movzbl %al,%eax
    3308:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    330b:	db 45 b4             	fildl  -0x4c(%ebp)
    330e:	d8 4d d8             	fmuls  -0x28(%ebp)
    3311:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3314:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3317:	db 45 b4             	fildl  -0x4c(%ebp)
    331a:	de c9                	fmulp  %st,%st(1)
    331c:	de c1                	faddp  %st,%st(1)
    331e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3321:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3325:	0f b6 c0             	movzbl %al,%eax
    3328:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    332b:	db 45 b4             	fildl  -0x4c(%ebp)
    332e:	d8 4d dc             	fmuls  -0x24(%ebp)
    3331:	8b 45 cc             	mov    -0x34(%ebp),%eax
    3334:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3337:	db 45 b4             	fildl  -0x4c(%ebp)
    333a:	de c9                	fmulp  %st,%st(1)
    333c:	de c1                	faddp  %st,%st(1)
    333e:	d9 6d bc             	fldcw  -0x44(%ebp)
    3341:	db 5d b8             	fistpl -0x48(%ebp)
    3344:	d9 6d be             	fldcw  -0x42(%ebp)
    3347:	8b 45 b8             	mov    -0x48(%ebp),%eax
    334a:	89 c2                	mov    %eax,%edx
    334c:	8b 45 14             	mov    0x14(%ebp),%eax
    334f:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    3352:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3355:	0f b6 00             	movzbl (%eax),%eax
    3358:	0f b6 c0             	movzbl %al,%eax
    335b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    335e:	db 45 b4             	fildl  -0x4c(%ebp)
    3361:	d8 4d d0             	fmuls  -0x30(%ebp)
    3364:	8b 45 c0             	mov    -0x40(%ebp),%eax
    3367:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    336a:	db 45 b4             	fildl  -0x4c(%ebp)
    336d:	de c9                	fmulp  %st,%st(1)
    336f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3372:	0f b6 00             	movzbl (%eax),%eax
    3375:	0f b6 c0             	movzbl %al,%eax
    3378:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    337b:	db 45 b4             	fildl  -0x4c(%ebp)
    337e:	d8 4d d4             	fmuls  -0x2c(%ebp)
    3381:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3384:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3387:	db 45 b4             	fildl  -0x4c(%ebp)
    338a:	de c9                	fmulp  %st,%st(1)
    338c:	de c1                	faddp  %st,%st(1)
    338e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3391:	0f b6 00             	movzbl (%eax),%eax
    3394:	0f b6 c0             	movzbl %al,%eax
    3397:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    339a:	db 45 b4             	fildl  -0x4c(%ebp)
    339d:	d8 4d d8             	fmuls  -0x28(%ebp)
    33a0:	8b 45 c8             	mov    -0x38(%ebp),%eax
    33a3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    33a6:	db 45 b4             	fildl  -0x4c(%ebp)
    33a9:	de c9                	fmulp  %st,%st(1)
    33ab:	de c1                	faddp  %st,%st(1)
    33ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    33b0:	0f b6 00             	movzbl (%eax),%eax
    33b3:	0f b6 c0             	movzbl %al,%eax
    33b6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    33b9:	db 45 b4             	fildl  -0x4c(%ebp)
    33bc:	d8 4d dc             	fmuls  -0x24(%ebp)
    33bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
    33c2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    33c5:	db 45 b4             	fildl  -0x4c(%ebp)
    33c8:	de c9                	fmulp  %st,%st(1)
    33ca:	de c1                	faddp  %st,%st(1)
    33cc:	d9 6d bc             	fldcw  -0x44(%ebp)
    33cf:	db 5d b8             	fistpl -0x48(%ebp)
    33d2:	d9 6d be             	fldcw  -0x42(%ebp)
    33d5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    33d8:	89 c2                	mov    %eax,%edx
    33da:	8b 45 14             	mov    0x14(%ebp),%eax
    33dd:	88 10                	mov    %dl,(%eax)

    return 1;
    33df:	b8 01 00 00 00       	mov    $0x1,%eax
}
    33e4:	c9                   	leave  
    33e5:	c3                   	ret    

000033e6 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    33e6:	55                   	push   %ebp
    33e7:	89 e5                	mov    %esp,%ebp
    33e9:	53                   	push   %ebx
    33ea:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    33ed:	8b 45 10             	mov    0x10(%ebp),%eax
    33f0:	c1 f8 10             	sar    $0x10,%eax
    33f3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    33f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    33f9:	c1 f8 10             	sar    $0x10,%eax
    33fc:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    33ff:	8d 45 bc             	lea    -0x44(%ebp),%eax
    3402:	50                   	push   %eax
    3403:	ff 75 f8             	pushl  -0x8(%ebp)
    3406:	ff 75 f4             	pushl  -0xc(%ebp)
    3409:	ff 75 08             	pushl  0x8(%ebp)
    340c:	e8 5b fc ff ff       	call   306c <getColor>
    3411:	83 c4 10             	add    $0x10,%esp
    3414:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    3417:	8b 45 f4             	mov    -0xc(%ebp),%eax
    341a:	83 c0 01             	add    $0x1,%eax
    341d:	8d 55 bc             	lea    -0x44(%ebp),%edx
    3420:	83 c2 04             	add    $0x4,%edx
    3423:	52                   	push   %edx
    3424:	ff 75 f8             	pushl  -0x8(%ebp)
    3427:	50                   	push   %eax
    3428:	ff 75 08             	pushl  0x8(%ebp)
    342b:	e8 3c fc ff ff       	call   306c <getColor>
    3430:	83 c4 10             	add    $0x10,%esp
    3433:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    3436:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3439:	83 c0 01             	add    $0x1,%eax
    343c:	8d 55 bc             	lea    -0x44(%ebp),%edx
    343f:	83 c2 08             	add    $0x8,%edx
    3442:	52                   	push   %edx
    3443:	50                   	push   %eax
    3444:	ff 75 f4             	pushl  -0xc(%ebp)
    3447:	ff 75 08             	pushl  0x8(%ebp)
    344a:	e8 1d fc ff ff       	call   306c <getColor>
    344f:	83 c4 10             	add    $0x10,%esp
    3452:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    3455:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3458:	8d 50 01             	lea    0x1(%eax),%edx
    345b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    345e:	83 c0 01             	add    $0x1,%eax
    3461:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    3464:	83 c1 0c             	add    $0xc,%ecx
    3467:	51                   	push   %ecx
    3468:	52                   	push   %edx
    3469:	50                   	push   %eax
    346a:	ff 75 08             	pushl  0x8(%ebp)
    346d:	e8 fa fb ff ff       	call   306c <getColor>
    3472:	83 c4 10             	add    $0x10,%esp
    3475:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    3478:	8b 45 10             	mov    0x10(%ebp),%eax
    347b:	0f b7 c0             	movzwl %ax,%eax
    347e:	c1 f8 08             	sar    $0x8,%eax
    3481:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    3484:	8b 45 0c             	mov    0xc(%ebp),%eax
    3487:	0f b7 c0             	movzwl %ax,%eax
    348a:	c1 f8 08             	sar    $0x8,%eax
    348d:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    3490:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3493:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    3497:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    349a:	b8 ff 00 00 00       	mov    $0xff,%eax
    349f:	2b 45 dc             	sub    -0x24(%ebp),%eax
    34a2:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    34a6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    34a9:	b8 ff 00 00 00       	mov    $0xff,%eax
    34ae:	2b 45 e0             	sub    -0x20(%ebp),%eax
    34b1:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    34b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    34b8:	b8 ff 00 00 00       	mov    $0xff,%eax
    34bd:	2b 45 e0             	sub    -0x20(%ebp),%eax
    34c0:	89 c2                	mov    %eax,%edx
    34c2:	b8 ff 00 00 00       	mov    $0xff,%eax
    34c7:	2b 45 dc             	sub    -0x24(%ebp),%eax
    34ca:	0f af c2             	imul   %edx,%eax
    34cd:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    34d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    34d3:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    34d7:	0f b6 c0             	movzbl %al,%eax
    34da:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    34de:	8b 55 bc             	mov    -0x44(%ebp),%edx
    34e1:	0f af d0             	imul   %eax,%edx
    34e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    34e7:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    34eb:	0f b6 c0             	movzbl %al,%eax
    34ee:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    34f2:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    34f5:	0f af c1             	imul   %ecx,%eax
    34f8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    34fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    34fe:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3502:	0f b6 c0             	movzbl %al,%eax
    3505:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    3509:	8b 55 c8             	mov    -0x38(%ebp),%edx
    350c:	0f af d0             	imul   %eax,%edx
    350f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3512:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3516:	0f b6 c0             	movzbl %al,%eax
    3519:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    351d:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    3520:	0f af c1             	imul   %ecx,%eax
    3523:	01 d0                	add    %edx,%eax
    3525:	01 d8                	add    %ebx,%eax
    3527:	c1 e8 10             	shr    $0x10,%eax
    352a:	89 c2                	mov    %eax,%edx
    352c:	8b 45 14             	mov    0x14(%ebp),%eax
    352f:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    3532:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3535:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3539:	0f b6 c0             	movzbl %al,%eax
    353c:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    3540:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3543:	0f af d0             	imul   %eax,%edx
    3546:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3549:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    354d:	0f b6 c0             	movzbl %al,%eax
    3550:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    3554:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    3557:	0f af c1             	imul   %ecx,%eax
    355a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    355d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3560:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3564:	0f b6 c0             	movzbl %al,%eax
    3567:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    356b:	8b 55 c8             	mov    -0x38(%ebp),%edx
    356e:	0f af d0             	imul   %eax,%edx
    3571:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3574:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3578:	0f b6 c0             	movzbl %al,%eax
    357b:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    357f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    3582:	0f af c1             	imul   %ecx,%eax
    3585:	01 d0                	add    %edx,%eax
    3587:	01 d8                	add    %ebx,%eax
    3589:	c1 e8 10             	shr    $0x10,%eax
    358c:	89 c2                	mov    %eax,%edx
    358e:	8b 45 14             	mov    0x14(%ebp),%eax
    3591:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    3594:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3597:	0f b6 00             	movzbl (%eax),%eax
    359a:	0f b6 c0             	movzbl %al,%eax
    359d:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    35a1:	8b 55 bc             	mov    -0x44(%ebp),%edx
    35a4:	0f af d0             	imul   %eax,%edx
    35a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    35aa:	0f b6 00             	movzbl (%eax),%eax
    35ad:	0f b6 c0             	movzbl %al,%eax
    35b0:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    35b4:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    35b7:	0f af c1             	imul   %ecx,%eax
    35ba:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    35bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    35c0:	0f b6 00             	movzbl (%eax),%eax
    35c3:	0f b6 c0             	movzbl %al,%eax
    35c6:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    35ca:	8b 55 c8             	mov    -0x38(%ebp),%edx
    35cd:	0f af d0             	imul   %eax,%edx
    35d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    35d3:	0f b6 00             	movzbl (%eax),%eax
    35d6:	0f b6 c0             	movzbl %al,%eax
    35d9:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    35dd:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    35e0:	0f af c1             	imul   %ecx,%eax
    35e3:	01 d0                	add    %edx,%eax
    35e5:	01 d8                	add    %ebx,%eax
    35e7:	c1 e8 10             	shr    $0x10,%eax
    35ea:	89 c2                	mov    %eax,%edx
    35ec:	8b 45 14             	mov    0x14(%ebp),%eax
    35ef:	88 10                	mov    %dl,(%eax)
}
    35f1:	90                   	nop
    35f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    35f5:	c9                   	leave  
    35f6:	c3                   	ret    

000035f7 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    35f7:	55                   	push   %ebp
    35f8:	89 e5                	mov    %esp,%ebp
    35fa:	53                   	push   %ebx
    35fb:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    35fe:	8b 45 08             	mov    0x8(%ebp),%eax
    3601:	8b 00                	mov    (%eax),%eax
    3603:	c1 e0 10             	shl    $0x10,%eax
    3606:	89 c1                	mov    %eax,%ecx
    3608:	8b 45 0c             	mov    0xc(%ebp),%eax
    360b:	8b 18                	mov    (%eax),%ebx
    360d:	89 c8                	mov    %ecx,%eax
    360f:	99                   	cltd   
    3610:	f7 fb                	idiv   %ebx
    3612:	83 c0 01             	add    $0x1,%eax
    3615:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    3618:	8b 45 08             	mov    0x8(%ebp),%eax
    361b:	8b 40 04             	mov    0x4(%eax),%eax
    361e:	c1 e0 10             	shl    $0x10,%eax
    3621:	89 c1                	mov    %eax,%ecx
    3623:	8b 45 0c             	mov    0xc(%ebp),%eax
    3626:	8b 58 04             	mov    0x4(%eax),%ebx
    3629:	89 c8                	mov    %ecx,%eax
    362b:	99                   	cltd   
    362c:	f7 fb                	idiv   %ebx
    362e:	83 c0 01             	add    $0x1,%eax
    3631:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    3634:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3637:	d1 f8                	sar    %eax
    3639:	2d 00 80 00 00       	sub    $0x8000,%eax
    363e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    3641:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3644:	d1 f8                	sar    %eax
    3646:	2d 00 80 00 00       	sub    $0x8000,%eax
    364b:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    364e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3651:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    3654:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    365b:	eb 5d                	jmp    36ba <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    365d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3660:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    3663:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    366a:	eb 3a                	jmp    36a6 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    366c:	8b 45 0c             	mov    0xc(%ebp),%eax
    366f:	8b 48 08             	mov    0x8(%eax),%ecx
    3672:	8b 45 0c             	mov    0xc(%ebp),%eax
    3675:	8b 00                	mov    (%eax),%eax
    3677:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    367b:	89 c2                	mov    %eax,%edx
    367d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3680:	01 c2                	add    %eax,%edx
    3682:	89 d0                	mov    %edx,%eax
    3684:	01 c0                	add    %eax,%eax
    3686:	01 d0                	add    %edx,%eax
    3688:	01 c8                	add    %ecx,%eax
    368a:	50                   	push   %eax
    368b:	ff 75 f0             	pushl  -0x10(%ebp)
    368e:	ff 75 f8             	pushl  -0x8(%ebp)
    3691:	ff 75 08             	pushl  0x8(%ebp)
    3694:	e8 4d fd ff ff       	call   33e6 <mixColorInt>
    3699:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    369c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    369f:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    36a2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    36a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    36a9:	8b 00                	mov    (%eax),%eax
    36ab:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    36ae:	7f bc                	jg     366c <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    36b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    36b3:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    36b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    36ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    36bd:	8b 40 04             	mov    0x4(%eax),%eax
    36c0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    36c3:	7f 98                	jg     365d <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    36c5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    36ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    36cd:	c9                   	leave  
    36ce:	c3                   	ret    

000036cf <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    36cf:	55                   	push   %ebp
    36d0:	89 e5                	mov    %esp,%ebp
    36d2:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    36d5:	8b 45 08             	mov    0x8(%ebp),%eax
    36d8:	8b 00                	mov    (%eax),%eax
    36da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    36dd:	db 45 e4             	fildl  -0x1c(%ebp)
    36e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    36e3:	8b 00                	mov    (%eax),%eax
    36e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    36e8:	db 45 e4             	fildl  -0x1c(%ebp)
    36eb:	de f9                	fdivrp %st,%st(1)
    36ed:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    36f0:	8b 45 08             	mov    0x8(%ebp),%eax
    36f3:	8b 40 04             	mov    0x4(%eax),%eax
    36f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    36f9:	db 45 e4             	fildl  -0x1c(%ebp)
    36fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    36ff:	8b 40 04             	mov    0x4(%eax),%eax
    3702:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3705:	db 45 e4             	fildl  -0x1c(%ebp)
    3708:	de f9                	fdivrp %st,%st(1)
    370a:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    370d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3714:	eb 5e                	jmp    3774 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    3716:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    371d:	eb 47                	jmp    3766 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    371f:	db 45 f8             	fildl  -0x8(%ebp)
    3722:	d8 4d f4             	fmuls  -0xc(%ebp)
    3725:	d9 7d ee             	fnstcw -0x12(%ebp)
    3728:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    372c:	b4 0c                	mov    $0xc,%ah
    372e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    3732:	d9 6d ec             	fldcw  -0x14(%ebp)
    3735:	db 5d e8             	fistpl -0x18(%ebp)
    3738:	d9 6d ee             	fldcw  -0x12(%ebp)
    373b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    373e:	db 45 fc             	fildl  -0x4(%ebp)
    3741:	d8 4d f0             	fmuls  -0x10(%ebp)
    3744:	d9 6d ec             	fldcw  -0x14(%ebp)
    3747:	db 5d e8             	fistpl -0x18(%ebp)
    374a:	d9 6d ee             	fldcw  -0x12(%ebp)
    374d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3750:	6a 00                	push   $0x0
    3752:	52                   	push   %edx
    3753:	50                   	push   %eax
    3754:	ff 75 08             	pushl  0x8(%ebp)
    3757:	e8 10 f9 ff ff       	call   306c <getColor>
    375c:	83 c4 10             	add    $0x10,%esp
    375f:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    3762:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3766:	8b 45 0c             	mov    0xc(%ebp),%eax
    3769:	8b 00                	mov    (%eax),%eax
    376b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    376e:	7f af                	jg     371f <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    3770:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3774:	8b 45 0c             	mov    0xc(%ebp),%eax
    3777:	8b 40 04             	mov    0x4(%eax),%eax
    377a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    377d:	7f 97                	jg     3716 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    377f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3784:	c9                   	leave  
    3785:	c3                   	ret    

00003786 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    3786:	55                   	push   %ebp
    3787:	89 e5                	mov    %esp,%ebp
    3789:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    378c:	8b 45 08             	mov    0x8(%ebp),%eax
    378f:	8b 00                	mov    (%eax),%eax
    3791:	89 45 e0             	mov    %eax,-0x20(%ebp)
    3794:	db 45 e0             	fildl  -0x20(%ebp)
    3797:	d9 5d e0             	fstps  -0x20(%ebp)
    379a:	83 ec 0c             	sub    $0xc,%esp
    379d:	ff 75 10             	pushl  0x10(%ebp)
    37a0:	e8 6b e2 ff ff       	call   1a10 <cos>
    37a5:	83 c4 10             	add    $0x10,%esp
    37a8:	d9 5d dc             	fstps  -0x24(%ebp)
    37ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
    37ae:	83 ec 0c             	sub    $0xc,%esp
    37b1:	50                   	push   %eax
    37b2:	e8 90 e1 ff ff       	call   1947 <abs>
    37b7:	83 c4 10             	add    $0x10,%esp
    37ba:	d8 4d e0             	fmuls  -0x20(%ebp)
    37bd:	d9 5d e0             	fstps  -0x20(%ebp)
    37c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    37c3:	8b 00                	mov    (%eax),%eax
    37c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    37c8:	db 45 dc             	fildl  -0x24(%ebp)
    37cb:	d9 5d dc             	fstps  -0x24(%ebp)
    37ce:	83 ec 0c             	sub    $0xc,%esp
    37d1:	ff 75 10             	pushl  0x10(%ebp)
    37d4:	e8 da e3 ff ff       	call   1bb3 <sin>
    37d9:	83 c4 10             	add    $0x10,%esp
    37dc:	d9 5d d8             	fstps  -0x28(%ebp)
    37df:	8b 45 d8             	mov    -0x28(%ebp),%eax
    37e2:	83 ec 0c             	sub    $0xc,%esp
    37e5:	50                   	push   %eax
    37e6:	e8 5c e1 ff ff       	call   1947 <abs>
    37eb:	83 c4 10             	add    $0x10,%esp
    37ee:	d8 4d dc             	fmuls  -0x24(%ebp)
    37f1:	d8 45 e0             	fadds  -0x20(%ebp)
    37f4:	d9 7d e6             	fnstcw -0x1a(%ebp)
    37f7:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    37fb:	b4 0c                	mov    $0xc,%ah
    37fd:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    3801:	d9 6d e4             	fldcw  -0x1c(%ebp)
    3804:	db 5d f4             	fistpl -0xc(%ebp)
    3807:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    380a:	8b 45 08             	mov    0x8(%ebp),%eax
    380d:	8b 00                	mov    (%eax),%eax
    380f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    3812:	db 45 e0             	fildl  -0x20(%ebp)
    3815:	d9 5d e0             	fstps  -0x20(%ebp)
    3818:	83 ec 0c             	sub    $0xc,%esp
    381b:	ff 75 10             	pushl  0x10(%ebp)
    381e:	e8 90 e3 ff ff       	call   1bb3 <sin>
    3823:	83 c4 10             	add    $0x10,%esp
    3826:	d9 5d dc             	fstps  -0x24(%ebp)
    3829:	8b 45 dc             	mov    -0x24(%ebp),%eax
    382c:	83 ec 0c             	sub    $0xc,%esp
    382f:	50                   	push   %eax
    3830:	e8 12 e1 ff ff       	call   1947 <abs>
    3835:	83 c4 10             	add    $0x10,%esp
    3838:	d8 4d e0             	fmuls  -0x20(%ebp)
    383b:	d9 5d e0             	fstps  -0x20(%ebp)
    383e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3841:	8b 00                	mov    (%eax),%eax
    3843:	89 45 dc             	mov    %eax,-0x24(%ebp)
    3846:	db 45 dc             	fildl  -0x24(%ebp)
    3849:	d9 5d dc             	fstps  -0x24(%ebp)
    384c:	83 ec 0c             	sub    $0xc,%esp
    384f:	ff 75 10             	pushl  0x10(%ebp)
    3852:	e8 b9 e1 ff ff       	call   1a10 <cos>
    3857:	83 c4 10             	add    $0x10,%esp
    385a:	d9 5d d8             	fstps  -0x28(%ebp)
    385d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3860:	83 ec 0c             	sub    $0xc,%esp
    3863:	50                   	push   %eax
    3864:	e8 de e0 ff ff       	call   1947 <abs>
    3869:	83 c4 10             	add    $0x10,%esp
    386c:	d8 4d dc             	fmuls  -0x24(%ebp)
    386f:	d8 45 e0             	fadds  -0x20(%ebp)
    3872:	d9 7d e6             	fnstcw -0x1a(%ebp)
    3875:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    3879:	b4 0c                	mov    $0xc,%ah
    387b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    387f:	d9 6d e4             	fldcw  -0x1c(%ebp)
    3882:	db 5d f0             	fistpl -0x10(%ebp)
    3885:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    3888:	8b 45 0c             	mov    0xc(%ebp),%eax
    388b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    388e:	89 10                	mov    %edx,(%eax)
    *width = w;
    3890:	8b 45 08             	mov    0x8(%ebp),%eax
    3893:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3896:	89 10                	mov    %edx,(%eax)
    return 1;
    3898:	b8 01 00 00 00       	mov    $0x1,%eax
}
    389d:	c9                   	leave  
    389e:	c3                   	ret    

0000389f <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    389f:	55                   	push   %ebp
    38a0:	89 e5                	mov    %esp,%ebp
    38a2:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    38a5:	8b 45 08             	mov    0x8(%ebp),%eax
    38a8:	8b 40 04             	mov    0x4(%eax),%eax
    38ab:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    38ae:	db 45 c4             	fildl  -0x3c(%ebp)
    38b1:	d9 05 64 ad 01 00    	flds   0x1ad64
    38b7:	de f9                	fdivrp %st,%st(1)
    38b9:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    38bc:	8b 45 08             	mov    0x8(%ebp),%eax
    38bf:	8b 00                	mov    (%eax),%eax
    38c1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    38c4:	db 45 c4             	fildl  -0x3c(%ebp)
    38c7:	d9 05 64 ad 01 00    	flds   0x1ad64
    38cd:	de f9                	fdivrp %st,%st(1)
    38cf:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    38d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    38d5:	8b 50 04             	mov    0x4(%eax),%edx
    38d8:	8b 45 08             	mov    0x8(%ebp),%eax
    38db:	8b 40 04             	mov    0x4(%eax),%eax
    38de:	29 c2                	sub    %eax,%edx
    38e0:	89 d0                	mov    %edx,%eax
    38e2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    38e5:	db 45 c4             	fildl  -0x3c(%ebp)
    38e8:	d9 05 64 ad 01 00    	flds   0x1ad64
    38ee:	de f9                	fdivrp %st,%st(1)
    38f0:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    38f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    38f6:	8b 10                	mov    (%eax),%edx
    38f8:	8b 45 08             	mov    0x8(%ebp),%eax
    38fb:	8b 00                	mov    (%eax),%eax
    38fd:	29 c2                	sub    %eax,%edx
    38ff:	89 d0                	mov    %edx,%eax
    3901:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3904:	db 45 c4             	fildl  -0x3c(%ebp)
    3907:	d9 05 64 ad 01 00    	flds   0x1ad64
    390d:	de f9                	fdivrp %st,%st(1)
    390f:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    3912:	d9 45 10             	flds   0x10(%ebp)
    3915:	d9 e0                	fchs   
    3917:	83 ec 0c             	sub    $0xc,%esp
    391a:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    391e:	d9 1c 24             	fstps  (%esp)
    3921:	e8 ea e0 ff ff       	call   1a10 <cos>
    3926:	83 c4 10             	add    $0x10,%esp
    3929:	d9 5d c4             	fstps  -0x3c(%ebp)
    392c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    392f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    3932:	d9 45 10             	flds   0x10(%ebp)
    3935:	d9 e0                	fchs   
    3937:	83 ec 0c             	sub    $0xc,%esp
    393a:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    393e:	d9 1c 24             	fstps  (%esp)
    3941:	e8 6d e2 ff ff       	call   1bb3 <sin>
    3946:	83 c4 10             	add    $0x10,%esp
    3949:	d9 5d c4             	fstps  -0x3c(%ebp)
    394c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    394f:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    3952:	d9 ee                	fldz   
    3954:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    3957:	d9 ee                	fldz   
    3959:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    395c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3963:	e9 28 01 00 00       	jmp    3a90 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    3968:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    396f:	e9 0a 01 00 00       	jmp    3a7e <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    3974:	db 45 f4             	fildl  -0xc(%ebp)
    3977:	d8 65 e4             	fsubs  -0x1c(%ebp)
    397a:	d8 65 ec             	fsubs  -0x14(%ebp)
    397d:	d8 4d dc             	fmuls  -0x24(%ebp)
    3980:	db 45 f0             	fildl  -0x10(%ebp)
    3983:	d8 65 e0             	fsubs  -0x20(%ebp)
    3986:	d8 65 e8             	fsubs  -0x18(%ebp)
    3989:	d8 4d d8             	fmuls  -0x28(%ebp)
    398c:	de c1                	faddp  %st,%st(1)
    398e:	d8 45 ec             	fadds  -0x14(%ebp)
    3991:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    3994:	db 45 f0             	fildl  -0x10(%ebp)
    3997:	d8 65 e0             	fsubs  -0x20(%ebp)
    399a:	d8 65 e8             	fsubs  -0x18(%ebp)
    399d:	d8 4d dc             	fmuls  -0x24(%ebp)
    39a0:	db 45 f4             	fildl  -0xc(%ebp)
    39a3:	d8 65 e4             	fsubs  -0x1c(%ebp)
    39a6:	d8 65 ec             	fsubs  -0x14(%ebp)
    39a9:	d8 4d d8             	fmuls  -0x28(%ebp)
    39ac:	de e9                	fsubrp %st,%st(1)
    39ae:	d8 45 e8             	fadds  -0x18(%ebp)
    39b1:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    39b4:	d9 45 d4             	flds   -0x2c(%ebp)
    39b7:	d9 ee                	fldz   
    39b9:	d9 c9                	fxch   %st(1)
    39bb:	df e9                	fucomip %st(1),%st
    39bd:	dd d8                	fstp   %st(0)
    39bf:	0f 93 c0             	setae  %al
    39c2:	83 f0 01             	xor    $0x1,%eax
    39c5:	84 c0                	test   %al,%al
    39c7:	75 52                	jne    3a1b <picTurn+0x17c>
    39c9:	8b 45 08             	mov    0x8(%ebp),%eax
    39cc:	8b 40 04             	mov    0x4(%eax),%eax
    39cf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    39d2:	db 45 c4             	fildl  -0x3c(%ebp)
    39d5:	d9 45 d4             	flds   -0x2c(%ebp)
    39d8:	d9 c9                	fxch   %st(1)
    39da:	df e9                	fucomip %st(1),%st
    39dc:	dd d8                	fstp   %st(0)
    39de:	0f 97 c0             	seta   %al
    39e1:	83 f0 01             	xor    $0x1,%eax
    39e4:	84 c0                	test   %al,%al
    39e6:	75 33                	jne    3a1b <picTurn+0x17c>
    39e8:	d9 45 d0             	flds   -0x30(%ebp)
    39eb:	d9 ee                	fldz   
    39ed:	d9 c9                	fxch   %st(1)
    39ef:	df e9                	fucomip %st(1),%st
    39f1:	dd d8                	fstp   %st(0)
    39f3:	0f 93 c0             	setae  %al
    39f6:	83 f0 01             	xor    $0x1,%eax
    39f9:	84 c0                	test   %al,%al
    39fb:	75 1e                	jne    3a1b <picTurn+0x17c>
    39fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3a00:	8b 00                	mov    (%eax),%eax
    3a02:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3a05:	db 45 c4             	fildl  -0x3c(%ebp)
    3a08:	d9 45 d0             	flds   -0x30(%ebp)
    3a0b:	d9 c9                	fxch   %st(1)
    3a0d:	df e9                	fucomip %st(1),%st
    3a0f:	dd d8                	fstp   %st(0)
    3a11:	0f 97 c0             	seta   %al
    3a14:	83 f0 01             	xor    $0x1,%eax
    3a17:	84 c0                	test   %al,%al
    3a19:	74 2f                	je     3a4a <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    3a1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a1e:	8b 48 08             	mov    0x8(%eax),%ecx
    3a21:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a24:	8b 00                	mov    (%eax),%eax
    3a26:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3a2a:	89 c2                	mov    %eax,%edx
    3a2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3a2f:	01 c2                	add    %eax,%edx
    3a31:	89 d0                	mov    %edx,%eax
    3a33:	01 c0                	add    %eax,%eax
    3a35:	01 d0                	add    %edx,%eax
    3a37:	01 c8                	add    %ecx,%eax
    3a39:	83 ec 08             	sub    $0x8,%esp
    3a3c:	50                   	push   %eax
    3a3d:	68 f1 f6 01 00       	push   $0x1f6f1
    3a42:	e8 9f f6 ff ff       	call   30e6 <setColor>
    3a47:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    3a4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a4d:	8b 48 08             	mov    0x8(%eax),%ecx
    3a50:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a53:	8b 00                	mov    (%eax),%eax
    3a55:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3a59:	89 c2                	mov    %eax,%edx
    3a5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3a5e:	01 c2                	add    %eax,%edx
    3a60:	89 d0                	mov    %edx,%eax
    3a62:	01 c0                	add    %eax,%eax
    3a64:	01 d0                	add    %edx,%eax
    3a66:	01 c8                	add    %ecx,%eax
    3a68:	50                   	push   %eax
    3a69:	ff 75 d0             	pushl  -0x30(%ebp)
    3a6c:	ff 75 d4             	pushl  -0x2c(%ebp)
    3a6f:	ff 75 08             	pushl  0x8(%ebp)
    3a72:	e8 9e f6 ff ff       	call   3115 <mixColor>
    3a77:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    3a7a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    3a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a81:	8b 00                	mov    (%eax),%eax
    3a83:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3a86:	0f 8f e8 fe ff ff    	jg     3974 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    3a8c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a90:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a93:	8b 40 04             	mov    0x4(%eax),%eax
    3a96:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3a99:	0f 8f c9 fe ff ff    	jg     3968 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    3a9f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3aa4:	c9                   	leave  
    3aa5:	c3                   	ret    

00003aa6 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    3aa6:	55                   	push   %ebp
    3aa7:	89 e5                	mov    %esp,%ebp
    3aa9:	53                   	push   %ebx
    3aaa:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    3aad:	8b 45 08             	mov    0x8(%ebp),%eax
    3ab0:	8b 10                	mov    (%eax),%edx
    3ab2:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ab5:	8b 00                	mov    (%eax),%eax
    3ab7:	39 c2                	cmp    %eax,%edx
    3ab9:	75 10                	jne    3acb <picRollingOver+0x25>
    3abb:	8b 45 08             	mov    0x8(%ebp),%eax
    3abe:	8b 50 04             	mov    0x4(%eax),%edx
    3ac1:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ac4:	8b 40 04             	mov    0x4(%eax),%eax
    3ac7:	39 c2                	cmp    %eax,%edx
    3ac9:	74 0a                	je     3ad5 <picRollingOver+0x2f>
        return 0;
    3acb:	b8 00 00 00 00       	mov    $0x0,%eax
    3ad0:	e9 88 00 00 00       	jmp    3b5d <picRollingOver+0xb7>

    int h = src->height;
    3ad5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ad8:	8b 40 04             	mov    0x4(%eax),%eax
    3adb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    3ade:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae1:	8b 00                	mov    (%eax),%eax
    3ae3:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    3ae6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    3aed:	eb 61                	jmp    3b50 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    3aef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3af6:	eb 4c                	jmp    3b44 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    3af8:	8b 45 0c             	mov    0xc(%ebp),%eax
    3afb:	8b 48 08             	mov    0x8(%eax),%ecx
    3afe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3b01:	2b 45 f8             	sub    -0x8(%ebp),%eax
    3b04:	83 e8 01             	sub    $0x1,%eax
    3b07:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3b0b:	89 c2                	mov    %eax,%edx
    3b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b10:	01 c2                	add    %eax,%edx
    3b12:	89 d0                	mov    %edx,%eax
    3b14:	01 c0                	add    %eax,%eax
    3b16:	01 d0                	add    %edx,%eax
    3b18:	01 c1                	add    %eax,%ecx
    3b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b1d:	8b 58 08             	mov    0x8(%eax),%ebx
    3b20:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b23:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3b27:	89 c2                	mov    %eax,%edx
    3b29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b2c:	01 c2                	add    %eax,%edx
    3b2e:	89 d0                	mov    %edx,%eax
    3b30:	01 c0                	add    %eax,%eax
    3b32:	01 d0                	add    %edx,%eax
    3b34:	01 d8                	add    %ebx,%eax
    3b36:	51                   	push   %ecx
    3b37:	50                   	push   %eax
    3b38:	e8 a9 f5 ff ff       	call   30e6 <setColor>
    3b3d:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    3b40:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b47:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    3b4a:	7c ac                	jl     3af8 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    3b4c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3b50:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b53:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3b56:	7c 97                	jl     3aef <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    3b58:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3b5d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3b60:	c9                   	leave  
    3b61:	c3                   	ret    

00003b62 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    3b62:	55                   	push   %ebp
    3b63:	89 e5                	mov    %esp,%ebp
    3b65:	53                   	push   %ebx
    3b66:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    3b69:	8b 45 08             	mov    0x8(%ebp),%eax
    3b6c:	8b 10                	mov    (%eax),%edx
    3b6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b71:	8b 00                	mov    (%eax),%eax
    3b73:	39 c2                	cmp    %eax,%edx
    3b75:	75 10                	jne    3b87 <picTurnAround+0x25>
    3b77:	8b 45 08             	mov    0x8(%ebp),%eax
    3b7a:	8b 50 04             	mov    0x4(%eax),%edx
    3b7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b80:	8b 40 04             	mov    0x4(%eax),%eax
    3b83:	39 c2                	cmp    %eax,%edx
    3b85:	74 0a                	je     3b91 <picTurnAround+0x2f>
        return 0;
    3b87:	b8 00 00 00 00       	mov    $0x0,%eax
    3b8c:	e9 88 00 00 00       	jmp    3c19 <picTurnAround+0xb7>

    int h = src->height;
    3b91:	8b 45 08             	mov    0x8(%ebp),%eax
    3b94:	8b 40 04             	mov    0x4(%eax),%eax
    3b97:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    3b9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9d:	8b 00                	mov    (%eax),%eax
    3b9f:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    3ba2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    3ba9:	eb 61                	jmp    3c0c <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    3bab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3bb2:	eb 4c                	jmp    3c00 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    3bb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    3bb7:	8b 48 08             	mov    0x8(%eax),%ecx
    3bba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bbd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3bc1:	89 c2                	mov    %eax,%edx
    3bc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3bc6:	2b 45 f4             	sub    -0xc(%ebp),%eax
    3bc9:	01 c2                	add    %eax,%edx
    3bcb:	89 d0                	mov    %edx,%eax
    3bcd:	01 c0                	add    %eax,%eax
    3bcf:	01 d0                	add    %edx,%eax
    3bd1:	83 e8 03             	sub    $0x3,%eax
    3bd4:	01 c1                	add    %eax,%ecx
    3bd6:	8b 45 08             	mov    0x8(%ebp),%eax
    3bd9:	8b 58 08             	mov    0x8(%eax),%ebx
    3bdc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bdf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3be3:	89 c2                	mov    %eax,%edx
    3be5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3be8:	01 c2                	add    %eax,%edx
    3bea:	89 d0                	mov    %edx,%eax
    3bec:	01 c0                	add    %eax,%eax
    3bee:	01 d0                	add    %edx,%eax
    3bf0:	01 d8                	add    %ebx,%eax
    3bf2:	51                   	push   %ecx
    3bf3:	50                   	push   %eax
    3bf4:	e8 ed f4 ff ff       	call   30e6 <setColor>
    3bf9:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    3bfc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c03:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    3c06:	7c ac                	jl     3bb4 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    3c08:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3c0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c0f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3c12:	7c 97                	jl     3bab <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    3c14:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3c19:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3c1c:	c9                   	leave  
    3c1d:	c3                   	ret    

00003c1e <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    3c1e:	55                   	push   %ebp
    3c1f:	89 e5                	mov    %esp,%ebp
    3c21:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    3c24:	83 ec 0c             	sub    $0xc,%esp
    3c27:	ff 75 08             	pushl  0x8(%ebp)
    3c2a:	e8 c5 d5 ff ff       	call   11f4 <strlen>
    3c2f:	83 c4 10             	add    $0x10,%esp
    3c32:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    3c35:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c38:	8d 50 ff             	lea    -0x1(%eax),%edx
    3c3b:	8b 45 08             	mov    0x8(%ebp),%eax
    3c3e:	01 d0                	add    %edx,%eax
    3c40:	0f b6 00             	movzbl (%eax),%eax
    3c43:	3c 67                	cmp    $0x67,%al
    3c45:	75 2b                	jne    3c72 <type+0x54>
    3c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c4a:	8d 50 fe             	lea    -0x2(%eax),%edx
    3c4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3c50:	01 d0                	add    %edx,%eax
    3c52:	0f b6 00             	movzbl (%eax),%eax
    3c55:	3c 70                	cmp    $0x70,%al
    3c57:	75 19                	jne    3c72 <type+0x54>
    3c59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c5c:	8d 50 fd             	lea    -0x3(%eax),%edx
    3c5f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c62:	01 d0                	add    %edx,%eax
    3c64:	0f b6 00             	movzbl (%eax),%eax
    3c67:	3c 6a                	cmp    $0x6a,%al
    3c69:	75 07                	jne    3c72 <type+0x54>
    3c6b:	b8 00 00 00 00       	mov    $0x0,%eax
    3c70:	eb 7f                	jmp    3cf1 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    3c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c75:	8d 50 ff             	lea    -0x1(%eax),%edx
    3c78:	8b 45 08             	mov    0x8(%ebp),%eax
    3c7b:	01 d0                	add    %edx,%eax
    3c7d:	0f b6 00             	movzbl (%eax),%eax
    3c80:	3c 70                	cmp    $0x70,%al
    3c82:	75 2b                	jne    3caf <type+0x91>
    3c84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c87:	8d 50 fe             	lea    -0x2(%eax),%edx
    3c8a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c8d:	01 d0                	add    %edx,%eax
    3c8f:	0f b6 00             	movzbl (%eax),%eax
    3c92:	3c 6d                	cmp    $0x6d,%al
    3c94:	75 19                	jne    3caf <type+0x91>
    3c96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c99:	8d 50 fd             	lea    -0x3(%eax),%edx
    3c9c:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9f:	01 d0                	add    %edx,%eax
    3ca1:	0f b6 00             	movzbl (%eax),%eax
    3ca4:	3c 62                	cmp    $0x62,%al
    3ca6:	75 07                	jne    3caf <type+0x91>
    3ca8:	b8 01 00 00 00       	mov    $0x1,%eax
    3cad:	eb 42                	jmp    3cf1 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    3caf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3cb2:	8d 50 ff             	lea    -0x1(%eax),%edx
    3cb5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cb8:	01 d0                	add    %edx,%eax
    3cba:	0f b6 00             	movzbl (%eax),%eax
    3cbd:	3c 67                	cmp    $0x67,%al
    3cbf:	75 2b                	jne    3cec <type+0xce>
    3cc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3cc4:	8d 50 fe             	lea    -0x2(%eax),%edx
    3cc7:	8b 45 08             	mov    0x8(%ebp),%eax
    3cca:	01 d0                	add    %edx,%eax
    3ccc:	0f b6 00             	movzbl (%eax),%eax
    3ccf:	3c 6e                	cmp    $0x6e,%al
    3cd1:	75 19                	jne    3cec <type+0xce>
    3cd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3cd6:	8d 50 fd             	lea    -0x3(%eax),%edx
    3cd9:	8b 45 08             	mov    0x8(%ebp),%eax
    3cdc:	01 d0                	add    %edx,%eax
    3cde:	0f b6 00             	movzbl (%eax),%eax
    3ce1:	3c 70                	cmp    $0x70,%al
    3ce3:	75 07                	jne    3cec <type+0xce>
    3ce5:	b8 02 00 00 00       	mov    $0x2,%eax
    3cea:	eb 05                	jmp    3cf1 <type+0xd3>
    else return NONE;
    3cec:	b8 03 00 00 00       	mov    $0x3,%eax
}
    3cf1:	c9                   	leave  
    3cf2:	c3                   	ret    

00003cf3 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    3cf3:	55                   	push   %ebp
    3cf4:	89 e5                	mov    %esp,%ebp
    3cf6:	56                   	push   %esi
    3cf7:	53                   	push   %ebx
    3cf8:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    3cfb:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    3d02:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    3d09:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    3d10:	83 ec 08             	sub    $0x8,%esp
    3d13:	6a 00                	push   $0x0
    3d15:	ff 75 0c             	pushl  0xc(%ebp)
    3d18:	e8 d9 d6 ff ff       	call   13f6 <open>
    3d1d:	83 c4 10             	add    $0x10,%esp
    3d20:	89 45 ec             	mov    %eax,-0x14(%ebp)
    3d23:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    3d27:	79 2c                	jns    3d55 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    3d29:	83 ec 08             	sub    $0x8,%esp
    3d2c:	ff 75 0c             	pushl  0xc(%ebp)
    3d2f:	68 68 ad 01 00       	push   $0x1ad68
    3d34:	e8 24 d8 ff ff       	call   155d <printf>
    3d39:	83 c4 10             	add    $0x10,%esp
        return bmp;
    3d3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3d3f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3d42:	89 10                	mov    %edx,(%eax)
    3d44:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3d47:	89 50 04             	mov    %edx,0x4(%eax)
    3d4a:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3d4d:	89 50 08             	mov    %edx,0x8(%eax)
    3d50:	e9 2d 02 00 00       	jmp    3f82 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    3d55:	83 ec 04             	sub    $0x4,%esp
    3d58:	6a 0e                	push   $0xe
    3d5a:	8d 45 aa             	lea    -0x56(%ebp),%eax
    3d5d:	50                   	push   %eax
    3d5e:	ff 75 ec             	pushl  -0x14(%ebp)
    3d61:	e8 68 d6 ff ff       	call   13ce <read>
    3d66:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    3d69:	83 ec 04             	sub    $0x4,%esp
    3d6c:	6a 28                	push   $0x28
    3d6e:	8d 45 82             	lea    -0x7e(%ebp),%eax
    3d71:	50                   	push   %eax
    3d72:	ff 75 ec             	pushl  -0x14(%ebp)
    3d75:	e8 54 d6 ff ff       	call   13ce <read>
    3d7a:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    3d7d:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    3d81:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    3d84:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    3d88:	0f b7 d8             	movzwl %ax,%ebx
    3d8b:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    3d8e:	8b 55 ac             	mov    -0x54(%ebp),%edx
    3d91:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    3d95:	0f b7 c0             	movzwl %ax,%eax
    3d98:	83 ec 04             	sub    $0x4,%esp
    3d9b:	6a 36                	push   $0x36
    3d9d:	56                   	push   %esi
    3d9e:	53                   	push   %ebx
    3d9f:	51                   	push   %ecx
    3da0:	52                   	push   %edx
    3da1:	50                   	push   %eax
    3da2:	68 78 ad 01 00       	push   $0x1ad78
    3da7:	e8 b1 d7 ff ff       	call   155d <printf>
    3dac:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    3daf:	8b 45 86             	mov    -0x7a(%ebp),%eax
    3db2:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    3db5:	8b 45 8a             	mov    -0x76(%ebp),%eax
    3db8:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    3dbb:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3dbe:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3dc1:	0f af c2             	imul   %edx,%eax
    3dc4:	89 c2                	mov    %eax,%edx
    3dc6:	89 d0                	mov    %edx,%eax
    3dc8:	01 c0                	add    %eax,%eax
    3dca:	01 d0                	add    %edx,%eax
    3dcc:	83 ec 0c             	sub    $0xc,%esp
    3dcf:	50                   	push   %eax
    3dd0:	e8 5b da ff ff       	call   1830 <malloc>
    3dd5:	83 c4 10             	add    $0x10,%esp
    3dd8:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    3ddb:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3ddf:	0f b7 c0             	movzwl %ax,%eax
    3de2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    3de5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3de8:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    3dec:	83 c0 1f             	add    $0x1f,%eax
    3def:	c1 f8 05             	sar    $0x5,%eax
    3df2:	c1 e0 02             	shl    $0x2,%eax
    3df5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    3df8:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3dfb:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3dff:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    3e02:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3e05:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3e08:	83 ec 08             	sub    $0x8,%esp
    3e0b:	52                   	push   %edx
    3e0c:	50                   	push   %eax
    3e0d:	ff 75 e8             	pushl  -0x18(%ebp)
    3e10:	ff 75 e0             	pushl  -0x20(%ebp)
    3e13:	ff 75 e4             	pushl  -0x1c(%ebp)
    3e16:	68 a0 ad 01 00       	push   $0x1ada0
    3e1b:	e8 3d d7 ff ff       	call   155d <printf>
    3e20:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    3e23:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    3e26:	83 e8 36             	sub    $0x36,%eax
    3e29:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    3e2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3e2f:	83 ec 0c             	sub    $0xc,%esp
    3e32:	50                   	push   %eax
    3e33:	e8 f8 d9 ff ff       	call   1830 <malloc>
    3e38:	83 c4 10             	add    $0x10,%esp
    3e3b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    3e3e:	83 ec 04             	sub    $0x4,%esp
    3e41:	ff 75 dc             	pushl  -0x24(%ebp)
    3e44:	ff 75 d8             	pushl  -0x28(%ebp)
    3e47:	ff 75 ec             	pushl  -0x14(%ebp)
    3e4a:	e8 7f d5 ff ff       	call   13ce <read>
    3e4f:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    3e52:	8b 45 ac             	mov    -0x54(%ebp),%eax
    3e55:	83 ec 0c             	sub    $0xc,%esp
    3e58:	50                   	push   %eax
    3e59:	e8 d2 d9 ff ff       	call   1830 <malloc>
    3e5e:	83 c4 10             	add    $0x10,%esp
    3e61:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    3e64:	8b 45 ac             	mov    -0x54(%ebp),%eax
    3e67:	83 ec 04             	sub    $0x4,%esp
    3e6a:	50                   	push   %eax
    3e6b:	ff 75 d4             	pushl  -0x2c(%ebp)
    3e6e:	ff 75 ec             	pushl  -0x14(%ebp)
    3e71:	e8 58 d5 ff ff       	call   13ce <read>
    3e76:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    3e79:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3e7d:	66 c1 e8 03          	shr    $0x3,%ax
    3e81:	0f b7 c0             	movzwl %ax,%eax
    3e84:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    3e87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3e8e:	e9 c1 00 00 00       	jmp    3f54 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    3e93:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3e96:	2b 45 f4             	sub    -0xc(%ebp),%eax
    3e99:	8d 50 ff             	lea    -0x1(%eax),%edx
    3e9c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3e9f:	0f af c2             	imul   %edx,%eax
    3ea2:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    3ea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ea8:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3eac:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    3eaf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3eb6:	e9 89 00 00 00       	jmp    3f44 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    3ebb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3ebe:	83 c0 01             	add    $0x1,%eax
    3ec1:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    3ec5:	89 c2                	mov    %eax,%edx
    3ec7:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3eca:	01 d0                	add    %edx,%eax
    3ecc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    3ecf:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3ed2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3ed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3ed8:	01 c8                	add    %ecx,%eax
    3eda:	89 c1                	mov    %eax,%ecx
    3edc:	89 c8                	mov    %ecx,%eax
    3ede:	01 c0                	add    %eax,%eax
    3ee0:	01 c8                	add    %ecx,%eax
    3ee2:	01 c2                	add    %eax,%edx
    3ee4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3ee7:	8d 48 ff             	lea    -0x1(%eax),%ecx
    3eea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3eed:	01 c8                	add    %ecx,%eax
    3eef:	0f b6 00             	movzbl (%eax),%eax
    3ef2:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    3ef5:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3ef8:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3efb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3efe:	01 c8                	add    %ecx,%eax
    3f00:	89 c1                	mov    %eax,%ecx
    3f02:	89 c8                	mov    %ecx,%eax
    3f04:	01 c0                	add    %eax,%eax
    3f06:	01 c8                	add    %ecx,%eax
    3f08:	01 c2                	add    %eax,%edx
    3f0a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3f0d:	8d 48 fe             	lea    -0x2(%eax),%ecx
    3f10:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3f13:	01 c8                	add    %ecx,%eax
    3f15:	0f b6 00             	movzbl (%eax),%eax
    3f18:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    3f1b:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3f1e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3f21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3f24:	01 c8                	add    %ecx,%eax
    3f26:	89 c1                	mov    %eax,%ecx
    3f28:	89 c8                	mov    %ecx,%eax
    3f2a:	01 c0                	add    %eax,%eax
    3f2c:	01 c8                	add    %ecx,%eax
    3f2e:	01 c2                	add    %eax,%edx
    3f30:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3f33:	8d 48 fd             	lea    -0x3(%eax),%ecx
    3f36:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3f39:	01 c8                	add    %ecx,%eax
    3f3b:	0f b6 00             	movzbl (%eax),%eax
    3f3e:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    3f40:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    3f44:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3f47:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3f4a:	0f 8f 6b ff ff ff    	jg     3ebb <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    3f50:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3f54:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3f57:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3f5a:	0f 8f 33 ff ff ff    	jg     3e93 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    3f60:	83 ec 0c             	sub    $0xc,%esp
    3f63:	ff 75 ec             	pushl  -0x14(%ebp)
    3f66:	e8 73 d4 ff ff       	call   13de <close>
    3f6b:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3f6e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f71:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3f74:	89 10                	mov    %edx,(%eax)
    3f76:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3f79:	89 50 04             	mov    %edx,0x4(%eax)
    3f7c:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3f7f:	89 50 08             	mov    %edx,0x8(%eax)
}
    3f82:	8b 45 08             	mov    0x8(%ebp),%eax
    3f85:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3f88:	5b                   	pop    %ebx
    3f89:	5e                   	pop    %esi
    3f8a:	5d                   	pop    %ebp
    3f8b:	c2 04 00             	ret    $0x4

00003f8e <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    3f8e:	55                   	push   %ebp
    3f8f:	89 e5                	mov    %esp,%ebp
    3f91:	53                   	push   %ebx
    3f92:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    3f95:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    3f99:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    3f9d:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    3fa1:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    3fa5:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    3fa9:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    3fad:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    3fb1:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    3fb5:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    3fb9:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    3fbd:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    3fc1:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    3fc5:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    3fc9:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    3fcd:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    3fd1:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    3fd5:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    3fd9:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    3fdd:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    3fe1:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    3fe5:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    3fe9:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    3fed:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    3ff1:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    3ff5:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    3ff9:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    3ffd:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    4001:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    4005:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    4009:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    400d:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    4011:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    4015:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    4019:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    401d:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    4021:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    4025:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    4029:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    402d:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    4031:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    4035:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    4039:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    403d:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    4041:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    4045:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    4049:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    404d:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    4051:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    4055:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    4059:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    405d:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    4061:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    4065:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    4069:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    406d:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    4071:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    4075:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    4079:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    407d:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    4081:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    4085:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    4089:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    408d:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    4091:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    4095:	83 ec 0c             	sub    $0xc,%esp
    4098:	68 c8 02 08 00       	push   $0x802c8
    409d:	e8 8e d7 ff ff       	call   1830 <malloc>
    40a2:	83 c4 10             	add    $0x10,%esp
    40a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    40a8:	83 ec 04             	sub    $0x4,%esp
    40ab:	68 c8 02 08 00       	push   $0x802c8
    40b0:	6a 00                	push   $0x0
    40b2:	ff 75 f0             	pushl  -0x10(%ebp)
    40b5:	e8 61 d1 ff ff       	call   121b <memset>
    40ba:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    40bd:	83 ec 08             	sub    $0x8,%esp
    40c0:	6a 00                	push   $0x0
    40c2:	ff 75 0c             	pushl  0xc(%ebp)
    40c5:	e8 2c d3 ff ff       	call   13f6 <open>
    40ca:	83 c4 10             	add    $0x10,%esp
    40cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    40d0:	83 ec 0c             	sub    $0xc,%esp
    40d3:	68 40 42 0f 00       	push   $0xf4240
    40d8:	e8 53 d7 ff ff       	call   1830 <malloc>
    40dd:	83 c4 10             	add    $0x10,%esp
    40e0:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    40e3:	83 ec 04             	sub    $0x4,%esp
    40e6:	68 40 42 0f 00       	push   $0xf4240
    40eb:	ff 75 e8             	pushl  -0x18(%ebp)
    40ee:	ff 75 ec             	pushl  -0x14(%ebp)
    40f1:	e8 d8 d2 ff ff       	call   13ce <read>
    40f6:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    40f9:	83 ec 0c             	sub    $0xc,%esp
    40fc:	ff 75 ec             	pushl  -0x14(%ebp)
    40ff:	e8 da d2 ff ff       	call   13de <close>
    4104:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    4107:	68 40 42 0f 00       	push   $0xf4240
    410c:	ff 75 e8             	pushl  -0x18(%ebp)
    410f:	8d 45 9c             	lea    -0x64(%ebp),%eax
    4112:	50                   	push   %eax
    4113:	ff 75 f0             	pushl  -0x10(%ebp)
    4116:	e8 5e 0c 01 00       	call   14d79 <_DecodeJPEG>
    411b:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    411e:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    4125:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    412c:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    4133:	83 ec 0c             	sub    $0xc,%esp
    4136:	ff 75 f0             	pushl  -0x10(%ebp)
    4139:	e8 29 0b 01 00       	call   14c67 <GetImageSize>
    413e:	83 c4 10             	add    $0x10,%esp
    4141:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    4144:	83 ec 0c             	sub    $0xc,%esp
    4147:	ff 75 f0             	pushl  -0x10(%ebp)
    414a:	e8 e1 0a 01 00       	call   14c30 <GetImage>
    414f:	83 c4 10             	add    $0x10,%esp
    4152:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    4155:	83 ec 0c             	sub    $0xc,%esp
    4158:	ff 75 f0             	pushl  -0x10(%ebp)
    415b:	e8 f1 0a 01 00       	call   14c51 <GetWidth>
    4160:	83 c4 10             	add    $0x10,%esp
    4163:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    4166:	83 ec 0c             	sub    $0xc,%esp
    4169:	ff 75 f0             	pushl  -0x10(%ebp)
    416c:	e8 eb 0a 01 00       	call   14c5c <GetHeight>
    4171:	83 c4 10             	add    $0x10,%esp
    4174:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    4177:	8b 55 90             	mov    -0x70(%ebp),%edx
    417a:	8b 45 94             	mov    -0x6c(%ebp),%eax
    417d:	0f af c2             	imul   %edx,%eax
    4180:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    4183:	8b 55 dc             	mov    -0x24(%ebp),%edx
    4186:	89 d0                	mov    %edx,%eax
    4188:	01 c0                	add    %eax,%eax
    418a:	01 d0                	add    %edx,%eax
    418c:	83 ec 0c             	sub    $0xc,%esp
    418f:	50                   	push   %eax
    4190:	e8 9b d6 ff ff       	call   1830 <malloc>
    4195:	83 c4 10             	add    $0x10,%esp
    4198:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    419b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    41a2:	e9 9c 00 00 00       	jmp    4243 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    41a7:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    41aa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    41ad:	ba 56 55 55 55       	mov    $0x55555556,%edx
    41b2:	89 c8                	mov    %ecx,%eax
    41b4:	f7 ea                	imul   %edx
    41b6:	89 c8                	mov    %ecx,%eax
    41b8:	c1 f8 1f             	sar    $0x1f,%eax
    41bb:	29 c2                	sub    %eax,%edx
    41bd:	89 d0                	mov    %edx,%eax
    41bf:	89 c2                	mov    %eax,%edx
    41c1:	89 d0                	mov    %edx,%eax
    41c3:	01 c0                	add    %eax,%eax
    41c5:	01 d0                	add    %edx,%eax
    41c7:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    41ca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    41cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    41d0:	01 c8                	add    %ecx,%eax
    41d2:	0f b6 00             	movzbl (%eax),%eax
    41d5:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    41d8:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    41db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    41de:	ba 56 55 55 55       	mov    $0x55555556,%edx
    41e3:	89 c8                	mov    %ecx,%eax
    41e5:	f7 ea                	imul   %edx
    41e7:	89 c8                	mov    %ecx,%eax
    41e9:	c1 f8 1f             	sar    $0x1f,%eax
    41ec:	29 c2                	sub    %eax,%edx
    41ee:	89 d0                	mov    %edx,%eax
    41f0:	89 c2                	mov    %eax,%edx
    41f2:	89 d0                	mov    %edx,%eax
    41f4:	01 c0                	add    %eax,%eax
    41f6:	01 d0                	add    %edx,%eax
    41f8:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    41fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    41fe:	8d 48 01             	lea    0x1(%eax),%ecx
    4201:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4204:	01 c8                	add    %ecx,%eax
    4206:	0f b6 00             	movzbl (%eax),%eax
    4209:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    420c:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    420f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4212:	ba 56 55 55 55       	mov    $0x55555556,%edx
    4217:	89 c8                	mov    %ecx,%eax
    4219:	f7 ea                	imul   %edx
    421b:	89 c8                	mov    %ecx,%eax
    421d:	c1 f8 1f             	sar    $0x1f,%eax
    4220:	29 c2                	sub    %eax,%edx
    4222:	89 d0                	mov    %edx,%eax
    4224:	89 c2                	mov    %eax,%edx
    4226:	89 d0                	mov    %edx,%eax
    4228:	01 c0                	add    %eax,%eax
    422a:	01 d0                	add    %edx,%eax
    422c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    422f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4232:	8d 48 02             	lea    0x2(%eax),%ecx
    4235:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4238:	01 c8                	add    %ecx,%eax
    423a:	0f b6 00             	movzbl (%eax),%eax
    423d:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    423f:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    4243:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4246:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    4249:	0f 8c 58 ff ff ff    	jl     41a7 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    424f:	8b 45 08             	mov    0x8(%ebp),%eax
    4252:	8b 55 90             	mov    -0x70(%ebp),%edx
    4255:	89 10                	mov    %edx,(%eax)
    4257:	8b 55 94             	mov    -0x6c(%ebp),%edx
    425a:	89 50 04             	mov    %edx,0x4(%eax)
    425d:	8b 55 98             	mov    -0x68(%ebp),%edx
    4260:	89 50 08             	mov    %edx,0x8(%eax)
}
    4263:	8b 45 08             	mov    0x8(%ebp),%eax
    4266:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4269:	c9                   	leave  
    426a:	c2 04 00             	ret    $0x4

0000426d <LoadPng>:

PBitmap LoadPng(char* filename){
    426d:	55                   	push   %ebp
    426e:	89 e5                	mov    %esp,%ebp
    4270:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    4273:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    427a:	ff 75 0c             	pushl  0xc(%ebp)
    427d:	8d 45 e0             	lea    -0x20(%ebp),%eax
    4280:	50                   	push   %eax
    4281:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    4284:	50                   	push   %eax
    4285:	8d 45 e8             	lea    -0x18(%ebp),%eax
    4288:	50                   	push   %eax
    4289:	e8 d3 d3 00 00       	call   11661 <lodepng_decode24_file>
    428e:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    4291:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4294:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    4297:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    429a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    429d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    42a4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    42a7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    42aa:	0f af c2             	imul   %edx,%eax
    42ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    42b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    42b3:	89 d0                	mov    %edx,%eax
    42b5:	01 c0                	add    %eax,%eax
    42b7:	01 d0                	add    %edx,%eax
    42b9:	83 ec 0c             	sub    $0xc,%esp
    42bc:	50                   	push   %eax
    42bd:	e8 6e d5 ff ff       	call   1830 <malloc>
    42c2:	83 c4 10             	add    $0x10,%esp
    42c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    42c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    42cf:	e9 87 00 00 00       	jmp    435b <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    42d4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    42d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42da:	89 d0                	mov    %edx,%eax
    42dc:	01 c0                	add    %eax,%eax
    42de:	01 d0                	add    %edx,%eax
    42e0:	01 c8                	add    %ecx,%eax
    42e2:	0f b6 00             	movzbl (%eax),%eax
    42e5:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    42e8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    42eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42ee:	89 d0                	mov    %edx,%eax
    42f0:	01 c0                	add    %eax,%eax
    42f2:	01 d0                	add    %edx,%eax
    42f4:	83 c0 01             	add    $0x1,%eax
    42f7:	01 c8                	add    %ecx,%eax
    42f9:	0f b6 00             	movzbl (%eax),%eax
    42fc:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    42ff:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    4302:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4305:	89 d0                	mov    %edx,%eax
    4307:	01 c0                	add    %eax,%eax
    4309:	01 d0                	add    %edx,%eax
    430b:	83 c0 02             	add    $0x2,%eax
    430e:	01 c8                	add    %ecx,%eax
    4310:	0f b6 00             	movzbl (%eax),%eax
    4313:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    4316:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    4319:	8b 55 f4             	mov    -0xc(%ebp),%edx
    431c:	89 d0                	mov    %edx,%eax
    431e:	01 c0                	add    %eax,%eax
    4320:	01 d0                	add    %edx,%eax
    4322:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    4325:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    4329:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    432c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    432f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4332:	89 d0                	mov    %edx,%eax
    4334:	01 c0                	add    %eax,%eax
    4336:	01 d0                	add    %edx,%eax
    4338:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    433b:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    433f:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    4342:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    4345:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4348:	89 d0                	mov    %edx,%eax
    434a:	01 c0                	add    %eax,%eax
    434c:	01 d0                	add    %edx,%eax
    434e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    4351:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    4355:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    4357:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    435b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    435e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4361:	0f 8c 6d ff ff ff    	jl     42d4 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    4367:	8b 45 e8             	mov    -0x18(%ebp),%eax
    436a:	83 ec 0c             	sub    $0xc,%esp
    436d:	50                   	push   %eax
    436e:	e8 7b d3 ff ff       	call   16ee <free>
    4373:	83 c4 10             	add    $0x10,%esp
    return bmp;
    4376:	8b 45 08             	mov    0x8(%ebp),%eax
    4379:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    437c:	89 10                	mov    %edx,(%eax)
    437e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4381:	89 50 04             	mov    %edx,0x4(%eax)
    4384:	8b 55 dc             	mov    -0x24(%ebp),%edx
    4387:	89 50 08             	mov    %edx,0x8(%eax)

}
    438a:	8b 45 08             	mov    0x8(%ebp),%eax
    438d:	c9                   	leave  
    438e:	c2 04 00             	ret    $0x4

00004391 <LoadImg>:

PBitmap LoadImg(char* filename){
    4391:	55                   	push   %ebp
    4392:	89 e5                	mov    %esp,%ebp
    4394:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    4397:	83 ec 0c             	sub    $0xc,%esp
    439a:	ff 75 0c             	pushl  0xc(%ebp)
    439d:	e8 7c f8 ff ff       	call   3c1e <type>
    43a2:	83 c4 10             	add    $0x10,%esp
    43a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    43a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43ab:	83 f8 01             	cmp    $0x1,%eax
    43ae:	74 1d                	je     43cd <LoadImg+0x3c>
    43b0:	83 f8 02             	cmp    $0x2,%eax
    43b3:	74 2c                	je     43e1 <LoadImg+0x50>
    43b5:	85 c0                	test   %eax,%eax
    43b7:	75 3c                	jne    43f5 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    43b9:	8b 45 08             	mov    0x8(%ebp),%eax
    43bc:	83 ec 08             	sub    $0x8,%esp
    43bf:	ff 75 0c             	pushl  0xc(%ebp)
    43c2:	50                   	push   %eax
    43c3:	e8 c6 fb ff ff       	call   3f8e <LoadJpeg>
    43c8:	83 c4 0c             	add    $0xc,%esp
    43cb:	eb 3c                	jmp    4409 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    43cd:	8b 45 08             	mov    0x8(%ebp),%eax
    43d0:	83 ec 08             	sub    $0x8,%esp
    43d3:	ff 75 0c             	pushl  0xc(%ebp)
    43d6:	50                   	push   %eax
    43d7:	e8 17 f9 ff ff       	call   3cf3 <LoadBmp>
    43dc:	83 c4 0c             	add    $0xc,%esp
    43df:	eb 28                	jmp    4409 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    43e1:	8b 45 08             	mov    0x8(%ebp),%eax
    43e4:	83 ec 08             	sub    $0x8,%esp
    43e7:	ff 75 0c             	pushl  0xc(%ebp)
    43ea:	50                   	push   %eax
    43eb:	e8 7d fe ff ff       	call   426d <LoadPng>
    43f0:	83 c4 0c             	add    $0xc,%esp
    43f3:	eb 14                	jmp    4409 <LoadImg+0x78>

        default: return bmp;
    43f5:	8b 45 08             	mov    0x8(%ebp),%eax
    43f8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    43fb:	89 10                	mov    %edx,(%eax)
    43fd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4400:	89 50 04             	mov    %edx,0x4(%eax)
    4403:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4406:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    4409:	8b 45 08             	mov    0x8(%ebp),%eax
    440c:	c9                   	leave  
    440d:	c2 04 00             	ret    $0x4

00004410 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    4410:	55                   	push   %ebp
    4411:	89 e5                	mov    %esp,%ebp
    4413:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    4416:	8b 45 08             	mov    0x8(%ebp),%eax
    4419:	83 ec 0c             	sub    $0xc,%esp
    441c:	50                   	push   %eax
    441d:	e8 0e d4 ff ff       	call   1830 <malloc>
    4422:	83 c4 10             	add    $0x10,%esp
}
    4425:	c9                   	leave  
    4426:	c3                   	ret    

00004427 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    4427:	55                   	push   %ebp
    4428:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    442a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    442f:	5d                   	pop    %ebp
    4430:	c3                   	ret    

00004431 <lodepng_free>:

static void lodepng_free(void* ptr) {
    4431:	55                   	push   %ebp
    4432:	89 e5                	mov    %esp,%ebp
    4434:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    4437:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    443b:	74 0e                	je     444b <lodepng_free+0x1a>
    free(ptr);
    443d:	83 ec 0c             	sub    $0xc,%esp
    4440:	ff 75 08             	pushl  0x8(%ebp)
    4443:	e8 a6 d2 ff ff       	call   16ee <free>
    4448:	83 c4 10             	add    $0x10,%esp
}
    444b:	90                   	nop
    444c:	c9                   	leave  
    444d:	c3                   	ret    

0000444e <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    444e:	55                   	push   %ebp
    444f:	89 e5                	mov    %esp,%ebp
    4451:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    4454:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    445b:	eb 19                	jmp    4476 <lodepng_memcpy+0x28>
    445d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4460:	8b 45 08             	mov    0x8(%ebp),%eax
    4463:	01 c2                	add    %eax,%edx
    4465:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4468:	8b 45 0c             	mov    0xc(%ebp),%eax
    446b:	01 c8                	add    %ecx,%eax
    446d:	0f b6 00             	movzbl (%eax),%eax
    4470:	88 02                	mov    %al,(%edx)
    4472:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4476:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4479:	3b 45 10             	cmp    0x10(%ebp),%eax
    447c:	7c df                	jl     445d <lodepng_memcpy+0xf>
}
    447e:	90                   	nop
    447f:	c9                   	leave  
    4480:	c3                   	ret    

00004481 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    4481:	55                   	push   %ebp
    4482:	89 e5                	mov    %esp,%ebp
    4484:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    4487:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    448e:	eb 11                	jmp    44a1 <lodepng_memset+0x20>
    4490:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4493:	8b 45 08             	mov    0x8(%ebp),%eax
    4496:	01 d0                	add    %edx,%eax
    4498:	8b 55 0c             	mov    0xc(%ebp),%edx
    449b:	88 10                	mov    %dl,(%eax)
    449d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    44a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44a4:	3b 45 10             	cmp    0x10(%ebp),%eax
    44a7:	7c e7                	jl     4490 <lodepng_memset+0xf>
}
    44a9:	90                   	nop
    44aa:	c9                   	leave  
    44ab:	c3                   	ret    

000044ac <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    44ac:	55                   	push   %ebp
    44ad:	89 e5                	mov    %esp,%ebp
    44af:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    44b2:	8b 45 08             	mov    0x8(%ebp),%eax
    44b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    44b8:	eb 04                	jmp    44be <lodepng_strlen+0x12>
    44ba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    44be:	8b 45 08             	mov    0x8(%ebp),%eax
    44c1:	0f b6 00             	movzbl (%eax),%eax
    44c4:	84 c0                	test   %al,%al
    44c6:	75 f2                	jne    44ba <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    44c8:	8b 55 08             	mov    0x8(%ebp),%edx
    44cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44ce:	29 c2                	sub    %eax,%edx
    44d0:	89 d0                	mov    %edx,%eax
}
    44d2:	c9                   	leave  
    44d3:	c3                   	ret    

000044d4 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    44d4:	55                   	push   %ebp
    44d5:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    44d7:	8b 55 08             	mov    0x8(%ebp),%edx
    44da:	8b 45 0c             	mov    0xc(%ebp),%eax
    44dd:	01 c2                	add    %eax,%edx
    44df:	8b 45 10             	mov    0x10(%ebp),%eax
    44e2:	89 10                	mov    %edx,(%eax)
  return *result < a;
    44e4:	8b 45 10             	mov    0x10(%ebp),%eax
    44e7:	8b 00                	mov    (%eax),%eax
    44e9:	3b 45 08             	cmp    0x8(%ebp),%eax
    44ec:	0f 9c c0             	setl   %al
    44ef:	0f b6 c0             	movzbl %al,%eax
}
    44f2:	5d                   	pop    %ebp
    44f3:	c3                   	ret    

000044f4 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    44f4:	55                   	push   %ebp
    44f5:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    44f7:	8b 45 08             	mov    0x8(%ebp),%eax
    44fa:	0f af 45 0c          	imul   0xc(%ebp),%eax
    44fe:	89 c2                	mov    %eax,%edx
    4500:	8b 45 10             	mov    0x10(%ebp),%eax
    4503:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    4505:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    4509:	74 15                	je     4520 <lodepng_mulofl+0x2c>
    450b:	8b 45 10             	mov    0x10(%ebp),%eax
    450e:	8b 00                	mov    (%eax),%eax
    4510:	99                   	cltd   
    4511:	f7 7d 08             	idivl  0x8(%ebp)
    4514:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4517:	74 07                	je     4520 <lodepng_mulofl+0x2c>
    4519:	b8 01 00 00 00       	mov    $0x1,%eax
    451e:	eb 05                	jmp    4525 <lodepng_mulofl+0x31>
    4520:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4525:	5d                   	pop    %ebp
    4526:	c3                   	ret    

00004527 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    4527:	55                   	push   %ebp
    4528:	89 e5                	mov    %esp,%ebp
    452a:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    452d:	8d 45 fc             	lea    -0x4(%ebp),%eax
    4530:	50                   	push   %eax
    4531:	ff 75 0c             	pushl  0xc(%ebp)
    4534:	ff 75 08             	pushl  0x8(%ebp)
    4537:	e8 98 ff ff ff       	call   44d4 <lodepng_addofl>
    453c:	83 c4 0c             	add    $0xc,%esp
    453f:	85 c0                	test   %eax,%eax
    4541:	74 07                	je     454a <lodepng_gtofl+0x23>
    4543:	b8 01 00 00 00       	mov    $0x1,%eax
    4548:	eb 0c                	jmp    4556 <lodepng_gtofl+0x2f>
  return d > c;
    454a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    454d:	3b 45 10             	cmp    0x10(%ebp),%eax
    4550:	0f 9f c0             	setg   %al
    4553:	0f b6 c0             	movzbl %al,%eax
}
    4556:	c9                   	leave  
    4557:	c3                   	ret    

00004558 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    4558:	55                   	push   %ebp
    4559:	89 e5                	mov    %esp,%ebp
    455b:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    455e:	8b 45 08             	mov    0x8(%ebp),%eax
    4561:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    4568:	8b 45 08             	mov    0x8(%ebp),%eax
    456b:	8b 50 08             	mov    0x8(%eax),%edx
    456e:	8b 45 08             	mov    0x8(%ebp),%eax
    4571:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    4574:	8b 45 08             	mov    0x8(%ebp),%eax
    4577:	8b 00                	mov    (%eax),%eax
    4579:	83 ec 0c             	sub    $0xc,%esp
    457c:	50                   	push   %eax
    457d:	e8 af fe ff ff       	call   4431 <lodepng_free>
    4582:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    4585:	8b 45 08             	mov    0x8(%ebp),%eax
    4588:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    458e:	90                   	nop
    458f:	c9                   	leave  
    4590:	c3                   	ret    

00004591 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    4591:	55                   	push   %ebp
    4592:	89 e5                	mov    %esp,%ebp
    4594:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    4597:	8b 45 0c             	mov    0xc(%ebp),%eax
    459a:	c1 e0 02             	shl    $0x2,%eax
    459d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    45a0:	8b 45 08             	mov    0x8(%ebp),%eax
    45a3:	8b 40 08             	mov    0x8(%eax),%eax
    45a6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    45a9:	7d 46                	jge    45f1 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    45ab:	8b 45 08             	mov    0x8(%ebp),%eax
    45ae:	8b 40 08             	mov    0x8(%eax),%eax
    45b1:	d1 f8                	sar    %eax
    45b3:	89 c2                	mov    %eax,%edx
    45b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    45b8:	01 d0                	add    %edx,%eax
    45ba:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    45bd:	8b 45 08             	mov    0x8(%ebp),%eax
    45c0:	8b 00                	mov    (%eax),%eax
    45c2:	ff 75 f8             	pushl  -0x8(%ebp)
    45c5:	50                   	push   %eax
    45c6:	e8 5c fe ff ff       	call   4427 <lodepng_realloc>
    45cb:	83 c4 08             	add    $0x8,%esp
    45ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    45d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    45d5:	74 13                	je     45ea <uivector_resize+0x59>
      p->allocsize = newsize;
    45d7:	8b 45 08             	mov    0x8(%ebp),%eax
    45da:	8b 55 f8             	mov    -0x8(%ebp),%edx
    45dd:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    45e0:	8b 45 08             	mov    0x8(%ebp),%eax
    45e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45e6:	89 10                	mov    %edx,(%eax)
    45e8:	eb 07                	jmp    45f1 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    45ea:	b8 00 00 00 00       	mov    $0x0,%eax
    45ef:	eb 0e                	jmp    45ff <uivector_resize+0x6e>
  }
  p->size = size;
    45f1:	8b 45 08             	mov    0x8(%ebp),%eax
    45f4:	8b 55 0c             	mov    0xc(%ebp),%edx
    45f7:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    45fa:	b8 01 00 00 00       	mov    $0x1,%eax
}
    45ff:	c9                   	leave  
    4600:	c3                   	ret    

00004601 <uivector_init>:

static void uivector_init(uivector* p) {
    4601:	55                   	push   %ebp
    4602:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    4604:	8b 45 08             	mov    0x8(%ebp),%eax
    4607:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    460d:	8b 45 08             	mov    0x8(%ebp),%eax
    4610:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    4617:	8b 45 08             	mov    0x8(%ebp),%eax
    461a:	8b 50 08             	mov    0x8(%eax),%edx
    461d:	8b 45 08             	mov    0x8(%ebp),%eax
    4620:	89 50 04             	mov    %edx,0x4(%eax)
}
    4623:	90                   	nop
    4624:	5d                   	pop    %ebp
    4625:	c3                   	ret    

00004626 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    4626:	55                   	push   %ebp
    4627:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    4629:	8b 45 08             	mov    0x8(%ebp),%eax
    462c:	8b 40 04             	mov    0x4(%eax),%eax
    462f:	83 c0 01             	add    $0x1,%eax
    4632:	50                   	push   %eax
    4633:	ff 75 08             	pushl  0x8(%ebp)
    4636:	e8 56 ff ff ff       	call   4591 <uivector_resize>
    463b:	83 c4 08             	add    $0x8,%esp
    463e:	85 c0                	test   %eax,%eax
    4640:	75 07                	jne    4649 <uivector_push_back+0x23>
    4642:	b8 00 00 00 00       	mov    $0x0,%eax
    4647:	eb 1f                	jmp    4668 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    4649:	8b 45 08             	mov    0x8(%ebp),%eax
    464c:	8b 10                	mov    (%eax),%edx
    464e:	8b 45 08             	mov    0x8(%ebp),%eax
    4651:	8b 40 04             	mov    0x4(%eax),%eax
    4654:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    4659:	c1 e0 02             	shl    $0x2,%eax
    465c:	01 c2                	add    %eax,%edx
    465e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4661:	89 02                	mov    %eax,(%edx)
  return 1;
    4663:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4668:	c9                   	leave  
    4669:	c3                   	ret    

0000466a <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    466a:	55                   	push   %ebp
    466b:	89 e5                	mov    %esp,%ebp
    466d:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    4670:	8b 45 08             	mov    0x8(%ebp),%eax
    4673:	8b 40 08             	mov    0x8(%eax),%eax
    4676:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4679:	7d 46                	jge    46c1 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    467b:	8b 45 08             	mov    0x8(%ebp),%eax
    467e:	8b 40 08             	mov    0x8(%eax),%eax
    4681:	d1 f8                	sar    %eax
    4683:	89 c2                	mov    %eax,%edx
    4685:	8b 45 0c             	mov    0xc(%ebp),%eax
    4688:	01 d0                	add    %edx,%eax
    468a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    468d:	8b 45 08             	mov    0x8(%ebp),%eax
    4690:	8b 00                	mov    (%eax),%eax
    4692:	ff 75 fc             	pushl  -0x4(%ebp)
    4695:	50                   	push   %eax
    4696:	e8 8c fd ff ff       	call   4427 <lodepng_realloc>
    469b:	83 c4 08             	add    $0x8,%esp
    469e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    46a1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    46a5:	74 13                	je     46ba <ucvector_resize+0x50>
      p->allocsize = newsize;
    46a7:	8b 45 08             	mov    0x8(%ebp),%eax
    46aa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    46ad:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    46b0:	8b 45 08             	mov    0x8(%ebp),%eax
    46b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    46b6:	89 10                	mov    %edx,(%eax)
    46b8:	eb 07                	jmp    46c1 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    46ba:	b8 00 00 00 00       	mov    $0x0,%eax
    46bf:	eb 0e                	jmp    46cf <ucvector_resize+0x65>
  }
  p->size = size;
    46c1:	8b 45 08             	mov    0x8(%ebp),%eax
    46c4:	8b 55 0c             	mov    0xc(%ebp),%edx
    46c7:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    46ca:	b8 01 00 00 00       	mov    $0x1,%eax
}
    46cf:	c9                   	leave  
    46d0:	c3                   	ret    

000046d1 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    46d1:	55                   	push   %ebp
    46d2:	89 e5                	mov    %esp,%ebp
    46d4:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    46d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    46da:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    46dd:	8b 45 10             	mov    0x10(%ebp),%eax
    46e0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    46e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    46e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    46e9:	8b 45 08             	mov    0x8(%ebp),%eax
    46ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46ef:	89 10                	mov    %edx,(%eax)
    46f1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    46f4:	89 50 04             	mov    %edx,0x4(%eax)
    46f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    46fa:	89 50 08             	mov    %edx,0x8(%eax)
}
    46fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4700:	c9                   	leave  
    4701:	c2 04 00             	ret    $0x4

00004704 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    4704:	55                   	push   %ebp
    4705:	89 e5                	mov    %esp,%ebp
    4707:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    470a:	8b 45 08             	mov    0x8(%ebp),%eax
    470d:	8b 00                	mov    (%eax),%eax
    470f:	83 ec 0c             	sub    $0xc,%esp
    4712:	50                   	push   %eax
    4713:	e8 19 fd ff ff       	call   4431 <lodepng_free>
    4718:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    471b:	8b 45 08             	mov    0x8(%ebp),%eax
    471e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    4724:	90                   	nop
    4725:	c9                   	leave  
    4726:	c3                   	ret    

00004727 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    4727:	55                   	push   %ebp
    4728:	89 e5                	mov    %esp,%ebp
    472a:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    472d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4730:	83 c0 01             	add    $0x1,%eax
    4733:	83 ec 0c             	sub    $0xc,%esp
    4736:	50                   	push   %eax
    4737:	e8 d4 fc ff ff       	call   4410 <lodepng_malloc>
    473c:	83 c4 10             	add    $0x10,%esp
    473f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    4742:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4746:	74 1f                	je     4767 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    4748:	83 ec 04             	sub    $0x4,%esp
    474b:	ff 75 0c             	pushl  0xc(%ebp)
    474e:	ff 75 08             	pushl  0x8(%ebp)
    4751:	ff 75 f4             	pushl  -0xc(%ebp)
    4754:	e8 f5 fc ff ff       	call   444e <lodepng_memcpy>
    4759:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    475c:	8b 55 0c             	mov    0xc(%ebp),%edx
    475f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4762:	01 d0                	add    %edx,%eax
    4764:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    4767:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    476a:	c9                   	leave  
    476b:	c3                   	ret    

0000476c <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    476c:	55                   	push   %ebp
    476d:	89 e5                	mov    %esp,%ebp
    476f:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    4772:	ff 75 08             	pushl  0x8(%ebp)
    4775:	e8 32 fd ff ff       	call   44ac <lodepng_strlen>
    477a:	83 c4 04             	add    $0x4,%esp
    477d:	83 ec 08             	sub    $0x8,%esp
    4780:	50                   	push   %eax
    4781:	ff 75 08             	pushl  0x8(%ebp)
    4784:	e8 9e ff ff ff       	call   4727 <alloc_string_sized>
    4789:	83 c4 10             	add    $0x10,%esp
}
    478c:	c9                   	leave  
    478d:	c3                   	ret    

0000478e <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    478e:	55                   	push   %ebp
    478f:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    4791:	8b 45 08             	mov    0x8(%ebp),%eax
    4794:	0f b6 00             	movzbl (%eax),%eax
    4797:	0f b6 c0             	movzbl %al,%eax
    479a:	c1 e0 18             	shl    $0x18,%eax
    479d:	89 c2                	mov    %eax,%edx
    479f:	8b 45 08             	mov    0x8(%ebp),%eax
    47a2:	83 c0 01             	add    $0x1,%eax
    47a5:	0f b6 00             	movzbl (%eax),%eax
    47a8:	0f b6 c0             	movzbl %al,%eax
    47ab:	c1 e0 10             	shl    $0x10,%eax
    47ae:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    47b0:	8b 45 08             	mov    0x8(%ebp),%eax
    47b3:	83 c0 02             	add    $0x2,%eax
    47b6:	0f b6 00             	movzbl (%eax),%eax
    47b9:	0f b6 c0             	movzbl %al,%eax
    47bc:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    47bf:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    47c1:	8b 45 08             	mov    0x8(%ebp),%eax
    47c4:	83 c0 03             	add    $0x3,%eax
    47c7:	0f b6 00             	movzbl (%eax),%eax
    47ca:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    47cd:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    47cf:	5d                   	pop    %ebp
    47d0:	c3                   	ret    

000047d1 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    47d1:	55                   	push   %ebp
    47d2:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    47d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    47d7:	c1 e8 18             	shr    $0x18,%eax
    47da:	89 c2                	mov    %eax,%edx
    47dc:	8b 45 08             	mov    0x8(%ebp),%eax
    47df:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    47e1:	8b 45 08             	mov    0x8(%ebp),%eax
    47e4:	83 c0 01             	add    $0x1,%eax
    47e7:	8b 55 0c             	mov    0xc(%ebp),%edx
    47ea:	c1 ea 10             	shr    $0x10,%edx
    47ed:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    47ef:	8b 45 08             	mov    0x8(%ebp),%eax
    47f2:	83 c0 02             	add    $0x2,%eax
    47f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    47f8:	c1 ea 08             	shr    $0x8,%edx
    47fb:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    47fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4800:	83 c0 03             	add    $0x3,%eax
    4803:	8b 55 0c             	mov    0xc(%ebp),%edx
    4806:	88 10                	mov    %dl,(%eax)
}
    4808:	90                   	nop
    4809:	5d                   	pop    %ebp
    480a:	c3                   	ret    

0000480b <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    480b:	55                   	push   %ebp
    480c:	89 e5                	mov    %esp,%ebp
    480e:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    4811:	83 ec 08             	sub    $0x8,%esp
    4814:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    4817:	50                   	push   %eax
    4818:	ff 75 08             	pushl  0x8(%ebp)
    481b:	e8 b7 ca ff ff       	call   12d7 <stat>
    4820:	83 c4 10             	add    $0x10,%esp
  return s.size;
    4823:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4826:	c9                   	leave  
    4827:	c3                   	ret    

00004828 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    4828:	55                   	push   %ebp
    4829:	89 e5                	mov    %esp,%ebp
    482b:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    482e:	83 ec 08             	sub    $0x8,%esp
    4831:	6a 00                	push   $0x0
    4833:	ff 75 10             	pushl  0x10(%ebp)
    4836:	e8 bb cb ff ff       	call   13f6 <open>
    483b:	83 c4 10             	add    $0x10,%esp
    483e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    4841:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4845:	79 07                	jns    484e <lodepng_buffer_file+0x26>
  {
      return -1;
    4847:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    484c:	eb 19                	jmp    4867 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    484e:	83 ec 04             	sub    $0x4,%esp
    4851:	ff 75 0c             	pushl  0xc(%ebp)
    4854:	ff 75 08             	pushl  0x8(%ebp)
    4857:	ff 75 f4             	pushl  -0xc(%ebp)
    485a:	e8 6f cb ff ff       	call   13ce <read>
    485f:	83 c4 10             	add    $0x10,%esp
  return 0;
    4862:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4867:	c9                   	leave  
    4868:	c3                   	ret    

00004869 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    4869:	55                   	push   %ebp
    486a:	89 e5                	mov    %esp,%ebp
    486c:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    486f:	83 ec 0c             	sub    $0xc,%esp
    4872:	ff 75 10             	pushl  0x10(%ebp)
    4875:	e8 91 ff ff ff       	call   480b <lodepng_filesize>
    487a:	83 c4 10             	add    $0x10,%esp
    487d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    4880:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4884:	79 07                	jns    488d <lodepng_load_file+0x24>
    4886:	b8 4e 00 00 00       	mov    $0x4e,%eax
    488b:	eb 4a                	jmp    48d7 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    488d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4890:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4893:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    4895:	83 ec 0c             	sub    $0xc,%esp
    4898:	ff 75 f4             	pushl  -0xc(%ebp)
    489b:	e8 70 fb ff ff       	call   4410 <lodepng_malloc>
    48a0:	83 c4 10             	add    $0x10,%esp
    48a3:	89 c2                	mov    %eax,%edx
    48a5:	8b 45 08             	mov    0x8(%ebp),%eax
    48a8:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    48aa:	8b 45 08             	mov    0x8(%ebp),%eax
    48ad:	8b 00                	mov    (%eax),%eax
    48af:	85 c0                	test   %eax,%eax
    48b1:	75 0d                	jne    48c0 <lodepng_load_file+0x57>
    48b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    48b7:	7e 07                	jle    48c0 <lodepng_load_file+0x57>
    48b9:	b8 53 00 00 00       	mov    $0x53,%eax
    48be:	eb 17                	jmp    48d7 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    48c0:	8b 45 08             	mov    0x8(%ebp),%eax
    48c3:	8b 00                	mov    (%eax),%eax
    48c5:	83 ec 04             	sub    $0x4,%esp
    48c8:	ff 75 10             	pushl  0x10(%ebp)
    48cb:	ff 75 f4             	pushl  -0xc(%ebp)
    48ce:	50                   	push   %eax
    48cf:	e8 54 ff ff ff       	call   4828 <lodepng_buffer_file>
    48d4:	83 c4 10             	add    $0x10,%esp
}
    48d7:	c9                   	leave  
    48d8:	c3                   	ret    

000048d9 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    48d9:	55                   	push   %ebp
    48da:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    48dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    48e1:	5d                   	pop    %ebp
    48e2:	c3                   	ret    

000048e3 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    48e3:	55                   	push   %ebp
    48e4:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    48e6:	8b 45 08             	mov    0x8(%ebp),%eax
    48e9:	8b 55 0c             	mov    0xc(%ebp),%edx
    48ec:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    48ee:	8b 45 08             	mov    0x8(%ebp),%eax
    48f1:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    48f5:	90                   	nop
    48f6:	5d                   	pop    %ebp
    48f7:	c3                   	ret    

000048f8 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    48f8:	55                   	push   %ebp
    48f9:	89 e5                	mov    %esp,%ebp
    48fb:	56                   	push   %esi
    48fc:	53                   	push   %ebx
    48fd:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    4900:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    4904:	0f 85 aa 00 00 00    	jne    49b4 <writeBits+0xbc>
    WRITEBIT(writer, value);
    490a:	8b 45 08             	mov    0x8(%ebp),%eax
    490d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4911:	0f b6 c0             	movzbl %al,%eax
    4914:	83 e0 07             	and    $0x7,%eax
    4917:	85 c0                	test   %eax,%eax
    4919:	75 39                	jne    4954 <writeBits+0x5c>
    491b:	8b 45 08             	mov    0x8(%ebp),%eax
    491e:	8b 00                	mov    (%eax),%eax
    4920:	8b 40 04             	mov    0x4(%eax),%eax
    4923:	8d 50 01             	lea    0x1(%eax),%edx
    4926:	8b 45 08             	mov    0x8(%ebp),%eax
    4929:	8b 00                	mov    (%eax),%eax
    492b:	52                   	push   %edx
    492c:	50                   	push   %eax
    492d:	e8 38 fd ff ff       	call   466a <ucvector_resize>
    4932:	83 c4 08             	add    $0x8,%esp
    4935:	85 c0                	test   %eax,%eax
    4937:	0f 84 44 01 00 00    	je     4a81 <writeBits+0x189>
    493d:	8b 45 08             	mov    0x8(%ebp),%eax
    4940:	8b 00                	mov    (%eax),%eax
    4942:	8b 10                	mov    (%eax),%edx
    4944:	8b 45 08             	mov    0x8(%ebp),%eax
    4947:	8b 00                	mov    (%eax),%eax
    4949:	8b 40 04             	mov    0x4(%eax),%eax
    494c:	83 e8 01             	sub    $0x1,%eax
    494f:	01 d0                	add    %edx,%eax
    4951:	c6 00 00             	movb   $0x0,(%eax)
    4954:	8b 45 08             	mov    0x8(%ebp),%eax
    4957:	8b 00                	mov    (%eax),%eax
    4959:	8b 10                	mov    (%eax),%edx
    495b:	8b 45 08             	mov    0x8(%ebp),%eax
    495e:	8b 00                	mov    (%eax),%eax
    4960:	8b 40 04             	mov    0x4(%eax),%eax
    4963:	83 e8 01             	sub    $0x1,%eax
    4966:	01 c2                	add    %eax,%edx
    4968:	8b 45 08             	mov    0x8(%ebp),%eax
    496b:	8b 00                	mov    (%eax),%eax
    496d:	8b 08                	mov    (%eax),%ecx
    496f:	8b 45 08             	mov    0x8(%ebp),%eax
    4972:	8b 00                	mov    (%eax),%eax
    4974:	8b 40 04             	mov    0x4(%eax),%eax
    4977:	83 e8 01             	sub    $0x1,%eax
    497a:	01 c8                	add    %ecx,%eax
    497c:	0f b6 00             	movzbl (%eax),%eax
    497f:	88 45 e7             	mov    %al,-0x19(%ebp)
    4982:	8b 45 08             	mov    0x8(%ebp),%eax
    4985:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4989:	0f b6 c0             	movzbl %al,%eax
    498c:	83 e0 07             	and    $0x7,%eax
    498f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4992:	89 de                	mov    %ebx,%esi
    4994:	89 c1                	mov    %eax,%ecx
    4996:	d3 e6                	shl    %cl,%esi
    4998:	89 f0                	mov    %esi,%eax
    499a:	0a 45 e7             	or     -0x19(%ebp),%al
    499d:	88 02                	mov    %al,(%edx)
    499f:	8b 45 08             	mov    0x8(%ebp),%eax
    49a2:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    49a6:	8d 50 01             	lea    0x1(%eax),%edx
    49a9:	8b 45 08             	mov    0x8(%ebp),%eax
    49ac:	88 50 04             	mov    %dl,0x4(%eax)
    49af:	e9 d1 00 00 00       	jmp    4a85 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    49b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    49bb:	e9 b3 00 00 00       	jmp    4a73 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    49c0:	8b 45 08             	mov    0x8(%ebp),%eax
    49c3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    49c7:	0f b6 c0             	movzbl %al,%eax
    49ca:	83 e0 07             	and    $0x7,%eax
    49cd:	85 c0                	test   %eax,%eax
    49cf:	75 39                	jne    4a0a <writeBits+0x112>
    49d1:	8b 45 08             	mov    0x8(%ebp),%eax
    49d4:	8b 00                	mov    (%eax),%eax
    49d6:	8b 40 04             	mov    0x4(%eax),%eax
    49d9:	8d 50 01             	lea    0x1(%eax),%edx
    49dc:	8b 45 08             	mov    0x8(%ebp),%eax
    49df:	8b 00                	mov    (%eax),%eax
    49e1:	52                   	push   %edx
    49e2:	50                   	push   %eax
    49e3:	e8 82 fc ff ff       	call   466a <ucvector_resize>
    49e8:	83 c4 08             	add    $0x8,%esp
    49eb:	85 c0                	test   %eax,%eax
    49ed:	0f 84 91 00 00 00    	je     4a84 <writeBits+0x18c>
    49f3:	8b 45 08             	mov    0x8(%ebp),%eax
    49f6:	8b 00                	mov    (%eax),%eax
    49f8:	8b 10                	mov    (%eax),%edx
    49fa:	8b 45 08             	mov    0x8(%ebp),%eax
    49fd:	8b 00                	mov    (%eax),%eax
    49ff:	8b 40 04             	mov    0x4(%eax),%eax
    4a02:	83 e8 01             	sub    $0x1,%eax
    4a05:	01 d0                	add    %edx,%eax
    4a07:	c6 00 00             	movb   $0x0,(%eax)
    4a0a:	8b 45 08             	mov    0x8(%ebp),%eax
    4a0d:	8b 00                	mov    (%eax),%eax
    4a0f:	8b 10                	mov    (%eax),%edx
    4a11:	8b 45 08             	mov    0x8(%ebp),%eax
    4a14:	8b 00                	mov    (%eax),%eax
    4a16:	8b 40 04             	mov    0x4(%eax),%eax
    4a19:	83 e8 01             	sub    $0x1,%eax
    4a1c:	01 c2                	add    %eax,%edx
    4a1e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a21:	8b 00                	mov    (%eax),%eax
    4a23:	8b 08                	mov    (%eax),%ecx
    4a25:	8b 45 08             	mov    0x8(%ebp),%eax
    4a28:	8b 00                	mov    (%eax),%eax
    4a2a:	8b 40 04             	mov    0x4(%eax),%eax
    4a2d:	83 e8 01             	sub    $0x1,%eax
    4a30:	01 c8                	add    %ecx,%eax
    4a32:	0f b6 00             	movzbl (%eax),%eax
    4a35:	89 c6                	mov    %eax,%esi
    4a37:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a3a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4a3d:	89 c1                	mov    %eax,%ecx
    4a3f:	d3 eb                	shr    %cl,%ebx
    4a41:	89 d8                	mov    %ebx,%eax
    4a43:	83 e0 01             	and    $0x1,%eax
    4a46:	89 c3                	mov    %eax,%ebx
    4a48:	8b 45 08             	mov    0x8(%ebp),%eax
    4a4b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4a4f:	0f b6 c0             	movzbl %al,%eax
    4a52:	83 e0 07             	and    $0x7,%eax
    4a55:	89 c1                	mov    %eax,%ecx
    4a57:	d3 e3                	shl    %cl,%ebx
    4a59:	89 d8                	mov    %ebx,%eax
    4a5b:	09 f0                	or     %esi,%eax
    4a5d:	88 02                	mov    %al,(%edx)
    4a5f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a62:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4a66:	8d 50 01             	lea    0x1(%eax),%edx
    4a69:	8b 45 08             	mov    0x8(%ebp),%eax
    4a6c:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    4a6f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4a73:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a76:	3b 45 10             	cmp    0x10(%ebp),%eax
    4a79:	0f 85 41 ff ff ff    	jne    49c0 <writeBits+0xc8>
    4a7f:	eb 04                	jmp    4a85 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    4a81:	90                   	nop
    4a82:	eb 01                	jmp    4a85 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    4a84:	90                   	nop
    }
  }
}
    4a85:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4a88:	5b                   	pop    %ebx
    4a89:	5e                   	pop    %esi
    4a8a:	5d                   	pop    %ebp
    4a8b:	c3                   	ret    

00004a8c <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    4a8c:	55                   	push   %ebp
    4a8d:	89 e5                	mov    %esp,%ebp
    4a8f:	56                   	push   %esi
    4a90:	53                   	push   %ebx
    4a91:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    4a94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4a9b:	e9 bd 00 00 00       	jmp    4b5d <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    4aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    4aa3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4aa7:	0f b6 c0             	movzbl %al,%eax
    4aaa:	83 e0 07             	and    $0x7,%eax
    4aad:	85 c0                	test   %eax,%eax
    4aaf:	75 39                	jne    4aea <writeBitsReversed+0x5e>
    4ab1:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab4:	8b 00                	mov    (%eax),%eax
    4ab6:	8b 40 04             	mov    0x4(%eax),%eax
    4ab9:	8d 50 01             	lea    0x1(%eax),%edx
    4abc:	8b 45 08             	mov    0x8(%ebp),%eax
    4abf:	8b 00                	mov    (%eax),%eax
    4ac1:	52                   	push   %edx
    4ac2:	50                   	push   %eax
    4ac3:	e8 a2 fb ff ff       	call   466a <ucvector_resize>
    4ac8:	83 c4 08             	add    $0x8,%esp
    4acb:	85 c0                	test   %eax,%eax
    4acd:	0f 84 98 00 00 00    	je     4b6b <writeBitsReversed+0xdf>
    4ad3:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad6:	8b 00                	mov    (%eax),%eax
    4ad8:	8b 10                	mov    (%eax),%edx
    4ada:	8b 45 08             	mov    0x8(%ebp),%eax
    4add:	8b 00                	mov    (%eax),%eax
    4adf:	8b 40 04             	mov    0x4(%eax),%eax
    4ae2:	83 e8 01             	sub    $0x1,%eax
    4ae5:	01 d0                	add    %edx,%eax
    4ae7:	c6 00 00             	movb   $0x0,(%eax)
    4aea:	8b 45 08             	mov    0x8(%ebp),%eax
    4aed:	8b 00                	mov    (%eax),%eax
    4aef:	8b 10                	mov    (%eax),%edx
    4af1:	8b 45 08             	mov    0x8(%ebp),%eax
    4af4:	8b 00                	mov    (%eax),%eax
    4af6:	8b 40 04             	mov    0x4(%eax),%eax
    4af9:	83 e8 01             	sub    $0x1,%eax
    4afc:	01 c2                	add    %eax,%edx
    4afe:	8b 45 08             	mov    0x8(%ebp),%eax
    4b01:	8b 00                	mov    (%eax),%eax
    4b03:	8b 08                	mov    (%eax),%ecx
    4b05:	8b 45 08             	mov    0x8(%ebp),%eax
    4b08:	8b 00                	mov    (%eax),%eax
    4b0a:	8b 40 04             	mov    0x4(%eax),%eax
    4b0d:	83 e8 01             	sub    $0x1,%eax
    4b10:	01 c8                	add    %ecx,%eax
    4b12:	0f b6 00             	movzbl (%eax),%eax
    4b15:	89 c6                	mov    %eax,%esi
    4b17:	8b 4d 10             	mov    0x10(%ebp),%ecx
    4b1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b1d:	29 c1                	sub    %eax,%ecx
    4b1f:	89 c8                	mov    %ecx,%eax
    4b21:	83 e8 01             	sub    $0x1,%eax
    4b24:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4b27:	89 c1                	mov    %eax,%ecx
    4b29:	d3 eb                	shr    %cl,%ebx
    4b2b:	89 d8                	mov    %ebx,%eax
    4b2d:	83 e0 01             	and    $0x1,%eax
    4b30:	89 c3                	mov    %eax,%ebx
    4b32:	8b 45 08             	mov    0x8(%ebp),%eax
    4b35:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4b39:	0f b6 c0             	movzbl %al,%eax
    4b3c:	83 e0 07             	and    $0x7,%eax
    4b3f:	89 c1                	mov    %eax,%ecx
    4b41:	d3 e3                	shl    %cl,%ebx
    4b43:	89 d8                	mov    %ebx,%eax
    4b45:	09 f0                	or     %esi,%eax
    4b47:	88 02                	mov    %al,(%edx)
    4b49:	8b 45 08             	mov    0x8(%ebp),%eax
    4b4c:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4b50:	8d 50 01             	lea    0x1(%eax),%edx
    4b53:	8b 45 08             	mov    0x8(%ebp),%eax
    4b56:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    4b59:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4b5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b60:	3b 45 10             	cmp    0x10(%ebp),%eax
    4b63:	0f 85 37 ff ff ff    	jne    4aa0 <writeBitsReversed+0x14>
    4b69:	eb 01                	jmp    4b6c <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    4b6b:	90                   	nop
  }
}
    4b6c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4b6f:	5b                   	pop    %ebx
    4b70:	5e                   	pop    %esi
    4b71:	5d                   	pop    %ebp
    4b72:	c3                   	ret    

00004b73 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    4b73:	55                   	push   %ebp
    4b74:	89 e5                	mov    %esp,%ebp
    4b76:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    4b79:	8b 45 08             	mov    0x8(%ebp),%eax
    4b7c:	8b 55 0c             	mov    0xc(%ebp),%edx
    4b7f:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    4b81:	8b 45 08             	mov    0x8(%ebp),%eax
    4b84:	8b 55 10             	mov    0x10(%ebp),%edx
    4b87:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    4b8a:	8b 45 08             	mov    0x8(%ebp),%eax
    4b8d:	83 c0 08             	add    $0x8,%eax
    4b90:	50                   	push   %eax
    4b91:	6a 08                	push   $0x8
    4b93:	ff 75 10             	pushl  0x10(%ebp)
    4b96:	e8 59 f9 ff ff       	call   44f4 <lodepng_mulofl>
    4b9b:	83 c4 0c             	add    $0xc,%esp
    4b9e:	85 c0                	test   %eax,%eax
    4ba0:	74 07                	je     4ba9 <LodePNGBitReader_init+0x36>
    4ba2:	b8 69 00 00 00       	mov    $0x69,%eax
    4ba7:	eb 39                	jmp    4be2 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    4ba9:	8b 45 08             	mov    0x8(%ebp),%eax
    4bac:	8b 40 08             	mov    0x8(%eax),%eax
    4baf:	8d 55 fc             	lea    -0x4(%ebp),%edx
    4bb2:	52                   	push   %edx
    4bb3:	6a 40                	push   $0x40
    4bb5:	50                   	push   %eax
    4bb6:	e8 19 f9 ff ff       	call   44d4 <lodepng_addofl>
    4bbb:	83 c4 0c             	add    $0xc,%esp
    4bbe:	85 c0                	test   %eax,%eax
    4bc0:	74 07                	je     4bc9 <LodePNGBitReader_init+0x56>
    4bc2:	b8 69 00 00 00       	mov    $0x69,%eax
    4bc7:	eb 19                	jmp    4be2 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    4bc9:	8b 45 08             	mov    0x8(%ebp),%eax
    4bcc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    4bd3:	8b 45 08             	mov    0x8(%ebp),%eax
    4bd6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    4bdd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4be2:	c9                   	leave  
    4be3:	c3                   	ret    

00004be4 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    4be4:	55                   	push   %ebp
    4be5:	89 e5                	mov    %esp,%ebp
    4be7:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4bea:	8b 45 08             	mov    0x8(%ebp),%eax
    4bed:	8b 40 0c             	mov    0xc(%eax),%eax
    4bf0:	c1 f8 03             	sar    $0x3,%eax
    4bf3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4bf6:	8b 45 08             	mov    0x8(%ebp),%eax
    4bf9:	8b 40 04             	mov    0x4(%eax),%eax
    4bfc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    4bff:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4c02:	8d 50 01             	lea    0x1(%eax),%edx
    4c05:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4c08:	39 c2                	cmp    %eax,%edx
    4c0a:	73 4e                	jae    4c5a <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    4c0c:	8b 45 08             	mov    0x8(%ebp),%eax
    4c0f:	8b 10                	mov    (%eax),%edx
    4c11:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4c14:	01 d0                	add    %edx,%eax
    4c16:	0f b6 00             	movzbl (%eax),%eax
    4c19:	0f b6 d0             	movzbl %al,%edx
    4c1c:	8b 45 08             	mov    0x8(%ebp),%eax
    4c1f:	8b 00                	mov    (%eax),%eax
    4c21:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4c24:	83 c1 01             	add    $0x1,%ecx
    4c27:	01 c8                	add    %ecx,%eax
    4c29:	0f b6 00             	movzbl (%eax),%eax
    4c2c:	0f b6 c0             	movzbl %al,%eax
    4c2f:	c1 e0 08             	shl    $0x8,%eax
    4c32:	09 c2                	or     %eax,%edx
    4c34:	8b 45 08             	mov    0x8(%ebp),%eax
    4c37:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4c3a:	8b 45 08             	mov    0x8(%ebp),%eax
    4c3d:	8b 50 10             	mov    0x10(%eax),%edx
    4c40:	8b 45 08             	mov    0x8(%ebp),%eax
    4c43:	8b 40 0c             	mov    0xc(%eax),%eax
    4c46:	83 e0 07             	and    $0x7,%eax
    4c49:	89 c1                	mov    %eax,%ecx
    4c4b:	d3 ea                	shr    %cl,%edx
    4c4d:	8b 45 08             	mov    0x8(%ebp),%eax
    4c50:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4c53:	b8 01 00 00 00       	mov    $0x1,%eax
    4c58:	eb 64                	jmp    4cbe <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    4c5a:	8b 45 08             	mov    0x8(%ebp),%eax
    4c5d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4c64:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4c67:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4c6a:	39 c2                	cmp    %eax,%edx
    4c6c:	73 1e                	jae    4c8c <ensureBits9+0xa8>
    4c6e:	8b 45 08             	mov    0x8(%ebp),%eax
    4c71:	8b 50 10             	mov    0x10(%eax),%edx
    4c74:	8b 45 08             	mov    0x8(%ebp),%eax
    4c77:	8b 08                	mov    (%eax),%ecx
    4c79:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4c7c:	01 c8                	add    %ecx,%eax
    4c7e:	0f b6 00             	movzbl (%eax),%eax
    4c81:	0f b6 c0             	movzbl %al,%eax
    4c84:	09 c2                	or     %eax,%edx
    4c86:	8b 45 08             	mov    0x8(%ebp),%eax
    4c89:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4c8c:	8b 45 08             	mov    0x8(%ebp),%eax
    4c8f:	8b 50 10             	mov    0x10(%eax),%edx
    4c92:	8b 45 08             	mov    0x8(%ebp),%eax
    4c95:	8b 40 0c             	mov    0xc(%eax),%eax
    4c98:	83 e0 07             	and    $0x7,%eax
    4c9b:	89 c1                	mov    %eax,%ecx
    4c9d:	d3 ea                	shr    %cl,%edx
    4c9f:	8b 45 08             	mov    0x8(%ebp),%eax
    4ca2:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4ca5:	8b 45 08             	mov    0x8(%ebp),%eax
    4ca8:	8b 50 0c             	mov    0xc(%eax),%edx
    4cab:	8b 45 0c             	mov    0xc(%ebp),%eax
    4cae:	01 c2                	add    %eax,%edx
    4cb0:	8b 45 08             	mov    0x8(%ebp),%eax
    4cb3:	8b 40 08             	mov    0x8(%eax),%eax
    4cb6:	39 c2                	cmp    %eax,%edx
    4cb8:	0f 9e c0             	setle  %al
    4cbb:	0f b6 c0             	movzbl %al,%eax
  }
}
    4cbe:	c9                   	leave  
    4cbf:	c3                   	ret    

00004cc0 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    4cc0:	55                   	push   %ebp
    4cc1:	89 e5                	mov    %esp,%ebp
    4cc3:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4cc6:	8b 45 08             	mov    0x8(%ebp),%eax
    4cc9:	8b 40 0c             	mov    0xc(%eax),%eax
    4ccc:	c1 f8 03             	sar    $0x3,%eax
    4ccf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4cd2:	8b 45 08             	mov    0x8(%ebp),%eax
    4cd5:	8b 40 04             	mov    0x4(%eax),%eax
    4cd8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    4cdb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4cde:	8d 50 02             	lea    0x2(%eax),%edx
    4ce1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4ce4:	39 c2                	cmp    %eax,%edx
    4ce6:	73 6d                	jae    4d55 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4ce8:	8b 45 08             	mov    0x8(%ebp),%eax
    4ceb:	8b 10                	mov    (%eax),%edx
    4ced:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4cf0:	01 d0                	add    %edx,%eax
    4cf2:	0f b6 00             	movzbl (%eax),%eax
    4cf5:	0f b6 d0             	movzbl %al,%edx
    4cf8:	8b 45 08             	mov    0x8(%ebp),%eax
    4cfb:	8b 00                	mov    (%eax),%eax
    4cfd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4d00:	83 c1 01             	add    $0x1,%ecx
    4d03:	01 c8                	add    %ecx,%eax
    4d05:	0f b6 00             	movzbl (%eax),%eax
    4d08:	0f b6 c0             	movzbl %al,%eax
    4d0b:	c1 e0 08             	shl    $0x8,%eax
    4d0e:	89 d1                	mov    %edx,%ecx
    4d10:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    4d12:	8b 45 08             	mov    0x8(%ebp),%eax
    4d15:	8b 00                	mov    (%eax),%eax
    4d17:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4d1a:	83 c2 02             	add    $0x2,%edx
    4d1d:	01 d0                	add    %edx,%eax
    4d1f:	0f b6 00             	movzbl (%eax),%eax
    4d22:	0f b6 c0             	movzbl %al,%eax
    4d25:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4d28:	09 c1                	or     %eax,%ecx
    4d2a:	89 ca                	mov    %ecx,%edx
    4d2c:	8b 45 08             	mov    0x8(%ebp),%eax
    4d2f:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    4d32:	8b 45 08             	mov    0x8(%ebp),%eax
    4d35:	8b 50 10             	mov    0x10(%eax),%edx
    4d38:	8b 45 08             	mov    0x8(%ebp),%eax
    4d3b:	8b 40 0c             	mov    0xc(%eax),%eax
    4d3e:	83 e0 07             	and    $0x7,%eax
    4d41:	89 c1                	mov    %eax,%ecx
    4d43:	d3 ea                	shr    %cl,%edx
    4d45:	8b 45 08             	mov    0x8(%ebp),%eax
    4d48:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4d4b:	b8 01 00 00 00       	mov    $0x1,%eax
    4d50:	e9 95 00 00 00       	jmp    4dea <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    4d55:	8b 45 08             	mov    0x8(%ebp),%eax
    4d58:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4d5f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4d62:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4d65:	39 c2                	cmp    %eax,%edx
    4d67:	73 1e                	jae    4d87 <ensureBits17+0xc7>
    4d69:	8b 45 08             	mov    0x8(%ebp),%eax
    4d6c:	8b 50 10             	mov    0x10(%eax),%edx
    4d6f:	8b 45 08             	mov    0x8(%ebp),%eax
    4d72:	8b 08                	mov    (%eax),%ecx
    4d74:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4d77:	01 c8                	add    %ecx,%eax
    4d79:	0f b6 00             	movzbl (%eax),%eax
    4d7c:	0f b6 c0             	movzbl %al,%eax
    4d7f:	09 c2                	or     %eax,%edx
    4d81:	8b 45 08             	mov    0x8(%ebp),%eax
    4d84:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4d87:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4d8a:	8d 50 01             	lea    0x1(%eax),%edx
    4d8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4d90:	39 c2                	cmp    %eax,%edx
    4d92:	73 24                	jae    4db8 <ensureBits17+0xf8>
    4d94:	8b 45 08             	mov    0x8(%ebp),%eax
    4d97:	8b 50 10             	mov    0x10(%eax),%edx
    4d9a:	8b 45 08             	mov    0x8(%ebp),%eax
    4d9d:	8b 00                	mov    (%eax),%eax
    4d9f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4da2:	83 c1 01             	add    $0x1,%ecx
    4da5:	01 c8                	add    %ecx,%eax
    4da7:	0f b6 00             	movzbl (%eax),%eax
    4daa:	0f b6 c0             	movzbl %al,%eax
    4dad:	c1 e0 08             	shl    $0x8,%eax
    4db0:	09 c2                	or     %eax,%edx
    4db2:	8b 45 08             	mov    0x8(%ebp),%eax
    4db5:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4db8:	8b 45 08             	mov    0x8(%ebp),%eax
    4dbb:	8b 50 10             	mov    0x10(%eax),%edx
    4dbe:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc1:	8b 40 0c             	mov    0xc(%eax),%eax
    4dc4:	83 e0 07             	and    $0x7,%eax
    4dc7:	89 c1                	mov    %eax,%ecx
    4dc9:	d3 ea                	shr    %cl,%edx
    4dcb:	8b 45 08             	mov    0x8(%ebp),%eax
    4dce:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd4:	8b 50 0c             	mov    0xc(%eax),%edx
    4dd7:	8b 45 0c             	mov    0xc(%ebp),%eax
    4dda:	01 c2                	add    %eax,%edx
    4ddc:	8b 45 08             	mov    0x8(%ebp),%eax
    4ddf:	8b 40 08             	mov    0x8(%eax),%eax
    4de2:	39 c2                	cmp    %eax,%edx
    4de4:	0f 9e c0             	setle  %al
    4de7:	0f b6 c0             	movzbl %al,%eax
  }
}
    4dea:	c9                   	leave  
    4deb:	c3                   	ret    

00004dec <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    4dec:	55                   	push   %ebp
    4ded:	89 e5                	mov    %esp,%ebp
    4def:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4df2:	8b 45 08             	mov    0x8(%ebp),%eax
    4df5:	8b 40 0c             	mov    0xc(%eax),%eax
    4df8:	c1 f8 03             	sar    $0x3,%eax
    4dfb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4dfe:	8b 45 08             	mov    0x8(%ebp),%eax
    4e01:	8b 40 04             	mov    0x4(%eax),%eax
    4e04:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    4e07:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4e0a:	8d 50 03             	lea    0x3(%eax),%edx
    4e0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4e10:	39 c2                	cmp    %eax,%edx
    4e12:	0f 83 85 00 00 00    	jae    4e9d <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4e18:	8b 45 08             	mov    0x8(%ebp),%eax
    4e1b:	8b 10                	mov    (%eax),%edx
    4e1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4e20:	01 d0                	add    %edx,%eax
    4e22:	0f b6 00             	movzbl (%eax),%eax
    4e25:	0f b6 d0             	movzbl %al,%edx
    4e28:	8b 45 08             	mov    0x8(%ebp),%eax
    4e2b:	8b 00                	mov    (%eax),%eax
    4e2d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4e30:	83 c1 01             	add    $0x1,%ecx
    4e33:	01 c8                	add    %ecx,%eax
    4e35:	0f b6 00             	movzbl (%eax),%eax
    4e38:	0f b6 c0             	movzbl %al,%eax
    4e3b:	c1 e0 08             	shl    $0x8,%eax
    4e3e:	89 d1                	mov    %edx,%ecx
    4e40:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4e42:	8b 45 08             	mov    0x8(%ebp),%eax
    4e45:	8b 00                	mov    (%eax),%eax
    4e47:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4e4a:	83 c2 02             	add    $0x2,%edx
    4e4d:	01 d0                	add    %edx,%eax
    4e4f:	0f b6 00             	movzbl (%eax),%eax
    4e52:	0f b6 c0             	movzbl %al,%eax
    4e55:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4e58:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4e5a:	8b 45 08             	mov    0x8(%ebp),%eax
    4e5d:	8b 00                	mov    (%eax),%eax
    4e5f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4e62:	83 c2 03             	add    $0x3,%edx
    4e65:	01 d0                	add    %edx,%eax
    4e67:	0f b6 00             	movzbl (%eax),%eax
    4e6a:	0f b6 c0             	movzbl %al,%eax
    4e6d:	c1 e0 18             	shl    $0x18,%eax
    4e70:	09 c1                	or     %eax,%ecx
    4e72:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4e74:	8b 45 08             	mov    0x8(%ebp),%eax
    4e77:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4e7a:	8b 45 08             	mov    0x8(%ebp),%eax
    4e7d:	8b 50 10             	mov    0x10(%eax),%edx
    4e80:	8b 45 08             	mov    0x8(%ebp),%eax
    4e83:	8b 40 0c             	mov    0xc(%eax),%eax
    4e86:	83 e0 07             	and    $0x7,%eax
    4e89:	89 c1                	mov    %eax,%ecx
    4e8b:	d3 ea                	shr    %cl,%edx
    4e8d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e90:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4e93:	b8 01 00 00 00       	mov    $0x1,%eax
    4e98:	e9 c6 00 00 00       	jmp    4f63 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    4e9d:	8b 45 08             	mov    0x8(%ebp),%eax
    4ea0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4ea7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4eaa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4ead:	39 c2                	cmp    %eax,%edx
    4eaf:	73 1e                	jae    4ecf <ensureBits25+0xe3>
    4eb1:	8b 45 08             	mov    0x8(%ebp),%eax
    4eb4:	8b 50 10             	mov    0x10(%eax),%edx
    4eb7:	8b 45 08             	mov    0x8(%ebp),%eax
    4eba:	8b 08                	mov    (%eax),%ecx
    4ebc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4ebf:	01 c8                	add    %ecx,%eax
    4ec1:	0f b6 00             	movzbl (%eax),%eax
    4ec4:	0f b6 c0             	movzbl %al,%eax
    4ec7:	09 c2                	or     %eax,%edx
    4ec9:	8b 45 08             	mov    0x8(%ebp),%eax
    4ecc:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4ecf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4ed2:	8d 50 01             	lea    0x1(%eax),%edx
    4ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4ed8:	39 c2                	cmp    %eax,%edx
    4eda:	73 24                	jae    4f00 <ensureBits25+0x114>
    4edc:	8b 45 08             	mov    0x8(%ebp),%eax
    4edf:	8b 50 10             	mov    0x10(%eax),%edx
    4ee2:	8b 45 08             	mov    0x8(%ebp),%eax
    4ee5:	8b 00                	mov    (%eax),%eax
    4ee7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4eea:	83 c1 01             	add    $0x1,%ecx
    4eed:	01 c8                	add    %ecx,%eax
    4eef:	0f b6 00             	movzbl (%eax),%eax
    4ef2:	0f b6 c0             	movzbl %al,%eax
    4ef5:	c1 e0 08             	shl    $0x8,%eax
    4ef8:	09 c2                	or     %eax,%edx
    4efa:	8b 45 08             	mov    0x8(%ebp),%eax
    4efd:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    4f00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4f03:	8d 50 02             	lea    0x2(%eax),%edx
    4f06:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4f09:	39 c2                	cmp    %eax,%edx
    4f0b:	73 24                	jae    4f31 <ensureBits25+0x145>
    4f0d:	8b 45 08             	mov    0x8(%ebp),%eax
    4f10:	8b 50 10             	mov    0x10(%eax),%edx
    4f13:	8b 45 08             	mov    0x8(%ebp),%eax
    4f16:	8b 00                	mov    (%eax),%eax
    4f18:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4f1b:	83 c1 02             	add    $0x2,%ecx
    4f1e:	01 c8                	add    %ecx,%eax
    4f20:	0f b6 00             	movzbl (%eax),%eax
    4f23:	0f b6 c0             	movzbl %al,%eax
    4f26:	c1 e0 10             	shl    $0x10,%eax
    4f29:	09 c2                	or     %eax,%edx
    4f2b:	8b 45 08             	mov    0x8(%ebp),%eax
    4f2e:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4f31:	8b 45 08             	mov    0x8(%ebp),%eax
    4f34:	8b 50 10             	mov    0x10(%eax),%edx
    4f37:	8b 45 08             	mov    0x8(%ebp),%eax
    4f3a:	8b 40 0c             	mov    0xc(%eax),%eax
    4f3d:	83 e0 07             	and    $0x7,%eax
    4f40:	89 c1                	mov    %eax,%ecx
    4f42:	d3 ea                	shr    %cl,%edx
    4f44:	8b 45 08             	mov    0x8(%ebp),%eax
    4f47:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4f4a:	8b 45 08             	mov    0x8(%ebp),%eax
    4f4d:	8b 50 0c             	mov    0xc(%eax),%edx
    4f50:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f53:	01 c2                	add    %eax,%edx
    4f55:	8b 45 08             	mov    0x8(%ebp),%eax
    4f58:	8b 40 08             	mov    0x8(%eax),%eax
    4f5b:	39 c2                	cmp    %eax,%edx
    4f5d:	0f 9e c0             	setle  %al
    4f60:	0f b6 c0             	movzbl %al,%eax
  }
}
    4f63:	c9                   	leave  
    4f64:	c3                   	ret    

00004f65 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    4f65:	55                   	push   %ebp
    4f66:	89 e5                	mov    %esp,%ebp
    4f68:	53                   	push   %ebx
    4f69:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4f6c:	8b 45 08             	mov    0x8(%ebp),%eax
    4f6f:	8b 40 0c             	mov    0xc(%eax),%eax
    4f72:	c1 f8 03             	sar    $0x3,%eax
    4f75:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    4f78:	8b 45 08             	mov    0x8(%ebp),%eax
    4f7b:	8b 40 04             	mov    0x4(%eax),%eax
    4f7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    4f81:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4f84:	8d 50 04             	lea    0x4(%eax),%edx
    4f87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f8a:	39 c2                	cmp    %eax,%edx
    4f8c:	0f 83 c3 00 00 00    	jae    5055 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4f92:	8b 45 08             	mov    0x8(%ebp),%eax
    4f95:	8b 10                	mov    (%eax),%edx
    4f97:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4f9a:	01 d0                	add    %edx,%eax
    4f9c:	0f b6 00             	movzbl (%eax),%eax
    4f9f:	0f b6 d0             	movzbl %al,%edx
    4fa2:	8b 45 08             	mov    0x8(%ebp),%eax
    4fa5:	8b 00                	mov    (%eax),%eax
    4fa7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4faa:	83 c1 01             	add    $0x1,%ecx
    4fad:	01 c8                	add    %ecx,%eax
    4faf:	0f b6 00             	movzbl (%eax),%eax
    4fb2:	0f b6 c0             	movzbl %al,%eax
    4fb5:	c1 e0 08             	shl    $0x8,%eax
    4fb8:	89 d1                	mov    %edx,%ecx
    4fba:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4fbc:	8b 45 08             	mov    0x8(%ebp),%eax
    4fbf:	8b 00                	mov    (%eax),%eax
    4fc1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4fc4:	83 c2 02             	add    $0x2,%edx
    4fc7:	01 d0                	add    %edx,%eax
    4fc9:	0f b6 00             	movzbl (%eax),%eax
    4fcc:	0f b6 c0             	movzbl %al,%eax
    4fcf:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4fd2:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4fd4:	8b 45 08             	mov    0x8(%ebp),%eax
    4fd7:	8b 00                	mov    (%eax),%eax
    4fd9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4fdc:	83 c2 03             	add    $0x3,%edx
    4fdf:	01 d0                	add    %edx,%eax
    4fe1:	0f b6 00             	movzbl (%eax),%eax
    4fe4:	0f b6 c0             	movzbl %al,%eax
    4fe7:	c1 e0 18             	shl    $0x18,%eax
    4fea:	09 c1                	or     %eax,%ecx
    4fec:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4fee:	8b 45 08             	mov    0x8(%ebp),%eax
    4ff1:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4ff4:	8b 45 08             	mov    0x8(%ebp),%eax
    4ff7:	8b 50 10             	mov    0x10(%eax),%edx
    4ffa:	8b 45 08             	mov    0x8(%ebp),%eax
    4ffd:	8b 40 0c             	mov    0xc(%eax),%eax
    5000:	83 e0 07             	and    $0x7,%eax
    5003:	89 c1                	mov    %eax,%ecx
    5005:	d3 ea                	shr    %cl,%edx
    5007:	8b 45 08             	mov    0x8(%ebp),%eax
    500a:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    500d:	8b 45 08             	mov    0x8(%ebp),%eax
    5010:	8b 50 10             	mov    0x10(%eax),%edx
    5013:	8b 45 08             	mov    0x8(%ebp),%eax
    5016:	8b 00                	mov    (%eax),%eax
    5018:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    501b:	83 c1 04             	add    $0x4,%ecx
    501e:	01 c8                	add    %ecx,%eax
    5020:	0f b6 00             	movzbl (%eax),%eax
    5023:	0f b6 c0             	movzbl %al,%eax
    5026:	c1 e0 18             	shl    $0x18,%eax
    5029:	89 c3                	mov    %eax,%ebx
    502b:	8b 45 08             	mov    0x8(%ebp),%eax
    502e:	8b 40 0c             	mov    0xc(%eax),%eax
    5031:	83 e0 07             	and    $0x7,%eax
    5034:	b9 08 00 00 00       	mov    $0x8,%ecx
    5039:	29 c1                	sub    %eax,%ecx
    503b:	89 c8                	mov    %ecx,%eax
    503d:	89 c1                	mov    %eax,%ecx
    503f:	d3 e3                	shl    %cl,%ebx
    5041:	89 d8                	mov    %ebx,%eax
    5043:	09 c2                	or     %eax,%edx
    5045:	8b 45 08             	mov    0x8(%ebp),%eax
    5048:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    504b:	b8 01 00 00 00       	mov    $0x1,%eax
    5050:	e9 f7 00 00 00       	jmp    514c <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    5055:	8b 45 08             	mov    0x8(%ebp),%eax
    5058:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    505f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5062:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5065:	39 c2                	cmp    %eax,%edx
    5067:	73 1e                	jae    5087 <ensureBits32+0x122>
    5069:	8b 45 08             	mov    0x8(%ebp),%eax
    506c:	8b 50 10             	mov    0x10(%eax),%edx
    506f:	8b 45 08             	mov    0x8(%ebp),%eax
    5072:	8b 08                	mov    (%eax),%ecx
    5074:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5077:	01 c8                	add    %ecx,%eax
    5079:	0f b6 00             	movzbl (%eax),%eax
    507c:	0f b6 c0             	movzbl %al,%eax
    507f:	09 c2                	or     %eax,%edx
    5081:	8b 45 08             	mov    0x8(%ebp),%eax
    5084:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    5087:	8b 45 f8             	mov    -0x8(%ebp),%eax
    508a:	8d 50 01             	lea    0x1(%eax),%edx
    508d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5090:	39 c2                	cmp    %eax,%edx
    5092:	73 24                	jae    50b8 <ensureBits32+0x153>
    5094:	8b 45 08             	mov    0x8(%ebp),%eax
    5097:	8b 50 10             	mov    0x10(%eax),%edx
    509a:	8b 45 08             	mov    0x8(%ebp),%eax
    509d:	8b 00                	mov    (%eax),%eax
    509f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    50a2:	83 c1 01             	add    $0x1,%ecx
    50a5:	01 c8                	add    %ecx,%eax
    50a7:	0f b6 00             	movzbl (%eax),%eax
    50aa:	0f b6 c0             	movzbl %al,%eax
    50ad:	c1 e0 08             	shl    $0x8,%eax
    50b0:	09 c2                	or     %eax,%edx
    50b2:	8b 45 08             	mov    0x8(%ebp),%eax
    50b5:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    50b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    50bb:	8d 50 02             	lea    0x2(%eax),%edx
    50be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50c1:	39 c2                	cmp    %eax,%edx
    50c3:	73 24                	jae    50e9 <ensureBits32+0x184>
    50c5:	8b 45 08             	mov    0x8(%ebp),%eax
    50c8:	8b 50 10             	mov    0x10(%eax),%edx
    50cb:	8b 45 08             	mov    0x8(%ebp),%eax
    50ce:	8b 00                	mov    (%eax),%eax
    50d0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    50d3:	83 c1 02             	add    $0x2,%ecx
    50d6:	01 c8                	add    %ecx,%eax
    50d8:	0f b6 00             	movzbl (%eax),%eax
    50db:	0f b6 c0             	movzbl %al,%eax
    50de:	c1 e0 10             	shl    $0x10,%eax
    50e1:	09 c2                	or     %eax,%edx
    50e3:	8b 45 08             	mov    0x8(%ebp),%eax
    50e6:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    50e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    50ec:	8d 50 03             	lea    0x3(%eax),%edx
    50ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50f2:	39 c2                	cmp    %eax,%edx
    50f4:	73 24                	jae    511a <ensureBits32+0x1b5>
    50f6:	8b 45 08             	mov    0x8(%ebp),%eax
    50f9:	8b 50 10             	mov    0x10(%eax),%edx
    50fc:	8b 45 08             	mov    0x8(%ebp),%eax
    50ff:	8b 00                	mov    (%eax),%eax
    5101:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    5104:	83 c1 03             	add    $0x3,%ecx
    5107:	01 c8                	add    %ecx,%eax
    5109:	0f b6 00             	movzbl (%eax),%eax
    510c:	0f b6 c0             	movzbl %al,%eax
    510f:	c1 e0 18             	shl    $0x18,%eax
    5112:	09 c2                	or     %eax,%edx
    5114:	8b 45 08             	mov    0x8(%ebp),%eax
    5117:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    511a:	8b 45 08             	mov    0x8(%ebp),%eax
    511d:	8b 50 10             	mov    0x10(%eax),%edx
    5120:	8b 45 08             	mov    0x8(%ebp),%eax
    5123:	8b 40 0c             	mov    0xc(%eax),%eax
    5126:	83 e0 07             	and    $0x7,%eax
    5129:	89 c1                	mov    %eax,%ecx
    512b:	d3 ea                	shr    %cl,%edx
    512d:	8b 45 08             	mov    0x8(%ebp),%eax
    5130:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    5133:	8b 45 08             	mov    0x8(%ebp),%eax
    5136:	8b 50 0c             	mov    0xc(%eax),%edx
    5139:	8b 45 0c             	mov    0xc(%ebp),%eax
    513c:	01 c2                	add    %eax,%edx
    513e:	8b 45 08             	mov    0x8(%ebp),%eax
    5141:	8b 40 08             	mov    0x8(%eax),%eax
    5144:	39 c2                	cmp    %eax,%edx
    5146:	0f 9e c0             	setle  %al
    5149:	0f b6 c0             	movzbl %al,%eax
  }
}
    514c:	83 c4 10             	add    $0x10,%esp
    514f:	5b                   	pop    %ebx
    5150:	5d                   	pop    %ebp
    5151:	c3                   	ret    

00005152 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    5152:	55                   	push   %ebp
    5153:	89 e5                	mov    %esp,%ebp
    5155:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    5156:	8b 45 08             	mov    0x8(%ebp),%eax
    5159:	8b 50 10             	mov    0x10(%eax),%edx
    515c:	8b 45 0c             	mov    0xc(%ebp),%eax
    515f:	bb 01 00 00 00       	mov    $0x1,%ebx
    5164:	89 c1                	mov    %eax,%ecx
    5166:	d3 e3                	shl    %cl,%ebx
    5168:	89 d8                	mov    %ebx,%eax
    516a:	83 e8 01             	sub    $0x1,%eax
    516d:	21 d0                	and    %edx,%eax
}
    516f:	5b                   	pop    %ebx
    5170:	5d                   	pop    %ebp
    5171:	c3                   	ret    

00005172 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    5172:	55                   	push   %ebp
    5173:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    5175:	8b 45 08             	mov    0x8(%ebp),%eax
    5178:	8b 50 10             	mov    0x10(%eax),%edx
    517b:	8b 45 0c             	mov    0xc(%ebp),%eax
    517e:	89 c1                	mov    %eax,%ecx
    5180:	d3 ea                	shr    %cl,%edx
    5182:	8b 45 08             	mov    0x8(%ebp),%eax
    5185:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    5188:	8b 45 08             	mov    0x8(%ebp),%eax
    518b:	8b 50 0c             	mov    0xc(%eax),%edx
    518e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5191:	01 c2                	add    %eax,%edx
    5193:	8b 45 08             	mov    0x8(%ebp),%eax
    5196:	89 50 0c             	mov    %edx,0xc(%eax)
}
    5199:	90                   	nop
    519a:	5d                   	pop    %ebp
    519b:	c3                   	ret    

0000519c <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    519c:	55                   	push   %ebp
    519d:	89 e5                	mov    %esp,%ebp
    519f:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    51a2:	ff 75 0c             	pushl  0xc(%ebp)
    51a5:	ff 75 08             	pushl  0x8(%ebp)
    51a8:	e8 a5 ff ff ff       	call   5152 <peekBits>
    51ad:	83 c4 08             	add    $0x8,%esp
    51b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    51b3:	ff 75 0c             	pushl  0xc(%ebp)
    51b6:	ff 75 08             	pushl  0x8(%ebp)
    51b9:	e8 b4 ff ff ff       	call   5172 <advanceBits>
    51be:	83 c4 08             	add    $0x8,%esp
  return result;
    51c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    51c4:	c9                   	leave  
    51c5:	c3                   	ret    

000051c6 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    51c6:	55                   	push   %ebp
    51c7:	89 e5                	mov    %esp,%ebp
    51c9:	53                   	push   %ebx
    51ca:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    51cd:	ff 75 0c             	pushl  0xc(%ebp)
    51d0:	ff 75 08             	pushl  0x8(%ebp)
    51d3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    51d6:	50                   	push   %eax
    51d7:	e8 97 f9 ff ff       	call   4b73 <LodePNGBitReader_init>
    51dc:	83 c4 0c             	add    $0xc,%esp
    51df:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    51e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    51e6:	74 0a                	je     51f2 <lode_png_test_bitreader+0x2c>
    51e8:	b8 00 00 00 00       	mov    $0x0,%eax
    51ed:	e9 c3 00 00 00       	jmp    52b5 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    51f2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    51f9:	e9 a6 00 00 00       	jmp    52a4 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    51fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5201:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5208:	8b 45 14             	mov    0x14(%ebp),%eax
    520b:	01 d0                	add    %edx,%eax
    520d:	8b 00                	mov    (%eax),%eax
    520f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    5212:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    5216:	7e 14                	jle    522c <lode_png_test_bitreader+0x66>
    5218:	ff 75 ec             	pushl  -0x14(%ebp)
    521b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    521e:	50                   	push   %eax
    521f:	e8 41 fd ff ff       	call   4f65 <ensureBits32>
    5224:	83 c4 08             	add    $0x8,%esp
    5227:	89 45 f4             	mov    %eax,-0xc(%ebp)
    522a:	eb 46                	jmp    5272 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    522c:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    5230:	7e 14                	jle    5246 <lode_png_test_bitreader+0x80>
    5232:	ff 75 ec             	pushl  -0x14(%ebp)
    5235:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5238:	50                   	push   %eax
    5239:	e8 ae fb ff ff       	call   4dec <ensureBits25>
    523e:	83 c4 08             	add    $0x8,%esp
    5241:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5244:	eb 2c                	jmp    5272 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    5246:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    524a:	7e 14                	jle    5260 <lode_png_test_bitreader+0x9a>
    524c:	ff 75 ec             	pushl  -0x14(%ebp)
    524f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5252:	50                   	push   %eax
    5253:	e8 68 fa ff ff       	call   4cc0 <ensureBits17>
    5258:	83 c4 08             	add    $0x8,%esp
    525b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    525e:	eb 12                	jmp    5272 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    5260:	ff 75 ec             	pushl  -0x14(%ebp)
    5263:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5266:	50                   	push   %eax
    5267:	e8 78 f9 ff ff       	call   4be4 <ensureBits9>
    526c:	83 c4 08             	add    $0x8,%esp
    526f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    5272:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5276:	75 07                	jne    527f <lode_png_test_bitreader+0xb9>
    5278:	b8 00 00 00 00       	mov    $0x0,%eax
    527d:	eb 36                	jmp    52b5 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    527f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5282:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5289:	8b 45 18             	mov    0x18(%ebp),%eax
    528c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    528f:	ff 75 ec             	pushl  -0x14(%ebp)
    5292:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5295:	50                   	push   %eax
    5296:	e8 01 ff ff ff       	call   519c <readBits>
    529b:	83 c4 08             	add    $0x8,%esp
    529e:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    52a0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    52a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    52a7:	3b 45 10             	cmp    0x10(%ebp),%eax
    52aa:	0f 8c 4e ff ff ff    	jl     51fe <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    52b0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    52b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    52b8:	c9                   	leave  
    52b9:	c3                   	ret    

000052ba <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    52ba:	55                   	push   %ebp
    52bb:	89 e5                	mov    %esp,%ebp
    52bd:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    52c0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    52c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    52ce:	eb 27                	jmp    52f7 <reverseBits+0x3d>
    52d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    52d3:	2b 45 fc             	sub    -0x4(%ebp),%eax
    52d6:	83 e8 01             	sub    $0x1,%eax
    52d9:	8b 55 08             	mov    0x8(%ebp),%edx
    52dc:	89 c1                	mov    %eax,%ecx
    52de:	d3 ea                	shr    %cl,%edx
    52e0:	89 d0                	mov    %edx,%eax
    52e2:	83 e0 01             	and    $0x1,%eax
    52e5:	89 c2                	mov    %eax,%edx
    52e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    52ea:	89 c1                	mov    %eax,%ecx
    52ec:	d3 e2                	shl    %cl,%edx
    52ee:	89 d0                	mov    %edx,%eax
    52f0:	09 45 f8             	or     %eax,-0x8(%ebp)
    52f3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    52f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    52fa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    52fd:	72 d1                	jb     52d0 <reverseBits+0x16>
  return result;
    52ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    5302:	c9                   	leave  
    5303:	c3                   	ret    

00005304 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    5304:	55                   	push   %ebp
    5305:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    5307:	8b 45 08             	mov    0x8(%ebp),%eax
    530a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    5310:	8b 45 08             	mov    0x8(%ebp),%eax
    5313:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    531a:	8b 45 08             	mov    0x8(%ebp),%eax
    531d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    5324:	8b 45 08             	mov    0x8(%ebp),%eax
    5327:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    532e:	90                   	nop
    532f:	5d                   	pop    %ebp
    5330:	c3                   	ret    

00005331 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    5331:	55                   	push   %ebp
    5332:	89 e5                	mov    %esp,%ebp
    5334:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    5337:	8b 45 08             	mov    0x8(%ebp),%eax
    533a:	8b 00                	mov    (%eax),%eax
    533c:	83 ec 0c             	sub    $0xc,%esp
    533f:	50                   	push   %eax
    5340:	e8 ec f0 ff ff       	call   4431 <lodepng_free>
    5345:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    5348:	8b 45 08             	mov    0x8(%ebp),%eax
    534b:	8b 40 04             	mov    0x4(%eax),%eax
    534e:	83 ec 0c             	sub    $0xc,%esp
    5351:	50                   	push   %eax
    5352:	e8 da f0 ff ff       	call   4431 <lodepng_free>
    5357:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    535a:	8b 45 08             	mov    0x8(%ebp),%eax
    535d:	8b 40 10             	mov    0x10(%eax),%eax
    5360:	83 ec 0c             	sub    $0xc,%esp
    5363:	50                   	push   %eax
    5364:	e8 c8 f0 ff ff       	call   4431 <lodepng_free>
    5369:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    536c:	8b 45 08             	mov    0x8(%ebp),%eax
    536f:	8b 40 14             	mov    0x14(%eax),%eax
    5372:	83 ec 0c             	sub    $0xc,%esp
    5375:	50                   	push   %eax
    5376:	e8 b6 f0 ff ff       	call   4431 <lodepng_free>
    537b:	83 c4 10             	add    $0x10,%esp
}
    537e:	90                   	nop
    537f:	c9                   	leave  
    5380:	c3                   	ret    

00005381 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    5381:	55                   	push   %ebp
    5382:	89 e5                	mov    %esp,%ebp
    5384:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    5387:	a1 88 c6 01 00       	mov    0x1c688,%eax
    538c:	c1 e0 02             	shl    $0x2,%eax
    538f:	83 ec 0c             	sub    $0xc,%esp
    5392:	50                   	push   %eax
    5393:	e8 78 f0 ff ff       	call   4410 <lodepng_malloc>
    5398:	83 c4 10             	add    $0x10,%esp
    539b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    539e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    53a2:	75 0a                	jne    53ae <HuffmanTree_makeTable+0x2d>
    53a4:	b8 53 00 00 00       	mov    $0x53,%eax
    53a9:	e9 61 04 00 00       	jmp    580f <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    53ae:	a1 88 c6 01 00       	mov    0x1c688,%eax
    53b3:	c1 e0 02             	shl    $0x2,%eax
    53b6:	83 ec 04             	sub    $0x4,%esp
    53b9:	50                   	push   %eax
    53ba:	6a 00                	push   $0x0
    53bc:	ff 75 dc             	pushl  -0x24(%ebp)
    53bf:	e8 bd f0 ff ff       	call   4481 <lodepng_memset>
    53c4:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    53c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    53ce:	eb 7d                	jmp    544d <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    53d0:	8b 45 08             	mov    0x8(%ebp),%eax
    53d3:	8b 00                	mov    (%eax),%eax
    53d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    53d8:	c1 e2 02             	shl    $0x2,%edx
    53db:	01 d0                	add    %edx,%eax
    53dd:	8b 00                	mov    (%eax),%eax
    53df:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    53e2:	8b 45 08             	mov    0x8(%ebp),%eax
    53e5:	8b 40 04             	mov    0x4(%eax),%eax
    53e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    53eb:	c1 e2 02             	shl    $0x2,%edx
    53ee:	01 d0                	add    %edx,%eax
    53f0:	8b 00                	mov    (%eax),%eax
    53f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    53f5:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    53f9:	76 4d                	jbe    5448 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    53fb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    53fe:	83 e8 09             	sub    $0x9,%eax
    5401:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5404:	89 c1                	mov    %eax,%ecx
    5406:	d3 ea                	shr    %cl,%edx
    5408:	89 d0                	mov    %edx,%eax
    540a:	83 ec 08             	sub    $0x8,%esp
    540d:	6a 09                	push   $0x9
    540f:	50                   	push   %eax
    5410:	e8 a5 fe ff ff       	call   52ba <reverseBits>
    5415:	83 c4 10             	add    $0x10,%esp
    5418:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    541b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    541e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5425:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5428:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    542b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    542e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5435:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5438:	01 d0                	add    %edx,%eax
    543a:	8b 10                	mov    (%eax),%edx
    543c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    543f:	39 c2                	cmp    %eax,%edx
    5441:	0f 43 c2             	cmovae %edx,%eax
    5444:	89 01                	mov    %eax,(%ecx)
    5446:	eb 01                	jmp    5449 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    5448:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    5449:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    544d:	8b 45 08             	mov    0x8(%ebp),%eax
    5450:	8b 50 0c             	mov    0xc(%eax),%edx
    5453:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5456:	39 c2                	cmp    %eax,%edx
    5458:	0f 87 72 ff ff ff    	ja     53d0 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    545e:	a1 88 c6 01 00       	mov    0x1c688,%eax
    5463:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    5466:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    546d:	eb 35                	jmp    54a4 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    546f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5472:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5479:	8b 45 dc             	mov    -0x24(%ebp),%eax
    547c:	01 d0                	add    %edx,%eax
    547e:	8b 00                	mov    (%eax),%eax
    5480:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    5483:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    5487:	76 17                	jbe    54a0 <HuffmanTree_makeTable+0x11f>
    5489:	8b 45 cc             	mov    -0x34(%ebp),%eax
    548c:	83 e8 09             	sub    $0x9,%eax
    548f:	ba 01 00 00 00       	mov    $0x1,%edx
    5494:	89 c1                	mov    %eax,%ecx
    5496:	d3 e2                	shl    %cl,%edx
    5498:	8b 45 e8             	mov    -0x18(%ebp),%eax
    549b:	01 d0                	add    %edx,%eax
    549d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    54a0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    54a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    54a7:	a1 88 c6 01 00       	mov    0x1c688,%eax
    54ac:	39 c2                	cmp    %eax,%edx
    54ae:	72 bf                	jb     546f <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    54b0:	83 ec 0c             	sub    $0xc,%esp
    54b3:	ff 75 e8             	pushl  -0x18(%ebp)
    54b6:	e8 55 ef ff ff       	call   4410 <lodepng_malloc>
    54bb:	83 c4 10             	add    $0x10,%esp
    54be:	89 c2                	mov    %eax,%edx
    54c0:	8b 45 08             	mov    0x8(%ebp),%eax
    54c3:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    54c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    54c9:	01 c0                	add    %eax,%eax
    54cb:	83 ec 0c             	sub    $0xc,%esp
    54ce:	50                   	push   %eax
    54cf:	e8 3c ef ff ff       	call   4410 <lodepng_malloc>
    54d4:	83 c4 10             	add    $0x10,%esp
    54d7:	89 c2                	mov    %eax,%edx
    54d9:	8b 45 08             	mov    0x8(%ebp),%eax
    54dc:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    54df:	8b 45 08             	mov    0x8(%ebp),%eax
    54e2:	8b 40 10             	mov    0x10(%eax),%eax
    54e5:	85 c0                	test   %eax,%eax
    54e7:	74 0a                	je     54f3 <HuffmanTree_makeTable+0x172>
    54e9:	8b 45 08             	mov    0x8(%ebp),%eax
    54ec:	8b 40 14             	mov    0x14(%eax),%eax
    54ef:	85 c0                	test   %eax,%eax
    54f1:	75 18                	jne    550b <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    54f3:	83 ec 0c             	sub    $0xc,%esp
    54f6:	ff 75 dc             	pushl  -0x24(%ebp)
    54f9:	e8 33 ef ff ff       	call   4431 <lodepng_free>
    54fe:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    5501:	b8 53 00 00 00       	mov    $0x53,%eax
    5506:	e9 04 03 00 00       	jmp    580f <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    550b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5512:	eb 12                	jmp    5526 <HuffmanTree_makeTable+0x1a5>
    5514:	8b 45 08             	mov    0x8(%ebp),%eax
    5517:	8b 50 10             	mov    0x10(%eax),%edx
    551a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    551d:	01 d0                	add    %edx,%eax
    551f:	c6 00 10             	movb   $0x10,(%eax)
    5522:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5526:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5529:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    552c:	7c e6                	jl     5514 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    552e:	a1 88 c6 01 00       	mov    0x1c688,%eax
    5533:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    5536:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    553d:	eb 5b                	jmp    559a <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    553f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5542:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5549:	8b 45 dc             	mov    -0x24(%ebp),%eax
    554c:	01 d0                	add    %edx,%eax
    554e:	8b 00                	mov    (%eax),%eax
    5550:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    5553:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    5557:	76 3c                	jbe    5595 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    5559:	8b 45 08             	mov    0x8(%ebp),%eax
    555c:	8b 50 10             	mov    0x10(%eax),%edx
    555f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5562:	01 d0                	add    %edx,%eax
    5564:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5567:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    5569:	8b 45 08             	mov    0x8(%ebp),%eax
    556c:	8b 40 14             	mov    0x14(%eax),%eax
    556f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5572:	01 d2                	add    %edx,%edx
    5574:	01 d0                	add    %edx,%eax
    5576:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5579:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    557c:	8b 45 c8             	mov    -0x38(%ebp),%eax
    557f:	83 e8 09             	sub    $0x9,%eax
    5582:	ba 01 00 00 00       	mov    $0x1,%edx
    5587:	89 c1                	mov    %eax,%ecx
    5589:	d3 e2                	shl    %cl,%edx
    558b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    558e:	01 d0                	add    %edx,%eax
    5590:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5593:	eb 01                	jmp    5596 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    5595:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    5596:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    559a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    559d:	a1 88 c6 01 00       	mov    0x1c688,%eax
    55a2:	39 c2                	cmp    %eax,%edx
    55a4:	72 99                	jb     553f <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    55a6:	83 ec 0c             	sub    $0xc,%esp
    55a9:	ff 75 dc             	pushl  -0x24(%ebp)
    55ac:	e8 80 ee ff ff       	call   4431 <lodepng_free>
    55b1:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    55b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    55bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    55c2:	e9 9d 01 00 00       	jmp    5764 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    55c7:	8b 45 08             	mov    0x8(%ebp),%eax
    55ca:	8b 40 04             	mov    0x4(%eax),%eax
    55cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    55d0:	c1 e2 02             	shl    $0x2,%edx
    55d3:	01 d0                	add    %edx,%eax
    55d5:	8b 00                	mov    (%eax),%eax
    55d7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    55da:	8b 45 08             	mov    0x8(%ebp),%eax
    55dd:	8b 00                	mov    (%eax),%eax
    55df:	8b 55 f4             	mov    -0xc(%ebp),%edx
    55e2:	c1 e2 02             	shl    $0x2,%edx
    55e5:	01 d0                	add    %edx,%eax
    55e7:	8b 00                	mov    (%eax),%eax
    55e9:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    55ec:	83 ec 08             	sub    $0x8,%esp
    55ef:	ff 75 c4             	pushl  -0x3c(%ebp)
    55f2:	ff 75 c0             	pushl  -0x40(%ebp)
    55f5:	e8 c0 fc ff ff       	call   52ba <reverseBits>
    55fa:	83 c4 10             	add    $0x10,%esp
    55fd:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    5600:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    5604:	0f 84 55 01 00 00    	je     575f <HuffmanTree_makeTable+0x3de>
    numpresent++;
    560a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    560e:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    5612:	0f 87 81 00 00 00    	ja     5699 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    5618:	b8 09 00 00 00       	mov    $0x9,%eax
    561d:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    5620:	ba 01 00 00 00       	mov    $0x1,%edx
    5625:	89 c1                	mov    %eax,%ecx
    5627:	d3 e2                	shl    %cl,%edx
    5629:	89 d0                	mov    %edx,%eax
    562b:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    562e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    5635:	eb 55                	jmp    568c <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    5637:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    563a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    563d:	89 c1                	mov    %eax,%ecx
    563f:	d3 e2                	shl    %cl,%edx
    5641:	89 d0                	mov    %edx,%eax
    5643:	0b 45 bc             	or     -0x44(%ebp),%eax
    5646:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    5649:	8b 45 08             	mov    0x8(%ebp),%eax
    564c:	8b 50 10             	mov    0x10(%eax),%edx
    564f:	8b 45 98             	mov    -0x68(%ebp),%eax
    5652:	01 d0                	add    %edx,%eax
    5654:	0f b6 00             	movzbl (%eax),%eax
    5657:	3c 10                	cmp    $0x10,%al
    5659:	74 0a                	je     5665 <HuffmanTree_makeTable+0x2e4>
    565b:	b8 37 00 00 00       	mov    $0x37,%eax
    5660:	e9 aa 01 00 00       	jmp    580f <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    5665:	8b 45 08             	mov    0x8(%ebp),%eax
    5668:	8b 50 10             	mov    0x10(%eax),%edx
    566b:	8b 45 98             	mov    -0x68(%ebp),%eax
    566e:	01 d0                	add    %edx,%eax
    5670:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    5673:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    5675:	8b 45 08             	mov    0x8(%ebp),%eax
    5678:	8b 40 14             	mov    0x14(%eax),%eax
    567b:	8b 55 98             	mov    -0x68(%ebp),%edx
    567e:	01 d2                	add    %edx,%edx
    5680:	01 d0                	add    %edx,%eax
    5682:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5685:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    5688:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    568c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    568f:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    5692:	72 a3                	jb     5637 <HuffmanTree_makeTable+0x2b6>
    5694:	e9 c7 00 00 00       	jmp    5760 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    5699:	a1 8c c6 01 00       	mov    0x1c68c,%eax
    569e:	23 45 bc             	and    -0x44(%ebp),%eax
    56a1:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    56a4:	8b 45 08             	mov    0x8(%ebp),%eax
    56a7:	8b 50 10             	mov    0x10(%eax),%edx
    56aa:	8b 45 b8             	mov    -0x48(%ebp),%eax
    56ad:	01 d0                	add    %edx,%eax
    56af:	0f b6 00             	movzbl (%eax),%eax
    56b2:	0f b6 c0             	movzbl %al,%eax
    56b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    56b8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    56bb:	83 e8 09             	sub    $0x9,%eax
    56be:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    56c1:	8b 45 08             	mov    0x8(%ebp),%eax
    56c4:	8b 40 14             	mov    0x14(%eax),%eax
    56c7:	8b 55 b8             	mov    -0x48(%ebp),%edx
    56ca:	01 d2                	add    %edx,%edx
    56cc:	01 d0                	add    %edx,%eax
    56ce:	0f b7 00             	movzwl (%eax),%eax
    56d1:	0f b7 c0             	movzwl %ax,%eax
    56d4:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    56d7:	8b 45 b0             	mov    -0x50(%ebp),%eax
    56da:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    56dd:	83 c0 09             	add    $0x9,%eax
    56e0:	ba 01 00 00 00       	mov    $0x1,%edx
    56e5:	89 c1                	mov    %eax,%ecx
    56e7:	d3 e2                	shl    %cl,%edx
    56e9:	89 d0                	mov    %edx,%eax
    56eb:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    56ee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    56f1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    56f4:	73 0a                	jae    5700 <HuffmanTree_makeTable+0x37f>
    56f6:	b8 37 00 00 00       	mov    $0x37,%eax
    56fb:	e9 0f 01 00 00       	jmp    580f <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    5700:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    5707:	eb 4c                	jmp    5755 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    5709:	8b 45 bc             	mov    -0x44(%ebp),%eax
    570c:	c1 e8 09             	shr    $0x9,%eax
    570f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    5712:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5715:	83 e8 09             	sub    $0x9,%eax
    5718:	8b 55 e0             	mov    -0x20(%ebp),%edx
    571b:	89 c1                	mov    %eax,%ecx
    571d:	d3 e2                	shl    %cl,%edx
    571f:	89 d0                	mov    %edx,%eax
    5721:	0b 45 a4             	or     -0x5c(%ebp),%eax
    5724:	89 c2                	mov    %eax,%edx
    5726:	8b 45 ac             	mov    -0x54(%ebp),%eax
    5729:	01 d0                	add    %edx,%eax
    572b:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    572e:	8b 45 08             	mov    0x8(%ebp),%eax
    5731:	8b 50 10             	mov    0x10(%eax),%edx
    5734:	8b 45 a0             	mov    -0x60(%ebp),%eax
    5737:	01 d0                	add    %edx,%eax
    5739:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    573c:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    573e:	8b 45 08             	mov    0x8(%ebp),%eax
    5741:	8b 40 14             	mov    0x14(%eax),%eax
    5744:	8b 55 a0             	mov    -0x60(%ebp),%edx
    5747:	01 d2                	add    %edx,%edx
    5749:	01 d0                	add    %edx,%eax
    574b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    574e:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    5751:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5755:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5758:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    575b:	72 ac                	jb     5709 <HuffmanTree_makeTable+0x388>
    575d:	eb 01                	jmp    5760 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    575f:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    5760:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5764:	8b 45 08             	mov    0x8(%ebp),%eax
    5767:	8b 50 0c             	mov    0xc(%eax),%edx
    576a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    576d:	39 c2                	cmp    %eax,%edx
    576f:	0f 87 52 fe ff ff    	ja     55c7 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    5775:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    5779:	7f 61                	jg     57dc <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    577b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5782:	eb 4e                	jmp    57d2 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    5784:	8b 45 08             	mov    0x8(%ebp),%eax
    5787:	8b 50 10             	mov    0x10(%eax),%edx
    578a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    578d:	01 d0                	add    %edx,%eax
    578f:	0f b6 00             	movzbl (%eax),%eax
    5792:	3c 10                	cmp    $0x10,%al
    5794:	75 38                	jne    57ce <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    5796:	8b 45 08             	mov    0x8(%ebp),%eax
    5799:	8b 50 10             	mov    0x10(%eax),%edx
    579c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    579f:	01 d0                	add    %edx,%eax
    57a1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    57a4:	8b 15 88 c6 01 00    	mov    0x1c688,%edx
    57aa:	39 d1                	cmp    %edx,%ecx
    57ac:	73 07                	jae    57b5 <HuffmanTree_makeTable+0x434>
    57ae:	ba 01 00 00 00       	mov    $0x1,%edx
    57b3:	eb 05                	jmp    57ba <HuffmanTree_makeTable+0x439>
    57b5:	ba 0a 00 00 00       	mov    $0xa,%edx
    57ba:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    57bc:	8b 45 08             	mov    0x8(%ebp),%eax
    57bf:	8b 40 14             	mov    0x14(%eax),%eax
    57c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    57c5:	01 d2                	add    %edx,%edx
    57c7:	01 d0                	add    %edx,%eax
    57c9:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    57ce:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    57d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    57d5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    57d8:	7c aa                	jl     5784 <HuffmanTree_makeTable+0x403>
    57da:	eb 2e                	jmp    580a <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    57dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    57e3:	eb 1d                	jmp    5802 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    57e5:	8b 45 08             	mov    0x8(%ebp),%eax
    57e8:	8b 50 10             	mov    0x10(%eax),%edx
    57eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    57ee:	01 d0                	add    %edx,%eax
    57f0:	0f b6 00             	movzbl (%eax),%eax
    57f3:	3c 10                	cmp    $0x10,%al
    57f5:	75 07                	jne    57fe <HuffmanTree_makeTable+0x47d>
    57f7:	b8 37 00 00 00       	mov    $0x37,%eax
    57fc:	eb 11                	jmp    580f <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    57fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5802:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5805:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    5808:	7c db                	jl     57e5 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    580a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    580f:	c9                   	leave  
    5810:	c3                   	ret    

00005811 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    5811:	55                   	push   %ebp
    5812:	89 e5                	mov    %esp,%ebp
    5814:	56                   	push   %esi
    5815:	53                   	push   %ebx
    5816:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    5819:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    5820:	8b 45 08             	mov    0x8(%ebp),%eax
    5823:	8b 40 0c             	mov    0xc(%eax),%eax
    5826:	c1 e0 02             	shl    $0x2,%eax
    5829:	83 ec 0c             	sub    $0xc,%esp
    582c:	50                   	push   %eax
    582d:	e8 de eb ff ff       	call   4410 <lodepng_malloc>
    5832:	83 c4 10             	add    $0x10,%esp
    5835:	89 c2                	mov    %eax,%edx
    5837:	8b 45 08             	mov    0x8(%ebp),%eax
    583a:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    583c:	8b 45 08             	mov    0x8(%ebp),%eax
    583f:	8b 40 08             	mov    0x8(%eax),%eax
    5842:	83 c0 01             	add    $0x1,%eax
    5845:	c1 e0 02             	shl    $0x2,%eax
    5848:	83 ec 0c             	sub    $0xc,%esp
    584b:	50                   	push   %eax
    584c:	e8 bf eb ff ff       	call   4410 <lodepng_malloc>
    5851:	83 c4 10             	add    $0x10,%esp
    5854:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    5857:	8b 45 08             	mov    0x8(%ebp),%eax
    585a:	8b 40 08             	mov    0x8(%eax),%eax
    585d:	83 c0 01             	add    $0x1,%eax
    5860:	c1 e0 02             	shl    $0x2,%eax
    5863:	83 ec 0c             	sub    $0xc,%esp
    5866:	50                   	push   %eax
    5867:	e8 a4 eb ff ff       	call   4410 <lodepng_malloc>
    586c:	83 c4 10             	add    $0x10,%esp
    586f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    5872:	8b 45 08             	mov    0x8(%ebp),%eax
    5875:	8b 00                	mov    (%eax),%eax
    5877:	85 c0                	test   %eax,%eax
    5879:	74 0c                	je     5887 <HuffmanTree_makeFromLengths2+0x76>
    587b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    587f:	74 06                	je     5887 <HuffmanTree_makeFromLengths2+0x76>
    5881:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5885:	75 07                	jne    588e <HuffmanTree_makeFromLengths2+0x7d>
    5887:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    588e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5892:	0f 85 7d 01 00 00    	jne    5a15 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    5898:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    589f:	eb 2c                	jmp    58cd <HuffmanTree_makeFromLengths2+0xbc>
    58a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    58ae:	01 c2                	add    %eax,%edx
    58b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58b3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    58ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    58bd:	01 c8                	add    %ecx,%eax
    58bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    58c5:	8b 00                	mov    (%eax),%eax
    58c7:	89 02                	mov    %eax,(%edx)
    58c9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    58cd:	8b 45 08             	mov    0x8(%ebp),%eax
    58d0:	8b 40 08             	mov    0x8(%eax),%eax
    58d3:	83 c0 01             	add    $0x1,%eax
    58d6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58d9:	75 c6                	jne    58a1 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    58db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58e2:	eb 27                	jmp    590b <HuffmanTree_makeFromLengths2+0xfa>
    58e4:	8b 45 08             	mov    0x8(%ebp),%eax
    58e7:	8b 40 04             	mov    0x4(%eax),%eax
    58ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
    58ed:	c1 e2 02             	shl    $0x2,%edx
    58f0:	01 d0                	add    %edx,%eax
    58f2:	8b 00                	mov    (%eax),%eax
    58f4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    58fe:	01 d0                	add    %edx,%eax
    5900:	8b 10                	mov    (%eax),%edx
    5902:	83 c2 01             	add    $0x1,%edx
    5905:	89 10                	mov    %edx,(%eax)
    5907:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    590b:	8b 45 08             	mov    0x8(%ebp),%eax
    590e:	8b 40 0c             	mov    0xc(%eax),%eax
    5911:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5914:	75 ce                	jne    58e4 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    5916:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    591d:	eb 47                	jmp    5966 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    591f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5922:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5929:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    592c:	01 d0                	add    %edx,%eax
    592e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5931:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5937:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    593e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5941:	01 ca                	add    %ecx,%edx
    5943:	8b 0a                	mov    (%edx),%ecx
    5945:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5948:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    594e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    5955:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5958:	01 da                	add    %ebx,%edx
    595a:	8b 12                	mov    (%edx),%edx
    595c:	01 ca                	add    %ecx,%edx
    595e:	01 d2                	add    %edx,%edx
    5960:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    5962:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5966:	8b 45 08             	mov    0x8(%ebp),%eax
    5969:	8b 40 08             	mov    0x8(%eax),%eax
    596c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    596f:	73 ae                	jae    591f <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    5971:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5978:	e9 89 00 00 00       	jmp    5a06 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    597d:	8b 45 08             	mov    0x8(%ebp),%eax
    5980:	8b 40 04             	mov    0x4(%eax),%eax
    5983:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5986:	c1 e2 02             	shl    $0x2,%edx
    5989:	01 d0                	add    %edx,%eax
    598b:	8b 00                	mov    (%eax),%eax
    598d:	85 c0                	test   %eax,%eax
    598f:	74 71                	je     5a02 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    5991:	8b 45 08             	mov    0x8(%ebp),%eax
    5994:	8b 00                	mov    (%eax),%eax
    5996:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5999:	c1 e2 02             	shl    $0x2,%edx
    599c:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    599f:	8b 45 08             	mov    0x8(%ebp),%eax
    59a2:	8b 40 04             	mov    0x4(%eax),%eax
    59a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    59a8:	c1 e2 02             	shl    $0x2,%edx
    59ab:	01 d0                	add    %edx,%eax
    59ad:	8b 00                	mov    (%eax),%eax
    59af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59b9:	01 c2                	add    %eax,%edx
    59bb:	8b 02                	mov    (%edx),%eax
    59bd:	8d 48 01             	lea    0x1(%eax),%ecx
    59c0:	89 0a                	mov    %ecx,(%edx)
    59c2:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    59c4:	8b 45 08             	mov    0x8(%ebp),%eax
    59c7:	8b 00                	mov    (%eax),%eax
    59c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    59cc:	c1 e2 02             	shl    $0x2,%edx
    59cf:	01 c2                	add    %eax,%edx
    59d1:	8b 45 08             	mov    0x8(%ebp),%eax
    59d4:	8b 00                	mov    (%eax),%eax
    59d6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    59d9:	c1 e1 02             	shl    $0x2,%ecx
    59dc:	01 c8                	add    %ecx,%eax
    59de:	8b 18                	mov    (%eax),%ebx
    59e0:	8b 45 08             	mov    0x8(%ebp),%eax
    59e3:	8b 40 04             	mov    0x4(%eax),%eax
    59e6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    59e9:	c1 e1 02             	shl    $0x2,%ecx
    59ec:	01 c8                	add    %ecx,%eax
    59ee:	8b 00                	mov    (%eax),%eax
    59f0:	be 01 00 00 00       	mov    $0x1,%esi
    59f5:	89 c1                	mov    %eax,%ecx
    59f7:	d3 e6                	shl    %cl,%esi
    59f9:	89 f0                	mov    %esi,%eax
    59fb:	83 e8 01             	sub    $0x1,%eax
    59fe:	21 d8                	and    %ebx,%eax
    5a00:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    5a02:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5a06:	8b 45 08             	mov    0x8(%ebp),%eax
    5a09:	8b 40 0c             	mov    0xc(%eax),%eax
    5a0c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a0f:	0f 85 68 ff ff ff    	jne    597d <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    5a15:	83 ec 0c             	sub    $0xc,%esp
    5a18:	ff 75 e8             	pushl  -0x18(%ebp)
    5a1b:	e8 11 ea ff ff       	call   4431 <lodepng_free>
    5a20:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    5a23:	83 ec 0c             	sub    $0xc,%esp
    5a26:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a29:	e8 03 ea ff ff       	call   4431 <lodepng_free>
    5a2e:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    5a31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a35:	75 11                	jne    5a48 <HuffmanTree_makeFromLengths2+0x237>
    5a37:	83 ec 0c             	sub    $0xc,%esp
    5a3a:	ff 75 08             	pushl  0x8(%ebp)
    5a3d:	e8 3f f9 ff ff       	call   5381 <HuffmanTree_makeTable>
    5a42:	83 c4 10             	add    $0x10,%esp
    5a45:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5a48:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5a4b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5a4e:	5b                   	pop    %ebx
    5a4f:	5e                   	pop    %esi
    5a50:	5d                   	pop    %ebp
    5a51:	c3                   	ret    

00005a52 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    5a52:	55                   	push   %ebp
    5a53:	89 e5                	mov    %esp,%ebp
    5a55:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5a58:	8b 45 10             	mov    0x10(%ebp),%eax
    5a5b:	c1 e0 02             	shl    $0x2,%eax
    5a5e:	83 ec 0c             	sub    $0xc,%esp
    5a61:	50                   	push   %eax
    5a62:	e8 a9 e9 ff ff       	call   4410 <lodepng_malloc>
    5a67:	83 c4 10             	add    $0x10,%esp
    5a6a:	89 c2                	mov    %eax,%edx
    5a6c:	8b 45 08             	mov    0x8(%ebp),%eax
    5a6f:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    5a72:	8b 45 08             	mov    0x8(%ebp),%eax
    5a75:	8b 40 04             	mov    0x4(%eax),%eax
    5a78:	85 c0                	test   %eax,%eax
    5a7a:	75 07                	jne    5a83 <HuffmanTree_makeFromLengths+0x31>
    5a7c:	b8 53 00 00 00       	mov    $0x53,%eax
    5a81:	eb 56                	jmp    5ad9 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    5a83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5a8a:	eb 25                	jmp    5ab1 <HuffmanTree_makeFromLengths+0x5f>
    5a8c:	8b 45 08             	mov    0x8(%ebp),%eax
    5a8f:	8b 40 04             	mov    0x4(%eax),%eax
    5a92:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5a95:	c1 e2 02             	shl    $0x2,%edx
    5a98:	01 c2                	add    %eax,%edx
    5a9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5a9d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5aa4:	8b 45 0c             	mov    0xc(%ebp),%eax
    5aa7:	01 c8                	add    %ecx,%eax
    5aa9:	8b 00                	mov    (%eax),%eax
    5aab:	89 02                	mov    %eax,(%edx)
    5aad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5ab1:	8b 45 10             	mov    0x10(%ebp),%eax
    5ab4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5ab7:	75 d3                	jne    5a8c <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5ab9:	8b 55 10             	mov    0x10(%ebp),%edx
    5abc:	8b 45 08             	mov    0x8(%ebp),%eax
    5abf:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    5ac2:	8b 45 08             	mov    0x8(%ebp),%eax
    5ac5:	8b 55 14             	mov    0x14(%ebp),%edx
    5ac8:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    5acb:	83 ec 0c             	sub    $0xc,%esp
    5ace:	ff 75 08             	pushl  0x8(%ebp)
    5ad1:	e8 3b fd ff ff       	call   5811 <HuffmanTree_makeFromLengths2>
    5ad6:	83 c4 10             	add    $0x10,%esp
}
    5ad9:	c9                   	leave  
    5ada:	c3                   	ret    

00005adb <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    5adb:	55                   	push   %ebp
    5adc:	89 e5                	mov    %esp,%ebp
    5ade:	53                   	push   %ebx
    5adf:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    5ae2:	8b 45 08             	mov    0x8(%ebp),%eax
    5ae5:	8b 50 0c             	mov    0xc(%eax),%edx
    5ae8:	8b 45 08             	mov    0x8(%ebp),%eax
    5aeb:	8b 40 08             	mov    0x8(%eax),%eax
    5aee:	39 c2                	cmp    %eax,%edx
    5af0:	0f 82 0b 01 00 00    	jb     5c01 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    5af6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5afd:	eb 19                	jmp    5b18 <bpmnode_create+0x3d>
    5aff:	8b 45 08             	mov    0x8(%ebp),%eax
    5b02:	8b 40 04             	mov    0x4(%eax),%eax
    5b05:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5b08:	c1 e2 04             	shl    $0x4,%edx
    5b0b:	01 d0                	add    %edx,%eax
    5b0d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    5b14:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5b18:	8b 45 08             	mov    0x8(%ebp),%eax
    5b1b:	8b 00                	mov    (%eax),%eax
    5b1d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5b20:	75 dd                	jne    5aff <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    5b22:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5b29:	eb 60                	jmp    5b8b <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    5b2b:	8b 45 08             	mov    0x8(%ebp),%eax
    5b2e:	8b 40 18             	mov    0x18(%eax),%eax
    5b31:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5b34:	c1 e2 02             	shl    $0x2,%edx
    5b37:	01 d0                	add    %edx,%eax
    5b39:	8b 00                	mov    (%eax),%eax
    5b3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5b3e:	eb 13                	jmp    5b53 <bpmnode_create+0x78>
    5b40:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b43:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    5b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b4d:	8b 40 08             	mov    0x8(%eax),%eax
    5b50:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5b53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5b57:	75 e7                	jne    5b40 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    5b59:	8b 45 08             	mov    0x8(%ebp),%eax
    5b5c:	8b 40 1c             	mov    0x1c(%eax),%eax
    5b5f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5b62:	c1 e2 02             	shl    $0x2,%edx
    5b65:	01 d0                	add    %edx,%eax
    5b67:	8b 00                	mov    (%eax),%eax
    5b69:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5b6c:	eb 13                	jmp    5b81 <bpmnode_create+0xa6>
    5b6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b71:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    5b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b7b:	8b 40 08             	mov    0x8(%eax),%eax
    5b7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5b81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5b85:	75 e7                	jne    5b6e <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    5b87:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5b8b:	8b 45 08             	mov    0x8(%ebp),%eax
    5b8e:	8b 40 14             	mov    0x14(%eax),%eax
    5b91:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5b94:	75 95                	jne    5b2b <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    5b96:	8b 45 08             	mov    0x8(%ebp),%eax
    5b99:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    5ba0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5ba7:	eb 44                	jmp    5bed <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    5ba9:	8b 45 08             	mov    0x8(%ebp),%eax
    5bac:	8b 40 04             	mov    0x4(%eax),%eax
    5baf:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5bb2:	c1 e2 04             	shl    $0x4,%edx
    5bb5:	01 d0                	add    %edx,%eax
    5bb7:	8b 40 0c             	mov    0xc(%eax),%eax
    5bba:	85 c0                	test   %eax,%eax
    5bbc:	75 2b                	jne    5be9 <bpmnode_create+0x10e>
    5bbe:	8b 45 08             	mov    0x8(%ebp),%eax
    5bc1:	8b 58 10             	mov    0x10(%eax),%ebx
    5bc4:	8b 45 08             	mov    0x8(%ebp),%eax
    5bc7:	8b 40 08             	mov    0x8(%eax),%eax
    5bca:	8d 48 01             	lea    0x1(%eax),%ecx
    5bcd:	8b 55 08             	mov    0x8(%ebp),%edx
    5bd0:	89 4a 08             	mov    %ecx,0x8(%edx)
    5bd3:	c1 e0 02             	shl    $0x2,%eax
    5bd6:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    5bd9:	8b 45 08             	mov    0x8(%ebp),%eax
    5bdc:	8b 40 04             	mov    0x4(%eax),%eax
    5bdf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    5be2:	c1 e1 04             	shl    $0x4,%ecx
    5be5:	01 c8                	add    %ecx,%eax
    5be7:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    5be9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5bed:	8b 45 08             	mov    0x8(%ebp),%eax
    5bf0:	8b 00                	mov    (%eax),%eax
    5bf2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5bf5:	75 b2                	jne    5ba9 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    5bf7:	8b 45 08             	mov    0x8(%ebp),%eax
    5bfa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    5c01:	8b 45 08             	mov    0x8(%ebp),%eax
    5c04:	8b 58 10             	mov    0x10(%eax),%ebx
    5c07:	8b 45 08             	mov    0x8(%ebp),%eax
    5c0a:	8b 40 0c             	mov    0xc(%eax),%eax
    5c0d:	8d 48 01             	lea    0x1(%eax),%ecx
    5c10:	8b 55 08             	mov    0x8(%ebp),%edx
    5c13:	89 4a 0c             	mov    %ecx,0xc(%edx)
    5c16:	c1 e0 02             	shl    $0x2,%eax
    5c19:	01 d8                	add    %ebx,%eax
    5c1b:	8b 00                	mov    (%eax),%eax
    5c1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    5c20:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c23:	8b 55 0c             	mov    0xc(%ebp),%edx
    5c26:	89 10                	mov    %edx,(%eax)
  result->index = index;
    5c28:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c2b:	8b 55 10             	mov    0x10(%ebp),%edx
    5c2e:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    5c31:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c34:	8b 55 14             	mov    0x14(%ebp),%edx
    5c37:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    5c3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5c3d:	83 c4 10             	add    $0x10,%esp
    5c40:	5b                   	pop    %ebx
    5c41:	5d                   	pop    %ebp
    5c42:	c3                   	ret    

00005c43 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    5c43:	55                   	push   %ebp
    5c44:	89 e5                	mov    %esp,%ebp
    5c46:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    5c49:	8b 45 0c             	mov    0xc(%ebp),%eax
    5c4c:	c1 e0 04             	shl    $0x4,%eax
    5c4f:	83 ec 0c             	sub    $0xc,%esp
    5c52:	50                   	push   %eax
    5c53:	e8 b8 e7 ff ff       	call   4410 <lodepng_malloc>
    5c58:	83 c4 10             	add    $0x10,%esp
    5c5b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    5c5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    5c65:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    5c6c:	e9 41 01 00 00       	jmp    5db2 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    5c71:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c74:	83 e0 01             	and    $0x1,%eax
    5c77:	85 c0                	test   %eax,%eax
    5c79:	74 05                	je     5c80 <bpmnode_sort+0x3d>
    5c7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c7e:	eb 03                	jmp    5c83 <bpmnode_sort+0x40>
    5c80:	8b 45 08             	mov    0x8(%ebp),%eax
    5c83:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    5c86:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c89:	83 e0 01             	and    $0x1,%eax
    5c8c:	85 c0                	test   %eax,%eax
    5c8e:	74 05                	je     5c95 <bpmnode_sort+0x52>
    5c90:	8b 45 08             	mov    0x8(%ebp),%eax
    5c93:	eb 03                	jmp    5c98 <bpmnode_sort+0x55>
    5c95:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c98:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    5c9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5ca2:	e9 f8 00 00 00       	jmp    5d9f <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    5ca7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5caa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5cad:	01 c2                	add    %eax,%edx
    5caf:	8b 45 0c             	mov    0xc(%ebp),%eax
    5cb2:	39 c2                	cmp    %eax,%edx
    5cb4:	0f 4e c2             	cmovle %edx,%eax
    5cb7:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    5cba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5cbd:	8d 14 00             	lea    (%eax,%eax,1),%edx
    5cc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cc3:	01 c2                	add    %eax,%edx
    5cc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    5cc8:	39 c2                	cmp    %eax,%edx
    5cca:	0f 4e c2             	cmovle %edx,%eax
    5ccd:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    5cd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5cd6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5cd9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    5cdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cdf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5ce2:	e9 a4 00 00 00       	jmp    5d8b <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    5ce7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cea:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5ced:	7d 62                	jge    5d51 <bpmnode_sort+0x10e>
    5cef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5cf2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    5cf5:	7d 22                	jge    5d19 <bpmnode_sort+0xd6>
    5cf7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cfa:	c1 e0 04             	shl    $0x4,%eax
    5cfd:	89 c2                	mov    %eax,%edx
    5cff:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5d02:	01 d0                	add    %edx,%eax
    5d04:	8b 10                	mov    (%eax),%edx
    5d06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d09:	c1 e0 04             	shl    $0x4,%eax
    5d0c:	89 c1                	mov    %eax,%ecx
    5d0e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5d11:	01 c8                	add    %ecx,%eax
    5d13:	8b 00                	mov    (%eax),%eax
    5d15:	39 c2                	cmp    %eax,%edx
    5d17:	7f 38                	jg     5d51 <bpmnode_sort+0x10e>
    5d19:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d1c:	c1 e0 04             	shl    $0x4,%eax
    5d1f:	89 c2                	mov    %eax,%edx
    5d21:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5d24:	01 d0                	add    %edx,%eax
    5d26:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5d29:	8d 4a 01             	lea    0x1(%edx),%ecx
    5d2c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    5d2f:	89 d1                	mov    %edx,%ecx
    5d31:	c1 e1 04             	shl    $0x4,%ecx
    5d34:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5d37:	01 ca                	add    %ecx,%edx
    5d39:	8b 0a                	mov    (%edx),%ecx
    5d3b:	89 08                	mov    %ecx,(%eax)
    5d3d:	8b 4a 04             	mov    0x4(%edx),%ecx
    5d40:	89 48 04             	mov    %ecx,0x4(%eax)
    5d43:	8b 4a 08             	mov    0x8(%edx),%ecx
    5d46:	89 48 08             	mov    %ecx,0x8(%eax)
    5d49:	8b 52 0c             	mov    0xc(%edx),%edx
    5d4c:	89 50 0c             	mov    %edx,0xc(%eax)
    5d4f:	eb 36                	jmp    5d87 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    5d51:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d54:	c1 e0 04             	shl    $0x4,%eax
    5d57:	89 c2                	mov    %eax,%edx
    5d59:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5d5c:	01 d0                	add    %edx,%eax
    5d5e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5d61:	8d 4a 01             	lea    0x1(%edx),%ecx
    5d64:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5d67:	89 d1                	mov    %edx,%ecx
    5d69:	c1 e1 04             	shl    $0x4,%ecx
    5d6c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5d6f:	01 ca                	add    %ecx,%edx
    5d71:	8b 0a                	mov    (%edx),%ecx
    5d73:	89 08                	mov    %ecx,(%eax)
    5d75:	8b 4a 04             	mov    0x4(%edx),%ecx
    5d78:	89 48 04             	mov    %ecx,0x4(%eax)
    5d7b:	8b 4a 08             	mov    0x8(%edx),%ecx
    5d7e:	89 48 08             	mov    %ecx,0x8(%eax)
    5d81:	8b 52 0c             	mov    0xc(%edx),%edx
    5d84:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    5d87:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5d8b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d8e:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    5d91:	0f 8c 50 ff ff ff    	jl     5ce7 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    5d97:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5d9a:	01 c0                	add    %eax,%eax
    5d9c:	01 45 ec             	add    %eax,-0x14(%ebp)
    5d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5da2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5da5:	0f 8c fc fe ff ff    	jl     5ca7 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    5dab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    5daf:	d1 65 f4             	shll   -0xc(%ebp)
    5db2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5db5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5db8:	0f 8c b3 fe ff ff    	jl     5c71 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    5dbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5dc1:	83 e0 01             	and    $0x1,%eax
    5dc4:	85 c0                	test   %eax,%eax
    5dc6:	74 18                	je     5de0 <bpmnode_sort+0x19d>
    5dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dcb:	c1 e0 04             	shl    $0x4,%eax
    5dce:	83 ec 04             	sub    $0x4,%esp
    5dd1:	50                   	push   %eax
    5dd2:	ff 75 dc             	pushl  -0x24(%ebp)
    5dd5:	ff 75 08             	pushl  0x8(%ebp)
    5dd8:	e8 71 e6 ff ff       	call   444e <lodepng_memcpy>
    5ddd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    5de0:	83 ec 0c             	sub    $0xc,%esp
    5de3:	ff 75 dc             	pushl  -0x24(%ebp)
    5de6:	e8 46 e6 ff ff       	call   4431 <lodepng_free>
    5deb:	83 c4 10             	add    $0x10,%esp
}
    5dee:	90                   	nop
    5def:	c9                   	leave  
    5df0:	c3                   	ret    

00005df1 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    5df1:	55                   	push   %ebp
    5df2:	89 e5                	mov    %esp,%ebp
    5df4:	56                   	push   %esi
    5df5:	53                   	push   %ebx
    5df6:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    5df9:	8b 45 08             	mov    0x8(%ebp),%eax
    5dfc:	8b 40 1c             	mov    0x1c(%eax),%eax
    5dff:	8b 55 14             	mov    0x14(%ebp),%edx
    5e02:	c1 e2 02             	shl    $0x2,%edx
    5e05:	01 d0                	add    %edx,%eax
    5e07:	8b 00                	mov    (%eax),%eax
    5e09:	8b 40 04             	mov    0x4(%eax),%eax
    5e0c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    5e0f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5e13:	75 66                	jne    5e7b <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    5e15:	8b 45 10             	mov    0x10(%ebp),%eax
    5e18:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5e1b:	0f 83 a0 01 00 00    	jae    5fc1 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    5e21:	8b 45 08             	mov    0x8(%ebp),%eax
    5e24:	8b 40 18             	mov    0x18(%eax),%eax
    5e27:	8b 55 14             	mov    0x14(%ebp),%edx
    5e2a:	c1 e2 02             	shl    $0x2,%edx
    5e2d:	01 c2                	add    %eax,%edx
    5e2f:	8b 45 08             	mov    0x8(%ebp),%eax
    5e32:	8b 40 1c             	mov    0x1c(%eax),%eax
    5e35:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5e38:	c1 e1 02             	shl    $0x2,%ecx
    5e3b:	01 c8                	add    %ecx,%eax
    5e3d:	8b 00                	mov    (%eax),%eax
    5e3f:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    5e41:	8b 45 08             	mov    0x8(%ebp),%eax
    5e44:	8b 40 1c             	mov    0x1c(%eax),%eax
    5e47:	8b 55 14             	mov    0x14(%ebp),%edx
    5e4a:	c1 e2 02             	shl    $0x2,%edx
    5e4d:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5e50:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5e53:	8d 50 01             	lea    0x1(%eax),%edx
    5e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5e59:	c1 e0 04             	shl    $0x4,%eax
    5e5c:	89 c1                	mov    %eax,%ecx
    5e5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e61:	01 c8                	add    %ecx,%eax
    5e63:	8b 00                	mov    (%eax),%eax
    5e65:	6a 00                	push   $0x0
    5e67:	52                   	push   %edx
    5e68:	50                   	push   %eax
    5e69:	ff 75 08             	pushl  0x8(%ebp)
    5e6c:	e8 6a fc ff ff       	call   5adb <bpmnode_create>
    5e71:	83 c4 10             	add    $0x10,%esp
    5e74:	89 03                	mov    %eax,(%ebx)
    5e76:	e9 47 01 00 00       	jmp    5fc2 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    5e7b:	8b 45 08             	mov    0x8(%ebp),%eax
    5e7e:	8b 40 18             	mov    0x18(%eax),%eax
    5e81:	8b 55 14             	mov    0x14(%ebp),%edx
    5e84:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5e8a:	c1 e2 02             	shl    $0x2,%edx
    5e8d:	01 d0                	add    %edx,%eax
    5e8f:	8b 00                	mov    (%eax),%eax
    5e91:	8b 10                	mov    (%eax),%edx
    5e93:	8b 45 08             	mov    0x8(%ebp),%eax
    5e96:	8b 40 1c             	mov    0x1c(%eax),%eax
    5e99:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5e9c:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    5ea2:	c1 e1 02             	shl    $0x2,%ecx
    5ea5:	01 c8                	add    %ecx,%eax
    5ea7:	8b 00                	mov    (%eax),%eax
    5ea9:	8b 00                	mov    (%eax),%eax
    5eab:	01 d0                	add    %edx,%eax
    5ead:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    5eb0:	8b 45 08             	mov    0x8(%ebp),%eax
    5eb3:	8b 40 18             	mov    0x18(%eax),%eax
    5eb6:	8b 55 14             	mov    0x14(%ebp),%edx
    5eb9:	c1 e2 02             	shl    $0x2,%edx
    5ebc:	01 c2                	add    %eax,%edx
    5ebe:	8b 45 08             	mov    0x8(%ebp),%eax
    5ec1:	8b 40 1c             	mov    0x1c(%eax),%eax
    5ec4:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5ec7:	c1 e1 02             	shl    $0x2,%ecx
    5eca:	01 c8                	add    %ecx,%eax
    5ecc:	8b 00                	mov    (%eax),%eax
    5ece:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    5ed0:	8b 45 10             	mov    0x10(%ebp),%eax
    5ed3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5ed6:	73 60                	jae    5f38 <boundaryPM+0x147>
    5ed8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5edb:	c1 e0 04             	shl    $0x4,%eax
    5ede:	89 c2                	mov    %eax,%edx
    5ee0:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ee3:	01 d0                	add    %edx,%eax
    5ee5:	8b 00                	mov    (%eax),%eax
    5ee7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5eea:	7d 4c                	jge    5f38 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    5eec:	8b 45 08             	mov    0x8(%ebp),%eax
    5eef:	8b 40 1c             	mov    0x1c(%eax),%eax
    5ef2:	8b 55 14             	mov    0x14(%ebp),%edx
    5ef5:	c1 e2 02             	shl    $0x2,%edx
    5ef8:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5efb:	8b 45 08             	mov    0x8(%ebp),%eax
    5efe:	8b 40 1c             	mov    0x1c(%eax),%eax
    5f01:	8b 55 14             	mov    0x14(%ebp),%edx
    5f04:	c1 e2 02             	shl    $0x2,%edx
    5f07:	01 d0                	add    %edx,%eax
    5f09:	8b 00                	mov    (%eax),%eax
    5f0b:	8b 50 08             	mov    0x8(%eax),%edx
    5f0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5f11:	8d 48 01             	lea    0x1(%eax),%ecx
    5f14:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5f17:	c1 e0 04             	shl    $0x4,%eax
    5f1a:	89 c6                	mov    %eax,%esi
    5f1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f1f:	01 f0                	add    %esi,%eax
    5f21:	8b 00                	mov    (%eax),%eax
    5f23:	52                   	push   %edx
    5f24:	51                   	push   %ecx
    5f25:	50                   	push   %eax
    5f26:	ff 75 08             	pushl  0x8(%ebp)
    5f29:	e8 ad fb ff ff       	call   5adb <bpmnode_create>
    5f2e:	83 c4 10             	add    $0x10,%esp
    5f31:	89 03                	mov    %eax,(%ebx)
      return;
    5f33:	e9 8a 00 00 00       	jmp    5fc2 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    5f38:	8b 45 08             	mov    0x8(%ebp),%eax
    5f3b:	8b 40 1c             	mov    0x1c(%eax),%eax
    5f3e:	8b 55 14             	mov    0x14(%ebp),%edx
    5f41:	c1 e2 02             	shl    $0x2,%edx
    5f44:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5f47:	8b 45 08             	mov    0x8(%ebp),%eax
    5f4a:	8b 40 1c             	mov    0x1c(%eax),%eax
    5f4d:	8b 55 14             	mov    0x14(%ebp),%edx
    5f50:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5f56:	c1 e2 02             	shl    $0x2,%edx
    5f59:	01 d0                	add    %edx,%eax
    5f5b:	8b 00                	mov    (%eax),%eax
    5f5d:	50                   	push   %eax
    5f5e:	ff 75 f4             	pushl  -0xc(%ebp)
    5f61:	ff 75 f0             	pushl  -0x10(%ebp)
    5f64:	ff 75 08             	pushl  0x8(%ebp)
    5f67:	e8 6f fb ff ff       	call   5adb <bpmnode_create>
    5f6c:	83 c4 10             	add    $0x10,%esp
    5f6f:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    5f71:	8b 45 18             	mov    0x18(%ebp),%eax
    5f74:	8d 50 01             	lea    0x1(%eax),%edx
    5f77:	8b 45 10             	mov    0x10(%ebp),%eax
    5f7a:	83 e8 01             	sub    $0x1,%eax
    5f7d:	01 c0                	add    %eax,%eax
    5f7f:	39 c2                	cmp    %eax,%edx
    5f81:	7d 3f                	jge    5fc2 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5f83:	8b 45 14             	mov    0x14(%ebp),%eax
    5f86:	83 e8 01             	sub    $0x1,%eax
    5f89:	83 ec 0c             	sub    $0xc,%esp
    5f8c:	ff 75 18             	pushl  0x18(%ebp)
    5f8f:	50                   	push   %eax
    5f90:	ff 75 10             	pushl  0x10(%ebp)
    5f93:	ff 75 0c             	pushl  0xc(%ebp)
    5f96:	ff 75 08             	pushl  0x8(%ebp)
    5f99:	e8 53 fe ff ff       	call   5df1 <boundaryPM>
    5f9e:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5fa1:	8b 45 14             	mov    0x14(%ebp),%eax
    5fa4:	83 e8 01             	sub    $0x1,%eax
    5fa7:	83 ec 0c             	sub    $0xc,%esp
    5faa:	ff 75 18             	pushl  0x18(%ebp)
    5fad:	50                   	push   %eax
    5fae:	ff 75 10             	pushl  0x10(%ebp)
    5fb1:	ff 75 0c             	pushl  0xc(%ebp)
    5fb4:	ff 75 08             	pushl  0x8(%ebp)
    5fb7:	e8 35 fe ff ff       	call   5df1 <boundaryPM>
    5fbc:	83 c4 20             	add    $0x20,%esp
    5fbf:	eb 01                	jmp    5fc2 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    5fc1:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    5fc2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5fc5:	5b                   	pop    %ebx
    5fc6:	5e                   	pop    %esi
    5fc7:	5d                   	pop    %ebp
    5fc8:	c3                   	ret    

00005fc9 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    5fc9:	55                   	push   %ebp
    5fca:	89 e5                	mov    %esp,%ebp
    5fcc:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    5fcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    5fd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    5fdd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    5fe1:	75 0a                	jne    5fed <lodepng_huffman_code_lengths+0x24>
    5fe3:	b8 50 00 00 00       	mov    $0x50,%eax
    5fe8:	e9 4d 03 00 00       	jmp    633a <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    5fed:	8b 45 14             	mov    0x14(%ebp),%eax
    5ff0:	ba 01 00 00 00       	mov    $0x1,%edx
    5ff5:	89 c1                	mov    %eax,%ecx
    5ff7:	d3 e2                	shl    %cl,%edx
    5ff9:	8b 45 10             	mov    0x10(%ebp),%eax
    5ffc:	39 c2                	cmp    %eax,%edx
    5ffe:	73 0a                	jae    600a <lodepng_huffman_code_lengths+0x41>
    6000:	b8 50 00 00 00       	mov    $0x50,%eax
    6005:	e9 30 03 00 00       	jmp    633a <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    600a:	8b 45 10             	mov    0x10(%ebp),%eax
    600d:	c1 e0 04             	shl    $0x4,%eax
    6010:	83 ec 0c             	sub    $0xc,%esp
    6013:	50                   	push   %eax
    6014:	e8 f7 e3 ff ff       	call   4410 <lodepng_malloc>
    6019:	83 c4 10             	add    $0x10,%esp
    601c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    601f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6023:	75 0a                	jne    602f <lodepng_huffman_code_lengths+0x66>
    6025:	b8 53 00 00 00       	mov    $0x53,%eax
    602a:	e9 0b 03 00 00       	jmp    633a <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    602f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6036:	eb 50                	jmp    6088 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    6038:	8b 45 f0             	mov    -0x10(%ebp),%eax
    603b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6042:	8b 45 0c             	mov    0xc(%ebp),%eax
    6045:	01 d0                	add    %edx,%eax
    6047:	8b 00                	mov    (%eax),%eax
    6049:	85 c0                	test   %eax,%eax
    604b:	74 37                	je     6084 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    604d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6050:	c1 e0 04             	shl    $0x4,%eax
    6053:	89 c2                	mov    %eax,%edx
    6055:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6058:	01 d0                	add    %edx,%eax
    605a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    605d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    6064:	8b 55 0c             	mov    0xc(%ebp),%edx
    6067:	01 ca                	add    %ecx,%edx
    6069:	8b 12                	mov    (%edx),%edx
    606b:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    606d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6070:	c1 e0 04             	shl    $0x4,%eax
    6073:	89 c2                	mov    %eax,%edx
    6075:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6078:	01 c2                	add    %eax,%edx
    607a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    607d:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    6080:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    6084:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6088:	8b 45 10             	mov    0x10(%ebp),%eax
    608b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    608e:	75 a8                	jne    6038 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    6090:	8b 45 10             	mov    0x10(%ebp),%eax
    6093:	c1 e0 02             	shl    $0x2,%eax
    6096:	83 ec 04             	sub    $0x4,%esp
    6099:	50                   	push   %eax
    609a:	6a 00                	push   $0x0
    609c:	ff 75 08             	pushl  0x8(%ebp)
    609f:	e8 dd e3 ff ff       	call   4481 <lodepng_memset>
    60a4:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    60a7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    60ab:	75 18                	jne    60c5 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    60ad:	8b 45 08             	mov    0x8(%ebp),%eax
    60b0:	83 c0 04             	add    $0x4,%eax
    60b3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    60b9:	8b 10                	mov    (%eax),%edx
    60bb:	8b 45 08             	mov    0x8(%ebp),%eax
    60be:	89 10                	mov    %edx,(%eax)
    60c0:	e9 64 02 00 00       	jmp    6329 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    60c5:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    60c9:	75 3e                	jne    6109 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    60cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    60ce:	8b 40 04             	mov    0x4(%eax),%eax
    60d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60d8:	8b 45 08             	mov    0x8(%ebp),%eax
    60db:	01 d0                	add    %edx,%eax
    60dd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    60e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    60e6:	8b 40 04             	mov    0x4(%eax),%eax
    60e9:	85 c0                	test   %eax,%eax
    60eb:	75 07                	jne    60f4 <lodepng_huffman_code_lengths+0x12b>
    60ed:	ba 04 00 00 00       	mov    $0x4,%edx
    60f2:	eb 05                	jmp    60f9 <lodepng_huffman_code_lengths+0x130>
    60f4:	ba 00 00 00 00       	mov    $0x0,%edx
    60f9:	8b 45 08             	mov    0x8(%ebp),%eax
    60fc:	01 d0                	add    %edx,%eax
    60fe:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    6104:	e9 20 02 00 00       	jmp    6329 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    6109:	83 ec 08             	sub    $0x8,%esp
    610c:	ff 75 ec             	pushl  -0x14(%ebp)
    610f:	ff 75 e4             	pushl  -0x1c(%ebp)
    6112:	e8 2c fb ff ff       	call   5c43 <bpmnode_sort>
    6117:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    611a:	8b 45 14             	mov    0x14(%ebp),%eax
    611d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    6120:	8b 45 14             	mov    0x14(%ebp),%eax
    6123:	83 c0 01             	add    $0x1,%eax
    6126:	0f af 45 14          	imul   0x14(%ebp),%eax
    612a:	01 c0                	add    %eax,%eax
    612c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    612f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    6136:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6139:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    613c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    613f:	c1 e0 04             	shl    $0x4,%eax
    6142:	83 ec 0c             	sub    $0xc,%esp
    6145:	50                   	push   %eax
    6146:	e8 c5 e2 ff ff       	call   4410 <lodepng_malloc>
    614b:	83 c4 10             	add    $0x10,%esp
    614e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    6151:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6154:	c1 e0 02             	shl    $0x2,%eax
    6157:	83 ec 0c             	sub    $0xc,%esp
    615a:	50                   	push   %eax
    615b:	e8 b0 e2 ff ff       	call   4410 <lodepng_malloc>
    6160:	83 c4 10             	add    $0x10,%esp
    6163:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    6166:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6169:	c1 e0 02             	shl    $0x2,%eax
    616c:	83 ec 0c             	sub    $0xc,%esp
    616f:	50                   	push   %eax
    6170:	e8 9b e2 ff ff       	call   4410 <lodepng_malloc>
    6175:	83 c4 10             	add    $0x10,%esp
    6178:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    617b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    617e:	c1 e0 02             	shl    $0x2,%eax
    6181:	83 ec 0c             	sub    $0xc,%esp
    6184:	50                   	push   %eax
    6185:	e8 86 e2 ff ff       	call   4410 <lodepng_malloc>
    618a:	83 c4 10             	add    $0x10,%esp
    618d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    6190:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6193:	85 c0                	test   %eax,%eax
    6195:	74 15                	je     61ac <lodepng_huffman_code_lengths+0x1e3>
    6197:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    619a:	85 c0                	test   %eax,%eax
    619c:	74 0e                	je     61ac <lodepng_huffman_code_lengths+0x1e3>
    619e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    61a1:	85 c0                	test   %eax,%eax
    61a3:	74 07                	je     61ac <lodepng_huffman_code_lengths+0x1e3>
    61a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    61a8:	85 c0                	test   %eax,%eax
    61aa:	75 07                	jne    61b3 <lodepng_huffman_code_lengths+0x1ea>
    61ac:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    61b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    61b7:	0f 85 30 01 00 00    	jne    62ed <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    61bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    61c4:	eb 1c                	jmp    61e2 <lodepng_huffman_code_lengths+0x219>
    61c6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    61c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    61cc:	c1 e2 02             	shl    $0x2,%edx
    61cf:	01 d0                	add    %edx,%eax
    61d1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    61d4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    61d7:	c1 e1 04             	shl    $0x4,%ecx
    61da:	01 ca                	add    %ecx,%edx
    61dc:	89 10                	mov    %edx,(%eax)
    61de:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    61e2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    61e5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    61e8:	75 dc                	jne    61c6 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    61ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    61ed:	8b 00                	mov    (%eax),%eax
    61ef:	6a 00                	push   $0x0
    61f1:	6a 01                	push   $0x1
    61f3:	50                   	push   %eax
    61f4:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    61f7:	50                   	push   %eax
    61f8:	e8 de f8 ff ff       	call   5adb <bpmnode_create>
    61fd:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    6200:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6203:	83 c0 10             	add    $0x10,%eax
    6206:	8b 00                	mov    (%eax),%eax
    6208:	6a 00                	push   $0x0
    620a:	6a 02                	push   $0x2
    620c:	50                   	push   %eax
    620d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    6210:	50                   	push   %eax
    6211:	e8 c5 f8 ff ff       	call   5adb <bpmnode_create>
    6216:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    6219:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6220:	eb 27                	jmp    6249 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    6222:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6225:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6228:	c1 e2 02             	shl    $0x2,%edx
    622b:	01 c2                	add    %eax,%edx
    622d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6230:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    6232:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6235:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6238:	c1 e2 02             	shl    $0x2,%edx
    623b:	01 d0                	add    %edx,%eax
    623d:	8b 55 c8             	mov    -0x38(%ebp),%edx
    6240:	83 c2 10             	add    $0x10,%edx
    6243:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    6245:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6249:	8b 45 d8             	mov    -0x28(%ebp),%eax
    624c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    624f:	75 d1                	jne    6222 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    6251:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    6258:	eb 24                	jmp    627e <lodepng_huffman_code_lengths+0x2b5>
    625a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    625d:	8b 55 14             	mov    0x14(%ebp),%edx
    6260:	83 ea 01             	sub    $0x1,%edx
    6263:	83 ec 0c             	sub    $0xc,%esp
    6266:	50                   	push   %eax
    6267:	52                   	push   %edx
    6268:	ff 75 ec             	pushl  -0x14(%ebp)
    626b:	ff 75 e4             	pushl  -0x1c(%ebp)
    626e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    6271:	50                   	push   %eax
    6272:	e8 7a fb ff ff       	call   5df1 <boundaryPM>
    6277:	83 c4 20             	add    $0x20,%esp
    627a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    627e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6281:	83 e8 01             	sub    $0x1,%eax
    6284:	01 c0                	add    %eax,%eax
    6286:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6289:	75 cf                	jne    625a <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    628b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    628e:	8b 55 14             	mov    0x14(%ebp),%edx
    6291:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    6297:	c1 e2 02             	shl    $0x2,%edx
    629a:	01 d0                	add    %edx,%eax
    629c:	8b 00                	mov    (%eax),%eax
    629e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    62a1:	eb 44                	jmp    62e7 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    62a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    62aa:	eb 27                	jmp    62d3 <lodepng_huffman_code_lengths+0x30a>
    62ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    62af:	c1 e0 04             	shl    $0x4,%eax
    62b2:	89 c2                	mov    %eax,%edx
    62b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    62b7:	01 d0                	add    %edx,%eax
    62b9:	8b 40 04             	mov    0x4(%eax),%eax
    62bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    62c3:	8b 45 08             	mov    0x8(%ebp),%eax
    62c6:	01 d0                	add    %edx,%eax
    62c8:	8b 10                	mov    (%eax),%edx
    62ca:	83 c2 01             	add    $0x1,%edx
    62cd:	89 10                	mov    %edx,(%eax)
    62cf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    62d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    62d6:	8b 40 04             	mov    0x4(%eax),%eax
    62d9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    62dc:	75 ce                	jne    62ac <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    62de:	8b 45 e8             	mov    -0x18(%ebp),%eax
    62e1:	8b 40 08             	mov    0x8(%eax),%eax
    62e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    62e7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    62eb:	75 b6                	jne    62a3 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    62ed:	8b 45 c8             	mov    -0x38(%ebp),%eax
    62f0:	83 ec 0c             	sub    $0xc,%esp
    62f3:	50                   	push   %eax
    62f4:	e8 38 e1 ff ff       	call   4431 <lodepng_free>
    62f9:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    62fc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    62ff:	83 ec 0c             	sub    $0xc,%esp
    6302:	50                   	push   %eax
    6303:	e8 29 e1 ff ff       	call   4431 <lodepng_free>
    6308:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    630b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    630e:	83 ec 0c             	sub    $0xc,%esp
    6311:	50                   	push   %eax
    6312:	e8 1a e1 ff ff       	call   4431 <lodepng_free>
    6317:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    631a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    631d:	83 ec 0c             	sub    $0xc,%esp
    6320:	50                   	push   %eax
    6321:	e8 0b e1 ff ff       	call   4431 <lodepng_free>
    6326:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    6329:	83 ec 0c             	sub    $0xc,%esp
    632c:	ff 75 e4             	pushl  -0x1c(%ebp)
    632f:	e8 fd e0 ff ff       	call   4431 <lodepng_free>
    6334:	83 c4 10             	add    $0x10,%esp
  return error;
    6337:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    633a:	c9                   	leave  
    633b:	c3                   	ret    

0000633c <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    633c:	55                   	push   %ebp
    633d:	89 e5                	mov    %esp,%ebp
    633f:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    6342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    6349:	eb 04                	jmp    634f <HuffmanTree_makeFromFrequencies+0x13>
    634b:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    634f:	8b 45 14             	mov    0x14(%ebp),%eax
    6352:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    6357:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    635e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6361:	01 d0                	add    %edx,%eax
    6363:	8b 00                	mov    (%eax),%eax
    6365:	85 c0                	test   %eax,%eax
    6367:	75 08                	jne    6371 <HuffmanTree_makeFromFrequencies+0x35>
    6369:	8b 45 14             	mov    0x14(%ebp),%eax
    636c:	3b 45 10             	cmp    0x10(%ebp),%eax
    636f:	7f da                	jg     634b <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    6371:	8b 45 14             	mov    0x14(%ebp),%eax
    6374:	c1 e0 02             	shl    $0x2,%eax
    6377:	83 ec 0c             	sub    $0xc,%esp
    637a:	50                   	push   %eax
    637b:	e8 90 e0 ff ff       	call   4410 <lodepng_malloc>
    6380:	83 c4 10             	add    $0x10,%esp
    6383:	89 c2                	mov    %eax,%edx
    6385:	8b 45 08             	mov    0x8(%ebp),%eax
    6388:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    638b:	8b 45 08             	mov    0x8(%ebp),%eax
    638e:	8b 40 04             	mov    0x4(%eax),%eax
    6391:	85 c0                	test   %eax,%eax
    6393:	75 07                	jne    639c <HuffmanTree_makeFromFrequencies+0x60>
    6395:	b8 53 00 00 00       	mov    $0x53,%eax
    639a:	eb 47                	jmp    63e3 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    639c:	8b 45 08             	mov    0x8(%ebp),%eax
    639f:	8b 55 18             	mov    0x18(%ebp),%edx
    63a2:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    63a5:	8b 55 14             	mov    0x14(%ebp),%edx
    63a8:	8b 45 08             	mov    0x8(%ebp),%eax
    63ab:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    63ae:	8b 45 08             	mov    0x8(%ebp),%eax
    63b1:	8b 40 04             	mov    0x4(%eax),%eax
    63b4:	ff 75 18             	pushl  0x18(%ebp)
    63b7:	ff 75 14             	pushl  0x14(%ebp)
    63ba:	ff 75 0c             	pushl  0xc(%ebp)
    63bd:	50                   	push   %eax
    63be:	e8 06 fc ff ff       	call   5fc9 <lodepng_huffman_code_lengths>
    63c3:	83 c4 10             	add    $0x10,%esp
    63c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    63c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    63cd:	75 11                	jne    63e0 <HuffmanTree_makeFromFrequencies+0xa4>
    63cf:	83 ec 0c             	sub    $0xc,%esp
    63d2:	ff 75 08             	pushl  0x8(%ebp)
    63d5:	e8 37 f4 ff ff       	call   5811 <HuffmanTree_makeFromLengths2>
    63da:	83 c4 10             	add    $0x10,%esp
    63dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    63e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    63e3:	c9                   	leave  
    63e4:	c3                   	ret    

000063e5 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    63e5:	55                   	push   %ebp
    63e6:	89 e5                	mov    %esp,%ebp
    63e8:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    63eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    63f2:	83 ec 0c             	sub    $0xc,%esp
    63f5:	68 80 04 00 00       	push   $0x480
    63fa:	e8 11 e0 ff ff       	call   4410 <lodepng_malloc>
    63ff:	83 c4 10             	add    $0x10,%esp
    6402:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    6405:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6409:	75 0a                	jne    6415 <generateFixedLitLenTree+0x30>
    640b:	b8 53 00 00 00       	mov    $0x53,%eax
    6410:	e9 d5 00 00 00       	jmp    64ea <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    6415:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    641c:	eb 19                	jmp    6437 <generateFixedLitLenTree+0x52>
    641e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6421:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6428:	8b 45 ec             	mov    -0x14(%ebp),%eax
    642b:	01 d0                	add    %edx,%eax
    642d:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    6433:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6437:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    643e:	76 de                	jbe    641e <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    6440:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    6447:	eb 19                	jmp    6462 <generateFixedLitLenTree+0x7d>
    6449:	8b 45 f4             	mov    -0xc(%ebp),%eax
    644c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6453:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6456:	01 d0                	add    %edx,%eax
    6458:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    645e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6462:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    6469:	76 de                	jbe    6449 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    646b:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    6472:	eb 19                	jmp    648d <generateFixedLitLenTree+0xa8>
    6474:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6477:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    647e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6481:	01 d0                	add    %edx,%eax
    6483:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    6489:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    648d:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    6494:	76 de                	jbe    6474 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    6496:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    649d:	eb 19                	jmp    64b8 <generateFixedLitLenTree+0xd3>
    649f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    64a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    64ac:	01 d0                	add    %edx,%eax
    64ae:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    64b4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    64b8:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    64bf:	76 de                	jbe    649f <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    64c1:	6a 0f                	push   $0xf
    64c3:	68 20 01 00 00       	push   $0x120
    64c8:	ff 75 ec             	pushl  -0x14(%ebp)
    64cb:	ff 75 08             	pushl  0x8(%ebp)
    64ce:	e8 7f f5 ff ff       	call   5a52 <HuffmanTree_makeFromLengths>
    64d3:	83 c4 10             	add    $0x10,%esp
    64d6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    64d9:	83 ec 0c             	sub    $0xc,%esp
    64dc:	ff 75 ec             	pushl  -0x14(%ebp)
    64df:	e8 4d df ff ff       	call   4431 <lodepng_free>
    64e4:	83 c4 10             	add    $0x10,%esp
  return error;
    64e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    64ea:	c9                   	leave  
    64eb:	c3                   	ret    

000064ec <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    64ec:	55                   	push   %ebp
    64ed:	89 e5                	mov    %esp,%ebp
    64ef:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    64f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    64f9:	83 ec 0c             	sub    $0xc,%esp
    64fc:	68 80 00 00 00       	push   $0x80
    6501:	e8 0a df ff ff       	call   4410 <lodepng_malloc>
    6506:	83 c4 10             	add    $0x10,%esp
    6509:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    650c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6510:	75 07                	jne    6519 <generateFixedDistanceTree+0x2d>
    6512:	b8 53 00 00 00       	mov    $0x53,%eax
    6517:	eb 4e                	jmp    6567 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    6519:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6520:	eb 19                	jmp    653b <generateFixedDistanceTree+0x4f>
    6522:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6525:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    652c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    652f:	01 d0                	add    %edx,%eax
    6531:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    6537:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    653b:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    653f:	75 e1                	jne    6522 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    6541:	6a 0f                	push   $0xf
    6543:	6a 20                	push   $0x20
    6545:	ff 75 ec             	pushl  -0x14(%ebp)
    6548:	ff 75 08             	pushl  0x8(%ebp)
    654b:	e8 02 f5 ff ff       	call   5a52 <HuffmanTree_makeFromLengths>
    6550:	83 c4 10             	add    $0x10,%esp
    6553:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    6556:	83 ec 0c             	sub    $0xc,%esp
    6559:	ff 75 ec             	pushl  -0x14(%ebp)
    655c:	e8 d0 de ff ff       	call   4431 <lodepng_free>
    6561:	83 c4 10             	add    $0x10,%esp
  return error;
    6564:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6567:	c9                   	leave  
    6568:	c3                   	ret    

00006569 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    6569:	55                   	push   %ebp
    656a:	89 e5                	mov    %esp,%ebp
    656c:	53                   	push   %ebx
    656d:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    6570:	6a 09                	push   $0x9
    6572:	ff 75 08             	pushl  0x8(%ebp)
    6575:	e8 d8 eb ff ff       	call   5152 <peekBits>
    657a:	83 c4 08             	add    $0x8,%esp
    657d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    6581:	8b 45 0c             	mov    0xc(%ebp),%eax
    6584:	8b 50 10             	mov    0x10(%eax),%edx
    6587:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    658b:	01 d0                	add    %edx,%eax
    658d:	0f b6 00             	movzbl (%eax),%eax
    6590:	0f b6 c0             	movzbl %al,%eax
    6593:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    6597:	8b 45 0c             	mov    0xc(%ebp),%eax
    659a:	8b 40 14             	mov    0x14(%eax),%eax
    659d:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    65a1:	01 d2                	add    %edx,%edx
    65a3:	01 d0                	add    %edx,%eax
    65a5:	0f b7 00             	movzwl (%eax),%eax
    65a8:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    65ac:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    65b1:	77 16                	ja     65c9 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    65b3:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    65b7:	50                   	push   %eax
    65b8:	ff 75 08             	pushl  0x8(%ebp)
    65bb:	e8 b2 eb ff ff       	call   5172 <advanceBits>
    65c0:	83 c4 08             	add    $0x8,%esp
    return value;
    65c3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    65c7:	eb 5c                	jmp    6625 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    65c9:	6a 09                	push   $0x9
    65cb:	ff 75 08             	pushl  0x8(%ebp)
    65ce:	e8 9f eb ff ff       	call   5172 <advanceBits>
    65d3:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    65d6:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    65da:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    65de:	83 e8 09             	sub    $0x9,%eax
    65e1:	50                   	push   %eax
    65e2:	ff 75 08             	pushl  0x8(%ebp)
    65e5:	e8 68 eb ff ff       	call   5152 <peekBits>
    65ea:	83 c4 08             	add    $0x8,%esp
    65ed:	01 d8                	add    %ebx,%eax
    65ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    65f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    65f5:	8b 50 10             	mov    0x10(%eax),%edx
    65f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    65fb:	01 d0                	add    %edx,%eax
    65fd:	0f b6 00             	movzbl (%eax),%eax
    6600:	0f b6 c0             	movzbl %al,%eax
    6603:	83 e8 09             	sub    $0x9,%eax
    6606:	50                   	push   %eax
    6607:	ff 75 08             	pushl  0x8(%ebp)
    660a:	e8 63 eb ff ff       	call   5172 <advanceBits>
    660f:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    6612:	8b 45 0c             	mov    0xc(%ebp),%eax
    6615:	8b 40 14             	mov    0x14(%eax),%eax
    6618:	8b 55 f0             	mov    -0x10(%ebp),%edx
    661b:	01 d2                	add    %edx,%edx
    661d:	01 d0                	add    %edx,%eax
    661f:	0f b7 00             	movzwl (%eax),%eax
    6622:	0f b7 c0             	movzwl %ax,%eax
  }
}
    6625:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6628:	c9                   	leave  
    6629:	c3                   	ret    

0000662a <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    662a:	55                   	push   %ebp
    662b:	89 e5                	mov    %esp,%ebp
    662d:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    6630:	83 ec 0c             	sub    $0xc,%esp
    6633:	ff 75 08             	pushl  0x8(%ebp)
    6636:	e8 aa fd ff ff       	call   63e5 <generateFixedLitLenTree>
    663b:	83 c4 10             	add    $0x10,%esp
    663e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    6641:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6645:	74 05                	je     664c <getTreeInflateFixed+0x22>
    6647:	8b 45 f4             	mov    -0xc(%ebp),%eax
    664a:	eb 0e                	jmp    665a <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    664c:	83 ec 0c             	sub    $0xc,%esp
    664f:	ff 75 0c             	pushl  0xc(%ebp)
    6652:	e8 95 fe ff ff       	call   64ec <generateFixedDistanceTree>
    6657:	83 c4 10             	add    $0x10,%esp
}
    665a:	c9                   	leave  
    665b:	c3                   	ret    

0000665c <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    665c:	55                   	push   %ebp
    665d:	89 e5                	mov    %esp,%ebp
    665f:	53                   	push   %ebx
    6660:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    6663:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    666a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    6671:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    6678:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    667f:	6a 0e                	push   $0xe
    6681:	ff 75 10             	pushl  0x10(%ebp)
    6684:	e8 37 e6 ff ff       	call   4cc0 <ensureBits17>
    6689:	83 c4 08             	add    $0x8,%esp
    668c:	85 c0                	test   %eax,%eax
    668e:	75 0a                	jne    669a <getTreeInflateDynamic+0x3e>
    6690:	b8 31 00 00 00       	mov    $0x31,%eax
    6695:	e9 ec 04 00 00       	jmp    6b86 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    669a:	6a 05                	push   $0x5
    669c:	ff 75 10             	pushl  0x10(%ebp)
    669f:	e8 f8 ea ff ff       	call   519c <readBits>
    66a4:	83 c4 08             	add    $0x8,%esp
    66a7:	05 01 01 00 00       	add    $0x101,%eax
    66ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    66af:	6a 05                	push   $0x5
    66b1:	ff 75 10             	pushl  0x10(%ebp)
    66b4:	e8 e3 ea ff ff       	call   519c <readBits>
    66b9:	83 c4 08             	add    $0x8,%esp
    66bc:	83 c0 01             	add    $0x1,%eax
    66bf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    66c2:	6a 04                	push   $0x4
    66c4:	ff 75 10             	pushl  0x10(%ebp)
    66c7:	e8 d0 ea ff ff       	call   519c <readBits>
    66cc:	83 c4 08             	add    $0x8,%esp
    66cf:	83 c0 04             	add    $0x4,%eax
    66d2:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    66d5:	83 ec 0c             	sub    $0xc,%esp
    66d8:	6a 4c                	push   $0x4c
    66da:	e8 31 dd ff ff       	call   4410 <lodepng_malloc>
    66df:	83 c4 10             	add    $0x10,%esp
    66e2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    66e5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    66e9:	75 0a                	jne    66f5 <getTreeInflateDynamic+0x99>
    66eb:	b8 53 00 00 00       	mov    $0x53,%eax
    66f0:	e9 91 04 00 00       	jmp    6b86 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    66f5:	83 ec 0c             	sub    $0xc,%esp
    66f8:	8d 45 a8             	lea    -0x58(%ebp),%eax
    66fb:	50                   	push   %eax
    66fc:	e8 03 ec ff ff       	call   5304 <HuffmanTree_init>
    6701:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    6704:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6708:	0f 85 3c 04 00 00    	jne    6b4a <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    670e:	8b 45 10             	mov    0x10(%ebp),%eax
    6711:	8b 48 08             	mov    0x8(%eax),%ecx
    6714:	8b 55 d0             	mov    -0x30(%ebp),%edx
    6717:	89 d0                	mov    %edx,%eax
    6719:	01 c0                	add    %eax,%eax
    671b:	01 d0                	add    %edx,%eax
    671d:	89 c2                	mov    %eax,%edx
    671f:	8b 45 10             	mov    0x10(%ebp),%eax
    6722:	8b 40 0c             	mov    0xc(%eax),%eax
    6725:	83 ec 04             	sub    $0x4,%esp
    6728:	51                   	push   %ecx
    6729:	52                   	push   %edx
    672a:	50                   	push   %eax
    672b:	e8 f7 dd ff ff       	call   4527 <lodepng_gtofl>
    6730:	83 c4 10             	add    $0x10,%esp
    6733:	85 c0                	test   %eax,%eax
    6735:	74 0c                	je     6743 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    6737:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    673e:	e9 07 04 00 00       	jmp    6b4a <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    6743:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    674a:	eb 3d                	jmp    6789 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    674c:	83 ec 08             	sub    $0x8,%esp
    674f:	6a 03                	push   $0x3
    6751:	ff 75 10             	pushl  0x10(%ebp)
    6754:	e8 8b e4 ff ff       	call   4be4 <ensureBits9>
    6759:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    675c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    675f:	8b 04 85 00 b0 01 00 	mov    0x1b000(,%eax,4),%eax
    6766:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    676d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6770:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    6773:	83 ec 08             	sub    $0x8,%esp
    6776:	6a 03                	push   $0x3
    6778:	ff 75 10             	pushl  0x10(%ebp)
    677b:	e8 1c ea ff ff       	call   519c <readBits>
    6780:	83 c4 10             	add    $0x10,%esp
    6783:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    6785:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6789:	8b 45 ec             	mov    -0x14(%ebp),%eax
    678c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    678f:	75 bb                	jne    674c <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    6791:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6794:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6797:	eb 20                	jmp    67b9 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    6799:	8b 45 ec             	mov    -0x14(%ebp),%eax
    679c:	8b 04 85 00 b0 01 00 	mov    0x1b000(,%eax,4),%eax
    67a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    67aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
    67ad:	01 d0                	add    %edx,%eax
    67af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    67b5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    67b9:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    67bd:	75 da                	jne    6799 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    67bf:	6a 07                	push   $0x7
    67c1:	6a 13                	push   $0x13
    67c3:	ff 75 dc             	pushl  -0x24(%ebp)
    67c6:	8d 45 a8             	lea    -0x58(%ebp),%eax
    67c9:	50                   	push   %eax
    67ca:	e8 83 f2 ff ff       	call   5a52 <HuffmanTree_makeFromLengths>
    67cf:	83 c4 10             	add    $0x10,%esp
    67d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    67d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    67d9:	0f 85 64 03 00 00    	jne    6b43 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    67df:	83 ec 0c             	sub    $0xc,%esp
    67e2:	68 80 04 00 00       	push   $0x480
    67e7:	e8 24 dc ff ff       	call   4410 <lodepng_malloc>
    67ec:	83 c4 10             	add    $0x10,%esp
    67ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    67f2:	83 ec 0c             	sub    $0xc,%esp
    67f5:	68 80 00 00 00       	push   $0x80
    67fa:	e8 11 dc ff ff       	call   4410 <lodepng_malloc>
    67ff:	83 c4 10             	add    $0x10,%esp
    6802:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    6805:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6809:	74 06                	je     6811 <getTreeInflateDynamic+0x1b5>
    680b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    680f:	75 0c                	jne    681d <getTreeInflateDynamic+0x1c1>
    6811:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6818:	e9 2d 03 00 00       	jmp    6b4a <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    681d:	83 ec 04             	sub    $0x4,%esp
    6820:	68 80 04 00 00       	push   $0x480
    6825:	6a 00                	push   $0x0
    6827:	ff 75 e8             	pushl  -0x18(%ebp)
    682a:	e8 52 dc ff ff       	call   4481 <lodepng_memset>
    682f:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    6832:	83 ec 04             	sub    $0x4,%esp
    6835:	68 80 00 00 00       	push   $0x80
    683a:	6a 00                	push   $0x0
    683c:	ff 75 e4             	pushl  -0x1c(%ebp)
    683f:	e8 3d dc ff ff       	call   4481 <lodepng_memset>
    6844:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    6847:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    684e:	e9 8d 02 00 00       	jmp    6ae0 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    6853:	83 ec 08             	sub    $0x8,%esp
    6856:	6a 16                	push   $0x16
    6858:	ff 75 10             	pushl  0x10(%ebp)
    685b:	e8 8c e5 ff ff       	call   4dec <ensureBits25>
    6860:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    6863:	83 ec 08             	sub    $0x8,%esp
    6866:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6869:	50                   	push   %eax
    686a:	ff 75 10             	pushl  0x10(%ebp)
    686d:	e8 f7 fc ff ff       	call   6569 <huffmanDecodeSymbol>
    6872:	83 c4 10             	add    $0x10,%esp
    6875:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    6878:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    687c:	77 3e                	ja     68bc <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    687e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6881:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6884:	73 16                	jae    689c <getTreeInflateDynamic+0x240>
    6886:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6889:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6890:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6893:	01 c2                	add    %eax,%edx
    6895:	8b 45 cc             	mov    -0x34(%ebp),%eax
    6898:	89 02                	mov    %eax,(%edx)
    689a:	eb 17                	jmp    68b3 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    689c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    689f:	2b 45 d8             	sub    -0x28(%ebp),%eax
    68a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    68a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    68ac:	01 c2                	add    %eax,%edx
    68ae:	8b 45 cc             	mov    -0x34(%ebp),%eax
    68b1:	89 02                	mov    %eax,(%edx)
        ++i;
    68b3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    68b7:	e9 0b 02 00 00       	jmp    6ac7 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    68bc:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    68c0:	0f 85 da 00 00 00    	jne    69a0 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    68c6:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    68cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    68d1:	75 0c                	jne    68df <getTreeInflateDynamic+0x283>
    68d3:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    68da:	e9 12 02 00 00       	jmp    6af1 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    68df:	83 ec 08             	sub    $0x8,%esp
    68e2:	6a 02                	push   $0x2
    68e4:	ff 75 10             	pushl  0x10(%ebp)
    68e7:	e8 b0 e8 ff ff       	call   519c <readBits>
    68ec:	83 c4 10             	add    $0x10,%esp
    68ef:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    68f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    68f5:	83 c0 01             	add    $0x1,%eax
    68f8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    68fb:	76 1b                	jbe    6918 <getTreeInflateDynamic+0x2bc>
    68fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6900:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    6905:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    690c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    690f:	01 d0                	add    %edx,%eax
    6911:	8b 00                	mov    (%eax),%eax
    6913:	89 45 e0             	mov    %eax,-0x20(%ebp)
    6916:	eb 1c                	jmp    6934 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    6918:	8b 45 ec             	mov    -0x14(%ebp),%eax
    691b:	2b 45 d8             	sub    -0x28(%ebp),%eax
    691e:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    6923:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    692a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    692d:	01 d0                	add    %edx,%eax
    692f:	8b 00                	mov    (%eax),%eax
    6931:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6934:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    693b:	eb 56                	jmp    6993 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    693d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6940:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6943:	01 d0                	add    %edx,%eax
    6945:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6948:	77 0c                	ja     6956 <getTreeInflateDynamic+0x2fa>
    694a:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    6951:	e9 71 01 00 00       	jmp    6ac7 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    6956:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6959:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    695c:	73 16                	jae    6974 <getTreeInflateDynamic+0x318>
    695e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6961:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6968:	8b 45 e8             	mov    -0x18(%ebp),%eax
    696b:	01 c2                	add    %eax,%edx
    696d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6970:	89 02                	mov    %eax,(%edx)
    6972:	eb 17                	jmp    698b <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    6974:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6977:	2b 45 d8             	sub    -0x28(%ebp),%eax
    697a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6981:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6984:	01 c2                	add    %eax,%edx
    6986:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6989:	89 02                	mov    %eax,(%edx)
          ++i;
    698b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    698f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6993:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6996:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6999:	72 a2                	jb     693d <getTreeInflateDynamic+0x2e1>
    699b:	e9 27 01 00 00       	jmp    6ac7 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    69a0:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    69a4:	0f 85 88 00 00 00    	jne    6a32 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    69aa:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    69b1:	83 ec 08             	sub    $0x8,%esp
    69b4:	6a 03                	push   $0x3
    69b6:	ff 75 10             	pushl  0x10(%ebp)
    69b9:	e8 de e7 ff ff       	call   519c <readBits>
    69be:	83 c4 10             	add    $0x10,%esp
    69c1:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    69c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    69cb:	eb 58                	jmp    6a25 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    69cd:	8b 55 d8             	mov    -0x28(%ebp),%edx
    69d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    69d3:	01 d0                	add    %edx,%eax
    69d5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    69d8:	77 0c                	ja     69e6 <getTreeInflateDynamic+0x38a>
    69da:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    69e1:	e9 e1 00 00 00       	jmp    6ac7 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    69e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    69e9:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    69ec:	73 17                	jae    6a05 <getTreeInflateDynamic+0x3a9>
    69ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    69f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    69f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    69fb:	01 d0                	add    %edx,%eax
    69fd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    6a03:	eb 18                	jmp    6a1d <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    6a05:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a08:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6a0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6a12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6a15:	01 d0                	add    %edx,%eax
    6a17:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    6a1d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6a21:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6a25:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a28:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    6a2b:	72 a0                	jb     69cd <getTreeInflateDynamic+0x371>
    6a2d:	e9 95 00 00 00       	jmp    6ac7 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    6a32:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    6a36:	0f 85 82 00 00 00    	jne    6abe <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    6a3c:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    6a43:	83 ec 08             	sub    $0x8,%esp
    6a46:	6a 07                	push   $0x7
    6a48:	ff 75 10             	pushl  0x10(%ebp)
    6a4b:	e8 4c e7 ff ff       	call   519c <readBits>
    6a50:	83 c4 10             	add    $0x10,%esp
    6a53:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6a56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6a5d:	eb 55                	jmp    6ab4 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    6a5f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6a62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6a65:	01 d0                	add    %edx,%eax
    6a67:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6a6a:	77 09                	ja     6a75 <getTreeInflateDynamic+0x419>
    6a6c:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    6a73:	eb 52                	jmp    6ac7 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    6a75:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a78:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6a7b:	73 17                	jae    6a94 <getTreeInflateDynamic+0x438>
    6a7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a80:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6a87:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a8a:	01 d0                	add    %edx,%eax
    6a8c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    6a92:	eb 18                	jmp    6aac <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    6a94:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a97:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6a9a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6aa1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6aa4:	01 d0                	add    %edx,%eax
    6aa6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    6aac:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6ab0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6ab4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ab7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    6aba:	72 a3                	jb     6a5f <getTreeInflateDynamic+0x403>
    6abc:	eb 09                	jmp    6ac7 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6abe:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    6ac5:	eb 2a                	jmp    6af1 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    6ac7:	8b 45 10             	mov    0x10(%ebp),%eax
    6aca:	8b 50 0c             	mov    0xc(%eax),%edx
    6acd:	8b 45 10             	mov    0x10(%ebp),%eax
    6ad0:	8b 40 08             	mov    0x8(%eax),%eax
    6ad3:	39 c2                	cmp    %eax,%edx
    6ad5:	7e 09                	jle    6ae0 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    6ad7:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    6ade:	eb 11                	jmp    6af1 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    6ae0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6ae3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6ae6:	01 d0                	add    %edx,%eax
    6ae8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6aeb:	0f 87 62 fd ff ff    	ja     6853 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    6af1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6af5:	75 4f                	jne    6b46 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    6af7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6afa:	05 00 04 00 00       	add    $0x400,%eax
    6aff:	8b 00                	mov    (%eax),%eax
    6b01:	85 c0                	test   %eax,%eax
    6b03:	75 09                	jne    6b0e <getTreeInflateDynamic+0x4b2>
    6b05:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    6b0c:	eb 3c                	jmp    6b4a <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    6b0e:	6a 0f                	push   $0xf
    6b10:	68 20 01 00 00       	push   $0x120
    6b15:	ff 75 e8             	pushl  -0x18(%ebp)
    6b18:	ff 75 08             	pushl  0x8(%ebp)
    6b1b:	e8 32 ef ff ff       	call   5a52 <HuffmanTree_makeFromLengths>
    6b20:	83 c4 10             	add    $0x10,%esp
    6b23:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    6b26:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6b2a:	75 1d                	jne    6b49 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    6b2c:	6a 0f                	push   $0xf
    6b2e:	6a 20                	push   $0x20
    6b30:	ff 75 e4             	pushl  -0x1c(%ebp)
    6b33:	ff 75 0c             	pushl  0xc(%ebp)
    6b36:	e8 17 ef ff ff       	call   5a52 <HuffmanTree_makeFromLengths>
    6b3b:	83 c4 10             	add    $0x10,%esp
    6b3e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    6b41:	eb 07                	jmp    6b4a <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    6b43:	90                   	nop
    6b44:	eb 04                	jmp    6b4a <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    6b46:	90                   	nop
    6b47:	eb 01                	jmp    6b4a <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    6b49:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    6b4a:	83 ec 0c             	sub    $0xc,%esp
    6b4d:	ff 75 dc             	pushl  -0x24(%ebp)
    6b50:	e8 dc d8 ff ff       	call   4431 <lodepng_free>
    6b55:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    6b58:	83 ec 0c             	sub    $0xc,%esp
    6b5b:	ff 75 e8             	pushl  -0x18(%ebp)
    6b5e:	e8 ce d8 ff ff       	call   4431 <lodepng_free>
    6b63:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    6b66:	83 ec 0c             	sub    $0xc,%esp
    6b69:	ff 75 e4             	pushl  -0x1c(%ebp)
    6b6c:	e8 c0 d8 ff ff       	call   4431 <lodepng_free>
    6b71:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    6b74:	83 ec 0c             	sub    $0xc,%esp
    6b77:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6b7a:	50                   	push   %eax
    6b7b:	e8 b1 e7 ff ff       	call   5331 <HuffmanTree_cleanup>
    6b80:	83 c4 10             	add    $0x10,%esp

  return error;
    6b83:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6b86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6b89:	c9                   	leave  
    6b8a:	c3                   	ret    

00006b8b <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    6b8b:	55                   	push   %ebp
    6b8c:	89 e5                	mov    %esp,%ebp
    6b8e:	53                   	push   %ebx
    6b8f:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    6b92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    6b99:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6b9c:	50                   	push   %eax
    6b9d:	e8 62 e7 ff ff       	call   5304 <HuffmanTree_init>
    6ba2:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6ba5:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6ba8:	50                   	push   %eax
    6ba9:	e8 56 e7 ff ff       	call   5304 <HuffmanTree_init>
    6bae:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    6bb1:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    6bb5:	75 1b                	jne    6bd2 <inflateHuffmanBlock+0x47>
    6bb7:	83 ec 08             	sub    $0x8,%esp
    6bba:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6bbd:	50                   	push   %eax
    6bbe:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6bc1:	50                   	push   %eax
    6bc2:	e8 63 fa ff ff       	call   662a <getTreeInflateFixed>
    6bc7:	83 c4 10             	add    $0x10,%esp
    6bca:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6bcd:	e9 9a 02 00 00       	jmp    6e6c <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    6bd2:	83 ec 04             	sub    $0x4,%esp
    6bd5:	ff 75 0c             	pushl  0xc(%ebp)
    6bd8:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6bdb:	50                   	push   %eax
    6bdc:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6bdf:	50                   	push   %eax
    6be0:	e8 77 fa ff ff       	call   665c <getTreeInflateDynamic>
    6be5:	83 c4 10             	add    $0x10,%esp
    6be8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6beb:	e9 7c 02 00 00       	jmp    6e6c <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    6bf0:	83 ec 08             	sub    $0x8,%esp
    6bf3:	6a 14                	push   $0x14
    6bf5:	ff 75 0c             	pushl  0xc(%ebp)
    6bf8:	e8 ef e1 ff ff       	call   4dec <ensureBits25>
    6bfd:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    6c00:	83 ec 08             	sub    $0x8,%esp
    6c03:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6c06:	50                   	push   %eax
    6c07:	ff 75 0c             	pushl  0xc(%ebp)
    6c0a:	e8 5a f9 ff ff       	call   6569 <huffmanDecodeSymbol>
    6c0f:	83 c4 10             	add    $0x10,%esp
    6c12:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    6c15:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    6c1c:	77 42                	ja     6c60 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    6c1e:	8b 45 08             	mov    0x8(%ebp),%eax
    6c21:	8b 40 04             	mov    0x4(%eax),%eax
    6c24:	83 c0 01             	add    $0x1,%eax
    6c27:	83 ec 08             	sub    $0x8,%esp
    6c2a:	50                   	push   %eax
    6c2b:	ff 75 08             	pushl  0x8(%ebp)
    6c2e:	e8 37 da ff ff       	call   466a <ucvector_resize>
    6c33:	83 c4 10             	add    $0x10,%esp
    6c36:	85 c0                	test   %eax,%eax
    6c38:	75 0c                	jne    6c46 <inflateHuffmanBlock+0xbb>
    6c3a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6c41:	e9 33 02 00 00       	jmp    6e79 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    6c46:	8b 45 08             	mov    0x8(%ebp),%eax
    6c49:	8b 10                	mov    (%eax),%edx
    6c4b:	8b 45 08             	mov    0x8(%ebp),%eax
    6c4e:	8b 40 04             	mov    0x4(%eax),%eax
    6c51:	83 e8 01             	sub    $0x1,%eax
    6c54:	01 d0                	add    %edx,%eax
    6c56:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c59:	88 10                	mov    %dl,(%eax)
    6c5b:	e9 d9 01 00 00       	jmp    6e39 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    6c60:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    6c67:	0f 86 ba 01 00 00    	jbe    6e27 <inflateHuffmanBlock+0x29c>
    6c6d:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    6c74:	0f 87 ad 01 00 00    	ja     6e27 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    6c7a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6c7d:	2d 01 01 00 00       	sub    $0x101,%eax
    6c82:	8b 04 85 00 ae 01 00 	mov    0x1ae00(,%eax,4),%eax
    6c89:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    6c8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6c8f:	2d 01 01 00 00       	sub    $0x101,%eax
    6c94:	8b 04 85 80 ae 01 00 	mov    0x1ae80(,%eax,4),%eax
    6c9b:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    6c9e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    6ca2:	74 1c                	je     6cc0 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    6ca4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6ca7:	83 ec 08             	sub    $0x8,%esp
    6caa:	50                   	push   %eax
    6cab:	ff 75 0c             	pushl  0xc(%ebp)
    6cae:	e8 e9 e4 ff ff       	call   519c <readBits>
    6cb3:	83 c4 10             	add    $0x10,%esp
    6cb6:	89 c2                	mov    %eax,%edx
    6cb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6cbb:	01 d0                	add    %edx,%eax
    6cbd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    6cc0:	83 ec 08             	sub    $0x8,%esp
    6cc3:	6a 1c                	push   $0x1c
    6cc5:	ff 75 0c             	pushl  0xc(%ebp)
    6cc8:	e8 98 e2 ff ff       	call   4f65 <ensureBits32>
    6ccd:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    6cd0:	83 ec 08             	sub    $0x8,%esp
    6cd3:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6cd6:	50                   	push   %eax
    6cd7:	ff 75 0c             	pushl  0xc(%ebp)
    6cda:	e8 8a f8 ff ff       	call   6569 <huffmanDecodeSymbol>
    6cdf:	83 c4 10             	add    $0x10,%esp
    6ce2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    6ce5:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    6ce9:	76 1e                	jbe    6d09 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    6ceb:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    6cef:	77 0c                	ja     6cfd <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    6cf1:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    6cf8:	e9 7c 01 00 00       	jmp    6e79 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6cfd:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    6d04:	e9 70 01 00 00       	jmp    6e79 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    6d09:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6d0c:	8b 04 85 00 af 01 00 	mov    0x1af00(,%eax,4),%eax
    6d13:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    6d16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6d19:	8b 04 85 80 af 01 00 	mov    0x1af80(,%eax,4),%eax
    6d20:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    6d23:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6d27:	74 15                	je     6d3e <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    6d29:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6d2c:	83 ec 08             	sub    $0x8,%esp
    6d2f:	50                   	push   %eax
    6d30:	ff 75 0c             	pushl  0xc(%ebp)
    6d33:	e8 64 e4 ff ff       	call   519c <readBits>
    6d38:	83 c4 10             	add    $0x10,%esp
    6d3b:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    6d3e:	8b 45 08             	mov    0x8(%ebp),%eax
    6d41:	8b 40 04             	mov    0x4(%eax),%eax
    6d44:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    6d47:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d4a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    6d4d:	76 0c                	jbe    6d5b <inflateHuffmanBlock+0x1d0>
    6d4f:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    6d56:	e9 1e 01 00 00       	jmp    6e79 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    6d5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d5e:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6d61:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    6d64:	8b 45 08             	mov    0x8(%ebp),%eax
    6d67:	8b 50 04             	mov    0x4(%eax),%edx
    6d6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d6d:	01 d0                	add    %edx,%eax
    6d6f:	83 ec 08             	sub    $0x8,%esp
    6d72:	50                   	push   %eax
    6d73:	ff 75 08             	pushl  0x8(%ebp)
    6d76:	e8 ef d8 ff ff       	call   466a <ucvector_resize>
    6d7b:	83 c4 10             	add    $0x10,%esp
    6d7e:	85 c0                	test   %eax,%eax
    6d80:	75 0c                	jne    6d8e <inflateHuffmanBlock+0x203>
    6d82:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6d89:	e9 eb 00 00 00       	jmp    6e79 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    6d8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d91:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    6d94:	73 6b                	jae    6e01 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    6d96:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d99:	8b 55 08             	mov    0x8(%ebp),%edx
    6d9c:	8b 0a                	mov    (%edx),%ecx
    6d9e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6da1:	01 d1                	add    %edx,%ecx
    6da3:	8b 55 08             	mov    0x8(%ebp),%edx
    6da6:	8b 1a                	mov    (%edx),%ebx
    6da8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6dab:	01 da                	add    %ebx,%edx
    6dad:	83 ec 04             	sub    $0x4,%esp
    6db0:	50                   	push   %eax
    6db1:	51                   	push   %ecx
    6db2:	52                   	push   %edx
    6db3:	e8 96 d6 ff ff       	call   444e <lodepng_memcpy>
    6db8:	83 c4 10             	add    $0x10,%esp
        start += distance;
    6dbb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6dbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dc1:	01 d0                	add    %edx,%eax
    6dc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    6dc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dc9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    6dcc:	eb 29                	jmp    6df7 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    6dce:	8b 45 08             	mov    0x8(%ebp),%eax
    6dd1:	8b 08                	mov    (%eax),%ecx
    6dd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6dd6:	8d 50 01             	lea    0x1(%eax),%edx
    6dd9:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6ddc:	01 c1                	add    %eax,%ecx
    6dde:	8b 45 08             	mov    0x8(%ebp),%eax
    6de1:	8b 18                	mov    (%eax),%ebx
    6de3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6de6:	8d 50 01             	lea    0x1(%eax),%edx
    6de9:	89 55 e8             	mov    %edx,-0x18(%ebp)
    6dec:	01 d8                	add    %ebx,%eax
    6dee:	0f b6 00             	movzbl (%eax),%eax
    6df1:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    6df3:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    6df7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6dfa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    6dfd:	7c cf                	jl     6dce <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    6dff:	eb 38                	jmp    6e39 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    6e01:	8b 45 08             	mov    0x8(%ebp),%eax
    6e04:	8b 10                	mov    (%eax),%edx
    6e06:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e09:	01 c2                	add    %eax,%edx
    6e0b:	8b 45 08             	mov    0x8(%ebp),%eax
    6e0e:	8b 08                	mov    (%eax),%ecx
    6e10:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6e13:	01 c8                	add    %ecx,%eax
    6e15:	83 ec 04             	sub    $0x4,%esp
    6e18:	ff 75 e4             	pushl  -0x1c(%ebp)
    6e1b:	52                   	push   %edx
    6e1c:	50                   	push   %eax
    6e1d:	e8 2c d6 ff ff       	call   444e <lodepng_memcpy>
    6e22:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    6e25:	eb 12                	jmp    6e39 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    6e27:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    6e2e:	74 48                	je     6e78 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6e30:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    6e37:	eb 40                	jmp    6e79 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    6e39:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e3c:	8b 50 0c             	mov    0xc(%eax),%edx
    6e3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e42:	8b 40 08             	mov    0x8(%eax),%eax
    6e45:	39 c2                	cmp    %eax,%edx
    6e47:	7e 09                	jle    6e52 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    6e49:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    6e50:	eb 27                	jmp    6e79 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    6e52:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    6e56:	74 14                	je     6e6c <inflateHuffmanBlock+0x2e1>
    6e58:	8b 45 08             	mov    0x8(%ebp),%eax
    6e5b:	8b 40 04             	mov    0x4(%eax),%eax
    6e5e:	3b 45 14             	cmp    0x14(%ebp),%eax
    6e61:	7e 09                	jle    6e6c <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    6e63:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    6e6a:	eb 0d                	jmp    6e79 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6e6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6e70:	0f 84 7a fd ff ff    	je     6bf0 <inflateHuffmanBlock+0x65>
    6e76:	eb 01                	jmp    6e79 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    6e78:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    6e79:	83 ec 0c             	sub    $0xc,%esp
    6e7c:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6e7f:	50                   	push   %eax
    6e80:	e8 ac e4 ff ff       	call   5331 <HuffmanTree_cleanup>
    6e85:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    6e88:	83 ec 0c             	sub    $0xc,%esp
    6e8b:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6e8e:	50                   	push   %eax
    6e8f:	e8 9d e4 ff ff       	call   5331 <HuffmanTree_cleanup>
    6e94:	83 c4 10             	add    $0x10,%esp

  return error;
    6e97:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6e9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6e9d:	c9                   	leave  
    6e9e:	c3                   	ret    

00006e9f <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    6e9f:	55                   	push   %ebp
    6ea0:	89 e5                	mov    %esp,%ebp
    6ea2:	53                   	push   %ebx
    6ea3:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    6ea6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ea9:	8b 40 04             	mov    0x4(%eax),%eax
    6eac:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    6eaf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    6eb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6eb9:	8b 40 0c             	mov    0xc(%eax),%eax
    6ebc:	83 c0 07             	add    $0x7,%eax
    6ebf:	c1 e8 03             	shr    $0x3,%eax
    6ec2:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    6ec5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ec8:	83 c0 04             	add    $0x4,%eax
    6ecb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6ece:	7c 0a                	jl     6eda <inflateNoCompression+0x3b>
    6ed0:	b8 34 00 00 00       	mov    $0x34,%eax
    6ed5:	e9 01 01 00 00       	jmp    6fdb <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    6eda:	8b 45 0c             	mov    0xc(%ebp),%eax
    6edd:	8b 10                	mov    (%eax),%edx
    6edf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ee2:	01 d0                	add    %edx,%eax
    6ee4:	0f b6 00             	movzbl (%eax),%eax
    6ee7:	0f b6 d0             	movzbl %al,%edx
    6eea:	8b 45 0c             	mov    0xc(%ebp),%eax
    6eed:	8b 00                	mov    (%eax),%eax
    6eef:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    6ef2:	83 c1 01             	add    $0x1,%ecx
    6ef5:	01 c8                	add    %ecx,%eax
    6ef7:	0f b6 00             	movzbl (%eax),%eax
    6efa:	0f b6 c0             	movzbl %al,%eax
    6efd:	c1 e0 08             	shl    $0x8,%eax
    6f00:	01 d0                	add    %edx,%eax
    6f02:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6f05:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    6f09:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f0c:	8b 10                	mov    (%eax),%edx
    6f0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f11:	01 d0                	add    %edx,%eax
    6f13:	0f b6 00             	movzbl (%eax),%eax
    6f16:	0f b6 d0             	movzbl %al,%edx
    6f19:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f1c:	8b 00                	mov    (%eax),%eax
    6f1e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    6f21:	83 c1 01             	add    $0x1,%ecx
    6f24:	01 c8                	add    %ecx,%eax
    6f26:	0f b6 00             	movzbl (%eax),%eax
    6f29:	0f b6 c0             	movzbl %al,%eax
    6f2c:	c1 e0 08             	shl    $0x8,%eax
    6f2f:	01 d0                	add    %edx,%eax
    6f31:	89 45 e8             	mov    %eax,-0x18(%ebp)
    6f34:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    6f38:	8b 45 10             	mov    0x10(%ebp),%eax
    6f3b:	8b 40 04             	mov    0x4(%eax),%eax
    6f3e:	85 c0                	test   %eax,%eax
    6f40:	75 19                	jne    6f5b <inflateNoCompression+0xbc>
    6f42:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6f45:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6f48:	01 d0                	add    %edx,%eax
    6f4a:	3d ff ff 00 00       	cmp    $0xffff,%eax
    6f4f:	74 0a                	je     6f5b <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    6f51:	b8 15 00 00 00       	mov    $0x15,%eax
    6f56:	e9 80 00 00 00       	jmp    6fdb <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    6f5b:	8b 45 08             	mov    0x8(%ebp),%eax
    6f5e:	8b 40 04             	mov    0x4(%eax),%eax
    6f61:	89 c2                	mov    %eax,%edx
    6f63:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f66:	01 d0                	add    %edx,%eax
    6f68:	50                   	push   %eax
    6f69:	ff 75 08             	pushl  0x8(%ebp)
    6f6c:	e8 f9 d6 ff ff       	call   466a <ucvector_resize>
    6f71:	83 c4 08             	add    $0x8,%esp
    6f74:	85 c0                	test   %eax,%eax
    6f76:	75 07                	jne    6f7f <inflateNoCompression+0xe0>
    6f78:	b8 53 00 00 00       	mov    $0x53,%eax
    6f7d:	eb 5c                	jmp    6fdb <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    6f7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6f82:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f85:	01 c2                	add    %eax,%edx
    6f87:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6f8a:	39 c2                	cmp    %eax,%edx
    6f8c:	76 07                	jbe    6f95 <inflateNoCompression+0xf6>
    6f8e:	b8 17 00 00 00       	mov    $0x17,%eax
    6f93:	eb 46                	jmp    6fdb <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    6f95:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f98:	8b 55 0c             	mov    0xc(%ebp),%edx
    6f9b:	8b 0a                	mov    (%edx),%ecx
    6f9d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6fa0:	01 d1                	add    %edx,%ecx
    6fa2:	8b 55 08             	mov    0x8(%ebp),%edx
    6fa5:	8b 1a                	mov    (%edx),%ebx
    6fa7:	8b 55 08             	mov    0x8(%ebp),%edx
    6faa:	8b 52 04             	mov    0x4(%edx),%edx
    6fad:	2b 55 ec             	sub    -0x14(%ebp),%edx
    6fb0:	01 da                	add    %ebx,%edx
    6fb2:	50                   	push   %eax
    6fb3:	51                   	push   %ecx
    6fb4:	52                   	push   %edx
    6fb5:	e8 94 d4 ff ff       	call   444e <lodepng_memcpy>
    6fba:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    6fbd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6fc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6fc3:	01 d0                	add    %edx,%eax
    6fc5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    6fc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6fcb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    6fd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    6fd5:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    6fd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6fdb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6fde:	c9                   	leave  
    6fdf:	c3                   	ret    

00006fe0 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    6fe0:	55                   	push   %ebp
    6fe1:	89 e5                	mov    %esp,%ebp
    6fe3:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    6fe6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    6fed:	ff 75 10             	pushl  0x10(%ebp)
    6ff0:	ff 75 0c             	pushl  0xc(%ebp)
    6ff3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6ff6:	50                   	push   %eax
    6ff7:	e8 77 db ff ff       	call   4b73 <LodePNGBitReader_init>
    6ffc:	83 c4 0c             	add    $0xc,%esp
    6fff:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    7002:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7006:	0f 84 b9 00 00 00    	je     70c5 <lodepng_inflatev+0xe5>
    700c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    700f:	e9 c1 00 00 00       	jmp    70d5 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    7014:	6a 03                	push   $0x3
    7016:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7019:	50                   	push   %eax
    701a:	e8 c5 db ff ff       	call   4be4 <ensureBits9>
    701f:	83 c4 08             	add    $0x8,%esp
    7022:	85 c0                	test   %eax,%eax
    7024:	75 0a                	jne    7030 <lodepng_inflatev+0x50>
    7026:	b8 34 00 00 00       	mov    $0x34,%eax
    702b:	e9 a5 00 00 00       	jmp    70d5 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    7030:	6a 01                	push   $0x1
    7032:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7035:	50                   	push   %eax
    7036:	e8 61 e1 ff ff       	call   519c <readBits>
    703b:	83 c4 08             	add    $0x8,%esp
    703e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    7041:	6a 02                	push   $0x2
    7043:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7046:	50                   	push   %eax
    7047:	e8 50 e1 ff ff       	call   519c <readBits>
    704c:	83 c4 08             	add    $0x8,%esp
    704f:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    7052:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    7056:	75 07                	jne    705f <lodepng_inflatev+0x7f>
    7058:	b8 14 00 00 00       	mov    $0x14,%eax
    705d:	eb 76                	jmp    70d5 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    705f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    7063:	75 17                	jne    707c <lodepng_inflatev+0x9c>
    7065:	ff 75 14             	pushl  0x14(%ebp)
    7068:	8d 45 d8             	lea    -0x28(%ebp),%eax
    706b:	50                   	push   %eax
    706c:	ff 75 08             	pushl  0x8(%ebp)
    706f:	e8 2b fe ff ff       	call   6e9f <inflateNoCompression>
    7074:	83 c4 0c             	add    $0xc,%esp
    7077:	89 45 f0             	mov    %eax,-0x10(%ebp)
    707a:	eb 1c                	jmp    7098 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    707c:	8b 45 14             	mov    0x14(%ebp),%eax
    707f:	8b 40 08             	mov    0x8(%eax),%eax
    7082:	50                   	push   %eax
    7083:	ff 75 ec             	pushl  -0x14(%ebp)
    7086:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7089:	50                   	push   %eax
    708a:	ff 75 08             	pushl  0x8(%ebp)
    708d:	e8 f9 fa ff ff       	call   6b8b <inflateHuffmanBlock>
    7092:	83 c4 10             	add    $0x10,%esp
    7095:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    7098:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    709c:	75 21                	jne    70bf <lodepng_inflatev+0xdf>
    709e:	8b 45 14             	mov    0x14(%ebp),%eax
    70a1:	8b 40 08             	mov    0x8(%eax),%eax
    70a4:	85 c0                	test   %eax,%eax
    70a6:	74 17                	je     70bf <lodepng_inflatev+0xdf>
    70a8:	8b 45 08             	mov    0x8(%ebp),%eax
    70ab:	8b 50 04             	mov    0x4(%eax),%edx
    70ae:	8b 45 14             	mov    0x14(%ebp),%eax
    70b1:	8b 40 08             	mov    0x8(%eax),%eax
    70b4:	39 c2                	cmp    %eax,%edx
    70b6:	7e 07                	jle    70bf <lodepng_inflatev+0xdf>
    70b8:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    70bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    70c3:	75 0c                	jne    70d1 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    70c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    70c9:	0f 84 45 ff ff ff    	je     7014 <lodepng_inflatev+0x34>
    70cf:	eb 01                	jmp    70d2 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    70d1:	90                   	nop
  }

  return error;
    70d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    70d5:	c9                   	leave  
    70d6:	c3                   	ret    

000070d7 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    70d7:	55                   	push   %ebp
    70d8:	89 e5                	mov    %esp,%ebp
    70da:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    70dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    70e0:	8b 08                	mov    (%eax),%ecx
    70e2:	8b 45 08             	mov    0x8(%ebp),%eax
    70e5:	8b 10                	mov    (%eax),%edx
    70e7:	8d 45 e8             	lea    -0x18(%ebp),%eax
    70ea:	51                   	push   %ecx
    70eb:	52                   	push   %edx
    70ec:	50                   	push   %eax
    70ed:	e8 df d5 ff ff       	call   46d1 <ucvector_init>
    70f2:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    70f5:	ff 75 18             	pushl  0x18(%ebp)
    70f8:	ff 75 14             	pushl  0x14(%ebp)
    70fb:	ff 75 10             	pushl  0x10(%ebp)
    70fe:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7101:	50                   	push   %eax
    7102:	e8 d9 fe ff ff       	call   6fe0 <lodepng_inflatev>
    7107:	83 c4 10             	add    $0x10,%esp
    710a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    710d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7110:	8b 45 08             	mov    0x8(%ebp),%eax
    7113:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7115:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7118:	8b 45 0c             	mov    0xc(%ebp),%eax
    711b:	89 10                	mov    %edx,(%eax)
  return error;
    711d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7120:	c9                   	leave  
    7121:	c3                   	ret    

00007122 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    7122:	55                   	push   %ebp
    7123:	89 e5                	mov    %esp,%ebp
    7125:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    7128:	8b 45 14             	mov    0x14(%ebp),%eax
    712b:	8b 40 10             	mov    0x10(%eax),%eax
    712e:	85 c0                	test   %eax,%eax
    7130:	74 64                	je     7196 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    7132:	8b 45 14             	mov    0x14(%ebp),%eax
    7135:	8b 40 10             	mov    0x10(%eax),%eax
    7138:	8b 55 08             	mov    0x8(%ebp),%edx
    713b:	8d 4a 04             	lea    0x4(%edx),%ecx
    713e:	8b 55 08             	mov    0x8(%ebp),%edx
    7141:	83 ec 0c             	sub    $0xc,%esp
    7144:	ff 75 14             	pushl  0x14(%ebp)
    7147:	ff 75 10             	pushl  0x10(%ebp)
    714a:	ff 75 0c             	pushl  0xc(%ebp)
    714d:	51                   	push   %ecx
    714e:	52                   	push   %edx
    714f:	ff d0                	call   *%eax
    7151:	83 c4 20             	add    $0x20,%esp
    7154:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    7157:	8b 45 08             	mov    0x8(%ebp),%eax
    715a:	8b 50 04             	mov    0x4(%eax),%edx
    715d:	8b 45 08             	mov    0x8(%ebp),%eax
    7160:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    7163:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7167:	74 28                	je     7191 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7169:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    7170:	8b 45 14             	mov    0x14(%ebp),%eax
    7173:	8b 40 08             	mov    0x8(%eax),%eax
    7176:	85 c0                	test   %eax,%eax
    7178:	74 17                	je     7191 <inflatev+0x6f>
    717a:	8b 45 08             	mov    0x8(%ebp),%eax
    717d:	8b 50 04             	mov    0x4(%eax),%edx
    7180:	8b 45 14             	mov    0x14(%ebp),%eax
    7183:	8b 40 08             	mov    0x8(%eax),%eax
    7186:	39 c2                	cmp    %eax,%edx
    7188:	7e 07                	jle    7191 <inflatev+0x6f>
    718a:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    7191:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7194:	eb 14                	jmp    71aa <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    7196:	ff 75 14             	pushl  0x14(%ebp)
    7199:	ff 75 10             	pushl  0x10(%ebp)
    719c:	ff 75 0c             	pushl  0xc(%ebp)
    719f:	ff 75 08             	pushl  0x8(%ebp)
    71a2:	e8 39 fe ff ff       	call   6fe0 <lodepng_inflatev>
    71a7:	83 c4 10             	add    $0x10,%esp
  }
}
    71aa:	c9                   	leave  
    71ab:	c3                   	ret    

000071ac <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    71ac:	55                   	push   %ebp
    71ad:	89 e5                	mov    %esp,%ebp
    71af:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    71b2:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    71b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    71bc:	83 e8 01             	sub    $0x1,%eax
    71bf:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    71c2:	eb 39                	jmp    71fd <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    71c4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    71c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    71ca:	01 d0                	add    %edx,%eax
    71cc:	d1 f8                	sar    %eax
    71ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    71d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    71d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71db:	8b 45 08             	mov    0x8(%ebp),%eax
    71de:	01 d0                	add    %edx,%eax
    71e0:	8b 10                	mov    (%eax),%edx
    71e2:	8b 45 10             	mov    0x10(%ebp),%eax
    71e5:	39 c2                	cmp    %eax,%edx
    71e7:	72 0b                	jb     71f4 <searchCodeIndex+0x48>
    71e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    71ec:	83 e8 01             	sub    $0x1,%eax
    71ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
    71f2:	eb 09                	jmp    71fd <searchCodeIndex+0x51>
    else left = mid + 1;
    71f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    71f7:	83 c0 01             	add    $0x1,%eax
    71fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    71fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7200:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    7203:	7e bf                	jle    71c4 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    7205:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7208:	3b 45 0c             	cmp    0xc(%ebp),%eax
    720b:	7d 18                	jge    7225 <searchCodeIndex+0x79>
    720d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7210:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7217:	8b 45 08             	mov    0x8(%ebp),%eax
    721a:	01 d0                	add    %edx,%eax
    721c:	8b 10                	mov    (%eax),%edx
    721e:	8b 45 10             	mov    0x10(%ebp),%eax
    7221:	39 c2                	cmp    %eax,%edx
    7223:	76 04                	jbe    7229 <searchCodeIndex+0x7d>
    7225:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    7229:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    722c:	c9                   	leave  
    722d:	c3                   	ret    

0000722e <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    722e:	55                   	push   %ebp
    722f:	89 e5                	mov    %esp,%ebp
    7231:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    7234:	ff 75 0c             	pushl  0xc(%ebp)
    7237:	6a 1d                	push   $0x1d
    7239:	68 00 ae 01 00       	push   $0x1ae00
    723e:	e8 69 ff ff ff       	call   71ac <searchCodeIndex>
    7243:	83 c4 0c             	add    $0xc,%esp
    7246:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    7249:	8b 55 0c             	mov    0xc(%ebp),%edx
    724c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    724f:	8b 04 85 00 ae 01 00 	mov    0x1ae00(,%eax,4),%eax
    7256:	29 c2                	sub    %eax,%edx
    7258:	89 d0                	mov    %edx,%eax
    725a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    725d:	ff 75 10             	pushl  0x10(%ebp)
    7260:	6a 1e                	push   $0x1e
    7262:	68 00 af 01 00       	push   $0x1af00
    7267:	e8 40 ff ff ff       	call   71ac <searchCodeIndex>
    726c:	83 c4 0c             	add    $0xc,%esp
    726f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    7272:	8b 55 10             	mov    0x10(%ebp),%edx
    7275:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7278:	8b 04 85 00 af 01 00 	mov    0x1af00(,%eax,4),%eax
    727f:	29 c2                	sub    %eax,%edx
    7281:	89 d0                	mov    %edx,%eax
    7283:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    7286:	8b 45 08             	mov    0x8(%ebp),%eax
    7289:	8b 40 04             	mov    0x4(%eax),%eax
    728c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    728f:	8b 45 08             	mov    0x8(%ebp),%eax
    7292:	8b 40 04             	mov    0x4(%eax),%eax
    7295:	83 c0 04             	add    $0x4,%eax
    7298:	50                   	push   %eax
    7299:	ff 75 08             	pushl  0x8(%ebp)
    729c:	e8 f0 d2 ff ff       	call   4591 <uivector_resize>
    72a1:	83 c4 08             	add    $0x8,%esp
    72a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    72a7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    72ab:	74 57                	je     7304 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    72ad:	8b 45 08             	mov    0x8(%ebp),%eax
    72b0:	8b 00                	mov    (%eax),%eax
    72b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    72b5:	c1 e2 02             	shl    $0x2,%edx
    72b8:	01 d0                	add    %edx,%eax
    72ba:	8b 55 fc             	mov    -0x4(%ebp),%edx
    72bd:	81 c2 01 01 00 00    	add    $0x101,%edx
    72c3:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    72c5:	8b 45 08             	mov    0x8(%ebp),%eax
    72c8:	8b 00                	mov    (%eax),%eax
    72ca:	8b 55 ec             	mov    -0x14(%ebp),%edx
    72cd:	83 c2 01             	add    $0x1,%edx
    72d0:	c1 e2 02             	shl    $0x2,%edx
    72d3:	01 c2                	add    %eax,%edx
    72d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    72d8:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    72da:	8b 45 08             	mov    0x8(%ebp),%eax
    72dd:	8b 00                	mov    (%eax),%eax
    72df:	8b 55 ec             	mov    -0x14(%ebp),%edx
    72e2:	83 c2 02             	add    $0x2,%edx
    72e5:	c1 e2 02             	shl    $0x2,%edx
    72e8:	01 c2                	add    %eax,%edx
    72ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    72ed:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    72ef:	8b 45 08             	mov    0x8(%ebp),%eax
    72f2:	8b 00                	mov    (%eax),%eax
    72f4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    72f7:	83 c2 03             	add    $0x3,%edx
    72fa:	c1 e2 02             	shl    $0x2,%edx
    72fd:	01 c2                	add    %eax,%edx
    72ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7302:	89 02                	mov    %eax,(%edx)
  }
}
    7304:	90                   	nop
    7305:	c9                   	leave  
    7306:	c3                   	ret    

00007307 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    7307:	55                   	push   %ebp
    7308:	89 e5                	mov    %esp,%ebp
    730a:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    730d:	b8 00 00 01 00       	mov    $0x10000,%eax
    7312:	c1 e0 02             	shl    $0x2,%eax
    7315:	83 ec 0c             	sub    $0xc,%esp
    7318:	50                   	push   %eax
    7319:	e8 f2 d0 ff ff       	call   4410 <lodepng_malloc>
    731e:	83 c4 10             	add    $0x10,%esp
    7321:	89 c2                	mov    %eax,%edx
    7323:	8b 45 08             	mov    0x8(%ebp),%eax
    7326:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    7328:	8b 45 0c             	mov    0xc(%ebp),%eax
    732b:	c1 e0 02             	shl    $0x2,%eax
    732e:	83 ec 0c             	sub    $0xc,%esp
    7331:	50                   	push   %eax
    7332:	e8 d9 d0 ff ff       	call   4410 <lodepng_malloc>
    7337:	83 c4 10             	add    $0x10,%esp
    733a:	89 c2                	mov    %eax,%edx
    733c:	8b 45 08             	mov    0x8(%ebp),%eax
    733f:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    7342:	8b 45 0c             	mov    0xc(%ebp),%eax
    7345:	01 c0                	add    %eax,%eax
    7347:	83 ec 0c             	sub    $0xc,%esp
    734a:	50                   	push   %eax
    734b:	e8 c0 d0 ff ff       	call   4410 <lodepng_malloc>
    7350:	83 c4 10             	add    $0x10,%esp
    7353:	89 c2                	mov    %eax,%edx
    7355:	8b 45 08             	mov    0x8(%ebp),%eax
    7358:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    735b:	8b 45 0c             	mov    0xc(%ebp),%eax
    735e:	01 c0                	add    %eax,%eax
    7360:	83 ec 0c             	sub    $0xc,%esp
    7363:	50                   	push   %eax
    7364:	e8 a7 d0 ff ff       	call   4410 <lodepng_malloc>
    7369:	83 c4 10             	add    $0x10,%esp
    736c:	89 c2                	mov    %eax,%edx
    736e:	8b 45 08             	mov    0x8(%ebp),%eax
    7371:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    7374:	b8 02 01 00 00       	mov    $0x102,%eax
    7379:	83 c0 01             	add    $0x1,%eax
    737c:	c1 e0 02             	shl    $0x2,%eax
    737f:	83 ec 0c             	sub    $0xc,%esp
    7382:	50                   	push   %eax
    7383:	e8 88 d0 ff ff       	call   4410 <lodepng_malloc>
    7388:	83 c4 10             	add    $0x10,%esp
    738b:	89 c2                	mov    %eax,%edx
    738d:	8b 45 08             	mov    0x8(%ebp),%eax
    7390:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    7393:	8b 45 0c             	mov    0xc(%ebp),%eax
    7396:	01 c0                	add    %eax,%eax
    7398:	83 ec 0c             	sub    $0xc,%esp
    739b:	50                   	push   %eax
    739c:	e8 6f d0 ff ff       	call   4410 <lodepng_malloc>
    73a1:	83 c4 10             	add    $0x10,%esp
    73a4:	89 c2                	mov    %eax,%edx
    73a6:	8b 45 08             	mov    0x8(%ebp),%eax
    73a9:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    73ac:	8b 45 08             	mov    0x8(%ebp),%eax
    73af:	8b 00                	mov    (%eax),%eax
    73b1:	85 c0                	test   %eax,%eax
    73b3:	74 32                	je     73e7 <hash_init+0xe0>
    73b5:	8b 45 08             	mov    0x8(%ebp),%eax
    73b8:	8b 40 04             	mov    0x4(%eax),%eax
    73bb:	85 c0                	test   %eax,%eax
    73bd:	74 28                	je     73e7 <hash_init+0xe0>
    73bf:	8b 45 08             	mov    0x8(%ebp),%eax
    73c2:	8b 40 08             	mov    0x8(%eax),%eax
    73c5:	85 c0                	test   %eax,%eax
    73c7:	74 1e                	je     73e7 <hash_init+0xe0>
    73c9:	8b 45 08             	mov    0x8(%ebp),%eax
    73cc:	8b 40 0c             	mov    0xc(%eax),%eax
    73cf:	85 c0                	test   %eax,%eax
    73d1:	74 14                	je     73e7 <hash_init+0xe0>
    73d3:	8b 45 08             	mov    0x8(%ebp),%eax
    73d6:	8b 40 10             	mov    0x10(%eax),%eax
    73d9:	85 c0                	test   %eax,%eax
    73db:	74 0a                	je     73e7 <hash_init+0xe0>
    73dd:	8b 45 08             	mov    0x8(%ebp),%eax
    73e0:	8b 40 14             	mov    0x14(%eax),%eax
    73e3:	85 c0                	test   %eax,%eax
    73e5:	75 0a                	jne    73f1 <hash_init+0xea>
    return 83; /*alloc fail*/
    73e7:	b8 53 00 00 00       	mov    $0x53,%eax
    73ec:	e9 d3 00 00 00       	jmp    74c4 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    73f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    73f8:	eb 17                	jmp    7411 <hash_init+0x10a>
    73fa:	8b 45 08             	mov    0x8(%ebp),%eax
    73fd:	8b 00                	mov    (%eax),%eax
    73ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7402:	c1 e2 02             	shl    $0x2,%edx
    7405:	01 d0                	add    %edx,%eax
    7407:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    740d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7411:	b8 00 00 01 00       	mov    $0x10000,%eax
    7416:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    7419:	75 df                	jne    73fa <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    741b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7422:	eb 18                	jmp    743c <hash_init+0x135>
    7424:	8b 45 08             	mov    0x8(%ebp),%eax
    7427:	8b 40 08             	mov    0x8(%eax),%eax
    742a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    742d:	c1 e2 02             	shl    $0x2,%edx
    7430:	01 d0                	add    %edx,%eax
    7432:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    7438:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    743c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    743f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7442:	75 e0                	jne    7424 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    7444:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    744b:	eb 17                	jmp    7464 <hash_init+0x15d>
    744d:	8b 45 08             	mov    0x8(%ebp),%eax
    7450:	8b 40 04             	mov    0x4(%eax),%eax
    7453:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7456:	01 d2                	add    %edx,%edx
    7458:	01 d0                	add    %edx,%eax
    745a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    745d:	66 89 10             	mov    %dx,(%eax)
    7460:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7464:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7467:	3b 45 0c             	cmp    0xc(%ebp),%eax
    746a:	75 e1                	jne    744d <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    746c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7473:	eb 18                	jmp    748d <hash_init+0x186>
    7475:	8b 45 08             	mov    0x8(%ebp),%eax
    7478:	8b 40 0c             	mov    0xc(%eax),%eax
    747b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    747e:	c1 e2 02             	shl    $0x2,%edx
    7481:	01 d0                	add    %edx,%eax
    7483:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    7489:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    748d:	b8 02 01 00 00       	mov    $0x102,%eax
    7492:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    7495:	76 de                	jbe    7475 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    7497:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    749e:	eb 17                	jmp    74b7 <hash_init+0x1b0>
    74a0:	8b 45 08             	mov    0x8(%ebp),%eax
    74a3:	8b 40 10             	mov    0x10(%eax),%eax
    74a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    74a9:	01 d2                	add    %edx,%edx
    74ab:	01 d0                	add    %edx,%eax
    74ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    74b0:	66 89 10             	mov    %dx,(%eax)
    74b3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    74b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    74ba:	3b 45 0c             	cmp    0xc(%ebp),%eax
    74bd:	75 e1                	jne    74a0 <hash_init+0x199>

  return 0;
    74bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    74c4:	c9                   	leave  
    74c5:	c3                   	ret    

000074c6 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    74c6:	55                   	push   %ebp
    74c7:	89 e5                	mov    %esp,%ebp
    74c9:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    74cc:	8b 45 08             	mov    0x8(%ebp),%eax
    74cf:	8b 00                	mov    (%eax),%eax
    74d1:	83 ec 0c             	sub    $0xc,%esp
    74d4:	50                   	push   %eax
    74d5:	e8 57 cf ff ff       	call   4431 <lodepng_free>
    74da:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    74dd:	8b 45 08             	mov    0x8(%ebp),%eax
    74e0:	8b 40 08             	mov    0x8(%eax),%eax
    74e3:	83 ec 0c             	sub    $0xc,%esp
    74e6:	50                   	push   %eax
    74e7:	e8 45 cf ff ff       	call   4431 <lodepng_free>
    74ec:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    74ef:	8b 45 08             	mov    0x8(%ebp),%eax
    74f2:	8b 40 04             	mov    0x4(%eax),%eax
    74f5:	83 ec 0c             	sub    $0xc,%esp
    74f8:	50                   	push   %eax
    74f9:	e8 33 cf ff ff       	call   4431 <lodepng_free>
    74fe:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    7501:	8b 45 08             	mov    0x8(%ebp),%eax
    7504:	8b 40 14             	mov    0x14(%eax),%eax
    7507:	83 ec 0c             	sub    $0xc,%esp
    750a:	50                   	push   %eax
    750b:	e8 21 cf ff ff       	call   4431 <lodepng_free>
    7510:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    7513:	8b 45 08             	mov    0x8(%ebp),%eax
    7516:	8b 40 0c             	mov    0xc(%eax),%eax
    7519:	83 ec 0c             	sub    $0xc,%esp
    751c:	50                   	push   %eax
    751d:	e8 0f cf ff ff       	call   4431 <lodepng_free>
    7522:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    7525:	8b 45 08             	mov    0x8(%ebp),%eax
    7528:	8b 40 10             	mov    0x10(%eax),%eax
    752b:	83 ec 0c             	sub    $0xc,%esp
    752e:	50                   	push   %eax
    752f:	e8 fd ce ff ff       	call   4431 <lodepng_free>
    7534:	83 c4 10             	add    $0x10,%esp
}
    7537:	90                   	nop
    7538:	c9                   	leave  
    7539:	c3                   	ret    

0000753a <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    753a:	55                   	push   %ebp
    753b:	89 e5                	mov    %esp,%ebp
    753d:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    7540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    7547:	8b 45 10             	mov    0x10(%ebp),%eax
    754a:	83 c0 02             	add    $0x2,%eax
    754d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7550:	7d 41                	jge    7593 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    7552:	8b 55 10             	mov    0x10(%ebp),%edx
    7555:	8b 45 08             	mov    0x8(%ebp),%eax
    7558:	01 d0                	add    %edx,%eax
    755a:	0f b6 00             	movzbl (%eax),%eax
    755d:	0f b6 c0             	movzbl %al,%eax
    7560:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    7563:	8b 45 10             	mov    0x10(%ebp),%eax
    7566:	8d 50 01             	lea    0x1(%eax),%edx
    7569:	8b 45 08             	mov    0x8(%ebp),%eax
    756c:	01 d0                	add    %edx,%eax
    756e:	0f b6 00             	movzbl (%eax),%eax
    7571:	0f b6 c0             	movzbl %al,%eax
    7574:	c1 e0 04             	shl    $0x4,%eax
    7577:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    757a:	8b 45 10             	mov    0x10(%ebp),%eax
    757d:	8d 50 02             	lea    0x2(%eax),%edx
    7580:	8b 45 08             	mov    0x8(%ebp),%eax
    7583:	01 d0                	add    %edx,%eax
    7585:	0f b6 00             	movzbl (%eax),%eax
    7588:	0f b6 c0             	movzbl %al,%eax
    758b:	c1 e0 08             	shl    $0x8,%eax
    758e:	31 45 fc             	xor    %eax,-0x4(%ebp)
    7591:	eb 51                	jmp    75e4 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    7593:	8b 45 10             	mov    0x10(%ebp),%eax
    7596:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7599:	7c 07                	jl     75a2 <getHash+0x68>
    759b:	b8 00 00 00 00       	mov    $0x0,%eax
    75a0:	eb 4a                	jmp    75ec <getHash+0xb2>
    amount = size - pos;
    75a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    75a5:	2b 45 10             	sub    0x10(%ebp),%eax
    75a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    75ab:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    75b2:	eb 28                	jmp    75dc <getHash+0xa2>
    75b4:	8b 55 10             	mov    0x10(%ebp),%edx
    75b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    75ba:	01 d0                	add    %edx,%eax
    75bc:	89 c2                	mov    %eax,%edx
    75be:	8b 45 08             	mov    0x8(%ebp),%eax
    75c1:	01 d0                	add    %edx,%eax
    75c3:	0f b6 00             	movzbl (%eax),%eax
    75c6:	0f b6 d0             	movzbl %al,%edx
    75c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    75cc:	c1 e0 03             	shl    $0x3,%eax
    75cf:	89 c1                	mov    %eax,%ecx
    75d1:	d3 e2                	shl    %cl,%edx
    75d3:	89 d0                	mov    %edx,%eax
    75d5:	31 45 fc             	xor    %eax,-0x4(%ebp)
    75d8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    75dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    75df:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    75e2:	75 d0                	jne    75b4 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    75e4:	b8 ff ff 00 00       	mov    $0xffff,%eax
    75e9:	23 45 fc             	and    -0x4(%ebp),%eax
}
    75ec:	c9                   	leave  
    75ed:	c3                   	ret    

000075ee <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    75ee:	55                   	push   %ebp
    75ef:	89 e5                	mov    %esp,%ebp
    75f1:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    75f4:	8b 55 10             	mov    0x10(%ebp),%edx
    75f7:	8b 45 08             	mov    0x8(%ebp),%eax
    75fa:	01 d0                	add    %edx,%eax
    75fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    75ff:	b8 02 01 00 00       	mov    $0x102,%eax
    7604:	89 c2                	mov    %eax,%edx
    7606:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7609:	01 d0                	add    %edx,%eax
    760b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    760e:	8b 55 0c             	mov    0xc(%ebp),%edx
    7611:	8b 45 08             	mov    0x8(%ebp),%eax
    7614:	01 d0                	add    %edx,%eax
    7616:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    7619:	73 0b                	jae    7626 <countZeros+0x38>
    761b:	8b 55 0c             	mov    0xc(%ebp),%edx
    761e:	8b 45 08             	mov    0x8(%ebp),%eax
    7621:	01 d0                	add    %edx,%eax
    7623:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    7626:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7629:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    762c:	eb 04                	jmp    7632 <countZeros+0x44>
    762e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    7632:	8b 45 08             	mov    0x8(%ebp),%eax
    7635:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    7638:	74 0a                	je     7644 <countZeros+0x56>
    763a:	8b 45 08             	mov    0x8(%ebp),%eax
    763d:	0f b6 00             	movzbl (%eax),%eax
    7640:	84 c0                	test   %al,%al
    7642:	74 ea                	je     762e <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    7644:	8b 55 08             	mov    0x8(%ebp),%edx
    7647:	8b 45 f8             	mov    -0x8(%ebp),%eax
    764a:	29 c2                	sub    %eax,%edx
    764c:	89 d0                	mov    %edx,%eax
}
    764e:	c9                   	leave  
    764f:	c3                   	ret    

00007650 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    7650:	55                   	push   %ebp
    7651:	89 e5                	mov    %esp,%ebp
    7653:	83 ec 04             	sub    $0x4,%esp
    7656:	8b 45 14             	mov    0x14(%ebp),%eax
    7659:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    765d:	8b 45 08             	mov    0x8(%ebp),%eax
    7660:	8b 40 08             	mov    0x8(%eax),%eax
    7663:	8b 55 0c             	mov    0xc(%ebp),%edx
    7666:	c1 e2 02             	shl    $0x2,%edx
    7669:	01 c2                	add    %eax,%edx
    766b:	8b 45 10             	mov    0x10(%ebp),%eax
    766e:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    7670:	8b 45 08             	mov    0x8(%ebp),%eax
    7673:	8b 00                	mov    (%eax),%eax
    7675:	8b 55 10             	mov    0x10(%ebp),%edx
    7678:	c1 e2 02             	shl    $0x2,%edx
    767b:	01 d0                	add    %edx,%eax
    767d:	8b 00                	mov    (%eax),%eax
    767f:	83 f8 ff             	cmp    $0xffffffff,%eax
    7682:	74 1f                	je     76a3 <updateHashChain+0x53>
    7684:	8b 45 08             	mov    0x8(%ebp),%eax
    7687:	8b 40 04             	mov    0x4(%eax),%eax
    768a:	8b 55 0c             	mov    0xc(%ebp),%edx
    768d:	01 d2                	add    %edx,%edx
    768f:	01 c2                	add    %eax,%edx
    7691:	8b 45 08             	mov    0x8(%ebp),%eax
    7694:	8b 00                	mov    (%eax),%eax
    7696:	8b 4d 10             	mov    0x10(%ebp),%ecx
    7699:	c1 e1 02             	shl    $0x2,%ecx
    769c:	01 c8                	add    %ecx,%eax
    769e:	8b 00                	mov    (%eax),%eax
    76a0:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    76a3:	8b 45 08             	mov    0x8(%ebp),%eax
    76a6:	8b 00                	mov    (%eax),%eax
    76a8:	8b 55 10             	mov    0x10(%ebp),%edx
    76ab:	c1 e2 02             	shl    $0x2,%edx
    76ae:	01 c2                	add    %eax,%edx
    76b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    76b3:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    76b5:	8b 45 08             	mov    0x8(%ebp),%eax
    76b8:	8b 40 14             	mov    0x14(%eax),%eax
    76bb:	8b 55 0c             	mov    0xc(%ebp),%edx
    76be:	01 d2                	add    %edx,%edx
    76c0:	01 c2                	add    %eax,%edx
    76c2:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    76c6:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    76c9:	8b 45 08             	mov    0x8(%ebp),%eax
    76cc:	8b 40 0c             	mov    0xc(%eax),%eax
    76cf:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    76d3:	c1 e2 02             	shl    $0x2,%edx
    76d6:	01 d0                	add    %edx,%eax
    76d8:	8b 00                	mov    (%eax),%eax
    76da:	83 f8 ff             	cmp    $0xffffffff,%eax
    76dd:	74 21                	je     7700 <updateHashChain+0xb0>
    76df:	8b 45 08             	mov    0x8(%ebp),%eax
    76e2:	8b 40 10             	mov    0x10(%eax),%eax
    76e5:	8b 55 0c             	mov    0xc(%ebp),%edx
    76e8:	01 d2                	add    %edx,%edx
    76ea:	01 c2                	add    %eax,%edx
    76ec:	8b 45 08             	mov    0x8(%ebp),%eax
    76ef:	8b 40 0c             	mov    0xc(%eax),%eax
    76f2:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    76f6:	c1 e1 02             	shl    $0x2,%ecx
    76f9:	01 c8                	add    %ecx,%eax
    76fb:	8b 00                	mov    (%eax),%eax
    76fd:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    7700:	8b 45 08             	mov    0x8(%ebp),%eax
    7703:	8b 40 0c             	mov    0xc(%eax),%eax
    7706:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    770a:	c1 e2 02             	shl    $0x2,%edx
    770d:	01 c2                	add    %eax,%edx
    770f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7712:	89 02                	mov    %eax,(%edx)
}
    7714:	90                   	nop
    7715:	c9                   	leave  
    7716:	c3                   	ret    

00007717 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    7717:	55                   	push   %ebp
    7718:	89 e5                	mov    %esp,%ebp
    771a:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    771d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    7724:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    772b:	77 08                	ja     7735 <encodeLZ77+0x1e>
    772d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7730:	c1 e8 03             	shr    $0x3,%eax
    7733:	eb 03                	jmp    7738 <encodeLZ77+0x21>
    7735:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7738:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    773b:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    7742:	76 07                	jbe    774b <encodeLZ77+0x34>
    7744:	b8 02 01 00 00       	mov    $0x102,%eax
    7749:	eb 05                	jmp    7750 <encodeLZ77+0x39>
    774b:	b8 40 00 00 00       	mov    $0x40,%eax
    7750:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    7753:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    775a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    7761:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    7768:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    776f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    7776:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    777a:	74 09                	je     7785 <encodeLZ77+0x6e>
    777c:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    7783:	76 0a                	jbe    778f <encodeLZ77+0x78>
    7785:	b8 3c 00 00 00       	mov    $0x3c,%eax
    778a:	e9 e3 04 00 00       	jmp    7c72 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    778f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7792:	83 e8 01             	sub    $0x1,%eax
    7795:	23 45 1c             	and    0x1c(%ebp),%eax
    7798:	85 c0                	test   %eax,%eax
    779a:	74 0a                	je     77a6 <encodeLZ77+0x8f>
    779c:	b8 5a 00 00 00       	mov    $0x5a,%eax
    77a1:	e9 cc 04 00 00       	jmp    7c72 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    77a6:	b8 02 01 00 00       	mov    $0x102,%eax
    77ab:	39 45 24             	cmp    %eax,0x24(%ebp)
    77ae:	76 08                	jbe    77b8 <encodeLZ77+0xa1>
    77b0:	b8 02 01 00 00       	mov    $0x102,%eax
    77b5:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    77b8:	8b 45 14             	mov    0x14(%ebp),%eax
    77bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    77be:	e9 a0 04 00 00       	jmp    7c63 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    77c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    77c6:	8d 50 ff             	lea    -0x1(%eax),%edx
    77c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    77cc:	21 d0                	and    %edx,%eax
    77ce:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    77d1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    77d8:	ff 75 fc             	pushl  -0x4(%ebp)
    77db:	ff 75 18             	pushl  0x18(%ebp)
    77de:	ff 75 10             	pushl  0x10(%ebp)
    77e1:	e8 54 fd ff ff       	call   753a <getHash>
    77e6:	83 c4 0c             	add    $0xc,%esp
    77e9:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    77ec:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    77f0:	74 4e                	je     7840 <encodeLZ77+0x129>
    77f2:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    77f6:	75 48                	jne    7840 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    77f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    77fc:	75 16                	jne    7814 <encodeLZ77+0xfd>
    77fe:	ff 75 fc             	pushl  -0x4(%ebp)
    7801:	ff 75 18             	pushl  0x18(%ebp)
    7804:	ff 75 10             	pushl  0x10(%ebp)
    7807:	e8 e2 fd ff ff       	call   75ee <countZeros>
    780c:	83 c4 0c             	add    $0xc,%esp
    780f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7812:	eb 35                	jmp    7849 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    7814:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7817:	8b 45 f0             	mov    -0x10(%ebp),%eax
    781a:	01 c2                	add    %eax,%edx
    781c:	8b 45 18             	mov    0x18(%ebp),%eax
    781f:	39 c2                	cmp    %eax,%edx
    7821:	77 17                	ja     783a <encodeLZ77+0x123>
    7823:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7826:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7829:	01 d0                	add    %edx,%eax
    782b:	8d 50 ff             	lea    -0x1(%eax),%edx
    782e:	8b 45 10             	mov    0x10(%ebp),%eax
    7831:	01 d0                	add    %edx,%eax
    7833:	0f b6 00             	movzbl (%eax),%eax
    7836:	84 c0                	test   %al,%al
    7838:	74 0f                	je     7849 <encodeLZ77+0x132>
    783a:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    783e:	eb 09                	jmp    7849 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    7840:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7847:	eb 01                	jmp    784a <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7849:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    784a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    784d:	0f b7 c0             	movzwl %ax,%eax
    7850:	50                   	push   %eax
    7851:	ff 75 b0             	pushl  -0x50(%ebp)
    7854:	ff 75 b4             	pushl  -0x4c(%ebp)
    7857:	ff 75 0c             	pushl  0xc(%ebp)
    785a:	e8 f1 fd ff ff       	call   7650 <updateHashChain>
    785f:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    7862:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    7869:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    7870:	8b 45 0c             	mov    0xc(%ebp),%eax
    7873:	8b 40 04             	mov    0x4(%eax),%eax
    7876:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    7879:	01 d2                	add    %edx,%edx
    787b:	01 d0                	add    %edx,%eax
    787d:	0f b7 00             	movzwl (%eax),%eax
    7880:	0f b7 c0             	movzwl %ax,%eax
    7883:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    7886:	ba 02 01 00 00       	mov    $0x102,%edx
    788b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    788e:	01 c2                	add    %eax,%edx
    7890:	8b 45 18             	mov    0x18(%ebp),%eax
    7893:	39 c2                	cmp    %eax,%edx
    7895:	0f 4e c2             	cmovle %edx,%eax
    7898:	89 c2                	mov    %eax,%edx
    789a:	8b 45 10             	mov    0x10(%ebp),%eax
    789d:	01 d0                	add    %edx,%eax
    789f:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    78a2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    78a9:	8b 45 c8             	mov    -0x38(%ebp),%eax
    78ac:	8d 50 01             	lea    0x1(%eax),%edx
    78af:	89 55 c8             	mov    %edx,-0x38(%ebp)
    78b2:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    78b5:	0f 83 67 01 00 00    	jae    7a22 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    78bb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    78be:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    78c1:	77 08                	ja     78cb <encodeLZ77+0x1b4>
    78c3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    78c6:	2b 45 cc             	sub    -0x34(%ebp),%eax
    78c9:	eb 0d                	jmp    78d8 <encodeLZ77+0x1c1>
    78cb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    78ce:	2b 45 cc             	sub    -0x34(%ebp),%eax
    78d1:	89 c2                	mov    %eax,%edx
    78d3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78d6:	01 d0                	add    %edx,%eax
    78d8:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    78db:	8b 45 a8             	mov    -0x58(%ebp),%eax
    78de:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    78e1:	0f 82 3e 01 00 00    	jb     7a25 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    78e7:	8b 45 a8             	mov    -0x58(%ebp),%eax
    78ea:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    78ed:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    78f1:	0f 84 a3 00 00 00    	je     799a <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    78f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    78fa:	8b 45 10             	mov    0x10(%ebp),%eax
    78fd:	01 d0                	add    %edx,%eax
    78ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    7902:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7905:	2b 45 a8             	sub    -0x58(%ebp),%eax
    7908:	89 c2                	mov    %eax,%edx
    790a:	8b 45 10             	mov    0x10(%ebp),%eax
    790d:	01 d0                	add    %edx,%eax
    790f:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    7912:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    7916:	76 3a                	jbe    7952 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    7918:	8b 45 0c             	mov    0xc(%ebp),%eax
    791b:	8b 40 14             	mov    0x14(%eax),%eax
    791e:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7921:	01 d2                	add    %edx,%edx
    7923:	01 d0                	add    %edx,%eax
    7925:	0f b7 00             	movzwl (%eax),%eax
    7928:	0f b7 c0             	movzwl %ax,%eax
    792b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    792e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7931:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7934:	76 06                	jbe    793c <encodeLZ77+0x225>
    7936:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7939:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    793c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    793f:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    7942:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7945:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    7948:	eb 08                	jmp    7952 <encodeLZ77+0x23b>
          ++backptr;
    794a:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    794e:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    7952:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7955:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7958:	74 10                	je     796a <encodeLZ77+0x253>
    795a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    795d:	0f b6 10             	movzbl (%eax),%edx
    7960:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7963:	0f b6 00             	movzbl (%eax),%eax
    7966:	38 c2                	cmp    %al,%dl
    7968:	74 e0                	je     794a <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    796a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    796d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7970:	8b 55 10             	mov    0x10(%ebp),%edx
    7973:	01 ca                	add    %ecx,%edx
    7975:	29 d0                	sub    %edx,%eax
    7977:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    797a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    797d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7980:	76 18                	jbe    799a <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    7982:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    7985:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    7988:	8b 45 a8             	mov    -0x58(%ebp),%eax
    798b:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    798e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    7991:	3b 45 24             	cmp    0x24(%ebp),%eax
    7994:	0f 83 8e 00 00 00    	jae    7a28 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    799a:	8b 45 0c             	mov    0xc(%ebp),%eax
    799d:	8b 40 04             	mov    0x4(%eax),%eax
    79a0:	8b 55 cc             	mov    -0x34(%ebp),%edx
    79a3:	01 d2                	add    %edx,%edx
    79a5:	01 d0                	add    %edx,%eax
    79a7:	0f b7 00             	movzwl (%eax),%eax
    79aa:	0f b7 c0             	movzwl %ax,%eax
    79ad:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    79b0:	74 79                	je     7a2b <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    79b2:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    79b6:	76 38                	jbe    79f0 <encodeLZ77+0x2d9>
    79b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    79bb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    79be:	76 30                	jbe    79f0 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    79c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    79c3:	8b 40 10             	mov    0x10(%eax),%eax
    79c6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    79c9:	01 d2                	add    %edx,%edx
    79cb:	01 d0                	add    %edx,%eax
    79cd:	0f b7 00             	movzwl (%eax),%eax
    79d0:	0f b7 c0             	movzwl %ax,%eax
    79d3:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    79d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    79d9:	8b 40 14             	mov    0x14(%eax),%eax
    79dc:	8b 55 cc             	mov    -0x34(%ebp),%edx
    79df:	01 d2                	add    %edx,%edx
    79e1:	01 d0                	add    %edx,%eax
    79e3:	0f b7 00             	movzwl (%eax),%eax
    79e6:	0f b7 c0             	movzwl %ax,%eax
    79e9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    79ec:	74 2f                	je     7a1d <encodeLZ77+0x306>
    79ee:	eb 3f                	jmp    7a2f <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    79f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    79f3:	8b 40 04             	mov    0x4(%eax),%eax
    79f6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    79f9:	01 d2                	add    %edx,%edx
    79fb:	01 d0                	add    %edx,%eax
    79fd:	0f b7 00             	movzwl (%eax),%eax
    7a00:	0f b7 c0             	movzwl %ax,%eax
    7a03:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    7a06:	8b 45 0c             	mov    0xc(%ebp),%eax
    7a09:	8b 40 08             	mov    0x8(%eax),%eax
    7a0c:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7a0f:	c1 e2 02             	shl    $0x2,%edx
    7a12:	01 d0                	add    %edx,%eax
    7a14:	8b 10                	mov    (%eax),%edx
    7a16:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7a19:	39 c2                	cmp    %eax,%edx
    7a1b:	75 11                	jne    7a2e <encodeLZ77+0x317>
      }
    }
    7a1d:	e9 87 fe ff ff       	jmp    78a9 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    7a22:	90                   	nop
    7a23:	eb 0a                	jmp    7a2f <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    7a25:	90                   	nop
    7a26:	eb 07                	jmp    7a2f <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    7a28:	90                   	nop
    7a29:	eb 04                	jmp    7a2f <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    7a2b:	90                   	nop
    7a2c:	eb 01                	jmp    7a2f <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    7a2e:	90                   	nop
      }
    }

    if(lazymatching) {
    7a2f:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    7a33:	0f 84 c8 00 00 00    	je     7b01 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    7a39:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    7a3d:	75 30                	jne    7a6f <encodeLZ77+0x358>
    7a3f:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    7a43:	76 2a                	jbe    7a6f <encodeLZ77+0x358>
    7a45:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a48:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    7a4b:	77 22                	ja     7a6f <encodeLZ77+0x358>
    7a4d:	b8 02 01 00 00       	mov    $0x102,%eax
    7a52:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    7a55:	73 18                	jae    7a6f <encodeLZ77+0x358>
        lazy = 1;
    7a57:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    7a5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a61:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    7a64:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a67:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    7a6a:	e9 f0 01 00 00       	jmp    7c5f <encodeLZ77+0x548>
      }
      if(lazy) {
    7a6f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    7a73:	0f 84 88 00 00 00    	je     7b01 <encodeLZ77+0x3ea>
        lazy = 0;
    7a79:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    7a80:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    7a84:	75 0c                	jne    7a92 <encodeLZ77+0x37b>
    7a86:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    7a8d:	e9 dd 01 00 00       	jmp    7c6f <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    7a92:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7a95:	83 c0 01             	add    $0x1,%eax
    7a98:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7a9b:	73 2d                	jae    7aca <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    7a9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7aa0:	8d 50 ff             	lea    -0x1(%eax),%edx
    7aa3:	8b 45 10             	mov    0x10(%ebp),%eax
    7aa6:	01 d0                	add    %edx,%eax
    7aa8:	0f b6 00             	movzbl (%eax),%eax
    7aab:	0f b6 c0             	movzbl %al,%eax
    7aae:	50                   	push   %eax
    7aaf:	ff 75 08             	pushl  0x8(%ebp)
    7ab2:	e8 6f cb ff ff       	call   4626 <uivector_push_back>
    7ab7:	83 c4 08             	add    $0x8,%esp
    7aba:	85 c0                	test   %eax,%eax
    7abc:	75 43                	jne    7b01 <encodeLZ77+0x3ea>
    7abe:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7ac5:	e9 a5 01 00 00       	jmp    7c6f <encodeLZ77+0x558>
        } else {
          length = lazylength;
    7aca:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7acd:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    7ad0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7ad3:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    7ad6:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ad9:	8b 00                	mov    (%eax),%eax
    7adb:	8b 55 b0             	mov    -0x50(%ebp),%edx
    7ade:	c1 e2 02             	shl    $0x2,%edx
    7ae1:	01 d0                	add    %edx,%eax
    7ae3:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    7ae9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7aec:	8b 40 0c             	mov    0xc(%eax),%eax
    7aef:	8b 55 f0             	mov    -0x10(%ebp),%edx
    7af2:	c1 e2 02             	shl    $0x2,%edx
    7af5:	01 d0                	add    %edx,%eax
    7af7:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    7afd:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    7b01:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    7b05:	76 14                	jbe    7b1b <encodeLZ77+0x404>
    7b07:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b0a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    7b0d:	76 0c                	jbe    7b1b <encodeLZ77+0x404>
    7b0f:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    7b16:	e9 54 01 00 00       	jmp    7c6f <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    7b1b:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    7b1f:	77 2e                	ja     7b4f <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    7b21:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7b24:	8b 45 10             	mov    0x10(%ebp),%eax
    7b27:	01 d0                	add    %edx,%eax
    7b29:	0f b6 00             	movzbl (%eax),%eax
    7b2c:	0f b6 c0             	movzbl %al,%eax
    7b2f:	50                   	push   %eax
    7b30:	ff 75 08             	pushl  0x8(%ebp)
    7b33:	e8 ee ca ff ff       	call   4626 <uivector_push_back>
    7b38:	83 c4 08             	add    $0x8,%esp
    7b3b:	85 c0                	test   %eax,%eax
    7b3d:	0f 85 1c 01 00 00    	jne    7c5f <encodeLZ77+0x548>
    7b43:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7b4a:	e9 20 01 00 00       	jmp    7c6f <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    7b4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b52:	3b 45 20             	cmp    0x20(%ebp),%eax
    7b55:	72 0f                	jb     7b66 <encodeLZ77+0x44f>
    7b57:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    7b5b:	75 37                	jne    7b94 <encodeLZ77+0x47d>
    7b5d:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    7b64:	76 2e                	jbe    7b94 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    7b66:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7b69:	8b 45 10             	mov    0x10(%ebp),%eax
    7b6c:	01 d0                	add    %edx,%eax
    7b6e:	0f b6 00             	movzbl (%eax),%eax
    7b71:	0f b6 c0             	movzbl %al,%eax
    7b74:	50                   	push   %eax
    7b75:	ff 75 08             	pushl  0x8(%ebp)
    7b78:	e8 a9 ca ff ff       	call   4626 <uivector_push_back>
    7b7d:	83 c4 08             	add    $0x8,%esp
    7b80:	85 c0                	test   %eax,%eax
    7b82:	0f 85 d7 00 00 00    	jne    7c5f <encodeLZ77+0x548>
    7b88:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7b8f:	e9 db 00 00 00       	jmp    7c6f <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    7b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7b97:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b9a:	52                   	push   %edx
    7b9b:	50                   	push   %eax
    7b9c:	ff 75 08             	pushl  0x8(%ebp)
    7b9f:	e8 8a f6 ff ff       	call   722e <addLengthDistance>
    7ba4:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    7ba7:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    7bae:	e9 a0 00 00 00       	jmp    7c53 <encodeLZ77+0x53c>
        ++pos;
    7bb3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    7bb7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7bba:	8d 50 ff             	lea    -0x1(%eax),%edx
    7bbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7bc0:	21 d0                	and    %edx,%eax
    7bc2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    7bc5:	ff 75 fc             	pushl  -0x4(%ebp)
    7bc8:	ff 75 18             	pushl  0x18(%ebp)
    7bcb:	ff 75 10             	pushl  0x10(%ebp)
    7bce:	e8 67 f9 ff ff       	call   753a <getHash>
    7bd3:	83 c4 0c             	add    $0xc,%esp
    7bd6:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    7bd9:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    7bdd:	74 4e                	je     7c2d <encodeLZ77+0x516>
    7bdf:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    7be3:	75 48                	jne    7c2d <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7be5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7be9:	75 16                	jne    7c01 <encodeLZ77+0x4ea>
    7beb:	ff 75 fc             	pushl  -0x4(%ebp)
    7bee:	ff 75 18             	pushl  0x18(%ebp)
    7bf1:	ff 75 10             	pushl  0x10(%ebp)
    7bf4:	e8 f5 f9 ff ff       	call   75ee <countZeros>
    7bf9:	83 c4 0c             	add    $0xc,%esp
    7bfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7bff:	eb 35                	jmp    7c36 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    7c01:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7c04:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c07:	01 c2                	add    %eax,%edx
    7c09:	8b 45 18             	mov    0x18(%ebp),%eax
    7c0c:	39 c2                	cmp    %eax,%edx
    7c0e:	77 17                	ja     7c27 <encodeLZ77+0x510>
    7c10:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c16:	01 d0                	add    %edx,%eax
    7c18:	8d 50 ff             	lea    -0x1(%eax),%edx
    7c1b:	8b 45 10             	mov    0x10(%ebp),%eax
    7c1e:	01 d0                	add    %edx,%eax
    7c20:	0f b6 00             	movzbl (%eax),%eax
    7c23:	84 c0                	test   %al,%al
    7c25:	74 0f                	je     7c36 <encodeLZ77+0x51f>
    7c27:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7c2b:	eb 09                	jmp    7c36 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    7c2d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7c34:	eb 01                	jmp    7c37 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7c36:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    7c37:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c3a:	0f b7 c0             	movzwl %ax,%eax
    7c3d:	50                   	push   %eax
    7c3e:	ff 75 b0             	pushl  -0x50(%ebp)
    7c41:	ff 75 b4             	pushl  -0x4c(%ebp)
    7c44:	ff 75 0c             	pushl  0xc(%ebp)
    7c47:	e8 04 fa ff ff       	call   7650 <updateHashChain>
    7c4c:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    7c4f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7c53:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c56:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7c59:	0f 82 54 ff ff ff    	jb     7bb3 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    7c5f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7c63:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7c66:	3b 45 18             	cmp    0x18(%ebp),%eax
    7c69:	0f 8c 54 fb ff ff    	jl     77c3 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    7c6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7c72:	c9                   	leave  
    7c73:	c3                   	ret    

00007c74 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    7c74:	55                   	push   %ebp
    7c75:	89 e5                	mov    %esp,%ebp
    7c77:	53                   	push   %ebx
    7c78:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    7c7b:	8b 45 10             	mov    0x10(%ebp),%eax
    7c7e:	05 fe ff 00 00       	add    $0xfffe,%eax
    7c83:	ba 01 80 00 80       	mov    $0x80008001,%edx
    7c88:	f7 e2                	mul    %edx
    7c8a:	89 d0                	mov    %edx,%eax
    7c8c:	c1 e8 0f             	shr    $0xf,%eax
    7c8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    7c92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    7c99:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    7ca0:	e9 1b 01 00 00       	jmp    7dc0 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    7ca5:	8b 45 08             	mov    0x8(%ebp),%eax
    7ca8:	8b 40 04             	mov    0x4(%eax),%eax
    7cab:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    7cae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7cb1:	83 e8 01             	sub    $0x1,%eax
    7cb4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    7cb7:	0f 94 c0             	sete   %al
    7cba:	0f b6 c0             	movzbl %al,%eax
    7cbd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    7cc0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    7cc7:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    7cce:	8b 45 10             	mov    0x10(%ebp),%eax
    7cd1:	2b 45 f4             	sub    -0xc(%ebp),%eax
    7cd4:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    7cd9:	77 09                	ja     7ce4 <deflateNoCompression+0x70>
    7cdb:	8b 45 10             	mov    0x10(%ebp),%eax
    7cde:	2b 45 f4             	sub    -0xc(%ebp),%eax
    7ce1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    7ce4:	b8 ff ff 00 00       	mov    $0xffff,%eax
    7ce9:	2b 45 f0             	sub    -0x10(%ebp),%eax
    7cec:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    7cef:	8b 45 08             	mov    0x8(%ebp),%eax
    7cf2:	8b 40 04             	mov    0x4(%eax),%eax
    7cf5:	89 c2                	mov    %eax,%edx
    7cf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7cfa:	01 d0                	add    %edx,%eax
    7cfc:	83 c0 05             	add    $0x5,%eax
    7cff:	50                   	push   %eax
    7d00:	ff 75 08             	pushl  0x8(%ebp)
    7d03:	e8 62 c9 ff ff       	call   466a <ucvector_resize>
    7d08:	83 c4 08             	add    $0x8,%esp
    7d0b:	85 c0                	test   %eax,%eax
    7d0d:	75 0a                	jne    7d19 <deflateNoCompression+0xa5>
    7d0f:	b8 53 00 00 00       	mov    $0x53,%eax
    7d14:	e9 b8 00 00 00       	jmp    7dd1 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    7d19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7d1c:	89 c2                	mov    %eax,%edx
    7d1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d21:	83 e0 01             	and    $0x1,%eax
    7d24:	01 c0                	add    %eax,%eax
    7d26:	01 c2                	add    %eax,%edx
    7d28:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d2b:	83 e0 02             	and    $0x2,%eax
    7d2e:	01 c0                	add    %eax,%eax
    7d30:	01 d0                	add    %edx,%eax
    7d32:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    7d35:	8b 45 08             	mov    0x8(%ebp),%eax
    7d38:	8b 10                	mov    (%eax),%edx
    7d3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d3d:	01 c2                	add    %eax,%edx
    7d3f:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    7d43:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    7d45:	8b 45 08             	mov    0x8(%ebp),%eax
    7d48:	8b 00                	mov    (%eax),%eax
    7d4a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d4d:	83 c2 01             	add    $0x1,%edx
    7d50:	01 d0                	add    %edx,%eax
    7d52:	8b 55 f0             	mov    -0x10(%ebp),%edx
    7d55:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    7d57:	8b 45 08             	mov    0x8(%ebp),%eax
    7d5a:	8b 00                	mov    (%eax),%eax
    7d5c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d5f:	83 c2 02             	add    $0x2,%edx
    7d62:	01 d0                	add    %edx,%eax
    7d64:	8b 55 f0             	mov    -0x10(%ebp),%edx
    7d67:	c1 ea 08             	shr    $0x8,%edx
    7d6a:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    7d6c:	8b 45 08             	mov    0x8(%ebp),%eax
    7d6f:	8b 00                	mov    (%eax),%eax
    7d71:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d74:	83 c2 03             	add    $0x3,%edx
    7d77:	01 d0                	add    %edx,%eax
    7d79:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7d7c:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    7d7e:	8b 45 08             	mov    0x8(%ebp),%eax
    7d81:	8b 00                	mov    (%eax),%eax
    7d83:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d86:	83 c2 04             	add    $0x4,%edx
    7d89:	01 d0                	add    %edx,%eax
    7d8b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7d8e:	c1 ea 08             	shr    $0x8,%edx
    7d91:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    7d93:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d96:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    7d99:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7d9c:	01 d1                	add    %edx,%ecx
    7d9e:	8b 55 08             	mov    0x8(%ebp),%edx
    7da1:	8b 12                	mov    (%edx),%edx
    7da3:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    7da6:	83 c3 05             	add    $0x5,%ebx
    7da9:	01 da                	add    %ebx,%edx
    7dab:	50                   	push   %eax
    7dac:	51                   	push   %ecx
    7dad:	52                   	push   %edx
    7dae:	e8 9b c6 ff ff       	call   444e <lodepng_memcpy>
    7db3:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    7db6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7db9:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    7dbc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7dc0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7dc3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    7dc6:	0f 85 d9 fe ff ff    	jne    7ca5 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    7dcc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7dd1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7dd4:	c9                   	leave  
    7dd5:	c3                   	ret    

00007dd6 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    7dd6:	55                   	push   %ebp
    7dd7:	89 e5                	mov    %esp,%ebp
    7dd9:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    7ddc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    7de3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    7dea:	e9 10 01 00 00       	jmp    7eff <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    7def:	8b 45 0c             	mov    0xc(%ebp),%eax
    7df2:	8b 00                	mov    (%eax),%eax
    7df4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7df7:	c1 e2 02             	shl    $0x2,%edx
    7dfa:	01 d0                	add    %edx,%eax
    7dfc:	8b 00                	mov    (%eax),%eax
    7dfe:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    7e01:	8b 45 10             	mov    0x10(%ebp),%eax
    7e04:	8b 40 04             	mov    0x4(%eax),%eax
    7e07:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7e0a:	c1 e2 02             	shl    $0x2,%edx
    7e0d:	01 d0                	add    %edx,%eax
    7e0f:	8b 00                	mov    (%eax),%eax
    7e11:	89 c1                	mov    %eax,%ecx
    7e13:	8b 45 10             	mov    0x10(%ebp),%eax
    7e16:	8b 00                	mov    (%eax),%eax
    7e18:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7e1b:	c1 e2 02             	shl    $0x2,%edx
    7e1e:	01 d0                	add    %edx,%eax
    7e20:	8b 00                	mov    (%eax),%eax
    7e22:	51                   	push   %ecx
    7e23:	50                   	push   %eax
    7e24:	ff 75 08             	pushl  0x8(%ebp)
    7e27:	e8 60 cc ff ff       	call   4a8c <writeBitsReversed>
    7e2c:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    7e2f:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    7e36:	0f 86 bf 00 00 00    	jbe    7efb <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    7e3c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7e3f:	2d 01 01 00 00       	sub    $0x101,%eax
    7e44:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    7e47:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7e4a:	8b 04 85 80 ae 01 00 	mov    0x1ae80(,%eax,4),%eax
    7e51:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    7e54:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e57:	8b 00                	mov    (%eax),%eax
    7e59:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7e5d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7e60:	c1 e2 02             	shl    $0x2,%edx
    7e63:	01 d0                	add    %edx,%eax
    7e65:	8b 00                	mov    (%eax),%eax
    7e67:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    7e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e6d:	8b 00                	mov    (%eax),%eax
    7e6f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7e73:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7e76:	c1 e2 02             	shl    $0x2,%edx
    7e79:	01 d0                	add    %edx,%eax
    7e7b:	8b 00                	mov    (%eax),%eax
    7e7d:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    7e80:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7e83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    7e86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7e89:	8b 04 85 80 af 01 00 	mov    0x1af80(,%eax,4),%eax
    7e90:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    7e93:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e96:	8b 00                	mov    (%eax),%eax
    7e98:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7e9c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7e9f:	c1 e2 02             	shl    $0x2,%edx
    7ea2:	01 d0                	add    %edx,%eax
    7ea4:	8b 00                	mov    (%eax),%eax
    7ea6:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    7ea9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7eac:	50                   	push   %eax
    7ead:	ff 75 ec             	pushl  -0x14(%ebp)
    7eb0:	ff 75 08             	pushl  0x8(%ebp)
    7eb3:	e8 40 ca ff ff       	call   48f8 <writeBits>
    7eb8:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    7ebb:	8b 45 14             	mov    0x14(%ebp),%eax
    7ebe:	8b 40 04             	mov    0x4(%eax),%eax
    7ec1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ec4:	c1 e2 02             	shl    $0x2,%edx
    7ec7:	01 d0                	add    %edx,%eax
    7ec9:	8b 00                	mov    (%eax),%eax
    7ecb:	89 c1                	mov    %eax,%ecx
    7ecd:	8b 45 14             	mov    0x14(%ebp),%eax
    7ed0:	8b 00                	mov    (%eax),%eax
    7ed2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ed5:	c1 e2 02             	shl    $0x2,%edx
    7ed8:	01 d0                	add    %edx,%eax
    7eda:	8b 00                	mov    (%eax),%eax
    7edc:	51                   	push   %ecx
    7edd:	50                   	push   %eax
    7ede:	ff 75 08             	pushl  0x8(%ebp)
    7ee1:	e8 a6 cb ff ff       	call   4a8c <writeBitsReversed>
    7ee6:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    7ee9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7eec:	50                   	push   %eax
    7eed:	ff 75 dc             	pushl  -0x24(%ebp)
    7ef0:	ff 75 08             	pushl  0x8(%ebp)
    7ef3:	e8 00 ca ff ff       	call   48f8 <writeBits>
    7ef8:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    7efb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7eff:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f02:	8b 40 04             	mov    0x4(%eax),%eax
    7f05:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    7f08:	0f 85 e1 fe ff ff    	jne    7def <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    7f0e:	90                   	nop
    7f0f:	c9                   	leave  
    7f10:	c3                   	ret    

00007f11 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    7f11:	55                   	push   %ebp
    7f12:	89 e5                	mov    %esp,%ebp
    7f14:	53                   	push   %ebx
    7f15:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    7f1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    7f22:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    7f29:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    7f30:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    7f37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    7f3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    7f45:	8b 45 18             	mov    0x18(%ebp),%eax
    7f48:	2b 45 14             	sub    0x14(%ebp),%eax
    7f4b:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    7f4e:	8b 45 20             	mov    0x20(%ebp),%eax
    7f51:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    7f54:	8d 45 90             	lea    -0x70(%ebp),%eax
    7f57:	50                   	push   %eax
    7f58:	e8 a4 c6 ff ff       	call   4601 <uivector_init>
    7f5d:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    7f60:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7f66:	50                   	push   %eax
    7f67:	e8 98 d3 ff ff       	call   5304 <HuffmanTree_init>
    7f6c:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7f6f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7f75:	50                   	push   %eax
    7f76:	e8 89 d3 ff ff       	call   5304 <HuffmanTree_init>
    7f7b:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    7f7e:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7f84:	50                   	push   %eax
    7f85:	e8 7a d3 ff ff       	call   5304 <HuffmanTree_init>
    7f8a:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    7f8d:	83 ec 0c             	sub    $0xc,%esp
    7f90:	68 78 04 00 00       	push   $0x478
    7f95:	e8 76 c4 ff ff       	call   4410 <lodepng_malloc>
    7f9a:	83 c4 10             	add    $0x10,%esp
    7f9d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    7fa0:	83 ec 0c             	sub    $0xc,%esp
    7fa3:	6a 78                	push   $0x78
    7fa5:	e8 66 c4 ff ff       	call   4410 <lodepng_malloc>
    7faa:	83 c4 10             	add    $0x10,%esp
    7fad:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7fb0:	83 ec 0c             	sub    $0xc,%esp
    7fb3:	6a 4c                	push   $0x4c
    7fb5:	e8 56 c4 ff ff       	call   4410 <lodepng_malloc>
    7fba:	83 c4 10             	add    $0x10,%esp
    7fbd:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    7fc0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    7fc4:	74 0c                	je     7fd2 <deflateDynamic+0xc1>
    7fc6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    7fca:	74 06                	je     7fd2 <deflateDynamic+0xc1>
    7fcc:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    7fd0:	75 07                	jne    7fd9 <deflateDynamic+0xc8>
    7fd2:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    7fd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7fdd:	0f 85 f6 07 00 00    	jne    87d9 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    7fe3:	83 ec 04             	sub    $0x4,%esp
    7fe6:	68 78 04 00 00       	push   $0x478
    7feb:	6a 00                	push   $0x0
    7fed:	ff 75 d4             	pushl  -0x2c(%ebp)
    7ff0:	e8 8c c4 ff ff       	call   4481 <lodepng_memset>
    7ff5:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    7ff8:	83 ec 04             	sub    $0x4,%esp
    7ffb:	6a 78                	push   $0x78
    7ffd:	6a 00                	push   $0x0
    7fff:	ff 75 d0             	pushl  -0x30(%ebp)
    8002:	e8 7a c4 ff ff       	call   4481 <lodepng_memset>
    8007:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    800a:	83 ec 04             	sub    $0x4,%esp
    800d:	6a 4c                	push   $0x4c
    800f:	6a 00                	push   $0x0
    8011:	ff 75 cc             	pushl  -0x34(%ebp)
    8014:	e8 68 c4 ff ff       	call   4481 <lodepng_memset>
    8019:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    801c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    801f:	8b 40 04             	mov    0x4(%eax),%eax
    8022:	85 c0                	test   %eax,%eax
    8024:	74 45                	je     806b <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    8026:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8029:	8b 58 14             	mov    0x14(%eax),%ebx
    802c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    802f:	8b 48 10             	mov    0x10(%eax),%ecx
    8032:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8035:	8b 50 0c             	mov    0xc(%eax),%edx
    8038:	8b 45 1c             	mov    0x1c(%ebp),%eax
    803b:	8b 40 08             	mov    0x8(%eax),%eax
    803e:	83 ec 0c             	sub    $0xc,%esp
    8041:	53                   	push   %ebx
    8042:	51                   	push   %ecx
    8043:	52                   	push   %edx
    8044:	50                   	push   %eax
    8045:	ff 75 18             	pushl  0x18(%ebp)
    8048:	ff 75 14             	pushl  0x14(%ebp)
    804b:	ff 75 10             	pushl  0x10(%ebp)
    804e:	ff 75 0c             	pushl  0xc(%ebp)
    8051:	8d 45 90             	lea    -0x70(%ebp),%eax
    8054:	50                   	push   %eax
    8055:	e8 bd f6 ff ff       	call   7717 <encodeLZ77>
    805a:	83 c4 30             	add    $0x30,%esp
    805d:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    8060:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8064:	74 59                	je     80bf <deflateDynamic+0x1ae>
    8066:	e9 6e 07 00 00       	jmp    87d9 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    806b:	83 ec 08             	sub    $0x8,%esp
    806e:	ff 75 c8             	pushl  -0x38(%ebp)
    8071:	8d 45 90             	lea    -0x70(%ebp),%eax
    8074:	50                   	push   %eax
    8075:	e8 17 c5 ff ff       	call   4591 <uivector_resize>
    807a:	83 c4 10             	add    $0x10,%esp
    807d:	85 c0                	test   %eax,%eax
    807f:	75 0c                	jne    808d <deflateDynamic+0x17c>
    8081:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    8088:	e9 4c 07 00 00       	jmp    87d9 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    808d:	8b 45 14             	mov    0x14(%ebp),%eax
    8090:	89 45 e8             	mov    %eax,-0x18(%ebp)
    8093:	eb 22                	jmp    80b7 <deflateDynamic+0x1a6>
    8095:	8b 55 90             	mov    -0x70(%ebp),%edx
    8098:	8b 45 e8             	mov    -0x18(%ebp),%eax
    809b:	2b 45 14             	sub    0x14(%ebp),%eax
    809e:	c1 e0 02             	shl    $0x2,%eax
    80a1:	01 c2                	add    %eax,%edx
    80a3:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    80a6:	8b 45 10             	mov    0x10(%ebp),%eax
    80a9:	01 c8                	add    %ecx,%eax
    80ab:	0f b6 00             	movzbl (%eax),%eax
    80ae:	0f b6 c0             	movzbl %al,%eax
    80b1:	89 02                	mov    %eax,(%edx)
    80b3:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    80b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    80ba:	3b 45 18             	cmp    0x18(%ebp),%eax
    80bd:	7c d6                	jl     8095 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    80bf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    80c6:	eb 60                	jmp    8128 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    80c8:	8b 45 90             	mov    -0x70(%ebp),%eax
    80cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    80ce:	c1 e2 02             	shl    $0x2,%edx
    80d1:	01 d0                	add    %edx,%eax
    80d3:	8b 00                	mov    (%eax),%eax
    80d5:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    80d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    80db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    80e2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    80e5:	01 d0                	add    %edx,%eax
    80e7:	8b 10                	mov    (%eax),%edx
    80e9:	83 c2 01             	add    $0x1,%edx
    80ec:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    80ee:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    80f5:	76 2d                	jbe    8124 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    80f7:	8b 45 90             	mov    -0x70(%ebp),%eax
    80fa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    80fd:	83 c2 02             	add    $0x2,%edx
    8100:	c1 e2 02             	shl    $0x2,%edx
    8103:	01 d0                	add    %edx,%eax
    8105:	8b 00                	mov    (%eax),%eax
    8107:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    810a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    810d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8114:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8117:	01 d0                	add    %edx,%eax
    8119:	8b 10                	mov    (%eax),%edx
    811b:	83 c2 01             	add    $0x1,%edx
    811e:	89 10                	mov    %edx,(%eax)
        i += 3;
    8120:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    8124:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8128:	8b 45 94             	mov    -0x6c(%ebp),%eax
    812b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    812e:	75 98                	jne    80c8 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    8130:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8133:	05 00 04 00 00       	add    $0x400,%eax
    8138:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    813e:	83 ec 0c             	sub    $0xc,%esp
    8141:	6a 0f                	push   $0xf
    8143:	68 1e 01 00 00       	push   $0x11e
    8148:	68 01 01 00 00       	push   $0x101
    814d:	ff 75 d4             	pushl  -0x2c(%ebp)
    8150:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    8156:	50                   	push   %eax
    8157:	e8 e0 e1 ff ff       	call   633c <HuffmanTree_makeFromFrequencies>
    815c:	83 c4 20             	add    $0x20,%esp
    815f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    8162:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8166:	0f 85 66 06 00 00    	jne    87d2 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    816c:	83 ec 0c             	sub    $0xc,%esp
    816f:	6a 0f                	push   $0xf
    8171:	6a 1e                	push   $0x1e
    8173:	6a 02                	push   $0x2
    8175:	ff 75 d0             	pushl  -0x30(%ebp)
    8178:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    817e:	50                   	push   %eax
    817f:	e8 b8 e1 ff ff       	call   633c <HuffmanTree_makeFromFrequencies>
    8184:	83 c4 20             	add    $0x20,%esp
    8187:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    818a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    818e:	0f 85 41 06 00 00    	jne    87d5 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    8194:	8b 45 84             	mov    -0x7c(%ebp),%eax
    8197:	ba 1e 01 00 00       	mov    $0x11e,%edx
    819c:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    81a1:	0f 47 c2             	cmova  %edx,%eax
    81a4:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    81a7:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    81ad:	ba 1e 00 00 00       	mov    $0x1e,%edx
    81b2:	83 f8 1e             	cmp    $0x1e,%eax
    81b5:	0f 47 c2             	cmova  %edx,%eax
    81b8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    81bb:	8b 55 b8             	mov    -0x48(%ebp),%edx
    81be:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    81c1:	01 d0                	add    %edx,%eax
    81c3:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    81c6:	8b 45 b0             	mov    -0x50(%ebp),%eax
    81c9:	c1 e0 02             	shl    $0x2,%eax
    81cc:	83 ec 0c             	sub    $0xc,%esp
    81cf:	50                   	push   %eax
    81d0:	e8 3b c2 ff ff       	call   4410 <lodepng_malloc>
    81d5:	83 c4 10             	add    $0x10,%esp
    81d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    81db:	8b 45 b0             	mov    -0x50(%ebp),%eax
    81de:	c1 e0 02             	shl    $0x2,%eax
    81e1:	83 ec 0c             	sub    $0xc,%esp
    81e4:	50                   	push   %eax
    81e5:	e8 26 c2 ff ff       	call   4410 <lodepng_malloc>
    81ea:	83 c4 10             	add    $0x10,%esp
    81ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    81f0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    81f4:	74 06                	je     81fc <deflateDynamic+0x2eb>
    81f6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    81fa:	75 0c                	jne    8208 <deflateDynamic+0x2f7>
    81fc:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    8203:	e9 d1 05 00 00       	jmp    87d9 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    8208:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    820f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8216:	eb 25                	jmp    823d <deflateDynamic+0x32c>
    8218:	8b 45 e8             	mov    -0x18(%ebp),%eax
    821b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8222:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8225:	01 c2                	add    %eax,%edx
    8227:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    822d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    8230:	c1 e1 02             	shl    $0x2,%ecx
    8233:	01 c8                	add    %ecx,%eax
    8235:	8b 00                	mov    (%eax),%eax
    8237:	89 02                	mov    %eax,(%edx)
    8239:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    823d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8240:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    8243:	75 d3                	jne    8218 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    8245:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    824c:	eb 2a                	jmp    8278 <deflateDynamic+0x367>
    824e:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8251:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8254:	01 d0                	add    %edx,%eax
    8256:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    825d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8260:	01 c2                	add    %eax,%edx
    8262:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    8268:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    826b:	c1 e1 02             	shl    $0x2,%ecx
    826e:	01 c8                	add    %ecx,%eax
    8270:	8b 00                	mov    (%eax),%eax
    8272:	89 02                	mov    %eax,(%edx)
    8274:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8278:	8b 45 e8             	mov    -0x18(%ebp),%eax
    827b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    827e:	75 ce                	jne    824e <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    8280:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8287:	e9 3b 02 00 00       	jmp    84c7 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    828c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    8293:	eb 04                	jmp    8299 <deflateDynamic+0x388>
    8295:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    8299:	8b 55 e8             	mov    -0x18(%ebp),%edx
    829c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    829f:	01 d0                	add    %edx,%eax
    82a1:	8d 50 01             	lea    0x1(%eax),%edx
    82a4:	8b 45 b0             	mov    -0x50(%ebp),%eax
    82a7:	39 c2                	cmp    %eax,%edx
    82a9:	73 2e                	jae    82d9 <deflateDynamic+0x3c8>
    82ab:	8b 55 e8             	mov    -0x18(%ebp),%edx
    82ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
    82b1:	01 d0                	add    %edx,%eax
    82b3:	83 c0 01             	add    $0x1,%eax
    82b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    82bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    82c0:	01 d0                	add    %edx,%eax
    82c2:	8b 10                	mov    (%eax),%edx
    82c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    82c7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    82ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    82d1:	01 c8                	add    %ecx,%eax
    82d3:	8b 00                	mov    (%eax),%eax
    82d5:	39 c2                	cmp    %eax,%edx
    82d7:	74 bc                	je     8295 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    82d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    82dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    82e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    82e6:	01 d0                	add    %edx,%eax
    82e8:	8b 00                	mov    (%eax),%eax
    82ea:	85 c0                	test   %eax,%eax
    82ec:	0f 85 a9 00 00 00    	jne    839b <deflateDynamic+0x48a>
    82f2:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    82f6:	0f 86 9f 00 00 00    	jbe    839b <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    82fc:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    8300:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    8304:	77 3a                	ja     8340 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    8306:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8309:	8d 50 01             	lea    0x1(%eax),%edx
    830c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    830f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8316:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8319:	01 d0                	add    %edx,%eax
    831b:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    8321:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8324:	8d 50 01             	lea    0x1(%eax),%edx
    8327:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    832a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8331:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8334:	01 d0                	add    %edx,%eax
    8336:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8339:	83 ea 03             	sub    $0x3,%edx
    833c:	89 10                	mov    %edx,(%eax)
    833e:	eb 48                	jmp    8388 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    8340:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    8347:	76 07                	jbe    8350 <deflateDynamic+0x43f>
    8349:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    8350:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8353:	8d 50 01             	lea    0x1(%eax),%edx
    8356:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8359:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8360:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8363:	01 d0                	add    %edx,%eax
    8365:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    836b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    836e:	8d 50 01             	lea    0x1(%eax),%edx
    8371:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8374:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    837b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    837e:	01 d0                	add    %edx,%eax
    8380:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8383:	83 ea 0b             	sub    $0xb,%edx
    8386:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    8388:	8b 55 e8             	mov    -0x18(%ebp),%edx
    838b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    838e:	01 d0                	add    %edx,%eax
    8390:	83 e8 01             	sub    $0x1,%eax
    8393:	89 45 e8             	mov    %eax,-0x18(%ebp)
    8396:	e9 28 01 00 00       	jmp    84c3 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    839b:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    839f:	0f 86 f6 00 00 00    	jbe    849b <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    83a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    83a8:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    83ad:	f7 e2                	mul    %edx
    83af:	89 d0                	mov    %edx,%eax
    83b1:	c1 e8 02             	shr    $0x2,%eax
    83b4:	89 45 ac             	mov    %eax,-0x54(%ebp)
    83b7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    83ba:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    83bf:	89 c8                	mov    %ecx,%eax
    83c1:	f7 e2                	mul    %edx
    83c3:	c1 ea 02             	shr    $0x2,%edx
    83c6:	89 d0                	mov    %edx,%eax
    83c8:	01 c0                	add    %eax,%eax
    83ca:	01 d0                	add    %edx,%eax
    83cc:	01 c0                	add    %eax,%eax
    83ce:	29 c1                	sub    %eax,%ecx
    83d0:	89 c8                	mov    %ecx,%eax
    83d2:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    83d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    83d8:	8d 50 01             	lea    0x1(%eax),%edx
    83db:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    83de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    83e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    83e8:	01 c2                	add    %eax,%edx
    83ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    83ed:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    83f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    83f7:	01 c8                	add    %ecx,%eax
    83f9:	8b 00                	mov    (%eax),%eax
    83fb:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    83fd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    8404:	eb 3a                	jmp    8440 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    8406:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8409:	8d 50 01             	lea    0x1(%eax),%edx
    840c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    840f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8416:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8419:	01 d0                	add    %edx,%eax
    841b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    8421:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8424:	8d 50 01             	lea    0x1(%eax),%edx
    8427:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    842a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8431:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8434:	01 d0                	add    %edx,%eax
    8436:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    843c:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    8440:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8443:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    8446:	72 be                	jb     8406 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    8448:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    844c:	76 3a                	jbe    8488 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    844e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8451:	8d 50 01             	lea    0x1(%eax),%edx
    8454:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8457:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    845e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8461:	01 d0                	add    %edx,%eax
    8463:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    8469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    846c:	8d 50 01             	lea    0x1(%eax),%edx
    846f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    8472:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8479:	8b 45 ec             	mov    -0x14(%ebp),%eax
    847c:	01 d0                	add    %edx,%eax
    847e:	8b 55 a8             	mov    -0x58(%ebp),%edx
    8481:	83 ea 03             	sub    $0x3,%edx
    8484:	89 10                	mov    %edx,(%eax)
    8486:	eb 06                	jmp    848e <deflateDynamic+0x57d>
        }
        else j -= rest;
    8488:	8b 45 a8             	mov    -0x58(%ebp),%eax
    848b:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    848e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8491:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8494:	01 d0                	add    %edx,%eax
    8496:	89 45 e8             	mov    %eax,-0x18(%ebp)
    8499:	eb 28                	jmp    84c3 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    849b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    849e:	8d 50 01             	lea    0x1(%eax),%edx
    84a1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    84a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    84ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    84ae:	01 c2                	add    %eax,%edx
    84b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    84b3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    84ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    84bd:	01 c8                	add    %ecx,%eax
    84bf:	8b 00                	mov    (%eax),%eax
    84c1:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    84c3:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    84c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    84ca:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    84cd:	0f 85 b9 fd ff ff    	jne    828c <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    84d3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    84da:	eb 42                	jmp    851e <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    84dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    84df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    84e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    84e9:	01 d0                	add    %edx,%eax
    84eb:	8b 00                	mov    (%eax),%eax
    84ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    84f4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    84f7:	01 d0                	add    %edx,%eax
    84f9:	8b 10                	mov    (%eax),%edx
    84fb:	83 c2 01             	add    $0x1,%edx
    84fe:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    8500:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8503:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    850a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    850d:	01 d0                	add    %edx,%eax
    850f:	8b 00                	mov    (%eax),%eax
    8511:	83 f8 0f             	cmp    $0xf,%eax
    8514:	76 04                	jbe    851a <deflateDynamic+0x609>
    8516:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    851a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    851e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8521:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8524:	75 b6                	jne    84dc <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    8526:	83 ec 0c             	sub    $0xc,%esp
    8529:	6a 07                	push   $0x7
    852b:	6a 13                	push   $0x13
    852d:	6a 13                	push   $0x13
    852f:	ff 75 cc             	pushl  -0x34(%ebp)
    8532:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    8538:	50                   	push   %eax
    8539:	e8 fe dd ff ff       	call   633c <HuffmanTree_makeFromFrequencies>
    853e:	83 c4 20             	add    $0x20,%esp
    8541:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    8544:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8548:	0f 85 8a 02 00 00    	jne    87d8 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    854e:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    8555:	eb 04                	jmp    855b <deflateDynamic+0x64a>
      numcodes_cl--;
    8557:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    855b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    855e:	83 f8 04             	cmp    $0x4,%eax
    8561:	76 1e                	jbe    8581 <deflateDynamic+0x670>
    8563:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    8569:	8b 55 e0             	mov    -0x20(%ebp),%edx
    856c:	83 ea 01             	sub    $0x1,%edx
    856f:	8b 14 95 00 b0 01 00 	mov    0x1b000(,%edx,4),%edx
    8576:	c1 e2 02             	shl    $0x2,%edx
    8579:	01 d0                	add    %edx,%eax
    857b:	8b 00                	mov    (%eax),%eax
    857d:	85 c0                	test   %eax,%eax
    857f:	74 d6                	je     8557 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    8581:	83 ec 04             	sub    $0x4,%esp
    8584:	6a 01                	push   $0x1
    8586:	ff 75 c4             	pushl  -0x3c(%ebp)
    8589:	ff 75 08             	pushl  0x8(%ebp)
    858c:	e8 67 c3 ff ff       	call   48f8 <writeBits>
    8591:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    8594:	83 ec 04             	sub    $0x4,%esp
    8597:	6a 01                	push   $0x1
    8599:	6a 00                	push   $0x0
    859b:	ff 75 08             	pushl  0x8(%ebp)
    859e:	e8 55 c3 ff ff       	call   48f8 <writeBits>
    85a3:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    85a6:	83 ec 04             	sub    $0x4,%esp
    85a9:	6a 01                	push   $0x1
    85ab:	6a 01                	push   $0x1
    85ad:	ff 75 08             	pushl  0x8(%ebp)
    85b0:	e8 43 c3 ff ff       	call   48f8 <writeBits>
    85b5:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    85b8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    85bb:	2d 01 01 00 00       	sub    $0x101,%eax
    85c0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    85c3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    85c6:	83 e8 01             	sub    $0x1,%eax
    85c9:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    85cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    85cf:	83 e8 04             	sub    $0x4,%eax
    85d2:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    85d5:	83 ec 04             	sub    $0x4,%esp
    85d8:	6a 05                	push   $0x5
    85da:	ff 75 a4             	pushl  -0x5c(%ebp)
    85dd:	ff 75 08             	pushl  0x8(%ebp)
    85e0:	e8 13 c3 ff ff       	call   48f8 <writeBits>
    85e5:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    85e8:	83 ec 04             	sub    $0x4,%esp
    85eb:	6a 05                	push   $0x5
    85ed:	ff 75 a0             	pushl  -0x60(%ebp)
    85f0:	ff 75 08             	pushl  0x8(%ebp)
    85f3:	e8 00 c3 ff ff       	call   48f8 <writeBits>
    85f8:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    85fb:	83 ec 04             	sub    $0x4,%esp
    85fe:	6a 04                	push   $0x4
    8600:	ff 75 9c             	pushl  -0x64(%ebp)
    8603:	ff 75 08             	pushl  0x8(%ebp)
    8606:	e8 ed c2 ff ff       	call   48f8 <writeBits>
    860b:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    860e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8615:	eb 2c                	jmp    8643 <deflateDynamic+0x732>
    8617:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    861d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8620:	8b 04 85 00 b0 01 00 	mov    0x1b000(,%eax,4),%eax
    8627:	c1 e0 02             	shl    $0x2,%eax
    862a:	01 d0                	add    %edx,%eax
    862c:	8b 00                	mov    (%eax),%eax
    862e:	83 ec 04             	sub    $0x4,%esp
    8631:	6a 03                	push   $0x3
    8633:	50                   	push   %eax
    8634:	ff 75 08             	pushl  0x8(%ebp)
    8637:	e8 bc c2 ff ff       	call   48f8 <writeBits>
    863c:	83 c4 10             	add    $0x10,%esp
    863f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8643:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8646:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    8649:	75 cc                	jne    8617 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    864b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    8652:	e9 0a 01 00 00       	jmp    8761 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    8657:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    865d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8660:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8667:	8b 55 ec             	mov    -0x14(%ebp),%edx
    866a:	01 ca                	add    %ecx,%edx
    866c:	8b 12                	mov    (%edx),%edx
    866e:	c1 e2 02             	shl    $0x2,%edx
    8671:	01 d0                	add    %edx,%eax
    8673:	8b 00                	mov    (%eax),%eax
    8675:	89 c3                	mov    %eax,%ebx
    8677:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    867d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8680:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8687:	8b 55 ec             	mov    -0x14(%ebp),%edx
    868a:	01 ca                	add    %ecx,%edx
    868c:	8b 12                	mov    (%edx),%edx
    868e:	c1 e2 02             	shl    $0x2,%edx
    8691:	01 d0                	add    %edx,%eax
    8693:	8b 00                	mov    (%eax),%eax
    8695:	83 ec 04             	sub    $0x4,%esp
    8698:	53                   	push   %ebx
    8699:	50                   	push   %eax
    869a:	ff 75 08             	pushl  0x8(%ebp)
    869d:	e8 ea c3 ff ff       	call   4a8c <writeBitsReversed>
    86a2:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    86a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    86a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    86af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    86b2:	01 d0                	add    %edx,%eax
    86b4:	8b 00                	mov    (%eax),%eax
    86b6:	83 f8 10             	cmp    $0x10,%eax
    86b9:	75 28                	jne    86e3 <deflateDynamic+0x7d2>
    86bb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    86bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    86c2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    86c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    86cc:	01 d0                	add    %edx,%eax
    86ce:	8b 00                	mov    (%eax),%eax
    86d0:	83 ec 04             	sub    $0x4,%esp
    86d3:	6a 02                	push   $0x2
    86d5:	50                   	push   %eax
    86d6:	ff 75 08             	pushl  0x8(%ebp)
    86d9:	e8 1a c2 ff ff       	call   48f8 <writeBits>
    86de:	83 c4 10             	add    $0x10,%esp
    86e1:	eb 7a                	jmp    875d <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    86e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    86e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    86ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    86f0:	01 d0                	add    %edx,%eax
    86f2:	8b 00                	mov    (%eax),%eax
    86f4:	83 f8 11             	cmp    $0x11,%eax
    86f7:	75 28                	jne    8721 <deflateDynamic+0x810>
    86f9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    86fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8700:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8707:	8b 45 ec             	mov    -0x14(%ebp),%eax
    870a:	01 d0                	add    %edx,%eax
    870c:	8b 00                	mov    (%eax),%eax
    870e:	83 ec 04             	sub    $0x4,%esp
    8711:	6a 03                	push   $0x3
    8713:	50                   	push   %eax
    8714:	ff 75 08             	pushl  0x8(%ebp)
    8717:	e8 dc c1 ff ff       	call   48f8 <writeBits>
    871c:	83 c4 10             	add    $0x10,%esp
    871f:	eb 3c                	jmp    875d <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    8721:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8724:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    872b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    872e:	01 d0                	add    %edx,%eax
    8730:	8b 00                	mov    (%eax),%eax
    8732:	83 f8 12             	cmp    $0x12,%eax
    8735:	75 26                	jne    875d <deflateDynamic+0x84c>
    8737:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    873b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    873e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8745:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8748:	01 d0                	add    %edx,%eax
    874a:	8b 00                	mov    (%eax),%eax
    874c:	83 ec 04             	sub    $0x4,%esp
    874f:	6a 07                	push   $0x7
    8751:	50                   	push   %eax
    8752:	ff 75 08             	pushl  0x8(%ebp)
    8755:	e8 9e c1 ff ff       	call   48f8 <writeBits>
    875a:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    875d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8761:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8764:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8767:	0f 85 ea fe ff ff    	jne    8657 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    876d:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    8773:	50                   	push   %eax
    8774:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    877a:	50                   	push   %eax
    877b:	8d 45 90             	lea    -0x70(%ebp),%eax
    877e:	50                   	push   %eax
    877f:	ff 75 08             	pushl  0x8(%ebp)
    8782:	e8 4f f6 ff ff       	call   7dd6 <writeLZ77data>
    8787:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    878a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    8790:	05 00 04 00 00       	add    $0x400,%eax
    8795:	8b 00                	mov    (%eax),%eax
    8797:	85 c0                	test   %eax,%eax
    8799:	75 09                	jne    87a4 <deflateDynamic+0x893>
    879b:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    87a2:	eb 35                	jmp    87d9 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    87a4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    87aa:	05 00 04 00 00       	add    $0x400,%eax
    87af:	8b 00                	mov    (%eax),%eax
    87b1:	89 c2                	mov    %eax,%edx
    87b3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    87b9:	05 00 04 00 00       	add    $0x400,%eax
    87be:	8b 00                	mov    (%eax),%eax
    87c0:	83 ec 04             	sub    $0x4,%esp
    87c3:	52                   	push   %edx
    87c4:	50                   	push   %eax
    87c5:	ff 75 08             	pushl  0x8(%ebp)
    87c8:	e8 bf c2 ff ff       	call   4a8c <writeBitsReversed>
    87cd:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    87d0:	eb 07                	jmp    87d9 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    87d2:	90                   	nop
    87d3:	eb 04                	jmp    87d9 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    87d5:	90                   	nop
    87d6:	eb 01                	jmp    87d9 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    87d8:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    87d9:	83 ec 0c             	sub    $0xc,%esp
    87dc:	8d 45 90             	lea    -0x70(%ebp),%eax
    87df:	50                   	push   %eax
    87e0:	e8 73 bd ff ff       	call   4558 <uivector_cleanup>
    87e5:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    87e8:	83 ec 0c             	sub    $0xc,%esp
    87eb:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    87f1:	50                   	push   %eax
    87f2:	e8 3a cb ff ff       	call   5331 <HuffmanTree_cleanup>
    87f7:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    87fa:	83 ec 0c             	sub    $0xc,%esp
    87fd:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    8803:	50                   	push   %eax
    8804:	e8 28 cb ff ff       	call   5331 <HuffmanTree_cleanup>
    8809:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    880c:	83 ec 0c             	sub    $0xc,%esp
    880f:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    8815:	50                   	push   %eax
    8816:	e8 16 cb ff ff       	call   5331 <HuffmanTree_cleanup>
    881b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    881e:	83 ec 0c             	sub    $0xc,%esp
    8821:	ff 75 d4             	pushl  -0x2c(%ebp)
    8824:	e8 08 bc ff ff       	call   4431 <lodepng_free>
    8829:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    882c:	83 ec 0c             	sub    $0xc,%esp
    882f:	ff 75 d0             	pushl  -0x30(%ebp)
    8832:	e8 fa bb ff ff       	call   4431 <lodepng_free>
    8837:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    883a:	83 ec 0c             	sub    $0xc,%esp
    883d:	ff 75 cc             	pushl  -0x34(%ebp)
    8840:	e8 ec bb ff ff       	call   4431 <lodepng_free>
    8845:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    8848:	83 ec 0c             	sub    $0xc,%esp
    884b:	ff 75 f0             	pushl  -0x10(%ebp)
    884e:	e8 de bb ff ff       	call   4431 <lodepng_free>
    8853:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    8856:	83 ec 0c             	sub    $0xc,%esp
    8859:	ff 75 ec             	pushl  -0x14(%ebp)
    885c:	e8 d0 bb ff ff       	call   4431 <lodepng_free>
    8861:	83 c4 10             	add    $0x10,%esp

  return error;
    8864:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8867:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    886a:	c9                   	leave  
    886b:	c3                   	ret    

0000886c <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    886c:	55                   	push   %ebp
    886d:	89 e5                	mov    %esp,%ebp
    886f:	53                   	push   %ebx
    8870:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    8873:	8b 45 20             	mov    0x20(%ebp),%eax
    8876:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    8879:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    8880:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8883:	50                   	push   %eax
    8884:	e8 7b ca ff ff       	call   5304 <HuffmanTree_init>
    8889:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    888c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    888f:	50                   	push   %eax
    8890:	e8 6f ca ff ff       	call   5304 <HuffmanTree_init>
    8895:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    8898:	83 ec 0c             	sub    $0xc,%esp
    889b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    889e:	50                   	push   %eax
    889f:	e8 41 db ff ff       	call   63e5 <generateFixedLitLenTree>
    88a4:	83 c4 10             	add    $0x10,%esp
    88a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    88aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    88ae:	75 12                	jne    88c2 <deflateFixed+0x56>
    88b0:	83 ec 0c             	sub    $0xc,%esp
    88b3:	8d 45 bc             	lea    -0x44(%ebp),%eax
    88b6:	50                   	push   %eax
    88b7:	e8 30 dc ff ff       	call   64ec <generateFixedDistanceTree>
    88bc:	83 c4 10             	add    $0x10,%esp
    88bf:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    88c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    88c6:	0f 85 3a 01 00 00    	jne    8a06 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    88cc:	83 ec 04             	sub    $0x4,%esp
    88cf:	6a 01                	push   $0x1
    88d1:	ff 75 ec             	pushl  -0x14(%ebp)
    88d4:	ff 75 08             	pushl  0x8(%ebp)
    88d7:	e8 1c c0 ff ff       	call   48f8 <writeBits>
    88dc:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    88df:	83 ec 04             	sub    $0x4,%esp
    88e2:	6a 01                	push   $0x1
    88e4:	6a 01                	push   $0x1
    88e6:	ff 75 08             	pushl  0x8(%ebp)
    88e9:	e8 0a c0 ff ff       	call   48f8 <writeBits>
    88ee:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    88f1:	83 ec 04             	sub    $0x4,%esp
    88f4:	6a 01                	push   $0x1
    88f6:	6a 00                	push   $0x0
    88f8:	ff 75 08             	pushl  0x8(%ebp)
    88fb:	e8 f8 bf ff ff       	call   48f8 <writeBits>
    8900:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    8903:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8906:	8b 40 04             	mov    0x4(%eax),%eax
    8909:	85 c0                	test   %eax,%eax
    890b:	74 77                	je     8984 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    890d:	83 ec 0c             	sub    $0xc,%esp
    8910:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8913:	50                   	push   %eax
    8914:	e8 e8 bc ff ff       	call   4601 <uivector_init>
    8919:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    891c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    891f:	8b 58 14             	mov    0x14(%eax),%ebx
    8922:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8925:	8b 48 10             	mov    0x10(%eax),%ecx
    8928:	8b 45 1c             	mov    0x1c(%ebp),%eax
    892b:	8b 50 0c             	mov    0xc(%eax),%edx
    892e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8931:	8b 40 08             	mov    0x8(%eax),%eax
    8934:	83 ec 0c             	sub    $0xc,%esp
    8937:	53                   	push   %ebx
    8938:	51                   	push   %ecx
    8939:	52                   	push   %edx
    893a:	50                   	push   %eax
    893b:	ff 75 18             	pushl  0x18(%ebp)
    893e:	ff 75 14             	pushl  0x14(%ebp)
    8941:	ff 75 10             	pushl  0x10(%ebp)
    8944:	ff 75 0c             	pushl  0xc(%ebp)
    8947:	8d 45 b0             	lea    -0x50(%ebp),%eax
    894a:	50                   	push   %eax
    894b:	e8 c7 ed ff ff       	call   7717 <encodeLZ77>
    8950:	83 c4 30             	add    $0x30,%esp
    8953:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    8956:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    895a:	75 17                	jne    8973 <deflateFixed+0x107>
    895c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    895f:	50                   	push   %eax
    8960:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8963:	50                   	push   %eax
    8964:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8967:	50                   	push   %eax
    8968:	ff 75 08             	pushl  0x8(%ebp)
    896b:	e8 66 f4 ff ff       	call   7dd6 <writeLZ77data>
    8970:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    8973:	83 ec 0c             	sub    $0xc,%esp
    8976:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8979:	50                   	push   %eax
    897a:	e8 d9 bb ff ff       	call   4558 <uivector_cleanup>
    897f:	83 c4 10             	add    $0x10,%esp
    8982:	eb 56                	jmp    89da <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    8984:	8b 45 14             	mov    0x14(%ebp),%eax
    8987:	89 45 f0             	mov    %eax,-0x10(%ebp)
    898a:	eb 46                	jmp    89d2 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    898c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    898f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    8992:	8b 55 10             	mov    0x10(%ebp),%edx
    8995:	01 ca                	add    %ecx,%edx
    8997:	0f b6 12             	movzbl (%edx),%edx
    899a:	0f b6 d2             	movzbl %dl,%edx
    899d:	c1 e2 02             	shl    $0x2,%edx
    89a0:	01 d0                	add    %edx,%eax
    89a2:	8b 00                	mov    (%eax),%eax
    89a4:	89 c3                	mov    %eax,%ebx
    89a6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    89a9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    89ac:	8b 55 10             	mov    0x10(%ebp),%edx
    89af:	01 ca                	add    %ecx,%edx
    89b1:	0f b6 12             	movzbl (%edx),%edx
    89b4:	0f b6 d2             	movzbl %dl,%edx
    89b7:	c1 e2 02             	shl    $0x2,%edx
    89ba:	01 d0                	add    %edx,%eax
    89bc:	8b 00                	mov    (%eax),%eax
    89be:	83 ec 04             	sub    $0x4,%esp
    89c1:	53                   	push   %ebx
    89c2:	50                   	push   %eax
    89c3:	ff 75 08             	pushl  0x8(%ebp)
    89c6:	e8 c1 c0 ff ff       	call   4a8c <writeBitsReversed>
    89cb:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    89ce:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    89d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    89d5:	3b 45 18             	cmp    0x18(%ebp),%eax
    89d8:	7c b2                	jl     898c <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    89da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    89de:	75 26                	jne    8a06 <deflateFixed+0x19a>
    89e0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    89e3:	05 00 04 00 00       	add    $0x400,%eax
    89e8:	8b 00                	mov    (%eax),%eax
    89ea:	89 c2                	mov    %eax,%edx
    89ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    89ef:	05 00 04 00 00       	add    $0x400,%eax
    89f4:	8b 00                	mov    (%eax),%eax
    89f6:	83 ec 04             	sub    $0x4,%esp
    89f9:	52                   	push   %edx
    89fa:	50                   	push   %eax
    89fb:	ff 75 08             	pushl  0x8(%ebp)
    89fe:	e8 89 c0 ff ff       	call   4a8c <writeBitsReversed>
    8a03:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    8a06:	83 ec 0c             	sub    $0xc,%esp
    8a09:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8a0c:	50                   	push   %eax
    8a0d:	e8 1f c9 ff ff       	call   5331 <HuffmanTree_cleanup>
    8a12:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    8a15:	83 ec 0c             	sub    $0xc,%esp
    8a18:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8a1b:	50                   	push   %eax
    8a1c:	e8 10 c9 ff ff       	call   5331 <HuffmanTree_cleanup>
    8a21:	83 c4 10             	add    $0x10,%esp

  return error;
    8a24:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8a27:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8a2a:	c9                   	leave  
    8a2b:	c3                   	ret    

00008a2c <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    8a2c:	55                   	push   %ebp
    8a2d:	89 e5                	mov    %esp,%ebp
    8a2f:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    8a32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    8a39:	ff 75 08             	pushl  0x8(%ebp)
    8a3c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8a3f:	50                   	push   %eax
    8a40:	e8 9e be ff ff       	call   48e3 <LodePNGBitWriter_init>
    8a45:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    8a48:	8b 45 14             	mov    0x14(%ebp),%eax
    8a4b:	8b 00                	mov    (%eax),%eax
    8a4d:	83 f8 02             	cmp    $0x2,%eax
    8a50:	76 0a                	jbe    8a5c <lodepng_deflatev+0x30>
    8a52:	b8 3d 00 00 00       	mov    $0x3d,%eax
    8a57:	e9 68 01 00 00       	jmp    8bc4 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    8a5c:	8b 45 14             	mov    0x14(%ebp),%eax
    8a5f:	8b 00                	mov    (%eax),%eax
    8a61:	85 c0                	test   %eax,%eax
    8a63:	75 16                	jne    8a7b <lodepng_deflatev+0x4f>
    8a65:	ff 75 10             	pushl  0x10(%ebp)
    8a68:	ff 75 0c             	pushl  0xc(%ebp)
    8a6b:	ff 75 08             	pushl  0x8(%ebp)
    8a6e:	e8 01 f2 ff ff       	call   7c74 <deflateNoCompression>
    8a73:	83 c4 0c             	add    $0xc,%esp
    8a76:	e9 49 01 00 00       	jmp    8bc4 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    8a7b:	8b 45 14             	mov    0x14(%ebp),%eax
    8a7e:	8b 00                	mov    (%eax),%eax
    8a80:	83 f8 01             	cmp    $0x1,%eax
    8a83:	75 08                	jne    8a8d <lodepng_deflatev+0x61>
    8a85:	8b 45 10             	mov    0x10(%ebp),%eax
    8a88:	89 45 ec             	mov    %eax,-0x14(%ebp)
    8a8b:	eb 2c                	jmp    8ab9 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    8a8d:	8b 45 10             	mov    0x10(%ebp),%eax
    8a90:	c1 e8 03             	shr    $0x3,%eax
    8a93:	83 c0 08             	add    $0x8,%eax
    8a96:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    8a99:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    8aa0:	7f 07                	jg     8aa9 <lodepng_deflatev+0x7d>
    8aa2:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    8aa9:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    8ab0:	7e 07                	jle    8ab9 <lodepng_deflatev+0x8d>
    8ab2:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    8ab9:	8b 55 10             	mov    0x10(%ebp),%edx
    8abc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8abf:	01 d0                	add    %edx,%eax
    8ac1:	83 e8 01             	sub    $0x1,%eax
    8ac4:	99                   	cltd   
    8ac5:	f7 7d ec             	idivl  -0x14(%ebp)
    8ac8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    8acb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    8acf:	75 07                	jne    8ad8 <lodepng_deflatev+0xac>
    8ad1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    8ad8:	8b 45 14             	mov    0x14(%ebp),%eax
    8adb:	8b 40 08             	mov    0x8(%eax),%eax
    8ade:	83 ec 08             	sub    $0x8,%esp
    8ae1:	50                   	push   %eax
    8ae2:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8ae5:	50                   	push   %eax
    8ae6:	e8 1c e8 ff ff       	call   7307 <hash_init>
    8aeb:	83 c4 10             	add    $0x10,%esp
    8aee:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    8af1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8af5:	0f 85 b7 00 00 00    	jne    8bb2 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    8afb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    8b02:	e9 99 00 00 00       	jmp    8ba0 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    8b07:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8b0a:	83 e8 01             	sub    $0x1,%eax
    8b0d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8b10:	0f 94 c0             	sete   %al
    8b13:	0f b6 c0             	movzbl %al,%eax
    8b16:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    8b19:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8b1c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    8b20:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    8b23:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8b26:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8b29:	01 d0                	add    %edx,%eax
    8b2b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    8b2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8b31:	3b 45 10             	cmp    0x10(%ebp),%eax
    8b34:	7e 06                	jle    8b3c <lodepng_deflatev+0x110>
    8b36:	8b 45 10             	mov    0x10(%ebp),%eax
    8b39:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    8b3c:	8b 45 14             	mov    0x14(%ebp),%eax
    8b3f:	8b 00                	mov    (%eax),%eax
    8b41:	83 f8 01             	cmp    $0x1,%eax
    8b44:	75 27                	jne    8b6d <lodepng_deflatev+0x141>
    8b46:	83 ec 04             	sub    $0x4,%esp
    8b49:	ff 75 e0             	pushl  -0x20(%ebp)
    8b4c:	ff 75 14             	pushl  0x14(%ebp)
    8b4f:	ff 75 e4             	pushl  -0x1c(%ebp)
    8b52:	ff 75 dc             	pushl  -0x24(%ebp)
    8b55:	ff 75 0c             	pushl  0xc(%ebp)
    8b58:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8b5b:	50                   	push   %eax
    8b5c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8b5f:	50                   	push   %eax
    8b60:	e8 07 fd ff ff       	call   886c <deflateFixed>
    8b65:	83 c4 20             	add    $0x20,%esp
    8b68:	89 45 f4             	mov    %eax,-0xc(%ebp)
    8b6b:	eb 2f                	jmp    8b9c <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    8b6d:	8b 45 14             	mov    0x14(%ebp),%eax
    8b70:	8b 00                	mov    (%eax),%eax
    8b72:	83 f8 02             	cmp    $0x2,%eax
    8b75:	75 25                	jne    8b9c <lodepng_deflatev+0x170>
    8b77:	83 ec 04             	sub    $0x4,%esp
    8b7a:	ff 75 e0             	pushl  -0x20(%ebp)
    8b7d:	ff 75 14             	pushl  0x14(%ebp)
    8b80:	ff 75 e4             	pushl  -0x1c(%ebp)
    8b83:	ff 75 dc             	pushl  -0x24(%ebp)
    8b86:	ff 75 0c             	pushl  0xc(%ebp)
    8b89:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8b8c:	50                   	push   %eax
    8b8d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8b90:	50                   	push   %eax
    8b91:	e8 7b f3 ff ff       	call   7f11 <deflateDynamic>
    8b96:	83 c4 20             	add    $0x20,%esp
    8b99:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    8b9c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8ba0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8ba3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    8ba6:	74 0a                	je     8bb2 <lodepng_deflatev+0x186>
    8ba8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8bac:	0f 84 55 ff ff ff    	je     8b07 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    8bb2:	83 ec 0c             	sub    $0xc,%esp
    8bb5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8bb8:	50                   	push   %eax
    8bb9:	e8 08 e9 ff ff       	call   74c6 <hash_cleanup>
    8bbe:	83 c4 10             	add    $0x10,%esp

  return error;
    8bc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8bc4:	c9                   	leave  
    8bc5:	c3                   	ret    

00008bc6 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    8bc6:	55                   	push   %ebp
    8bc7:	89 e5                	mov    %esp,%ebp
    8bc9:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8bcc:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bcf:	8b 08                	mov    (%eax),%ecx
    8bd1:	8b 45 08             	mov    0x8(%ebp),%eax
    8bd4:	8b 10                	mov    (%eax),%edx
    8bd6:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8bd9:	51                   	push   %ecx
    8bda:	52                   	push   %edx
    8bdb:	50                   	push   %eax
    8bdc:	e8 f0 ba ff ff       	call   46d1 <ucvector_init>
    8be1:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    8be4:	ff 75 18             	pushl  0x18(%ebp)
    8be7:	ff 75 14             	pushl  0x14(%ebp)
    8bea:	ff 75 10             	pushl  0x10(%ebp)
    8bed:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8bf0:	50                   	push   %eax
    8bf1:	e8 36 fe ff ff       	call   8a2c <lodepng_deflatev>
    8bf6:	83 c4 10             	add    $0x10,%esp
    8bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    8bfc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8bff:	8b 45 08             	mov    0x8(%ebp),%eax
    8c02:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8c04:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8c07:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c0a:	89 10                	mov    %edx,(%eax)
  return error;
    8c0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8c0f:	c9                   	leave  
    8c10:	c3                   	ret    

00008c11 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    8c11:	55                   	push   %ebp
    8c12:	89 e5                	mov    %esp,%ebp
    8c14:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    8c17:	8b 45 18             	mov    0x18(%ebp),%eax
    8c1a:	8b 40 1c             	mov    0x1c(%eax),%eax
    8c1d:	85 c0                	test   %eax,%eax
    8c1f:	74 34                	je     8c55 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    8c21:	8b 45 18             	mov    0x18(%ebp),%eax
    8c24:	8b 40 1c             	mov    0x1c(%eax),%eax
    8c27:	83 ec 0c             	sub    $0xc,%esp
    8c2a:	ff 75 18             	pushl  0x18(%ebp)
    8c2d:	ff 75 14             	pushl  0x14(%ebp)
    8c30:	ff 75 10             	pushl  0x10(%ebp)
    8c33:	ff 75 0c             	pushl  0xc(%ebp)
    8c36:	ff 75 08             	pushl  0x8(%ebp)
    8c39:	ff d0                	call   *%eax
    8c3b:	83 c4 20             	add    $0x20,%esp
    8c3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8c41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8c45:	74 07                	je     8c4e <deflate+0x3d>
    8c47:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8c4c:	eb 21                	jmp    8c6f <deflate+0x5e>
    8c4e:	b8 00 00 00 00       	mov    $0x0,%eax
    8c53:	eb 1a                	jmp    8c6f <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    8c55:	83 ec 0c             	sub    $0xc,%esp
    8c58:	ff 75 18             	pushl  0x18(%ebp)
    8c5b:	ff 75 14             	pushl  0x14(%ebp)
    8c5e:	ff 75 10             	pushl  0x10(%ebp)
    8c61:	ff 75 0c             	pushl  0xc(%ebp)
    8c64:	ff 75 08             	pushl  0x8(%ebp)
    8c67:	e8 5a ff ff ff       	call   8bc6 <lodepng_deflate>
    8c6c:	83 c4 20             	add    $0x20,%esp
  }
}
    8c6f:	c9                   	leave  
    8c70:	c3                   	ret    

00008c71 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    8c71:	55                   	push   %ebp
    8c72:	89 e5                	mov    %esp,%ebp
    8c74:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    8c77:	8b 45 08             	mov    0x8(%ebp),%eax
    8c7a:	0f b7 c0             	movzwl %ax,%eax
    8c7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    8c80:	8b 45 08             	mov    0x8(%ebp),%eax
    8c83:	c1 e8 10             	shr    $0x10,%eax
    8c86:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    8c89:	e9 82 00 00 00       	jmp    8d10 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    8c8e:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    8c93:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    8c9a:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    8c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    8ca1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8ca4:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    8ca7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8cae:	eb 1c                	jmp    8ccc <update_adler32+0x5b>
      s1 += (*data++);
    8cb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cb3:	8d 50 01             	lea    0x1(%eax),%edx
    8cb6:	89 55 0c             	mov    %edx,0xc(%ebp)
    8cb9:	0f b6 00             	movzbl (%eax),%eax
    8cbc:	0f b6 c0             	movzbl %al,%eax
    8cbf:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    8cc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8cc5:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    8cc8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8ccc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8ccf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8cd2:	75 dc                	jne    8cb0 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    8cd4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    8cd7:	ba 71 80 07 80       	mov    $0x80078071,%edx
    8cdc:	89 c8                	mov    %ecx,%eax
    8cde:	f7 e2                	mul    %edx
    8ce0:	89 d0                	mov    %edx,%eax
    8ce2:	c1 e8 0f             	shr    $0xf,%eax
    8ce5:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    8ceb:	29 c1                	sub    %eax,%ecx
    8ced:	89 c8                	mov    %ecx,%eax
    8cef:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    8cf2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    8cf5:	ba 71 80 07 80       	mov    $0x80078071,%edx
    8cfa:	89 c8                	mov    %ecx,%eax
    8cfc:	f7 e2                	mul    %edx
    8cfe:	89 d0                	mov    %edx,%eax
    8d00:	c1 e8 0f             	shr    $0xf,%eax
    8d03:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    8d09:	29 c1                	sub    %eax,%ecx
    8d0b:	89 c8                	mov    %ecx,%eax
    8d0d:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    8d10:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8d14:	0f 85 74 ff ff ff    	jne    8c8e <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    8d1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8d1d:	c1 e0 10             	shl    $0x10,%eax
    8d20:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    8d23:	c9                   	leave  
    8d24:	c3                   	ret    

00008d25 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    8d25:	55                   	push   %ebp
    8d26:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    8d28:	ff 75 0c             	pushl  0xc(%ebp)
    8d2b:	ff 75 08             	pushl  0x8(%ebp)
    8d2e:	6a 01                	push   $0x1
    8d30:	e8 3c ff ff ff       	call   8c71 <update_adler32>
    8d35:	83 c4 0c             	add    $0xc,%esp
}
    8d38:	c9                   	leave  
    8d39:	c3                   	ret    

00008d3a <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    8d3a:	55                   	push   %ebp
    8d3b:	89 e5                	mov    %esp,%ebp
    8d3d:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    8d40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    8d47:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    8d4b:	7f 0a                	jg     8d57 <lodepng_zlib_decompressv+0x1d>
    8d4d:	b8 35 00 00 00       	mov    $0x35,%eax
    8d52:	e9 27 01 00 00       	jmp    8e7e <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    8d57:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d5a:	0f b6 00             	movzbl (%eax),%eax
    8d5d:	0f b6 c0             	movzbl %al,%eax
    8d60:	c1 e0 08             	shl    $0x8,%eax
    8d63:	89 c2                	mov    %eax,%edx
    8d65:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d68:	83 c0 01             	add    $0x1,%eax
    8d6b:	0f b6 00             	movzbl (%eax),%eax
    8d6e:	0f b6 c0             	movzbl %al,%eax
    8d71:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    8d74:	ba 43 08 21 84       	mov    $0x84210843,%edx
    8d79:	89 c8                	mov    %ecx,%eax
    8d7b:	f7 ea                	imul   %edx
    8d7d:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    8d80:	c1 f8 04             	sar    $0x4,%eax
    8d83:	89 c2                	mov    %eax,%edx
    8d85:	89 c8                	mov    %ecx,%eax
    8d87:	c1 f8 1f             	sar    $0x1f,%eax
    8d8a:	29 c2                	sub    %eax,%edx
    8d8c:	89 d0                	mov    %edx,%eax
    8d8e:	89 c2                	mov    %eax,%edx
    8d90:	c1 e2 05             	shl    $0x5,%edx
    8d93:	29 c2                	sub    %eax,%edx
    8d95:	89 c8                	mov    %ecx,%eax
    8d97:	29 d0                	sub    %edx,%eax
    8d99:	85 c0                	test   %eax,%eax
    8d9b:	74 0a                	je     8da7 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    8d9d:	b8 18 00 00 00       	mov    $0x18,%eax
    8da2:	e9 d7 00 00 00       	jmp    8e7e <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    8da7:	8b 45 0c             	mov    0xc(%ebp),%eax
    8daa:	0f b6 00             	movzbl (%eax),%eax
    8dad:	0f b6 c0             	movzbl %al,%eax
    8db0:	83 e0 0f             	and    $0xf,%eax
    8db3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    8db6:	8b 45 0c             	mov    0xc(%ebp),%eax
    8db9:	0f b6 00             	movzbl (%eax),%eax
    8dbc:	c0 e8 04             	shr    $0x4,%al
    8dbf:	0f b6 c0             	movzbl %al,%eax
    8dc2:	83 e0 0f             	and    $0xf,%eax
    8dc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    8dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    8dcb:	83 c0 01             	add    $0x1,%eax
    8dce:	0f b6 00             	movzbl (%eax),%eax
    8dd1:	c0 e8 05             	shr    $0x5,%al
    8dd4:	0f b6 c0             	movzbl %al,%eax
    8dd7:	83 e0 01             	and    $0x1,%eax
    8dda:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    8ddd:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    8de1:	75 06                	jne    8de9 <lodepng_zlib_decompressv+0xaf>
    8de3:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    8de7:	76 0a                	jbe    8df3 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    8de9:	b8 19 00 00 00       	mov    $0x19,%eax
    8dee:	e9 8b 00 00 00       	jmp    8e7e <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    8df3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    8df7:	74 07                	je     8e00 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    8df9:	b8 1a 00 00 00       	mov    $0x1a,%eax
    8dfe:	eb 7e                	jmp    8e7e <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    8e00:	8b 45 10             	mov    0x10(%ebp),%eax
    8e03:	8d 50 fe             	lea    -0x2(%eax),%edx
    8e06:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e09:	83 c0 02             	add    $0x2,%eax
    8e0c:	ff 75 14             	pushl  0x14(%ebp)
    8e0f:	52                   	push   %edx
    8e10:	50                   	push   %eax
    8e11:	ff 75 08             	pushl  0x8(%ebp)
    8e14:	e8 09 e3 ff ff       	call   7122 <inflatev>
    8e19:	83 c4 10             	add    $0x10,%esp
    8e1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    8e1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8e23:	74 05                	je     8e2a <lodepng_zlib_decompressv+0xf0>
    8e25:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8e28:	eb 54                	jmp    8e7e <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    8e2a:	8b 45 14             	mov    0x14(%ebp),%eax
    8e2d:	8b 00                	mov    (%eax),%eax
    8e2f:	85 c0                	test   %eax,%eax
    8e31:	75 46                	jne    8e79 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    8e33:	8b 45 10             	mov    0x10(%ebp),%eax
    8e36:	8d 50 fc             	lea    -0x4(%eax),%edx
    8e39:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e3c:	01 d0                	add    %edx,%eax
    8e3e:	83 ec 0c             	sub    $0xc,%esp
    8e41:	50                   	push   %eax
    8e42:	e8 47 b9 ff ff       	call   478e <lodepng_read32bitInt>
    8e47:	83 c4 10             	add    $0x10,%esp
    8e4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    8e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    8e50:	8b 40 04             	mov    0x4(%eax),%eax
    8e53:	89 c2                	mov    %eax,%edx
    8e55:	8b 45 08             	mov    0x8(%ebp),%eax
    8e58:	8b 00                	mov    (%eax),%eax
    8e5a:	83 ec 08             	sub    $0x8,%esp
    8e5d:	52                   	push   %edx
    8e5e:	50                   	push   %eax
    8e5f:	e8 c1 fe ff ff       	call   8d25 <adler32>
    8e64:	83 c4 10             	add    $0x10,%esp
    8e67:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    8e6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8e6d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8e70:	74 07                	je     8e79 <lodepng_zlib_decompressv+0x13f>
    8e72:	b8 3a 00 00 00       	mov    $0x3a,%eax
    8e77:	eb 05                	jmp    8e7e <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    8e79:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e7e:	c9                   	leave  
    8e7f:	c3                   	ret    

00008e80 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    8e80:	55                   	push   %ebp
    8e81:	89 e5                	mov    %esp,%ebp
    8e83:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8e86:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e89:	8b 08                	mov    (%eax),%ecx
    8e8b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e8e:	8b 10                	mov    (%eax),%edx
    8e90:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8e93:	51                   	push   %ecx
    8e94:	52                   	push   %edx
    8e95:	50                   	push   %eax
    8e96:	e8 36 b8 ff ff       	call   46d1 <ucvector_init>
    8e9b:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8e9e:	ff 75 18             	pushl  0x18(%ebp)
    8ea1:	ff 75 14             	pushl  0x14(%ebp)
    8ea4:	ff 75 10             	pushl  0x10(%ebp)
    8ea7:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8eaa:	50                   	push   %eax
    8eab:	e8 8a fe ff ff       	call   8d3a <lodepng_zlib_decompressv>
    8eb0:	83 c4 10             	add    $0x10,%esp
    8eb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    8eb6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8eb9:	8b 45 08             	mov    0x8(%ebp),%eax
    8ebc:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8ebe:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8ec1:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ec4:	89 10                	mov    %edx,(%eax)
  return error;
    8ec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8ec9:	c9                   	leave  
    8eca:	c3                   	ret    

00008ecb <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    8ecb:	55                   	push   %ebp
    8ecc:	89 e5                	mov    %esp,%ebp
    8ece:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    8ed1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8ed4:	8b 40 0c             	mov    0xc(%eax),%eax
    8ed7:	85 c0                	test   %eax,%eax
    8ed9:	74 57                	je     8f32 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    8edb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8ede:	8b 40 0c             	mov    0xc(%eax),%eax
    8ee1:	83 ec 0c             	sub    $0xc,%esp
    8ee4:	ff 75 1c             	pushl  0x1c(%ebp)
    8ee7:	ff 75 18             	pushl  0x18(%ebp)
    8eea:	ff 75 14             	pushl  0x14(%ebp)
    8eed:	ff 75 0c             	pushl  0xc(%ebp)
    8ef0:	ff 75 08             	pushl  0x8(%ebp)
    8ef3:	ff d0                	call   *%eax
    8ef5:	83 c4 20             	add    $0x20,%esp
    8ef8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    8efb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8eff:	0f 84 98 00 00 00    	je     8f9d <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    8f05:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    8f0c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8f0f:	8b 40 08             	mov    0x8(%eax),%eax
    8f12:	85 c0                	test   %eax,%eax
    8f14:	0f 84 83 00 00 00    	je     8f9d <zlib_decompress+0xd2>
    8f1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f1d:	8b 10                	mov    (%eax),%edx
    8f1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8f22:	8b 40 08             	mov    0x8(%eax),%eax
    8f25:	39 c2                	cmp    %eax,%edx
    8f27:	7e 74                	jle    8f9d <zlib_decompress+0xd2>
    8f29:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    8f30:	eb 6b                	jmp    8f9d <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    8f32:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f35:	8b 08                	mov    (%eax),%ecx
    8f37:	8b 45 08             	mov    0x8(%ebp),%eax
    8f3a:	8b 10                	mov    (%eax),%edx
    8f3c:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8f3f:	83 ec 04             	sub    $0x4,%esp
    8f42:	51                   	push   %ecx
    8f43:	52                   	push   %edx
    8f44:	50                   	push   %eax
    8f45:	e8 87 b7 ff ff       	call   46d1 <ucvector_init>
    8f4a:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    8f4d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8f51:	74 22                	je     8f75 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    8f53:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f56:	8b 10                	mov    (%eax),%edx
    8f58:	8b 45 10             	mov    0x10(%ebp),%eax
    8f5b:	01 d0                	add    %edx,%eax
    8f5d:	83 ec 08             	sub    $0x8,%esp
    8f60:	50                   	push   %eax
    8f61:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8f64:	50                   	push   %eax
    8f65:	e8 00 b7 ff ff       	call   466a <ucvector_resize>
    8f6a:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    8f6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f70:	8b 00                	mov    (%eax),%eax
    8f72:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8f75:	ff 75 1c             	pushl  0x1c(%ebp)
    8f78:	ff 75 18             	pushl  0x18(%ebp)
    8f7b:	ff 75 14             	pushl  0x14(%ebp)
    8f7e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8f81:	50                   	push   %eax
    8f82:	e8 b3 fd ff ff       	call   8d3a <lodepng_zlib_decompressv>
    8f87:	83 c4 10             	add    $0x10,%esp
    8f8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    8f8d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8f90:	8b 45 08             	mov    0x8(%ebp),%eax
    8f93:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    8f95:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8f98:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f9b:	89 10                	mov    %edx,(%eax)
  }
  return error;
    8f9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8fa0:	c9                   	leave  
    8fa1:	c3                   	ret    

00008fa2 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    8fa2:	55                   	push   %ebp
    8fa3:	89 e5                	mov    %esp,%ebp
    8fa5:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    8fa8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    8faf:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    8fb6:	83 ec 0c             	sub    $0xc,%esp
    8fb9:	ff 75 18             	pushl  0x18(%ebp)
    8fbc:	ff 75 14             	pushl  0x14(%ebp)
    8fbf:	ff 75 10             	pushl  0x10(%ebp)
    8fc2:	8d 45 d0             	lea    -0x30(%ebp),%eax
    8fc5:	50                   	push   %eax
    8fc6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8fc9:	50                   	push   %eax
    8fca:	e8 42 fc ff ff       	call   8c11 <deflate>
    8fcf:	83 c4 20             	add    $0x20,%esp
    8fd2:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    8fd5:	8b 45 08             	mov    0x8(%ebp),%eax
    8fd8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    8fde:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fe1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    8fe7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8feb:	75 33                	jne    9020 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    8fed:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8ff0:	8d 50 06             	lea    0x6(%eax),%edx
    8ff3:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ff6:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    8ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ffb:	8b 00                	mov    (%eax),%eax
    8ffd:	83 ec 0c             	sub    $0xc,%esp
    9000:	50                   	push   %eax
    9001:	e8 0a b4 ff ff       	call   4410 <lodepng_malloc>
    9006:	83 c4 10             	add    $0x10,%esp
    9009:	89 c2                	mov    %eax,%edx
    900b:	8b 45 08             	mov    0x8(%ebp),%eax
    900e:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    9010:	8b 45 08             	mov    0x8(%ebp),%eax
    9013:	8b 00                	mov    (%eax),%eax
    9015:	85 c0                	test   %eax,%eax
    9017:	75 07                	jne    9020 <lodepng_zlib_compress+0x7e>
    9019:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    9020:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9024:	0f 85 e2 00 00 00    	jne    910c <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    902a:	8b 45 14             	mov    0x14(%ebp),%eax
    902d:	83 ec 08             	sub    $0x8,%esp
    9030:	50                   	push   %eax
    9031:	ff 75 10             	pushl  0x10(%ebp)
    9034:	e8 ec fc ff ff       	call   8d25 <adler32>
    9039:	83 c4 10             	add    $0x10,%esp
    903c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    903f:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    9046:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    904d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    9054:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9057:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    905e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9061:	01 d0                	add    %edx,%eax
    9063:	8d 14 00             	lea    (%eax,%eax,1),%edx
    9066:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9069:	01 d0                	add    %edx,%eax
    906b:	c1 e0 05             	shl    $0x5,%eax
    906e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    9071:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    9074:	ba 85 10 42 08       	mov    $0x8421085,%edx
    9079:	89 c8                	mov    %ecx,%eax
    907b:	f7 e2                	mul    %edx
    907d:	89 c8                	mov    %ecx,%eax
    907f:	29 d0                	sub    %edx,%eax
    9081:	d1 e8                	shr    %eax
    9083:	01 d0                	add    %edx,%eax
    9085:	c1 e8 04             	shr    $0x4,%eax
    9088:	89 c2                	mov    %eax,%edx
    908a:	c1 e2 05             	shl    $0x5,%edx
    908d:	29 c2                	sub    %eax,%edx
    908f:	89 c8                	mov    %ecx,%eax
    9091:	29 d0                	sub    %edx,%eax
    9093:	ba 1f 00 00 00       	mov    $0x1f,%edx
    9098:	29 c2                	sub    %eax,%edx
    909a:	89 d0                	mov    %edx,%eax
    909c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    909f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    90a2:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    90a5:	8b 45 08             	mov    0x8(%ebp),%eax
    90a8:	8b 00                	mov    (%eax),%eax
    90aa:	8b 55 dc             	mov    -0x24(%ebp),%edx
    90ad:	c1 ea 08             	shr    $0x8,%edx
    90b0:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    90b2:	8b 45 08             	mov    0x8(%ebp),%eax
    90b5:	8b 00                	mov    (%eax),%eax
    90b7:	83 c0 01             	add    $0x1,%eax
    90ba:	8b 55 dc             	mov    -0x24(%ebp),%edx
    90bd:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    90bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    90c6:	eb 1e                	jmp    90e6 <lodepng_zlib_compress+0x144>
    90c8:	8b 45 08             	mov    0x8(%ebp),%eax
    90cb:	8b 00                	mov    (%eax),%eax
    90cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    90d0:	83 c2 02             	add    $0x2,%edx
    90d3:	01 c2                	add    %eax,%edx
    90d5:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    90d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    90db:	01 c8                	add    %ecx,%eax
    90dd:	0f b6 00             	movzbl (%eax),%eax
    90e0:	88 02                	mov    %al,(%edx)
    90e2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    90e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    90e9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    90ec:	75 da                	jne    90c8 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    90ee:	8b 45 08             	mov    0x8(%ebp),%eax
    90f1:	8b 10                	mov    (%eax),%edx
    90f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    90f6:	8b 00                	mov    (%eax),%eax
    90f8:	83 e8 04             	sub    $0x4,%eax
    90fb:	01 d0                	add    %edx,%eax
    90fd:	83 ec 08             	sub    $0x8,%esp
    9100:	ff 75 ec             	pushl  -0x14(%ebp)
    9103:	50                   	push   %eax
    9104:	e8 c8 b6 ff ff       	call   47d1 <lodepng_set32bitInt>
    9109:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    910c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    910f:	83 ec 0c             	sub    $0xc,%esp
    9112:	50                   	push   %eax
    9113:	e8 19 b3 ff ff       	call   4431 <lodepng_free>
    9118:	83 c4 10             	add    $0x10,%esp
  return error;
    911b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    911e:	c9                   	leave  
    911f:	c3                   	ret    

00009120 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    9120:	55                   	push   %ebp
    9121:	89 e5                	mov    %esp,%ebp
    9123:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    9126:	8b 45 18             	mov    0x18(%ebp),%eax
    9129:	8b 40 18             	mov    0x18(%eax),%eax
    912c:	85 c0                	test   %eax,%eax
    912e:	74 34                	je     9164 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    9130:	8b 45 18             	mov    0x18(%ebp),%eax
    9133:	8b 40 18             	mov    0x18(%eax),%eax
    9136:	83 ec 0c             	sub    $0xc,%esp
    9139:	ff 75 18             	pushl  0x18(%ebp)
    913c:	ff 75 14             	pushl  0x14(%ebp)
    913f:	ff 75 10             	pushl  0x10(%ebp)
    9142:	ff 75 0c             	pushl  0xc(%ebp)
    9145:	ff 75 08             	pushl  0x8(%ebp)
    9148:	ff d0                	call   *%eax
    914a:	83 c4 20             	add    $0x20,%esp
    914d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    9150:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9154:	74 07                	je     915d <zlib_compress+0x3d>
    9156:	b8 6f 00 00 00       	mov    $0x6f,%eax
    915b:	eb 21                	jmp    917e <zlib_compress+0x5e>
    915d:	b8 00 00 00 00       	mov    $0x0,%eax
    9162:	eb 1a                	jmp    917e <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    9164:	83 ec 0c             	sub    $0xc,%esp
    9167:	ff 75 18             	pushl  0x18(%ebp)
    916a:	ff 75 14             	pushl  0x14(%ebp)
    916d:	ff 75 10             	pushl  0x10(%ebp)
    9170:	ff 75 0c             	pushl  0xc(%ebp)
    9173:	ff 75 08             	pushl  0x8(%ebp)
    9176:	e8 27 fe ff ff       	call   8fa2 <lodepng_zlib_compress>
    917b:	83 c4 20             	add    $0x20,%esp
  }
}
    917e:	c9                   	leave  
    917f:	c3                   	ret    

00009180 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    9180:	55                   	push   %ebp
    9181:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    9183:	8b 45 08             	mov    0x8(%ebp),%eax
    9186:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    918c:	8b 45 08             	mov    0x8(%ebp),%eax
    918f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    9196:	8b 45 08             	mov    0x8(%ebp),%eax
    9199:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    91a0:	8b 45 08             	mov    0x8(%ebp),%eax
    91a3:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    91aa:	8b 45 08             	mov    0x8(%ebp),%eax
    91ad:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    91b4:	8b 45 08             	mov    0x8(%ebp),%eax
    91b7:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    91be:	8b 45 08             	mov    0x8(%ebp),%eax
    91c1:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    91c8:	8b 45 08             	mov    0x8(%ebp),%eax
    91cb:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    91d2:	8b 45 08             	mov    0x8(%ebp),%eax
    91d5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    91dc:	90                   	nop
    91dd:	5d                   	pop    %ebp
    91de:	c3                   	ret    

000091df <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    91df:	55                   	push   %ebp
    91e0:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    91e2:	8b 45 08             	mov    0x8(%ebp),%eax
    91e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    91eb:	8b 45 08             	mov    0x8(%ebp),%eax
    91ee:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    91f5:	8b 45 08             	mov    0x8(%ebp),%eax
    91f8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    91ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9202:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    9209:	8b 45 08             	mov    0x8(%ebp),%eax
    920c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    9213:	8b 45 08             	mov    0x8(%ebp),%eax
    9216:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    921d:	90                   	nop
    921e:	5d                   	pop    %ebp
    921f:	c3                   	ret    

00009220 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    9220:	55                   	push   %ebp
    9221:	89 e5                	mov    %esp,%ebp
    9223:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    9226:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    922d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9234:	eb 2a                	jmp    9260 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    9236:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9239:	8b 45 08             	mov    0x8(%ebp),%eax
    923c:	01 d0                	add    %edx,%eax
    923e:	0f b6 00             	movzbl (%eax),%eax
    9241:	0f b6 c0             	movzbl %al,%eax
    9244:	33 45 fc             	xor    -0x4(%ebp),%eax
    9247:	0f b6 c0             	movzbl %al,%eax
    924a:	8b 04 85 20 f7 01 00 	mov    0x1f720(,%eax,4),%eax
    9251:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9254:	c1 ea 08             	shr    $0x8,%edx
    9257:	31 d0                	xor    %edx,%eax
    9259:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    925c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9260:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9263:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9266:	7c ce                	jl     9236 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    9268:	8b 45 fc             	mov    -0x4(%ebp),%eax
    926b:	f7 d0                	not    %eax
}
    926d:	c9                   	leave  
    926e:	c3                   	ret    

0000926f <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    926f:	55                   	push   %ebp
    9270:	89 e5                	mov    %esp,%ebp
    9272:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    9275:	8b 45 08             	mov    0x8(%ebp),%eax
    9278:	8b 00                	mov    (%eax),%eax
    927a:	c1 f8 03             	sar    $0x3,%eax
    927d:	89 c2                	mov    %eax,%edx
    927f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9282:	01 d0                	add    %edx,%eax
    9284:	0f b6 00             	movzbl (%eax),%eax
    9287:	0f b6 d0             	movzbl %al,%edx
    928a:	8b 45 08             	mov    0x8(%ebp),%eax
    928d:	8b 00                	mov    (%eax),%eax
    928f:	f7 d0                	not    %eax
    9291:	83 e0 07             	and    $0x7,%eax
    9294:	89 c1                	mov    %eax,%ecx
    9296:	d3 fa                	sar    %cl,%edx
    9298:	89 d0                	mov    %edx,%eax
    929a:	83 e0 01             	and    $0x1,%eax
    929d:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    92a0:	8b 45 08             	mov    0x8(%ebp),%eax
    92a3:	8b 00                	mov    (%eax),%eax
    92a5:	8d 50 01             	lea    0x1(%eax),%edx
    92a8:	8b 45 08             	mov    0x8(%ebp),%eax
    92ab:	89 10                	mov    %edx,(%eax)
  return result;
    92ad:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    92b1:	c9                   	leave  
    92b2:	c3                   	ret    

000092b3 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    92b3:	55                   	push   %ebp
    92b4:	89 e5                	mov    %esp,%ebp
    92b6:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    92b9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    92c0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    92c7:	eb 1b                	jmp    92e4 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    92c9:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    92cc:	ff 75 0c             	pushl  0xc(%ebp)
    92cf:	ff 75 08             	pushl  0x8(%ebp)
    92d2:	e8 98 ff ff ff       	call   926f <readBitFromReversedStream>
    92d7:	83 c4 08             	add    $0x8,%esp
    92da:	0f b6 c0             	movzbl %al,%eax
    92dd:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    92e0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    92e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    92e7:	3b 45 10             	cmp    0x10(%ebp),%eax
    92ea:	7c dd                	jl     92c9 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    92ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    92ef:	c9                   	leave  
    92f0:	c3                   	ret    

000092f1 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    92f1:	55                   	push   %ebp
    92f2:	89 e5                	mov    %esp,%ebp
    92f4:	56                   	push   %esi
    92f5:	53                   	push   %ebx
    92f6:	83 ec 04             	sub    $0x4,%esp
    92f9:	8b 45 10             	mov    0x10(%ebp),%eax
    92fc:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    92ff:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    9303:	75 3e                	jne    9343 <setBitOfReversedStream+0x52>
    9305:	8b 45 08             	mov    0x8(%ebp),%eax
    9308:	8b 00                	mov    (%eax),%eax
    930a:	c1 f8 03             	sar    $0x3,%eax
    930d:	89 c2                	mov    %eax,%edx
    930f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9312:	01 c2                	add    %eax,%edx
    9314:	8b 45 08             	mov    0x8(%ebp),%eax
    9317:	8b 00                	mov    (%eax),%eax
    9319:	c1 f8 03             	sar    $0x3,%eax
    931c:	89 c1                	mov    %eax,%ecx
    931e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9321:	01 c8                	add    %ecx,%eax
    9323:	0f b6 18             	movzbl (%eax),%ebx
    9326:	8b 45 08             	mov    0x8(%ebp),%eax
    9329:	8b 00                	mov    (%eax),%eax
    932b:	f7 d0                	not    %eax
    932d:	83 e0 07             	and    $0x7,%eax
    9330:	be 01 00 00 00       	mov    $0x1,%esi
    9335:	89 c1                	mov    %eax,%ecx
    9337:	d3 e6                	shl    %cl,%esi
    9339:	89 f0                	mov    %esi,%eax
    933b:	f7 d0                	not    %eax
    933d:	21 d8                	and    %ebx,%eax
    933f:	88 02                	mov    %al,(%edx)
    9341:	eb 3a                	jmp    937d <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    9343:	8b 45 08             	mov    0x8(%ebp),%eax
    9346:	8b 00                	mov    (%eax),%eax
    9348:	c1 f8 03             	sar    $0x3,%eax
    934b:	89 c2                	mov    %eax,%edx
    934d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9350:	01 c2                	add    %eax,%edx
    9352:	8b 45 08             	mov    0x8(%ebp),%eax
    9355:	8b 00                	mov    (%eax),%eax
    9357:	c1 f8 03             	sar    $0x3,%eax
    935a:	89 c1                	mov    %eax,%ecx
    935c:	8b 45 0c             	mov    0xc(%ebp),%eax
    935f:	01 c8                	add    %ecx,%eax
    9361:	0f b6 18             	movzbl (%eax),%ebx
    9364:	8b 45 08             	mov    0x8(%ebp),%eax
    9367:	8b 00                	mov    (%eax),%eax
    9369:	f7 d0                	not    %eax
    936b:	83 e0 07             	and    $0x7,%eax
    936e:	be 01 00 00 00       	mov    $0x1,%esi
    9373:	89 c1                	mov    %eax,%ecx
    9375:	d3 e6                	shl    %cl,%esi
    9377:	89 f0                	mov    %esi,%eax
    9379:	09 d8                	or     %ebx,%eax
    937b:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    937d:	8b 45 08             	mov    0x8(%ebp),%eax
    9380:	8b 00                	mov    (%eax),%eax
    9382:	8d 50 01             	lea    0x1(%eax),%edx
    9385:	8b 45 08             	mov    0x8(%ebp),%eax
    9388:	89 10                	mov    %edx,(%eax)
}
    938a:	90                   	nop
    938b:	83 c4 04             	add    $0x4,%esp
    938e:	5b                   	pop    %ebx
    938f:	5e                   	pop    %esi
    9390:	5d                   	pop    %ebp
    9391:	c3                   	ret    

00009392 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    9392:	55                   	push   %ebp
    9393:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    9395:	ff 75 08             	pushl  0x8(%ebp)
    9398:	e8 f1 b3 ff ff       	call   478e <lodepng_read32bitInt>
    939d:	83 c4 04             	add    $0x4,%esp
}
    93a0:	c9                   	leave  
    93a1:	c3                   	ret    

000093a2 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    93a2:	55                   	push   %ebp
    93a3:	89 e5                	mov    %esp,%ebp
    93a5:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    93a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    93af:	eb 1c                	jmp    93cd <lodepng_chunk_type+0x2b>
    93b1:	8b 55 08             	mov    0x8(%ebp),%edx
    93b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    93b7:	01 d0                	add    %edx,%eax
    93b9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    93bc:	8d 4a 04             	lea    0x4(%edx),%ecx
    93bf:	8b 55 0c             	mov    0xc(%ebp),%edx
    93c2:	01 ca                	add    %ecx,%edx
    93c4:	0f b6 12             	movzbl (%edx),%edx
    93c7:	88 10                	mov    %dl,(%eax)
    93c9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    93cd:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    93d1:	75 de                	jne    93b1 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    93d3:	8b 45 08             	mov    0x8(%ebp),%eax
    93d6:	83 c0 04             	add    $0x4,%eax
    93d9:	c6 00 00             	movb   $0x0,(%eax)
}
    93dc:	90                   	nop
    93dd:	c9                   	leave  
    93de:	c3                   	ret    

000093df <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    93df:	55                   	push   %ebp
    93e0:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    93e2:	ff 75 0c             	pushl  0xc(%ebp)
    93e5:	e8 c2 b0 ff ff       	call   44ac <lodepng_strlen>
    93ea:	83 c4 04             	add    $0x4,%esp
    93ed:	83 f8 04             	cmp    $0x4,%eax
    93f0:	74 07                	je     93f9 <lodepng_chunk_type_equals+0x1a>
    93f2:	b8 00 00 00 00       	mov    $0x0,%eax
    93f7:	eb 79                	jmp    9472 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    93f9:	8b 45 08             	mov    0x8(%ebp),%eax
    93fc:	83 c0 04             	add    $0x4,%eax
    93ff:	0f b6 00             	movzbl (%eax),%eax
    9402:	0f b6 d0             	movzbl %al,%edx
    9405:	8b 45 0c             	mov    0xc(%ebp),%eax
    9408:	0f b6 00             	movzbl (%eax),%eax
    940b:	0f be c0             	movsbl %al,%eax
    940e:	39 c2                	cmp    %eax,%edx
    9410:	75 5b                	jne    946d <lodepng_chunk_type_equals+0x8e>
    9412:	8b 45 08             	mov    0x8(%ebp),%eax
    9415:	83 c0 05             	add    $0x5,%eax
    9418:	0f b6 00             	movzbl (%eax),%eax
    941b:	0f b6 d0             	movzbl %al,%edx
    941e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9421:	83 c0 01             	add    $0x1,%eax
    9424:	0f b6 00             	movzbl (%eax),%eax
    9427:	0f be c0             	movsbl %al,%eax
    942a:	39 c2                	cmp    %eax,%edx
    942c:	75 3f                	jne    946d <lodepng_chunk_type_equals+0x8e>
    942e:	8b 45 08             	mov    0x8(%ebp),%eax
    9431:	83 c0 06             	add    $0x6,%eax
    9434:	0f b6 00             	movzbl (%eax),%eax
    9437:	0f b6 d0             	movzbl %al,%edx
    943a:	8b 45 0c             	mov    0xc(%ebp),%eax
    943d:	83 c0 02             	add    $0x2,%eax
    9440:	0f b6 00             	movzbl (%eax),%eax
    9443:	0f be c0             	movsbl %al,%eax
    9446:	39 c2                	cmp    %eax,%edx
    9448:	75 23                	jne    946d <lodepng_chunk_type_equals+0x8e>
    944a:	8b 45 08             	mov    0x8(%ebp),%eax
    944d:	83 c0 07             	add    $0x7,%eax
    9450:	0f b6 00             	movzbl (%eax),%eax
    9453:	0f b6 d0             	movzbl %al,%edx
    9456:	8b 45 0c             	mov    0xc(%ebp),%eax
    9459:	83 c0 03             	add    $0x3,%eax
    945c:	0f b6 00             	movzbl (%eax),%eax
    945f:	0f be c0             	movsbl %al,%eax
    9462:	39 c2                	cmp    %eax,%edx
    9464:	75 07                	jne    946d <lodepng_chunk_type_equals+0x8e>
    9466:	b8 01 00 00 00       	mov    $0x1,%eax
    946b:	eb 05                	jmp    9472 <lodepng_chunk_type_equals+0x93>
    946d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9472:	c9                   	leave  
    9473:	c3                   	ret    

00009474 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    9474:	55                   	push   %ebp
    9475:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    9477:	8b 45 08             	mov    0x8(%ebp),%eax
    947a:	83 c0 04             	add    $0x4,%eax
    947d:	0f b6 00             	movzbl (%eax),%eax
    9480:	0f b6 c0             	movzbl %al,%eax
    9483:	83 e0 20             	and    $0x20,%eax
    9486:	85 c0                	test   %eax,%eax
    9488:	0f 95 c0             	setne  %al
}
    948b:	5d                   	pop    %ebp
    948c:	c3                   	ret    

0000948d <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    948d:	55                   	push   %ebp
    948e:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    9490:	8b 45 08             	mov    0x8(%ebp),%eax
    9493:	83 c0 06             	add    $0x6,%eax
    9496:	0f b6 00             	movzbl (%eax),%eax
    9499:	0f b6 c0             	movzbl %al,%eax
    949c:	83 e0 20             	and    $0x20,%eax
    949f:	85 c0                	test   %eax,%eax
    94a1:	0f 95 c0             	setne  %al
}
    94a4:	5d                   	pop    %ebp
    94a5:	c3                   	ret    

000094a6 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    94a6:	55                   	push   %ebp
    94a7:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    94a9:	8b 45 08             	mov    0x8(%ebp),%eax
    94ac:	83 c0 07             	add    $0x7,%eax
    94af:	0f b6 00             	movzbl (%eax),%eax
    94b2:	0f b6 c0             	movzbl %al,%eax
    94b5:	83 e0 20             	and    $0x20,%eax
    94b8:	85 c0                	test   %eax,%eax
    94ba:	0f 95 c0             	setne  %al
}
    94bd:	5d                   	pop    %ebp
    94be:	c3                   	ret    

000094bf <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    94bf:	55                   	push   %ebp
    94c0:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    94c2:	8b 45 08             	mov    0x8(%ebp),%eax
    94c5:	83 c0 08             	add    $0x8,%eax
}
    94c8:	5d                   	pop    %ebp
    94c9:	c3                   	ret    

000094ca <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    94ca:	55                   	push   %ebp
    94cb:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    94cd:	8b 45 08             	mov    0x8(%ebp),%eax
    94d0:	83 c0 08             	add    $0x8,%eax
}
    94d3:	5d                   	pop    %ebp
    94d4:	c3                   	ret    

000094d5 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    94d5:	55                   	push   %ebp
    94d6:	89 e5                	mov    %esp,%ebp
    94d8:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    94db:	ff 75 08             	pushl  0x8(%ebp)
    94de:	e8 af fe ff ff       	call   9392 <lodepng_chunk_length>
    94e3:	83 c4 04             	add    $0x4,%esp
    94e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    94e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    94ec:	8d 50 08             	lea    0x8(%eax),%edx
    94ef:	8b 45 08             	mov    0x8(%ebp),%eax
    94f2:	01 d0                	add    %edx,%eax
    94f4:	50                   	push   %eax
    94f5:	e8 94 b2 ff ff       	call   478e <lodepng_read32bitInt>
    94fa:	83 c4 04             	add    $0x4,%esp
    94fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    9500:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9503:	83 c0 04             	add    $0x4,%eax
    9506:	89 c2                	mov    %eax,%edx
    9508:	8b 45 08             	mov    0x8(%ebp),%eax
    950b:	83 c0 04             	add    $0x4,%eax
    950e:	52                   	push   %edx
    950f:	50                   	push   %eax
    9510:	e8 0b fd ff ff       	call   9220 <lodepng_crc32>
    9515:	83 c4 08             	add    $0x8,%esp
    9518:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    951b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    951e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9521:	74 07                	je     952a <lodepng_chunk_check_crc+0x55>
    9523:	b8 01 00 00 00       	mov    $0x1,%eax
    9528:	eb 05                	jmp    952f <lodepng_chunk_check_crc+0x5a>
  else return 0;
    952a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    952f:	c9                   	leave  
    9530:	c3                   	ret    

00009531 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    9531:	55                   	push   %ebp
    9532:	89 e5                	mov    %esp,%ebp
    9534:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    9537:	ff 75 08             	pushl  0x8(%ebp)
    953a:	e8 53 fe ff ff       	call   9392 <lodepng_chunk_length>
    953f:	83 c4 04             	add    $0x4,%esp
    9542:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    9545:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9548:	83 c0 04             	add    $0x4,%eax
    954b:	89 c2                	mov    %eax,%edx
    954d:	8b 45 08             	mov    0x8(%ebp),%eax
    9550:	83 c0 04             	add    $0x4,%eax
    9553:	52                   	push   %edx
    9554:	50                   	push   %eax
    9555:	e8 c6 fc ff ff       	call   9220 <lodepng_crc32>
    955a:	83 c4 08             	add    $0x8,%esp
    955d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    9560:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9563:	8d 50 08             	lea    0x8(%eax),%edx
    9566:	8b 45 08             	mov    0x8(%ebp),%eax
    9569:	01 d0                	add    %edx,%eax
    956b:	ff 75 f8             	pushl  -0x8(%ebp)
    956e:	50                   	push   %eax
    956f:	e8 5d b2 ff ff       	call   47d1 <lodepng_set32bitInt>
    9574:	83 c4 08             	add    $0x8,%esp
}
    9577:	90                   	nop
    9578:	c9                   	leave  
    9579:	c3                   	ret    

0000957a <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    957a:	55                   	push   %ebp
    957b:	89 e5                	mov    %esp,%ebp
    957d:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    9580:	8b 45 08             	mov    0x8(%ebp),%eax
    9583:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9586:	73 0f                	jae    9597 <lodepng_chunk_next+0x1d>
    9588:	8b 55 0c             	mov    0xc(%ebp),%edx
    958b:	8b 45 08             	mov    0x8(%ebp),%eax
    958e:	29 c2                	sub    %eax,%edx
    9590:	89 d0                	mov    %edx,%eax
    9592:	83 f8 0b             	cmp    $0xb,%eax
    9595:	7f 08                	jg     959f <lodepng_chunk_next+0x25>
    9597:	8b 45 0c             	mov    0xc(%ebp),%eax
    959a:	e9 af 00 00 00       	jmp    964e <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    959f:	8b 45 08             	mov    0x8(%ebp),%eax
    95a2:	0f b6 00             	movzbl (%eax),%eax
    95a5:	3c 89                	cmp    $0x89,%al
    95a7:	75 63                	jne    960c <lodepng_chunk_next+0x92>
    95a9:	8b 45 08             	mov    0x8(%ebp),%eax
    95ac:	83 c0 01             	add    $0x1,%eax
    95af:	0f b6 00             	movzbl (%eax),%eax
    95b2:	3c 50                	cmp    $0x50,%al
    95b4:	75 56                	jne    960c <lodepng_chunk_next+0x92>
    95b6:	8b 45 08             	mov    0x8(%ebp),%eax
    95b9:	83 c0 02             	add    $0x2,%eax
    95bc:	0f b6 00             	movzbl (%eax),%eax
    95bf:	3c 4e                	cmp    $0x4e,%al
    95c1:	75 49                	jne    960c <lodepng_chunk_next+0x92>
    95c3:	8b 45 08             	mov    0x8(%ebp),%eax
    95c6:	83 c0 03             	add    $0x3,%eax
    95c9:	0f b6 00             	movzbl (%eax),%eax
    95cc:	3c 47                	cmp    $0x47,%al
    95ce:	75 3c                	jne    960c <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    95d0:	8b 45 08             	mov    0x8(%ebp),%eax
    95d3:	83 c0 04             	add    $0x4,%eax
    95d6:	0f b6 00             	movzbl (%eax),%eax
    95d9:	3c 0d                	cmp    $0xd,%al
    95db:	75 2f                	jne    960c <lodepng_chunk_next+0x92>
    95dd:	8b 45 08             	mov    0x8(%ebp),%eax
    95e0:	83 c0 05             	add    $0x5,%eax
    95e3:	0f b6 00             	movzbl (%eax),%eax
    95e6:	3c 0a                	cmp    $0xa,%al
    95e8:	75 22                	jne    960c <lodepng_chunk_next+0x92>
    95ea:	8b 45 08             	mov    0x8(%ebp),%eax
    95ed:	83 c0 06             	add    $0x6,%eax
    95f0:	0f b6 00             	movzbl (%eax),%eax
    95f3:	3c 1a                	cmp    $0x1a,%al
    95f5:	75 15                	jne    960c <lodepng_chunk_next+0x92>
    95f7:	8b 45 08             	mov    0x8(%ebp),%eax
    95fa:	83 c0 07             	add    $0x7,%eax
    95fd:	0f b6 00             	movzbl (%eax),%eax
    9600:	3c 0a                	cmp    $0xa,%al
    9602:	75 08                	jne    960c <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    9604:	8b 45 08             	mov    0x8(%ebp),%eax
    9607:	83 c0 08             	add    $0x8,%eax
    960a:	eb 42                	jmp    964e <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    960c:	ff 75 08             	pushl  0x8(%ebp)
    960f:	e8 7e fd ff ff       	call   9392 <lodepng_chunk_length>
    9614:	83 c4 04             	add    $0x4,%esp
    9617:	89 c2                	mov    %eax,%edx
    9619:	8d 45 f8             	lea    -0x8(%ebp),%eax
    961c:	50                   	push   %eax
    961d:	6a 0c                	push   $0xc
    961f:	52                   	push   %edx
    9620:	e8 af ae ff ff       	call   44d4 <lodepng_addofl>
    9625:	83 c4 0c             	add    $0xc,%esp
    9628:	85 c0                	test   %eax,%eax
    962a:	74 05                	je     9631 <lodepng_chunk_next+0xb7>
    962c:	8b 45 0c             	mov    0xc(%ebp),%eax
    962f:	eb 1d                	jmp    964e <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    9631:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9634:	89 c2                	mov    %eax,%edx
    9636:	8b 45 08             	mov    0x8(%ebp),%eax
    9639:	01 d0                	add    %edx,%eax
    963b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    963e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9641:	3b 45 08             	cmp    0x8(%ebp),%eax
    9644:	73 05                	jae    964b <lodepng_chunk_next+0xd1>
    9646:	8b 45 0c             	mov    0xc(%ebp),%eax
    9649:	eb 03                	jmp    964e <lodepng_chunk_next+0xd4>
    return result;
    964b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    964e:	c9                   	leave  
    964f:	c3                   	ret    

00009650 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    9650:	55                   	push   %ebp
    9651:	89 e5                	mov    %esp,%ebp
    9653:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    9656:	8b 45 08             	mov    0x8(%ebp),%eax
    9659:	3b 45 0c             	cmp    0xc(%ebp),%eax
    965c:	73 0f                	jae    966d <lodepng_chunk_next_const+0x1d>
    965e:	8b 55 0c             	mov    0xc(%ebp),%edx
    9661:	8b 45 08             	mov    0x8(%ebp),%eax
    9664:	29 c2                	sub    %eax,%edx
    9666:	89 d0                	mov    %edx,%eax
    9668:	83 f8 0b             	cmp    $0xb,%eax
    966b:	7f 08                	jg     9675 <lodepng_chunk_next_const+0x25>
    966d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9670:	e9 af 00 00 00       	jmp    9724 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    9675:	8b 45 08             	mov    0x8(%ebp),%eax
    9678:	0f b6 00             	movzbl (%eax),%eax
    967b:	3c 89                	cmp    $0x89,%al
    967d:	75 63                	jne    96e2 <lodepng_chunk_next_const+0x92>
    967f:	8b 45 08             	mov    0x8(%ebp),%eax
    9682:	83 c0 01             	add    $0x1,%eax
    9685:	0f b6 00             	movzbl (%eax),%eax
    9688:	3c 50                	cmp    $0x50,%al
    968a:	75 56                	jne    96e2 <lodepng_chunk_next_const+0x92>
    968c:	8b 45 08             	mov    0x8(%ebp),%eax
    968f:	83 c0 02             	add    $0x2,%eax
    9692:	0f b6 00             	movzbl (%eax),%eax
    9695:	3c 4e                	cmp    $0x4e,%al
    9697:	75 49                	jne    96e2 <lodepng_chunk_next_const+0x92>
    9699:	8b 45 08             	mov    0x8(%ebp),%eax
    969c:	83 c0 03             	add    $0x3,%eax
    969f:	0f b6 00             	movzbl (%eax),%eax
    96a2:	3c 47                	cmp    $0x47,%al
    96a4:	75 3c                	jne    96e2 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    96a6:	8b 45 08             	mov    0x8(%ebp),%eax
    96a9:	83 c0 04             	add    $0x4,%eax
    96ac:	0f b6 00             	movzbl (%eax),%eax
    96af:	3c 0d                	cmp    $0xd,%al
    96b1:	75 2f                	jne    96e2 <lodepng_chunk_next_const+0x92>
    96b3:	8b 45 08             	mov    0x8(%ebp),%eax
    96b6:	83 c0 05             	add    $0x5,%eax
    96b9:	0f b6 00             	movzbl (%eax),%eax
    96bc:	3c 0a                	cmp    $0xa,%al
    96be:	75 22                	jne    96e2 <lodepng_chunk_next_const+0x92>
    96c0:	8b 45 08             	mov    0x8(%ebp),%eax
    96c3:	83 c0 06             	add    $0x6,%eax
    96c6:	0f b6 00             	movzbl (%eax),%eax
    96c9:	3c 1a                	cmp    $0x1a,%al
    96cb:	75 15                	jne    96e2 <lodepng_chunk_next_const+0x92>
    96cd:	8b 45 08             	mov    0x8(%ebp),%eax
    96d0:	83 c0 07             	add    $0x7,%eax
    96d3:	0f b6 00             	movzbl (%eax),%eax
    96d6:	3c 0a                	cmp    $0xa,%al
    96d8:	75 08                	jne    96e2 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    96da:	8b 45 08             	mov    0x8(%ebp),%eax
    96dd:	83 c0 08             	add    $0x8,%eax
    96e0:	eb 42                	jmp    9724 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    96e2:	ff 75 08             	pushl  0x8(%ebp)
    96e5:	e8 a8 fc ff ff       	call   9392 <lodepng_chunk_length>
    96ea:	83 c4 04             	add    $0x4,%esp
    96ed:	89 c2                	mov    %eax,%edx
    96ef:	8d 45 f8             	lea    -0x8(%ebp),%eax
    96f2:	50                   	push   %eax
    96f3:	6a 0c                	push   $0xc
    96f5:	52                   	push   %edx
    96f6:	e8 d9 ad ff ff       	call   44d4 <lodepng_addofl>
    96fb:	83 c4 0c             	add    $0xc,%esp
    96fe:	85 c0                	test   %eax,%eax
    9700:	74 05                	je     9707 <lodepng_chunk_next_const+0xb7>
    9702:	8b 45 0c             	mov    0xc(%ebp),%eax
    9705:	eb 1d                	jmp    9724 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    9707:	8b 45 f8             	mov    -0x8(%ebp),%eax
    970a:	89 c2                	mov    %eax,%edx
    970c:	8b 45 08             	mov    0x8(%ebp),%eax
    970f:	01 d0                	add    %edx,%eax
    9711:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    9714:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9717:	3b 45 08             	cmp    0x8(%ebp),%eax
    971a:	73 05                	jae    9721 <lodepng_chunk_next_const+0xd1>
    971c:	8b 45 0c             	mov    0xc(%ebp),%eax
    971f:	eb 03                	jmp    9724 <lodepng_chunk_next_const+0xd4>
    return result;
    9721:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    9724:	c9                   	leave  
    9725:	c3                   	ret    

00009726 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    9726:	55                   	push   %ebp
    9727:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    9729:	8b 45 08             	mov    0x8(%ebp),%eax
    972c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    972f:	73 0f                	jae    9740 <lodepng_chunk_find+0x1a>
    9731:	8b 55 0c             	mov    0xc(%ebp),%edx
    9734:	8b 45 08             	mov    0x8(%ebp),%eax
    9737:	29 c2                	sub    %eax,%edx
    9739:	89 d0                	mov    %edx,%eax
    973b:	83 f8 0b             	cmp    $0xb,%eax
    973e:	7f 07                	jg     9747 <lodepng_chunk_find+0x21>
    9740:	b8 00 00 00 00       	mov    $0x0,%eax
    9745:	eb 2a                	jmp    9771 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    9747:	ff 75 10             	pushl  0x10(%ebp)
    974a:	ff 75 08             	pushl  0x8(%ebp)
    974d:	e8 8d fc ff ff       	call   93df <lodepng_chunk_type_equals>
    9752:	83 c4 08             	add    $0x8,%esp
    9755:	84 c0                	test   %al,%al
    9757:	74 05                	je     975e <lodepng_chunk_find+0x38>
    9759:	8b 45 08             	mov    0x8(%ebp),%eax
    975c:	eb 13                	jmp    9771 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    975e:	ff 75 0c             	pushl  0xc(%ebp)
    9761:	ff 75 08             	pushl  0x8(%ebp)
    9764:	e8 11 fe ff ff       	call   957a <lodepng_chunk_next>
    9769:	83 c4 08             	add    $0x8,%esp
    976c:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    976f:	eb b8                	jmp    9729 <lodepng_chunk_find+0x3>
}
    9771:	c9                   	leave  
    9772:	c3                   	ret    

00009773 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    9773:	55                   	push   %ebp
    9774:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    9776:	8b 45 08             	mov    0x8(%ebp),%eax
    9779:	3b 45 0c             	cmp    0xc(%ebp),%eax
    977c:	73 0f                	jae    978d <lodepng_chunk_find_const+0x1a>
    977e:	8b 55 0c             	mov    0xc(%ebp),%edx
    9781:	8b 45 08             	mov    0x8(%ebp),%eax
    9784:	29 c2                	sub    %eax,%edx
    9786:	89 d0                	mov    %edx,%eax
    9788:	83 f8 0b             	cmp    $0xb,%eax
    978b:	7f 07                	jg     9794 <lodepng_chunk_find_const+0x21>
    978d:	b8 00 00 00 00       	mov    $0x0,%eax
    9792:	eb 2a                	jmp    97be <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    9794:	ff 75 10             	pushl  0x10(%ebp)
    9797:	ff 75 08             	pushl  0x8(%ebp)
    979a:	e8 40 fc ff ff       	call   93df <lodepng_chunk_type_equals>
    979f:	83 c4 08             	add    $0x8,%esp
    97a2:	84 c0                	test   %al,%al
    97a4:	74 05                	je     97ab <lodepng_chunk_find_const+0x38>
    97a6:	8b 45 08             	mov    0x8(%ebp),%eax
    97a9:	eb 13                	jmp    97be <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    97ab:	ff 75 0c             	pushl  0xc(%ebp)
    97ae:	ff 75 08             	pushl  0x8(%ebp)
    97b1:	e8 9a fe ff ff       	call   9650 <lodepng_chunk_next_const>
    97b6:	83 c4 08             	add    $0x8,%esp
    97b9:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    97bc:	eb b8                	jmp    9776 <lodepng_chunk_find_const+0x3>
}
    97be:	c9                   	leave  
    97bf:	c3                   	ret    

000097c0 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    97c0:	55                   	push   %ebp
    97c1:	89 e5                	mov    %esp,%ebp
    97c3:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    97c6:	ff 75 10             	pushl  0x10(%ebp)
    97c9:	e8 c4 fb ff ff       	call   9392 <lodepng_chunk_length>
    97ce:	83 c4 04             	add    $0x4,%esp
    97d1:	89 c2                	mov    %eax,%edx
    97d3:	8d 45 f0             	lea    -0x10(%ebp),%eax
    97d6:	50                   	push   %eax
    97d7:	6a 0c                	push   $0xc
    97d9:	52                   	push   %edx
    97da:	e8 f5 ac ff ff       	call   44d4 <lodepng_addofl>
    97df:	83 c4 0c             	add    $0xc,%esp
    97e2:	85 c0                	test   %eax,%eax
    97e4:	74 0a                	je     97f0 <lodepng_chunk_append+0x30>
    97e6:	b8 4d 00 00 00       	mov    $0x4d,%eax
    97eb:	e9 96 00 00 00       	jmp    9886 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    97f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    97f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    97f6:	8b 00                	mov    (%eax),%eax
    97f8:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    97fb:	51                   	push   %ecx
    97fc:	52                   	push   %edx
    97fd:	50                   	push   %eax
    97fe:	e8 d1 ac ff ff       	call   44d4 <lodepng_addofl>
    9803:	83 c4 0c             	add    $0xc,%esp
    9806:	85 c0                	test   %eax,%eax
    9808:	74 07                	je     9811 <lodepng_chunk_append+0x51>
    980a:	b8 4d 00 00 00       	mov    $0x4d,%eax
    980f:	eb 75                	jmp    9886 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    9811:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9814:	8b 45 08             	mov    0x8(%ebp),%eax
    9817:	8b 00                	mov    (%eax),%eax
    9819:	52                   	push   %edx
    981a:	50                   	push   %eax
    981b:	e8 07 ac ff ff       	call   4427 <lodepng_realloc>
    9820:	83 c4 08             	add    $0x8,%esp
    9823:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    9826:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    982a:	75 07                	jne    9833 <lodepng_chunk_append+0x73>
    982c:	b8 53 00 00 00       	mov    $0x53,%eax
    9831:	eb 53                	jmp    9886 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    9833:	8b 45 08             	mov    0x8(%ebp),%eax
    9836:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9839:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    983b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    983e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9841:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    9843:	8b 45 08             	mov    0x8(%ebp),%eax
    9846:	8b 00                	mov    (%eax),%eax
    9848:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    984b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    984e:	29 d1                	sub    %edx,%ecx
    9850:	89 ca                	mov    %ecx,%edx
    9852:	01 d0                	add    %edx,%eax
    9854:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    9857:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    985e:	eb 19                	jmp    9879 <lodepng_chunk_append+0xb9>
    9860:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9863:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9866:	01 c2                	add    %eax,%edx
    9868:	8b 4d 10             	mov    0x10(%ebp),%ecx
    986b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    986e:	01 c8                	add    %ecx,%eax
    9870:	0f b6 00             	movzbl (%eax),%eax
    9873:	88 02                	mov    %al,(%edx)
    9875:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9879:	8b 45 f0             	mov    -0x10(%ebp),%eax
    987c:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    987f:	75 df                	jne    9860 <lodepng_chunk_append+0xa0>

  return 0;
    9881:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9886:	c9                   	leave  
    9887:	c3                   	ret    

00009888 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    9888:	55                   	push   %ebp
    9889:	89 e5                	mov    %esp,%ebp
    988b:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    988e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9891:	8b 40 04             	mov    0x4(%eax),%eax
    9894:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    9897:	8b 55 10             	mov    0x10(%ebp),%edx
    989a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    989d:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    98a0:	51                   	push   %ecx
    98a1:	52                   	push   %edx
    98a2:	50                   	push   %eax
    98a3:	e8 2c ac ff ff       	call   44d4 <lodepng_addofl>
    98a8:	83 c4 0c             	add    $0xc,%esp
    98ab:	85 c0                	test   %eax,%eax
    98ad:	74 07                	je     98b6 <lodepng_chunk_init+0x2e>
    98af:	b8 4d 00 00 00       	mov    $0x4d,%eax
    98b4:	eb 78                	jmp    992e <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    98b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    98b9:	8d 55 fc             	lea    -0x4(%ebp),%edx
    98bc:	52                   	push   %edx
    98bd:	6a 0c                	push   $0xc
    98bf:	50                   	push   %eax
    98c0:	e8 0f ac ff ff       	call   44d4 <lodepng_addofl>
    98c5:	83 c4 0c             	add    $0xc,%esp
    98c8:	85 c0                	test   %eax,%eax
    98ca:	74 07                	je     98d3 <lodepng_chunk_init+0x4b>
    98cc:	b8 4d 00 00 00       	mov    $0x4d,%eax
    98d1:	eb 5b                	jmp    992e <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    98d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    98d6:	50                   	push   %eax
    98d7:	ff 75 0c             	pushl  0xc(%ebp)
    98da:	e8 8b ad ff ff       	call   466a <ucvector_resize>
    98df:	83 c4 08             	add    $0x8,%esp
    98e2:	85 c0                	test   %eax,%eax
    98e4:	75 07                	jne    98ed <lodepng_chunk_init+0x65>
    98e6:	b8 53 00 00 00       	mov    $0x53,%eax
    98eb:	eb 41                	jmp    992e <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    98ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    98f0:	8b 00                	mov    (%eax),%eax
    98f2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    98f5:	2b 55 10             	sub    0x10(%ebp),%edx
    98f8:	83 ea 0c             	sub    $0xc,%edx
    98fb:	01 c2                	add    %eax,%edx
    98fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9900:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    9902:	8b 45 08             	mov    0x8(%ebp),%eax
    9905:	8b 00                	mov    (%eax),%eax
    9907:	ff 75 10             	pushl  0x10(%ebp)
    990a:	50                   	push   %eax
    990b:	e8 c1 ae ff ff       	call   47d1 <lodepng_set32bitInt>
    9910:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    9913:	8b 45 08             	mov    0x8(%ebp),%eax
    9916:	8b 00                	mov    (%eax),%eax
    9918:	83 c0 04             	add    $0x4,%eax
    991b:	6a 04                	push   $0x4
    991d:	ff 75 14             	pushl  0x14(%ebp)
    9920:	50                   	push   %eax
    9921:	e8 28 ab ff ff       	call   444e <lodepng_memcpy>
    9926:	83 c4 0c             	add    $0xc,%esp

  return 0;
    9929:	b8 00 00 00 00       	mov    $0x0,%eax
}
    992e:	c9                   	leave  
    992f:	c3                   	ret    

00009930 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    9930:	55                   	push   %ebp
    9931:	89 e5                	mov    %esp,%ebp
    9933:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    9936:	ff 75 10             	pushl  0x10(%ebp)
    9939:	ff 75 0c             	pushl  0xc(%ebp)
    993c:	ff 75 08             	pushl  0x8(%ebp)
    993f:	8d 45 f8             	lea    -0x8(%ebp),%eax
    9942:	50                   	push   %eax
    9943:	e8 40 ff ff ff       	call   9888 <lodepng_chunk_init>
    9948:	83 c4 10             	add    $0x10,%esp
    994b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    994e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    9952:	74 05                	je     9959 <lodepng_chunk_createv+0x29>
    9954:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9957:	eb 27                	jmp    9980 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    9959:	8b 45 0c             	mov    0xc(%ebp),%eax
    995c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    995f:	83 c2 08             	add    $0x8,%edx
    9962:	50                   	push   %eax
    9963:	ff 75 14             	pushl  0x14(%ebp)
    9966:	52                   	push   %edx
    9967:	e8 e2 aa ff ff       	call   444e <lodepng_memcpy>
    996c:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    996f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9972:	50                   	push   %eax
    9973:	e8 b9 fb ff ff       	call   9531 <lodepng_chunk_generate_crc>
    9978:	83 c4 04             	add    $0x4,%esp

  return 0;
    997b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9980:	c9                   	leave  
    9981:	c3                   	ret    

00009982 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    9982:	55                   	push   %ebp
    9983:	89 e5                	mov    %esp,%ebp
    9985:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    9988:	8b 45 0c             	mov    0xc(%ebp),%eax
    998b:	8b 08                	mov    (%eax),%ecx
    998d:	8b 45 08             	mov    0x8(%ebp),%eax
    9990:	8b 10                	mov    (%eax),%edx
    9992:	8d 45 f0             	lea    -0x10(%ebp),%eax
    9995:	51                   	push   %ecx
    9996:	52                   	push   %edx
    9997:	50                   	push   %eax
    9998:	e8 34 ad ff ff       	call   46d1 <ucvector_init>
    999d:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    99a0:	ff 75 18             	pushl  0x18(%ebp)
    99a3:	ff 75 14             	pushl  0x14(%ebp)
    99a6:	ff 75 10             	pushl  0x10(%ebp)
    99a9:	8d 45 f0             	lea    -0x10(%ebp),%eax
    99ac:	50                   	push   %eax
    99ad:	e8 7e ff ff ff       	call   9930 <lodepng_chunk_createv>
    99b2:	83 c4 10             	add    $0x10,%esp
    99b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    99b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    99bb:	8b 45 08             	mov    0x8(%ebp),%eax
    99be:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    99c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    99c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    99c6:	89 10                	mov    %edx,(%eax)
  return error;
    99c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    99cb:	c9                   	leave  
    99cc:	c3                   	ret    

000099cd <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    99cd:	55                   	push   %ebp
    99ce:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    99d0:	8b 45 08             	mov    0x8(%ebp),%eax
    99d3:	83 f8 03             	cmp    $0x3,%eax
    99d6:	74 6d                	je     9a45 <checkColorValidity+0x78>
    99d8:	83 f8 03             	cmp    $0x3,%eax
    99db:	77 0e                	ja     99eb <checkColorValidity+0x1e>
    99dd:	85 c0                	test   %eax,%eax
    99df:	74 28                	je     9a09 <checkColorValidity+0x3c>
    99e1:	83 f8 02             	cmp    $0x2,%eax
    99e4:	74 4c                	je     9a32 <checkColorValidity+0x65>
    99e6:	e9 a6 00 00 00       	jmp    9a91 <checkColorValidity+0xc4>
    99eb:	83 f8 06             	cmp    $0x6,%eax
    99ee:	0f 84 83 00 00 00    	je     9a77 <checkColorValidity+0xaa>
    99f4:	3d ff 00 00 00       	cmp    $0xff,%eax
    99f9:	0f 84 8b 00 00 00    	je     9a8a <checkColorValidity+0xbd>
    99ff:	83 f8 04             	cmp    $0x4,%eax
    9a02:	74 60                	je     9a64 <checkColorValidity+0x97>
    9a04:	e9 88 00 00 00       	jmp    9a91 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    9a09:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    9a0d:	0f 84 85 00 00 00    	je     9a98 <checkColorValidity+0xcb>
    9a13:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    9a17:	74 7f                	je     9a98 <checkColorValidity+0xcb>
    9a19:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    9a1d:	74 79                	je     9a98 <checkColorValidity+0xcb>
    9a1f:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9a23:	74 73                	je     9a98 <checkColorValidity+0xcb>
    9a25:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    9a29:	74 6d                	je     9a98 <checkColorValidity+0xcb>
    9a2b:	b8 25 00 00 00       	mov    $0x25,%eax
    9a30:	eb 78                	jmp    9aaa <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9a32:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9a36:	74 63                	je     9a9b <checkColorValidity+0xce>
    9a38:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    9a3c:	74 5d                	je     9a9b <checkColorValidity+0xce>
    9a3e:	b8 25 00 00 00       	mov    $0x25,%eax
    9a43:	eb 65                	jmp    9aaa <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    9a45:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    9a49:	74 53                	je     9a9e <checkColorValidity+0xd1>
    9a4b:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    9a4f:	74 4d                	je     9a9e <checkColorValidity+0xd1>
    9a51:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    9a55:	74 47                	je     9a9e <checkColorValidity+0xd1>
    9a57:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9a5b:	74 41                	je     9a9e <checkColorValidity+0xd1>
    9a5d:	b8 25 00 00 00       	mov    $0x25,%eax
    9a62:	eb 46                	jmp    9aaa <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9a64:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9a68:	74 37                	je     9aa1 <checkColorValidity+0xd4>
    9a6a:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    9a6e:	74 31                	je     9aa1 <checkColorValidity+0xd4>
    9a70:	b8 25 00 00 00       	mov    $0x25,%eax
    9a75:	eb 33                	jmp    9aaa <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9a77:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9a7b:	74 27                	je     9aa4 <checkColorValidity+0xd7>
    9a7d:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    9a81:	74 21                	je     9aa4 <checkColorValidity+0xd7>
    9a83:	b8 25 00 00 00       	mov    $0x25,%eax
    9a88:	eb 20                	jmp    9aaa <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    9a8a:	b8 1f 00 00 00       	mov    $0x1f,%eax
    9a8f:	eb 19                	jmp    9aaa <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    9a91:	b8 1f 00 00 00       	mov    $0x1f,%eax
    9a96:	eb 12                	jmp    9aaa <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    9a98:	90                   	nop
    9a99:	eb 0a                	jmp    9aa5 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9a9b:	90                   	nop
    9a9c:	eb 07                	jmp    9aa5 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    9a9e:	90                   	nop
    9a9f:	eb 04                	jmp    9aa5 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9aa1:	90                   	nop
    9aa2:	eb 01                	jmp    9aa5 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9aa4:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    9aa5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9aaa:	5d                   	pop    %ebp
    9aab:	c3                   	ret    

00009aac <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    9aac:	55                   	push   %ebp
    9aad:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    9aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab2:	83 f8 03             	cmp    $0x3,%eax
    9ab5:	74 31                	je     9ae8 <getNumColorChannels+0x3c>
    9ab7:	83 f8 03             	cmp    $0x3,%eax
    9aba:	77 0b                	ja     9ac7 <getNumColorChannels+0x1b>
    9abc:	85 c0                	test   %eax,%eax
    9abe:	74 1a                	je     9ada <getNumColorChannels+0x2e>
    9ac0:	83 f8 02             	cmp    $0x2,%eax
    9ac3:	74 1c                	je     9ae1 <getNumColorChannels+0x35>
    9ac5:	eb 3d                	jmp    9b04 <getNumColorChannels+0x58>
    9ac7:	83 f8 06             	cmp    $0x6,%eax
    9aca:	74 2a                	je     9af6 <getNumColorChannels+0x4a>
    9acc:	3d ff 00 00 00       	cmp    $0xff,%eax
    9ad1:	74 2a                	je     9afd <getNumColorChannels+0x51>
    9ad3:	83 f8 04             	cmp    $0x4,%eax
    9ad6:	74 17                	je     9aef <getNumColorChannels+0x43>
    9ad8:	eb 2a                	jmp    9b04 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    9ada:	b8 01 00 00 00       	mov    $0x1,%eax
    9adf:	eb 28                	jmp    9b09 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    9ae1:	b8 03 00 00 00       	mov    $0x3,%eax
    9ae6:	eb 21                	jmp    9b09 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    9ae8:	b8 01 00 00 00       	mov    $0x1,%eax
    9aed:	eb 1a                	jmp    9b09 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    9aef:	b8 02 00 00 00       	mov    $0x2,%eax
    9af4:	eb 13                	jmp    9b09 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    9af6:	b8 04 00 00 00       	mov    $0x4,%eax
    9afb:	eb 0c                	jmp    9b09 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    9afd:	b8 00 00 00 00       	mov    $0x0,%eax
    9b02:	eb 05                	jmp    9b09 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    9b04:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    9b09:	5d                   	pop    %ebp
    9b0a:	c3                   	ret    

00009b0b <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    9b0b:	55                   	push   %ebp
    9b0c:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    9b0e:	ff 75 08             	pushl  0x8(%ebp)
    9b11:	e8 96 ff ff ff       	call   9aac <getNumColorChannels>
    9b16:	83 c4 04             	add    $0x4,%esp
    9b19:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    9b1d:	c9                   	leave  
    9b1e:	c3                   	ret    

00009b1f <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    9b1f:	55                   	push   %ebp
    9b20:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    9b22:	8b 45 08             	mov    0x8(%ebp),%eax
    9b25:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    9b2c:	8b 45 08             	mov    0x8(%ebp),%eax
    9b2f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    9b36:	8b 45 08             	mov    0x8(%ebp),%eax
    9b39:	8b 50 1c             	mov    0x1c(%eax),%edx
    9b3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9b3f:	89 50 18             	mov    %edx,0x18(%eax)
    9b42:	8b 45 08             	mov    0x8(%ebp),%eax
    9b45:	8b 50 18             	mov    0x18(%eax),%edx
    9b48:	8b 45 08             	mov    0x8(%ebp),%eax
    9b4b:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    9b4e:	8b 45 08             	mov    0x8(%ebp),%eax
    9b51:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    9b57:	8b 45 08             	mov    0x8(%ebp),%eax
    9b5a:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    9b61:	8b 45 08             	mov    0x8(%ebp),%eax
    9b64:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    9b6b:	8b 45 08             	mov    0x8(%ebp),%eax
    9b6e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9b75:	90                   	nop
    9b76:	5d                   	pop    %ebp
    9b77:	c3                   	ret    

00009b78 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    9b78:	55                   	push   %ebp
    9b79:	89 e5                	mov    %esp,%ebp
    9b7b:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    9b7e:	8b 45 08             	mov    0x8(%ebp),%eax
    9b81:	8b 40 08             	mov    0x8(%eax),%eax
    9b84:	85 c0                	test   %eax,%eax
    9b86:	75 18                	jne    9ba0 <lodepng_color_mode_alloc_palette+0x28>
    9b88:	83 ec 0c             	sub    $0xc,%esp
    9b8b:	68 00 04 00 00       	push   $0x400
    9b90:	e8 7b a8 ff ff       	call   4410 <lodepng_malloc>
    9b95:	83 c4 10             	add    $0x10,%esp
    9b98:	89 c2                	mov    %eax,%edx
    9b9a:	8b 45 08             	mov    0x8(%ebp),%eax
    9b9d:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    9ba0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ba3:	8b 40 08             	mov    0x8(%eax),%eax
    9ba6:	85 c0                	test   %eax,%eax
    9ba8:	74 65                	je     9c0f <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    9baa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9bb1:	eb 51                	jmp    9c04 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    9bb3:	8b 45 08             	mov    0x8(%ebp),%eax
    9bb6:	8b 40 08             	mov    0x8(%eax),%eax
    9bb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bbc:	c1 e2 02             	shl    $0x2,%edx
    9bbf:	01 d0                	add    %edx,%eax
    9bc1:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    9bc4:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc7:	8b 40 08             	mov    0x8(%eax),%eax
    9bca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bcd:	c1 e2 02             	shl    $0x2,%edx
    9bd0:	83 c2 01             	add    $0x1,%edx
    9bd3:	01 d0                	add    %edx,%eax
    9bd5:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    9bd8:	8b 45 08             	mov    0x8(%ebp),%eax
    9bdb:	8b 40 08             	mov    0x8(%eax),%eax
    9bde:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9be1:	c1 e2 02             	shl    $0x2,%edx
    9be4:	83 c2 02             	add    $0x2,%edx
    9be7:	01 d0                	add    %edx,%eax
    9be9:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    9bec:	8b 45 08             	mov    0x8(%ebp),%eax
    9bef:	8b 40 08             	mov    0x8(%eax),%eax
    9bf2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bf5:	c1 e2 02             	shl    $0x2,%edx
    9bf8:	83 c2 03             	add    $0x3,%edx
    9bfb:	01 d0                	add    %edx,%eax
    9bfd:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    9c00:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9c04:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    9c0b:	75 a6                	jne    9bb3 <lodepng_color_mode_alloc_palette+0x3b>
    9c0d:	eb 01                	jmp    9c10 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    9c0f:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    9c10:	c9                   	leave  
    9c11:	c3                   	ret    

00009c12 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    9c12:	55                   	push   %ebp
    9c13:	89 e5                	mov    %esp,%ebp
    9c15:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    9c18:	83 ec 0c             	sub    $0xc,%esp
    9c1b:	ff 75 08             	pushl  0x8(%ebp)
    9c1e:	e8 f3 01 00 00       	call   9e16 <lodepng_palette_clear>
    9c23:	83 c4 10             	add    $0x10,%esp
}
    9c26:	90                   	nop
    9c27:	c9                   	leave  
    9c28:	c3                   	ret    

00009c29 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    9c29:	55                   	push   %ebp
    9c2a:	89 e5                	mov    %esp,%ebp
    9c2c:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    9c2f:	83 ec 0c             	sub    $0xc,%esp
    9c32:	ff 75 08             	pushl  0x8(%ebp)
    9c35:	e8 d8 ff ff ff       	call   9c12 <lodepng_color_mode_cleanup>
    9c3a:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    9c3d:	83 ec 04             	sub    $0x4,%esp
    9c40:	6a 20                	push   $0x20
    9c42:	ff 75 0c             	pushl  0xc(%ebp)
    9c45:	ff 75 08             	pushl  0x8(%ebp)
    9c48:	e8 01 a8 ff ff       	call   444e <lodepng_memcpy>
    9c4d:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    9c50:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c53:	8b 40 08             	mov    0x8(%eax),%eax
    9c56:	85 c0                	test   %eax,%eax
    9c58:	74 5a                	je     9cb4 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    9c5a:	83 ec 0c             	sub    $0xc,%esp
    9c5d:	68 00 04 00 00       	push   $0x400
    9c62:	e8 a9 a7 ff ff       	call   4410 <lodepng_malloc>
    9c67:	83 c4 10             	add    $0x10,%esp
    9c6a:	89 c2                	mov    %eax,%edx
    9c6c:	8b 45 08             	mov    0x8(%ebp),%eax
    9c6f:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    9c72:	8b 45 08             	mov    0x8(%ebp),%eax
    9c75:	8b 40 08             	mov    0x8(%eax),%eax
    9c78:	85 c0                	test   %eax,%eax
    9c7a:	75 11                	jne    9c8d <lodepng_color_mode_copy+0x64>
    9c7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c7f:	8b 40 0c             	mov    0xc(%eax),%eax
    9c82:	85 c0                	test   %eax,%eax
    9c84:	74 07                	je     9c8d <lodepng_color_mode_copy+0x64>
    9c86:	b8 53 00 00 00       	mov    $0x53,%eax
    9c8b:	eb 2c                	jmp    9cb9 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    9c8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c90:	8b 40 0c             	mov    0xc(%eax),%eax
    9c93:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    9c9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c9d:	8b 50 08             	mov    0x8(%eax),%edx
    9ca0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca3:	8b 40 08             	mov    0x8(%eax),%eax
    9ca6:	83 ec 04             	sub    $0x4,%esp
    9ca9:	51                   	push   %ecx
    9caa:	52                   	push   %edx
    9cab:	50                   	push   %eax
    9cac:	e8 9d a7 ff ff       	call   444e <lodepng_memcpy>
    9cb1:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    9cb4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9cb9:	c9                   	leave  
    9cba:	c3                   	ret    

00009cbb <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    9cbb:	55                   	push   %ebp
    9cbc:	89 e5                	mov    %esp,%ebp
    9cbe:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    9cc1:	8d 45 e0             	lea    -0x20(%ebp),%eax
    9cc4:	50                   	push   %eax
    9cc5:	e8 55 fe ff ff       	call   9b1f <lodepng_color_mode_init>
    9cca:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    9ccd:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cd0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    9cd3:	8b 45 10             	mov    0x10(%ebp),%eax
    9cd6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    9cd9:	8b 45 08             	mov    0x8(%ebp),%eax
    9cdc:	8b 55 e0             	mov    -0x20(%ebp),%edx
    9cdf:	89 10                	mov    %edx,(%eax)
    9ce1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    9ce4:	89 50 04             	mov    %edx,0x4(%eax)
    9ce7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9cea:	89 50 08             	mov    %edx,0x8(%eax)
    9ced:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9cf0:	89 50 0c             	mov    %edx,0xc(%eax)
    9cf3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9cf6:	89 50 10             	mov    %edx,0x10(%eax)
    9cf9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cfc:	89 50 14             	mov    %edx,0x14(%eax)
    9cff:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9d02:	89 50 18             	mov    %edx,0x18(%eax)
    9d05:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9d08:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    9d0b:	8b 45 08             	mov    0x8(%ebp),%eax
    9d0e:	c9                   	leave  
    9d0f:	c2 04 00             	ret    $0x4

00009d12 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    9d12:	55                   	push   %ebp
    9d13:	89 e5                	mov    %esp,%ebp
    9d15:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    9d18:	8b 45 08             	mov    0x8(%ebp),%eax
    9d1b:	8b 10                	mov    (%eax),%edx
    9d1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d20:	8b 00                	mov    (%eax),%eax
    9d22:	39 c2                	cmp    %eax,%edx
    9d24:	74 0a                	je     9d30 <lodepng_color_mode_equal+0x1e>
    9d26:	b8 00 00 00 00       	mov    $0x0,%eax
    9d2b:	e9 e4 00 00 00       	jmp    9e14 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    9d30:	8b 45 08             	mov    0x8(%ebp),%eax
    9d33:	8b 50 04             	mov    0x4(%eax),%edx
    9d36:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d39:	8b 40 04             	mov    0x4(%eax),%eax
    9d3c:	39 c2                	cmp    %eax,%edx
    9d3e:	74 0a                	je     9d4a <lodepng_color_mode_equal+0x38>
    9d40:	b8 00 00 00 00       	mov    $0x0,%eax
    9d45:	e9 ca 00 00 00       	jmp    9e14 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    9d4a:	8b 45 08             	mov    0x8(%ebp),%eax
    9d4d:	8b 50 10             	mov    0x10(%eax),%edx
    9d50:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d53:	8b 40 10             	mov    0x10(%eax),%eax
    9d56:	39 c2                	cmp    %eax,%edx
    9d58:	74 0a                	je     9d64 <lodepng_color_mode_equal+0x52>
    9d5a:	b8 00 00 00 00       	mov    $0x0,%eax
    9d5f:	e9 b0 00 00 00       	jmp    9e14 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    9d64:	8b 45 08             	mov    0x8(%ebp),%eax
    9d67:	8b 40 10             	mov    0x10(%eax),%eax
    9d6a:	85 c0                	test   %eax,%eax
    9d6c:	74 48                	je     9db6 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    9d6e:	8b 45 08             	mov    0x8(%ebp),%eax
    9d71:	8b 50 14             	mov    0x14(%eax),%edx
    9d74:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d77:	8b 40 14             	mov    0x14(%eax),%eax
    9d7a:	39 c2                	cmp    %eax,%edx
    9d7c:	74 0a                	je     9d88 <lodepng_color_mode_equal+0x76>
    9d7e:	b8 00 00 00 00       	mov    $0x0,%eax
    9d83:	e9 8c 00 00 00       	jmp    9e14 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    9d88:	8b 45 08             	mov    0x8(%ebp),%eax
    9d8b:	8b 50 18             	mov    0x18(%eax),%edx
    9d8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d91:	8b 40 18             	mov    0x18(%eax),%eax
    9d94:	39 c2                	cmp    %eax,%edx
    9d96:	74 07                	je     9d9f <lodepng_color_mode_equal+0x8d>
    9d98:	b8 00 00 00 00       	mov    $0x0,%eax
    9d9d:	eb 75                	jmp    9e14 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    9d9f:	8b 45 08             	mov    0x8(%ebp),%eax
    9da2:	8b 50 1c             	mov    0x1c(%eax),%edx
    9da5:	8b 45 0c             	mov    0xc(%ebp),%eax
    9da8:	8b 40 1c             	mov    0x1c(%eax),%eax
    9dab:	39 c2                	cmp    %eax,%edx
    9dad:	74 07                	je     9db6 <lodepng_color_mode_equal+0xa4>
    9daf:	b8 00 00 00 00       	mov    $0x0,%eax
    9db4:	eb 5e                	jmp    9e14 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    9db6:	8b 45 08             	mov    0x8(%ebp),%eax
    9db9:	8b 50 0c             	mov    0xc(%eax),%edx
    9dbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    9dbf:	8b 40 0c             	mov    0xc(%eax),%eax
    9dc2:	39 c2                	cmp    %eax,%edx
    9dc4:	74 07                	je     9dcd <lodepng_color_mode_equal+0xbb>
    9dc6:	b8 00 00 00 00       	mov    $0x0,%eax
    9dcb:	eb 47                	jmp    9e14 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    9dcd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9dd4:	eb 2b                	jmp    9e01 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    9dd6:	8b 45 08             	mov    0x8(%ebp),%eax
    9dd9:	8b 50 08             	mov    0x8(%eax),%edx
    9ddc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9ddf:	01 d0                	add    %edx,%eax
    9de1:	0f b6 10             	movzbl (%eax),%edx
    9de4:	8b 45 0c             	mov    0xc(%ebp),%eax
    9de7:	8b 48 08             	mov    0x8(%eax),%ecx
    9dea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9ded:	01 c8                	add    %ecx,%eax
    9def:	0f b6 00             	movzbl (%eax),%eax
    9df2:	38 c2                	cmp    %al,%dl
    9df4:	74 07                	je     9dfd <lodepng_color_mode_equal+0xeb>
    9df6:	b8 00 00 00 00       	mov    $0x0,%eax
    9dfb:	eb 17                	jmp    9e14 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    9dfd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9e01:	8b 45 08             	mov    0x8(%ebp),%eax
    9e04:	8b 40 0c             	mov    0xc(%eax),%eax
    9e07:	c1 e0 02             	shl    $0x2,%eax
    9e0a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    9e0d:	75 c7                	jne    9dd6 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    9e0f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9e14:	c9                   	leave  
    9e15:	c3                   	ret    

00009e16 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    9e16:	55                   	push   %ebp
    9e17:	89 e5                	mov    %esp,%ebp
    9e19:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    9e1c:	8b 45 08             	mov    0x8(%ebp),%eax
    9e1f:	8b 40 08             	mov    0x8(%eax),%eax
    9e22:	85 c0                	test   %eax,%eax
    9e24:	74 12                	je     9e38 <lodepng_palette_clear+0x22>
    9e26:	8b 45 08             	mov    0x8(%ebp),%eax
    9e29:	8b 40 08             	mov    0x8(%eax),%eax
    9e2c:	83 ec 0c             	sub    $0xc,%esp
    9e2f:	50                   	push   %eax
    9e30:	e8 fc a5 ff ff       	call   4431 <lodepng_free>
    9e35:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    9e38:	8b 45 08             	mov    0x8(%ebp),%eax
    9e3b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    9e42:	8b 45 08             	mov    0x8(%ebp),%eax
    9e45:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9e4c:	90                   	nop
    9e4d:	c9                   	leave  
    9e4e:	c3                   	ret    

00009e4f <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9e4f:	55                   	push   %ebp
    9e50:	89 e5                	mov    %esp,%ebp
    9e52:	53                   	push   %ebx
    9e53:	83 ec 14             	sub    $0x14,%esp
    9e56:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e59:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e5c:	8b 55 14             	mov    0x14(%ebp),%edx
    9e5f:	8b 45 18             	mov    0x18(%ebp),%eax
    9e62:	88 5d f4             	mov    %bl,-0xc(%ebp)
    9e65:	88 4d f0             	mov    %cl,-0x10(%ebp)
    9e68:	88 55 ec             	mov    %dl,-0x14(%ebp)
    9e6b:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    9e6e:	8b 45 08             	mov    0x8(%ebp),%eax
    9e71:	8b 40 08             	mov    0x8(%eax),%eax
    9e74:	85 c0                	test   %eax,%eax
    9e76:	75 22                	jne    9e9a <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    9e78:	83 ec 0c             	sub    $0xc,%esp
    9e7b:	ff 75 08             	pushl  0x8(%ebp)
    9e7e:	e8 f5 fc ff ff       	call   9b78 <lodepng_color_mode_alloc_palette>
    9e83:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    9e86:	8b 45 08             	mov    0x8(%ebp),%eax
    9e89:	8b 40 08             	mov    0x8(%eax),%eax
    9e8c:	85 c0                	test   %eax,%eax
    9e8e:	75 0a                	jne    9e9a <lodepng_palette_add+0x4b>
    9e90:	b8 53 00 00 00       	mov    $0x53,%eax
    9e95:	e9 8d 00 00 00       	jmp    9f27 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    9e9a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e9d:	8b 40 0c             	mov    0xc(%eax),%eax
    9ea0:	3d ff 00 00 00       	cmp    $0xff,%eax
    9ea5:	7e 07                	jle    9eae <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    9ea7:	b8 6c 00 00 00       	mov    $0x6c,%eax
    9eac:	eb 79                	jmp    9f27 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    9eae:	8b 45 08             	mov    0x8(%ebp),%eax
    9eb1:	8b 50 08             	mov    0x8(%eax),%edx
    9eb4:	8b 45 08             	mov    0x8(%ebp),%eax
    9eb7:	8b 40 0c             	mov    0xc(%eax),%eax
    9eba:	c1 e0 02             	shl    $0x2,%eax
    9ebd:	01 c2                	add    %eax,%edx
    9ebf:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    9ec3:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    9ec5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ec8:	8b 50 08             	mov    0x8(%eax),%edx
    9ecb:	8b 45 08             	mov    0x8(%ebp),%eax
    9ece:	8b 40 0c             	mov    0xc(%eax),%eax
    9ed1:	c1 e0 02             	shl    $0x2,%eax
    9ed4:	83 c0 01             	add    $0x1,%eax
    9ed7:	01 c2                	add    %eax,%edx
    9ed9:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    9edd:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    9edf:	8b 45 08             	mov    0x8(%ebp),%eax
    9ee2:	8b 50 08             	mov    0x8(%eax),%edx
    9ee5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ee8:	8b 40 0c             	mov    0xc(%eax),%eax
    9eeb:	c1 e0 02             	shl    $0x2,%eax
    9eee:	83 c0 02             	add    $0x2,%eax
    9ef1:	01 c2                	add    %eax,%edx
    9ef3:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    9ef7:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    9ef9:	8b 45 08             	mov    0x8(%ebp),%eax
    9efc:	8b 50 08             	mov    0x8(%eax),%edx
    9eff:	8b 45 08             	mov    0x8(%ebp),%eax
    9f02:	8b 40 0c             	mov    0xc(%eax),%eax
    9f05:	c1 e0 02             	shl    $0x2,%eax
    9f08:	83 c0 03             	add    $0x3,%eax
    9f0b:	01 c2                	add    %eax,%edx
    9f0d:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9f11:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    9f13:	8b 45 08             	mov    0x8(%ebp),%eax
    9f16:	8b 40 0c             	mov    0xc(%eax),%eax
    9f19:	8d 50 01             	lea    0x1(%eax),%edx
    9f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    9f1f:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    9f22:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f27:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f2a:	c9                   	leave  
    9f2b:	c3                   	ret    

00009f2c <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    9f2c:	55                   	push   %ebp
    9f2d:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    9f2f:	8b 45 08             	mov    0x8(%ebp),%eax
    9f32:	8b 50 04             	mov    0x4(%eax),%edx
    9f35:	8b 45 08             	mov    0x8(%ebp),%eax
    9f38:	8b 00                	mov    (%eax),%eax
    9f3a:	52                   	push   %edx
    9f3b:	50                   	push   %eax
    9f3c:	e8 ca fb ff ff       	call   9b0b <lodepng_get_bpp_lct>
    9f41:	83 c4 08             	add    $0x8,%esp
}
    9f44:	c9                   	leave  
    9f45:	c3                   	ret    

00009f46 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    9f46:	55                   	push   %ebp
    9f47:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    9f49:	8b 45 08             	mov    0x8(%ebp),%eax
    9f4c:	8b 00                	mov    (%eax),%eax
    9f4e:	50                   	push   %eax
    9f4f:	e8 58 fb ff ff       	call   9aac <getNumColorChannels>
    9f54:	83 c4 04             	add    $0x4,%esp
}
    9f57:	c9                   	leave  
    9f58:	c3                   	ret    

00009f59 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    9f59:	55                   	push   %ebp
    9f5a:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    9f5c:	8b 45 08             	mov    0x8(%ebp),%eax
    9f5f:	8b 00                	mov    (%eax),%eax
    9f61:	85 c0                	test   %eax,%eax
    9f63:	74 0a                	je     9f6f <lodepng_is_greyscale_type+0x16>
    9f65:	8b 45 08             	mov    0x8(%ebp),%eax
    9f68:	8b 00                	mov    (%eax),%eax
    9f6a:	83 f8 04             	cmp    $0x4,%eax
    9f6d:	75 07                	jne    9f76 <lodepng_is_greyscale_type+0x1d>
    9f6f:	b8 01 00 00 00       	mov    $0x1,%eax
    9f74:	eb 05                	jmp    9f7b <lodepng_is_greyscale_type+0x22>
    9f76:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f7b:	5d                   	pop    %ebp
    9f7c:	c3                   	ret    

00009f7d <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    9f7d:	55                   	push   %ebp
    9f7e:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    9f80:	8b 45 08             	mov    0x8(%ebp),%eax
    9f83:	8b 00                	mov    (%eax),%eax
    9f85:	83 e0 04             	and    $0x4,%eax
    9f88:	85 c0                	test   %eax,%eax
    9f8a:	0f 95 c0             	setne  %al
    9f8d:	0f b6 c0             	movzbl %al,%eax
}
    9f90:	5d                   	pop    %ebp
    9f91:	c3                   	ret    

00009f92 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    9f92:	55                   	push   %ebp
    9f93:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    9f95:	8b 45 08             	mov    0x8(%ebp),%eax
    9f98:	8b 00                	mov    (%eax),%eax
    9f9a:	83 f8 03             	cmp    $0x3,%eax
    9f9d:	0f 94 c0             	sete   %al
    9fa0:	0f b6 c0             	movzbl %al,%eax
}
    9fa3:	5d                   	pop    %ebp
    9fa4:	c3                   	ret    

00009fa5 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    9fa5:	55                   	push   %ebp
    9fa6:	89 e5                	mov    %esp,%ebp
    9fa8:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9fab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9fb2:	eb 23                	jmp    9fd7 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    9fb4:	8b 45 08             	mov    0x8(%ebp),%eax
    9fb7:	8b 40 08             	mov    0x8(%eax),%eax
    9fba:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9fbd:	c1 e2 02             	shl    $0x2,%edx
    9fc0:	83 c2 03             	add    $0x3,%edx
    9fc3:	01 d0                	add    %edx,%eax
    9fc5:	0f b6 00             	movzbl (%eax),%eax
    9fc8:	3c ff                	cmp    $0xff,%al
    9fca:	74 07                	je     9fd3 <lodepng_has_palette_alpha+0x2e>
    9fcc:	b8 01 00 00 00       	mov    $0x1,%eax
    9fd1:	eb 14                	jmp    9fe7 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9fd3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9fd7:	8b 45 08             	mov    0x8(%ebp),%eax
    9fda:	8b 40 0c             	mov    0xc(%eax),%eax
    9fdd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    9fe0:	75 d2                	jne    9fb4 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    9fe2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9fe7:	c9                   	leave  
    9fe8:	c3                   	ret    

00009fe9 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    9fe9:	55                   	push   %ebp
    9fea:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    9fec:	8b 45 08             	mov    0x8(%ebp),%eax
    9fef:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    9ff2:	85 c0                	test   %eax,%eax
    9ff4:	75 1e                	jne    a014 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    9ff6:	ff 75 08             	pushl  0x8(%ebp)
    9ff9:	e8 7f ff ff ff       	call   9f7d <lodepng_is_alpha_type>
    9ffe:	83 c4 04             	add    $0x4,%esp
    a001:	85 c0                	test   %eax,%eax
    a003:	75 0f                	jne    a014 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    a005:	ff 75 08             	pushl  0x8(%ebp)
    a008:	e8 98 ff ff ff       	call   9fa5 <lodepng_has_palette_alpha>
    a00d:	83 c4 04             	add    $0x4,%esp
    a010:	85 c0                	test   %eax,%eax
    a012:	74 07                	je     a01b <lodepng_can_have_alpha+0x32>
    a014:	b8 01 00 00 00       	mov    $0x1,%eax
    a019:	eb 05                	jmp    a020 <lodepng_can_have_alpha+0x37>
    a01b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a020:	c9                   	leave  
    a021:	c3                   	ret    

0000a022 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    a022:	55                   	push   %ebp
    a023:	89 e5                	mov    %esp,%ebp
    a025:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    a028:	ff 75 14             	pushl  0x14(%ebp)
    a02b:	ff 75 10             	pushl  0x10(%ebp)
    a02e:	e8 d8 fa ff ff       	call   9b0b <lodepng_get_bpp_lct>
    a033:	83 c4 08             	add    $0x8,%esp
    a036:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    a039:	8b 55 08             	mov    0x8(%ebp),%edx
    a03c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a03f:	0f af c2             	imul   %edx,%eax
    a042:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    a045:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a048:	c1 e8 03             	shr    $0x3,%eax
    a04b:	89 c2                	mov    %eax,%edx
    a04d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a050:	0f af c2             	imul   %edx,%eax
    a053:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a056:	89 d1                	mov    %edx,%ecx
    a058:	83 e1 07             	and    $0x7,%ecx
    a05b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a05e:	0f af d1             	imul   %ecx,%edx
    a061:	83 c2 07             	add    $0x7,%edx
    a064:	c1 ea 03             	shr    $0x3,%edx
    a067:	01 d0                	add    %edx,%eax
}
    a069:	c9                   	leave  
    a06a:	c3                   	ret    

0000a06b <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    a06b:	55                   	push   %ebp
    a06c:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    a06e:	8b 45 10             	mov    0x10(%ebp),%eax
    a071:	8b 50 04             	mov    0x4(%eax),%edx
    a074:	8b 45 10             	mov    0x10(%ebp),%eax
    a077:	8b 00                	mov    (%eax),%eax
    a079:	52                   	push   %edx
    a07a:	50                   	push   %eax
    a07b:	ff 75 0c             	pushl  0xc(%ebp)
    a07e:	ff 75 08             	pushl  0x8(%ebp)
    a081:	e8 9c ff ff ff       	call   a022 <lodepng_get_raw_size_lct>
    a086:	83 c4 10             	add    $0x10,%esp
}
    a089:	c9                   	leave  
    a08a:	c3                   	ret    

0000a08b <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    a08b:	55                   	push   %ebp
    a08c:	89 e5                	mov    %esp,%ebp
    a08e:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    a091:	8b 45 08             	mov    0x8(%ebp),%eax
    a094:	c1 e8 03             	shr    $0x3,%eax
    a097:	0f af 45 10          	imul   0x10(%ebp),%eax
    a09b:	8b 55 08             	mov    0x8(%ebp),%edx
    a09e:	83 e2 07             	and    $0x7,%edx
    a0a1:	0f af 55 10          	imul   0x10(%ebp),%edx
    a0a5:	83 c2 07             	add    $0x7,%edx
    a0a8:	c1 ea 03             	shr    $0x3,%edx
    a0ab:	01 d0                	add    %edx,%eax
    a0ad:	83 c0 01             	add    $0x1,%eax
    a0b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    a0b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a0b6:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    a0ba:	c9                   	leave  
    a0bb:	c3                   	ret    

0000a0bc <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    a0bc:	55                   	push   %ebp
    a0bd:	89 e5                	mov    %esp,%ebp
    a0bf:	53                   	push   %ebx
    a0c0:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    a0c3:	ff 75 10             	pushl  0x10(%ebp)
    a0c6:	e8 61 fe ff ff       	call   9f2c <lodepng_get_bpp>
    a0cb:	83 c4 04             	add    $0x4,%esp
    a0ce:	89 c3                	mov    %eax,%ebx
    a0d0:	ff 75 14             	pushl  0x14(%ebp)
    a0d3:	e8 54 fe ff ff       	call   9f2c <lodepng_get_bpp>
    a0d8:	83 c4 04             	add    $0x4,%esp
    a0db:	39 c3                	cmp    %eax,%ebx
    a0dd:	76 0d                	jbe    a0ec <lodepng_pixel_overflow+0x30>
    a0df:	ff 75 10             	pushl  0x10(%ebp)
    a0e2:	e8 45 fe ff ff       	call   9f2c <lodepng_get_bpp>
    a0e7:	83 c4 04             	add    $0x4,%esp
    a0ea:	eb 0b                	jmp    a0f7 <lodepng_pixel_overflow+0x3b>
    a0ec:	ff 75 14             	pushl  0x14(%ebp)
    a0ef:	e8 38 fe ff ff       	call   9f2c <lodepng_get_bpp>
    a0f4:	83 c4 04             	add    $0x4,%esp
    a0f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    a0fa:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0fd:	8b 45 08             	mov    0x8(%ebp),%eax
    a100:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    a103:	51                   	push   %ecx
    a104:	52                   	push   %edx
    a105:	50                   	push   %eax
    a106:	e8 e9 a3 ff ff       	call   44f4 <lodepng_mulofl>
    a10b:	83 c4 0c             	add    $0xc,%esp
    a10e:	85 c0                	test   %eax,%eax
    a110:	74 0a                	je     a11c <lodepng_pixel_overflow+0x60>
    a112:	b8 01 00 00 00       	mov    $0x1,%eax
    a117:	e9 b6 00 00 00       	jmp    a1d2 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    a11c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a11f:	8d 55 f0             	lea    -0x10(%ebp),%edx
    a122:	52                   	push   %edx
    a123:	6a 08                	push   $0x8
    a125:	50                   	push   %eax
    a126:	e8 c9 a3 ff ff       	call   44f4 <lodepng_mulofl>
    a12b:	83 c4 0c             	add    $0xc,%esp
    a12e:	85 c0                	test   %eax,%eax
    a130:	74 0a                	je     a13c <lodepng_pixel_overflow+0x80>
    a132:	b8 01 00 00 00       	mov    $0x1,%eax
    a137:	e9 96 00 00 00       	jmp    a1d2 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    a13c:	8b 45 08             	mov    0x8(%ebp),%eax
    a13f:	c1 e8 03             	shr    $0x3,%eax
    a142:	89 c2                	mov    %eax,%edx
    a144:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a147:	50                   	push   %eax
    a148:	ff 75 f8             	pushl  -0x8(%ebp)
    a14b:	52                   	push   %edx
    a14c:	e8 a3 a3 ff ff       	call   44f4 <lodepng_mulofl>
    a151:	83 c4 0c             	add    $0xc,%esp
    a154:	85 c0                	test   %eax,%eax
    a156:	74 07                	je     a15f <lodepng_pixel_overflow+0xa3>
    a158:	b8 01 00 00 00       	mov    $0x1,%eax
    a15d:	eb 73                	jmp    a1d2 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    a15f:	8b 45 08             	mov    0x8(%ebp),%eax
    a162:	83 e0 07             	and    $0x7,%eax
    a165:	89 c2                	mov    %eax,%edx
    a167:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a16a:	0f af c2             	imul   %edx,%eax
    a16d:	83 c0 07             	add    $0x7,%eax
    a170:	c1 e8 03             	shr    $0x3,%eax
    a173:	89 c1                	mov    %eax,%ecx
    a175:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a178:	8d 55 ec             	lea    -0x14(%ebp),%edx
    a17b:	52                   	push   %edx
    a17c:	51                   	push   %ecx
    a17d:	50                   	push   %eax
    a17e:	e8 51 a3 ff ff       	call   44d4 <lodepng_addofl>
    a183:	83 c4 0c             	add    $0xc,%esp
    a186:	85 c0                	test   %eax,%eax
    a188:	74 07                	je     a191 <lodepng_pixel_overflow+0xd5>
    a18a:	b8 01 00 00 00       	mov    $0x1,%eax
    a18f:	eb 41                	jmp    a1d2 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    a191:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a194:	8d 55 ec             	lea    -0x14(%ebp),%edx
    a197:	52                   	push   %edx
    a198:	6a 05                	push   $0x5
    a19a:	50                   	push   %eax
    a19b:	e8 34 a3 ff ff       	call   44d4 <lodepng_addofl>
    a1a0:	83 c4 0c             	add    $0xc,%esp
    a1a3:	85 c0                	test   %eax,%eax
    a1a5:	74 07                	je     a1ae <lodepng_pixel_overflow+0xf2>
    a1a7:	b8 01 00 00 00       	mov    $0x1,%eax
    a1ac:	eb 24                	jmp    a1d2 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    a1ae:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a1b4:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    a1b7:	51                   	push   %ecx
    a1b8:	52                   	push   %edx
    a1b9:	50                   	push   %eax
    a1ba:	e8 35 a3 ff ff       	call   44f4 <lodepng_mulofl>
    a1bf:	83 c4 0c             	add    $0xc,%esp
    a1c2:	85 c0                	test   %eax,%eax
    a1c4:	74 07                	je     a1cd <lodepng_pixel_overflow+0x111>
    a1c6:	b8 01 00 00 00       	mov    $0x1,%eax
    a1cb:	eb 05                	jmp    a1d2 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    a1cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a1d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a1d5:	c9                   	leave  
    a1d6:	c3                   	ret    

0000a1d7 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    a1d7:	55                   	push   %ebp
    a1d8:	89 e5                	mov    %esp,%ebp
    a1da:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    a1dd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    a1e4:	eb 15                	jmp    a1fb <LodePNGUnknownChunks_init+0x24>
    a1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a1ec:	83 c2 30             	add    $0x30,%edx
    a1ef:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    a1f6:	00 
    a1f7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a1fb:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    a1ff:	75 e5                	jne    a1e6 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    a201:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    a208:	eb 15                	jmp    a21f <LodePNGUnknownChunks_init+0x48>
    a20a:	8b 45 08             	mov    0x8(%ebp),%eax
    a20d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a210:	83 c2 34             	add    $0x34,%edx
    a213:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    a21a:	00 
    a21b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a21f:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    a223:	75 e5                	jne    a20a <LodePNGUnknownChunks_init+0x33>
}
    a225:	90                   	nop
    a226:	c9                   	leave  
    a227:	c3                   	ret    

0000a228 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    a228:	55                   	push   %ebp
    a229:	89 e5                	mov    %esp,%ebp
    a22b:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    a22e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a235:	eb 1d                	jmp    a254 <LodePNGUnknownChunks_cleanup+0x2c>
    a237:	8b 45 08             	mov    0x8(%ebp),%eax
    a23a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a23d:	83 c2 30             	add    $0x30,%edx
    a240:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    a244:	83 ec 0c             	sub    $0xc,%esp
    a247:	50                   	push   %eax
    a248:	e8 e4 a1 ff ff       	call   4431 <lodepng_free>
    a24d:	83 c4 10             	add    $0x10,%esp
    a250:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a254:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    a258:	75 dd                	jne    a237 <LodePNGUnknownChunks_cleanup+0xf>
}
    a25a:	90                   	nop
    a25b:	c9                   	leave  
    a25c:	c3                   	ret    

0000a25d <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    a25d:	55                   	push   %ebp
    a25e:	89 e5                	mov    %esp,%ebp
    a260:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    a263:	83 ec 0c             	sub    $0xc,%esp
    a266:	ff 75 08             	pushl  0x8(%ebp)
    a269:	e8 ba ff ff ff       	call   a228 <LodePNGUnknownChunks_cleanup>
    a26e:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    a271:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a278:	e9 b7 00 00 00       	jmp    a334 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    a27d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a280:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a283:	83 c2 34             	add    $0x34,%edx
    a286:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    a28a:	8b 45 08             	mov    0x8(%ebp),%eax
    a28d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    a290:	83 c1 34             	add    $0x34,%ecx
    a293:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    a297:	8b 45 0c             	mov    0xc(%ebp),%eax
    a29a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a29d:	83 c2 34             	add    $0x34,%edx
    a2a0:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    a2a4:	83 ec 0c             	sub    $0xc,%esp
    a2a7:	50                   	push   %eax
    a2a8:	e8 63 a1 ff ff       	call   4410 <lodepng_malloc>
    a2ad:	83 c4 10             	add    $0x10,%esp
    a2b0:	89 c1                	mov    %eax,%ecx
    a2b2:	8b 45 08             	mov    0x8(%ebp),%eax
    a2b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a2b8:	83 c2 30             	add    $0x30,%edx
    a2bb:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    a2bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a2c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a2c5:	83 c2 30             	add    $0x30,%edx
    a2c8:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    a2cc:	85 c0                	test   %eax,%eax
    a2ce:	75 18                	jne    a2e8 <LodePNGUnknownChunks_copy+0x8b>
    a2d0:	8b 45 08             	mov    0x8(%ebp),%eax
    a2d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a2d6:	83 c2 34             	add    $0x34,%edx
    a2d9:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    a2dd:	85 c0                	test   %eax,%eax
    a2df:	74 07                	je     a2e8 <LodePNGUnknownChunks_copy+0x8b>
    a2e1:	b8 53 00 00 00       	mov    $0x53,%eax
    a2e6:	eb 5b                	jmp    a343 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    a2e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    a2ef:	eb 2d                	jmp    a31e <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    a2f1:	8b 45 08             	mov    0x8(%ebp),%eax
    a2f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a2f7:	83 c2 30             	add    $0x30,%edx
    a2fa:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    a2fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a301:	01 c2                	add    %eax,%edx
    a303:	8b 45 0c             	mov    0xc(%ebp),%eax
    a306:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    a309:	83 c1 30             	add    $0x30,%ecx
    a30c:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    a310:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a313:	01 c8                	add    %ecx,%eax
    a315:	0f b6 00             	movzbl (%eax),%eax
    a318:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    a31a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    a31e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a321:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a324:	83 c2 34             	add    $0x34,%edx
    a327:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    a32b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    a32e:	7f c1                	jg     a2f1 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    a330:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a334:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    a338:	0f 85 3f ff ff ff    	jne    a27d <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    a33e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a343:	c9                   	leave  
    a344:	c3                   	ret    

0000a345 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    a345:	55                   	push   %ebp
    a346:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    a348:	8b 45 08             	mov    0x8(%ebp),%eax
    a34b:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    a352:	8b 45 08             	mov    0x8(%ebp),%eax
    a355:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    a35c:	8b 45 08             	mov    0x8(%ebp),%eax
    a35f:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    a366:	90                   	nop
    a367:	5d                   	pop    %ebp
    a368:	c3                   	ret    

0000a369 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    a369:	55                   	push   %ebp
    a36a:	89 e5                	mov    %esp,%ebp
    a36c:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    a36f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a376:	eb 38                	jmp    a3b0 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    a378:	8b 45 08             	mov    0x8(%ebp),%eax
    a37b:	8b 40 40             	mov    0x40(%eax),%eax
    a37e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a381:	c1 e2 02             	shl    $0x2,%edx
    a384:	01 d0                	add    %edx,%eax
    a386:	83 ec 0c             	sub    $0xc,%esp
    a389:	50                   	push   %eax
    a38a:	e8 75 a3 ff ff       	call   4704 <string_cleanup>
    a38f:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    a392:	8b 45 08             	mov    0x8(%ebp),%eax
    a395:	8b 40 44             	mov    0x44(%eax),%eax
    a398:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a39b:	c1 e2 02             	shl    $0x2,%edx
    a39e:	01 d0                	add    %edx,%eax
    a3a0:	83 ec 0c             	sub    $0xc,%esp
    a3a3:	50                   	push   %eax
    a3a4:	e8 5b a3 ff ff       	call   4704 <string_cleanup>
    a3a9:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    a3ac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a3b0:	8b 45 08             	mov    0x8(%ebp),%eax
    a3b3:	8b 40 3c             	mov    0x3c(%eax),%eax
    a3b6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a3b9:	75 bd                	jne    a378 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    a3bb:	8b 45 08             	mov    0x8(%ebp),%eax
    a3be:	8b 40 40             	mov    0x40(%eax),%eax
    a3c1:	83 ec 0c             	sub    $0xc,%esp
    a3c4:	50                   	push   %eax
    a3c5:	e8 67 a0 ff ff       	call   4431 <lodepng_free>
    a3ca:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    a3cd:	8b 45 08             	mov    0x8(%ebp),%eax
    a3d0:	8b 40 44             	mov    0x44(%eax),%eax
    a3d3:	83 ec 0c             	sub    $0xc,%esp
    a3d6:	50                   	push   %eax
    a3d7:	e8 55 a0 ff ff       	call   4431 <lodepng_free>
    a3dc:	83 c4 10             	add    $0x10,%esp
}
    a3df:	90                   	nop
    a3e0:	c9                   	leave  
    a3e1:	c3                   	ret    

0000a3e2 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    a3e2:	55                   	push   %ebp
    a3e3:	89 e5                	mov    %esp,%ebp
    a3e5:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    a3e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    a3ef:	8b 45 08             	mov    0x8(%ebp),%eax
    a3f2:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    a3f9:	8b 45 08             	mov    0x8(%ebp),%eax
    a3fc:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    a403:	8b 45 08             	mov    0x8(%ebp),%eax
    a406:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    a40d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a414:	eb 42                	jmp    a458 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    a416:	8b 45 0c             	mov    0xc(%ebp),%eax
    a419:	8b 40 44             	mov    0x44(%eax),%eax
    a41c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a41f:	c1 e2 02             	shl    $0x2,%edx
    a422:	01 d0                	add    %edx,%eax
    a424:	8b 10                	mov    (%eax),%edx
    a426:	8b 45 0c             	mov    0xc(%ebp),%eax
    a429:	8b 40 40             	mov    0x40(%eax),%eax
    a42c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    a42f:	c1 e1 02             	shl    $0x2,%ecx
    a432:	01 c8                	add    %ecx,%eax
    a434:	8b 00                	mov    (%eax),%eax
    a436:	83 ec 04             	sub    $0x4,%esp
    a439:	52                   	push   %edx
    a43a:	50                   	push   %eax
    a43b:	ff 75 08             	pushl  0x8(%ebp)
    a43e:	e8 4d 01 00 00       	call   a590 <lodepng_add_text>
    a443:	83 c4 10             	add    $0x10,%esp
    a446:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a449:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a44d:	74 05                	je     a454 <LodePNGText_copy+0x72>
    a44f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a452:	eb 14                	jmp    a468 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    a454:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a458:	8b 45 0c             	mov    0xc(%ebp),%eax
    a45b:	8b 40 3c             	mov    0x3c(%eax),%eax
    a45e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a461:	75 b3                	jne    a416 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    a463:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a468:	c9                   	leave  
    a469:	c3                   	ret    

0000a46a <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    a46a:	55                   	push   %ebp
    a46b:	89 e5                	mov    %esp,%ebp
    a46d:	53                   	push   %ebx
    a46e:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    a471:	8b 45 08             	mov    0x8(%ebp),%eax
    a474:	8b 40 3c             	mov    0x3c(%eax),%eax
    a477:	83 c0 01             	add    $0x1,%eax
    a47a:	c1 e0 02             	shl    $0x2,%eax
    a47d:	89 c2                	mov    %eax,%edx
    a47f:	8b 45 08             	mov    0x8(%ebp),%eax
    a482:	8b 40 40             	mov    0x40(%eax),%eax
    a485:	52                   	push   %edx
    a486:	50                   	push   %eax
    a487:	e8 9b 9f ff ff       	call   4427 <lodepng_realloc>
    a48c:	83 c4 08             	add    $0x8,%esp
    a48f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    a492:	8b 45 08             	mov    0x8(%ebp),%eax
    a495:	8b 40 3c             	mov    0x3c(%eax),%eax
    a498:	83 c0 01             	add    $0x1,%eax
    a49b:	c1 e0 02             	shl    $0x2,%eax
    a49e:	89 c2                	mov    %eax,%edx
    a4a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a3:	8b 40 44             	mov    0x44(%eax),%eax
    a4a6:	52                   	push   %edx
    a4a7:	50                   	push   %eax
    a4a8:	e8 7a 9f ff ff       	call   4427 <lodepng_realloc>
    a4ad:	83 c4 08             	add    $0x8,%esp
    a4b0:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    a4b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a4b7:	74 09                	je     a4c2 <lodepng_add_text_sized+0x58>
    a4b9:	8b 45 08             	mov    0x8(%ebp),%eax
    a4bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a4bf:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    a4c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a4c6:	74 09                	je     a4d1 <lodepng_add_text_sized+0x67>
    a4c8:	8b 45 08             	mov    0x8(%ebp),%eax
    a4cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a4ce:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    a4d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a4d5:	74 06                	je     a4dd <lodepng_add_text_sized+0x73>
    a4d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a4db:	75 0a                	jne    a4e7 <lodepng_add_text_sized+0x7d>
    a4dd:	b8 53 00 00 00       	mov    $0x53,%eax
    a4e2:	e9 a4 00 00 00       	jmp    a58b <lodepng_add_text_sized+0x121>

  ++info->text_num;
    a4e7:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ea:	8b 40 3c             	mov    0x3c(%eax),%eax
    a4ed:	8d 50 01             	lea    0x1(%eax),%edx
    a4f0:	8b 45 08             	mov    0x8(%ebp),%eax
    a4f3:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    a4f6:	8b 45 08             	mov    0x8(%ebp),%eax
    a4f9:	8b 50 40             	mov    0x40(%eax),%edx
    a4fc:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ff:	8b 40 3c             	mov    0x3c(%eax),%eax
    a502:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a507:	c1 e0 02             	shl    $0x2,%eax
    a50a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a50d:	83 ec 0c             	sub    $0xc,%esp
    a510:	ff 75 0c             	pushl  0xc(%ebp)
    a513:	e8 54 a2 ff ff       	call   476c <alloc_string>
    a518:	83 c4 10             	add    $0x10,%esp
    a51b:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    a51d:	8b 45 08             	mov    0x8(%ebp),%eax
    a520:	8b 50 44             	mov    0x44(%eax),%edx
    a523:	8b 45 08             	mov    0x8(%ebp),%eax
    a526:	8b 40 3c             	mov    0x3c(%eax),%eax
    a529:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a52e:	c1 e0 02             	shl    $0x2,%eax
    a531:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a534:	83 ec 08             	sub    $0x8,%esp
    a537:	ff 75 14             	pushl  0x14(%ebp)
    a53a:	ff 75 10             	pushl  0x10(%ebp)
    a53d:	e8 e5 a1 ff ff       	call   4727 <alloc_string_sized>
    a542:	83 c4 10             	add    $0x10,%esp
    a545:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    a547:	8b 45 08             	mov    0x8(%ebp),%eax
    a54a:	8b 50 40             	mov    0x40(%eax),%edx
    a54d:	8b 45 08             	mov    0x8(%ebp),%eax
    a550:	8b 40 3c             	mov    0x3c(%eax),%eax
    a553:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a558:	c1 e0 02             	shl    $0x2,%eax
    a55b:	01 d0                	add    %edx,%eax
    a55d:	8b 00                	mov    (%eax),%eax
    a55f:	85 c0                	test   %eax,%eax
    a561:	74 1c                	je     a57f <lodepng_add_text_sized+0x115>
    a563:	8b 45 08             	mov    0x8(%ebp),%eax
    a566:	8b 50 44             	mov    0x44(%eax),%edx
    a569:	8b 45 08             	mov    0x8(%ebp),%eax
    a56c:	8b 40 3c             	mov    0x3c(%eax),%eax
    a56f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a574:	c1 e0 02             	shl    $0x2,%eax
    a577:	01 d0                	add    %edx,%eax
    a579:	8b 00                	mov    (%eax),%eax
    a57b:	85 c0                	test   %eax,%eax
    a57d:	75 07                	jne    a586 <lodepng_add_text_sized+0x11c>
    a57f:	b8 53 00 00 00       	mov    $0x53,%eax
    a584:	eb 05                	jmp    a58b <lodepng_add_text_sized+0x121>

  return 0;
    a586:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a58b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a58e:	c9                   	leave  
    a58f:	c3                   	ret    

0000a590 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    a590:	55                   	push   %ebp
    a591:	89 e5                	mov    %esp,%ebp
    a593:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    a596:	ff 75 10             	pushl  0x10(%ebp)
    a599:	e8 0e 9f ff ff       	call   44ac <lodepng_strlen>
    a59e:	83 c4 04             	add    $0x4,%esp
    a5a1:	50                   	push   %eax
    a5a2:	ff 75 10             	pushl  0x10(%ebp)
    a5a5:	ff 75 0c             	pushl  0xc(%ebp)
    a5a8:	ff 75 08             	pushl  0x8(%ebp)
    a5ab:	e8 ba fe ff ff       	call   a46a <lodepng_add_text_sized>
    a5b0:	83 c4 10             	add    $0x10,%esp
}
    a5b3:	c9                   	leave  
    a5b4:	c3                   	ret    

0000a5b5 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    a5b5:	55                   	push   %ebp
    a5b6:	89 e5                	mov    %esp,%ebp
    a5b8:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    a5bb:	83 ec 0c             	sub    $0xc,%esp
    a5be:	ff 75 08             	pushl  0x8(%ebp)
    a5c1:	e8 a3 fd ff ff       	call   a369 <LodePNGText_cleanup>
    a5c6:	83 c4 10             	add    $0x10,%esp
}
    a5c9:	90                   	nop
    a5ca:	c9                   	leave  
    a5cb:	c3                   	ret    

0000a5cc <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    a5cc:	55                   	push   %ebp
    a5cd:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    a5cf:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d2:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    a5d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a5dc:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    a5e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e6:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    a5ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f0:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    a5f7:	8b 45 08             	mov    0x8(%ebp),%eax
    a5fa:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    a601:	90                   	nop
    a602:	5d                   	pop    %ebp
    a603:	c3                   	ret    

0000a604 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    a604:	55                   	push   %ebp
    a605:	89 e5                	mov    %esp,%ebp
    a607:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    a60a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a611:	eb 6c                	jmp    a67f <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    a613:	8b 45 08             	mov    0x8(%ebp),%eax
    a616:	8b 40 4c             	mov    0x4c(%eax),%eax
    a619:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a61c:	c1 e2 02             	shl    $0x2,%edx
    a61f:	01 d0                	add    %edx,%eax
    a621:	83 ec 0c             	sub    $0xc,%esp
    a624:	50                   	push   %eax
    a625:	e8 da a0 ff ff       	call   4704 <string_cleanup>
    a62a:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    a62d:	8b 45 08             	mov    0x8(%ebp),%eax
    a630:	8b 40 50             	mov    0x50(%eax),%eax
    a633:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a636:	c1 e2 02             	shl    $0x2,%edx
    a639:	01 d0                	add    %edx,%eax
    a63b:	83 ec 0c             	sub    $0xc,%esp
    a63e:	50                   	push   %eax
    a63f:	e8 c0 a0 ff ff       	call   4704 <string_cleanup>
    a644:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    a647:	8b 45 08             	mov    0x8(%ebp),%eax
    a64a:	8b 40 54             	mov    0x54(%eax),%eax
    a64d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a650:	c1 e2 02             	shl    $0x2,%edx
    a653:	01 d0                	add    %edx,%eax
    a655:	83 ec 0c             	sub    $0xc,%esp
    a658:	50                   	push   %eax
    a659:	e8 a6 a0 ff ff       	call   4704 <string_cleanup>
    a65e:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    a661:	8b 45 08             	mov    0x8(%ebp),%eax
    a664:	8b 40 58             	mov    0x58(%eax),%eax
    a667:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a66a:	c1 e2 02             	shl    $0x2,%edx
    a66d:	01 d0                	add    %edx,%eax
    a66f:	83 ec 0c             	sub    $0xc,%esp
    a672:	50                   	push   %eax
    a673:	e8 8c a0 ff ff       	call   4704 <string_cleanup>
    a678:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    a67b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a67f:	8b 45 08             	mov    0x8(%ebp),%eax
    a682:	8b 40 48             	mov    0x48(%eax),%eax
    a685:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a688:	75 89                	jne    a613 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    a68a:	8b 45 08             	mov    0x8(%ebp),%eax
    a68d:	8b 40 4c             	mov    0x4c(%eax),%eax
    a690:	83 ec 0c             	sub    $0xc,%esp
    a693:	50                   	push   %eax
    a694:	e8 98 9d ff ff       	call   4431 <lodepng_free>
    a699:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    a69c:	8b 45 08             	mov    0x8(%ebp),%eax
    a69f:	8b 40 50             	mov    0x50(%eax),%eax
    a6a2:	83 ec 0c             	sub    $0xc,%esp
    a6a5:	50                   	push   %eax
    a6a6:	e8 86 9d ff ff       	call   4431 <lodepng_free>
    a6ab:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    a6ae:	8b 45 08             	mov    0x8(%ebp),%eax
    a6b1:	8b 40 54             	mov    0x54(%eax),%eax
    a6b4:	83 ec 0c             	sub    $0xc,%esp
    a6b7:	50                   	push   %eax
    a6b8:	e8 74 9d ff ff       	call   4431 <lodepng_free>
    a6bd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    a6c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a6c3:	8b 40 58             	mov    0x58(%eax),%eax
    a6c6:	83 ec 0c             	sub    $0xc,%esp
    a6c9:	50                   	push   %eax
    a6ca:	e8 62 9d ff ff       	call   4431 <lodepng_free>
    a6cf:	83 c4 10             	add    $0x10,%esp
}
    a6d2:	90                   	nop
    a6d3:	c9                   	leave  
    a6d4:	c3                   	ret    

0000a6d5 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    a6d5:	55                   	push   %ebp
    a6d6:	89 e5                	mov    %esp,%ebp
    a6d8:	56                   	push   %esi
    a6d9:	53                   	push   %ebx
    a6da:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    a6dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    a6e4:	8b 45 08             	mov    0x8(%ebp),%eax
    a6e7:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    a6ee:	8b 45 08             	mov    0x8(%ebp),%eax
    a6f1:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    a6f8:	8b 45 08             	mov    0x8(%ebp),%eax
    a6fb:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    a702:	8b 45 08             	mov    0x8(%ebp),%eax
    a705:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    a70c:	8b 45 08             	mov    0x8(%ebp),%eax
    a70f:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    a716:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a71d:	eb 64                	jmp    a783 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    a71f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a722:	8b 40 58             	mov    0x58(%eax),%eax
    a725:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a728:	c1 e2 02             	shl    $0x2,%edx
    a72b:	01 d0                	add    %edx,%eax
    a72d:	8b 18                	mov    (%eax),%ebx
    a72f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a732:	8b 40 54             	mov    0x54(%eax),%eax
    a735:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a738:	c1 e2 02             	shl    $0x2,%edx
    a73b:	01 d0                	add    %edx,%eax
    a73d:	8b 08                	mov    (%eax),%ecx
    a73f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a742:	8b 40 50             	mov    0x50(%eax),%eax
    a745:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a748:	c1 e2 02             	shl    $0x2,%edx
    a74b:	01 d0                	add    %edx,%eax
    a74d:	8b 10                	mov    (%eax),%edx
    a74f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a752:	8b 40 4c             	mov    0x4c(%eax),%eax
    a755:	8b 75 f4             	mov    -0xc(%ebp),%esi
    a758:	c1 e6 02             	shl    $0x2,%esi
    a75b:	01 f0                	add    %esi,%eax
    a75d:	8b 00                	mov    (%eax),%eax
    a75f:	83 ec 0c             	sub    $0xc,%esp
    a762:	53                   	push   %ebx
    a763:	51                   	push   %ecx
    a764:	52                   	push   %edx
    a765:	50                   	push   %eax
    a766:	ff 75 08             	pushl  0x8(%ebp)
    a769:	e8 e4 01 00 00       	call   a952 <lodepng_add_itext>
    a76e:	83 c4 20             	add    $0x20,%esp
    a771:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a774:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a778:	74 05                	je     a77f <LodePNGIText_copy+0xaa>
    a77a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a77d:	eb 14                	jmp    a793 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    a77f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a783:	8b 45 0c             	mov    0xc(%ebp),%eax
    a786:	8b 40 48             	mov    0x48(%eax),%eax
    a789:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a78c:	75 91                	jne    a71f <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    a78e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a793:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a796:	5b                   	pop    %ebx
    a797:	5e                   	pop    %esi
    a798:	5d                   	pop    %ebp
    a799:	c3                   	ret    

0000a79a <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    a79a:	55                   	push   %ebp
    a79b:	89 e5                	mov    %esp,%ebp
    a79d:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    a7a0:	83 ec 0c             	sub    $0xc,%esp
    a7a3:	ff 75 08             	pushl  0x8(%ebp)
    a7a6:	e8 59 fe ff ff       	call   a604 <LodePNGIText_cleanup>
    a7ab:	83 c4 10             	add    $0x10,%esp
}
    a7ae:	90                   	nop
    a7af:	c9                   	leave  
    a7b0:	c3                   	ret    

0000a7b1 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    a7b1:	55                   	push   %ebp
    a7b2:	89 e5                	mov    %esp,%ebp
    a7b4:	53                   	push   %ebx
    a7b5:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    a7b8:	8b 45 08             	mov    0x8(%ebp),%eax
    a7bb:	8b 40 48             	mov    0x48(%eax),%eax
    a7be:	83 c0 01             	add    $0x1,%eax
    a7c1:	c1 e0 02             	shl    $0x2,%eax
    a7c4:	89 c2                	mov    %eax,%edx
    a7c6:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c9:	8b 40 4c             	mov    0x4c(%eax),%eax
    a7cc:	52                   	push   %edx
    a7cd:	50                   	push   %eax
    a7ce:	e8 54 9c ff ff       	call   4427 <lodepng_realloc>
    a7d3:	83 c4 08             	add    $0x8,%esp
    a7d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    a7d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a7dc:	8b 40 48             	mov    0x48(%eax),%eax
    a7df:	83 c0 01             	add    $0x1,%eax
    a7e2:	c1 e0 02             	shl    $0x2,%eax
    a7e5:	89 c2                	mov    %eax,%edx
    a7e7:	8b 45 08             	mov    0x8(%ebp),%eax
    a7ea:	8b 40 50             	mov    0x50(%eax),%eax
    a7ed:	52                   	push   %edx
    a7ee:	50                   	push   %eax
    a7ef:	e8 33 9c ff ff       	call   4427 <lodepng_realloc>
    a7f4:	83 c4 08             	add    $0x8,%esp
    a7f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    a7fa:	8b 45 08             	mov    0x8(%ebp),%eax
    a7fd:	8b 40 48             	mov    0x48(%eax),%eax
    a800:	83 c0 01             	add    $0x1,%eax
    a803:	c1 e0 02             	shl    $0x2,%eax
    a806:	89 c2                	mov    %eax,%edx
    a808:	8b 45 08             	mov    0x8(%ebp),%eax
    a80b:	8b 40 54             	mov    0x54(%eax),%eax
    a80e:	52                   	push   %edx
    a80f:	50                   	push   %eax
    a810:	e8 12 9c ff ff       	call   4427 <lodepng_realloc>
    a815:	83 c4 08             	add    $0x8,%esp
    a818:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    a81b:	8b 45 08             	mov    0x8(%ebp),%eax
    a81e:	8b 40 48             	mov    0x48(%eax),%eax
    a821:	83 c0 01             	add    $0x1,%eax
    a824:	c1 e0 02             	shl    $0x2,%eax
    a827:	89 c2                	mov    %eax,%edx
    a829:	8b 45 08             	mov    0x8(%ebp),%eax
    a82c:	8b 40 58             	mov    0x58(%eax),%eax
    a82f:	52                   	push   %edx
    a830:	50                   	push   %eax
    a831:	e8 f1 9b ff ff       	call   4427 <lodepng_realloc>
    a836:	83 c4 08             	add    $0x8,%esp
    a839:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    a83c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a840:	74 09                	je     a84b <lodepng_add_itext_sized+0x9a>
    a842:	8b 45 08             	mov    0x8(%ebp),%eax
    a845:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a848:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    a84b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a84f:	74 09                	je     a85a <lodepng_add_itext_sized+0xa9>
    a851:	8b 45 08             	mov    0x8(%ebp),%eax
    a854:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a857:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    a85a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    a85e:	74 09                	je     a869 <lodepng_add_itext_sized+0xb8>
    a860:	8b 45 08             	mov    0x8(%ebp),%eax
    a863:	8b 55 ec             	mov    -0x14(%ebp),%edx
    a866:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    a869:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    a86d:	74 09                	je     a878 <lodepng_add_itext_sized+0xc7>
    a86f:	8b 45 08             	mov    0x8(%ebp),%eax
    a872:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a875:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    a878:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a87c:	74 12                	je     a890 <lodepng_add_itext_sized+0xdf>
    a87e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a882:	74 0c                	je     a890 <lodepng_add_itext_sized+0xdf>
    a884:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    a888:	74 06                	je     a890 <lodepng_add_itext_sized+0xdf>
    a88a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    a88e:	75 0a                	jne    a89a <lodepng_add_itext_sized+0xe9>
    a890:	b8 53 00 00 00       	mov    $0x53,%eax
    a895:	e9 b3 00 00 00       	jmp    a94d <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    a89a:	8b 45 08             	mov    0x8(%ebp),%eax
    a89d:	8b 40 48             	mov    0x48(%eax),%eax
    a8a0:	8d 50 01             	lea    0x1(%eax),%edx
    a8a3:	8b 45 08             	mov    0x8(%ebp),%eax
    a8a6:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    a8a9:	8b 45 08             	mov    0x8(%ebp),%eax
    a8ac:	8b 50 4c             	mov    0x4c(%eax),%edx
    a8af:	8b 45 08             	mov    0x8(%ebp),%eax
    a8b2:	8b 40 48             	mov    0x48(%eax),%eax
    a8b5:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a8ba:	c1 e0 02             	shl    $0x2,%eax
    a8bd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a8c0:	83 ec 0c             	sub    $0xc,%esp
    a8c3:	ff 75 0c             	pushl  0xc(%ebp)
    a8c6:	e8 a1 9e ff ff       	call   476c <alloc_string>
    a8cb:	83 c4 10             	add    $0x10,%esp
    a8ce:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    a8d0:	8b 45 08             	mov    0x8(%ebp),%eax
    a8d3:	8b 50 50             	mov    0x50(%eax),%edx
    a8d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a8d9:	8b 40 48             	mov    0x48(%eax),%eax
    a8dc:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a8e1:	c1 e0 02             	shl    $0x2,%eax
    a8e4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a8e7:	83 ec 0c             	sub    $0xc,%esp
    a8ea:	ff 75 10             	pushl  0x10(%ebp)
    a8ed:	e8 7a 9e ff ff       	call   476c <alloc_string>
    a8f2:	83 c4 10             	add    $0x10,%esp
    a8f5:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    a8f7:	8b 45 08             	mov    0x8(%ebp),%eax
    a8fa:	8b 50 54             	mov    0x54(%eax),%edx
    a8fd:	8b 45 08             	mov    0x8(%ebp),%eax
    a900:	8b 40 48             	mov    0x48(%eax),%eax
    a903:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a908:	c1 e0 02             	shl    $0x2,%eax
    a90b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a90e:	83 ec 0c             	sub    $0xc,%esp
    a911:	ff 75 14             	pushl  0x14(%ebp)
    a914:	e8 53 9e ff ff       	call   476c <alloc_string>
    a919:	83 c4 10             	add    $0x10,%esp
    a91c:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    a91e:	8b 45 08             	mov    0x8(%ebp),%eax
    a921:	8b 50 58             	mov    0x58(%eax),%edx
    a924:	8b 45 08             	mov    0x8(%ebp),%eax
    a927:	8b 40 48             	mov    0x48(%eax),%eax
    a92a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a92f:	c1 e0 02             	shl    $0x2,%eax
    a932:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a935:	83 ec 08             	sub    $0x8,%esp
    a938:	ff 75 1c             	pushl  0x1c(%ebp)
    a93b:	ff 75 18             	pushl  0x18(%ebp)
    a93e:	e8 e4 9d ff ff       	call   4727 <alloc_string_sized>
    a943:	83 c4 10             	add    $0x10,%esp
    a946:	89 03                	mov    %eax,(%ebx)

  return 0;
    a948:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a94d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a950:	c9                   	leave  
    a951:	c3                   	ret    

0000a952 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    a952:	55                   	push   %ebp
    a953:	89 e5                	mov    %esp,%ebp
    a955:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    a958:	ff 75 18             	pushl  0x18(%ebp)
    a95b:	e8 4c 9b ff ff       	call   44ac <lodepng_strlen>
    a960:	83 c4 04             	add    $0x4,%esp
    a963:	83 ec 08             	sub    $0x8,%esp
    a966:	50                   	push   %eax
    a967:	ff 75 18             	pushl  0x18(%ebp)
    a96a:	ff 75 14             	pushl  0x14(%ebp)
    a96d:	ff 75 10             	pushl  0x10(%ebp)
    a970:	ff 75 0c             	pushl  0xc(%ebp)
    a973:	ff 75 08             	pushl  0x8(%ebp)
    a976:	e8 36 fe ff ff       	call   a7b1 <lodepng_add_itext_sized>
    a97b:	83 c4 20             	add    $0x20,%esp
}
    a97e:	c9                   	leave  
    a97f:	c3                   	ret    

0000a980 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    a980:	55                   	push   %ebp
    a981:	89 e5                	mov    %esp,%ebp
    a983:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    a986:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    a98a:	75 0a                	jne    a996 <lodepng_assign_icc+0x16>
    a98c:	b8 64 00 00 00       	mov    $0x64,%eax
    a991:	e9 81 00 00 00       	jmp    aa17 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    a996:	83 ec 0c             	sub    $0xc,%esp
    a999:	ff 75 0c             	pushl  0xc(%ebp)
    a99c:	e8 cb 9d ff ff       	call   476c <alloc_string>
    a9a1:	83 c4 10             	add    $0x10,%esp
    a9a4:	89 c2                	mov    %eax,%edx
    a9a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a9a9:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    a9af:	8b 45 14             	mov    0x14(%ebp),%eax
    a9b2:	83 ec 0c             	sub    $0xc,%esp
    a9b5:	50                   	push   %eax
    a9b6:	e8 55 9a ff ff       	call   4410 <lodepng_malloc>
    a9bb:	83 c4 10             	add    $0x10,%esp
    a9be:	89 c2                	mov    %eax,%edx
    a9c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a9c3:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    a9c9:	8b 45 08             	mov    0x8(%ebp),%eax
    a9cc:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a9d2:	85 c0                	test   %eax,%eax
    a9d4:	74 0d                	je     a9e3 <lodepng_assign_icc+0x63>
    a9d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a9d9:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a9df:	85 c0                	test   %eax,%eax
    a9e1:	75 07                	jne    a9ea <lodepng_assign_icc+0x6a>
    a9e3:	b8 53 00 00 00       	mov    $0x53,%eax
    a9e8:	eb 2d                	jmp    aa17 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    a9ea:	8b 55 14             	mov    0x14(%ebp),%edx
    a9ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a9f0:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a9f6:	83 ec 04             	sub    $0x4,%esp
    a9f9:	52                   	push   %edx
    a9fa:	ff 75 10             	pushl  0x10(%ebp)
    a9fd:	50                   	push   %eax
    a9fe:	e8 4b 9a ff ff       	call   444e <lodepng_memcpy>
    aa03:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    aa06:	8b 45 08             	mov    0x8(%ebp),%eax
    aa09:	8b 55 14             	mov    0x14(%ebp),%edx
    aa0c:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    aa12:	b8 00 00 00 00       	mov    $0x0,%eax
}
    aa17:	c9                   	leave  
    aa18:	c3                   	ret    

0000aa19 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    aa19:	55                   	push   %ebp
    aa1a:	89 e5                	mov    %esp,%ebp
    aa1c:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    aa1f:	8b 45 08             	mov    0x8(%ebp),%eax
    aa22:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    aa28:	85 c0                	test   %eax,%eax
    aa2a:	74 0e                	je     aa3a <lodepng_set_icc+0x21>
    aa2c:	83 ec 0c             	sub    $0xc,%esp
    aa2f:	ff 75 08             	pushl  0x8(%ebp)
    aa32:	e8 26 00 00 00       	call   aa5d <lodepng_clear_icc>
    aa37:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    aa3a:	8b 45 08             	mov    0x8(%ebp),%eax
    aa3d:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    aa44:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    aa47:	ff 75 14             	pushl  0x14(%ebp)
    aa4a:	ff 75 10             	pushl  0x10(%ebp)
    aa4d:	ff 75 0c             	pushl  0xc(%ebp)
    aa50:	ff 75 08             	pushl  0x8(%ebp)
    aa53:	e8 28 ff ff ff       	call   a980 <lodepng_assign_icc>
    aa58:	83 c4 10             	add    $0x10,%esp
}
    aa5b:	c9                   	leave  
    aa5c:	c3                   	ret    

0000aa5d <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    aa5d:	55                   	push   %ebp
    aa5e:	89 e5                	mov    %esp,%ebp
    aa60:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    aa63:	8b 45 08             	mov    0x8(%ebp),%eax
    aa66:	05 c0 00 00 00       	add    $0xc0,%eax
    aa6b:	83 ec 0c             	sub    $0xc,%esp
    aa6e:	50                   	push   %eax
    aa6f:	e8 90 9c ff ff       	call   4704 <string_cleanup>
    aa74:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    aa77:	8b 45 08             	mov    0x8(%ebp),%eax
    aa7a:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    aa80:	83 ec 0c             	sub    $0xc,%esp
    aa83:	50                   	push   %eax
    aa84:	e8 a8 99 ff ff       	call   4431 <lodepng_free>
    aa89:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    aa8c:	8b 45 08             	mov    0x8(%ebp),%eax
    aa8f:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    aa96:	00 00 00 
  info->iccp_profile_size = 0;
    aa99:	8b 45 08             	mov    0x8(%ebp),%eax
    aa9c:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    aaa3:	00 00 00 
  info->iccp_defined = 0;
    aaa6:	8b 45 08             	mov    0x8(%ebp),%eax
    aaa9:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    aab0:	00 00 00 
}
    aab3:	90                   	nop
    aab4:	c9                   	leave  
    aab5:	c3                   	ret    

0000aab6 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    aab6:	55                   	push   %ebp
    aab7:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    aab9:	8b 45 08             	mov    0x8(%ebp),%eax
    aabc:	83 c0 0c             	add    $0xc,%eax
    aabf:	50                   	push   %eax
    aac0:	e8 5a f0 ff ff       	call   9b1f <lodepng_color_mode_init>
    aac5:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    aac8:	8b 45 08             	mov    0x8(%ebp),%eax
    aacb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    aad2:	8b 45 08             	mov    0x8(%ebp),%eax
    aad5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    aadb:	8b 45 08             	mov    0x8(%ebp),%eax
    aade:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    aae5:	8b 45 08             	mov    0x8(%ebp),%eax
    aae8:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    aaef:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf2:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    aaf9:	8b 45 08             	mov    0x8(%ebp),%eax
    aafc:	8b 50 38             	mov    0x38(%eax),%edx
    aaff:	8b 45 08             	mov    0x8(%ebp),%eax
    ab02:	89 50 34             	mov    %edx,0x34(%eax)
    ab05:	8b 45 08             	mov    0x8(%ebp),%eax
    ab08:	8b 50 34             	mov    0x34(%eax),%edx
    ab0b:	8b 45 08             	mov    0x8(%ebp),%eax
    ab0e:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    ab11:	ff 75 08             	pushl  0x8(%ebp)
    ab14:	e8 2c f8 ff ff       	call   a345 <LodePNGText_init>
    ab19:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    ab1c:	ff 75 08             	pushl  0x8(%ebp)
    ab1f:	e8 a8 fa ff ff       	call   a5cc <LodePNGIText_init>
    ab24:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    ab27:	8b 45 08             	mov    0x8(%ebp),%eax
    ab2a:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    ab31:	8b 45 08             	mov    0x8(%ebp),%eax
    ab34:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    ab3b:	8b 45 08             	mov    0x8(%ebp),%eax
    ab3e:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    ab45:	00 00 00 
  info->chrm_defined = 0;
    ab48:	8b 45 08             	mov    0x8(%ebp),%eax
    ab4b:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    ab52:	00 00 00 
  info->srgb_defined = 0;
    ab55:	8b 45 08             	mov    0x8(%ebp),%eax
    ab58:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    ab5f:	00 00 00 
  info->iccp_defined = 0;
    ab62:	8b 45 08             	mov    0x8(%ebp),%eax
    ab65:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    ab6c:	00 00 00 
  info->iccp_name = NULL;
    ab6f:	8b 45 08             	mov    0x8(%ebp),%eax
    ab72:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    ab79:	00 00 00 
  info->iccp_profile = NULL;
    ab7c:	8b 45 08             	mov    0x8(%ebp),%eax
    ab7f:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    ab86:	00 00 00 

  LodePNGUnknownChunks_init(info);
    ab89:	ff 75 08             	pushl  0x8(%ebp)
    ab8c:	e8 46 f6 ff ff       	call   a1d7 <LodePNGUnknownChunks_init>
    ab91:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    ab94:	90                   	nop
    ab95:	c9                   	leave  
    ab96:	c3                   	ret    

0000ab97 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    ab97:	55                   	push   %ebp
    ab98:	89 e5                	mov    %esp,%ebp
    ab9a:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    ab9d:	8b 45 08             	mov    0x8(%ebp),%eax
    aba0:	83 c0 0c             	add    $0xc,%eax
    aba3:	83 ec 0c             	sub    $0xc,%esp
    aba6:	50                   	push   %eax
    aba7:	e8 66 f0 ff ff       	call   9c12 <lodepng_color_mode_cleanup>
    abac:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    abaf:	83 ec 0c             	sub    $0xc,%esp
    abb2:	ff 75 08             	pushl  0x8(%ebp)
    abb5:	e8 af f7 ff ff       	call   a369 <LodePNGText_cleanup>
    abba:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    abbd:	83 ec 0c             	sub    $0xc,%esp
    abc0:	ff 75 08             	pushl  0x8(%ebp)
    abc3:	e8 3c fa ff ff       	call   a604 <LodePNGIText_cleanup>
    abc8:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    abcb:	83 ec 0c             	sub    $0xc,%esp
    abce:	ff 75 08             	pushl  0x8(%ebp)
    abd1:	e8 87 fe ff ff       	call   aa5d <lodepng_clear_icc>
    abd6:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    abd9:	83 ec 0c             	sub    $0xc,%esp
    abdc:	ff 75 08             	pushl  0x8(%ebp)
    abdf:	e8 44 f6 ff ff       	call   a228 <LodePNGUnknownChunks_cleanup>
    abe4:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    abe7:	90                   	nop
    abe8:	c9                   	leave  
    abe9:	c3                   	ret    

0000abea <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    abea:	55                   	push   %ebp
    abeb:	89 e5                	mov    %esp,%ebp
    abed:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    abf0:	83 ec 0c             	sub    $0xc,%esp
    abf3:	ff 75 08             	pushl  0x8(%ebp)
    abf6:	e8 9c ff ff ff       	call   ab97 <lodepng_info_cleanup>
    abfb:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    abfe:	83 ec 04             	sub    $0x4,%esp
    ac01:	68 e4 00 00 00       	push   $0xe4
    ac06:	ff 75 0c             	pushl  0xc(%ebp)
    ac09:	ff 75 08             	pushl  0x8(%ebp)
    ac0c:	e8 3d 98 ff ff       	call   444e <lodepng_memcpy>
    ac11:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    ac14:	8b 45 08             	mov    0x8(%ebp),%eax
    ac17:	83 c0 0c             	add    $0xc,%eax
    ac1a:	83 ec 0c             	sub    $0xc,%esp
    ac1d:	50                   	push   %eax
    ac1e:	e8 fc ee ff ff       	call   9b1f <lodepng_color_mode_init>
    ac23:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    ac26:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac29:	8d 50 0c             	lea    0xc(%eax),%edx
    ac2c:	8b 45 08             	mov    0x8(%ebp),%eax
    ac2f:	83 c0 0c             	add    $0xc,%eax
    ac32:	83 ec 08             	sub    $0x8,%esp
    ac35:	52                   	push   %edx
    ac36:	50                   	push   %eax
    ac37:	e8 ed ef ff ff       	call   9c29 <lodepng_color_mode_copy>
    ac3c:	83 c4 10             	add    $0x10,%esp
    ac3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ac42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ac46:	74 08                	je     ac50 <lodepng_info_copy+0x66>
    ac48:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac4b:	e9 b7 00 00 00       	jmp    ad07 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    ac50:	83 ec 08             	sub    $0x8,%esp
    ac53:	ff 75 0c             	pushl  0xc(%ebp)
    ac56:	ff 75 08             	pushl  0x8(%ebp)
    ac59:	e8 84 f7 ff ff       	call   a3e2 <LodePNGText_copy>
    ac5e:	83 c4 10             	add    $0x10,%esp
    ac61:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ac64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ac68:	74 08                	je     ac72 <lodepng_info_copy+0x88>
    ac6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ac6d:	e9 95 00 00 00       	jmp    ad07 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    ac72:	83 ec 08             	sub    $0x8,%esp
    ac75:	ff 75 0c             	pushl  0xc(%ebp)
    ac78:	ff 75 08             	pushl  0x8(%ebp)
    ac7b:	e8 55 fa ff ff       	call   a6d5 <LodePNGIText_copy>
    ac80:	83 c4 10             	add    $0x10,%esp
    ac83:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ac86:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ac8a:	74 05                	je     ac91 <lodepng_info_copy+0xa7>
    ac8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ac8f:	eb 76                	jmp    ad07 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    ac91:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac94:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    ac9a:	85 c0                	test   %eax,%eax
    ac9c:	74 37                	je     acd5 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    ac9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    aca1:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    aca7:	8b 45 0c             	mov    0xc(%ebp),%eax
    acaa:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    acb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    acb3:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    acb9:	51                   	push   %ecx
    acba:	52                   	push   %edx
    acbb:	50                   	push   %eax
    acbc:	ff 75 08             	pushl  0x8(%ebp)
    acbf:	e8 bc fc ff ff       	call   a980 <lodepng_assign_icc>
    acc4:	83 c4 10             	add    $0x10,%esp
    acc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    acca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    acce:	74 05                	je     acd5 <lodepng_info_copy+0xeb>
    acd0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    acd3:	eb 32                	jmp    ad07 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    acd5:	83 ec 0c             	sub    $0xc,%esp
    acd8:	ff 75 08             	pushl  0x8(%ebp)
    acdb:	e8 f7 f4 ff ff       	call   a1d7 <LodePNGUnknownChunks_init>
    ace0:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    ace3:	83 ec 08             	sub    $0x8,%esp
    ace6:	ff 75 0c             	pushl  0xc(%ebp)
    ace9:	ff 75 08             	pushl  0x8(%ebp)
    acec:	e8 6c f5 ff ff       	call   a25d <LodePNGUnknownChunks_copy>
    acf1:	83 c4 10             	add    $0x10,%esp
    acf4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    acf7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    acfb:	74 05                	je     ad02 <lodepng_info_copy+0x118>
    acfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ad00:	eb 05                	jmp    ad07 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    ad02:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ad07:	c9                   	leave  
    ad08:	c3                   	ret    

0000ad09 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    ad09:	55                   	push   %ebp
    ad0a:	89 e5                	mov    %esp,%ebp
    ad0c:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    ad0f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    ad13:	74 14                	je     ad29 <addColorBits+0x20>
    ad15:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    ad19:	75 07                	jne    ad22 <addColorBits+0x19>
    ad1b:	b8 03 00 00 00       	mov    $0x3,%eax
    ad20:	eb 0c                	jmp    ad2e <addColorBits+0x25>
    ad22:	b8 01 00 00 00       	mov    $0x1,%eax
    ad27:	eb 05                	jmp    ad2e <addColorBits+0x25>
    ad29:	b8 07 00 00 00       	mov    $0x7,%eax
    ad2e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    ad31:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad34:	23 45 fc             	and    -0x4(%ebp),%eax
    ad37:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    ad3a:	8b 45 10             	mov    0x10(%ebp),%eax
    ad3d:	ba 01 00 00 00       	mov    $0x1,%edx
    ad42:	89 c1                	mov    %eax,%ecx
    ad44:	d3 e2                	shl    %cl,%edx
    ad46:	89 d0                	mov    %edx,%eax
    ad48:	83 e8 01             	sub    $0x1,%eax
    ad4b:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    ad4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ad51:	2b 45 f8             	sub    -0x8(%ebp),%eax
    ad54:	0f af 45 10          	imul   0x10(%ebp),%eax
    ad58:	89 c1                	mov    %eax,%ecx
    ad5a:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    ad5d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    ad61:	75 18                	jne    ad7b <addColorBits+0x72>
    ad63:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad66:	0f af 45 10          	imul   0x10(%ebp),%eax
    ad6a:	c1 e8 03             	shr    $0x3,%eax
    ad6d:	89 c2                	mov    %eax,%edx
    ad6f:	8b 45 08             	mov    0x8(%ebp),%eax
    ad72:	01 d0                	add    %edx,%eax
    ad74:	8b 55 14             	mov    0x14(%ebp),%edx
    ad77:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    ad79:	eb 1e                	jmp    ad99 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    ad7b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad7e:	0f af 45 10          	imul   0x10(%ebp),%eax
    ad82:	c1 e8 03             	shr    $0x3,%eax
    ad85:	8b 55 08             	mov    0x8(%ebp),%edx
    ad88:	01 c2                	add    %eax,%edx
    ad8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ad8d:	01 c8                	add    %ecx,%eax
    ad8f:	0f b6 08             	movzbl (%eax),%ecx
    ad92:	8b 45 14             	mov    0x14(%ebp),%eax
    ad95:	09 c8                	or     %ecx,%eax
    ad97:	88 02                	mov    %al,(%edx)
}
    ad99:	90                   	nop
    ad9a:	c9                   	leave  
    ad9b:	c3                   	ret    

0000ad9c <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    ad9c:	55                   	push   %ebp
    ad9d:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    ad9f:	8b 45 08             	mov    0x8(%ebp),%eax
    ada2:	6a 40                	push   $0x40
    ada4:	6a 00                	push   $0x0
    ada6:	50                   	push   %eax
    ada7:	e8 d5 96 ff ff       	call   4481 <lodepng_memset>
    adac:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    adaf:	8b 45 08             	mov    0x8(%ebp),%eax
    adb2:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    adb9:	90                   	nop
    adba:	c9                   	leave  
    adbb:	c3                   	ret    

0000adbc <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    adbc:	55                   	push   %ebp
    adbd:	89 e5                	mov    %esp,%ebp
    adbf:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    adc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    adc9:	eb 3b                	jmp    ae06 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    adcb:	8b 45 08             	mov    0x8(%ebp),%eax
    adce:	8b 55 f4             	mov    -0xc(%ebp),%edx
    add1:	8b 04 90             	mov    (%eax,%edx,4),%eax
    add4:	85 c0                	test   %eax,%eax
    add6:	74 2a                	je     ae02 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    add8:	8b 45 08             	mov    0x8(%ebp),%eax
    addb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    adde:	8b 04 90             	mov    (%eax,%edx,4),%eax
    ade1:	83 ec 0c             	sub    $0xc,%esp
    ade4:	50                   	push   %eax
    ade5:	e8 d2 ff ff ff       	call   adbc <color_tree_cleanup>
    adea:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    aded:	8b 45 08             	mov    0x8(%ebp),%eax
    adf0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    adf3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    adf6:	83 ec 0c             	sub    $0xc,%esp
    adf9:	50                   	push   %eax
    adfa:	e8 32 96 ff ff       	call   4431 <lodepng_free>
    adff:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    ae02:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ae06:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    ae0a:	75 bf                	jne    adcb <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    ae0c:	90                   	nop
    ae0d:	c9                   	leave  
    ae0e:	c3                   	ret    

0000ae0f <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    ae0f:	55                   	push   %ebp
    ae10:	89 e5                	mov    %esp,%ebp
    ae12:	53                   	push   %ebx
    ae13:	83 ec 20             	sub    $0x20,%esp
    ae16:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ae19:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ae1c:	8b 55 14             	mov    0x14(%ebp),%edx
    ae1f:	8b 45 18             	mov    0x18(%ebp),%eax
    ae22:	88 5d e8             	mov    %bl,-0x18(%ebp)
    ae25:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    ae28:	88 55 e0             	mov    %dl,-0x20(%ebp)
    ae2b:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    ae2e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    ae35:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae3c:	eb 76                	jmp    aeb4 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    ae3e:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    ae42:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae45:	89 c1                	mov    %eax,%ecx
    ae47:	d3 fa                	sar    %cl,%edx
    ae49:	89 d0                	mov    %edx,%eax
    ae4b:	83 e0 01             	and    $0x1,%eax
    ae4e:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    ae51:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    ae55:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae58:	89 c1                	mov    %eax,%ecx
    ae5a:	d3 fa                	sar    %cl,%edx
    ae5c:	89 d0                	mov    %edx,%eax
    ae5e:	83 e0 01             	and    $0x1,%eax
    ae61:	01 d8                	add    %ebx,%eax
    ae63:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    ae66:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    ae6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae6d:	89 c1                	mov    %eax,%ecx
    ae6f:	d3 fa                	sar    %cl,%edx
    ae71:	89 d0                	mov    %edx,%eax
    ae73:	83 e0 01             	and    $0x1,%eax
    ae76:	01 d8                	add    %ebx,%eax
    ae78:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    ae7b:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    ae7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae82:	89 c1                	mov    %eax,%ecx
    ae84:	d3 fa                	sar    %cl,%edx
    ae86:	89 d0                	mov    %edx,%eax
    ae88:	83 e0 01             	and    $0x1,%eax
    ae8b:	01 d8                	add    %ebx,%eax
    ae8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    ae90:	8b 45 08             	mov    0x8(%ebp),%eax
    ae93:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ae96:	8b 04 90             	mov    (%eax,%edx,4),%eax
    ae99:	85 c0                	test   %eax,%eax
    ae9b:	75 07                	jne    aea4 <color_tree_get+0x95>
    ae9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    aea2:	eb 2a                	jmp    aece <color_tree_get+0xbf>
    else tree = tree->children[i];
    aea4:	8b 45 08             	mov    0x8(%ebp),%eax
    aea7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    aeaa:	8b 04 90             	mov    (%eax,%edx,4),%eax
    aead:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    aeb0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aeb4:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    aeb8:	7e 84                	jle    ae3e <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    aeba:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    aebe:	74 08                	je     aec8 <color_tree_get+0xb9>
    aec0:	8b 45 08             	mov    0x8(%ebp),%eax
    aec3:	8b 40 40             	mov    0x40(%eax),%eax
    aec6:	eb 05                	jmp    aecd <color_tree_get+0xbe>
    aec8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    aecd:	90                   	nop
}
    aece:	83 c4 20             	add    $0x20,%esp
    aed1:	5b                   	pop    %ebx
    aed2:	5d                   	pop    %ebp
    aed3:	c3                   	ret    

0000aed4 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    aed4:	55                   	push   %ebp
    aed5:	89 e5                	mov    %esp,%ebp
    aed7:	53                   	push   %ebx
    aed8:	83 ec 10             	sub    $0x10,%esp
    aedb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    aede:	8b 4d 10             	mov    0x10(%ebp),%ecx
    aee1:	8b 55 14             	mov    0x14(%ebp),%edx
    aee4:	8b 45 18             	mov    0x18(%ebp),%eax
    aee7:	88 5d f8             	mov    %bl,-0x8(%ebp)
    aeea:	88 4d f4             	mov    %cl,-0xc(%ebp)
    aeed:	88 55 f0             	mov    %dl,-0x10(%ebp)
    aef0:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    aef3:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    aef7:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    aefb:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    aeff:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    af03:	53                   	push   %ebx
    af04:	51                   	push   %ecx
    af05:	52                   	push   %edx
    af06:	50                   	push   %eax
    af07:	ff 75 08             	pushl  0x8(%ebp)
    af0a:	e8 00 ff ff ff       	call   ae0f <color_tree_get>
    af0f:	83 c4 14             	add    $0x14,%esp
    af12:	f7 d0                	not    %eax
    af14:	c1 e8 1f             	shr    $0x1f,%eax
    af17:	0f b6 c0             	movzbl %al,%eax
}
    af1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    af1d:	c9                   	leave  
    af1e:	c3                   	ret    

0000af1f <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    af1f:	55                   	push   %ebp
    af20:	89 e5                	mov    %esp,%ebp
    af22:	53                   	push   %ebx
    af23:	83 ec 24             	sub    $0x24,%esp
    af26:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    af29:	8b 4d 10             	mov    0x10(%ebp),%ecx
    af2c:	8b 55 14             	mov    0x14(%ebp),%edx
    af2f:	8b 45 18             	mov    0x18(%ebp),%eax
    af32:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    af35:	88 4d e0             	mov    %cl,-0x20(%ebp)
    af38:	88 55 dc             	mov    %dl,-0x24(%ebp)
    af3b:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    af3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    af45:	e9 b0 00 00 00       	jmp    affa <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    af4a:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    af4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af51:	89 c1                	mov    %eax,%ecx
    af53:	d3 fa                	sar    %cl,%edx
    af55:	89 d0                	mov    %edx,%eax
    af57:	83 e0 01             	and    $0x1,%eax
    af5a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    af5d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    af61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af64:	89 c1                	mov    %eax,%ecx
    af66:	d3 fa                	sar    %cl,%edx
    af68:	89 d0                	mov    %edx,%eax
    af6a:	83 e0 01             	and    $0x1,%eax
    af6d:	01 d8                	add    %ebx,%eax
    af6f:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    af72:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    af76:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af79:	89 c1                	mov    %eax,%ecx
    af7b:	d3 fa                	sar    %cl,%edx
    af7d:	89 d0                	mov    %edx,%eax
    af7f:	83 e0 01             	and    $0x1,%eax
    af82:	01 d8                	add    %ebx,%eax
    af84:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    af87:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    af8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af8e:	89 c1                	mov    %eax,%ecx
    af90:	d3 fa                	sar    %cl,%edx
    af92:	89 d0                	mov    %edx,%eax
    af94:	83 e0 01             	and    $0x1,%eax
    af97:	01 d8                	add    %ebx,%eax
    af99:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    af9c:	8b 45 08             	mov    0x8(%ebp),%eax
    af9f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    afa2:	8b 04 90             	mov    (%eax,%edx,4),%eax
    afa5:	85 c0                	test   %eax,%eax
    afa7:	75 41                	jne    afea <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    afa9:	83 ec 0c             	sub    $0xc,%esp
    afac:	6a 44                	push   $0x44
    afae:	e8 5d 94 ff ff       	call   4410 <lodepng_malloc>
    afb3:	83 c4 10             	add    $0x10,%esp
    afb6:	89 c1                	mov    %eax,%ecx
    afb8:	8b 45 08             	mov    0x8(%ebp),%eax
    afbb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    afbe:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    afc1:	8b 45 08             	mov    0x8(%ebp),%eax
    afc4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    afc7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    afca:	85 c0                	test   %eax,%eax
    afcc:	75 07                	jne    afd5 <color_tree_add+0xb6>
    afce:	b8 53 00 00 00       	mov    $0x53,%eax
    afd3:	eb 3d                	jmp    b012 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    afd5:	8b 45 08             	mov    0x8(%ebp),%eax
    afd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    afdb:	8b 04 90             	mov    (%eax,%edx,4),%eax
    afde:	83 ec 0c             	sub    $0xc,%esp
    afe1:	50                   	push   %eax
    afe2:	e8 b5 fd ff ff       	call   ad9c <color_tree_init>
    afe7:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    afea:	8b 45 08             	mov    0x8(%ebp),%eax
    afed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aff0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    aff3:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    aff6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    affa:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    affe:	0f 8e 46 ff ff ff    	jle    af4a <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    b004:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b007:	8b 45 08             	mov    0x8(%ebp),%eax
    b00a:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    b00d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b012:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b015:	c9                   	leave  
    b016:	c3                   	ret    

0000b017 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    b017:	55                   	push   %ebp
    b018:	89 e5                	mov    %esp,%ebp
    b01a:	53                   	push   %ebx
    b01b:	83 ec 20             	sub    $0x20,%esp
    b01e:	8b 5d 18             	mov    0x18(%ebp),%ebx
    b021:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    b024:	8b 55 20             	mov    0x20(%ebp),%edx
    b027:	8b 45 24             	mov    0x24(%ebp),%eax
    b02a:	88 5d e8             	mov    %bl,-0x18(%ebp)
    b02d:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    b030:	88 55 e0             	mov    %dl,-0x20(%ebp)
    b033:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    b036:	8b 45 10             	mov    0x10(%ebp),%eax
    b039:	8b 00                	mov    (%eax),%eax
    b03b:	85 c0                	test   %eax,%eax
    b03d:	0f 85 ad 00 00 00    	jne    b0f0 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    b043:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b047:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    b04a:	8b 45 10             	mov    0x10(%ebp),%eax
    b04d:	8b 40 04             	mov    0x4(%eax),%eax
    b050:	83 f8 08             	cmp    $0x8,%eax
    b053:	75 13                	jne    b068 <rgba8ToPixel+0x51>
    b055:	8b 55 0c             	mov    0xc(%ebp),%edx
    b058:	8b 45 08             	mov    0x8(%ebp),%eax
    b05b:	01 c2                	add    %eax,%edx
    b05d:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    b061:	88 02                	mov    %al,(%edx)
    b063:	e9 b4 03 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    b068:	8b 45 10             	mov    0x10(%ebp),%eax
    b06b:	8b 40 04             	mov    0x4(%eax),%eax
    b06e:	83 f8 10             	cmp    $0x10,%eax
    b071:	75 2a                	jne    b09d <rgba8ToPixel+0x86>
    b073:	8b 45 0c             	mov    0xc(%ebp),%eax
    b076:	01 c0                	add    %eax,%eax
    b078:	89 c2                	mov    %eax,%edx
    b07a:	8b 45 08             	mov    0x8(%ebp),%eax
    b07d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b080:	8b 45 0c             	mov    0xc(%ebp),%eax
    b083:	01 c0                	add    %eax,%eax
    b085:	8d 50 01             	lea    0x1(%eax),%edx
    b088:	8b 45 08             	mov    0x8(%ebp),%eax
    b08b:	01 d0                	add    %edx,%eax
    b08d:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    b091:	88 10                	mov    %dl,(%eax)
    b093:	0f b6 00             	movzbl (%eax),%eax
    b096:	88 01                	mov    %al,(%ecx)
    b098:	e9 7f 03 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    b09d:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    b0a1:	8b 45 10             	mov    0x10(%ebp),%eax
    b0a4:	8b 40 04             	mov    0x4(%eax),%eax
    b0a7:	b9 08 00 00 00       	mov    $0x8,%ecx
    b0ac:	29 c1                	sub    %eax,%ecx
    b0ae:	89 c8                	mov    %ecx,%eax
    b0b0:	89 c1                	mov    %eax,%ecx
    b0b2:	d3 ea                	shr    %cl,%edx
    b0b4:	89 d0                	mov    %edx,%eax
    b0b6:	89 c2                	mov    %eax,%edx
    b0b8:	8b 45 10             	mov    0x10(%ebp),%eax
    b0bb:	8b 40 04             	mov    0x4(%eax),%eax
    b0be:	bb 01 00 00 00       	mov    $0x1,%ebx
    b0c3:	89 c1                	mov    %eax,%ecx
    b0c5:	d3 e3                	shl    %cl,%ebx
    b0c7:	89 d8                	mov    %ebx,%eax
    b0c9:	83 e8 01             	sub    $0x1,%eax
    b0cc:	21 d0                	and    %edx,%eax
    b0ce:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    b0d1:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    b0d5:	8b 45 10             	mov    0x10(%ebp),%eax
    b0d8:	8b 40 04             	mov    0x4(%eax),%eax
    b0db:	52                   	push   %edx
    b0dc:	50                   	push   %eax
    b0dd:	ff 75 0c             	pushl  0xc(%ebp)
    b0e0:	ff 75 08             	pushl  0x8(%ebp)
    b0e3:	e8 21 fc ff ff       	call   ad09 <addColorBits>
    b0e8:	83 c4 10             	add    $0x10,%esp
    b0eb:	e9 2c 03 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    b0f0:	8b 45 10             	mov    0x10(%ebp),%eax
    b0f3:	8b 00                	mov    (%eax),%eax
    b0f5:	83 f8 02             	cmp    $0x2,%eax
    b0f8:	0f 85 ee 00 00 00    	jne    b1ec <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    b0fe:	8b 45 10             	mov    0x10(%ebp),%eax
    b101:	8b 40 04             	mov    0x4(%eax),%eax
    b104:	83 f8 08             	cmp    $0x8,%eax
    b107:	75 49                	jne    b152 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    b109:	8b 55 0c             	mov    0xc(%ebp),%edx
    b10c:	89 d0                	mov    %edx,%eax
    b10e:	01 c0                	add    %eax,%eax
    b110:	01 d0                	add    %edx,%eax
    b112:	89 c2                	mov    %eax,%edx
    b114:	8b 45 08             	mov    0x8(%ebp),%eax
    b117:	01 c2                	add    %eax,%edx
    b119:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b11d:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    b11f:	8b 55 0c             	mov    0xc(%ebp),%edx
    b122:	89 d0                	mov    %edx,%eax
    b124:	01 c0                	add    %eax,%eax
    b126:	01 d0                	add    %edx,%eax
    b128:	8d 50 01             	lea    0x1(%eax),%edx
    b12b:	8b 45 08             	mov    0x8(%ebp),%eax
    b12e:	01 c2                	add    %eax,%edx
    b130:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    b134:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    b136:	8b 55 0c             	mov    0xc(%ebp),%edx
    b139:	89 d0                	mov    %edx,%eax
    b13b:	01 c0                	add    %eax,%eax
    b13d:	01 d0                	add    %edx,%eax
    b13f:	8d 50 02             	lea    0x2(%eax),%edx
    b142:	8b 45 08             	mov    0x8(%ebp),%eax
    b145:	01 c2                	add    %eax,%edx
    b147:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    b14b:	88 02                	mov    %al,(%edx)
    b14d:	e9 ca 02 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    b152:	8b 55 0c             	mov    0xc(%ebp),%edx
    b155:	89 d0                	mov    %edx,%eax
    b157:	01 c0                	add    %eax,%eax
    b159:	01 d0                	add    %edx,%eax
    b15b:	01 c0                	add    %eax,%eax
    b15d:	89 c2                	mov    %eax,%edx
    b15f:	8b 45 08             	mov    0x8(%ebp),%eax
    b162:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b165:	8b 55 0c             	mov    0xc(%ebp),%edx
    b168:	89 d0                	mov    %edx,%eax
    b16a:	01 c0                	add    %eax,%eax
    b16c:	01 d0                	add    %edx,%eax
    b16e:	01 c0                	add    %eax,%eax
    b170:	8d 50 01             	lea    0x1(%eax),%edx
    b173:	8b 45 08             	mov    0x8(%ebp),%eax
    b176:	01 d0                	add    %edx,%eax
    b178:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    b17c:	88 10                	mov    %dl,(%eax)
    b17e:	0f b6 00             	movzbl (%eax),%eax
    b181:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    b183:	8b 55 0c             	mov    0xc(%ebp),%edx
    b186:	89 d0                	mov    %edx,%eax
    b188:	01 c0                	add    %eax,%eax
    b18a:	01 d0                	add    %edx,%eax
    b18c:	01 c0                	add    %eax,%eax
    b18e:	8d 50 02             	lea    0x2(%eax),%edx
    b191:	8b 45 08             	mov    0x8(%ebp),%eax
    b194:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b197:	8b 55 0c             	mov    0xc(%ebp),%edx
    b19a:	89 d0                	mov    %edx,%eax
    b19c:	01 c0                	add    %eax,%eax
    b19e:	01 d0                	add    %edx,%eax
    b1a0:	01 c0                	add    %eax,%eax
    b1a2:	8d 50 03             	lea    0x3(%eax),%edx
    b1a5:	8b 45 08             	mov    0x8(%ebp),%eax
    b1a8:	01 d0                	add    %edx,%eax
    b1aa:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b1ae:	88 10                	mov    %dl,(%eax)
    b1b0:	0f b6 00             	movzbl (%eax),%eax
    b1b3:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    b1b5:	8b 55 0c             	mov    0xc(%ebp),%edx
    b1b8:	89 d0                	mov    %edx,%eax
    b1ba:	01 c0                	add    %eax,%eax
    b1bc:	01 d0                	add    %edx,%eax
    b1be:	01 c0                	add    %eax,%eax
    b1c0:	8d 50 04             	lea    0x4(%eax),%edx
    b1c3:	8b 45 08             	mov    0x8(%ebp),%eax
    b1c6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b1c9:	8b 55 0c             	mov    0xc(%ebp),%edx
    b1cc:	89 d0                	mov    %edx,%eax
    b1ce:	01 c0                	add    %eax,%eax
    b1d0:	01 d0                	add    %edx,%eax
    b1d2:	01 c0                	add    %eax,%eax
    b1d4:	8d 50 05             	lea    0x5(%eax),%edx
    b1d7:	8b 45 08             	mov    0x8(%ebp),%eax
    b1da:	01 d0                	add    %edx,%eax
    b1dc:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    b1e0:	88 10                	mov    %dl,(%eax)
    b1e2:	0f b6 00             	movzbl (%eax),%eax
    b1e5:	88 01                	mov    %al,(%ecx)
    b1e7:	e9 30 02 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b1ec:	8b 45 10             	mov    0x10(%ebp),%eax
    b1ef:	8b 00                	mov    (%eax),%eax
    b1f1:	83 f8 03             	cmp    $0x3,%eax
    b1f4:	75 6d                	jne    b263 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    b1f6:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    b1fa:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    b1fe:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b202:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b206:	53                   	push   %ebx
    b207:	51                   	push   %ecx
    b208:	52                   	push   %edx
    b209:	50                   	push   %eax
    b20a:	ff 75 14             	pushl  0x14(%ebp)
    b20d:	e8 fd fb ff ff       	call   ae0f <color_tree_get>
    b212:	83 c4 14             	add    $0x14,%esp
    b215:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    b218:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    b21c:	79 0a                	jns    b228 <rgba8ToPixel+0x211>
    b21e:	b8 52 00 00 00       	mov    $0x52,%eax
    b223:	e9 f9 01 00 00       	jmp    b421 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    b228:	8b 45 10             	mov    0x10(%ebp),%eax
    b22b:	8b 40 04             	mov    0x4(%eax),%eax
    b22e:	83 f8 08             	cmp    $0x8,%eax
    b231:	75 12                	jne    b245 <rgba8ToPixel+0x22e>
    b233:	8b 55 0c             	mov    0xc(%ebp),%edx
    b236:	8b 45 08             	mov    0x8(%ebp),%eax
    b239:	01 d0                	add    %edx,%eax
    b23b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b23e:	88 10                	mov    %dl,(%eax)
    b240:	e9 d7 01 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    b245:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b248:	8b 45 10             	mov    0x10(%ebp),%eax
    b24b:	8b 40 04             	mov    0x4(%eax),%eax
    b24e:	52                   	push   %edx
    b24f:	50                   	push   %eax
    b250:	ff 75 0c             	pushl  0xc(%ebp)
    b253:	ff 75 08             	pushl  0x8(%ebp)
    b256:	e8 ae fa ff ff       	call   ad09 <addColorBits>
    b25b:	83 c4 10             	add    $0x10,%esp
    b25e:	e9 b9 01 00 00       	jmp    b41c <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b263:	8b 45 10             	mov    0x10(%ebp),%eax
    b266:	8b 00                	mov    (%eax),%eax
    b268:	83 f8 04             	cmp    $0x4,%eax
    b26b:	0f 85 9f 00 00 00    	jne    b310 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    b271:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b275:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    b278:	8b 45 10             	mov    0x10(%ebp),%eax
    b27b:	8b 40 04             	mov    0x4(%eax),%eax
    b27e:	83 f8 08             	cmp    $0x8,%eax
    b281:	75 2a                	jne    b2ad <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    b283:	8b 45 0c             	mov    0xc(%ebp),%eax
    b286:	01 c0                	add    %eax,%eax
    b288:	89 c2                	mov    %eax,%edx
    b28a:	8b 45 08             	mov    0x8(%ebp),%eax
    b28d:	01 c2                	add    %eax,%edx
    b28f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    b293:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    b295:	8b 45 0c             	mov    0xc(%ebp),%eax
    b298:	01 c0                	add    %eax,%eax
    b29a:	8d 50 01             	lea    0x1(%eax),%edx
    b29d:	8b 45 08             	mov    0x8(%ebp),%eax
    b2a0:	01 c2                	add    %eax,%edx
    b2a2:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    b2a6:	88 02                	mov    %al,(%edx)
    b2a8:	e9 6f 01 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    b2ad:	8b 45 10             	mov    0x10(%ebp),%eax
    b2b0:	8b 40 04             	mov    0x4(%eax),%eax
    b2b3:	83 f8 10             	cmp    $0x10,%eax
    b2b6:	0f 85 60 01 00 00    	jne    b41c <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    b2bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2bf:	c1 e0 02             	shl    $0x2,%eax
    b2c2:	89 c2                	mov    %eax,%edx
    b2c4:	8b 45 08             	mov    0x8(%ebp),%eax
    b2c7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b2ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2cd:	c1 e0 02             	shl    $0x2,%eax
    b2d0:	8d 50 01             	lea    0x1(%eax),%edx
    b2d3:	8b 45 08             	mov    0x8(%ebp),%eax
    b2d6:	01 d0                	add    %edx,%eax
    b2d8:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    b2dc:	88 10                	mov    %dl,(%eax)
    b2de:	0f b6 00             	movzbl (%eax),%eax
    b2e1:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    b2e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2e6:	c1 e0 02             	shl    $0x2,%eax
    b2e9:	8d 50 02             	lea    0x2(%eax),%edx
    b2ec:	8b 45 08             	mov    0x8(%ebp),%eax
    b2ef:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b2f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2f5:	c1 e0 02             	shl    $0x2,%eax
    b2f8:	8d 50 03             	lea    0x3(%eax),%edx
    b2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    b2fe:	01 d0                	add    %edx,%eax
    b300:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    b304:	88 10                	mov    %dl,(%eax)
    b306:	0f b6 00             	movzbl (%eax),%eax
    b309:	88 01                	mov    %al,(%ecx)
    b30b:	e9 0c 01 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    b310:	8b 45 10             	mov    0x10(%ebp),%eax
    b313:	8b 00                	mov    (%eax),%eax
    b315:	83 f8 06             	cmp    $0x6,%eax
    b318:	0f 85 fe 00 00 00    	jne    b41c <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    b31e:	8b 45 10             	mov    0x10(%ebp),%eax
    b321:	8b 40 04             	mov    0x4(%eax),%eax
    b324:	83 f8 08             	cmp    $0x8,%eax
    b327:	75 54                	jne    b37d <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    b329:	8b 45 0c             	mov    0xc(%ebp),%eax
    b32c:	c1 e0 02             	shl    $0x2,%eax
    b32f:	89 c2                	mov    %eax,%edx
    b331:	8b 45 08             	mov    0x8(%ebp),%eax
    b334:	01 c2                	add    %eax,%edx
    b336:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    b33a:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    b33c:	8b 45 0c             	mov    0xc(%ebp),%eax
    b33f:	c1 e0 02             	shl    $0x2,%eax
    b342:	8d 50 01             	lea    0x1(%eax),%edx
    b345:	8b 45 08             	mov    0x8(%ebp),%eax
    b348:	01 c2                	add    %eax,%edx
    b34a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    b34e:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    b350:	8b 45 0c             	mov    0xc(%ebp),%eax
    b353:	c1 e0 02             	shl    $0x2,%eax
    b356:	8d 50 02             	lea    0x2(%eax),%edx
    b359:	8b 45 08             	mov    0x8(%ebp),%eax
    b35c:	01 c2                	add    %eax,%edx
    b35e:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    b362:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    b364:	8b 45 0c             	mov    0xc(%ebp),%eax
    b367:	c1 e0 02             	shl    $0x2,%eax
    b36a:	8d 50 03             	lea    0x3(%eax),%edx
    b36d:	8b 45 08             	mov    0x8(%ebp),%eax
    b370:	01 c2                	add    %eax,%edx
    b372:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    b376:	88 02                	mov    %al,(%edx)
    b378:	e9 9f 00 00 00       	jmp    b41c <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    b37d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b380:	c1 e0 03             	shl    $0x3,%eax
    b383:	89 c2                	mov    %eax,%edx
    b385:	8b 45 08             	mov    0x8(%ebp),%eax
    b388:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b38b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b38e:	c1 e0 03             	shl    $0x3,%eax
    b391:	8d 50 01             	lea    0x1(%eax),%edx
    b394:	8b 45 08             	mov    0x8(%ebp),%eax
    b397:	01 d0                	add    %edx,%eax
    b399:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    b39d:	88 10                	mov    %dl,(%eax)
    b39f:	0f b6 00             	movzbl (%eax),%eax
    b3a2:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    b3a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    b3a7:	c1 e0 03             	shl    $0x3,%eax
    b3aa:	8d 50 02             	lea    0x2(%eax),%edx
    b3ad:	8b 45 08             	mov    0x8(%ebp),%eax
    b3b0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b3b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    b3b6:	c1 e0 03             	shl    $0x3,%eax
    b3b9:	8d 50 03             	lea    0x3(%eax),%edx
    b3bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b3bf:	01 d0                	add    %edx,%eax
    b3c1:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    b3c5:	88 10                	mov    %dl,(%eax)
    b3c7:	0f b6 00             	movzbl (%eax),%eax
    b3ca:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    b3cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    b3cf:	c1 e0 03             	shl    $0x3,%eax
    b3d2:	8d 50 04             	lea    0x4(%eax),%edx
    b3d5:	8b 45 08             	mov    0x8(%ebp),%eax
    b3d8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b3db:	8b 45 0c             	mov    0xc(%ebp),%eax
    b3de:	c1 e0 03             	shl    $0x3,%eax
    b3e1:	8d 50 05             	lea    0x5(%eax),%edx
    b3e4:	8b 45 08             	mov    0x8(%ebp),%eax
    b3e7:	01 d0                	add    %edx,%eax
    b3e9:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    b3ed:	88 10                	mov    %dl,(%eax)
    b3ef:	0f b6 00             	movzbl (%eax),%eax
    b3f2:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    b3f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    b3f7:	c1 e0 03             	shl    $0x3,%eax
    b3fa:	8d 50 06             	lea    0x6(%eax),%edx
    b3fd:	8b 45 08             	mov    0x8(%ebp),%eax
    b400:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b403:	8b 45 0c             	mov    0xc(%ebp),%eax
    b406:	c1 e0 03             	shl    $0x3,%eax
    b409:	8d 50 07             	lea    0x7(%eax),%edx
    b40c:	8b 45 08             	mov    0x8(%ebp),%eax
    b40f:	01 d0                	add    %edx,%eax
    b411:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    b415:	88 10                	mov    %dl,(%eax)
    b417:	0f b6 00             	movzbl (%eax),%eax
    b41a:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    b41c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b421:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b424:	c9                   	leave  
    b425:	c3                   	ret    

0000b426 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    b426:	55                   	push   %ebp
    b427:	89 e5                	mov    %esp,%ebp
    b429:	53                   	push   %ebx
    b42a:	83 ec 20             	sub    $0x20,%esp
    b42d:	8b 5d 14             	mov    0x14(%ebp),%ebx
    b430:	8b 4d 18             	mov    0x18(%ebp),%ecx
    b433:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b436:	8b 45 20             	mov    0x20(%ebp),%eax
    b439:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    b43d:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    b441:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    b445:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    b449:	8b 45 10             	mov    0x10(%ebp),%eax
    b44c:	8b 00                	mov    (%eax),%eax
    b44e:	85 c0                	test   %eax,%eax
    b450:	75 36                	jne    b488 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    b452:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    b456:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    b45a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b45d:	01 c0                	add    %eax,%eax
    b45f:	89 c2                	mov    %eax,%edx
    b461:	8b 45 08             	mov    0x8(%ebp),%eax
    b464:	01 d0                	add    %edx,%eax
    b466:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    b46a:	66 c1 ea 08          	shr    $0x8,%dx
    b46e:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    b470:	8b 45 0c             	mov    0xc(%ebp),%eax
    b473:	01 c0                	add    %eax,%eax
    b475:	8d 50 01             	lea    0x1(%eax),%edx
    b478:	8b 45 08             	mov    0x8(%ebp),%eax
    b47b:	01 d0                	add    %edx,%eax
    b47d:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    b481:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    b483:	e9 df 01 00 00       	jmp    b667 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    b488:	8b 45 10             	mov    0x10(%ebp),%eax
    b48b:	8b 00                	mov    (%eax),%eax
    b48d:	83 f8 02             	cmp    $0x2,%eax
    b490:	0f 85 a6 00 00 00    	jne    b53c <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    b496:	8b 55 0c             	mov    0xc(%ebp),%edx
    b499:	89 d0                	mov    %edx,%eax
    b49b:	01 c0                	add    %eax,%eax
    b49d:	01 d0                	add    %edx,%eax
    b49f:	01 c0                	add    %eax,%eax
    b4a1:	89 c2                	mov    %eax,%edx
    b4a3:	8b 45 08             	mov    0x8(%ebp),%eax
    b4a6:	01 d0                	add    %edx,%eax
    b4a8:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    b4ac:	66 c1 ea 08          	shr    $0x8,%dx
    b4b0:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    b4b2:	8b 55 0c             	mov    0xc(%ebp),%edx
    b4b5:	89 d0                	mov    %edx,%eax
    b4b7:	01 c0                	add    %eax,%eax
    b4b9:	01 d0                	add    %edx,%eax
    b4bb:	01 c0                	add    %eax,%eax
    b4bd:	8d 50 01             	lea    0x1(%eax),%edx
    b4c0:	8b 45 08             	mov    0x8(%ebp),%eax
    b4c3:	01 d0                	add    %edx,%eax
    b4c5:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    b4c9:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    b4cb:	8b 55 0c             	mov    0xc(%ebp),%edx
    b4ce:	89 d0                	mov    %edx,%eax
    b4d0:	01 c0                	add    %eax,%eax
    b4d2:	01 d0                	add    %edx,%eax
    b4d4:	01 c0                	add    %eax,%eax
    b4d6:	8d 50 02             	lea    0x2(%eax),%edx
    b4d9:	8b 45 08             	mov    0x8(%ebp),%eax
    b4dc:	01 d0                	add    %edx,%eax
    b4de:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    b4e2:	66 c1 ea 08          	shr    $0x8,%dx
    b4e6:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    b4e8:	8b 55 0c             	mov    0xc(%ebp),%edx
    b4eb:	89 d0                	mov    %edx,%eax
    b4ed:	01 c0                	add    %eax,%eax
    b4ef:	01 d0                	add    %edx,%eax
    b4f1:	01 c0                	add    %eax,%eax
    b4f3:	8d 50 03             	lea    0x3(%eax),%edx
    b4f6:	8b 45 08             	mov    0x8(%ebp),%eax
    b4f9:	01 d0                	add    %edx,%eax
    b4fb:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    b4ff:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    b501:	8b 55 0c             	mov    0xc(%ebp),%edx
    b504:	89 d0                	mov    %edx,%eax
    b506:	01 c0                	add    %eax,%eax
    b508:	01 d0                	add    %edx,%eax
    b50a:	01 c0                	add    %eax,%eax
    b50c:	8d 50 04             	lea    0x4(%eax),%edx
    b50f:	8b 45 08             	mov    0x8(%ebp),%eax
    b512:	01 d0                	add    %edx,%eax
    b514:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    b518:	66 c1 ea 08          	shr    $0x8,%dx
    b51c:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    b51e:	8b 55 0c             	mov    0xc(%ebp),%edx
    b521:	89 d0                	mov    %edx,%eax
    b523:	01 c0                	add    %eax,%eax
    b525:	01 d0                	add    %edx,%eax
    b527:	01 c0                	add    %eax,%eax
    b529:	8d 50 05             	lea    0x5(%eax),%edx
    b52c:	8b 45 08             	mov    0x8(%ebp),%eax
    b52f:	01 d0                	add    %edx,%eax
    b531:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    b535:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    b537:	e9 2b 01 00 00       	jmp    b667 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b53c:	8b 45 10             	mov    0x10(%ebp),%eax
    b53f:	8b 00                	mov    (%eax),%eax
    b541:	83 f8 04             	cmp    $0x4,%eax
    b544:	75 64                	jne    b5aa <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    b546:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    b54a:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    b54e:	8b 45 0c             	mov    0xc(%ebp),%eax
    b551:	c1 e0 02             	shl    $0x2,%eax
    b554:	89 c2                	mov    %eax,%edx
    b556:	8b 45 08             	mov    0x8(%ebp),%eax
    b559:	01 d0                	add    %edx,%eax
    b55b:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    b55f:	66 c1 ea 08          	shr    $0x8,%dx
    b563:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    b565:	8b 45 0c             	mov    0xc(%ebp),%eax
    b568:	c1 e0 02             	shl    $0x2,%eax
    b56b:	8d 50 01             	lea    0x1(%eax),%edx
    b56e:	8b 45 08             	mov    0x8(%ebp),%eax
    b571:	01 d0                	add    %edx,%eax
    b573:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    b577:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    b579:	8b 45 0c             	mov    0xc(%ebp),%eax
    b57c:	c1 e0 02             	shl    $0x2,%eax
    b57f:	8d 50 02             	lea    0x2(%eax),%edx
    b582:	8b 45 08             	mov    0x8(%ebp),%eax
    b585:	01 d0                	add    %edx,%eax
    b587:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b58b:	66 c1 ea 08          	shr    $0x8,%dx
    b58f:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    b591:	8b 45 0c             	mov    0xc(%ebp),%eax
    b594:	c1 e0 02             	shl    $0x2,%eax
    b597:	8d 50 03             	lea    0x3(%eax),%edx
    b59a:	8b 45 08             	mov    0x8(%ebp),%eax
    b59d:	01 d0                	add    %edx,%eax
    b59f:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b5a3:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    b5a5:	e9 bd 00 00 00       	jmp    b667 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    b5aa:	8b 45 10             	mov    0x10(%ebp),%eax
    b5ad:	8b 00                	mov    (%eax),%eax
    b5af:	83 f8 06             	cmp    $0x6,%eax
    b5b2:	0f 85 af 00 00 00    	jne    b667 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    b5b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    b5bb:	c1 e0 03             	shl    $0x3,%eax
    b5be:	89 c2                	mov    %eax,%edx
    b5c0:	8b 45 08             	mov    0x8(%ebp),%eax
    b5c3:	01 d0                	add    %edx,%eax
    b5c5:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    b5c9:	66 c1 ea 08          	shr    $0x8,%dx
    b5cd:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    b5cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    b5d2:	c1 e0 03             	shl    $0x3,%eax
    b5d5:	8d 50 01             	lea    0x1(%eax),%edx
    b5d8:	8b 45 08             	mov    0x8(%ebp),%eax
    b5db:	01 d0                	add    %edx,%eax
    b5dd:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    b5e1:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    b5e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    b5e6:	c1 e0 03             	shl    $0x3,%eax
    b5e9:	8d 50 02             	lea    0x2(%eax),%edx
    b5ec:	8b 45 08             	mov    0x8(%ebp),%eax
    b5ef:	01 d0                	add    %edx,%eax
    b5f1:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    b5f5:	66 c1 ea 08          	shr    $0x8,%dx
    b5f9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    b5fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    b5fe:	c1 e0 03             	shl    $0x3,%eax
    b601:	8d 50 03             	lea    0x3(%eax),%edx
    b604:	8b 45 08             	mov    0x8(%ebp),%eax
    b607:	01 d0                	add    %edx,%eax
    b609:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    b60d:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    b60f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b612:	c1 e0 03             	shl    $0x3,%eax
    b615:	8d 50 04             	lea    0x4(%eax),%edx
    b618:	8b 45 08             	mov    0x8(%ebp),%eax
    b61b:	01 d0                	add    %edx,%eax
    b61d:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    b621:	66 c1 ea 08          	shr    $0x8,%dx
    b625:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    b627:	8b 45 0c             	mov    0xc(%ebp),%eax
    b62a:	c1 e0 03             	shl    $0x3,%eax
    b62d:	8d 50 05             	lea    0x5(%eax),%edx
    b630:	8b 45 08             	mov    0x8(%ebp),%eax
    b633:	01 d0                	add    %edx,%eax
    b635:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    b639:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    b63b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b63e:	c1 e0 03             	shl    $0x3,%eax
    b641:	8d 50 06             	lea    0x6(%eax),%edx
    b644:	8b 45 08             	mov    0x8(%ebp),%eax
    b647:	01 d0                	add    %edx,%eax
    b649:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b64d:	66 c1 ea 08          	shr    $0x8,%dx
    b651:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    b653:	8b 45 0c             	mov    0xc(%ebp),%eax
    b656:	c1 e0 03             	shl    $0x3,%eax
    b659:	8d 50 07             	lea    0x7(%eax),%edx
    b65c:	8b 45 08             	mov    0x8(%ebp),%eax
    b65f:	01 d0                	add    %edx,%eax
    b661:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b665:	88 10                	mov    %dl,(%eax)
  }
}
    b667:	90                   	nop
    b668:	83 c4 20             	add    $0x20,%esp
    b66b:	5b                   	pop    %ebx
    b66c:	5d                   	pop    %ebp
    b66d:	c3                   	ret    

0000b66e <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    b66e:	55                   	push   %ebp
    b66f:	89 e5                	mov    %esp,%ebp
    b671:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    b674:	8b 45 20             	mov    0x20(%ebp),%eax
    b677:	8b 00                	mov    (%eax),%eax
    b679:	85 c0                	test   %eax,%eax
    b67b:	0f 85 8c 01 00 00    	jne    b80d <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    b681:	8b 45 20             	mov    0x20(%ebp),%eax
    b684:	8b 40 04             	mov    0x4(%eax),%eax
    b687:	83 f8 08             	cmp    $0x8,%eax
    b68a:	75 59                	jne    b6e5 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    b68c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b68f:	8b 45 18             	mov    0x18(%ebp),%eax
    b692:	01 d0                	add    %edx,%eax
    b694:	0f b6 10             	movzbl (%eax),%edx
    b697:	8b 45 10             	mov    0x10(%ebp),%eax
    b69a:	88 10                	mov    %dl,(%eax)
    b69c:	8b 45 10             	mov    0x10(%ebp),%eax
    b69f:	0f b6 10             	movzbl (%eax),%edx
    b6a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    b6a5:	88 10                	mov    %dl,(%eax)
    b6a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    b6aa:	0f b6 10             	movzbl (%eax),%edx
    b6ad:	8b 45 08             	mov    0x8(%ebp),%eax
    b6b0:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    b6b2:	8b 45 20             	mov    0x20(%ebp),%eax
    b6b5:	8b 40 10             	mov    0x10(%eax),%eax
    b6b8:	85 c0                	test   %eax,%eax
    b6ba:	74 1e                	je     b6da <getPixelColorRGBA8+0x6c>
    b6bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b6bf:	0f b6 00             	movzbl (%eax),%eax
    b6c2:	0f b6 d0             	movzbl %al,%edx
    b6c5:	8b 45 20             	mov    0x20(%ebp),%eax
    b6c8:	8b 40 14             	mov    0x14(%eax),%eax
    b6cb:	39 c2                	cmp    %eax,%edx
    b6cd:	75 0b                	jne    b6da <getPixelColorRGBA8+0x6c>
    b6cf:	8b 45 14             	mov    0x14(%ebp),%eax
    b6d2:	c6 00 00             	movb   $0x0,(%eax)
    b6d5:	e9 5e 05 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b6da:	8b 45 14             	mov    0x14(%ebp),%eax
    b6dd:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b6e0:	e9 53 05 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    b6e5:	8b 45 20             	mov    0x20(%ebp),%eax
    b6e8:	8b 40 04             	mov    0x4(%eax),%eax
    b6eb:	83 f8 10             	cmp    $0x10,%eax
    b6ee:	0f 85 80 00 00 00    	jne    b774 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    b6f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6f7:	01 c0                	add    %eax,%eax
    b6f9:	89 c2                	mov    %eax,%edx
    b6fb:	8b 45 18             	mov    0x18(%ebp),%eax
    b6fe:	01 d0                	add    %edx,%eax
    b700:	0f b6 10             	movzbl (%eax),%edx
    b703:	8b 45 10             	mov    0x10(%ebp),%eax
    b706:	88 10                	mov    %dl,(%eax)
    b708:	8b 45 10             	mov    0x10(%ebp),%eax
    b70b:	0f b6 10             	movzbl (%eax),%edx
    b70e:	8b 45 0c             	mov    0xc(%ebp),%eax
    b711:	88 10                	mov    %dl,(%eax)
    b713:	8b 45 0c             	mov    0xc(%ebp),%eax
    b716:	0f b6 10             	movzbl (%eax),%edx
    b719:	8b 45 08             	mov    0x8(%ebp),%eax
    b71c:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b71e:	8b 45 20             	mov    0x20(%ebp),%eax
    b721:	8b 40 10             	mov    0x10(%eax),%eax
    b724:	85 c0                	test   %eax,%eax
    b726:	74 41                	je     b769 <getPixelColorRGBA8+0xfb>
    b728:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b72b:	01 c0                	add    %eax,%eax
    b72d:	89 c2                	mov    %eax,%edx
    b72f:	8b 45 18             	mov    0x18(%ebp),%eax
    b732:	01 d0                	add    %edx,%eax
    b734:	0f b6 00             	movzbl (%eax),%eax
    b737:	0f b6 c0             	movzbl %al,%eax
    b73a:	c1 e0 08             	shl    $0x8,%eax
    b73d:	89 c2                	mov    %eax,%edx
    b73f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b742:	01 c0                	add    %eax,%eax
    b744:	8d 48 01             	lea    0x1(%eax),%ecx
    b747:	8b 45 18             	mov    0x18(%ebp),%eax
    b74a:	01 c8                	add    %ecx,%eax
    b74c:	0f b6 00             	movzbl (%eax),%eax
    b74f:	0f b6 c0             	movzbl %al,%eax
    b752:	01 c2                	add    %eax,%edx
    b754:	8b 45 20             	mov    0x20(%ebp),%eax
    b757:	8b 40 14             	mov    0x14(%eax),%eax
    b75a:	39 c2                	cmp    %eax,%edx
    b75c:	75 0b                	jne    b769 <getPixelColorRGBA8+0xfb>
    b75e:	8b 45 14             	mov    0x14(%ebp),%eax
    b761:	c6 00 00             	movb   $0x0,(%eax)
    b764:	e9 cf 04 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b769:	8b 45 14             	mov    0x14(%ebp),%eax
    b76c:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b76f:	e9 c4 04 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b774:	8b 45 20             	mov    0x20(%ebp),%eax
    b777:	8b 40 04             	mov    0x4(%eax),%eax
    b77a:	ba 01 00 00 00       	mov    $0x1,%edx
    b77f:	89 c1                	mov    %eax,%ecx
    b781:	d3 e2                	shl    %cl,%edx
    b783:	89 d0                	mov    %edx,%eax
    b785:	83 e8 01             	sub    $0x1,%eax
    b788:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    b78b:	8b 45 20             	mov    0x20(%ebp),%eax
    b78e:	8b 50 04             	mov    0x4(%eax),%edx
    b791:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b794:	0f af c2             	imul   %edx,%eax
    b797:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b79a:	8b 45 20             	mov    0x20(%ebp),%eax
    b79d:	8b 40 04             	mov    0x4(%eax),%eax
    b7a0:	50                   	push   %eax
    b7a1:	ff 75 18             	pushl  0x18(%ebp)
    b7a4:	8d 45 f0             	lea    -0x10(%ebp),%eax
    b7a7:	50                   	push   %eax
    b7a8:	e8 06 db ff ff       	call   92b3 <readBitsFromReversedStream>
    b7ad:	83 c4 0c             	add    $0xc,%esp
    b7b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    b7b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b7b6:	89 d0                	mov    %edx,%eax
    b7b8:	c1 e0 08             	shl    $0x8,%eax
    b7bb:	29 d0                	sub    %edx,%eax
    b7bd:	ba 00 00 00 00       	mov    $0x0,%edx
    b7c2:	f7 75 f8             	divl   -0x8(%ebp)
    b7c5:	89 c2                	mov    %eax,%edx
    b7c7:	8b 45 10             	mov    0x10(%ebp),%eax
    b7ca:	88 10                	mov    %dl,(%eax)
    b7cc:	8b 45 10             	mov    0x10(%ebp),%eax
    b7cf:	0f b6 10             	movzbl (%eax),%edx
    b7d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    b7d5:	88 10                	mov    %dl,(%eax)
    b7d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    b7da:	0f b6 10             	movzbl (%eax),%edx
    b7dd:	8b 45 08             	mov    0x8(%ebp),%eax
    b7e0:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    b7e2:	8b 45 20             	mov    0x20(%ebp),%eax
    b7e5:	8b 40 10             	mov    0x10(%eax),%eax
    b7e8:	85 c0                	test   %eax,%eax
    b7ea:	74 16                	je     b802 <getPixelColorRGBA8+0x194>
    b7ec:	8b 45 20             	mov    0x20(%ebp),%eax
    b7ef:	8b 40 14             	mov    0x14(%eax),%eax
    b7f2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    b7f5:	75 0b                	jne    b802 <getPixelColorRGBA8+0x194>
    b7f7:	8b 45 14             	mov    0x14(%ebp),%eax
    b7fa:	c6 00 00             	movb   $0x0,(%eax)
    b7fd:	e9 36 04 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b802:	8b 45 14             	mov    0x14(%ebp),%eax
    b805:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b808:	e9 2b 04 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    b80d:	8b 45 20             	mov    0x20(%ebp),%eax
    b810:	8b 00                	mov    (%eax),%eax
    b812:	83 f8 02             	cmp    $0x2,%eax
    b815:	0f 85 f5 01 00 00    	jne    ba10 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    b81b:	8b 45 20             	mov    0x20(%ebp),%eax
    b81e:	8b 40 04             	mov    0x4(%eax),%eax
    b821:	83 f8 08             	cmp    $0x8,%eax
    b824:	0f 85 a3 00 00 00    	jne    b8cd <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    b82a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b82d:	89 d0                	mov    %edx,%eax
    b82f:	01 c0                	add    %eax,%eax
    b831:	01 d0                	add    %edx,%eax
    b833:	89 c2                	mov    %eax,%edx
    b835:	8b 45 18             	mov    0x18(%ebp),%eax
    b838:	01 d0                	add    %edx,%eax
    b83a:	0f b6 10             	movzbl (%eax),%edx
    b83d:	8b 45 08             	mov    0x8(%ebp),%eax
    b840:	88 10                	mov    %dl,(%eax)
    b842:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b845:	89 d0                	mov    %edx,%eax
    b847:	01 c0                	add    %eax,%eax
    b849:	01 d0                	add    %edx,%eax
    b84b:	8d 50 01             	lea    0x1(%eax),%edx
    b84e:	8b 45 18             	mov    0x18(%ebp),%eax
    b851:	01 d0                	add    %edx,%eax
    b853:	0f b6 10             	movzbl (%eax),%edx
    b856:	8b 45 0c             	mov    0xc(%ebp),%eax
    b859:	88 10                	mov    %dl,(%eax)
    b85b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b85e:	89 d0                	mov    %edx,%eax
    b860:	01 c0                	add    %eax,%eax
    b862:	01 d0                	add    %edx,%eax
    b864:	8d 50 02             	lea    0x2(%eax),%edx
    b867:	8b 45 18             	mov    0x18(%ebp),%eax
    b86a:	01 d0                	add    %edx,%eax
    b86c:	0f b6 10             	movzbl (%eax),%edx
    b86f:	8b 45 10             	mov    0x10(%ebp),%eax
    b872:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    b874:	8b 45 20             	mov    0x20(%ebp),%eax
    b877:	8b 40 10             	mov    0x10(%eax),%eax
    b87a:	85 c0                	test   %eax,%eax
    b87c:	74 44                	je     b8c2 <getPixelColorRGBA8+0x254>
    b87e:	8b 45 08             	mov    0x8(%ebp),%eax
    b881:	0f b6 00             	movzbl (%eax),%eax
    b884:	0f b6 d0             	movzbl %al,%edx
    b887:	8b 45 20             	mov    0x20(%ebp),%eax
    b88a:	8b 40 14             	mov    0x14(%eax),%eax
    b88d:	39 c2                	cmp    %eax,%edx
    b88f:	75 31                	jne    b8c2 <getPixelColorRGBA8+0x254>
    b891:	8b 45 0c             	mov    0xc(%ebp),%eax
    b894:	0f b6 00             	movzbl (%eax),%eax
    b897:	0f b6 d0             	movzbl %al,%edx
    b89a:	8b 45 20             	mov    0x20(%ebp),%eax
    b89d:	8b 40 18             	mov    0x18(%eax),%eax
    b8a0:	39 c2                	cmp    %eax,%edx
    b8a2:	75 1e                	jne    b8c2 <getPixelColorRGBA8+0x254>
    b8a4:	8b 45 10             	mov    0x10(%ebp),%eax
    b8a7:	0f b6 00             	movzbl (%eax),%eax
    b8aa:	0f b6 d0             	movzbl %al,%edx
    b8ad:	8b 45 20             	mov    0x20(%ebp),%eax
    b8b0:	8b 40 1c             	mov    0x1c(%eax),%eax
    b8b3:	39 c2                	cmp    %eax,%edx
    b8b5:	75 0b                	jne    b8c2 <getPixelColorRGBA8+0x254>
    b8b7:	8b 45 14             	mov    0x14(%ebp),%eax
    b8ba:	c6 00 00             	movb   $0x0,(%eax)
    b8bd:	e9 76 03 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b8c2:	8b 45 14             	mov    0x14(%ebp),%eax
    b8c5:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b8c8:	e9 6b 03 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    b8cd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8d0:	89 d0                	mov    %edx,%eax
    b8d2:	01 c0                	add    %eax,%eax
    b8d4:	01 d0                	add    %edx,%eax
    b8d6:	01 c0                	add    %eax,%eax
    b8d8:	89 c2                	mov    %eax,%edx
    b8da:	8b 45 18             	mov    0x18(%ebp),%eax
    b8dd:	01 d0                	add    %edx,%eax
    b8df:	0f b6 10             	movzbl (%eax),%edx
    b8e2:	8b 45 08             	mov    0x8(%ebp),%eax
    b8e5:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    b8e7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8ea:	89 d0                	mov    %edx,%eax
    b8ec:	01 c0                	add    %eax,%eax
    b8ee:	01 d0                	add    %edx,%eax
    b8f0:	01 c0                	add    %eax,%eax
    b8f2:	8d 50 02             	lea    0x2(%eax),%edx
    b8f5:	8b 45 18             	mov    0x18(%ebp),%eax
    b8f8:	01 d0                	add    %edx,%eax
    b8fa:	0f b6 10             	movzbl (%eax),%edx
    b8fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    b900:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    b902:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b905:	89 d0                	mov    %edx,%eax
    b907:	01 c0                	add    %eax,%eax
    b909:	01 d0                	add    %edx,%eax
    b90b:	01 c0                	add    %eax,%eax
    b90d:	8d 50 04             	lea    0x4(%eax),%edx
    b910:	8b 45 18             	mov    0x18(%ebp),%eax
    b913:	01 d0                	add    %edx,%eax
    b915:	0f b6 10             	movzbl (%eax),%edx
    b918:	8b 45 10             	mov    0x10(%ebp),%eax
    b91b:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b91d:	8b 45 20             	mov    0x20(%ebp),%eax
    b920:	8b 40 10             	mov    0x10(%eax),%eax
    b923:	85 c0                	test   %eax,%eax
    b925:	0f 84 da 00 00 00    	je     ba05 <getPixelColorRGBA8+0x397>
    b92b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b92e:	89 d0                	mov    %edx,%eax
    b930:	01 c0                	add    %eax,%eax
    b932:	01 d0                	add    %edx,%eax
    b934:	01 c0                	add    %eax,%eax
    b936:	89 c2                	mov    %eax,%edx
    b938:	8b 45 18             	mov    0x18(%ebp),%eax
    b93b:	01 d0                	add    %edx,%eax
    b93d:	0f b6 00             	movzbl (%eax),%eax
    b940:	0f b6 c0             	movzbl %al,%eax
    b943:	c1 e0 08             	shl    $0x8,%eax
    b946:	89 c1                	mov    %eax,%ecx
    b948:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b94b:	89 d0                	mov    %edx,%eax
    b94d:	01 c0                	add    %eax,%eax
    b94f:	01 d0                	add    %edx,%eax
    b951:	01 c0                	add    %eax,%eax
    b953:	8d 50 01             	lea    0x1(%eax),%edx
    b956:	8b 45 18             	mov    0x18(%ebp),%eax
    b959:	01 d0                	add    %edx,%eax
    b95b:	0f b6 00             	movzbl (%eax),%eax
    b95e:	0f b6 c0             	movzbl %al,%eax
    b961:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b964:	8b 45 20             	mov    0x20(%ebp),%eax
    b967:	8b 40 14             	mov    0x14(%eax),%eax
    b96a:	39 c2                	cmp    %eax,%edx
    b96c:	0f 85 93 00 00 00    	jne    ba05 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b972:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b975:	89 d0                	mov    %edx,%eax
    b977:	01 c0                	add    %eax,%eax
    b979:	01 d0                	add    %edx,%eax
    b97b:	01 c0                	add    %eax,%eax
    b97d:	8d 50 02             	lea    0x2(%eax),%edx
    b980:	8b 45 18             	mov    0x18(%ebp),%eax
    b983:	01 d0                	add    %edx,%eax
    b985:	0f b6 00             	movzbl (%eax),%eax
    b988:	0f b6 c0             	movzbl %al,%eax
    b98b:	c1 e0 08             	shl    $0x8,%eax
    b98e:	89 c1                	mov    %eax,%ecx
    b990:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b993:	89 d0                	mov    %edx,%eax
    b995:	01 c0                	add    %eax,%eax
    b997:	01 d0                	add    %edx,%eax
    b999:	01 c0                	add    %eax,%eax
    b99b:	8d 50 03             	lea    0x3(%eax),%edx
    b99e:	8b 45 18             	mov    0x18(%ebp),%eax
    b9a1:	01 d0                	add    %edx,%eax
    b9a3:	0f b6 00             	movzbl (%eax),%eax
    b9a6:	0f b6 c0             	movzbl %al,%eax
    b9a9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b9ac:	8b 45 20             	mov    0x20(%ebp),%eax
    b9af:	8b 40 18             	mov    0x18(%eax),%eax
    b9b2:	39 c2                	cmp    %eax,%edx
    b9b4:	75 4f                	jne    ba05 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b9b6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9b9:	89 d0                	mov    %edx,%eax
    b9bb:	01 c0                	add    %eax,%eax
    b9bd:	01 d0                	add    %edx,%eax
    b9bf:	01 c0                	add    %eax,%eax
    b9c1:	8d 50 04             	lea    0x4(%eax),%edx
    b9c4:	8b 45 18             	mov    0x18(%ebp),%eax
    b9c7:	01 d0                	add    %edx,%eax
    b9c9:	0f b6 00             	movzbl (%eax),%eax
    b9cc:	0f b6 c0             	movzbl %al,%eax
    b9cf:	c1 e0 08             	shl    $0x8,%eax
    b9d2:	89 c1                	mov    %eax,%ecx
    b9d4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9d7:	89 d0                	mov    %edx,%eax
    b9d9:	01 c0                	add    %eax,%eax
    b9db:	01 d0                	add    %edx,%eax
    b9dd:	01 c0                	add    %eax,%eax
    b9df:	8d 50 05             	lea    0x5(%eax),%edx
    b9e2:	8b 45 18             	mov    0x18(%ebp),%eax
    b9e5:	01 d0                	add    %edx,%eax
    b9e7:	0f b6 00             	movzbl (%eax),%eax
    b9ea:	0f b6 c0             	movzbl %al,%eax
    b9ed:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b9f0:	8b 45 20             	mov    0x20(%ebp),%eax
    b9f3:	8b 40 1c             	mov    0x1c(%eax),%eax
    b9f6:	39 c2                	cmp    %eax,%edx
    b9f8:	75 0b                	jne    ba05 <getPixelColorRGBA8+0x397>
    b9fa:	8b 45 14             	mov    0x14(%ebp),%eax
    b9fd:	c6 00 00             	movb   $0x0,(%eax)
    ba00:	e9 33 02 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ba05:	8b 45 14             	mov    0x14(%ebp),%eax
    ba08:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ba0b:	e9 28 02 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    ba10:	8b 45 20             	mov    0x20(%ebp),%eax
    ba13:	8b 00                	mov    (%eax),%eax
    ba15:	83 f8 03             	cmp    $0x3,%eax
    ba18:	0f 85 ac 00 00 00    	jne    baca <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    ba1e:	8b 45 20             	mov    0x20(%ebp),%eax
    ba21:	8b 40 04             	mov    0x4(%eax),%eax
    ba24:	83 f8 08             	cmp    $0x8,%eax
    ba27:	75 13                	jne    ba3c <getPixelColorRGBA8+0x3ce>
    ba29:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba2c:	8b 45 18             	mov    0x18(%ebp),%eax
    ba2f:	01 d0                	add    %edx,%eax
    ba31:	0f b6 00             	movzbl (%eax),%eax
    ba34:	0f b6 c0             	movzbl %al,%eax
    ba37:	89 45 fc             	mov    %eax,-0x4(%ebp)
    ba3a:	eb 28                	jmp    ba64 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    ba3c:	8b 45 20             	mov    0x20(%ebp),%eax
    ba3f:	8b 50 04             	mov    0x4(%eax),%edx
    ba42:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba45:	0f af c2             	imul   %edx,%eax
    ba48:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ba4b:	8b 45 20             	mov    0x20(%ebp),%eax
    ba4e:	8b 40 04             	mov    0x4(%eax),%eax
    ba51:	50                   	push   %eax
    ba52:	ff 75 18             	pushl  0x18(%ebp)
    ba55:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ba58:	50                   	push   %eax
    ba59:	e8 55 d8 ff ff       	call   92b3 <readBitsFromReversedStream>
    ba5e:	83 c4 0c             	add    $0xc,%esp
    ba61:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    ba64:	8b 45 20             	mov    0x20(%ebp),%eax
    ba67:	8b 40 08             	mov    0x8(%eax),%eax
    ba6a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ba6d:	c1 e2 02             	shl    $0x2,%edx
    ba70:	01 d0                	add    %edx,%eax
    ba72:	0f b6 10             	movzbl (%eax),%edx
    ba75:	8b 45 08             	mov    0x8(%ebp),%eax
    ba78:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    ba7a:	8b 45 20             	mov    0x20(%ebp),%eax
    ba7d:	8b 40 08             	mov    0x8(%eax),%eax
    ba80:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ba83:	c1 e2 02             	shl    $0x2,%edx
    ba86:	83 c2 01             	add    $0x1,%edx
    ba89:	01 d0                	add    %edx,%eax
    ba8b:	0f b6 10             	movzbl (%eax),%edx
    ba8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba91:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    ba93:	8b 45 20             	mov    0x20(%ebp),%eax
    ba96:	8b 40 08             	mov    0x8(%eax),%eax
    ba99:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ba9c:	c1 e2 02             	shl    $0x2,%edx
    ba9f:	83 c2 02             	add    $0x2,%edx
    baa2:	01 d0                	add    %edx,%eax
    baa4:	0f b6 10             	movzbl (%eax),%edx
    baa7:	8b 45 10             	mov    0x10(%ebp),%eax
    baaa:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    baac:	8b 45 20             	mov    0x20(%ebp),%eax
    baaf:	8b 40 08             	mov    0x8(%eax),%eax
    bab2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bab5:	c1 e2 02             	shl    $0x2,%edx
    bab8:	83 c2 03             	add    $0x3,%edx
    babb:	01 d0                	add    %edx,%eax
    babd:	0f b6 10             	movzbl (%eax),%edx
    bac0:	8b 45 14             	mov    0x14(%ebp),%eax
    bac3:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    bac5:	e9 6e 01 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    baca:	8b 45 20             	mov    0x20(%ebp),%eax
    bacd:	8b 00                	mov    (%eax),%eax
    bacf:	83 f8 04             	cmp    $0x4,%eax
    bad2:	0f 85 95 00 00 00    	jne    bb6d <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    bad8:	8b 45 20             	mov    0x20(%ebp),%eax
    badb:	8b 40 04             	mov    0x4(%eax),%eax
    bade:	83 f8 08             	cmp    $0x8,%eax
    bae1:	75 44                	jne    bb27 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    bae3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bae6:	01 c0                	add    %eax,%eax
    bae8:	89 c2                	mov    %eax,%edx
    baea:	8b 45 18             	mov    0x18(%ebp),%eax
    baed:	01 d0                	add    %edx,%eax
    baef:	0f b6 10             	movzbl (%eax),%edx
    baf2:	8b 45 10             	mov    0x10(%ebp),%eax
    baf5:	88 10                	mov    %dl,(%eax)
    baf7:	8b 45 10             	mov    0x10(%ebp),%eax
    bafa:	0f b6 10             	movzbl (%eax),%edx
    bafd:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb00:	88 10                	mov    %dl,(%eax)
    bb02:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb05:	0f b6 10             	movzbl (%eax),%edx
    bb08:	8b 45 08             	mov    0x8(%ebp),%eax
    bb0b:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    bb0d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb10:	01 c0                	add    %eax,%eax
    bb12:	8d 50 01             	lea    0x1(%eax),%edx
    bb15:	8b 45 18             	mov    0x18(%ebp),%eax
    bb18:	01 d0                	add    %edx,%eax
    bb1a:	0f b6 10             	movzbl (%eax),%edx
    bb1d:	8b 45 14             	mov    0x14(%ebp),%eax
    bb20:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    bb22:	e9 11 01 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    bb27:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb2a:	c1 e0 02             	shl    $0x2,%eax
    bb2d:	89 c2                	mov    %eax,%edx
    bb2f:	8b 45 18             	mov    0x18(%ebp),%eax
    bb32:	01 d0                	add    %edx,%eax
    bb34:	0f b6 10             	movzbl (%eax),%edx
    bb37:	8b 45 10             	mov    0x10(%ebp),%eax
    bb3a:	88 10                	mov    %dl,(%eax)
    bb3c:	8b 45 10             	mov    0x10(%ebp),%eax
    bb3f:	0f b6 10             	movzbl (%eax),%edx
    bb42:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb45:	88 10                	mov    %dl,(%eax)
    bb47:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb4a:	0f b6 10             	movzbl (%eax),%edx
    bb4d:	8b 45 08             	mov    0x8(%ebp),%eax
    bb50:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    bb52:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb55:	c1 e0 02             	shl    $0x2,%eax
    bb58:	8d 50 02             	lea    0x2(%eax),%edx
    bb5b:	8b 45 18             	mov    0x18(%ebp),%eax
    bb5e:	01 d0                	add    %edx,%eax
    bb60:	0f b6 10             	movzbl (%eax),%edx
    bb63:	8b 45 14             	mov    0x14(%ebp),%eax
    bb66:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    bb68:	e9 cb 00 00 00       	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    bb6d:	8b 45 20             	mov    0x20(%ebp),%eax
    bb70:	8b 00                	mov    (%eax),%eax
    bb72:	83 f8 06             	cmp    $0x6,%eax
    bb75:	0f 85 bd 00 00 00    	jne    bc38 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    bb7b:	8b 45 20             	mov    0x20(%ebp),%eax
    bb7e:	8b 40 04             	mov    0x4(%eax),%eax
    bb81:	83 f8 08             	cmp    $0x8,%eax
    bb84:	75 59                	jne    bbdf <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    bb86:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb89:	c1 e0 02             	shl    $0x2,%eax
    bb8c:	89 c2                	mov    %eax,%edx
    bb8e:	8b 45 18             	mov    0x18(%ebp),%eax
    bb91:	01 d0                	add    %edx,%eax
    bb93:	0f b6 10             	movzbl (%eax),%edx
    bb96:	8b 45 08             	mov    0x8(%ebp),%eax
    bb99:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    bb9b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb9e:	c1 e0 02             	shl    $0x2,%eax
    bba1:	8d 50 01             	lea    0x1(%eax),%edx
    bba4:	8b 45 18             	mov    0x18(%ebp),%eax
    bba7:	01 d0                	add    %edx,%eax
    bba9:	0f b6 10             	movzbl (%eax),%edx
    bbac:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbaf:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    bbb1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbb4:	c1 e0 02             	shl    $0x2,%eax
    bbb7:	8d 50 02             	lea    0x2(%eax),%edx
    bbba:	8b 45 18             	mov    0x18(%ebp),%eax
    bbbd:	01 d0                	add    %edx,%eax
    bbbf:	0f b6 10             	movzbl (%eax),%edx
    bbc2:	8b 45 10             	mov    0x10(%ebp),%eax
    bbc5:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    bbc7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbca:	c1 e0 02             	shl    $0x2,%eax
    bbcd:	8d 50 03             	lea    0x3(%eax),%edx
    bbd0:	8b 45 18             	mov    0x18(%ebp),%eax
    bbd3:	01 d0                	add    %edx,%eax
    bbd5:	0f b6 10             	movzbl (%eax),%edx
    bbd8:	8b 45 14             	mov    0x14(%ebp),%eax
    bbdb:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    bbdd:	eb 59                	jmp    bc38 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    bbdf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbe2:	c1 e0 03             	shl    $0x3,%eax
    bbe5:	89 c2                	mov    %eax,%edx
    bbe7:	8b 45 18             	mov    0x18(%ebp),%eax
    bbea:	01 d0                	add    %edx,%eax
    bbec:	0f b6 10             	movzbl (%eax),%edx
    bbef:	8b 45 08             	mov    0x8(%ebp),%eax
    bbf2:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    bbf4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbf7:	c1 e0 03             	shl    $0x3,%eax
    bbfa:	8d 50 02             	lea    0x2(%eax),%edx
    bbfd:	8b 45 18             	mov    0x18(%ebp),%eax
    bc00:	01 d0                	add    %edx,%eax
    bc02:	0f b6 10             	movzbl (%eax),%edx
    bc05:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc08:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    bc0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc0d:	c1 e0 03             	shl    $0x3,%eax
    bc10:	8d 50 04             	lea    0x4(%eax),%edx
    bc13:	8b 45 18             	mov    0x18(%ebp),%eax
    bc16:	01 d0                	add    %edx,%eax
    bc18:	0f b6 10             	movzbl (%eax),%edx
    bc1b:	8b 45 10             	mov    0x10(%ebp),%eax
    bc1e:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    bc20:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc23:	c1 e0 03             	shl    $0x3,%eax
    bc26:	8d 50 06             	lea    0x6(%eax),%edx
    bc29:	8b 45 18             	mov    0x18(%ebp),%eax
    bc2c:	01 d0                	add    %edx,%eax
    bc2e:	0f b6 10             	movzbl (%eax),%edx
    bc31:	8b 45 14             	mov    0x14(%ebp),%eax
    bc34:	88 10                	mov    %dl,(%eax)
    }
  }
}
    bc36:	eb 00                	jmp    bc38 <getPixelColorRGBA8+0x5ca>
    bc38:	90                   	nop
    bc39:	c9                   	leave  
    bc3a:	c3                   	ret    

0000bc3b <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    bc3b:	55                   	push   %ebp
    bc3c:	89 e5                	mov    %esp,%ebp
    bc3e:	53                   	push   %ebx
    bc3f:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    bc42:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    bc49:	8b 45 14             	mov    0x14(%ebp),%eax
    bc4c:	8b 00                	mov    (%eax),%eax
    bc4e:	85 c0                	test   %eax,%eax
    bc50:	0f 85 14 02 00 00    	jne    be6a <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    bc56:	8b 45 14             	mov    0x14(%ebp),%eax
    bc59:	8b 40 04             	mov    0x4(%eax),%eax
    bc5c:	83 f8 08             	cmp    $0x8,%eax
    bc5f:	0f 85 a0 00 00 00    	jne    bd05 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc65:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bc6c:	eb 39                	jmp    bca7 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    bc6e:	8b 45 08             	mov    0x8(%ebp),%eax
    bc71:	83 c0 01             	add    $0x1,%eax
    bc74:	8b 55 08             	mov    0x8(%ebp),%edx
    bc77:	83 c2 02             	add    $0x2,%edx
    bc7a:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    bc7d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bc80:	01 d9                	add    %ebx,%ecx
    bc82:	0f b6 09             	movzbl (%ecx),%ecx
    bc85:	88 0a                	mov    %cl,(%edx)
    bc87:	0f b6 12             	movzbl (%edx),%edx
    bc8a:	88 10                	mov    %dl,(%eax)
    bc8c:	0f b6 10             	movzbl (%eax),%edx
    bc8f:	8b 45 08             	mov    0x8(%ebp),%eax
    bc92:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    bc94:	8b 45 08             	mov    0x8(%ebp),%eax
    bc97:	83 c0 03             	add    $0x3,%eax
    bc9a:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc9d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bca1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bca4:	01 45 08             	add    %eax,0x8(%ebp)
    bca7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bcaa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bcad:	75 bf                	jne    bc6e <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    bcaf:	8b 45 14             	mov    0x14(%ebp),%eax
    bcb2:	8b 40 10             	mov    0x10(%eax),%eax
    bcb5:	85 c0                	test   %eax,%eax
    bcb7:	0f 84 48 06 00 00    	je     c305 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    bcbd:	8b 45 0c             	mov    0xc(%ebp),%eax
    bcc0:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    bcc4:	f7 d8                	neg    %eax
    bcc6:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bcc9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bcd0:	eb 26                	jmp    bcf8 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    bcd2:	8b 45 08             	mov    0x8(%ebp),%eax
    bcd5:	0f b6 00             	movzbl (%eax),%eax
    bcd8:	0f b6 d0             	movzbl %al,%edx
    bcdb:	8b 45 14             	mov    0x14(%ebp),%eax
    bcde:	8b 40 14             	mov    0x14(%eax),%eax
    bce1:	39 c2                	cmp    %eax,%edx
    bce3:	75 09                	jne    bcee <getPixelColorsRGBA8+0xb3>
    bce5:	8b 45 08             	mov    0x8(%ebp),%eax
    bce8:	83 c0 03             	add    $0x3,%eax
    bceb:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bcee:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bcf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bcf5:	01 45 08             	add    %eax,0x8(%ebp)
    bcf8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bcfb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bcfe:	75 d2                	jne    bcd2 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bd00:	e9 00 06 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    bd05:	8b 45 14             	mov    0x14(%ebp),%eax
    bd08:	8b 40 04             	mov    0x4(%eax),%eax
    bd0b:	83 f8 10             	cmp    $0x10,%eax
    bd0e:	0f 85 a5 00 00 00    	jne    bdb9 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bd14:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bd1b:	e9 88 00 00 00       	jmp    bda8 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    bd20:	8b 45 08             	mov    0x8(%ebp),%eax
    bd23:	83 c0 01             	add    $0x1,%eax
    bd26:	8b 55 08             	mov    0x8(%ebp),%edx
    bd29:	83 c2 02             	add    $0x2,%edx
    bd2c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    bd2f:	01 c9                	add    %ecx,%ecx
    bd31:	89 cb                	mov    %ecx,%ebx
    bd33:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bd36:	01 d9                	add    %ebx,%ecx
    bd38:	0f b6 09             	movzbl (%ecx),%ecx
    bd3b:	88 0a                	mov    %cl,(%edx)
    bd3d:	0f b6 12             	movzbl (%edx),%edx
    bd40:	88 10                	mov    %dl,(%eax)
    bd42:	0f b6 10             	movzbl (%eax),%edx
    bd45:	8b 45 08             	mov    0x8(%ebp),%eax
    bd48:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    bd4a:	8b 45 08             	mov    0x8(%ebp),%eax
    bd4d:	8d 50 03             	lea    0x3(%eax),%edx
    bd50:	8b 45 14             	mov    0x14(%ebp),%eax
    bd53:	8b 40 10             	mov    0x10(%eax),%eax
    bd56:	85 c0                	test   %eax,%eax
    bd58:	74 3d                	je     bd97 <getPixelColorsRGBA8+0x15c>
    bd5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd5d:	01 c0                	add    %eax,%eax
    bd5f:	89 c1                	mov    %eax,%ecx
    bd61:	8b 45 10             	mov    0x10(%ebp),%eax
    bd64:	01 c8                	add    %ecx,%eax
    bd66:	0f b6 00             	movzbl (%eax),%eax
    bd69:	0f b6 c0             	movzbl %al,%eax
    bd6c:	c1 e0 08             	shl    $0x8,%eax
    bd6f:	89 c1                	mov    %eax,%ecx
    bd71:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd74:	01 c0                	add    %eax,%eax
    bd76:	8d 58 01             	lea    0x1(%eax),%ebx
    bd79:	8b 45 10             	mov    0x10(%ebp),%eax
    bd7c:	01 d8                	add    %ebx,%eax
    bd7e:	0f b6 00             	movzbl (%eax),%eax
    bd81:	0f b6 c0             	movzbl %al,%eax
    bd84:	01 c1                	add    %eax,%ecx
    bd86:	8b 45 14             	mov    0x14(%ebp),%eax
    bd89:	8b 40 14             	mov    0x14(%eax),%eax
    bd8c:	39 c1                	cmp    %eax,%ecx
    bd8e:	75 07                	jne    bd97 <getPixelColorsRGBA8+0x15c>
    bd90:	b8 00 00 00 00       	mov    $0x0,%eax
    bd95:	eb 05                	jmp    bd9c <getPixelColorsRGBA8+0x161>
    bd97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    bd9c:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bd9e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bda2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bda5:	01 45 08             	add    %eax,0x8(%ebp)
    bda8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bdab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bdae:	0f 85 6c ff ff ff    	jne    bd20 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bdb4:	e9 4c 05 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    bdb9:	8b 45 14             	mov    0x14(%ebp),%eax
    bdbc:	8b 40 04             	mov    0x4(%eax),%eax
    bdbf:	ba 01 00 00 00       	mov    $0x1,%edx
    bdc4:	89 c1                	mov    %eax,%ecx
    bdc6:	d3 e2                	shl    %cl,%edx
    bdc8:	89 d0                	mov    %edx,%eax
    bdca:	83 e8 01             	sub    $0x1,%eax
    bdcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    bdd0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bdd7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bdde:	eb 79                	jmp    be59 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    bde0:	8b 45 14             	mov    0x14(%ebp),%eax
    bde3:	8b 40 04             	mov    0x4(%eax),%eax
    bde6:	50                   	push   %eax
    bde7:	ff 75 10             	pushl  0x10(%ebp)
    bdea:	8d 45 e0             	lea    -0x20(%ebp),%eax
    bded:	50                   	push   %eax
    bdee:	e8 c0 d4 ff ff       	call   92b3 <readBitsFromReversedStream>
    bdf3:	83 c4 0c             	add    $0xc,%esp
    bdf6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    bdf9:	8b 45 08             	mov    0x8(%ebp),%eax
    bdfc:	8d 48 01             	lea    0x1(%eax),%ecx
    bdff:	8b 45 08             	mov    0x8(%ebp),%eax
    be02:	8d 58 02             	lea    0x2(%eax),%ebx
    be05:	8b 55 ec             	mov    -0x14(%ebp),%edx
    be08:	89 d0                	mov    %edx,%eax
    be0a:	c1 e0 08             	shl    $0x8,%eax
    be0d:	29 d0                	sub    %edx,%eax
    be0f:	ba 00 00 00 00       	mov    $0x0,%edx
    be14:	f7 75 f0             	divl   -0x10(%ebp)
    be17:	88 03                	mov    %al,(%ebx)
    be19:	0f b6 03             	movzbl (%ebx),%eax
    be1c:	88 01                	mov    %al,(%ecx)
    be1e:	0f b6 11             	movzbl (%ecx),%edx
    be21:	8b 45 08             	mov    0x8(%ebp),%eax
    be24:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    be26:	8b 45 08             	mov    0x8(%ebp),%eax
    be29:	8d 50 03             	lea    0x3(%eax),%edx
    be2c:	8b 45 14             	mov    0x14(%ebp),%eax
    be2f:	8b 40 10             	mov    0x10(%eax),%eax
    be32:	85 c0                	test   %eax,%eax
    be34:	74 12                	je     be48 <getPixelColorsRGBA8+0x20d>
    be36:	8b 45 14             	mov    0x14(%ebp),%eax
    be39:	8b 40 14             	mov    0x14(%eax),%eax
    be3c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    be3f:	75 07                	jne    be48 <getPixelColorsRGBA8+0x20d>
    be41:	b8 00 00 00 00       	mov    $0x0,%eax
    be46:	eb 05                	jmp    be4d <getPixelColorsRGBA8+0x212>
    be48:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    be4d:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    be4f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    be53:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be56:	01 45 08             	add    %eax,0x8(%ebp)
    be59:	8b 45 f8             	mov    -0x8(%ebp),%eax
    be5c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    be5f:	0f 85 7b ff ff ff    	jne    bde0 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    be65:	e9 9b 04 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    be6a:	8b 45 14             	mov    0x14(%ebp),%eax
    be6d:	8b 00                	mov    (%eax),%eax
    be6f:	83 f8 02             	cmp    $0x2,%eax
    be72:	0f 85 41 02 00 00    	jne    c0b9 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    be78:	8b 45 14             	mov    0x14(%ebp),%eax
    be7b:	8b 40 04             	mov    0x4(%eax),%eax
    be7e:	83 f8 08             	cmp    $0x8,%eax
    be81:	0f 85 c4 00 00 00    	jne    bf4b <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    be87:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    be8e:	eb 31                	jmp    bec1 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    be90:	8b 55 f8             	mov    -0x8(%ebp),%edx
    be93:	89 d0                	mov    %edx,%eax
    be95:	01 c0                	add    %eax,%eax
    be97:	01 d0                	add    %edx,%eax
    be99:	89 c2                	mov    %eax,%edx
    be9b:	8b 45 10             	mov    0x10(%ebp),%eax
    be9e:	01 d0                	add    %edx,%eax
    bea0:	6a 03                	push   $0x3
    bea2:	50                   	push   %eax
    bea3:	ff 75 08             	pushl  0x8(%ebp)
    bea6:	e8 a3 85 ff ff       	call   444e <lodepng_memcpy>
    beab:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    beae:	8b 45 08             	mov    0x8(%ebp),%eax
    beb1:	83 c0 03             	add    $0x3,%eax
    beb4:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    beb7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bebb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bebe:	01 45 08             	add    %eax,0x8(%ebp)
    bec1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bec4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bec7:	75 c7                	jne    be90 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    bec9:	8b 45 14             	mov    0x14(%ebp),%eax
    becc:	8b 40 10             	mov    0x10(%eax),%eax
    becf:	85 c0                	test   %eax,%eax
    bed1:	0f 84 2e 04 00 00    	je     c305 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    bed7:	8b 45 0c             	mov    0xc(%ebp),%eax
    beda:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    bede:	f7 d8                	neg    %eax
    bee0:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bee3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    beea:	eb 52                	jmp    bf3e <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    beec:	8b 45 08             	mov    0x8(%ebp),%eax
    beef:	0f b6 00             	movzbl (%eax),%eax
    bef2:	0f b6 d0             	movzbl %al,%edx
    bef5:	8b 45 14             	mov    0x14(%ebp),%eax
    bef8:	8b 40 14             	mov    0x14(%eax),%eax
    befb:	39 c2                	cmp    %eax,%edx
    befd:	75 35                	jne    bf34 <getPixelColorsRGBA8+0x2f9>
    beff:	8b 45 08             	mov    0x8(%ebp),%eax
    bf02:	83 c0 01             	add    $0x1,%eax
    bf05:	0f b6 00             	movzbl (%eax),%eax
    bf08:	0f b6 d0             	movzbl %al,%edx
    bf0b:	8b 45 14             	mov    0x14(%ebp),%eax
    bf0e:	8b 40 18             	mov    0x18(%eax),%eax
    bf11:	39 c2                	cmp    %eax,%edx
    bf13:	75 1f                	jne    bf34 <getPixelColorsRGBA8+0x2f9>
    bf15:	8b 45 08             	mov    0x8(%ebp),%eax
    bf18:	83 c0 02             	add    $0x2,%eax
    bf1b:	0f b6 00             	movzbl (%eax),%eax
    bf1e:	0f b6 d0             	movzbl %al,%edx
    bf21:	8b 45 14             	mov    0x14(%ebp),%eax
    bf24:	8b 40 1c             	mov    0x1c(%eax),%eax
    bf27:	39 c2                	cmp    %eax,%edx
    bf29:	75 09                	jne    bf34 <getPixelColorsRGBA8+0x2f9>
    bf2b:	8b 45 08             	mov    0x8(%ebp),%eax
    bf2e:	83 c0 03             	add    $0x3,%eax
    bf31:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bf34:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bf38:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf3b:	01 45 08             	add    %eax,0x8(%ebp)
    bf3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf41:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bf44:	75 a6                	jne    beec <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bf46:	e9 ba 03 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bf4b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bf52:	e9 51 01 00 00       	jmp    c0a8 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    bf57:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf5a:	89 d0                	mov    %edx,%eax
    bf5c:	01 c0                	add    %eax,%eax
    bf5e:	01 d0                	add    %edx,%eax
    bf60:	01 c0                	add    %eax,%eax
    bf62:	89 c2                	mov    %eax,%edx
    bf64:	8b 45 10             	mov    0x10(%ebp),%eax
    bf67:	01 d0                	add    %edx,%eax
    bf69:	0f b6 10             	movzbl (%eax),%edx
    bf6c:	8b 45 08             	mov    0x8(%ebp),%eax
    bf6f:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    bf71:	8b 45 08             	mov    0x8(%ebp),%eax
    bf74:	8d 48 01             	lea    0x1(%eax),%ecx
    bf77:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf7a:	89 d0                	mov    %edx,%eax
    bf7c:	01 c0                	add    %eax,%eax
    bf7e:	01 d0                	add    %edx,%eax
    bf80:	01 c0                	add    %eax,%eax
    bf82:	8d 50 02             	lea    0x2(%eax),%edx
    bf85:	8b 45 10             	mov    0x10(%ebp),%eax
    bf88:	01 d0                	add    %edx,%eax
    bf8a:	0f b6 00             	movzbl (%eax),%eax
    bf8d:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    bf8f:	8b 45 08             	mov    0x8(%ebp),%eax
    bf92:	8d 48 02             	lea    0x2(%eax),%ecx
    bf95:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf98:	89 d0                	mov    %edx,%eax
    bf9a:	01 c0                	add    %eax,%eax
    bf9c:	01 d0                	add    %edx,%eax
    bf9e:	01 c0                	add    %eax,%eax
    bfa0:	8d 50 04             	lea    0x4(%eax),%edx
    bfa3:	8b 45 10             	mov    0x10(%ebp),%eax
    bfa6:	01 d0                	add    %edx,%eax
    bfa8:	0f b6 00             	movzbl (%eax),%eax
    bfab:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    bfad:	8b 45 08             	mov    0x8(%ebp),%eax
    bfb0:	8d 48 03             	lea    0x3(%eax),%ecx
    bfb3:	8b 45 14             	mov    0x14(%ebp),%eax
    bfb6:	8b 40 10             	mov    0x10(%eax),%eax
    bfb9:	85 c0                	test   %eax,%eax
    bfbb:	0f 84 d6 00 00 00    	je     c097 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    bfc1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bfc4:	89 d0                	mov    %edx,%eax
    bfc6:	01 c0                	add    %eax,%eax
    bfc8:	01 d0                	add    %edx,%eax
    bfca:	01 c0                	add    %eax,%eax
    bfcc:	89 c2                	mov    %eax,%edx
    bfce:	8b 45 10             	mov    0x10(%ebp),%eax
    bfd1:	01 d0                	add    %edx,%eax
    bfd3:	0f b6 00             	movzbl (%eax),%eax
    bfd6:	0f b6 c0             	movzbl %al,%eax
    bfd9:	c1 e0 08             	shl    $0x8,%eax
    bfdc:	89 c3                	mov    %eax,%ebx
    bfde:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bfe1:	89 d0                	mov    %edx,%eax
    bfe3:	01 c0                	add    %eax,%eax
    bfe5:	01 d0                	add    %edx,%eax
    bfe7:	01 c0                	add    %eax,%eax
    bfe9:	8d 50 01             	lea    0x1(%eax),%edx
    bfec:	8b 45 10             	mov    0x10(%ebp),%eax
    bfef:	01 d0                	add    %edx,%eax
    bff1:	0f b6 00             	movzbl (%eax),%eax
    bff4:	0f b6 c0             	movzbl %al,%eax
    bff7:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    bffa:	8b 45 14             	mov    0x14(%ebp),%eax
    bffd:	8b 40 14             	mov    0x14(%eax),%eax
    c000:	39 c2                	cmp    %eax,%edx
    c002:	0f 85 8f 00 00 00    	jne    c097 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    c008:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c00b:	89 d0                	mov    %edx,%eax
    c00d:	01 c0                	add    %eax,%eax
    c00f:	01 d0                	add    %edx,%eax
    c011:	01 c0                	add    %eax,%eax
    c013:	8d 50 02             	lea    0x2(%eax),%edx
    c016:	8b 45 10             	mov    0x10(%ebp),%eax
    c019:	01 d0                	add    %edx,%eax
    c01b:	0f b6 00             	movzbl (%eax),%eax
    c01e:	0f b6 c0             	movzbl %al,%eax
    c021:	c1 e0 08             	shl    $0x8,%eax
    c024:	89 c3                	mov    %eax,%ebx
    c026:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c029:	89 d0                	mov    %edx,%eax
    c02b:	01 c0                	add    %eax,%eax
    c02d:	01 d0                	add    %edx,%eax
    c02f:	01 c0                	add    %eax,%eax
    c031:	8d 50 03             	lea    0x3(%eax),%edx
    c034:	8b 45 10             	mov    0x10(%ebp),%eax
    c037:	01 d0                	add    %edx,%eax
    c039:	0f b6 00             	movzbl (%eax),%eax
    c03c:	0f b6 c0             	movzbl %al,%eax
    c03f:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    c042:	8b 45 14             	mov    0x14(%ebp),%eax
    c045:	8b 40 18             	mov    0x18(%eax),%eax
    c048:	39 c2                	cmp    %eax,%edx
    c04a:	75 4b                	jne    c097 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    c04c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c04f:	89 d0                	mov    %edx,%eax
    c051:	01 c0                	add    %eax,%eax
    c053:	01 d0                	add    %edx,%eax
    c055:	01 c0                	add    %eax,%eax
    c057:	8d 50 04             	lea    0x4(%eax),%edx
    c05a:	8b 45 10             	mov    0x10(%ebp),%eax
    c05d:	01 d0                	add    %edx,%eax
    c05f:	0f b6 00             	movzbl (%eax),%eax
    c062:	0f b6 c0             	movzbl %al,%eax
    c065:	c1 e0 08             	shl    $0x8,%eax
    c068:	89 c3                	mov    %eax,%ebx
    c06a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c06d:	89 d0                	mov    %edx,%eax
    c06f:	01 c0                	add    %eax,%eax
    c071:	01 d0                	add    %edx,%eax
    c073:	01 c0                	add    %eax,%eax
    c075:	8d 50 05             	lea    0x5(%eax),%edx
    c078:	8b 45 10             	mov    0x10(%ebp),%eax
    c07b:	01 d0                	add    %edx,%eax
    c07d:	0f b6 00             	movzbl (%eax),%eax
    c080:	0f b6 c0             	movzbl %al,%eax
    c083:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    c086:	8b 45 14             	mov    0x14(%ebp),%eax
    c089:	8b 40 1c             	mov    0x1c(%eax),%eax
    c08c:	39 c2                	cmp    %eax,%edx
    c08e:	75 07                	jne    c097 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    c090:	b8 00 00 00 00       	mov    $0x0,%eax
    c095:	eb 05                	jmp    c09c <getPixelColorsRGBA8+0x461>
    c097:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    c09c:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c09e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c0a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0a5:	01 45 08             	add    %eax,0x8(%ebp)
    c0a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c0ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c0ae:	0f 85 a3 fe ff ff    	jne    bf57 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c0b4:	e9 4c 02 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    c0b9:	8b 45 14             	mov    0x14(%ebp),%eax
    c0bc:	8b 00                	mov    (%eax),%eax
    c0be:	83 f8 03             	cmp    $0x3,%eax
    c0c1:	0f 85 b4 00 00 00    	jne    c17b <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    c0c7:	8b 45 14             	mov    0x14(%ebp),%eax
    c0ca:	8b 40 04             	mov    0x4(%eax),%eax
    c0cd:	83 f8 08             	cmp    $0x8,%eax
    c0d0:	75 4d                	jne    c11f <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c0d2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c0d9:	eb 37                	jmp    c112 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    c0db:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c0de:	8b 45 10             	mov    0x10(%ebp),%eax
    c0e1:	01 d0                	add    %edx,%eax
    c0e3:	0f b6 00             	movzbl (%eax),%eax
    c0e6:	0f b6 c0             	movzbl %al,%eax
    c0e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    c0ec:	8b 45 14             	mov    0x14(%ebp),%eax
    c0ef:	8b 40 08             	mov    0x8(%eax),%eax
    c0f2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    c0f5:	c1 e2 02             	shl    $0x2,%edx
    c0f8:	01 d0                	add    %edx,%eax
    c0fa:	6a 04                	push   $0x4
    c0fc:	50                   	push   %eax
    c0fd:	ff 75 08             	pushl  0x8(%ebp)
    c100:	e8 49 83 ff ff       	call   444e <lodepng_memcpy>
    c105:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c108:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c10c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c10f:	01 45 08             	add    %eax,0x8(%ebp)
    c112:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c115:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c118:	75 c1                	jne    c0db <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c11a:	e9 e6 01 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    c11f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c126:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c12d:	eb 3f                	jmp    c16e <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c12f:	8b 45 14             	mov    0x14(%ebp),%eax
    c132:	8b 40 04             	mov    0x4(%eax),%eax
    c135:	50                   	push   %eax
    c136:	ff 75 10             	pushl  0x10(%ebp)
    c139:	8d 45 dc             	lea    -0x24(%ebp),%eax
    c13c:	50                   	push   %eax
    c13d:	e8 71 d1 ff ff       	call   92b3 <readBitsFromReversedStream>
    c142:	83 c4 0c             	add    $0xc,%esp
    c145:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    c148:	8b 45 14             	mov    0x14(%ebp),%eax
    c14b:	8b 40 08             	mov    0x8(%eax),%eax
    c14e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c151:	c1 e2 02             	shl    $0x2,%edx
    c154:	01 d0                	add    %edx,%eax
    c156:	6a 04                	push   $0x4
    c158:	50                   	push   %eax
    c159:	ff 75 08             	pushl  0x8(%ebp)
    c15c:	e8 ed 82 ff ff       	call   444e <lodepng_memcpy>
    c161:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c164:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c168:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c16b:	01 45 08             	add    %eax,0x8(%ebp)
    c16e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c171:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c174:	75 b9                	jne    c12f <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c176:	e9 8a 01 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    c17b:	8b 45 14             	mov    0x14(%ebp),%eax
    c17e:	8b 00                	mov    (%eax),%eax
    c180:	83 f8 04             	cmp    $0x4,%eax
    c183:	0f 85 d1 00 00 00    	jne    c25a <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    c189:	8b 45 14             	mov    0x14(%ebp),%eax
    c18c:	8b 40 04             	mov    0x4(%eax),%eax
    c18f:	83 f8 08             	cmp    $0x8,%eax
    c192:	75 62                	jne    c1f6 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c194:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c19b:	eb 4c                	jmp    c1e9 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    c19d:	8b 45 08             	mov    0x8(%ebp),%eax
    c1a0:	83 c0 01             	add    $0x1,%eax
    c1a3:	8b 55 08             	mov    0x8(%ebp),%edx
    c1a6:	83 c2 02             	add    $0x2,%edx
    c1a9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c1ac:	01 c9                	add    %ecx,%ecx
    c1ae:	89 cb                	mov    %ecx,%ebx
    c1b0:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c1b3:	01 d9                	add    %ebx,%ecx
    c1b5:	0f b6 09             	movzbl (%ecx),%ecx
    c1b8:	88 0a                	mov    %cl,(%edx)
    c1ba:	0f b6 12             	movzbl (%edx),%edx
    c1bd:	88 10                	mov    %dl,(%eax)
    c1bf:	0f b6 10             	movzbl (%eax),%edx
    c1c2:	8b 45 08             	mov    0x8(%ebp),%eax
    c1c5:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    c1c7:	8b 45 08             	mov    0x8(%ebp),%eax
    c1ca:	8d 50 03             	lea    0x3(%eax),%edx
    c1cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c1d0:	01 c0                	add    %eax,%eax
    c1d2:	8d 48 01             	lea    0x1(%eax),%ecx
    c1d5:	8b 45 10             	mov    0x10(%ebp),%eax
    c1d8:	01 c8                	add    %ecx,%eax
    c1da:	0f b6 00             	movzbl (%eax),%eax
    c1dd:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c1df:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c1e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c1e6:	01 45 08             	add    %eax,0x8(%ebp)
    c1e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c1ec:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c1ef:	75 ac                	jne    c19d <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c1f1:	e9 0f 01 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c1f6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c1fd:	eb 4e                	jmp    c24d <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    c1ff:	8b 45 08             	mov    0x8(%ebp),%eax
    c202:	83 c0 01             	add    $0x1,%eax
    c205:	8b 55 08             	mov    0x8(%ebp),%edx
    c208:	83 c2 02             	add    $0x2,%edx
    c20b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c20e:	c1 e1 02             	shl    $0x2,%ecx
    c211:	89 cb                	mov    %ecx,%ebx
    c213:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c216:	01 d9                	add    %ebx,%ecx
    c218:	0f b6 09             	movzbl (%ecx),%ecx
    c21b:	88 0a                	mov    %cl,(%edx)
    c21d:	0f b6 12             	movzbl (%edx),%edx
    c220:	88 10                	mov    %dl,(%eax)
    c222:	0f b6 10             	movzbl (%eax),%edx
    c225:	8b 45 08             	mov    0x8(%ebp),%eax
    c228:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    c22a:	8b 45 08             	mov    0x8(%ebp),%eax
    c22d:	8d 50 03             	lea    0x3(%eax),%edx
    c230:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c233:	c1 e0 02             	shl    $0x2,%eax
    c236:	8d 48 02             	lea    0x2(%eax),%ecx
    c239:	8b 45 10             	mov    0x10(%ebp),%eax
    c23c:	01 c8                	add    %ecx,%eax
    c23e:	0f b6 00             	movzbl (%eax),%eax
    c241:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c243:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c247:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c24a:	01 45 08             	add    %eax,0x8(%ebp)
    c24d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c250:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c253:	75 aa                	jne    c1ff <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c255:	e9 ab 00 00 00       	jmp    c305 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    c25a:	8b 45 14             	mov    0x14(%ebp),%eax
    c25d:	8b 00                	mov    (%eax),%eax
    c25f:	83 f8 06             	cmp    $0x6,%eax
    c262:	0f 85 9d 00 00 00    	jne    c305 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    c268:	8b 45 14             	mov    0x14(%ebp),%eax
    c26b:	8b 40 04             	mov    0x4(%eax),%eax
    c26e:	83 f8 08             	cmp    $0x8,%eax
    c271:	75 17                	jne    c28a <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    c273:	8b 45 0c             	mov    0xc(%ebp),%eax
    c276:	c1 e0 02             	shl    $0x2,%eax
    c279:	50                   	push   %eax
    c27a:	ff 75 10             	pushl  0x10(%ebp)
    c27d:	ff 75 08             	pushl  0x8(%ebp)
    c280:	e8 c9 81 ff ff       	call   444e <lodepng_memcpy>
    c285:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c288:	eb 7b                	jmp    c305 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c28a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c291:	eb 6a                	jmp    c2fd <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    c293:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c296:	c1 e0 03             	shl    $0x3,%eax
    c299:	89 c2                	mov    %eax,%edx
    c29b:	8b 45 10             	mov    0x10(%ebp),%eax
    c29e:	01 d0                	add    %edx,%eax
    c2a0:	0f b6 10             	movzbl (%eax),%edx
    c2a3:	8b 45 08             	mov    0x8(%ebp),%eax
    c2a6:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    c2a8:	8b 45 08             	mov    0x8(%ebp),%eax
    c2ab:	8d 50 01             	lea    0x1(%eax),%edx
    c2ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c2b1:	c1 e0 03             	shl    $0x3,%eax
    c2b4:	8d 48 02             	lea    0x2(%eax),%ecx
    c2b7:	8b 45 10             	mov    0x10(%ebp),%eax
    c2ba:	01 c8                	add    %ecx,%eax
    c2bc:	0f b6 00             	movzbl (%eax),%eax
    c2bf:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    c2c1:	8b 45 08             	mov    0x8(%ebp),%eax
    c2c4:	8d 50 02             	lea    0x2(%eax),%edx
    c2c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c2ca:	c1 e0 03             	shl    $0x3,%eax
    c2cd:	8d 48 04             	lea    0x4(%eax),%ecx
    c2d0:	8b 45 10             	mov    0x10(%ebp),%eax
    c2d3:	01 c8                	add    %ecx,%eax
    c2d5:	0f b6 00             	movzbl (%eax),%eax
    c2d8:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    c2da:	8b 45 08             	mov    0x8(%ebp),%eax
    c2dd:	8d 50 03             	lea    0x3(%eax),%edx
    c2e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c2e3:	c1 e0 03             	shl    $0x3,%eax
    c2e6:	8d 48 06             	lea    0x6(%eax),%ecx
    c2e9:	8b 45 10             	mov    0x10(%ebp),%eax
    c2ec:	01 c8                	add    %ecx,%eax
    c2ee:	0f b6 00             	movzbl (%eax),%eax
    c2f1:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c2f3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c2f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2fa:	01 45 08             	add    %eax,0x8(%ebp)
    c2fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c300:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c303:	75 8e                	jne    c293 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    c305:	90                   	nop
    c306:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c309:	c9                   	leave  
    c30a:	c3                   	ret    

0000c30b <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    c30b:	55                   	push   %ebp
    c30c:	89 e5                	mov    %esp,%ebp
    c30e:	53                   	push   %ebx
    c30f:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    c312:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    c319:	8b 45 14             	mov    0x14(%ebp),%eax
    c31c:	8b 00                	mov    (%eax),%eax
    c31e:	85 c0                	test   %eax,%eax
    c320:	0f 85 2a 01 00 00    	jne    c450 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    c326:	8b 45 14             	mov    0x14(%ebp),%eax
    c329:	8b 40 04             	mov    0x4(%eax),%eax
    c32c:	83 f8 08             	cmp    $0x8,%eax
    c32f:	75 46                	jne    c377 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c331:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c338:	eb 30                	jmp    c36a <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    c33a:	8b 45 08             	mov    0x8(%ebp),%eax
    c33d:	83 c0 01             	add    $0x1,%eax
    c340:	8b 55 08             	mov    0x8(%ebp),%edx
    c343:	83 c2 02             	add    $0x2,%edx
    c346:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    c349:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c34c:	01 d9                	add    %ebx,%ecx
    c34e:	0f b6 09             	movzbl (%ecx),%ecx
    c351:	88 0a                	mov    %cl,(%edx)
    c353:	0f b6 12             	movzbl (%edx),%edx
    c356:	88 10                	mov    %dl,(%eax)
    c358:	0f b6 10             	movzbl (%eax),%edx
    c35b:	8b 45 08             	mov    0x8(%ebp),%eax
    c35e:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c360:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c364:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c367:	01 45 08             	add    %eax,0x8(%ebp)
    c36a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c36d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c370:	75 c8                	jne    c33a <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c372:	e9 a8 03 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    c377:	8b 45 14             	mov    0x14(%ebp),%eax
    c37a:	8b 40 04             	mov    0x4(%eax),%eax
    c37d:	83 f8 10             	cmp    $0x10,%eax
    c380:	75 4a                	jne    c3cc <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c382:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c389:	eb 34                	jmp    c3bf <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    c38b:	8b 45 08             	mov    0x8(%ebp),%eax
    c38e:	83 c0 01             	add    $0x1,%eax
    c391:	8b 55 08             	mov    0x8(%ebp),%edx
    c394:	83 c2 02             	add    $0x2,%edx
    c397:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c39a:	01 c9                	add    %ecx,%ecx
    c39c:	89 cb                	mov    %ecx,%ebx
    c39e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c3a1:	01 d9                	add    %ebx,%ecx
    c3a3:	0f b6 09             	movzbl (%ecx),%ecx
    c3a6:	88 0a                	mov    %cl,(%edx)
    c3a8:	0f b6 12             	movzbl (%edx),%edx
    c3ab:	88 10                	mov    %dl,(%eax)
    c3ad:	0f b6 10             	movzbl (%eax),%edx
    c3b0:	8b 45 08             	mov    0x8(%ebp),%eax
    c3b3:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c3b5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c3b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3bc:	01 45 08             	add    %eax,0x8(%ebp)
    c3bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c3c2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c3c5:	75 c4                	jne    c38b <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c3c7:	e9 53 03 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    c3cc:	8b 45 14             	mov    0x14(%ebp),%eax
    c3cf:	8b 40 04             	mov    0x4(%eax),%eax
    c3d2:	ba 01 00 00 00       	mov    $0x1,%edx
    c3d7:	89 c1                	mov    %eax,%ecx
    c3d9:	d3 e2                	shl    %cl,%edx
    c3db:	89 d0                	mov    %edx,%eax
    c3dd:	83 e8 01             	sub    $0x1,%eax
    c3e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    c3e3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c3ea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c3f1:	eb 50                	jmp    c443 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c3f3:	8b 45 14             	mov    0x14(%ebp),%eax
    c3f6:	8b 40 04             	mov    0x4(%eax),%eax
    c3f9:	50                   	push   %eax
    c3fa:	ff 75 10             	pushl  0x10(%ebp)
    c3fd:	8d 45 e0             	lea    -0x20(%ebp),%eax
    c400:	50                   	push   %eax
    c401:	e8 ad ce ff ff       	call   92b3 <readBitsFromReversedStream>
    c406:	83 c4 0c             	add    $0xc,%esp
    c409:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    c40c:	8b 45 08             	mov    0x8(%ebp),%eax
    c40f:	8d 48 01             	lea    0x1(%eax),%ecx
    c412:	8b 45 08             	mov    0x8(%ebp),%eax
    c415:	8d 58 02             	lea    0x2(%eax),%ebx
    c418:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c41b:	89 d0                	mov    %edx,%eax
    c41d:	c1 e0 08             	shl    $0x8,%eax
    c420:	29 d0                	sub    %edx,%eax
    c422:	ba 00 00 00 00       	mov    $0x0,%edx
    c427:	f7 75 f0             	divl   -0x10(%ebp)
    c42a:	88 03                	mov    %al,(%ebx)
    c42c:	0f b6 03             	movzbl (%ebx),%eax
    c42f:	88 01                	mov    %al,(%ecx)
    c431:	0f b6 11             	movzbl (%ecx),%edx
    c434:	8b 45 08             	mov    0x8(%ebp),%eax
    c437:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c439:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c43d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c440:	01 45 08             	add    %eax,0x8(%ebp)
    c443:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c446:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c449:	75 a8                	jne    c3f3 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c44b:	e9 cf 02 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    c450:	8b 45 14             	mov    0x14(%ebp),%eax
    c453:	8b 00                	mov    (%eax),%eax
    c455:	83 f8 02             	cmp    $0x2,%eax
    c458:	0f 85 9e 00 00 00    	jne    c4fc <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    c45e:	8b 45 14             	mov    0x14(%ebp),%eax
    c461:	8b 40 04             	mov    0x4(%eax),%eax
    c464:	83 f8 08             	cmp    $0x8,%eax
    c467:	75 1d                	jne    c486 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    c469:	8b 55 0c             	mov    0xc(%ebp),%edx
    c46c:	89 d0                	mov    %edx,%eax
    c46e:	01 c0                	add    %eax,%eax
    c470:	01 d0                	add    %edx,%eax
    c472:	50                   	push   %eax
    c473:	ff 75 10             	pushl  0x10(%ebp)
    c476:	ff 75 08             	pushl  0x8(%ebp)
    c479:	e8 d0 7f ff ff       	call   444e <lodepng_memcpy>
    c47e:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c481:	e9 99 02 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c486:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c48d:	eb 60                	jmp    c4ef <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    c48f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c492:	89 d0                	mov    %edx,%eax
    c494:	01 c0                	add    %eax,%eax
    c496:	01 d0                	add    %edx,%eax
    c498:	01 c0                	add    %eax,%eax
    c49a:	89 c2                	mov    %eax,%edx
    c49c:	8b 45 10             	mov    0x10(%ebp),%eax
    c49f:	01 d0                	add    %edx,%eax
    c4a1:	0f b6 10             	movzbl (%eax),%edx
    c4a4:	8b 45 08             	mov    0x8(%ebp),%eax
    c4a7:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    c4a9:	8b 45 08             	mov    0x8(%ebp),%eax
    c4ac:	8d 48 01             	lea    0x1(%eax),%ecx
    c4af:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c4b2:	89 d0                	mov    %edx,%eax
    c4b4:	01 c0                	add    %eax,%eax
    c4b6:	01 d0                	add    %edx,%eax
    c4b8:	01 c0                	add    %eax,%eax
    c4ba:	8d 50 02             	lea    0x2(%eax),%edx
    c4bd:	8b 45 10             	mov    0x10(%ebp),%eax
    c4c0:	01 d0                	add    %edx,%eax
    c4c2:	0f b6 00             	movzbl (%eax),%eax
    c4c5:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    c4c7:	8b 45 08             	mov    0x8(%ebp),%eax
    c4ca:	8d 48 02             	lea    0x2(%eax),%ecx
    c4cd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c4d0:	89 d0                	mov    %edx,%eax
    c4d2:	01 c0                	add    %eax,%eax
    c4d4:	01 d0                	add    %edx,%eax
    c4d6:	01 c0                	add    %eax,%eax
    c4d8:	8d 50 04             	lea    0x4(%eax),%edx
    c4db:	8b 45 10             	mov    0x10(%ebp),%eax
    c4de:	01 d0                	add    %edx,%eax
    c4e0:	0f b6 00             	movzbl (%eax),%eax
    c4e3:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c4e5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c4e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c4ec:	01 45 08             	add    %eax,0x8(%ebp)
    c4ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c4f2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c4f5:	75 98                	jne    c48f <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c4f7:	e9 23 02 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    c4fc:	8b 45 14             	mov    0x14(%ebp),%eax
    c4ff:	8b 00                	mov    (%eax),%eax
    c501:	83 f8 03             	cmp    $0x3,%eax
    c504:	0f 85 b4 00 00 00    	jne    c5be <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    c50a:	8b 45 14             	mov    0x14(%ebp),%eax
    c50d:	8b 40 04             	mov    0x4(%eax),%eax
    c510:	83 f8 08             	cmp    $0x8,%eax
    c513:	75 4d                	jne    c562 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c515:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c51c:	eb 37                	jmp    c555 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    c51e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c521:	8b 45 10             	mov    0x10(%ebp),%eax
    c524:	01 d0                	add    %edx,%eax
    c526:	0f b6 00             	movzbl (%eax),%eax
    c529:	0f b6 c0             	movzbl %al,%eax
    c52c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    c52f:	8b 45 14             	mov    0x14(%ebp),%eax
    c532:	8b 40 08             	mov    0x8(%eax),%eax
    c535:	8b 55 e8             	mov    -0x18(%ebp),%edx
    c538:	c1 e2 02             	shl    $0x2,%edx
    c53b:	01 d0                	add    %edx,%eax
    c53d:	6a 03                	push   $0x3
    c53f:	50                   	push   %eax
    c540:	ff 75 08             	pushl  0x8(%ebp)
    c543:	e8 06 7f ff ff       	call   444e <lodepng_memcpy>
    c548:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c54b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c54f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c552:	01 45 08             	add    %eax,0x8(%ebp)
    c555:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c558:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c55b:	75 c1                	jne    c51e <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c55d:	e9 bd 01 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    c562:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c569:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c570:	eb 3f                	jmp    c5b1 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c572:	8b 45 14             	mov    0x14(%ebp),%eax
    c575:	8b 40 04             	mov    0x4(%eax),%eax
    c578:	50                   	push   %eax
    c579:	ff 75 10             	pushl  0x10(%ebp)
    c57c:	8d 45 dc             	lea    -0x24(%ebp),%eax
    c57f:	50                   	push   %eax
    c580:	e8 2e cd ff ff       	call   92b3 <readBitsFromReversedStream>
    c585:	83 c4 0c             	add    $0xc,%esp
    c588:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    c58b:	8b 45 14             	mov    0x14(%ebp),%eax
    c58e:	8b 40 08             	mov    0x8(%eax),%eax
    c591:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c594:	c1 e2 02             	shl    $0x2,%edx
    c597:	01 d0                	add    %edx,%eax
    c599:	6a 03                	push   $0x3
    c59b:	50                   	push   %eax
    c59c:	ff 75 08             	pushl  0x8(%ebp)
    c59f:	e8 aa 7e ff ff       	call   444e <lodepng_memcpy>
    c5a4:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c5a7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c5ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c5ae:	01 45 08             	add    %eax,0x8(%ebp)
    c5b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c5b4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c5b7:	75 b9                	jne    c572 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c5b9:	e9 61 01 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    c5be:	8b 45 14             	mov    0x14(%ebp),%eax
    c5c1:	8b 00                	mov    (%eax),%eax
    c5c3:	83 f8 04             	cmp    $0x4,%eax
    c5c6:	0f 85 a0 00 00 00    	jne    c66c <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    c5cc:	8b 45 14             	mov    0x14(%ebp),%eax
    c5cf:	8b 40 04             	mov    0x4(%eax),%eax
    c5d2:	83 f8 08             	cmp    $0x8,%eax
    c5d5:	75 4a                	jne    c621 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c5d7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c5de:	eb 34                	jmp    c614 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    c5e0:	8b 45 08             	mov    0x8(%ebp),%eax
    c5e3:	83 c0 01             	add    $0x1,%eax
    c5e6:	8b 55 08             	mov    0x8(%ebp),%edx
    c5e9:	83 c2 02             	add    $0x2,%edx
    c5ec:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c5ef:	01 c9                	add    %ecx,%ecx
    c5f1:	89 cb                	mov    %ecx,%ebx
    c5f3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c5f6:	01 d9                	add    %ebx,%ecx
    c5f8:	0f b6 09             	movzbl (%ecx),%ecx
    c5fb:	88 0a                	mov    %cl,(%edx)
    c5fd:	0f b6 12             	movzbl (%edx),%edx
    c600:	88 10                	mov    %dl,(%eax)
    c602:	0f b6 10             	movzbl (%eax),%edx
    c605:	8b 45 08             	mov    0x8(%ebp),%eax
    c608:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c60a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c60e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c611:	01 45 08             	add    %eax,0x8(%ebp)
    c614:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c617:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c61a:	75 c4                	jne    c5e0 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c61c:	e9 fe 00 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c621:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c628:	eb 35                	jmp    c65f <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    c62a:	8b 45 08             	mov    0x8(%ebp),%eax
    c62d:	83 c0 01             	add    $0x1,%eax
    c630:	8b 55 08             	mov    0x8(%ebp),%edx
    c633:	83 c2 02             	add    $0x2,%edx
    c636:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c639:	c1 e1 02             	shl    $0x2,%ecx
    c63c:	89 cb                	mov    %ecx,%ebx
    c63e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c641:	01 d9                	add    %ebx,%ecx
    c643:	0f b6 09             	movzbl (%ecx),%ecx
    c646:	88 0a                	mov    %cl,(%edx)
    c648:	0f b6 12             	movzbl (%edx),%edx
    c64b:	88 10                	mov    %dl,(%eax)
    c64d:	0f b6 10             	movzbl (%eax),%edx
    c650:	8b 45 08             	mov    0x8(%ebp),%eax
    c653:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c655:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c659:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c65c:	01 45 08             	add    %eax,0x8(%ebp)
    c65f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c662:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c665:	75 c3                	jne    c62a <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c667:	e9 b3 00 00 00       	jmp    c71f <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    c66c:	8b 45 14             	mov    0x14(%ebp),%eax
    c66f:	8b 00                	mov    (%eax),%eax
    c671:	83 f8 06             	cmp    $0x6,%eax
    c674:	0f 85 a5 00 00 00    	jne    c71f <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    c67a:	8b 45 14             	mov    0x14(%ebp),%eax
    c67d:	8b 40 04             	mov    0x4(%eax),%eax
    c680:	83 f8 08             	cmp    $0x8,%eax
    c683:	75 38                	jne    c6bd <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c685:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c68c:	eb 25                	jmp    c6b3 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    c68e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c691:	c1 e0 02             	shl    $0x2,%eax
    c694:	89 c2                	mov    %eax,%edx
    c696:	8b 45 10             	mov    0x10(%ebp),%eax
    c699:	01 d0                	add    %edx,%eax
    c69b:	6a 03                	push   $0x3
    c69d:	50                   	push   %eax
    c69e:	ff 75 08             	pushl  0x8(%ebp)
    c6a1:	e8 a8 7d ff ff       	call   444e <lodepng_memcpy>
    c6a6:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c6a9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c6ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6b0:	01 45 08             	add    %eax,0x8(%ebp)
    c6b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c6b6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c6b9:	75 d3                	jne    c68e <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c6bb:	eb 62                	jmp    c71f <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c6bd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c6c4:	eb 51                	jmp    c717 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    c6c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c6c9:	c1 e0 03             	shl    $0x3,%eax
    c6cc:	89 c2                	mov    %eax,%edx
    c6ce:	8b 45 10             	mov    0x10(%ebp),%eax
    c6d1:	01 d0                	add    %edx,%eax
    c6d3:	0f b6 10             	movzbl (%eax),%edx
    c6d6:	8b 45 08             	mov    0x8(%ebp),%eax
    c6d9:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    c6db:	8b 45 08             	mov    0x8(%ebp),%eax
    c6de:	8d 50 01             	lea    0x1(%eax),%edx
    c6e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c6e4:	c1 e0 03             	shl    $0x3,%eax
    c6e7:	8d 48 02             	lea    0x2(%eax),%ecx
    c6ea:	8b 45 10             	mov    0x10(%ebp),%eax
    c6ed:	01 c8                	add    %ecx,%eax
    c6ef:	0f b6 00             	movzbl (%eax),%eax
    c6f2:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    c6f4:	8b 45 08             	mov    0x8(%ebp),%eax
    c6f7:	8d 50 02             	lea    0x2(%eax),%edx
    c6fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c6fd:	c1 e0 03             	shl    $0x3,%eax
    c700:	8d 48 04             	lea    0x4(%eax),%ecx
    c703:	8b 45 10             	mov    0x10(%ebp),%eax
    c706:	01 c8                	add    %ecx,%eax
    c708:	0f b6 00             	movzbl (%eax),%eax
    c70b:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c70d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c711:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c714:	01 45 08             	add    %eax,0x8(%ebp)
    c717:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c71a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c71d:	75 a7                	jne    c6c6 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c71f:	90                   	nop
    c720:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c723:	c9                   	leave  
    c724:	c3                   	ret    

0000c725 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    c725:	55                   	push   %ebp
    c726:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    c728:	8b 45 20             	mov    0x20(%ebp),%eax
    c72b:	8b 00                	mov    (%eax),%eax
    c72d:	85 c0                	test   %eax,%eax
    c72f:	0f 85 a4 00 00 00    	jne    c7d9 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    c735:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c738:	01 c0                	add    %eax,%eax
    c73a:	89 c2                	mov    %eax,%edx
    c73c:	8b 45 18             	mov    0x18(%ebp),%eax
    c73f:	01 d0                	add    %edx,%eax
    c741:	0f b6 00             	movzbl (%eax),%eax
    c744:	0f b6 c0             	movzbl %al,%eax
    c747:	c1 e0 08             	shl    $0x8,%eax
    c74a:	89 c2                	mov    %eax,%edx
    c74c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c74f:	01 c0                	add    %eax,%eax
    c751:	8d 48 01             	lea    0x1(%eax),%ecx
    c754:	8b 45 18             	mov    0x18(%ebp),%eax
    c757:	01 c8                	add    %ecx,%eax
    c759:	0f b6 00             	movzbl (%eax),%eax
    c75c:	0f b6 c0             	movzbl %al,%eax
    c75f:	01 c2                	add    %eax,%edx
    c761:	8b 45 10             	mov    0x10(%ebp),%eax
    c764:	66 89 10             	mov    %dx,(%eax)
    c767:	8b 45 10             	mov    0x10(%ebp),%eax
    c76a:	0f b7 10             	movzwl (%eax),%edx
    c76d:	8b 45 0c             	mov    0xc(%ebp),%eax
    c770:	66 89 10             	mov    %dx,(%eax)
    c773:	8b 45 0c             	mov    0xc(%ebp),%eax
    c776:	0f b7 10             	movzwl (%eax),%edx
    c779:	8b 45 08             	mov    0x8(%ebp),%eax
    c77c:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    c77f:	8b 45 20             	mov    0x20(%ebp),%eax
    c782:	8b 40 10             	mov    0x10(%eax),%eax
    c785:	85 c0                	test   %eax,%eax
    c787:	74 43                	je     c7cc <getPixelColorRGBA16+0xa7>
    c789:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c78c:	01 c0                	add    %eax,%eax
    c78e:	89 c2                	mov    %eax,%edx
    c790:	8b 45 18             	mov    0x18(%ebp),%eax
    c793:	01 d0                	add    %edx,%eax
    c795:	0f b6 00             	movzbl (%eax),%eax
    c798:	0f b6 c0             	movzbl %al,%eax
    c79b:	c1 e0 08             	shl    $0x8,%eax
    c79e:	89 c2                	mov    %eax,%edx
    c7a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c7a3:	01 c0                	add    %eax,%eax
    c7a5:	8d 48 01             	lea    0x1(%eax),%ecx
    c7a8:	8b 45 18             	mov    0x18(%ebp),%eax
    c7ab:	01 c8                	add    %ecx,%eax
    c7ad:	0f b6 00             	movzbl (%eax),%eax
    c7b0:	0f b6 c0             	movzbl %al,%eax
    c7b3:	01 c2                	add    %eax,%edx
    c7b5:	8b 45 20             	mov    0x20(%ebp),%eax
    c7b8:	8b 40 14             	mov    0x14(%eax),%eax
    c7bb:	39 c2                	cmp    %eax,%edx
    c7bd:	75 0d                	jne    c7cc <getPixelColorRGBA16+0xa7>
    c7bf:	8b 45 14             	mov    0x14(%ebp),%eax
    c7c2:	66 c7 00 00 00       	movw   $0x0,(%eax)
    c7c7:	e9 48 03 00 00       	jmp    cb14 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    c7cc:	8b 45 14             	mov    0x14(%ebp),%eax
    c7cf:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    c7d4:	e9 3b 03 00 00       	jmp    cb14 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    c7d9:	8b 45 20             	mov    0x20(%ebp),%eax
    c7dc:	8b 00                	mov    (%eax),%eax
    c7de:	83 f8 02             	cmp    $0x2,%eax
    c7e1:	0f 85 b6 01 00 00    	jne    c99d <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    c7e7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c7ea:	89 d0                	mov    %edx,%eax
    c7ec:	01 c0                	add    %eax,%eax
    c7ee:	01 d0                	add    %edx,%eax
    c7f0:	01 c0                	add    %eax,%eax
    c7f2:	89 c2                	mov    %eax,%edx
    c7f4:	8b 45 18             	mov    0x18(%ebp),%eax
    c7f7:	01 d0                	add    %edx,%eax
    c7f9:	0f b6 00             	movzbl (%eax),%eax
    c7fc:	0f b6 c0             	movzbl %al,%eax
    c7ff:	c1 e0 08             	shl    $0x8,%eax
    c802:	89 c1                	mov    %eax,%ecx
    c804:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c807:	89 d0                	mov    %edx,%eax
    c809:	01 c0                	add    %eax,%eax
    c80b:	01 d0                	add    %edx,%eax
    c80d:	01 c0                	add    %eax,%eax
    c80f:	8d 50 01             	lea    0x1(%eax),%edx
    c812:	8b 45 18             	mov    0x18(%ebp),%eax
    c815:	01 d0                	add    %edx,%eax
    c817:	0f b6 00             	movzbl (%eax),%eax
    c81a:	0f b6 c0             	movzbl %al,%eax
    c81d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c820:	8b 45 08             	mov    0x8(%ebp),%eax
    c823:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    c826:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c829:	89 d0                	mov    %edx,%eax
    c82b:	01 c0                	add    %eax,%eax
    c82d:	01 d0                	add    %edx,%eax
    c82f:	01 c0                	add    %eax,%eax
    c831:	8d 50 02             	lea    0x2(%eax),%edx
    c834:	8b 45 18             	mov    0x18(%ebp),%eax
    c837:	01 d0                	add    %edx,%eax
    c839:	0f b6 00             	movzbl (%eax),%eax
    c83c:	0f b6 c0             	movzbl %al,%eax
    c83f:	c1 e0 08             	shl    $0x8,%eax
    c842:	89 c1                	mov    %eax,%ecx
    c844:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c847:	89 d0                	mov    %edx,%eax
    c849:	01 c0                	add    %eax,%eax
    c84b:	01 d0                	add    %edx,%eax
    c84d:	01 c0                	add    %eax,%eax
    c84f:	8d 50 03             	lea    0x3(%eax),%edx
    c852:	8b 45 18             	mov    0x18(%ebp),%eax
    c855:	01 d0                	add    %edx,%eax
    c857:	0f b6 00             	movzbl (%eax),%eax
    c85a:	0f b6 c0             	movzbl %al,%eax
    c85d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c860:	8b 45 0c             	mov    0xc(%ebp),%eax
    c863:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    c866:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c869:	89 d0                	mov    %edx,%eax
    c86b:	01 c0                	add    %eax,%eax
    c86d:	01 d0                	add    %edx,%eax
    c86f:	01 c0                	add    %eax,%eax
    c871:	8d 50 04             	lea    0x4(%eax),%edx
    c874:	8b 45 18             	mov    0x18(%ebp),%eax
    c877:	01 d0                	add    %edx,%eax
    c879:	0f b6 00             	movzbl (%eax),%eax
    c87c:	0f b6 c0             	movzbl %al,%eax
    c87f:	c1 e0 08             	shl    $0x8,%eax
    c882:	89 c1                	mov    %eax,%ecx
    c884:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c887:	89 d0                	mov    %edx,%eax
    c889:	01 c0                	add    %eax,%eax
    c88b:	01 d0                	add    %edx,%eax
    c88d:	01 c0                	add    %eax,%eax
    c88f:	8d 50 05             	lea    0x5(%eax),%edx
    c892:	8b 45 18             	mov    0x18(%ebp),%eax
    c895:	01 d0                	add    %edx,%eax
    c897:	0f b6 00             	movzbl (%eax),%eax
    c89a:	0f b6 c0             	movzbl %al,%eax
    c89d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c8a0:	8b 45 10             	mov    0x10(%ebp),%eax
    c8a3:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    c8a6:	8b 45 20             	mov    0x20(%ebp),%eax
    c8a9:	8b 40 10             	mov    0x10(%eax),%eax
    c8ac:	85 c0                	test   %eax,%eax
    c8ae:	0f 84 dc 00 00 00    	je     c990 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    c8b4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c8b7:	89 d0                	mov    %edx,%eax
    c8b9:	01 c0                	add    %eax,%eax
    c8bb:	01 d0                	add    %edx,%eax
    c8bd:	01 c0                	add    %eax,%eax
    c8bf:	89 c2                	mov    %eax,%edx
    c8c1:	8b 45 18             	mov    0x18(%ebp),%eax
    c8c4:	01 d0                	add    %edx,%eax
    c8c6:	0f b6 00             	movzbl (%eax),%eax
    c8c9:	0f b6 c0             	movzbl %al,%eax
    c8cc:	c1 e0 08             	shl    $0x8,%eax
    c8cf:	89 c1                	mov    %eax,%ecx
    c8d1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c8d4:	89 d0                	mov    %edx,%eax
    c8d6:	01 c0                	add    %eax,%eax
    c8d8:	01 d0                	add    %edx,%eax
    c8da:	01 c0                	add    %eax,%eax
    c8dc:	8d 50 01             	lea    0x1(%eax),%edx
    c8df:	8b 45 18             	mov    0x18(%ebp),%eax
    c8e2:	01 d0                	add    %edx,%eax
    c8e4:	0f b6 00             	movzbl (%eax),%eax
    c8e7:	0f b6 c0             	movzbl %al,%eax
    c8ea:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c8ed:	8b 45 20             	mov    0x20(%ebp),%eax
    c8f0:	8b 40 14             	mov    0x14(%eax),%eax
    c8f3:	39 c2                	cmp    %eax,%edx
    c8f5:	0f 85 95 00 00 00    	jne    c990 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    c8fb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c8fe:	89 d0                	mov    %edx,%eax
    c900:	01 c0                	add    %eax,%eax
    c902:	01 d0                	add    %edx,%eax
    c904:	01 c0                	add    %eax,%eax
    c906:	8d 50 02             	lea    0x2(%eax),%edx
    c909:	8b 45 18             	mov    0x18(%ebp),%eax
    c90c:	01 d0                	add    %edx,%eax
    c90e:	0f b6 00             	movzbl (%eax),%eax
    c911:	0f b6 c0             	movzbl %al,%eax
    c914:	c1 e0 08             	shl    $0x8,%eax
    c917:	89 c1                	mov    %eax,%ecx
    c919:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c91c:	89 d0                	mov    %edx,%eax
    c91e:	01 c0                	add    %eax,%eax
    c920:	01 d0                	add    %edx,%eax
    c922:	01 c0                	add    %eax,%eax
    c924:	8d 50 03             	lea    0x3(%eax),%edx
    c927:	8b 45 18             	mov    0x18(%ebp),%eax
    c92a:	01 d0                	add    %edx,%eax
    c92c:	0f b6 00             	movzbl (%eax),%eax
    c92f:	0f b6 c0             	movzbl %al,%eax
    c932:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c935:	8b 45 20             	mov    0x20(%ebp),%eax
    c938:	8b 40 18             	mov    0x18(%eax),%eax
    c93b:	39 c2                	cmp    %eax,%edx
    c93d:	75 51                	jne    c990 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    c93f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c942:	89 d0                	mov    %edx,%eax
    c944:	01 c0                	add    %eax,%eax
    c946:	01 d0                	add    %edx,%eax
    c948:	01 c0                	add    %eax,%eax
    c94a:	8d 50 04             	lea    0x4(%eax),%edx
    c94d:	8b 45 18             	mov    0x18(%ebp),%eax
    c950:	01 d0                	add    %edx,%eax
    c952:	0f b6 00             	movzbl (%eax),%eax
    c955:	0f b6 c0             	movzbl %al,%eax
    c958:	c1 e0 08             	shl    $0x8,%eax
    c95b:	89 c1                	mov    %eax,%ecx
    c95d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c960:	89 d0                	mov    %edx,%eax
    c962:	01 c0                	add    %eax,%eax
    c964:	01 d0                	add    %edx,%eax
    c966:	01 c0                	add    %eax,%eax
    c968:	8d 50 05             	lea    0x5(%eax),%edx
    c96b:	8b 45 18             	mov    0x18(%ebp),%eax
    c96e:	01 d0                	add    %edx,%eax
    c970:	0f b6 00             	movzbl (%eax),%eax
    c973:	0f b6 c0             	movzbl %al,%eax
    c976:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c979:	8b 45 20             	mov    0x20(%ebp),%eax
    c97c:	8b 40 1c             	mov    0x1c(%eax),%eax
    c97f:	39 c2                	cmp    %eax,%edx
    c981:	75 0d                	jne    c990 <getPixelColorRGBA16+0x26b>
    c983:	8b 45 14             	mov    0x14(%ebp),%eax
    c986:	66 c7 00 00 00       	movw   $0x0,(%eax)
    c98b:	e9 84 01 00 00       	jmp    cb14 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    c990:	8b 45 14             	mov    0x14(%ebp),%eax
    c993:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    c998:	e9 77 01 00 00       	jmp    cb14 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    c99d:	8b 45 20             	mov    0x20(%ebp),%eax
    c9a0:	8b 00                	mov    (%eax),%eax
    c9a2:	83 f8 04             	cmp    $0x4,%eax
    c9a5:	0f 85 86 00 00 00    	jne    ca31 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    c9ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c9ae:	c1 e0 02             	shl    $0x2,%eax
    c9b1:	89 c2                	mov    %eax,%edx
    c9b3:	8b 45 18             	mov    0x18(%ebp),%eax
    c9b6:	01 d0                	add    %edx,%eax
    c9b8:	0f b6 00             	movzbl (%eax),%eax
    c9bb:	0f b6 c0             	movzbl %al,%eax
    c9be:	c1 e0 08             	shl    $0x8,%eax
    c9c1:	89 c2                	mov    %eax,%edx
    c9c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c9c6:	c1 e0 02             	shl    $0x2,%eax
    c9c9:	8d 48 01             	lea    0x1(%eax),%ecx
    c9cc:	8b 45 18             	mov    0x18(%ebp),%eax
    c9cf:	01 c8                	add    %ecx,%eax
    c9d1:	0f b6 00             	movzbl (%eax),%eax
    c9d4:	0f b6 c0             	movzbl %al,%eax
    c9d7:	01 c2                	add    %eax,%edx
    c9d9:	8b 45 10             	mov    0x10(%ebp),%eax
    c9dc:	66 89 10             	mov    %dx,(%eax)
    c9df:	8b 45 10             	mov    0x10(%ebp),%eax
    c9e2:	0f b7 10             	movzwl (%eax),%edx
    c9e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    c9e8:	66 89 10             	mov    %dx,(%eax)
    c9eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    c9ee:	0f b7 10             	movzwl (%eax),%edx
    c9f1:	8b 45 08             	mov    0x8(%ebp),%eax
    c9f4:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    c9f7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c9fa:	c1 e0 02             	shl    $0x2,%eax
    c9fd:	8d 50 02             	lea    0x2(%eax),%edx
    ca00:	8b 45 18             	mov    0x18(%ebp),%eax
    ca03:	01 d0                	add    %edx,%eax
    ca05:	0f b6 00             	movzbl (%eax),%eax
    ca08:	0f b6 c0             	movzbl %al,%eax
    ca0b:	c1 e0 08             	shl    $0x8,%eax
    ca0e:	89 c2                	mov    %eax,%edx
    ca10:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ca13:	c1 e0 02             	shl    $0x2,%eax
    ca16:	8d 48 03             	lea    0x3(%eax),%ecx
    ca19:	8b 45 18             	mov    0x18(%ebp),%eax
    ca1c:	01 c8                	add    %ecx,%eax
    ca1e:	0f b6 00             	movzbl (%eax),%eax
    ca21:	0f b6 c0             	movzbl %al,%eax
    ca24:	01 c2                	add    %eax,%edx
    ca26:	8b 45 14             	mov    0x14(%ebp),%eax
    ca29:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    ca2c:	e9 e3 00 00 00       	jmp    cb14 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    ca31:	8b 45 20             	mov    0x20(%ebp),%eax
    ca34:	8b 00                	mov    (%eax),%eax
    ca36:	83 f8 06             	cmp    $0x6,%eax
    ca39:	0f 85 d5 00 00 00    	jne    cb14 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    ca3f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ca42:	c1 e0 03             	shl    $0x3,%eax
    ca45:	89 c2                	mov    %eax,%edx
    ca47:	8b 45 18             	mov    0x18(%ebp),%eax
    ca4a:	01 d0                	add    %edx,%eax
    ca4c:	0f b6 00             	movzbl (%eax),%eax
    ca4f:	0f b6 c0             	movzbl %al,%eax
    ca52:	c1 e0 08             	shl    $0x8,%eax
    ca55:	89 c2                	mov    %eax,%edx
    ca57:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ca5a:	c1 e0 03             	shl    $0x3,%eax
    ca5d:	8d 48 01             	lea    0x1(%eax),%ecx
    ca60:	8b 45 18             	mov    0x18(%ebp),%eax
    ca63:	01 c8                	add    %ecx,%eax
    ca65:	0f b6 00             	movzbl (%eax),%eax
    ca68:	0f b6 c0             	movzbl %al,%eax
    ca6b:	01 c2                	add    %eax,%edx
    ca6d:	8b 45 08             	mov    0x8(%ebp),%eax
    ca70:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    ca73:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ca76:	c1 e0 03             	shl    $0x3,%eax
    ca79:	8d 50 02             	lea    0x2(%eax),%edx
    ca7c:	8b 45 18             	mov    0x18(%ebp),%eax
    ca7f:	01 d0                	add    %edx,%eax
    ca81:	0f b6 00             	movzbl (%eax),%eax
    ca84:	0f b6 c0             	movzbl %al,%eax
    ca87:	c1 e0 08             	shl    $0x8,%eax
    ca8a:	89 c2                	mov    %eax,%edx
    ca8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ca8f:	c1 e0 03             	shl    $0x3,%eax
    ca92:	8d 48 03             	lea    0x3(%eax),%ecx
    ca95:	8b 45 18             	mov    0x18(%ebp),%eax
    ca98:	01 c8                	add    %ecx,%eax
    ca9a:	0f b6 00             	movzbl (%eax),%eax
    ca9d:	0f b6 c0             	movzbl %al,%eax
    caa0:	01 c2                	add    %eax,%edx
    caa2:	8b 45 0c             	mov    0xc(%ebp),%eax
    caa5:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    caa8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    caab:	c1 e0 03             	shl    $0x3,%eax
    caae:	8d 50 04             	lea    0x4(%eax),%edx
    cab1:	8b 45 18             	mov    0x18(%ebp),%eax
    cab4:	01 d0                	add    %edx,%eax
    cab6:	0f b6 00             	movzbl (%eax),%eax
    cab9:	0f b6 c0             	movzbl %al,%eax
    cabc:	c1 e0 08             	shl    $0x8,%eax
    cabf:	89 c2                	mov    %eax,%edx
    cac1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cac4:	c1 e0 03             	shl    $0x3,%eax
    cac7:	8d 48 05             	lea    0x5(%eax),%ecx
    caca:	8b 45 18             	mov    0x18(%ebp),%eax
    cacd:	01 c8                	add    %ecx,%eax
    cacf:	0f b6 00             	movzbl (%eax),%eax
    cad2:	0f b6 c0             	movzbl %al,%eax
    cad5:	01 c2                	add    %eax,%edx
    cad7:	8b 45 10             	mov    0x10(%ebp),%eax
    cada:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    cadd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cae0:	c1 e0 03             	shl    $0x3,%eax
    cae3:	8d 50 06             	lea    0x6(%eax),%edx
    cae6:	8b 45 18             	mov    0x18(%ebp),%eax
    cae9:	01 d0                	add    %edx,%eax
    caeb:	0f b6 00             	movzbl (%eax),%eax
    caee:	0f b6 c0             	movzbl %al,%eax
    caf1:	c1 e0 08             	shl    $0x8,%eax
    caf4:	89 c2                	mov    %eax,%edx
    caf6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    caf9:	c1 e0 03             	shl    $0x3,%eax
    cafc:	8d 48 07             	lea    0x7(%eax),%ecx
    caff:	8b 45 18             	mov    0x18(%ebp),%eax
    cb02:	01 c8                	add    %ecx,%eax
    cb04:	0f b6 00             	movzbl (%eax),%eax
    cb07:	0f b6 c0             	movzbl %al,%eax
    cb0a:	01 c2                	add    %eax,%edx
    cb0c:	8b 45 14             	mov    0x14(%ebp),%eax
    cb0f:	66 89 10             	mov    %dx,(%eax)
  }
}
    cb12:	eb 00                	jmp    cb14 <getPixelColorRGBA16+0x3ef>
    cb14:	90                   	nop
    cb15:	5d                   	pop    %ebp
    cb16:	c3                   	ret    

0000cb17 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    cb17:	55                   	push   %ebp
    cb18:	89 e5                	mov    %esp,%ebp
    cb1a:	56                   	push   %esi
    cb1b:	53                   	push   %ebx
    cb1c:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    cb1f:	8b 55 18             	mov    0x18(%ebp),%edx
    cb22:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cb25:	0f af c2             	imul   %edx,%eax
    cb28:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    cb2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    cb32:	8b 45 14             	mov    0x14(%ebp),%eax
    cb35:	8b 00                	mov    (%eax),%eax
    cb37:	83 f8 03             	cmp    $0x3,%eax
    cb3a:	75 14                	jne    cb50 <lodepng_convert+0x39>
    cb3c:	8b 45 14             	mov    0x14(%ebp),%eax
    cb3f:	8b 40 08             	mov    0x8(%eax),%eax
    cb42:	85 c0                	test   %eax,%eax
    cb44:	75 0a                	jne    cb50 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    cb46:	b8 6b 00 00 00       	mov    $0x6b,%eax
    cb4b:	e9 19 03 00 00       	jmp    ce69 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    cb50:	ff 75 14             	pushl  0x14(%ebp)
    cb53:	ff 75 10             	pushl  0x10(%ebp)
    cb56:	e8 b7 d1 ff ff       	call   9d12 <lodepng_color_mode_equal>
    cb5b:	83 c4 08             	add    $0x8,%esp
    cb5e:	85 c0                	test   %eax,%eax
    cb60:	74 2f                	je     cb91 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    cb62:	ff 75 14             	pushl  0x14(%ebp)
    cb65:	ff 75 1c             	pushl  0x1c(%ebp)
    cb68:	ff 75 18             	pushl  0x18(%ebp)
    cb6b:	e8 fb d4 ff ff       	call   a06b <lodepng_get_raw_size>
    cb70:	83 c4 0c             	add    $0xc,%esp
    cb73:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    cb76:	ff 75 dc             	pushl  -0x24(%ebp)
    cb79:	ff 75 0c             	pushl  0xc(%ebp)
    cb7c:	ff 75 08             	pushl  0x8(%ebp)
    cb7f:	e8 ca 78 ff ff       	call   444e <lodepng_memcpy>
    cb84:	83 c4 0c             	add    $0xc,%esp
    return 0;
    cb87:	b8 00 00 00 00       	mov    $0x0,%eax
    cb8c:	e9 d8 02 00 00       	jmp    ce69 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    cb91:	8b 45 10             	mov    0x10(%ebp),%eax
    cb94:	8b 00                	mov    (%eax),%eax
    cb96:	83 f8 03             	cmp    $0x3,%eax
    cb99:	0f 85 16 01 00 00    	jne    ccb5 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    cb9f:	8b 45 10             	mov    0x10(%ebp),%eax
    cba2:	8b 40 0c             	mov    0xc(%eax),%eax
    cba5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    cba8:	8b 45 10             	mov    0x10(%ebp),%eax
    cbab:	8b 40 08             	mov    0x8(%eax),%eax
    cbae:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    cbb1:	8b 45 10             	mov    0x10(%ebp),%eax
    cbb4:	8b 40 04             	mov    0x4(%eax),%eax
    cbb7:	ba 01 00 00 00       	mov    $0x1,%edx
    cbbc:	89 c1                	mov    %eax,%ecx
    cbbe:	d3 e2                	shl    %cl,%edx
    cbc0:	89 d0                	mov    %edx,%eax
    cbc2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    cbc5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cbc9:	75 5b                	jne    cc26 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    cbcb:	8b 45 14             	mov    0x14(%ebp),%eax
    cbce:	8b 40 0c             	mov    0xc(%eax),%eax
    cbd1:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    cbd4:	8b 45 14             	mov    0x14(%ebp),%eax
    cbd7:	8b 40 08             	mov    0x8(%eax),%eax
    cbda:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    cbdd:	8b 45 14             	mov    0x14(%ebp),%eax
    cbe0:	8b 00                	mov    (%eax),%eax
    cbe2:	83 f8 03             	cmp    $0x3,%eax
    cbe5:	75 3f                	jne    cc26 <lodepng_convert+0x10f>
    cbe7:	8b 45 14             	mov    0x14(%ebp),%eax
    cbea:	8b 50 04             	mov    0x4(%eax),%edx
    cbed:	8b 45 10             	mov    0x10(%ebp),%eax
    cbf0:	8b 40 04             	mov    0x4(%eax),%eax
    cbf3:	39 c2                	cmp    %eax,%edx
    cbf5:	75 2f                	jne    cc26 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    cbf7:	ff 75 14             	pushl  0x14(%ebp)
    cbfa:	ff 75 1c             	pushl  0x1c(%ebp)
    cbfd:	ff 75 18             	pushl  0x18(%ebp)
    cc00:	e8 66 d4 ff ff       	call   a06b <lodepng_get_raw_size>
    cc05:	83 c4 0c             	add    $0xc,%esp
    cc08:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    cc0b:	ff 75 d8             	pushl  -0x28(%ebp)
    cc0e:	ff 75 0c             	pushl  0xc(%ebp)
    cc11:	ff 75 08             	pushl  0x8(%ebp)
    cc14:	e8 35 78 ff ff       	call   444e <lodepng_memcpy>
    cc19:	83 c4 0c             	add    $0xc,%esp
        return 0;
    cc1c:	b8 00 00 00 00       	mov    $0x0,%eax
    cc21:	e9 43 02 00 00       	jmp    ce69 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    cc26:	8b 45 ec             	mov    -0x14(%ebp),%eax
    cc29:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    cc2c:	7d 06                	jge    cc34 <lodepng_convert+0x11d>
    cc2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    cc31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    cc34:	8d 45 90             	lea    -0x70(%ebp),%eax
    cc37:	50                   	push   %eax
    cc38:	e8 5f e1 ff ff       	call   ad9c <color_tree_init>
    cc3d:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    cc40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cc47:	eb 61                	jmp    ccaa <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    cc49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc4c:	c1 e0 02             	shl    $0x2,%eax
    cc4f:	89 c2                	mov    %eax,%edx
    cc51:	8b 45 e8             	mov    -0x18(%ebp),%eax
    cc54:	01 d0                	add    %edx,%eax
    cc56:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    cc59:	8b 75 f4             	mov    -0xc(%ebp),%esi
    cc5c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cc5f:	83 c0 03             	add    $0x3,%eax
    cc62:	0f b6 00             	movzbl (%eax),%eax
    cc65:	0f b6 d8             	movzbl %al,%ebx
    cc68:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cc6b:	83 c0 02             	add    $0x2,%eax
    cc6e:	0f b6 00             	movzbl (%eax),%eax
    cc71:	0f b6 c8             	movzbl %al,%ecx
    cc74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cc77:	83 c0 01             	add    $0x1,%eax
    cc7a:	0f b6 00             	movzbl (%eax),%eax
    cc7d:	0f b6 d0             	movzbl %al,%edx
    cc80:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cc83:	0f b6 00             	movzbl (%eax),%eax
    cc86:	0f b6 c0             	movzbl %al,%eax
    cc89:	83 ec 08             	sub    $0x8,%esp
    cc8c:	56                   	push   %esi
    cc8d:	53                   	push   %ebx
    cc8e:	51                   	push   %ecx
    cc8f:	52                   	push   %edx
    cc90:	50                   	push   %eax
    cc91:	8d 45 90             	lea    -0x70(%ebp),%eax
    cc94:	50                   	push   %eax
    cc95:	e8 85 e2 ff ff       	call   af1f <color_tree_add>
    cc9a:	83 c4 20             	add    $0x20,%esp
    cc9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    cca0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cca4:	75 0e                	jne    ccb4 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    cca6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ccaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ccad:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    ccb0:	75 97                	jne    cc49 <lodepng_convert+0x132>
    ccb2:	eb 01                	jmp    ccb5 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    ccb4:	90                   	nop
    }
  }

  if(!error) {
    ccb5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ccb9:	0f 85 8e 01 00 00    	jne    ce4d <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    ccbf:	8b 45 14             	mov    0x14(%ebp),%eax
    ccc2:	8b 40 04             	mov    0x4(%eax),%eax
    ccc5:	83 f8 10             	cmp    $0x10,%eax
    ccc8:	0f 85 99 00 00 00    	jne    cd67 <lodepng_convert+0x250>
    ccce:	8b 45 10             	mov    0x10(%ebp),%eax
    ccd1:	8b 40 04             	mov    0x4(%eax),%eax
    ccd4:	83 f8 10             	cmp    $0x10,%eax
    ccd7:	0f 85 8a 00 00 00    	jne    cd67 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    ccdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cce4:	eb 74                	jmp    cd5a <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    cce6:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    ccec:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    ccf2:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    ccf8:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    ccfe:	83 ec 04             	sub    $0x4,%esp
    cd01:	ff 75 14             	pushl  0x14(%ebp)
    cd04:	ff 75 f4             	pushl  -0xc(%ebp)
    cd07:	ff 75 0c             	pushl  0xc(%ebp)
    cd0a:	8d 45 88             	lea    -0x78(%ebp),%eax
    cd0d:	50                   	push   %eax
    cd0e:	8d 45 8a             	lea    -0x76(%ebp),%eax
    cd11:	50                   	push   %eax
    cd12:	8d 45 8c             	lea    -0x74(%ebp),%eax
    cd15:	50                   	push   %eax
    cd16:	8d 45 8e             	lea    -0x72(%ebp),%eax
    cd19:	50                   	push   %eax
    cd1a:	e8 06 fa ff ff       	call   c725 <getPixelColorRGBA16>
    cd1f:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    cd22:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    cd26:	0f b7 d8             	movzwl %ax,%ebx
    cd29:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    cd2d:	0f b7 c8             	movzwl %ax,%ecx
    cd30:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    cd34:	0f b7 d0             	movzwl %ax,%edx
    cd37:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    cd3b:	0f b7 c0             	movzwl %ax,%eax
    cd3e:	83 ec 04             	sub    $0x4,%esp
    cd41:	53                   	push   %ebx
    cd42:	51                   	push   %ecx
    cd43:	52                   	push   %edx
    cd44:	50                   	push   %eax
    cd45:	ff 75 10             	pushl  0x10(%ebp)
    cd48:	ff 75 f4             	pushl  -0xc(%ebp)
    cd4b:	ff 75 08             	pushl  0x8(%ebp)
    cd4e:	e8 d3 e6 ff ff       	call   b426 <rgba16ToPixel>
    cd53:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    cd56:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cd5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cd5d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    cd60:	75 84                	jne    cce6 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    cd62:	e9 e6 00 00 00       	jmp    ce4d <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    cd67:	8b 45 10             	mov    0x10(%ebp),%eax
    cd6a:	8b 40 04             	mov    0x4(%eax),%eax
    cd6d:	83 f8 08             	cmp    $0x8,%eax
    cd70:	75 23                	jne    cd95 <lodepng_convert+0x27e>
    cd72:	8b 45 10             	mov    0x10(%ebp),%eax
    cd75:	8b 00                	mov    (%eax),%eax
    cd77:	83 f8 06             	cmp    $0x6,%eax
    cd7a:	75 19                	jne    cd95 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    cd7c:	ff 75 14             	pushl  0x14(%ebp)
    cd7f:	ff 75 0c             	pushl  0xc(%ebp)
    cd82:	ff 75 e0             	pushl  -0x20(%ebp)
    cd85:	ff 75 08             	pushl  0x8(%ebp)
    cd88:	e8 ae ee ff ff       	call   bc3b <getPixelColorsRGBA8>
    cd8d:	83 c4 10             	add    $0x10,%esp
    cd90:	e9 b8 00 00 00       	jmp    ce4d <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    cd95:	8b 45 10             	mov    0x10(%ebp),%eax
    cd98:	8b 40 04             	mov    0x4(%eax),%eax
    cd9b:	83 f8 08             	cmp    $0x8,%eax
    cd9e:	75 23                	jne    cdc3 <lodepng_convert+0x2ac>
    cda0:	8b 45 10             	mov    0x10(%ebp),%eax
    cda3:	8b 00                	mov    (%eax),%eax
    cda5:	83 f8 02             	cmp    $0x2,%eax
    cda8:	75 19                	jne    cdc3 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    cdaa:	ff 75 14             	pushl  0x14(%ebp)
    cdad:	ff 75 0c             	pushl  0xc(%ebp)
    cdb0:	ff 75 e0             	pushl  -0x20(%ebp)
    cdb3:	ff 75 08             	pushl  0x8(%ebp)
    cdb6:	e8 50 f5 ff ff       	call   c30b <getPixelColorsRGB8>
    cdbb:	83 c4 10             	add    $0x10,%esp
    cdbe:	e9 8a 00 00 00       	jmp    ce4d <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    cdc3:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    cdc7:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    cdcb:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    cdcf:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    cdd3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cdda:	eb 66                	jmp    ce42 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cddc:	83 ec 04             	sub    $0x4,%esp
    cddf:	ff 75 14             	pushl  0x14(%ebp)
    cde2:	ff 75 f4             	pushl  -0xc(%ebp)
    cde5:	ff 75 0c             	pushl  0xc(%ebp)
    cde8:	8d 45 84             	lea    -0x7c(%ebp),%eax
    cdeb:	50                   	push   %eax
    cdec:	8d 45 85             	lea    -0x7b(%ebp),%eax
    cdef:	50                   	push   %eax
    cdf0:	8d 45 86             	lea    -0x7a(%ebp),%eax
    cdf3:	50                   	push   %eax
    cdf4:	8d 45 87             	lea    -0x79(%ebp),%eax
    cdf7:	50                   	push   %eax
    cdf8:	e8 71 e8 ff ff       	call   b66e <getPixelColorRGBA8>
    cdfd:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    ce00:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    ce04:	0f b6 d8             	movzbl %al,%ebx
    ce07:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    ce0b:	0f b6 c8             	movzbl %al,%ecx
    ce0e:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    ce12:	0f b6 d0             	movzbl %al,%edx
    ce15:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    ce19:	0f b6 c0             	movzbl %al,%eax
    ce1c:	53                   	push   %ebx
    ce1d:	51                   	push   %ecx
    ce1e:	52                   	push   %edx
    ce1f:	50                   	push   %eax
    ce20:	8d 45 90             	lea    -0x70(%ebp),%eax
    ce23:	50                   	push   %eax
    ce24:	ff 75 10             	pushl  0x10(%ebp)
    ce27:	ff 75 f4             	pushl  -0xc(%ebp)
    ce2a:	ff 75 08             	pushl  0x8(%ebp)
    ce2d:	e8 e5 e1 ff ff       	call   b017 <rgba8ToPixel>
    ce32:	83 c4 20             	add    $0x20,%esp
    ce35:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    ce38:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ce3c:	75 0e                	jne    ce4c <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    ce3e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ce42:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ce45:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    ce48:	75 92                	jne    cddc <lodepng_convert+0x2c5>
    ce4a:	eb 01                	jmp    ce4d <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    ce4c:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    ce4d:	8b 45 10             	mov    0x10(%ebp),%eax
    ce50:	8b 00                	mov    (%eax),%eax
    ce52:	83 f8 03             	cmp    $0x3,%eax
    ce55:	75 0f                	jne    ce66 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    ce57:	83 ec 0c             	sub    $0xc,%esp
    ce5a:	8d 45 90             	lea    -0x70(%ebp),%eax
    ce5d:	50                   	push   %eax
    ce5e:	e8 59 df ff ff       	call   adbc <color_tree_cleanup>
    ce63:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    ce66:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    ce69:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ce6c:	5b                   	pop    %ebx
    ce6d:	5e                   	pop    %esi
    ce6e:	5d                   	pop    %ebp
    ce6f:	c3                   	ret    

0000ce70 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    ce70:	55                   	push   %ebp
    ce71:	89 e5                	mov    %esp,%ebp
    ce73:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    ce76:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ce7d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ce84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    ce8b:	8b 45 24             	mov    0x24(%ebp),%eax
    ce8e:	8b 40 04             	mov    0x4(%eax),%eax
    ce91:	ba 01 00 00 00       	mov    $0x1,%edx
    ce96:	89 c1                	mov    %eax,%ecx
    ce98:	d3 e2                	shl    %cl,%edx
    ce9a:	89 d0                	mov    %edx,%eax
    ce9c:	8d 48 ff             	lea    -0x1(%eax),%ecx
    ce9f:	b8 ff ff 00 00       	mov    $0xffff,%eax
    cea4:	ba 00 00 00 00       	mov    $0x0,%edx
    cea9:	f7 f1                	div    %ecx
    ceab:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    ceae:	8b 45 20             	mov    0x20(%ebp),%eax
    ceb1:	8b 40 04             	mov    0x4(%eax),%eax
    ceb4:	ba 10 00 00 00       	mov    $0x10,%edx
    ceb9:	29 c2                	sub    %eax,%edx
    cebb:	89 d0                	mov    %edx,%eax
    cebd:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    cec0:	8b 45 24             	mov    0x24(%ebp),%eax
    cec3:	8b 00                	mov    (%eax),%eax
    cec5:	85 c0                	test   %eax,%eax
    cec7:	74 0a                	je     ced3 <lodepng_convert_rgb+0x63>
    cec9:	8b 45 24             	mov    0x24(%ebp),%eax
    cecc:	8b 00                	mov    (%eax),%eax
    cece:	83 f8 04             	cmp    $0x4,%eax
    ced1:	75 1b                	jne    ceee <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    ced3:	8b 45 14             	mov    0x14(%ebp),%eax
    ced6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    ceda:	89 45 f4             	mov    %eax,-0xc(%ebp)
    cedd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cee0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    cee3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cee6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    cee9:	e9 c2 00 00 00       	jmp    cfb0 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    ceee:	8b 45 24             	mov    0x24(%ebp),%eax
    cef1:	8b 00                	mov    (%eax),%eax
    cef3:	83 f8 02             	cmp    $0x2,%eax
    cef6:	74 0a                	je     cf02 <lodepng_convert_rgb+0x92>
    cef8:	8b 45 24             	mov    0x24(%ebp),%eax
    cefb:	8b 00                	mov    (%eax),%eax
    cefd:	83 f8 06             	cmp    $0x6,%eax
    cf00:	75 23                	jne    cf25 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    cf02:	8b 45 14             	mov    0x14(%ebp),%eax
    cf05:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    cf09:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    cf0c:	8b 45 18             	mov    0x18(%ebp),%eax
    cf0f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    cf13:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    cf16:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cf19:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    cf1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    cf20:	e9 8b 00 00 00       	jmp    cfb0 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    cf25:	8b 45 24             	mov    0x24(%ebp),%eax
    cf28:	8b 00                	mov    (%eax),%eax
    cf2a:	83 f8 03             	cmp    $0x3,%eax
    cf2d:	75 77                	jne    cfa6 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    cf2f:	8b 45 24             	mov    0x24(%ebp),%eax
    cf32:	8b 40 0c             	mov    0xc(%eax),%eax
    cf35:	3b 45 14             	cmp    0x14(%ebp),%eax
    cf38:	77 0a                	ja     cf44 <lodepng_convert_rgb+0xd4>
    cf3a:	b8 52 00 00 00       	mov    $0x52,%eax
    cf3f:	e9 cb 01 00 00       	jmp    d10f <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    cf44:	8b 45 24             	mov    0x24(%ebp),%eax
    cf47:	8b 40 08             	mov    0x8(%eax),%eax
    cf4a:	8b 55 14             	mov    0x14(%ebp),%edx
    cf4d:	c1 e2 02             	shl    $0x2,%edx
    cf50:	01 d0                	add    %edx,%eax
    cf52:	0f b6 00             	movzbl (%eax),%eax
    cf55:	0f b6 d0             	movzbl %al,%edx
    cf58:	89 d0                	mov    %edx,%eax
    cf5a:	c1 e0 08             	shl    $0x8,%eax
    cf5d:	01 d0                	add    %edx,%eax
    cf5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    cf62:	8b 45 24             	mov    0x24(%ebp),%eax
    cf65:	8b 40 08             	mov    0x8(%eax),%eax
    cf68:	8b 55 14             	mov    0x14(%ebp),%edx
    cf6b:	c1 e2 02             	shl    $0x2,%edx
    cf6e:	83 c2 01             	add    $0x1,%edx
    cf71:	01 d0                	add    %edx,%eax
    cf73:	0f b6 00             	movzbl (%eax),%eax
    cf76:	0f b6 d0             	movzbl %al,%edx
    cf79:	89 d0                	mov    %edx,%eax
    cf7b:	c1 e0 08             	shl    $0x8,%eax
    cf7e:	01 d0                	add    %edx,%eax
    cf80:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    cf83:	8b 45 24             	mov    0x24(%ebp),%eax
    cf86:	8b 40 08             	mov    0x8(%eax),%eax
    cf89:	8b 55 14             	mov    0x14(%ebp),%edx
    cf8c:	c1 e2 02             	shl    $0x2,%edx
    cf8f:	83 c2 02             	add    $0x2,%edx
    cf92:	01 d0                	add    %edx,%eax
    cf94:	0f b6 00             	movzbl (%eax),%eax
    cf97:	0f b6 d0             	movzbl %al,%edx
    cf9a:	89 d0                	mov    %edx,%eax
    cf9c:	c1 e0 08             	shl    $0x8,%eax
    cf9f:	01 d0                	add    %edx,%eax
    cfa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    cfa4:	eb 0a                	jmp    cfb0 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    cfa6:	b8 1f 00 00 00       	mov    $0x1f,%eax
    cfab:	e9 5f 01 00 00       	jmp    d10f <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    cfb0:	8b 45 20             	mov    0x20(%ebp),%eax
    cfb3:	8b 00                	mov    (%eax),%eax
    cfb5:	85 c0                	test   %eax,%eax
    cfb7:	74 0a                	je     cfc3 <lodepng_convert_rgb+0x153>
    cfb9:	8b 45 20             	mov    0x20(%ebp),%eax
    cfbc:	8b 00                	mov    (%eax),%eax
    cfbe:	83 f8 04             	cmp    $0x4,%eax
    cfc1:	75 14                	jne    cfd7 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    cfc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    cfc6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    cfc9:	89 c1                	mov    %eax,%ecx
    cfcb:	d3 ea                	shr    %cl,%edx
    cfcd:	8b 45 08             	mov    0x8(%ebp),%eax
    cfd0:	89 10                	mov    %edx,(%eax)
    cfd2:	e9 33 01 00 00       	jmp    d10a <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    cfd7:	8b 45 20             	mov    0x20(%ebp),%eax
    cfda:	8b 00                	mov    (%eax),%eax
    cfdc:	83 f8 02             	cmp    $0x2,%eax
    cfdf:	74 0a                	je     cfeb <lodepng_convert_rgb+0x17b>
    cfe1:	8b 45 20             	mov    0x20(%ebp),%eax
    cfe4:	8b 00                	mov    (%eax),%eax
    cfe6:	83 f8 06             	cmp    $0x6,%eax
    cfe9:	75 32                	jne    d01d <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    cfeb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    cfee:	8b 55 fc             	mov    -0x4(%ebp),%edx
    cff1:	89 c1                	mov    %eax,%ecx
    cff3:	d3 ea                	shr    %cl,%edx
    cff5:	8b 45 08             	mov    0x8(%ebp),%eax
    cff8:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    cffa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    cffd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    d000:	89 c1                	mov    %eax,%ecx
    d002:	d3 ea                	shr    %cl,%edx
    d004:	8b 45 0c             	mov    0xc(%ebp),%eax
    d007:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    d009:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d00c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d00f:	89 c1                	mov    %eax,%ecx
    d011:	d3 ea                	shr    %cl,%edx
    d013:	8b 45 10             	mov    0x10(%ebp),%eax
    d016:	89 10                	mov    %edx,(%eax)
    d018:	e9 ed 00 00 00       	jmp    d10a <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    d01d:	8b 45 20             	mov    0x20(%ebp),%eax
    d020:	8b 00                	mov    (%eax),%eax
    d022:	83 f8 03             	cmp    $0x3,%eax
    d025:	0f 85 d8 00 00 00    	jne    d103 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    d02b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d02e:	c1 e8 08             	shr    $0x8,%eax
    d031:	89 c2                	mov    %eax,%edx
    d033:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d036:	0f b6 c0             	movzbl %al,%eax
    d039:	39 c2                	cmp    %eax,%edx
    d03b:	75 24                	jne    d061 <lodepng_convert_rgb+0x1f1>
    d03d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d040:	c1 e8 08             	shr    $0x8,%eax
    d043:	89 c2                	mov    %eax,%edx
    d045:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d048:	0f b6 c0             	movzbl %al,%eax
    d04b:	39 c2                	cmp    %eax,%edx
    d04d:	75 12                	jne    d061 <lodepng_convert_rgb+0x1f1>
    d04f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d052:	c1 e8 08             	shr    $0x8,%eax
    d055:	89 c2                	mov    %eax,%edx
    d057:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d05a:	0f b6 c0             	movzbl %al,%eax
    d05d:	39 c2                	cmp    %eax,%edx
    d05f:	74 0a                	je     d06b <lodepng_convert_rgb+0x1fb>
    d061:	b8 52 00 00 00       	mov    $0x52,%eax
    d066:	e9 a4 00 00 00       	jmp    d10f <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    d06b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d072:	eb 79                	jmp    d0ed <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    d074:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d077:	c1 e0 02             	shl    $0x2,%eax
    d07a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    d07d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d080:	c1 e8 08             	shr    $0x8,%eax
    d083:	89 c1                	mov    %eax,%ecx
    d085:	8b 45 20             	mov    0x20(%ebp),%eax
    d088:	8b 50 08             	mov    0x8(%eax),%edx
    d08b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d08e:	01 d0                	add    %edx,%eax
    d090:	0f b6 00             	movzbl (%eax),%eax
    d093:	0f b6 c0             	movzbl %al,%eax
    d096:	39 c1                	cmp    %eax,%ecx
    d098:	75 4f                	jne    d0e9 <lodepng_convert_rgb+0x279>
    d09a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d09d:	c1 e8 08             	shr    $0x8,%eax
    d0a0:	89 c1                	mov    %eax,%ecx
    d0a2:	8b 45 20             	mov    0x20(%ebp),%eax
    d0a5:	8b 40 08             	mov    0x8(%eax),%eax
    d0a8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    d0ab:	83 c2 01             	add    $0x1,%edx
    d0ae:	01 d0                	add    %edx,%eax
    d0b0:	0f b6 00             	movzbl (%eax),%eax
    d0b3:	0f b6 c0             	movzbl %al,%eax
    d0b6:	39 c1                	cmp    %eax,%ecx
    d0b8:	75 2f                	jne    d0e9 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    d0ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0bd:	c1 e8 08             	shr    $0x8,%eax
    d0c0:	89 c1                	mov    %eax,%ecx
    d0c2:	8b 45 20             	mov    0x20(%ebp),%eax
    d0c5:	8b 40 08             	mov    0x8(%eax),%eax
    d0c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    d0cb:	83 c2 02             	add    $0x2,%edx
    d0ce:	01 d0                	add    %edx,%eax
    d0d0:	0f b6 00             	movzbl (%eax),%eax
    d0d3:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    d0d6:	39 c1                	cmp    %eax,%ecx
    d0d8:	75 0f                	jne    d0e9 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    d0da:	8b 45 08             	mov    0x8(%ebp),%eax
    d0dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d0e0:	89 10                	mov    %edx,(%eax)
        return 0;
    d0e2:	b8 00 00 00 00       	mov    $0x0,%eax
    d0e7:	eb 26                	jmp    d10f <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    d0e9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    d0ed:	8b 45 20             	mov    0x20(%ebp),%eax
    d0f0:	8b 40 0c             	mov    0xc(%eax),%eax
    d0f3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    d0f6:	0f 87 78 ff ff ff    	ja     d074 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    d0fc:	b8 52 00 00 00       	mov    $0x52,%eax
    d101:	eb 0c                	jmp    d10f <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    d103:	b8 1f 00 00 00       	mov    $0x1f,%eax
    d108:	eb 05                	jmp    d10f <lodepng_convert_rgb+0x29f>
  }

  return 0;
    d10a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d10f:	c9                   	leave  
    d110:	c3                   	ret    

0000d111 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    d111:	55                   	push   %ebp
    d112:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    d114:	8b 45 08             	mov    0x8(%ebp),%eax
    d117:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    d11d:	8b 45 08             	mov    0x8(%ebp),%eax
    d120:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    d127:	8b 45 08             	mov    0x8(%ebp),%eax
    d12a:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    d130:	8b 45 08             	mov    0x8(%ebp),%eax
    d133:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d137:	8b 45 08             	mov    0x8(%ebp),%eax
    d13a:	66 89 50 0a          	mov    %dx,0xa(%eax)
    d13e:	8b 45 08             	mov    0x8(%ebp),%eax
    d141:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d145:	8b 45 08             	mov    0x8(%ebp),%eax
    d148:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    d14c:	8b 45 08             	mov    0x8(%ebp),%eax
    d14f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    d156:	8b 45 08             	mov    0x8(%ebp),%eax
    d159:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    d160:	8b 45 08             	mov    0x8(%ebp),%eax
    d163:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    d16a:	00 00 00 
  stats->numpixels = 0;
    d16d:	8b 45 08             	mov    0x8(%ebp),%eax
    d170:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    d177:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    d17a:	8b 45 08             	mov    0x8(%ebp),%eax
    d17d:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    d184:	00 00 00 
  stats->allow_greyscale = 1;
    d187:	8b 45 08             	mov    0x8(%ebp),%eax
    d18a:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    d191:	00 00 00 
}
    d194:	90                   	nop
    d195:	5d                   	pop    %ebp
    d196:	c3                   	ret    

0000d197 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    d197:	55                   	push   %ebp
    d198:	89 e5                	mov    %esp,%ebp
    d19a:	53                   	push   %ebx
    d19b:	83 ec 04             	sub    $0x4,%esp
    d19e:	8b 45 08             	mov    0x8(%ebp),%eax
    d1a1:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    d1a4:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    d1a8:	74 06                	je     d1b0 <getValueRequiredBits+0x19>
    d1aa:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    d1ae:	75 07                	jne    d1b7 <getValueRequiredBits+0x20>
    d1b0:	b8 01 00 00 00       	mov    $0x1,%eax
    d1b5:	eb 6b                	jmp    d222 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    d1b7:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    d1bb:	0f b6 d9             	movzbl %cl,%ebx
    d1be:	89 da                	mov    %ebx,%edx
    d1c0:	89 d0                	mov    %edx,%eax
    d1c2:	c1 e0 04             	shl    $0x4,%eax
    d1c5:	89 c2                	mov    %eax,%edx
    d1c7:	89 d0                	mov    %edx,%eax
    d1c9:	c1 e0 04             	shl    $0x4,%eax
    d1cc:	29 d0                	sub    %edx,%eax
    d1ce:	01 d8                	add    %ebx,%eax
    d1d0:	66 c1 e8 08          	shr    $0x8,%ax
    d1d4:	c0 e8 04             	shr    $0x4,%al
    d1d7:	89 c2                	mov    %eax,%edx
    d1d9:	c1 e2 04             	shl    $0x4,%edx
    d1dc:	01 c2                	add    %eax,%edx
    d1de:	89 c8                	mov    %ecx,%eax
    d1e0:	29 d0                	sub    %edx,%eax
    d1e2:	84 c0                	test   %al,%al
    d1e4:	75 37                	jne    d21d <getValueRequiredBits+0x86>
    d1e6:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    d1ea:	0f b6 d1             	movzbl %cl,%edx
    d1ed:	89 d0                	mov    %edx,%eax
    d1ef:	01 c0                	add    %eax,%eax
    d1f1:	01 d0                	add    %edx,%eax
    d1f3:	c1 e0 06             	shl    $0x6,%eax
    d1f6:	01 d0                	add    %edx,%eax
    d1f8:	66 c1 e8 08          	shr    $0x8,%ax
    d1fc:	c0 e8 06             	shr    $0x6,%al
    d1ff:	ba 55 00 00 00       	mov    $0x55,%edx
    d204:	0f af c2             	imul   %edx,%eax
    d207:	29 c1                	sub    %eax,%ecx
    d209:	89 c8                	mov    %ecx,%eax
    d20b:	84 c0                	test   %al,%al
    d20d:	75 07                	jne    d216 <getValueRequiredBits+0x7f>
    d20f:	b8 02 00 00 00       	mov    $0x2,%eax
    d214:	eb 0c                	jmp    d222 <getValueRequiredBits+0x8b>
    d216:	b8 04 00 00 00       	mov    $0x4,%eax
    d21b:	eb 05                	jmp    d222 <getValueRequiredBits+0x8b>
  return 8;
    d21d:	b8 08 00 00 00       	mov    $0x8,%eax
}
    d222:	83 c4 04             	add    $0x4,%esp
    d225:	5b                   	pop    %ebx
    d226:	5d                   	pop    %ebp
    d227:	c3                   	ret    

0000d228 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    d228:	55                   	push   %ebp
    d229:	89 e5                	mov    %esp,%ebp
    d22b:	56                   	push   %esi
    d22c:	53                   	push   %ebx
    d22d:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    d233:	8b 55 10             	mov    0x10(%ebp),%edx
    d236:	8b 45 14             	mov    0x14(%ebp),%eax
    d239:	0f af c2             	imul   %edx,%eax
    d23c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    d23f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    d246:	ff 75 18             	pushl  0x18(%ebp)
    d249:	e8 0b cd ff ff       	call   9f59 <lodepng_is_greyscale_type>
    d24e:	83 c4 04             	add    $0x4,%esp
    d251:	85 c0                	test   %eax,%eax
    d253:	0f 95 c0             	setne  %al
    d256:	0f b6 c0             	movzbl %al,%eax
    d259:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    d25c:	ff 75 18             	pushl  0x18(%ebp)
    d25f:	e8 85 cd ff ff       	call   9fe9 <lodepng_can_have_alpha>
    d264:	83 c4 04             	add    $0x4,%esp
    d267:	85 c0                	test   %eax,%eax
    d269:	0f 94 c0             	sete   %al
    d26c:	0f b6 c0             	movzbl %al,%eax
    d26f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    d272:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    d279:	ff 75 18             	pushl  0x18(%ebp)
    d27c:	e8 ab cc ff ff       	call   9f2c <lodepng_get_bpp>
    d281:	83 c4 04             	add    $0x4,%esp
    d284:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    d287:	8b 45 08             	mov    0x8(%ebp),%eax
    d28a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d290:	83 f8 01             	cmp    $0x1,%eax
    d293:	75 0d                	jne    d2a2 <lodepng_compute_color_stats+0x7a>
    d295:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    d299:	75 07                	jne    d2a2 <lodepng_compute_color_stats+0x7a>
    d29b:	b8 01 00 00 00       	mov    $0x1,%eax
    d2a0:	eb 05                	jmp    d2a7 <lodepng_compute_color_stats+0x7f>
    d2a2:	b8 00 00 00 00       	mov    $0x0,%eax
    d2a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    d2aa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    d2b1:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    d2b8:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    d2bc:	77 26                	ja     d2e4 <lodepng_compute_color_stats+0xbc>
    d2be:	8b 45 08             	mov    0x8(%ebp),%eax
    d2c1:	8b 50 14             	mov    0x14(%eax),%edx
    d2c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d2c7:	bb 01 00 00 00       	mov    $0x1,%ebx
    d2cc:	89 c1                	mov    %eax,%ecx
    d2ce:	d3 e3                	shl    %cl,%ebx
    d2d0:	89 d8                	mov    %ebx,%eax
    d2d2:	01 d0                	add    %edx,%eax
    d2d4:	ba 01 01 00 00       	mov    $0x101,%edx
    d2d9:	3d 01 01 00 00       	cmp    $0x101,%eax
    d2de:	0f 47 c2             	cmova  %edx,%eax
    d2e1:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    d2e4:	8b 45 08             	mov    0x8(%ebp),%eax
    d2e7:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    d2ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d2f0:	01 c2                	add    %eax,%edx
    d2f2:	8b 45 08             	mov    0x8(%ebp),%eax
    d2f5:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    d2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    d2fe:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d304:	85 c0                	test   %eax,%eax
    d306:	75 07                	jne    d30f <lodepng_compute_color_stats+0xe7>
    d308:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    d30f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d315:	50                   	push   %eax
    d316:	e8 81 da ff ff       	call   ad9c <color_tree_init>
    d31b:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    d31e:	8b 45 08             	mov    0x8(%ebp),%eax
    d321:	8b 40 10             	mov    0x10(%eax),%eax
    d324:	85 c0                	test   %eax,%eax
    d326:	74 07                	je     d32f <lodepng_compute_color_stats+0x107>
    d328:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    d32f:	8b 45 08             	mov    0x8(%ebp),%eax
    d332:	8b 00                	mov    (%eax),%eax
    d334:	85 c0                	test   %eax,%eax
    d336:	74 07                	je     d33f <lodepng_compute_color_stats+0x117>
    d338:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    d33f:	8b 45 08             	mov    0x8(%ebp),%eax
    d342:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d348:	83 f8 10             	cmp    $0x10,%eax
    d34b:	75 07                	jne    d354 <lodepng_compute_color_stats+0x12c>
    d34d:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    d354:	8b 45 08             	mov    0x8(%ebp),%eax
    d357:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d35d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d360:	72 07                	jb     d369 <lodepng_compute_color_stats+0x141>
    d362:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    d369:	8b 45 08             	mov    0x8(%ebp),%eax
    d36c:	8b 40 14             	mov    0x14(%eax),%eax
    d36f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d372:	72 07                	jb     d37b <lodepng_compute_color_stats+0x153>
    d374:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    d37b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d37f:	0f 85 82 00 00 00    	jne    d407 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    d385:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d38c:	eb 6c                	jmp    d3fa <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    d38e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d391:	c1 e0 02             	shl    $0x2,%eax
    d394:	8d 50 10             	lea    0x10(%eax),%edx
    d397:	8b 45 08             	mov    0x8(%ebp),%eax
    d39a:	01 d0                	add    %edx,%eax
    d39c:	83 c0 08             	add    $0x8,%eax
    d39f:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    d3a2:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d3a5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d3a8:	83 c0 03             	add    $0x3,%eax
    d3ab:	0f b6 00             	movzbl (%eax),%eax
    d3ae:	0f b6 d8             	movzbl %al,%ebx
    d3b1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d3b4:	83 c0 02             	add    $0x2,%eax
    d3b7:	0f b6 00             	movzbl (%eax),%eax
    d3ba:	0f b6 c8             	movzbl %al,%ecx
    d3bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d3c0:	83 c0 01             	add    $0x1,%eax
    d3c3:	0f b6 00             	movzbl (%eax),%eax
    d3c6:	0f b6 d0             	movzbl %al,%edx
    d3c9:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d3cc:	0f b6 00             	movzbl (%eax),%eax
    d3cf:	0f b6 c0             	movzbl %al,%eax
    d3d2:	83 ec 08             	sub    $0x8,%esp
    d3d5:	56                   	push   %esi
    d3d6:	53                   	push   %ebx
    d3d7:	51                   	push   %ecx
    d3d8:	52                   	push   %edx
    d3d9:	50                   	push   %eax
    d3da:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d3e0:	50                   	push   %eax
    d3e1:	e8 39 db ff ff       	call   af1f <color_tree_add>
    d3e6:	83 c4 20             	add    $0x20,%esp
    d3e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    d3ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d3f0:	0f 85 22 09 00 00    	jne    dd18 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    d3f6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d3fa:	8b 45 08             	mov    0x8(%ebp),%eax
    d3fd:	8b 50 14             	mov    0x14(%eax),%edx
    d400:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d403:	39 c2                	cmp    %eax,%edx
    d405:	77 87                	ja     d38e <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    d407:	8b 45 18             	mov    0x18(%ebp),%eax
    d40a:	8b 40 04             	mov    0x4(%eax),%eax
    d40d:	83 f8 10             	cmp    $0x10,%eax
    d410:	0f 85 1e 01 00 00    	jne    d534 <lodepng_compute_color_stats+0x30c>
    d416:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    d41a:	0f 85 14 01 00 00    	jne    d534 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    d420:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    d427:	00 00 
    d429:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    d430:	00 00 
    d432:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    d439:	00 00 
    d43b:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    d442:	00 00 
    for(i = 0; i != numpixels; ++i) {
    d444:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d44b:	e9 d8 00 00 00       	jmp    d528 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    d450:	83 ec 04             	sub    $0x4,%esp
    d453:	ff 75 18             	pushl  0x18(%ebp)
    d456:	ff 75 f4             	pushl  -0xc(%ebp)
    d459:	ff 75 0c             	pushl  0xc(%ebp)
    d45c:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    d462:	50                   	push   %eax
    d463:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    d469:	50                   	push   %eax
    d46a:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    d470:	50                   	push   %eax
    d471:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    d477:	50                   	push   %eax
    d478:	e8 a8 f2 ff ff       	call   c725 <getPixelColorRGBA16>
    d47d:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    d480:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    d487:	66 c1 e8 08          	shr    $0x8,%ax
    d48b:	89 c2                	mov    %eax,%edx
    d48d:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    d494:	31 d0                	xor    %edx,%eax
    d496:	0f b7 c0             	movzwl %ax,%eax
    d499:	0f b6 c0             	movzbl %al,%eax
    d49c:	85 c0                	test   %eax,%eax
    d49e:	75 60                	jne    d500 <lodepng_compute_color_stats+0x2d8>
    d4a0:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    d4a7:	66 c1 e8 08          	shr    $0x8,%ax
    d4ab:	89 c2                	mov    %eax,%edx
    d4ad:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    d4b4:	31 d0                	xor    %edx,%eax
    d4b6:	0f b7 c0             	movzwl %ax,%eax
    d4b9:	0f b6 c0             	movzbl %al,%eax
    d4bc:	85 c0                	test   %eax,%eax
    d4be:	75 40                	jne    d500 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    d4c0:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    d4c7:	66 c1 e8 08          	shr    $0x8,%ax
    d4cb:	89 c2                	mov    %eax,%edx
    d4cd:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    d4d4:	31 d0                	xor    %edx,%eax
    d4d6:	0f b7 c0             	movzwl %ax,%eax
    d4d9:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    d4dc:	85 c0                	test   %eax,%eax
    d4de:	75 20                	jne    d500 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    d4e0:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    d4e7:	66 c1 e8 08          	shr    $0x8,%ax
    d4eb:	89 c2                	mov    %eax,%edx
    d4ed:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    d4f4:	31 d0                	xor    %edx,%eax
    d4f6:	0f b7 c0             	movzwl %ax,%eax
    d4f9:	0f b6 c0             	movzbl %al,%eax
    d4fc:	85 c0                	test   %eax,%eax
    d4fe:	74 24                	je     d524 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    d500:	8b 45 08             	mov    0x8(%ebp),%eax
    d503:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    d50a:	00 00 00 
        sixteen = 1;
    d50d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    d514:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    d51b:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    d522:	eb 10                	jmp    d534 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    d524:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d528:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d52b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d52e:	0f 85 1c ff ff ff    	jne    d450 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    d534:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    d538:	0f 84 bd 02 00 00    	je     d7fb <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    d53e:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    d545:	00 00 
    d547:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    d54e:	00 00 
    d550:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    d557:	00 00 
    d559:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    d560:	00 00 

    for(i = 0; i != numpixels; ++i) {
    d562:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d569:	e9 b1 01 00 00       	jmp    d71f <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    d56e:	83 ec 04             	sub    $0x4,%esp
    d571:	ff 75 18             	pushl  0x18(%ebp)
    d574:	ff 75 f4             	pushl  -0xc(%ebp)
    d577:	ff 75 0c             	pushl  0xc(%ebp)
    d57a:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    d580:	50                   	push   %eax
    d581:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    d587:	50                   	push   %eax
    d588:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    d58e:	50                   	push   %eax
    d58f:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    d595:	50                   	push   %eax
    d596:	e8 8a f1 ff ff       	call   c725 <getPixelColorRGBA16>
    d59b:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    d59e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d5a2:	75 36                	jne    d5da <lodepng_compute_color_stats+0x3b2>
    d5a4:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    d5ab:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    d5b2:	66 39 c2             	cmp    %ax,%dx
    d5b5:	75 13                	jne    d5ca <lodepng_compute_color_stats+0x3a2>
    d5b7:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    d5be:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    d5c5:	66 39 c2             	cmp    %ax,%dx
    d5c8:	74 10                	je     d5da <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    d5ca:	8b 45 08             	mov    0x8(%ebp),%eax
    d5cd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    d5d3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    d5da:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d5de:	0f 85 1f 01 00 00    	jne    d703 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    d5e4:	8b 45 08             	mov    0x8(%ebp),%eax
    d5e7:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    d5eb:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    d5f2:	66 39 c2             	cmp    %ax,%dx
    d5f5:	75 2d                	jne    d624 <lodepng_compute_color_stats+0x3fc>
    d5f7:	8b 45 08             	mov    0x8(%ebp),%eax
    d5fa:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d5fe:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    d605:	66 39 c2             	cmp    %ax,%dx
    d608:	75 1a                	jne    d624 <lodepng_compute_color_stats+0x3fc>
    d60a:	8b 45 08             	mov    0x8(%ebp),%eax
    d60d:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d611:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    d618:	66 39 c2             	cmp    %ax,%dx
    d61b:	75 07                	jne    d624 <lodepng_compute_color_stats+0x3fc>
    d61d:	b8 01 00 00 00       	mov    $0x1,%eax
    d622:	eb 05                	jmp    d629 <lodepng_compute_color_stats+0x401>
    d624:	b8 00 00 00 00       	mov    $0x0,%eax
    d629:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    d62c:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d633:	66 83 f8 ff          	cmp    $0xffff,%ax
    d637:	74 3c                	je     d675 <lodepng_compute_color_stats+0x44d>
    d639:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d640:	66 85 c0             	test   %ax,%ax
    d643:	75 10                	jne    d655 <lodepng_compute_color_stats+0x42d>
    d645:	8b 45 08             	mov    0x8(%ebp),%eax
    d648:	8b 40 04             	mov    0x4(%eax),%eax
    d64b:	85 c0                	test   %eax,%eax
    d64d:	74 26                	je     d675 <lodepng_compute_color_stats+0x44d>
    d64f:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    d653:	75 20                	jne    d675 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    d655:	8b 45 08             	mov    0x8(%ebp),%eax
    d658:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d65f:	8b 45 08             	mov    0x8(%ebp),%eax
    d662:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d669:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    d670:	e9 8e 00 00 00       	jmp    d703 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    d675:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d67c:	66 85 c0             	test   %ax,%ax
    d67f:	75 4a                	jne    d6cb <lodepng_compute_color_stats+0x4a3>
    d681:	8b 45 08             	mov    0x8(%ebp),%eax
    d684:	8b 40 10             	mov    0x10(%eax),%eax
    d687:	85 c0                	test   %eax,%eax
    d689:	75 40                	jne    d6cb <lodepng_compute_color_stats+0x4a3>
    d68b:	8b 45 08             	mov    0x8(%ebp),%eax
    d68e:	8b 40 04             	mov    0x4(%eax),%eax
    d691:	85 c0                	test   %eax,%eax
    d693:	75 36                	jne    d6cb <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    d695:	8b 45 08             	mov    0x8(%ebp),%eax
    d698:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    d69f:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    d6a6:	8b 45 08             	mov    0x8(%ebp),%eax
    d6a9:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    d6ad:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    d6b4:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b7:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    d6bb:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    d6c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d6c5:	66 89 50 0c          	mov    %dx,0xc(%eax)
    d6c9:	eb 38                	jmp    d703 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    d6cb:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d6d2:	66 83 f8 ff          	cmp    $0xffff,%ax
    d6d6:	75 2b                	jne    d703 <lodepng_compute_color_stats+0x4db>
    d6d8:	8b 45 08             	mov    0x8(%ebp),%eax
    d6db:	8b 40 04             	mov    0x4(%eax),%eax
    d6de:	85 c0                	test   %eax,%eax
    d6e0:	74 21                	je     d703 <lodepng_compute_color_stats+0x4db>
    d6e2:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    d6e6:	74 1b                	je     d703 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d6e8:	8b 45 08             	mov    0x8(%ebp),%eax
    d6eb:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d6f2:	8b 45 08             	mov    0x8(%ebp),%eax
    d6f5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d6fc:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d703:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d707:	74 12                	je     d71b <lodepng_compute_color_stats+0x4f3>
    d709:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d70d:	74 0c                	je     d71b <lodepng_compute_color_stats+0x4f3>
    d70f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d713:	74 06                	je     d71b <lodepng_compute_color_stats+0x4f3>
    d715:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d719:	75 12                	jne    d72d <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    d71b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d71f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d722:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d725:	0f 85 43 fe ff ff    	jne    d56e <lodepng_compute_color_stats+0x346>
    d72b:	eb 01                	jmp    d72e <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d72d:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    d72e:	8b 45 08             	mov    0x8(%ebp),%eax
    d731:	8b 40 04             	mov    0x4(%eax),%eax
    d734:	85 c0                	test   %eax,%eax
    d736:	0f 84 e0 05 00 00    	je     dd1c <lodepng_compute_color_stats+0xaf4>
    d73c:	8b 45 08             	mov    0x8(%ebp),%eax
    d73f:	8b 40 10             	mov    0x10(%eax),%eax
    d742:	85 c0                	test   %eax,%eax
    d744:	0f 85 d2 05 00 00    	jne    dd1c <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    d74a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d751:	e9 94 00 00 00       	jmp    d7ea <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    d756:	83 ec 04             	sub    $0x4,%esp
    d759:	ff 75 18             	pushl  0x18(%ebp)
    d75c:	ff 75 f4             	pushl  -0xc(%ebp)
    d75f:	ff 75 0c             	pushl  0xc(%ebp)
    d762:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    d768:	50                   	push   %eax
    d769:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    d76f:	50                   	push   %eax
    d770:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    d776:	50                   	push   %eax
    d777:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    d77d:	50                   	push   %eax
    d77e:	e8 a2 ef ff ff       	call   c725 <getPixelColorRGBA16>
    d783:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    d786:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d78d:	66 85 c0             	test   %ax,%ax
    d790:	74 54                	je     d7e6 <lodepng_compute_color_stats+0x5be>
    d792:	8b 45 08             	mov    0x8(%ebp),%eax
    d795:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    d799:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    d7a0:	66 39 c2             	cmp    %ax,%dx
    d7a3:	75 41                	jne    d7e6 <lodepng_compute_color_stats+0x5be>
    d7a5:	8b 45 08             	mov    0x8(%ebp),%eax
    d7a8:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d7ac:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    d7b3:	66 39 c2             	cmp    %ax,%dx
    d7b6:	75 2e                	jne    d7e6 <lodepng_compute_color_stats+0x5be>
    d7b8:	8b 45 08             	mov    0x8(%ebp),%eax
    d7bb:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d7bf:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    d7c6:	66 39 c2             	cmp    %ax,%dx
    d7c9:	75 1b                	jne    d7e6 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d7cb:	8b 45 08             	mov    0x8(%ebp),%eax
    d7ce:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d7d5:	8b 45 08             	mov    0x8(%ebp),%eax
    d7d8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d7df:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    d7e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7ed:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d7f0:	0f 85 60 ff ff ff    	jne    d756 <lodepng_compute_color_stats+0x52e>
    d7f6:	e9 21 05 00 00       	jmp    dd1c <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    d7fb:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    d802:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    d809:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    d810:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    d817:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d81e:	e9 ab 03 00 00       	jmp    dbce <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    d823:	83 ec 04             	sub    $0x4,%esp
    d826:	ff 75 18             	pushl  0x18(%ebp)
    d829:	ff 75 f4             	pushl  -0xc(%ebp)
    d82c:	ff 75 0c             	pushl  0xc(%ebp)
    d82f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    d835:	50                   	push   %eax
    d836:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    d83c:	50                   	push   %eax
    d83d:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    d843:	50                   	push   %eax
    d844:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    d84a:	50                   	push   %eax
    d84b:	e8 1e de ff ff       	call   b66e <getPixelColorRGBA8>
    d850:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    d853:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d857:	75 41                	jne    d89a <lodepng_compute_color_stats+0x672>
    d859:	8b 45 08             	mov    0x8(%ebp),%eax
    d85c:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d862:	83 f8 07             	cmp    $0x7,%eax
    d865:	77 33                	ja     d89a <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    d867:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d86e:	0f b6 c0             	movzbl %al,%eax
    d871:	83 ec 0c             	sub    $0xc,%esp
    d874:	50                   	push   %eax
    d875:	e8 1d f9 ff ff       	call   d197 <getValueRequiredBits>
    d87a:	83 c4 10             	add    $0x10,%esp
    d87d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    d880:	8b 45 08             	mov    0x8(%ebp),%eax
    d883:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d889:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    d88c:	73 0c                	jae    d89a <lodepng_compute_color_stats+0x672>
    d88e:	8b 45 08             	mov    0x8(%ebp),%eax
    d891:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    d894:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    d89a:	8b 45 08             	mov    0x8(%ebp),%eax
    d89d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d8a3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d8a6:	0f 93 c0             	setae  %al
    d8a9:	0f b6 c0             	movzbl %al,%eax
    d8ac:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    d8af:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d8b3:	75 4f                	jne    d904 <lodepng_compute_color_stats+0x6dc>
    d8b5:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    d8bc:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d8c3:	38 c2                	cmp    %al,%dl
    d8c5:	75 12                	jne    d8d9 <lodepng_compute_color_stats+0x6b1>
    d8c7:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    d8ce:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d8d5:	38 c2                	cmp    %al,%dl
    d8d7:	74 2b                	je     d904 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    d8d9:	8b 45 08             	mov    0x8(%ebp),%eax
    d8dc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    d8e2:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    d8e9:	8b 45 08             	mov    0x8(%ebp),%eax
    d8ec:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d8f2:	83 f8 07             	cmp    $0x7,%eax
    d8f5:	77 0d                	ja     d904 <lodepng_compute_color_stats+0x6dc>
    d8f7:	8b 45 08             	mov    0x8(%ebp),%eax
    d8fa:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d901:	00 00 00 
      }

      if(!alpha_done) {
    d904:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d908:	0f 85 65 01 00 00    	jne    da73 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    d90e:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d915:	0f b6 d0             	movzbl %al,%edx
    d918:	8b 45 08             	mov    0x8(%ebp),%eax
    d91b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d91f:	66 39 c2             	cmp    %ax,%dx
    d922:	75 33                	jne    d957 <lodepng_compute_color_stats+0x72f>
    d924:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d92b:	0f b6 d0             	movzbl %al,%edx
    d92e:	8b 45 08             	mov    0x8(%ebp),%eax
    d931:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d935:	66 39 c2             	cmp    %ax,%dx
    d938:	75 1d                	jne    d957 <lodepng_compute_color_stats+0x72f>
    d93a:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d941:	0f b6 d0             	movzbl %al,%edx
    d944:	8b 45 08             	mov    0x8(%ebp),%eax
    d947:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d94b:	66 39 c2             	cmp    %ax,%dx
    d94e:	75 07                	jne    d957 <lodepng_compute_color_stats+0x72f>
    d950:	b8 01 00 00 00       	mov    $0x1,%eax
    d955:	eb 05                	jmp    d95c <lodepng_compute_color_stats+0x734>
    d957:	b8 00 00 00 00       	mov    $0x0,%eax
    d95c:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    d95f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d966:	3c ff                	cmp    $0xff,%al
    d968:	74 5a                	je     d9c4 <lodepng_compute_color_stats+0x79c>
    d96a:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d971:	84 c0                	test   %al,%al
    d973:	75 10                	jne    d985 <lodepng_compute_color_stats+0x75d>
    d975:	8b 45 08             	mov    0x8(%ebp),%eax
    d978:	8b 40 04             	mov    0x4(%eax),%eax
    d97b:	85 c0                	test   %eax,%eax
    d97d:	74 45                	je     d9c4 <lodepng_compute_color_stats+0x79c>
    d97f:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    d983:	75 3f                	jne    d9c4 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    d985:	8b 45 08             	mov    0x8(%ebp),%eax
    d988:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d98f:	8b 45 08             	mov    0x8(%ebp),%eax
    d992:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d999:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d9a0:	8b 45 08             	mov    0x8(%ebp),%eax
    d9a3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d9a9:	83 f8 07             	cmp    $0x7,%eax
    d9ac:	0f 87 c1 00 00 00    	ja     da73 <lodepng_compute_color_stats+0x84b>
    d9b2:	8b 45 08             	mov    0x8(%ebp),%eax
    d9b5:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d9bc:	00 00 00 
    d9bf:	e9 af 00 00 00       	jmp    da73 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    d9c4:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d9cb:	84 c0                	test   %al,%al
    d9cd:	75 53                	jne    da22 <lodepng_compute_color_stats+0x7fa>
    d9cf:	8b 45 08             	mov    0x8(%ebp),%eax
    d9d2:	8b 40 10             	mov    0x10(%eax),%eax
    d9d5:	85 c0                	test   %eax,%eax
    d9d7:	75 49                	jne    da22 <lodepng_compute_color_stats+0x7fa>
    d9d9:	8b 45 08             	mov    0x8(%ebp),%eax
    d9dc:	8b 40 04             	mov    0x4(%eax),%eax
    d9df:	85 c0                	test   %eax,%eax
    d9e1:	75 3f                	jne    da22 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    d9e3:	8b 45 08             	mov    0x8(%ebp),%eax
    d9e6:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    d9ed:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d9f4:	0f b6 d0             	movzbl %al,%edx
    d9f7:	8b 45 08             	mov    0x8(%ebp),%eax
    d9fa:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    d9fe:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    da05:	0f b6 d0             	movzbl %al,%edx
    da08:	8b 45 08             	mov    0x8(%ebp),%eax
    da0b:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    da0f:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    da16:	0f b6 d0             	movzbl %al,%edx
    da19:	8b 45 08             	mov    0x8(%ebp),%eax
    da1c:	66 89 50 0c          	mov    %dx,0xc(%eax)
    da20:	eb 51                	jmp    da73 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    da22:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    da29:	3c ff                	cmp    $0xff,%al
    da2b:	75 46                	jne    da73 <lodepng_compute_color_stats+0x84b>
    da2d:	8b 45 08             	mov    0x8(%ebp),%eax
    da30:	8b 40 04             	mov    0x4(%eax),%eax
    da33:	85 c0                	test   %eax,%eax
    da35:	74 3c                	je     da73 <lodepng_compute_color_stats+0x84b>
    da37:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    da3b:	74 36                	je     da73 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    da3d:	8b 45 08             	mov    0x8(%ebp),%eax
    da40:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    da47:	8b 45 08             	mov    0x8(%ebp),%eax
    da4a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    da51:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    da58:	8b 45 08             	mov    0x8(%ebp),%eax
    da5b:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    da61:	83 f8 07             	cmp    $0x7,%eax
    da64:	77 0d                	ja     da73 <lodepng_compute_color_stats+0x84b>
    da66:	8b 45 08             	mov    0x8(%ebp),%eax
    da69:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    da70:	00 00 00 
        }
      }

      if(!numcolors_done) {
    da73:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    da77:	0f 85 35 01 00 00    	jne    dbb2 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    da7d:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    da84:	0f b6 d8             	movzbl %al,%ebx
    da87:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    da8e:	0f b6 c8             	movzbl %al,%ecx
    da91:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    da98:	0f b6 d0             	movzbl %al,%edx
    da9b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    daa2:	0f b6 c0             	movzbl %al,%eax
    daa5:	83 ec 0c             	sub    $0xc,%esp
    daa8:	53                   	push   %ebx
    daa9:	51                   	push   %ecx
    daaa:	52                   	push   %edx
    daab:	50                   	push   %eax
    daac:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    dab2:	50                   	push   %eax
    dab3:	e8 1c d4 ff ff       	call   aed4 <color_tree_has>
    dab8:	83 c4 20             	add    $0x20,%esp
    dabb:	85 c0                	test   %eax,%eax
    dabd:	0f 85 ef 00 00 00    	jne    dbb2 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    dac3:	8b 45 08             	mov    0x8(%ebp),%eax
    dac6:	8b 70 14             	mov    0x14(%eax),%esi
    dac9:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    dad0:	0f b6 d8             	movzbl %al,%ebx
    dad3:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    dada:	0f b6 c8             	movzbl %al,%ecx
    dadd:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    dae4:	0f b6 d0             	movzbl %al,%edx
    dae7:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    daee:	0f b6 c0             	movzbl %al,%eax
    daf1:	83 ec 08             	sub    $0x8,%esp
    daf4:	56                   	push   %esi
    daf5:	53                   	push   %ebx
    daf6:	51                   	push   %ecx
    daf7:	52                   	push   %edx
    daf8:	50                   	push   %eax
    daf9:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    daff:	50                   	push   %eax
    db00:	e8 1a d4 ff ff       	call   af1f <color_tree_add>
    db05:	83 c4 20             	add    $0x20,%esp
    db08:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    db0b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    db0f:	0f 85 06 02 00 00    	jne    dd1b <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    db15:	8b 45 08             	mov    0x8(%ebp),%eax
    db18:	8b 40 14             	mov    0x14(%eax),%eax
    db1b:	3d ff 00 00 00       	cmp    $0xff,%eax
    db20:	77 6f                	ja     db91 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    db22:	8b 45 08             	mov    0x8(%ebp),%eax
    db25:	83 c0 18             	add    $0x18,%eax
    db28:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    db2b:	8b 45 08             	mov    0x8(%ebp),%eax
    db2e:	8b 40 14             	mov    0x14(%eax),%eax
    db31:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    db34:	8b 45 b8             	mov    -0x48(%ebp),%eax
    db37:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    db3e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    db41:	01 c2                	add    %eax,%edx
    db43:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    db4a:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    db4c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    db4f:	c1 e0 02             	shl    $0x2,%eax
    db52:	8d 50 01             	lea    0x1(%eax),%edx
    db55:	8b 45 bc             	mov    -0x44(%ebp),%eax
    db58:	01 c2                	add    %eax,%edx
    db5a:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    db61:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    db63:	8b 45 b8             	mov    -0x48(%ebp),%eax
    db66:	c1 e0 02             	shl    $0x2,%eax
    db69:	8d 50 02             	lea    0x2(%eax),%edx
    db6c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    db6f:	01 c2                	add    %eax,%edx
    db71:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    db78:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    db7a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    db7d:	c1 e0 02             	shl    $0x2,%eax
    db80:	8d 50 03             	lea    0x3(%eax),%edx
    db83:	8b 45 bc             	mov    -0x44(%ebp),%eax
    db86:	01 c2                	add    %eax,%edx
    db88:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    db8f:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    db91:	8b 45 08             	mov    0x8(%ebp),%eax
    db94:	8b 40 14             	mov    0x14(%eax),%eax
    db97:	8d 50 01             	lea    0x1(%eax),%edx
    db9a:	8b 45 08             	mov    0x8(%ebp),%eax
    db9d:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    dba0:	8b 45 08             	mov    0x8(%ebp),%eax
    dba3:	8b 40 14             	mov    0x14(%eax),%eax
    dba6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    dba9:	0f 93 c0             	setae  %al
    dbac:	0f b6 c0             	movzbl %al,%eax
    dbaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    dbb2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    dbb6:	74 12                	je     dbca <lodepng_compute_color_stats+0x9a2>
    dbb8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    dbbc:	74 0c                	je     dbca <lodepng_compute_color_stats+0x9a2>
    dbbe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    dbc2:	74 06                	je     dbca <lodepng_compute_color_stats+0x9a2>
    dbc4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    dbc8:	75 12                	jne    dbdc <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    dbca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dbce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbd1:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    dbd4:	0f 85 49 fc ff ff    	jne    d823 <lodepng_compute_color_stats+0x5fb>
    dbda:	eb 01                	jmp    dbdd <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    dbdc:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    dbdd:	8b 45 08             	mov    0x8(%ebp),%eax
    dbe0:	8b 40 04             	mov    0x4(%eax),%eax
    dbe3:	85 c0                	test   %eax,%eax
    dbe5:	0f 84 dd 00 00 00    	je     dcc8 <lodepng_compute_color_stats+0xaa0>
    dbeb:	8b 45 08             	mov    0x8(%ebp),%eax
    dbee:	8b 40 10             	mov    0x10(%eax),%eax
    dbf1:	85 c0                	test   %eax,%eax
    dbf3:	0f 85 cf 00 00 00    	jne    dcc8 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    dbf9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dc00:	e9 b7 00 00 00       	jmp    dcbc <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    dc05:	83 ec 04             	sub    $0x4,%esp
    dc08:	ff 75 18             	pushl  0x18(%ebp)
    dc0b:	ff 75 f4             	pushl  -0xc(%ebp)
    dc0e:	ff 75 0c             	pushl  0xc(%ebp)
    dc11:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    dc17:	50                   	push   %eax
    dc18:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    dc1e:	50                   	push   %eax
    dc1f:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    dc25:	50                   	push   %eax
    dc26:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    dc2c:	50                   	push   %eax
    dc2d:	e8 3c da ff ff       	call   b66e <getPixelColorRGBA8>
    dc32:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    dc35:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    dc3c:	84 c0                	test   %al,%al
    dc3e:	74 78                	je     dcb8 <lodepng_compute_color_stats+0xa90>
    dc40:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    dc47:	0f b6 d0             	movzbl %al,%edx
    dc4a:	8b 45 08             	mov    0x8(%ebp),%eax
    dc4d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    dc51:	66 39 c2             	cmp    %ax,%dx
    dc54:	75 62                	jne    dcb8 <lodepng_compute_color_stats+0xa90>
    dc56:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    dc5d:	0f b6 d0             	movzbl %al,%edx
    dc60:	8b 45 08             	mov    0x8(%ebp),%eax
    dc63:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    dc67:	66 39 c2             	cmp    %ax,%dx
    dc6a:	75 4c                	jne    dcb8 <lodepng_compute_color_stats+0xa90>
    dc6c:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    dc73:	0f b6 d0             	movzbl %al,%edx
    dc76:	8b 45 08             	mov    0x8(%ebp),%eax
    dc79:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    dc7d:	66 39 c2             	cmp    %ax,%dx
    dc80:	75 36                	jne    dcb8 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    dc82:	8b 45 08             	mov    0x8(%ebp),%eax
    dc85:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    dc8c:	8b 45 08             	mov    0x8(%ebp),%eax
    dc8f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    dc96:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    dc9d:	8b 45 08             	mov    0x8(%ebp),%eax
    dca0:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    dca6:	83 f8 07             	cmp    $0x7,%eax
    dca9:	77 0d                	ja     dcb8 <lodepng_compute_color_stats+0xa90>
    dcab:	8b 45 08             	mov    0x8(%ebp),%eax
    dcae:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    dcb5:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    dcb8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dcbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcbf:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    dcc2:	0f 85 3d ff ff ff    	jne    dc05 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    dcc8:	8b 45 08             	mov    0x8(%ebp),%eax
    dccb:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    dccf:	8b 45 08             	mov    0x8(%ebp),%eax
    dcd2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    dcd6:	c1 e0 08             	shl    $0x8,%eax
    dcd9:	01 c2                	add    %eax,%edx
    dcdb:	8b 45 08             	mov    0x8(%ebp),%eax
    dcde:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    dce2:	8b 45 08             	mov    0x8(%ebp),%eax
    dce5:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    dce9:	8b 45 08             	mov    0x8(%ebp),%eax
    dcec:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    dcf0:	c1 e0 08             	shl    $0x8,%eax
    dcf3:	01 c2                	add    %eax,%edx
    dcf5:	8b 45 08             	mov    0x8(%ebp),%eax
    dcf8:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    dcfc:	8b 45 08             	mov    0x8(%ebp),%eax
    dcff:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    dd03:	8b 45 08             	mov    0x8(%ebp),%eax
    dd06:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    dd0a:	c1 e0 08             	shl    $0x8,%eax
    dd0d:	01 c2                	add    %eax,%edx
    dd0f:	8b 45 08             	mov    0x8(%ebp),%eax
    dd12:	66 89 50 0c          	mov    %dx,0xc(%eax)
    dd16:	eb 04                	jmp    dd1c <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    dd18:	90                   	nop
    dd19:	eb 01                	jmp    dd1c <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    dd1b:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    dd1c:	83 ec 0c             	sub    $0xc,%esp
    dd1f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    dd25:	50                   	push   %eax
    dd26:	e8 91 d0 ff ff       	call   adbc <color_tree_cleanup>
    dd2b:	83 c4 10             	add    $0x10,%esp
  return error;
    dd2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    dd31:	8d 65 f8             	lea    -0x8(%ebp),%esp
    dd34:	5b                   	pop    %ebx
    dd35:	5e                   	pop    %esi
    dd36:	5d                   	pop    %ebp
    dd37:	c3                   	ret    

0000dd38 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    dd38:	55                   	push   %ebp
    dd39:	89 e5                	mov    %esp,%ebp
    dd3b:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    dd3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    dd45:	8d 45 cc             	lea    -0x34(%ebp),%eax
    dd48:	50                   	push   %eax
    dd49:	e8 d1 bd ff ff       	call   9b1f <lodepng_color_mode_init>
    dd4e:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    dd51:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd54:	c1 e8 08             	shr    $0x8,%eax
    dd57:	88 45 ec             	mov    %al,-0x14(%ebp)
    dd5a:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd5d:	88 45 ed             	mov    %al,-0x13(%ebp)
    dd60:	8b 45 10             	mov    0x10(%ebp),%eax
    dd63:	c1 e8 08             	shr    $0x8,%eax
    dd66:	88 45 ee             	mov    %al,-0x12(%ebp)
    dd69:	8b 45 10             	mov    0x10(%ebp),%eax
    dd6c:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    dd6f:	8b 45 14             	mov    0x14(%ebp),%eax
    dd72:	c1 e8 08             	shr    $0x8,%eax
    dd75:	88 45 f0             	mov    %al,-0x10(%ebp)
    dd78:	8b 45 14             	mov    0x14(%ebp),%eax
    dd7b:	88 45 f1             	mov    %al,-0xf(%ebp)
    dd7e:	8b 45 18             	mov    0x18(%ebp),%eax
    dd81:	c1 e8 08             	shr    $0x8,%eax
    dd84:	88 45 f2             	mov    %al,-0xe(%ebp)
    dd87:	8b 45 18             	mov    0x18(%ebp),%eax
    dd8a:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    dd8d:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    dd94:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    dd9b:	83 ec 0c             	sub    $0xc,%esp
    dd9e:	8d 45 cc             	lea    -0x34(%ebp),%eax
    dda1:	50                   	push   %eax
    dda2:	6a 01                	push   $0x1
    dda4:	6a 01                	push   $0x1
    dda6:	8d 45 ec             	lea    -0x14(%ebp),%eax
    dda9:	50                   	push   %eax
    ddaa:	ff 75 08             	pushl  0x8(%ebp)
    ddad:	e8 76 f4 ff ff       	call   d228 <lodepng_compute_color_stats>
    ddb2:	83 c4 20             	add    $0x20,%esp
    ddb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    ddb8:	83 ec 0c             	sub    $0xc,%esp
    ddbb:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ddbe:	50                   	push   %eax
    ddbf:	e8 4e be ff ff       	call   9c12 <lodepng_color_mode_cleanup>
    ddc4:	83 c4 10             	add    $0x10,%esp
  return error;
    ddc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ddca:	c9                   	leave  
    ddcb:	c3                   	ret    

0000ddcc <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    ddcc:	55                   	push   %ebp
    ddcd:	89 e5                	mov    %esp,%ebp
    ddcf:	56                   	push   %esi
    ddd0:	53                   	push   %ebx
    ddd1:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    ddd4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    dddb:	8b 45 10             	mov    0x10(%ebp),%eax
    ddde:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    dde4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    dde7:	8b 45 10             	mov    0x10(%ebp),%eax
    ddea:	8b 40 10             	mov    0x10(%eax),%eax
    dded:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    ddf0:	8b 45 10             	mov    0x10(%ebp),%eax
    ddf3:	8b 40 04             	mov    0x4(%eax),%eax
    ddf6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    ddf9:	8b 45 10             	mov    0x10(%ebp),%eax
    ddfc:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    de02:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    de05:	8b 45 08             	mov    0x8(%ebp),%eax
    de08:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    de0f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    de13:	74 21                	je     de36 <auto_choose_color+0x6a>
    de15:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    de19:	7f 1b                	jg     de36 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    de1b:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    de22:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    de29:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    de2d:	77 07                	ja     de36 <auto_choose_color+0x6a>
    de2f:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    de36:	8b 45 10             	mov    0x10(%ebp),%eax
    de39:	8b 00                	mov    (%eax),%eax
    de3b:	85 c0                	test   %eax,%eax
    de3d:	0f 94 c0             	sete   %al
    de40:	0f b6 c0             	movzbl %al,%eax
    de43:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    de46:	8b 45 10             	mov    0x10(%ebp),%eax
    de49:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    de4f:	85 c0                	test   %eax,%eax
    de51:	75 07                	jne    de5a <auto_choose_color+0x8e>
    de53:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    de5a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    de5e:	75 0d                	jne    de6d <auto_choose_color+0xa1>
    de60:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    de64:	77 07                	ja     de6d <auto_choose_color+0xa1>
    de66:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    de6d:	8b 45 10             	mov    0x10(%ebp),%eax
    de70:	8b 40 14             	mov    0x14(%eax),%eax
    de73:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    de76:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    de7a:	7e 21                	jle    de9d <auto_choose_color+0xd1>
    de7c:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    de80:	7e 14                	jle    de96 <auto_choose_color+0xca>
    de82:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    de86:	7f 07                	jg     de8f <auto_choose_color+0xc3>
    de88:	b8 04 00 00 00       	mov    $0x4,%eax
    de8d:	eb 13                	jmp    dea2 <auto_choose_color+0xd6>
    de8f:	b8 08 00 00 00       	mov    $0x8,%eax
    de94:	eb 0c                	jmp    dea2 <auto_choose_color+0xd6>
    de96:	b8 02 00 00 00       	mov    $0x2,%eax
    de9b:	eb 05                	jmp    dea2 <auto_choose_color+0xd6>
    de9d:	b8 01 00 00 00       	mov    $0x1,%eax
    dea2:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    dea5:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    deac:	7f 13                	jg     dec1 <auto_choose_color+0xf5>
    deae:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    deb2:	77 0d                	ja     dec1 <auto_choose_color+0xf5>
    deb4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    deb8:	74 07                	je     dec1 <auto_choose_color+0xf5>
    deba:	b8 01 00 00 00       	mov    $0x1,%eax
    debf:	eb 05                	jmp    dec6 <auto_choose_color+0xfa>
    dec1:	b8 00 00 00 00       	mov    $0x0,%eax
    dec6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    dec9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    decc:	01 c0                	add    %eax,%eax
    dece:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ded1:	7e 07                	jle    deda <auto_choose_color+0x10e>
    ded3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    deda:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    dede:	74 15                	je     def5 <auto_choose_color+0x129>
    dee0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    dee4:	75 0f                	jne    def5 <auto_choose_color+0x129>
    dee6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dee9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    deec:	77 07                	ja     def5 <auto_choose_color+0x129>
    deee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    def5:	8b 45 10             	mov    0x10(%ebp),%eax
    def8:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    defe:	85 c0                	test   %eax,%eax
    df00:	75 07                	jne    df09 <auto_choose_color+0x13d>
    df02:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    df09:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    df0d:	0f 84 0a 01 00 00    	je     e01d <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    df13:	8b 45 10             	mov    0x10(%ebp),%eax
    df16:	83 c0 18             	add    $0x18,%eax
    df19:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    df1c:	83 ec 0c             	sub    $0xc,%esp
    df1f:	ff 75 08             	pushl  0x8(%ebp)
    df22:	e8 ef be ff ff       	call   9e16 <lodepng_palette_clear>
    df27:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    df2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    df31:	eb 6e                	jmp    dfa1 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    df33:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df36:	c1 e0 02             	shl    $0x2,%eax
    df39:	8d 50 03             	lea    0x3(%eax),%edx
    df3c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    df3f:	01 d0                	add    %edx,%eax
    df41:	0f b6 00             	movzbl (%eax),%eax
    df44:	0f b6 d8             	movzbl %al,%ebx
    df47:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df4a:	c1 e0 02             	shl    $0x2,%eax
    df4d:	8d 50 02             	lea    0x2(%eax),%edx
    df50:	8b 45 cc             	mov    -0x34(%ebp),%eax
    df53:	01 d0                	add    %edx,%eax
    df55:	0f b6 00             	movzbl (%eax),%eax
    df58:	0f b6 c8             	movzbl %al,%ecx
    df5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df5e:	c1 e0 02             	shl    $0x2,%eax
    df61:	8d 50 01             	lea    0x1(%eax),%edx
    df64:	8b 45 cc             	mov    -0x34(%ebp),%eax
    df67:	01 d0                	add    %edx,%eax
    df69:	0f b6 00             	movzbl (%eax),%eax
    df6c:	0f b6 d0             	movzbl %al,%edx
    df6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df72:	c1 e0 02             	shl    $0x2,%eax
    df75:	89 c6                	mov    %eax,%esi
    df77:	8b 45 cc             	mov    -0x34(%ebp),%eax
    df7a:	01 f0                	add    %esi,%eax
    df7c:	0f b6 00             	movzbl (%eax),%eax
    df7f:	0f b6 c0             	movzbl %al,%eax
    df82:	83 ec 0c             	sub    $0xc,%esp
    df85:	53                   	push   %ebx
    df86:	51                   	push   %ecx
    df87:	52                   	push   %edx
    df88:	50                   	push   %eax
    df89:	ff 75 08             	pushl  0x8(%ebp)
    df8c:	e8 be be ff ff       	call   9e4f <lodepng_palette_add>
    df91:	83 c4 20             	add    $0x20,%esp
    df94:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    df97:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    df9b:	75 13                	jne    dfb0 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    df9d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    dfa1:	8b 45 10             	mov    0x10(%ebp),%eax
    dfa4:	8b 50 14             	mov    0x14(%eax),%edx
    dfa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dfaa:	39 c2                	cmp    %eax,%edx
    dfac:	75 85                	jne    df33 <auto_choose_color+0x167>
    dfae:	eb 01                	jmp    dfb1 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    dfb0:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    dfb1:	8b 45 08             	mov    0x8(%ebp),%eax
    dfb4:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    dfba:	8b 45 08             	mov    0x8(%ebp),%eax
    dfbd:	8b 55 d0             	mov    -0x30(%ebp),%edx
    dfc0:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    dfc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfc6:	8b 00                	mov    (%eax),%eax
    dfc8:	83 f8 03             	cmp    $0x3,%eax
    dfcb:	0f 85 ec 00 00 00    	jne    e0bd <auto_choose_color+0x2f1>
    dfd1:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfd4:	8b 50 0c             	mov    0xc(%eax),%edx
    dfd7:	8b 45 08             	mov    0x8(%ebp),%eax
    dfda:	8b 40 0c             	mov    0xc(%eax),%eax
    dfdd:	39 c2                	cmp    %eax,%edx
    dfdf:	0f 8c d8 00 00 00    	jl     e0bd <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    dfe5:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfe8:	8b 50 04             	mov    0x4(%eax),%edx
    dfeb:	8b 45 08             	mov    0x8(%ebp),%eax
    dfee:	8b 40 04             	mov    0x4(%eax),%eax
    dff1:	39 c2                	cmp    %eax,%edx
    dff3:	0f 85 c4 00 00 00    	jne    e0bd <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    dff9:	83 ec 0c             	sub    $0xc,%esp
    dffc:	ff 75 08             	pushl  0x8(%ebp)
    dfff:	e8 0e bc ff ff       	call   9c12 <lodepng_color_mode_cleanup>
    e004:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    e007:	83 ec 08             	sub    $0x8,%esp
    e00a:	ff 75 0c             	pushl  0xc(%ebp)
    e00d:	ff 75 08             	pushl  0x8(%ebp)
    e010:	e8 14 bc ff ff       	call   9c29 <lodepng_color_mode_copy>
    e015:	83 c4 10             	add    $0x10,%esp
    e018:	e9 a0 00 00 00       	jmp    e0bd <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    e01d:	8b 45 08             	mov    0x8(%ebp),%eax
    e020:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e023:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    e026:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e02a:	74 14                	je     e040 <auto_choose_color+0x274>
    e02c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e030:	74 07                	je     e039 <auto_choose_color+0x26d>
    e032:	b8 04 00 00 00       	mov    $0x4,%eax
    e037:	eb 19                	jmp    e052 <auto_choose_color+0x286>
    e039:	b8 06 00 00 00       	mov    $0x6,%eax
    e03e:	eb 12                	jmp    e052 <auto_choose_color+0x286>
    e040:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e044:	74 07                	je     e04d <auto_choose_color+0x281>
    e046:	b8 00 00 00 00       	mov    $0x0,%eax
    e04b:	eb 05                	jmp    e052 <auto_choose_color+0x286>
    e04d:	b8 02 00 00 00       	mov    $0x2,%eax
    e052:	8b 55 08             	mov    0x8(%ebp),%edx
    e055:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    e057:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e05b:	74 60                	je     e0bd <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    e05d:	8b 45 08             	mov    0x8(%ebp),%eax
    e060:	8b 40 04             	mov    0x4(%eax),%eax
    e063:	ba 01 00 00 00       	mov    $0x1,%edx
    e068:	89 c1                	mov    %eax,%ecx
    e06a:	d3 e2                	shl    %cl,%edx
    e06c:	89 d0                	mov    %edx,%eax
    e06e:	83 e8 01             	sub    $0x1,%eax
    e071:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    e074:	8b 45 10             	mov    0x10(%ebp),%eax
    e077:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    e07b:	0f b7 c0             	movzwl %ax,%eax
    e07e:	23 45 c8             	and    -0x38(%ebp),%eax
    e081:	89 c2                	mov    %eax,%edx
    e083:	8b 45 08             	mov    0x8(%ebp),%eax
    e086:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    e089:	8b 45 10             	mov    0x10(%ebp),%eax
    e08c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    e090:	0f b7 c0             	movzwl %ax,%eax
    e093:	23 45 c8             	and    -0x38(%ebp),%eax
    e096:	89 c2                	mov    %eax,%edx
    e098:	8b 45 08             	mov    0x8(%ebp),%eax
    e09b:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    e09e:	8b 45 10             	mov    0x10(%ebp),%eax
    e0a1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    e0a5:	0f b7 c0             	movzwl %ax,%eax
    e0a8:	23 45 c8             	and    -0x38(%ebp),%eax
    e0ab:	89 c2                	mov    %eax,%edx
    e0ad:	8b 45 08             	mov    0x8(%ebp),%eax
    e0b0:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    e0b3:	8b 45 08             	mov    0x8(%ebp),%eax
    e0b6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    e0bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e0c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e0c3:	5b                   	pop    %ebx
    e0c4:	5e                   	pop    %esi
    e0c5:	5d                   	pop    %ebp
    e0c6:	c3                   	ret    

0000e0c7 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    e0c7:	55                   	push   %ebp
    e0c8:	89 e5                	mov    %esp,%ebp
    e0ca:	83 ec 1c             	sub    $0x1c,%esp
    e0cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
    e0d0:	8b 55 0c             	mov    0xc(%ebp),%edx
    e0d3:	8b 45 10             	mov    0x10(%ebp),%eax
    e0d6:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    e0da:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    e0de:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    e0e2:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    e0e6:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e0ea:	29 c2                	sub    %eax,%edx
    e0ec:	89 d0                	mov    %edx,%eax
    e0ee:	99                   	cltd   
    e0ef:	31 d0                	xor    %edx,%eax
    e0f1:	29 d0                	sub    %edx,%eax
    e0f3:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    e0f7:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    e0fb:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e0ff:	29 c2                	sub    %eax,%edx
    e101:	89 d0                	mov    %edx,%eax
    e103:	99                   	cltd   
    e104:	31 d0                	xor    %edx,%eax
    e106:	29 d0                	sub    %edx,%eax
    e108:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    e10c:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    e110:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    e114:	01 c2                	add    %eax,%edx
    e116:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e11a:	29 c2                	sub    %eax,%edx
    e11c:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    e120:	29 c2                	sub    %eax,%edx
    e122:	89 d0                	mov    %edx,%eax
    e124:	99                   	cltd   
    e125:	31 d0                	xor    %edx,%eax
    e127:	29 d0                	sub    %edx,%eax
    e129:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    e12d:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    e131:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    e135:	7d 10                	jge    e147 <paethPredictor+0x80>
    e137:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    e13b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    e13f:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    e143:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    e147:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    e14b:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    e14f:	7d 06                	jge    e157 <paethPredictor+0x90>
    e151:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    e155:	eb 04                	jmp    e15b <paethPredictor+0x94>
    e157:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    e15b:	c9                   	leave  
    e15c:	c3                   	ret    

0000e15d <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    e15d:	55                   	push   %ebp
    e15e:	89 e5                	mov    %esp,%ebp
    e160:	56                   	push   %esi
    e161:	53                   	push   %ebx
    e162:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    e165:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e16c:	e9 e2 00 00 00       	jmp    e253 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    e171:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e174:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e17b:	8b 45 08             	mov    0x8(%ebp),%eax
    e17e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    e181:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e184:	8b 14 85 d4 b0 01 00 	mov    0x1b0d4(,%eax,4),%edx
    e18b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e18e:	01 c2                	add    %eax,%edx
    e190:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e193:	8b 04 85 9c b0 01 00 	mov    0x1b09c(,%eax,4),%eax
    e19a:	29 c2                	sub    %eax,%edx
    e19c:	89 d0                	mov    %edx,%eax
    e19e:	8d 58 ff             	lea    -0x1(%eax),%ebx
    e1a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1a4:	8b 34 85 d4 b0 01 00 	mov    0x1b0d4(,%eax,4),%esi
    e1ab:	89 d8                	mov    %ebx,%eax
    e1ad:	ba 00 00 00 00       	mov    $0x0,%edx
    e1b2:	f7 f6                	div    %esi
    e1b4:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    e1b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e1c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e1c3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    e1c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1c9:	8b 14 85 f0 b0 01 00 	mov    0x1b0f0(,%eax,4),%edx
    e1d0:	8b 45 20             	mov    0x20(%ebp),%eax
    e1d3:	01 c2                	add    %eax,%edx
    e1d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1d8:	8b 04 85 b8 b0 01 00 	mov    0x1b0b8(,%eax,4),%eax
    e1df:	29 c2                	sub    %eax,%edx
    e1e1:	89 d0                	mov    %edx,%eax
    e1e3:	8d 58 ff             	lea    -0x1(%eax),%ebx
    e1e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1e9:	8b 34 85 f0 b0 01 00 	mov    0x1b0f0(,%eax,4),%esi
    e1f0:	89 d8                	mov    %ebx,%eax
    e1f2:	ba 00 00 00 00       	mov    $0x0,%edx
    e1f7:	f7 f6                	div    %esi
    e1f9:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    e1fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e205:	8b 45 08             	mov    0x8(%ebp),%eax
    e208:	01 d0                	add    %edx,%eax
    e20a:	8b 00                	mov    (%eax),%eax
    e20c:	85 c0                	test   %eax,%eax
    e20e:	75 15                	jne    e225 <Adam7_getpassvalues+0xc8>
    e210:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e213:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e21a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e21d:	01 d0                	add    %edx,%eax
    e21f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    e225:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e228:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e22f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e232:	01 d0                	add    %edx,%eax
    e234:	8b 00                	mov    (%eax),%eax
    e236:	85 c0                	test   %eax,%eax
    e238:	75 15                	jne    e24f <Adam7_getpassvalues+0xf2>
    e23a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e23d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e244:	8b 45 08             	mov    0x8(%ebp),%eax
    e247:	01 d0                	add    %edx,%eax
    e249:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    e24f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e253:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    e257:	0f 85 14 ff ff ff    	jne    e171 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    e25d:	8b 45 18             	mov    0x18(%ebp),%eax
    e260:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    e266:	8b 45 18             	mov    0x18(%ebp),%eax
    e269:	8b 10                	mov    (%eax),%edx
    e26b:	8b 45 14             	mov    0x14(%ebp),%eax
    e26e:	89 10                	mov    %edx,(%eax)
    e270:	8b 45 14             	mov    0x14(%ebp),%eax
    e273:	8b 10                	mov    (%eax),%edx
    e275:	8b 45 10             	mov    0x10(%ebp),%eax
    e278:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    e27a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e281:	e9 40 01 00 00       	jmp    e3c6 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    e286:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e289:	83 c0 01             	add    $0x1,%eax
    e28c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e293:	8b 45 10             	mov    0x10(%ebp),%eax
    e296:	01 c2                	add    %eax,%edx
    e298:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e29b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e2a2:	8b 45 10             	mov    0x10(%ebp),%eax
    e2a5:	01 c8                	add    %ecx,%eax
    e2a7:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    e2a9:	89 c6                	mov    %eax,%esi
    e2ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2ae:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e2b5:	8b 45 08             	mov    0x8(%ebp),%eax
    e2b8:	01 c8                	add    %ecx,%eax
    e2ba:	8b 00                	mov    (%eax),%eax
    e2bc:	85 c0                	test   %eax,%eax
    e2be:	74 49                	je     e309 <Adam7_getpassvalues+0x1ac>
    e2c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2c3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e2ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2cd:	01 c8                	add    %ecx,%eax
    e2cf:	8b 00                	mov    (%eax),%eax
    e2d1:	85 c0                	test   %eax,%eax
    e2d3:	74 34                	je     e309 <Adam7_getpassvalues+0x1ac>
    e2d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2d8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e2df:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2e2:	01 c8                	add    %ecx,%eax
    e2e4:	8b 08                	mov    (%eax),%ecx
    e2e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2e9:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    e2f0:	8b 45 08             	mov    0x8(%ebp),%eax
    e2f3:	01 d8                	add    %ebx,%eax
    e2f5:	8b 00                	mov    (%eax),%eax
    e2f7:	0f af 45 24          	imul   0x24(%ebp),%eax
    e2fb:	83 c0 07             	add    $0x7,%eax
    e2fe:	c1 e8 03             	shr    $0x3,%eax
    e301:	83 c0 01             	add    $0x1,%eax
    e304:	0f af c1             	imul   %ecx,%eax
    e307:	eb 05                	jmp    e30e <Adam7_getpassvalues+0x1b1>
    e309:	b8 00 00 00 00       	mov    $0x0,%eax
    e30e:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    e310:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    e312:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e315:	83 c0 01             	add    $0x1,%eax
    e318:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e31f:	8b 45 14             	mov    0x14(%ebp),%eax
    e322:	01 c2                	add    %eax,%edx
    e324:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e327:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e32e:	8b 45 14             	mov    0x14(%ebp),%eax
    e331:	01 c8                	add    %ecx,%eax
    e333:	8b 00                	mov    (%eax),%eax
    e335:	89 c6                	mov    %eax,%esi
    e337:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e33a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e341:	8b 45 0c             	mov    0xc(%ebp),%eax
    e344:	01 c8                	add    %ecx,%eax
    e346:	8b 08                	mov    (%eax),%ecx
    e348:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e34b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    e352:	8b 45 08             	mov    0x8(%ebp),%eax
    e355:	01 d8                	add    %ebx,%eax
    e357:	8b 00                	mov    (%eax),%eax
    e359:	0f af 45 24          	imul   0x24(%ebp),%eax
    e35d:	83 c0 07             	add    $0x7,%eax
    e360:	c1 e8 03             	shr    $0x3,%eax
    e363:	0f af c1             	imul   %ecx,%eax
    e366:	01 f0                	add    %esi,%eax
    e368:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    e36a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e36d:	83 c0 01             	add    $0x1,%eax
    e370:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e377:	8b 45 18             	mov    0x18(%ebp),%eax
    e37a:	01 c2                	add    %eax,%edx
    e37c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e37f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e386:	8b 45 18             	mov    0x18(%ebp),%eax
    e389:	01 c8                	add    %ecx,%eax
    e38b:	8b 00                	mov    (%eax),%eax
    e38d:	89 c6                	mov    %eax,%esi
    e38f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e392:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    e399:	8b 45 0c             	mov    0xc(%ebp),%eax
    e39c:	01 c8                	add    %ecx,%eax
    e39e:	8b 08                	mov    (%eax),%ecx
    e3a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3a3:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    e3aa:	8b 45 08             	mov    0x8(%ebp),%eax
    e3ad:	01 d8                	add    %ebx,%eax
    e3af:	8b 00                	mov    (%eax),%eax
    e3b1:	0f af c1             	imul   %ecx,%eax
    e3b4:	0f af 45 24          	imul   0x24(%ebp),%eax
    e3b8:	83 c0 07             	add    $0x7,%eax
    e3bb:	c1 e8 03             	shr    $0x3,%eax
    e3be:	01 f0                	add    %esi,%eax
    e3c0:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    e3c2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e3c6:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    e3ca:	0f 85 b6 fe ff ff    	jne    e286 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    e3d0:	90                   	nop
    e3d1:	83 c4 10             	add    $0x10,%esp
    e3d4:	5b                   	pop    %ebx
    e3d5:	5e                   	pop    %esi
    e3d6:	5d                   	pop    %ebp
    e3d7:	c3                   	ret    

0000e3d8 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    e3d8:	55                   	push   %ebp
    e3d9:	89 e5                	mov    %esp,%ebp
    e3db:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    e3de:	8b 45 10             	mov    0x10(%ebp),%eax
    e3e1:	05 98 00 00 00       	add    $0x98,%eax
    e3e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    e3e9:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    e3ed:	74 06                	je     e3f5 <lodepng_inspect+0x1d>
    e3ef:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    e3f3:	75 17                	jne    e40c <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    e3f5:	8b 45 10             	mov    0x10(%ebp),%eax
    e3f8:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    e3ff:	00 00 00 
    e402:	b8 30 00 00 00       	mov    $0x30,%eax
    e407:	e9 ce 02 00 00       	jmp    e6da <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    e40c:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    e410:	7f 17                	jg     e429 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    e412:	8b 45 10             	mov    0x10(%ebp),%eax
    e415:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    e41c:	00 00 00 
    e41f:	b8 1b 00 00 00       	mov    $0x1b,%eax
    e424:	e9 b1 02 00 00       	jmp    e6da <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    e429:	83 ec 0c             	sub    $0xc,%esp
    e42c:	ff 75 f4             	pushl  -0xc(%ebp)
    e42f:	e8 63 c7 ff ff       	call   ab97 <lodepng_info_cleanup>
    e434:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    e437:	83 ec 0c             	sub    $0xc,%esp
    e43a:	ff 75 f4             	pushl  -0xc(%ebp)
    e43d:	e8 74 c6 ff ff       	call   aab6 <lodepng_info_init>
    e442:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    e445:	8b 45 14             	mov    0x14(%ebp),%eax
    e448:	0f b6 00             	movzbl (%eax),%eax
    e44b:	3c 89                	cmp    $0x89,%al
    e44d:	75 5b                	jne    e4aa <lodepng_inspect+0xd2>
    e44f:	8b 45 14             	mov    0x14(%ebp),%eax
    e452:	83 c0 01             	add    $0x1,%eax
    e455:	0f b6 00             	movzbl (%eax),%eax
    e458:	3c 50                	cmp    $0x50,%al
    e45a:	75 4e                	jne    e4aa <lodepng_inspect+0xd2>
    e45c:	8b 45 14             	mov    0x14(%ebp),%eax
    e45f:	83 c0 02             	add    $0x2,%eax
    e462:	0f b6 00             	movzbl (%eax),%eax
    e465:	3c 4e                	cmp    $0x4e,%al
    e467:	75 41                	jne    e4aa <lodepng_inspect+0xd2>
    e469:	8b 45 14             	mov    0x14(%ebp),%eax
    e46c:	83 c0 03             	add    $0x3,%eax
    e46f:	0f b6 00             	movzbl (%eax),%eax
    e472:	3c 47                	cmp    $0x47,%al
    e474:	75 34                	jne    e4aa <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    e476:	8b 45 14             	mov    0x14(%ebp),%eax
    e479:	83 c0 04             	add    $0x4,%eax
    e47c:	0f b6 00             	movzbl (%eax),%eax
    e47f:	3c 0d                	cmp    $0xd,%al
    e481:	75 27                	jne    e4aa <lodepng_inspect+0xd2>
    e483:	8b 45 14             	mov    0x14(%ebp),%eax
    e486:	83 c0 05             	add    $0x5,%eax
    e489:	0f b6 00             	movzbl (%eax),%eax
    e48c:	3c 0a                	cmp    $0xa,%al
    e48e:	75 1a                	jne    e4aa <lodepng_inspect+0xd2>
    e490:	8b 45 14             	mov    0x14(%ebp),%eax
    e493:	83 c0 06             	add    $0x6,%eax
    e496:	0f b6 00             	movzbl (%eax),%eax
    e499:	3c 1a                	cmp    $0x1a,%al
    e49b:	75 0d                	jne    e4aa <lodepng_inspect+0xd2>
    e49d:	8b 45 14             	mov    0x14(%ebp),%eax
    e4a0:	83 c0 07             	add    $0x7,%eax
    e4a3:	0f b6 00             	movzbl (%eax),%eax
    e4a6:	3c 0a                	cmp    $0xa,%al
    e4a8:	74 17                	je     e4c1 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    e4aa:	8b 45 10             	mov    0x10(%ebp),%eax
    e4ad:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    e4b4:	00 00 00 
    e4b7:	b8 1c 00 00 00       	mov    $0x1c,%eax
    e4bc:	e9 19 02 00 00       	jmp    e6da <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    e4c1:	8b 45 14             	mov    0x14(%ebp),%eax
    e4c4:	83 c0 08             	add    $0x8,%eax
    e4c7:	83 ec 0c             	sub    $0xc,%esp
    e4ca:	50                   	push   %eax
    e4cb:	e8 c2 ae ff ff       	call   9392 <lodepng_chunk_length>
    e4d0:	83 c4 10             	add    $0x10,%esp
    e4d3:	83 f8 0d             	cmp    $0xd,%eax
    e4d6:	74 17                	je     e4ef <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    e4d8:	8b 45 10             	mov    0x10(%ebp),%eax
    e4db:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    e4e2:	00 00 00 
    e4e5:	b8 5e 00 00 00       	mov    $0x5e,%eax
    e4ea:	e9 eb 01 00 00       	jmp    e6da <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    e4ef:	8b 45 14             	mov    0x14(%ebp),%eax
    e4f2:	83 c0 08             	add    $0x8,%eax
    e4f5:	83 ec 08             	sub    $0x8,%esp
    e4f8:	68 0c b1 01 00       	push   $0x1b10c
    e4fd:	50                   	push   %eax
    e4fe:	e8 dc ae ff ff       	call   93df <lodepng_chunk_type_equals>
    e503:	83 c4 10             	add    $0x10,%esp
    e506:	84 c0                	test   %al,%al
    e508:	75 17                	jne    e521 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    e50a:	8b 45 10             	mov    0x10(%ebp),%eax
    e50d:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    e514:	00 00 00 
    e517:	b8 1d 00 00 00       	mov    $0x1d,%eax
    e51c:	e9 b9 01 00 00       	jmp    e6da <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    e521:	8b 45 14             	mov    0x14(%ebp),%eax
    e524:	83 c0 10             	add    $0x10,%eax
    e527:	83 ec 0c             	sub    $0xc,%esp
    e52a:	50                   	push   %eax
    e52b:	e8 5e 62 ff ff       	call   478e <lodepng_read32bitInt>
    e530:	83 c4 10             	add    $0x10,%esp
    e533:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    e536:	8b 45 14             	mov    0x14(%ebp),%eax
    e539:	83 c0 14             	add    $0x14,%eax
    e53c:	83 ec 0c             	sub    $0xc,%esp
    e53f:	50                   	push   %eax
    e540:	e8 49 62 ff ff       	call   478e <lodepng_read32bitInt>
    e545:	83 c4 10             	add    $0x10,%esp
    e548:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    e54b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    e54f:	74 08                	je     e559 <lodepng_inspect+0x181>
    e551:	8b 45 08             	mov    0x8(%ebp),%eax
    e554:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e557:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    e559:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    e55d:	74 08                	je     e567 <lodepng_inspect+0x18f>
    e55f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e562:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e565:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    e567:	8b 45 14             	mov    0x14(%ebp),%eax
    e56a:	83 c0 18             	add    $0x18,%eax
    e56d:	0f b6 00             	movzbl (%eax),%eax
    e570:	0f b6 d0             	movzbl %al,%edx
    e573:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e576:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    e579:	8b 45 14             	mov    0x14(%ebp),%eax
    e57c:	83 c0 19             	add    $0x19,%eax
    e57f:	0f b6 00             	movzbl (%eax),%eax
    e582:	0f b6 d0             	movzbl %al,%edx
    e585:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e588:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    e58b:	8b 45 14             	mov    0x14(%ebp),%eax
    e58e:	83 c0 1a             	add    $0x1a,%eax
    e591:	0f b6 00             	movzbl (%eax),%eax
    e594:	0f b6 d0             	movzbl %al,%edx
    e597:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e59a:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    e59c:	8b 45 14             	mov    0x14(%ebp),%eax
    e59f:	83 c0 1b             	add    $0x1b,%eax
    e5a2:	0f b6 00             	movzbl (%eax),%eax
    e5a5:	0f b6 d0             	movzbl %al,%edx
    e5a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e5ab:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    e5ae:	8b 45 14             	mov    0x14(%ebp),%eax
    e5b1:	83 c0 1c             	add    $0x1c,%eax
    e5b4:	0f b6 00             	movzbl (%eax),%eax
    e5b7:	0f b6 d0             	movzbl %al,%edx
    e5ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e5bd:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    e5c0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e5c4:	74 06                	je     e5cc <lodepng_inspect+0x1f4>
    e5c6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e5ca:	75 17                	jne    e5e3 <lodepng_inspect+0x20b>
    e5cc:	8b 45 10             	mov    0x10(%ebp),%eax
    e5cf:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    e5d6:	00 00 00 
    e5d9:	b8 5d 00 00 00       	mov    $0x5d,%eax
    e5de:	e9 f7 00 00 00       	jmp    e6da <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    e5e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e5e6:	8b 50 10             	mov    0x10(%eax),%edx
    e5e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e5ec:	8b 40 0c             	mov    0xc(%eax),%eax
    e5ef:	83 ec 08             	sub    $0x8,%esp
    e5f2:	52                   	push   %edx
    e5f3:	50                   	push   %eax
    e5f4:	e8 d4 b3 ff ff       	call   99cd <checkColorValidity>
    e5f9:	83 c4 10             	add    $0x10,%esp
    e5fc:	89 c2                	mov    %eax,%edx
    e5fe:	8b 45 10             	mov    0x10(%ebp),%eax
    e601:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    e607:	8b 45 10             	mov    0x10(%ebp),%eax
    e60a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    e610:	85 c0                	test   %eax,%eax
    e612:	74 0e                	je     e622 <lodepng_inspect+0x24a>
    e614:	8b 45 10             	mov    0x10(%ebp),%eax
    e617:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    e61d:	e9 b8 00 00 00       	jmp    e6da <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    e622:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e625:	8b 00                	mov    (%eax),%eax
    e627:	85 c0                	test   %eax,%eax
    e629:	74 17                	je     e642 <lodepng_inspect+0x26a>
    e62b:	8b 45 10             	mov    0x10(%ebp),%eax
    e62e:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    e635:	00 00 00 
    e638:	b8 20 00 00 00       	mov    $0x20,%eax
    e63d:	e9 98 00 00 00       	jmp    e6da <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    e642:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e645:	8b 40 04             	mov    0x4(%eax),%eax
    e648:	85 c0                	test   %eax,%eax
    e64a:	74 14                	je     e660 <lodepng_inspect+0x288>
    e64c:	8b 45 10             	mov    0x10(%ebp),%eax
    e64f:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    e656:	00 00 00 
    e659:	b8 21 00 00 00       	mov    $0x21,%eax
    e65e:	eb 7a                	jmp    e6da <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    e660:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e663:	8b 40 08             	mov    0x8(%eax),%eax
    e666:	83 f8 01             	cmp    $0x1,%eax
    e669:	76 14                	jbe    e67f <lodepng_inspect+0x2a7>
    e66b:	8b 45 10             	mov    0x10(%ebp),%eax
    e66e:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    e675:	00 00 00 
    e678:	b8 22 00 00 00       	mov    $0x22,%eax
    e67d:	eb 5b                	jmp    e6da <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    e67f:	8b 45 10             	mov    0x10(%ebp),%eax
    e682:	8b 40 18             	mov    0x18(%eax),%eax
    e685:	85 c0                	test   %eax,%eax
    e687:	75 48                	jne    e6d1 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    e689:	8b 45 14             	mov    0x14(%ebp),%eax
    e68c:	83 c0 1d             	add    $0x1d,%eax
    e68f:	83 ec 0c             	sub    $0xc,%esp
    e692:	50                   	push   %eax
    e693:	e8 f6 60 ff ff       	call   478e <lodepng_read32bitInt>
    e698:	83 c4 10             	add    $0x10,%esp
    e69b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    e69e:	8b 45 14             	mov    0x14(%ebp),%eax
    e6a1:	83 c0 0c             	add    $0xc,%eax
    e6a4:	83 ec 08             	sub    $0x8,%esp
    e6a7:	6a 11                	push   $0x11
    e6a9:	50                   	push   %eax
    e6aa:	e8 71 ab ff ff       	call   9220 <lodepng_crc32>
    e6af:	83 c4 10             	add    $0x10,%esp
    e6b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    e6b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e6b8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e6bb:	74 14                	je     e6d1 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    e6bd:	8b 45 10             	mov    0x10(%ebp),%eax
    e6c0:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    e6c7:	00 00 00 
    e6ca:	b8 39 00 00 00       	mov    $0x39,%eax
    e6cf:	eb 09                	jmp    e6da <lodepng_inspect+0x302>
    }
  }

  return state->error;
    e6d1:	8b 45 10             	mov    0x10(%ebp),%eax
    e6d4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    e6da:	c9                   	leave  
    e6db:	c3                   	ret    

0000e6dc <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    e6dc:	55                   	push   %ebp
    e6dd:	89 e5                	mov    %esp,%ebp
    e6df:	56                   	push   %esi
    e6e0:	53                   	push   %ebx
    e6e1:	83 ec 44             	sub    $0x44,%esp
    e6e4:	8b 45 18             	mov    0x18(%ebp),%eax
    e6e7:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    e6ea:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    e6ee:	83 f8 04             	cmp    $0x4,%eax
    e6f1:	0f 87 81 07 00 00    	ja     ee78 <unfilterScanline+0x79c>
    e6f7:	8b 04 85 14 b1 01 00 	mov    0x1b114(,%eax,4),%eax
    e6fe:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    e700:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e707:	eb 19                	jmp    e722 <unfilterScanline+0x46>
    e709:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e70c:	8b 45 08             	mov    0x8(%ebp),%eax
    e70f:	01 c2                	add    %eax,%edx
    e711:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e714:	8b 45 0c             	mov    0xc(%ebp),%eax
    e717:	01 c8                	add    %ecx,%eax
    e719:	0f b6 00             	movzbl (%eax),%eax
    e71c:	88 02                	mov    %al,(%edx)
    e71e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e722:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e725:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e728:	75 df                	jne    e709 <unfilterScanline+0x2d>
      break;
    e72a:	e9 50 07 00 00       	jmp    ee7f <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    e72f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e736:	eb 19                	jmp    e751 <unfilterScanline+0x75>
    e738:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e73b:	8b 45 08             	mov    0x8(%ebp),%eax
    e73e:	01 c2                	add    %eax,%edx
    e740:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e743:	8b 45 0c             	mov    0xc(%ebp),%eax
    e746:	01 c8                	add    %ecx,%eax
    e748:	0f b6 00             	movzbl (%eax),%eax
    e74b:	88 02                	mov    %al,(%edx)
    e74d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e751:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e754:	3b 45 14             	cmp    0x14(%ebp),%eax
    e757:	75 df                	jne    e738 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    e759:	8b 45 14             	mov    0x14(%ebp),%eax
    e75c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e75f:	eb 2b                	jmp    e78c <unfilterScanline+0xb0>
    e761:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e764:	8b 45 08             	mov    0x8(%ebp),%eax
    e767:	01 c2                	add    %eax,%edx
    e769:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e76c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e76f:	01 c8                	add    %ecx,%eax
    e771:	0f b6 08             	movzbl (%eax),%ecx
    e774:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e777:	2b 45 14             	sub    0x14(%ebp),%eax
    e77a:	89 c3                	mov    %eax,%ebx
    e77c:	8b 45 08             	mov    0x8(%ebp),%eax
    e77f:	01 d8                	add    %ebx,%eax
    e781:	0f b6 00             	movzbl (%eax),%eax
    e784:	01 c8                	add    %ecx,%eax
    e786:	88 02                	mov    %al,(%edx)
    e788:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e78c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e78f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e792:	7c cd                	jl     e761 <unfilterScanline+0x85>
      break;
    e794:	e9 e6 06 00 00       	jmp    ee7f <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    e799:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e79d:	74 3c                	je     e7db <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    e79f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e7a6:	eb 26                	jmp    e7ce <unfilterScanline+0xf2>
    e7a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e7ab:	8b 45 08             	mov    0x8(%ebp),%eax
    e7ae:	01 d0                	add    %edx,%eax
    e7b0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e7b3:	8b 55 0c             	mov    0xc(%ebp),%edx
    e7b6:	01 ca                	add    %ecx,%edx
    e7b8:	0f b6 0a             	movzbl (%edx),%ecx
    e7bb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    e7be:	8b 55 10             	mov    0x10(%ebp),%edx
    e7c1:	01 da                	add    %ebx,%edx
    e7c3:	0f b6 12             	movzbl (%edx),%edx
    e7c6:	01 ca                	add    %ecx,%edx
    e7c8:	88 10                	mov    %dl,(%eax)
    e7ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e7ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7d1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e7d4:	75 d2                	jne    e7a8 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    e7d6:	e9 a4 06 00 00       	jmp    ee7f <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    e7db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e7e2:	eb 19                	jmp    e7fd <unfilterScanline+0x121>
    e7e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e7e7:	8b 45 08             	mov    0x8(%ebp),%eax
    e7ea:	01 c2                	add    %eax,%edx
    e7ec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e7ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7f2:	01 c8                	add    %ecx,%eax
    e7f4:	0f b6 00             	movzbl (%eax),%eax
    e7f7:	88 02                	mov    %al,(%edx)
    e7f9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e7fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e800:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e803:	75 df                	jne    e7e4 <unfilterScanline+0x108>
      }
      break;
    e805:	e9 75 06 00 00       	jmp    ee7f <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    e80a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e80e:	0f 84 8e 00 00 00    	je     e8a2 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    e814:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e81b:	eb 28                	jmp    e845 <unfilterScanline+0x169>
    e81d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e820:	8b 45 08             	mov    0x8(%ebp),%eax
    e823:	01 d0                	add    %edx,%eax
    e825:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e828:	8b 55 0c             	mov    0xc(%ebp),%edx
    e82b:	01 ca                	add    %ecx,%edx
    e82d:	0f b6 12             	movzbl (%edx),%edx
    e830:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    e833:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e836:	01 d9                	add    %ebx,%ecx
    e838:	0f b6 09             	movzbl (%ecx),%ecx
    e83b:	d0 e9                	shr    %cl
    e83d:	01 ca                	add    %ecx,%edx
    e83f:	88 10                	mov    %dl,(%eax)
    e841:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e845:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e848:	3b 45 14             	cmp    0x14(%ebp),%eax
    e84b:	75 d0                	jne    e81d <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    e84d:	8b 45 14             	mov    0x14(%ebp),%eax
    e850:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e853:	eb 40                	jmp    e895 <unfilterScanline+0x1b9>
    e855:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e858:	8b 45 08             	mov    0x8(%ebp),%eax
    e85b:	01 c2                	add    %eax,%edx
    e85d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e860:	8b 45 0c             	mov    0xc(%ebp),%eax
    e863:	01 c8                	add    %ecx,%eax
    e865:	0f b6 08             	movzbl (%eax),%ecx
    e868:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e86b:	2b 45 14             	sub    0x14(%ebp),%eax
    e86e:	89 c3                	mov    %eax,%ebx
    e870:	8b 45 08             	mov    0x8(%ebp),%eax
    e873:	01 d8                	add    %ebx,%eax
    e875:	0f b6 00             	movzbl (%eax),%eax
    e878:	0f b6 d8             	movzbl %al,%ebx
    e87b:	8b 75 f4             	mov    -0xc(%ebp),%esi
    e87e:	8b 45 10             	mov    0x10(%ebp),%eax
    e881:	01 f0                	add    %esi,%eax
    e883:	0f b6 00             	movzbl (%eax),%eax
    e886:	0f b6 c0             	movzbl %al,%eax
    e889:	01 d8                	add    %ebx,%eax
    e88b:	d1 f8                	sar    %eax
    e88d:	01 c8                	add    %ecx,%eax
    e88f:	88 02                	mov    %al,(%edx)
    e891:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e895:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e898:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e89b:	7c b8                	jl     e855 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    e89d:	e9 dd 05 00 00       	jmp    ee7f <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    e8a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e8a9:	eb 19                	jmp    e8c4 <unfilterScanline+0x1e8>
    e8ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e8ae:	8b 45 08             	mov    0x8(%ebp),%eax
    e8b1:	01 c2                	add    %eax,%edx
    e8b3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e8b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8b9:	01 c8                	add    %ecx,%eax
    e8bb:	0f b6 00             	movzbl (%eax),%eax
    e8be:	88 02                	mov    %al,(%edx)
    e8c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e8c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8c7:	3b 45 14             	cmp    0x14(%ebp),%eax
    e8ca:	75 df                	jne    e8ab <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    e8cc:	8b 45 14             	mov    0x14(%ebp),%eax
    e8cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e8d2:	eb 2d                	jmp    e901 <unfilterScanline+0x225>
    e8d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e8d7:	8b 45 08             	mov    0x8(%ebp),%eax
    e8da:	01 c2                	add    %eax,%edx
    e8dc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e8df:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8e2:	01 c8                	add    %ecx,%eax
    e8e4:	0f b6 08             	movzbl (%eax),%ecx
    e8e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8ea:	2b 45 14             	sub    0x14(%ebp),%eax
    e8ed:	89 c3                	mov    %eax,%ebx
    e8ef:	8b 45 08             	mov    0x8(%ebp),%eax
    e8f2:	01 d8                	add    %ebx,%eax
    e8f4:	0f b6 00             	movzbl (%eax),%eax
    e8f7:	d0 e8                	shr    %al
    e8f9:	01 c8                	add    %ecx,%eax
    e8fb:	88 02                	mov    %al,(%edx)
    e8fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e901:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e904:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e907:	7c cb                	jl     e8d4 <unfilterScanline+0x1f8>
      }
      break;
    e909:	e9 71 05 00 00       	jmp    ee7f <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    e90e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e912:	0f 84 f9 04 00 00    	je     ee11 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    e918:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e91f:	eb 26                	jmp    e947 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    e921:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e924:	8b 45 08             	mov    0x8(%ebp),%eax
    e927:	01 d0                	add    %edx,%eax
    e929:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e92c:	8b 55 0c             	mov    0xc(%ebp),%edx
    e92f:	01 ca                	add    %ecx,%edx
    e931:	0f b6 0a             	movzbl (%edx),%ecx
    e934:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    e937:	8b 55 10             	mov    0x10(%ebp),%edx
    e93a:	01 da                	add    %ebx,%edx
    e93c:	0f b6 12             	movzbl (%edx),%edx
    e93f:	01 ca                	add    %ecx,%edx
    e941:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    e943:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e947:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e94a:	3b 45 14             	cmp    0x14(%ebp),%eax
    e94d:	75 d2                	jne    e921 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    e94f:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    e953:	0f 8e db 01 00 00    	jle    eb34 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    e959:	e9 c2 01 00 00       	jmp    eb20 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    e95e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e961:	2b 45 14             	sub    0x14(%ebp),%eax
    e964:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    e967:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e96a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e96d:	01 d0                	add    %edx,%eax
    e96f:	0f b6 00             	movzbl (%eax),%eax
    e972:	88 45 ef             	mov    %al,-0x11(%ebp)
    e975:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e978:	8d 50 01             	lea    0x1(%eax),%edx
    e97b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e97e:	01 d0                	add    %edx,%eax
    e980:	0f b6 00             	movzbl (%eax),%eax
    e983:	88 45 ee             	mov    %al,-0x12(%ebp)
    e986:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e989:	8d 50 02             	lea    0x2(%eax),%edx
    e98c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e98f:	01 d0                	add    %edx,%eax
    e991:	0f b6 00             	movzbl (%eax),%eax
    e994:	88 45 ed             	mov    %al,-0x13(%ebp)
    e997:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e99a:	8d 50 03             	lea    0x3(%eax),%edx
    e99d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9a0:	01 d0                	add    %edx,%eax
    e9a2:	0f b6 00             	movzbl (%eax),%eax
    e9a5:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    e9a8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e9ab:	8b 45 08             	mov    0x8(%ebp),%eax
    e9ae:	01 d0                	add    %edx,%eax
    e9b0:	0f b6 00             	movzbl (%eax),%eax
    e9b3:	88 45 eb             	mov    %al,-0x15(%ebp)
    e9b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9b9:	8d 50 01             	lea    0x1(%eax),%edx
    e9bc:	8b 45 08             	mov    0x8(%ebp),%eax
    e9bf:	01 d0                	add    %edx,%eax
    e9c1:	0f b6 00             	movzbl (%eax),%eax
    e9c4:	88 45 ea             	mov    %al,-0x16(%ebp)
    e9c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9ca:	8d 50 02             	lea    0x2(%eax),%edx
    e9cd:	8b 45 08             	mov    0x8(%ebp),%eax
    e9d0:	01 d0                	add    %edx,%eax
    e9d2:	0f b6 00             	movzbl (%eax),%eax
    e9d5:	88 45 e9             	mov    %al,-0x17(%ebp)
    e9d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9db:	8d 50 03             	lea    0x3(%eax),%edx
    e9de:	8b 45 08             	mov    0x8(%ebp),%eax
    e9e1:	01 d0                	add    %edx,%eax
    e9e3:	0f b6 00             	movzbl (%eax),%eax
    e9e6:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    e9e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e9ec:	8b 45 10             	mov    0x10(%ebp),%eax
    e9ef:	01 d0                	add    %edx,%eax
    e9f1:	0f b6 00             	movzbl (%eax),%eax
    e9f4:	88 45 e7             	mov    %al,-0x19(%ebp)
    e9f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e9fa:	8d 50 01             	lea    0x1(%eax),%edx
    e9fd:	8b 45 10             	mov    0x10(%ebp),%eax
    ea00:	01 d0                	add    %edx,%eax
    ea02:	0f b6 00             	movzbl (%eax),%eax
    ea05:	88 45 e6             	mov    %al,-0x1a(%ebp)
    ea08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ea0b:	8d 50 02             	lea    0x2(%eax),%edx
    ea0e:	8b 45 10             	mov    0x10(%ebp),%eax
    ea11:	01 d0                	add    %edx,%eax
    ea13:	0f b6 00             	movzbl (%eax),%eax
    ea16:	88 45 e5             	mov    %al,-0x1b(%ebp)
    ea19:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ea1c:	8d 50 03             	lea    0x3(%eax),%edx
    ea1f:	8b 45 10             	mov    0x10(%ebp),%eax
    ea22:	01 d0                	add    %edx,%eax
    ea24:	0f b6 00             	movzbl (%eax),%eax
    ea27:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    ea2a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ea2d:	8b 45 10             	mov    0x10(%ebp),%eax
    ea30:	01 d0                	add    %edx,%eax
    ea32:	0f b6 00             	movzbl (%eax),%eax
    ea35:	88 45 e3             	mov    %al,-0x1d(%ebp)
    ea38:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea3b:	8d 50 01             	lea    0x1(%eax),%edx
    ea3e:	8b 45 10             	mov    0x10(%ebp),%eax
    ea41:	01 d0                	add    %edx,%eax
    ea43:	0f b6 00             	movzbl (%eax),%eax
    ea46:	88 45 e2             	mov    %al,-0x1e(%ebp)
    ea49:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea4c:	8d 50 02             	lea    0x2(%eax),%edx
    ea4f:	8b 45 10             	mov    0x10(%ebp),%eax
    ea52:	01 d0                	add    %edx,%eax
    ea54:	0f b6 00             	movzbl (%eax),%eax
    ea57:	88 45 e1             	mov    %al,-0x1f(%ebp)
    ea5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea5d:	8d 50 03             	lea    0x3(%eax),%edx
    ea60:	8b 45 10             	mov    0x10(%ebp),%eax
    ea63:	01 d0                	add    %edx,%eax
    ea65:	0f b6 00             	movzbl (%eax),%eax
    ea68:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    ea6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ea6e:	8b 45 08             	mov    0x8(%ebp),%eax
    ea71:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ea74:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    ea78:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    ea7c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    ea80:	51                   	push   %ecx
    ea81:	52                   	push   %edx
    ea82:	50                   	push   %eax
    ea83:	e8 3f f6 ff ff       	call   e0c7 <paethPredictor>
    ea88:	83 c4 0c             	add    $0xc,%esp
    ea8b:	89 c2                	mov    %eax,%edx
    ea8d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    ea91:	01 d0                	add    %edx,%eax
    ea93:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    ea95:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ea98:	8d 50 01             	lea    0x1(%eax),%edx
    ea9b:	8b 45 08             	mov    0x8(%ebp),%eax
    ea9e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    eaa1:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    eaa5:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    eaa9:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    eaad:	51                   	push   %ecx
    eaae:	52                   	push   %edx
    eaaf:	50                   	push   %eax
    eab0:	e8 12 f6 ff ff       	call   e0c7 <paethPredictor>
    eab5:	83 c4 0c             	add    $0xc,%esp
    eab8:	89 c2                	mov    %eax,%edx
    eaba:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    eabe:	01 d0                	add    %edx,%eax
    eac0:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    eac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eac5:	8d 50 02             	lea    0x2(%eax),%edx
    eac8:	8b 45 08             	mov    0x8(%ebp),%eax
    eacb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    eace:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    ead2:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    ead6:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    eada:	51                   	push   %ecx
    eadb:	52                   	push   %edx
    eadc:	50                   	push   %eax
    eadd:	e8 e5 f5 ff ff       	call   e0c7 <paethPredictor>
    eae2:	83 c4 0c             	add    $0xc,%esp
    eae5:	89 c2                	mov    %eax,%edx
    eae7:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    eaeb:	01 d0                	add    %edx,%eax
    eaed:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    eaef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eaf2:	8d 50 03             	lea    0x3(%eax),%edx
    eaf5:	8b 45 08             	mov    0x8(%ebp),%eax
    eaf8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    eafb:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    eaff:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    eb03:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    eb07:	51                   	push   %ecx
    eb08:	52                   	push   %edx
    eb09:	50                   	push   %eax
    eb0a:	e8 b8 f5 ff ff       	call   e0c7 <paethPredictor>
    eb0f:	83 c4 0c             	add    $0xc,%esp
    eb12:	89 c2                	mov    %eax,%edx
    eb14:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    eb18:	01 d0                	add    %edx,%eax
    eb1a:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    eb1c:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    eb20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb23:	83 c0 03             	add    $0x3,%eax
    eb26:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    eb29:	0f 8c 2f fe ff ff    	jl     e95e <unfilterScanline+0x282>
    eb2f:	e9 d3 02 00 00       	jmp    ee07 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    eb34:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    eb38:	0f 8e 6a 01 00 00    	jle    eca8 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    eb3e:	e9 51 01 00 00       	jmp    ec94 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    eb43:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb46:	2b 45 14             	sub    0x14(%ebp),%eax
    eb49:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    eb4c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    eb4f:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb52:	01 d0                	add    %edx,%eax
    eb54:	0f b6 00             	movzbl (%eax),%eax
    eb57:	88 45 db             	mov    %al,-0x25(%ebp)
    eb5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb5d:	8d 50 01             	lea    0x1(%eax),%edx
    eb60:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb63:	01 d0                	add    %edx,%eax
    eb65:	0f b6 00             	movzbl (%eax),%eax
    eb68:	88 45 da             	mov    %al,-0x26(%ebp)
    eb6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb6e:	8d 50 02             	lea    0x2(%eax),%edx
    eb71:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb74:	01 d0                	add    %edx,%eax
    eb76:	0f b6 00             	movzbl (%eax),%eax
    eb79:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    eb7c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    eb7f:	8b 45 08             	mov    0x8(%ebp),%eax
    eb82:	01 d0                	add    %edx,%eax
    eb84:	0f b6 00             	movzbl (%eax),%eax
    eb87:	88 45 d8             	mov    %al,-0x28(%ebp)
    eb8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    eb8d:	8d 50 01             	lea    0x1(%eax),%edx
    eb90:	8b 45 08             	mov    0x8(%ebp),%eax
    eb93:	01 d0                	add    %edx,%eax
    eb95:	0f b6 00             	movzbl (%eax),%eax
    eb98:	88 45 d7             	mov    %al,-0x29(%ebp)
    eb9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    eb9e:	8d 50 02             	lea    0x2(%eax),%edx
    eba1:	8b 45 08             	mov    0x8(%ebp),%eax
    eba4:	01 d0                	add    %edx,%eax
    eba6:	0f b6 00             	movzbl (%eax),%eax
    eba9:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    ebac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ebaf:	8b 45 10             	mov    0x10(%ebp),%eax
    ebb2:	01 d0                	add    %edx,%eax
    ebb4:	0f b6 00             	movzbl (%eax),%eax
    ebb7:	88 45 d5             	mov    %al,-0x2b(%ebp)
    ebba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ebbd:	8d 50 01             	lea    0x1(%eax),%edx
    ebc0:	8b 45 10             	mov    0x10(%ebp),%eax
    ebc3:	01 d0                	add    %edx,%eax
    ebc5:	0f b6 00             	movzbl (%eax),%eax
    ebc8:	88 45 d4             	mov    %al,-0x2c(%ebp)
    ebcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ebce:	8d 50 02             	lea    0x2(%eax),%edx
    ebd1:	8b 45 10             	mov    0x10(%ebp),%eax
    ebd4:	01 d0                	add    %edx,%eax
    ebd6:	0f b6 00             	movzbl (%eax),%eax
    ebd9:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    ebdc:	8b 55 dc             	mov    -0x24(%ebp),%edx
    ebdf:	8b 45 10             	mov    0x10(%ebp),%eax
    ebe2:	01 d0                	add    %edx,%eax
    ebe4:	0f b6 00             	movzbl (%eax),%eax
    ebe7:	88 45 d2             	mov    %al,-0x2e(%ebp)
    ebea:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ebed:	8d 50 01             	lea    0x1(%eax),%edx
    ebf0:	8b 45 10             	mov    0x10(%ebp),%eax
    ebf3:	01 d0                	add    %edx,%eax
    ebf5:	0f b6 00             	movzbl (%eax),%eax
    ebf8:	88 45 d1             	mov    %al,-0x2f(%ebp)
    ebfb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ebfe:	8d 50 02             	lea    0x2(%eax),%edx
    ec01:	8b 45 10             	mov    0x10(%ebp),%eax
    ec04:	01 d0                	add    %edx,%eax
    ec06:	0f b6 00             	movzbl (%eax),%eax
    ec09:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    ec0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ec0f:	8b 45 08             	mov    0x8(%ebp),%eax
    ec12:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ec15:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    ec19:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    ec1d:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    ec21:	51                   	push   %ecx
    ec22:	52                   	push   %edx
    ec23:	50                   	push   %eax
    ec24:	e8 9e f4 ff ff       	call   e0c7 <paethPredictor>
    ec29:	83 c4 0c             	add    $0xc,%esp
    ec2c:	89 c2                	mov    %eax,%edx
    ec2e:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    ec32:	01 d0                	add    %edx,%eax
    ec34:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    ec36:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec39:	8d 50 01             	lea    0x1(%eax),%edx
    ec3c:	8b 45 08             	mov    0x8(%ebp),%eax
    ec3f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ec42:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    ec46:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    ec4a:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    ec4e:	51                   	push   %ecx
    ec4f:	52                   	push   %edx
    ec50:	50                   	push   %eax
    ec51:	e8 71 f4 ff ff       	call   e0c7 <paethPredictor>
    ec56:	83 c4 0c             	add    $0xc,%esp
    ec59:	89 c2                	mov    %eax,%edx
    ec5b:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    ec5f:	01 d0                	add    %edx,%eax
    ec61:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    ec63:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec66:	8d 50 02             	lea    0x2(%eax),%edx
    ec69:	8b 45 08             	mov    0x8(%ebp),%eax
    ec6c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ec6f:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    ec73:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    ec77:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    ec7b:	51                   	push   %ecx
    ec7c:	52                   	push   %edx
    ec7d:	50                   	push   %eax
    ec7e:	e8 44 f4 ff ff       	call   e0c7 <paethPredictor>
    ec83:	83 c4 0c             	add    $0xc,%esp
    ec86:	89 c2                	mov    %eax,%edx
    ec88:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    ec8c:	01 d0                	add    %edx,%eax
    ec8e:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    ec90:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    ec94:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec97:	83 c0 02             	add    $0x2,%eax
    ec9a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ec9d:	0f 8c a0 fe ff ff    	jl     eb43 <unfilterScanline+0x467>
    eca3:	e9 5f 01 00 00       	jmp    ee07 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    eca8:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    ecac:	0f 8e 55 01 00 00    	jle    ee07 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    ecb2:	e9 e0 00 00 00       	jmp    ed97 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    ecb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ecba:	2b 45 14             	sub    0x14(%ebp),%eax
    ecbd:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    ecc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ecc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecc6:	01 d0                	add    %edx,%eax
    ecc8:	0f b6 00             	movzbl (%eax),%eax
    eccb:	88 45 cb             	mov    %al,-0x35(%ebp)
    ecce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ecd1:	8d 50 01             	lea    0x1(%eax),%edx
    ecd4:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecd7:	01 d0                	add    %edx,%eax
    ecd9:	0f b6 00             	movzbl (%eax),%eax
    ecdc:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    ecdf:	8b 55 cc             	mov    -0x34(%ebp),%edx
    ece2:	8b 45 08             	mov    0x8(%ebp),%eax
    ece5:	01 d0                	add    %edx,%eax
    ece7:	0f b6 00             	movzbl (%eax),%eax
    ecea:	88 45 c9             	mov    %al,-0x37(%ebp)
    eced:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ecf0:	8d 50 01             	lea    0x1(%eax),%edx
    ecf3:	8b 45 08             	mov    0x8(%ebp),%eax
    ecf6:	01 d0                	add    %edx,%eax
    ecf8:	0f b6 00             	movzbl (%eax),%eax
    ecfb:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    ecfe:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ed01:	8b 45 10             	mov    0x10(%ebp),%eax
    ed04:	01 d0                	add    %edx,%eax
    ed06:	0f b6 00             	movzbl (%eax),%eax
    ed09:	88 45 c7             	mov    %al,-0x39(%ebp)
    ed0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed0f:	8d 50 01             	lea    0x1(%eax),%edx
    ed12:	8b 45 10             	mov    0x10(%ebp),%eax
    ed15:	01 d0                	add    %edx,%eax
    ed17:	0f b6 00             	movzbl (%eax),%eax
    ed1a:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    ed1d:	8b 55 cc             	mov    -0x34(%ebp),%edx
    ed20:	8b 45 10             	mov    0x10(%ebp),%eax
    ed23:	01 d0                	add    %edx,%eax
    ed25:	0f b6 00             	movzbl (%eax),%eax
    ed28:	88 45 c5             	mov    %al,-0x3b(%ebp)
    ed2b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ed2e:	8d 50 01             	lea    0x1(%eax),%edx
    ed31:	8b 45 10             	mov    0x10(%ebp),%eax
    ed34:	01 d0                	add    %edx,%eax
    ed36:	0f b6 00             	movzbl (%eax),%eax
    ed39:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    ed3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ed3f:	8b 45 08             	mov    0x8(%ebp),%eax
    ed42:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ed45:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    ed49:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    ed4d:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    ed51:	51                   	push   %ecx
    ed52:	52                   	push   %edx
    ed53:	50                   	push   %eax
    ed54:	e8 6e f3 ff ff       	call   e0c7 <paethPredictor>
    ed59:	83 c4 0c             	add    $0xc,%esp
    ed5c:	89 c2                	mov    %eax,%edx
    ed5e:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    ed62:	01 d0                	add    %edx,%eax
    ed64:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    ed66:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed69:	8d 50 01             	lea    0x1(%eax),%edx
    ed6c:	8b 45 08             	mov    0x8(%ebp),%eax
    ed6f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ed72:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    ed76:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    ed7a:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    ed7e:	51                   	push   %ecx
    ed7f:	52                   	push   %edx
    ed80:	50                   	push   %eax
    ed81:	e8 41 f3 ff ff       	call   e0c7 <paethPredictor>
    ed86:	83 c4 0c             	add    $0xc,%esp
    ed89:	89 c2                	mov    %eax,%edx
    ed8b:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    ed8f:	01 d0                	add    %edx,%eax
    ed91:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    ed93:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    ed97:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed9a:	83 c0 01             	add    $0x1,%eax
    ed9d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    eda0:	0f 8c 11 ff ff ff    	jl     ecb7 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    eda6:	eb 5f                	jmp    ee07 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    eda8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    edab:	8b 45 08             	mov    0x8(%ebp),%eax
    edae:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    edb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    edb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    edb7:	01 d0                	add    %edx,%eax
    edb9:	0f b6 00             	movzbl (%eax),%eax
    edbc:	88 45 b7             	mov    %al,-0x49(%ebp)
    edbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    edc2:	2b 45 14             	sub    0x14(%ebp),%eax
    edc5:	89 c2                	mov    %eax,%edx
    edc7:	8b 45 10             	mov    0x10(%ebp),%eax
    edca:	01 d0                	add    %edx,%eax
    edcc:	0f b6 00             	movzbl (%eax),%eax
    edcf:	0f b6 c8             	movzbl %al,%ecx
    edd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    edd5:	8b 45 10             	mov    0x10(%ebp),%eax
    edd8:	01 d0                	add    %edx,%eax
    edda:	0f b6 00             	movzbl (%eax),%eax
    eddd:	0f b6 d0             	movzbl %al,%edx
    ede0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ede3:	2b 45 14             	sub    0x14(%ebp),%eax
    ede6:	89 c6                	mov    %eax,%esi
    ede8:	8b 45 08             	mov    0x8(%ebp),%eax
    edeb:	01 f0                	add    %esi,%eax
    eded:	0f b6 00             	movzbl (%eax),%eax
    edf0:	0f b6 c0             	movzbl %al,%eax
    edf3:	51                   	push   %ecx
    edf4:	52                   	push   %edx
    edf5:	50                   	push   %eax
    edf6:	e8 cc f2 ff ff       	call   e0c7 <paethPredictor>
    edfb:	83 c4 0c             	add    $0xc,%esp
    edfe:	02 45 b7             	add    -0x49(%ebp),%al
    ee01:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    ee03:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ee07:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee0a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ee0d:	75 99                	jne    eda8 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    ee0f:	eb 6e                	jmp    ee7f <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    ee11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ee18:	eb 19                	jmp    ee33 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    ee1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ee1d:	8b 45 08             	mov    0x8(%ebp),%eax
    ee20:	01 c2                	add    %eax,%edx
    ee22:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ee25:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee28:	01 c8                	add    %ecx,%eax
    ee2a:	0f b6 00             	movzbl (%eax),%eax
    ee2d:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    ee2f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ee33:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee36:	3b 45 14             	cmp    0x14(%ebp),%eax
    ee39:	75 df                	jne    ee1a <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    ee3b:	8b 45 14             	mov    0x14(%ebp),%eax
    ee3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ee41:	eb 2b                	jmp    ee6e <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    ee43:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ee46:	8b 45 08             	mov    0x8(%ebp),%eax
    ee49:	01 c2                	add    %eax,%edx
    ee4b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ee4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee51:	01 c8                	add    %ecx,%eax
    ee53:	0f b6 08             	movzbl (%eax),%ecx
    ee56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee59:	2b 45 14             	sub    0x14(%ebp),%eax
    ee5c:	89 c3                	mov    %eax,%ebx
    ee5e:	8b 45 08             	mov    0x8(%ebp),%eax
    ee61:	01 d8                	add    %ebx,%eax
    ee63:	0f b6 00             	movzbl (%eax),%eax
    ee66:	01 c8                	add    %ecx,%eax
    ee68:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    ee6a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ee6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee71:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ee74:	7c cd                	jl     ee43 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    ee76:	eb 07                	jmp    ee7f <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    ee78:	b8 24 00 00 00       	mov    $0x24,%eax
    ee7d:	eb 05                	jmp    ee84 <unfilterScanline+0x7a8>
  }
  return 0;
    ee7f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ee84:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ee87:	5b                   	pop    %ebx
    ee88:	5e                   	pop    %esi
    ee89:	5d                   	pop    %ebp
    ee8a:	c3                   	ret    

0000ee8b <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    ee8b:	55                   	push   %ebp
    ee8c:	89 e5                	mov    %esp,%ebp
    ee8e:	53                   	push   %ebx
    ee8f:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    ee92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    ee99:	8b 45 18             	mov    0x18(%ebp),%eax
    ee9c:	83 c0 07             	add    $0x7,%eax
    ee9f:	c1 e8 03             	shr    $0x3,%eax
    eea2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    eea5:	ff 75 18             	pushl  0x18(%ebp)
    eea8:	6a 01                	push   $0x1
    eeaa:	ff 75 10             	pushl  0x10(%ebp)
    eead:	e8 d9 b1 ff ff       	call   a08b <lodepng_get_raw_size_idat>
    eeb2:	83 c4 0c             	add    $0xc,%esp
    eeb5:	83 e8 01             	sub    $0x1,%eax
    eeb8:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    eebb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    eec2:	eb 6d                	jmp    ef31 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    eec4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eec7:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    eecb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    eece:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eed1:	83 c0 01             	add    $0x1,%eax
    eed4:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    eed8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    eedb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    eede:	8b 45 0c             	mov    0xc(%ebp),%eax
    eee1:	01 d0                	add    %edx,%eax
    eee3:	0f b6 00             	movzbl (%eax),%eax
    eee6:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    eee9:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    eeed:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    eef0:	8d 4a 01             	lea    0x1(%edx),%ecx
    eef3:	8b 55 0c             	mov    0xc(%ebp),%edx
    eef6:	01 d1                	add    %edx,%ecx
    eef8:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    eefb:	8b 55 08             	mov    0x8(%ebp),%edx
    eefe:	01 da                	add    %ebx,%edx
    ef00:	ff 75 ec             	pushl  -0x14(%ebp)
    ef03:	50                   	push   %eax
    ef04:	ff 75 f0             	pushl  -0x10(%ebp)
    ef07:	ff 75 f4             	pushl  -0xc(%ebp)
    ef0a:	51                   	push   %ecx
    ef0b:	52                   	push   %edx
    ef0c:	e8 cb f7 ff ff       	call   e6dc <unfilterScanline>
    ef11:	83 c4 18             	add    $0x18,%esp
    ef14:	89 45 dc             	mov    %eax,-0x24(%ebp)
    ef17:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ef1b:	74 05                	je     ef22 <unfilter+0x97>
    ef1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ef20:	eb 1c                	jmp    ef3e <unfilter+0xb3>

    prevline = &out[outindex];
    ef22:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ef25:	8b 45 08             	mov    0x8(%ebp),%eax
    ef28:	01 d0                	add    %edx,%eax
    ef2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    ef2d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ef31:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ef34:	3b 45 14             	cmp    0x14(%ebp),%eax
    ef37:	72 8b                	jb     eec4 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    ef39:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ef41:	c9                   	leave  
    ef42:	c3                   	ret    

0000ef43 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    ef43:	55                   	push   %ebp
    ef44:	89 e5                	mov    %esp,%ebp
    ef46:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    ef4c:	ff 75 18             	pushl  0x18(%ebp)
    ef4f:	ff 75 14             	pushl  0x14(%ebp)
    ef52:	ff 75 10             	pushl  0x10(%ebp)
    ef55:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    ef5b:	50                   	push   %eax
    ef5c:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    ef62:	50                   	push   %eax
    ef63:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ef69:	50                   	push   %eax
    ef6a:	8d 45 94             	lea    -0x6c(%ebp),%eax
    ef6d:	50                   	push   %eax
    ef6e:	8d 45 b0             	lea    -0x50(%ebp),%eax
    ef71:	50                   	push   %eax
    ef72:	e8 e6 f1 ff ff       	call   e15d <Adam7_getpassvalues>
    ef77:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    ef7a:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    ef7e:	0f 86 0a 01 00 00    	jbe    f08e <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    ef84:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ef8b:	e9 ef 00 00 00       	jmp    f07f <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    ef90:	8b 45 18             	mov    0x18(%ebp),%eax
    ef93:	c1 e8 03             	shr    $0x3,%eax
    ef96:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    ef99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    efa0:	e9 c6 00 00 00       	jmp    f06b <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    efa5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    efac:	e9 a6 00 00 00       	jmp    f057 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    efb1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    efb4:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    efbb:	89 c1                	mov    %eax,%ecx
    efbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    efc0:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    efc4:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    efc8:	89 c2                	mov    %eax,%edx
    efca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    efcd:	01 c2                	add    %eax,%edx
    efcf:	8b 45 e0             	mov    -0x20(%ebp),%eax
    efd2:	0f af c2             	imul   %edx,%eax
    efd5:	01 c8                	add    %ecx,%eax
    efd7:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    efda:	8b 45 fc             	mov    -0x4(%ebp),%eax
    efdd:	8b 14 85 b8 b0 01 00 	mov    0x1b0b8(,%eax,4),%edx
    efe4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    efe7:	8b 04 85 f0 b0 01 00 	mov    0x1b0f0(,%eax,4),%eax
    efee:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    eff2:	01 d0                	add    %edx,%eax
    eff4:	0f af 45 10          	imul   0x10(%ebp),%eax
    eff8:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    effa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    effd:	8b 04 85 d4 b0 01 00 	mov    0x1b0d4(,%eax,4),%eax
    f004:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    f008:	01 c2                	add    %eax,%edx
    f00a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f00d:	8b 04 85 9c b0 01 00 	mov    0x1b09c(,%eax,4),%eax
    f014:	01 c2                	add    %eax,%edx
    f016:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f019:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    f01c:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    f01f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f026:	eb 23                	jmp    f04b <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    f028:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f02b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f02e:	01 c2                	add    %eax,%edx
    f030:	8b 45 08             	mov    0x8(%ebp),%eax
    f033:	01 c2                	add    %eax,%edx
    f035:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    f038:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f03b:	01 c1                	add    %eax,%ecx
    f03d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f040:	01 c8                	add    %ecx,%eax
    f042:	0f b6 00             	movzbl (%eax),%eax
    f045:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    f047:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f04b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f04e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f051:	72 d5                	jb     f028 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    f053:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f057:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f05a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    f05e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    f061:	0f 87 4a ff ff ff    	ja     efb1 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    f067:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f06b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f06e:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    f072:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    f075:	0f 87 2a ff ff ff    	ja     efa5 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    f07b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f07f:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    f083:	0f 85 07 ff ff ff    	jne    ef90 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    f089:	e9 22 01 00 00       	jmp    f1b0 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    f08e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f095:	e9 0c 01 00 00       	jmp    f1a6 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    f09a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f09d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    f0a1:	0f af 45 18          	imul   0x18(%ebp),%eax
    f0a5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    f0a8:	8b 45 18             	mov    0x18(%ebp),%eax
    f0ab:	0f af 45 10          	imul   0x10(%ebp),%eax
    f0af:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    f0b2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    f0b9:	e9 d4 00 00 00       	jmp    f192 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    f0be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f0c5:	e9 b4 00 00 00       	jmp    f17e <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    f0ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f0cd:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    f0d4:	c1 e0 03             	shl    $0x3,%eax
    f0d7:	89 c1                	mov    %eax,%ecx
    f0d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f0dc:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    f0e0:	89 c2                	mov    %eax,%edx
    f0e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f0e5:	0f af 45 18          	imul   0x18(%ebp),%eax
    f0e9:	01 d0                	add    %edx,%eax
    f0eb:	01 c8                	add    %ecx,%eax
    f0ed:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    f0f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f0f6:	8b 14 85 b8 b0 01 00 	mov    0x1b0b8(,%eax,4),%edx
    f0fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f100:	8b 04 85 f0 b0 01 00 	mov    0x1b0f0(,%eax,4),%eax
    f107:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    f10b:	01 d0                	add    %edx,%eax
    f10d:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    f111:	89 c2                	mov    %eax,%edx
    f113:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f116:	8b 0c 85 9c b0 01 00 	mov    0x1b09c(,%eax,4),%ecx
    f11d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f120:	8b 04 85 d4 b0 01 00 	mov    0x1b0d4(,%eax,4),%eax
    f127:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f12b:	01 c8                	add    %ecx,%eax
    f12d:	0f af 45 18          	imul   0x18(%ebp),%eax
    f131:	01 d0                	add    %edx,%eax
    f133:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    f139:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    f140:	eb 30                	jmp    f172 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    f142:	ff 75 0c             	pushl  0xc(%ebp)
    f145:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    f14b:	50                   	push   %eax
    f14c:	e8 1e a1 ff ff       	call   926f <readBitFromReversedStream>
    f151:	83 c4 08             	add    $0x8,%esp
    f154:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    f157:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    f15b:	50                   	push   %eax
    f15c:	ff 75 08             	pushl  0x8(%ebp)
    f15f:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    f165:	50                   	push   %eax
    f166:	e8 86 a1 ff ff       	call   92f1 <setBitOfReversedStream>
    f16b:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    f16e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    f172:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f175:	3b 45 18             	cmp    0x18(%ebp),%eax
    f178:	72 c8                	jb     f142 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    f17a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f17e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f181:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    f185:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f188:	0f 87 3c ff ff ff    	ja     f0ca <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    f18e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    f192:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f195:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    f199:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    f19c:	0f 87 1c ff ff ff    	ja     f0be <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    f1a2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f1a6:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    f1aa:	0f 85 ea fe ff ff    	jne    f09a <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    f1b0:	90                   	nop
    f1b1:	c9                   	leave  
    f1b2:	c3                   	ret    

0000f1b3 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    f1b3:	55                   	push   %ebp
    f1b4:	89 e5                	mov    %esp,%ebp
    f1b6:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    f1b9:	8b 45 14             	mov    0x14(%ebp),%eax
    f1bc:	2b 45 10             	sub    0x10(%ebp),%eax
    f1bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    f1c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f1c9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    f1d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f1d7:	eb 4a                	jmp    f223 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    f1d9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f1e0:	eb 2a                	jmp    f20c <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    f1e2:	ff 75 0c             	pushl  0xc(%ebp)
    f1e5:	8d 45 ec             	lea    -0x14(%ebp),%eax
    f1e8:	50                   	push   %eax
    f1e9:	e8 81 a0 ff ff       	call   926f <readBitFromReversedStream>
    f1ee:	83 c4 08             	add    $0x8,%esp
    f1f1:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    f1f4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    f1f8:	50                   	push   %eax
    f1f9:	ff 75 08             	pushl  0x8(%ebp)
    f1fc:	8d 45 e8             	lea    -0x18(%ebp),%eax
    f1ff:	50                   	push   %eax
    f200:	e8 ec a0 ff ff       	call   92f1 <setBitOfReversedStream>
    f205:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    f208:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f20c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f20f:	3b 45 10             	cmp    0x10(%ebp),%eax
    f212:	7c ce                	jl     f1e2 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    f214:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f217:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f21a:	01 d0                	add    %edx,%eax
    f21c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    f21f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f223:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f226:	3b 45 18             	cmp    0x18(%ebp),%eax
    f229:	72 ae                	jb     f1d9 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    f22b:	90                   	nop
    f22c:	c9                   	leave  
    f22d:	c3                   	ret    

0000f22e <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    f22e:	55                   	push   %ebp
    f22f:	89 e5                	mov    %esp,%ebp
    f231:	57                   	push   %edi
    f232:	56                   	push   %esi
    f233:	53                   	push   %ebx
    f234:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    f23a:	8b 45 18             	mov    0x18(%ebp),%eax
    f23d:	83 c0 0c             	add    $0xc,%eax
    f240:	50                   	push   %eax
    f241:	e8 e6 ac ff ff       	call   9f2c <lodepng_get_bpp>
    f246:	83 c4 04             	add    $0x4,%esp
    f249:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    f24c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f250:	75 0a                	jne    f25c <postProcessScanlines+0x2e>
    f252:	b8 1f 00 00 00       	mov    $0x1f,%eax
    f257:	e9 c3 01 00 00       	jmp    f41f <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    f25c:	8b 45 18             	mov    0x18(%ebp),%eax
    f25f:	8b 40 08             	mov    0x8(%eax),%eax
    f262:	85 c0                	test   %eax,%eax
    f264:	0f 85 a8 00 00 00    	jne    f312 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    f26a:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    f26e:	77 76                	ja     f2e6 <postProcessScanlines+0xb8>
    f270:	8b 45 10             	mov    0x10(%ebp),%eax
    f273:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f277:	89 c2                	mov    %eax,%edx
    f279:	8b 45 10             	mov    0x10(%ebp),%eax
    f27c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f280:	83 c0 07             	add    $0x7,%eax
    f283:	c1 e8 03             	shr    $0x3,%eax
    f286:	c1 e0 03             	shl    $0x3,%eax
    f289:	39 c2                	cmp    %eax,%edx
    f28b:	74 59                	je     f2e6 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    f28d:	ff 75 ec             	pushl  -0x14(%ebp)
    f290:	ff 75 14             	pushl  0x14(%ebp)
    f293:	ff 75 10             	pushl  0x10(%ebp)
    f296:	ff 75 0c             	pushl  0xc(%ebp)
    f299:	ff 75 0c             	pushl  0xc(%ebp)
    f29c:	e8 ea fb ff ff       	call   ee8b <unfilter>
    f2a1:	83 c4 14             	add    $0x14,%esp
    f2a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    f2a7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    f2ab:	74 08                	je     f2b5 <postProcessScanlines+0x87>
    f2ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f2b0:	e9 6a 01 00 00       	jmp    f41f <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    f2b5:	8b 45 10             	mov    0x10(%ebp),%eax
    f2b8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f2bc:	83 c0 07             	add    $0x7,%eax
    f2bf:	c1 e8 03             	shr    $0x3,%eax
    f2c2:	c1 e0 03             	shl    $0x3,%eax
    f2c5:	89 c2                	mov    %eax,%edx
    f2c7:	8b 45 10             	mov    0x10(%ebp),%eax
    f2ca:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f2ce:	ff 75 14             	pushl  0x14(%ebp)
    f2d1:	52                   	push   %edx
    f2d2:	50                   	push   %eax
    f2d3:	ff 75 0c             	pushl  0xc(%ebp)
    f2d6:	ff 75 08             	pushl  0x8(%ebp)
    f2d9:	e8 d5 fe ff ff       	call   f1b3 <removePaddingBits>
    f2de:	83 c4 14             	add    $0x14,%esp
    f2e1:	e9 34 01 00 00       	jmp    f41a <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    f2e6:	ff 75 ec             	pushl  -0x14(%ebp)
    f2e9:	ff 75 14             	pushl  0x14(%ebp)
    f2ec:	ff 75 10             	pushl  0x10(%ebp)
    f2ef:	ff 75 0c             	pushl  0xc(%ebp)
    f2f2:	ff 75 08             	pushl  0x8(%ebp)
    f2f5:	e8 91 fb ff ff       	call   ee8b <unfilter>
    f2fa:	83 c4 14             	add    $0x14,%esp
    f2fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    f300:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    f304:	0f 84 10 01 00 00    	je     f41a <postProcessScanlines+0x1ec>
    f30a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f30d:	e9 0d 01 00 00       	jmp    f41f <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    f312:	ff 75 ec             	pushl  -0x14(%ebp)
    f315:	ff 75 14             	pushl  0x14(%ebp)
    f318:	ff 75 10             	pushl  0x10(%ebp)
    f31b:	8d 45 88             	lea    -0x78(%ebp),%eax
    f31e:	50                   	push   %eax
    f31f:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    f325:	50                   	push   %eax
    f326:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    f32c:	50                   	push   %eax
    f32d:	8d 45 a8             	lea    -0x58(%ebp),%eax
    f330:	50                   	push   %eax
    f331:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    f334:	50                   	push   %eax
    f335:	e8 23 ee ff ff       	call   e15d <Adam7_getpassvalues>
    f33a:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    f33d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f344:	e9 b0 00 00 00       	jmp    f3f9 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    f349:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f34c:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    f350:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f353:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    f357:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    f35a:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    f361:	89 cb                	mov    %ecx,%ebx
    f363:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f366:	01 cb                	add    %ecx,%ebx
    f368:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    f36b:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    f372:	89 ce                	mov    %ecx,%esi
    f374:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f377:	01 f1                	add    %esi,%ecx
    f379:	ff 75 ec             	pushl  -0x14(%ebp)
    f37c:	52                   	push   %edx
    f37d:	50                   	push   %eax
    f37e:	53                   	push   %ebx
    f37f:	51                   	push   %ecx
    f380:	e8 06 fb ff ff       	call   ee8b <unfilter>
    f385:	83 c4 14             	add    $0x14,%esp
    f388:	89 45 e0             	mov    %eax,-0x20(%ebp)
    f38b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    f38f:	74 08                	je     f399 <postProcessScanlines+0x16b>
    f391:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f394:	e9 86 00 00 00       	jmp    f41f <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    f399:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    f39d:	77 56                	ja     f3f5 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    f39f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f3a2:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    f3a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3a9:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    f3ad:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    f3b1:	83 c2 07             	add    $0x7,%edx
    f3b4:	c1 ea 03             	shr    $0x3,%edx
    f3b7:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    f3ba:	89 d6                	mov    %edx,%esi
    f3bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3bf:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    f3c3:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    f3c7:	89 d3                	mov    %edx,%ebx
    f3c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3cc:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    f3d3:	89 d1                	mov    %edx,%ecx
    f3d5:	8b 55 0c             	mov    0xc(%ebp),%edx
    f3d8:	01 d1                	add    %edx,%ecx
    f3da:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3dd:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    f3e1:	89 d7                	mov    %edx,%edi
    f3e3:	8b 55 0c             	mov    0xc(%ebp),%edx
    f3e6:	01 fa                	add    %edi,%edx
    f3e8:	50                   	push   %eax
    f3e9:	56                   	push   %esi
    f3ea:	53                   	push   %ebx
    f3eb:	51                   	push   %ecx
    f3ec:	52                   	push   %edx
    f3ed:	e8 c1 fd ff ff       	call   f1b3 <removePaddingBits>
    f3f2:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    f3f5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f3f9:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    f3fd:	0f 85 46 ff ff ff    	jne    f349 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    f403:	ff 75 ec             	pushl  -0x14(%ebp)
    f406:	ff 75 14             	pushl  0x14(%ebp)
    f409:	ff 75 10             	pushl  0x10(%ebp)
    f40c:	ff 75 0c             	pushl  0xc(%ebp)
    f40f:	ff 75 08             	pushl  0x8(%ebp)
    f412:	e8 2c fb ff ff       	call   ef43 <Adam7_deinterlace>
    f417:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    f41a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f41f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f422:	5b                   	pop    %ebx
    f423:	5e                   	pop    %esi
    f424:	5f                   	pop    %edi
    f425:	5d                   	pop    %ebp
    f426:	c3                   	ret    

0000f427 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    f427:	55                   	push   %ebp
    f428:	89 e5                	mov    %esp,%ebp
    f42a:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    f42d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    f434:	8b 45 10             	mov    0x10(%ebp),%eax
    f437:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    f43c:	f7 e2                	mul    %edx
    f43e:	89 d0                	mov    %edx,%eax
    f440:	d1 e8                	shr    %eax
    f442:	89 c2                	mov    %eax,%edx
    f444:	8b 45 08             	mov    0x8(%ebp),%eax
    f447:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    f44a:	8b 45 08             	mov    0x8(%ebp),%eax
    f44d:	8b 40 0c             	mov    0xc(%eax),%eax
    f450:	85 c0                	test   %eax,%eax
    f452:	74 0d                	je     f461 <readChunk_PLTE+0x3a>
    f454:	8b 45 08             	mov    0x8(%ebp),%eax
    f457:	8b 40 0c             	mov    0xc(%eax),%eax
    f45a:	3d 00 01 00 00       	cmp    $0x100,%eax
    f45f:	7e 0a                	jle    f46b <readChunk_PLTE+0x44>
    f461:	b8 26 00 00 00       	mov    $0x26,%eax
    f466:	e9 da 00 00 00       	jmp    f545 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    f46b:	83 ec 0c             	sub    $0xc,%esp
    f46e:	ff 75 08             	pushl  0x8(%ebp)
    f471:	e8 02 a7 ff ff       	call   9b78 <lodepng_color_mode_alloc_palette>
    f476:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    f479:	8b 45 08             	mov    0x8(%ebp),%eax
    f47c:	8b 40 08             	mov    0x8(%eax),%eax
    f47f:	85 c0                	test   %eax,%eax
    f481:	75 1e                	jne    f4a1 <readChunk_PLTE+0x7a>
    f483:	8b 45 08             	mov    0x8(%ebp),%eax
    f486:	8b 40 0c             	mov    0xc(%eax),%eax
    f489:	85 c0                	test   %eax,%eax
    f48b:	74 14                	je     f4a1 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    f48d:	8b 45 08             	mov    0x8(%ebp),%eax
    f490:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    f497:	b8 53 00 00 00       	mov    $0x53,%eax
    f49c:	e9 a4 00 00 00       	jmp    f545 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    f4a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f4a8:	e9 84 00 00 00       	jmp    f531 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    f4ad:	8b 45 08             	mov    0x8(%ebp),%eax
    f4b0:	8b 40 08             	mov    0x8(%eax),%eax
    f4b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f4b6:	c1 e2 02             	shl    $0x2,%edx
    f4b9:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    f4bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f4bf:	8d 50 01             	lea    0x1(%eax),%edx
    f4c2:	89 55 f4             	mov    %edx,-0xc(%ebp)
    f4c5:	8b 55 0c             	mov    0xc(%ebp),%edx
    f4c8:	01 d0                	add    %edx,%eax
    f4ca:	0f b6 00             	movzbl (%eax),%eax
    f4cd:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    f4cf:	8b 45 08             	mov    0x8(%ebp),%eax
    f4d2:	8b 40 08             	mov    0x8(%eax),%eax
    f4d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f4d8:	c1 e2 02             	shl    $0x2,%edx
    f4db:	83 c2 01             	add    $0x1,%edx
    f4de:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    f4e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f4e4:	8d 50 01             	lea    0x1(%eax),%edx
    f4e7:	89 55 f4             	mov    %edx,-0xc(%ebp)
    f4ea:	8b 55 0c             	mov    0xc(%ebp),%edx
    f4ed:	01 d0                	add    %edx,%eax
    f4ef:	0f b6 00             	movzbl (%eax),%eax
    f4f2:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    f4f4:	8b 45 08             	mov    0x8(%ebp),%eax
    f4f7:	8b 40 08             	mov    0x8(%eax),%eax
    f4fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f4fd:	c1 e2 02             	shl    $0x2,%edx
    f500:	83 c2 02             	add    $0x2,%edx
    f503:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    f506:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f509:	8d 50 01             	lea    0x1(%eax),%edx
    f50c:	89 55 f4             	mov    %edx,-0xc(%ebp)
    f50f:	8b 55 0c             	mov    0xc(%ebp),%edx
    f512:	01 d0                	add    %edx,%eax
    f514:	0f b6 00             	movzbl (%eax),%eax
    f517:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    f519:	8b 45 08             	mov    0x8(%ebp),%eax
    f51c:	8b 40 08             	mov    0x8(%eax),%eax
    f51f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f522:	c1 e2 02             	shl    $0x2,%edx
    f525:	83 c2 03             	add    $0x3,%edx
    f528:	01 d0                	add    %edx,%eax
    f52a:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    f52d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f531:	8b 45 08             	mov    0x8(%ebp),%eax
    f534:	8b 40 0c             	mov    0xc(%eax),%eax
    f537:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    f53a:	0f 85 6d ff ff ff    	jne    f4ad <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    f540:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f545:	c9                   	leave  
    f546:	c3                   	ret    

0000f547 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    f547:	55                   	push   %ebp
    f548:	89 e5                	mov    %esp,%ebp
    f54a:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    f54d:	8b 45 08             	mov    0x8(%ebp),%eax
    f550:	8b 00                	mov    (%eax),%eax
    f552:	83 f8 03             	cmp    $0x3,%eax
    f555:	75 4d                	jne    f5a4 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    f557:	8b 45 08             	mov    0x8(%ebp),%eax
    f55a:	8b 40 0c             	mov    0xc(%eax),%eax
    f55d:	3b 45 10             	cmp    0x10(%ebp),%eax
    f560:	7d 0a                	jge    f56c <readChunk_tRNS+0x25>
    f562:	b8 27 00 00 00       	mov    $0x27,%eax
    f567:	e9 3c 01 00 00       	jmp    f6a8 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    f56c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f573:	eb 22                	jmp    f597 <readChunk_tRNS+0x50>
    f575:	8b 45 08             	mov    0x8(%ebp),%eax
    f578:	8b 40 08             	mov    0x8(%eax),%eax
    f57b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    f57e:	c1 e2 02             	shl    $0x2,%edx
    f581:	83 c2 03             	add    $0x3,%edx
    f584:	01 c2                	add    %eax,%edx
    f586:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f589:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f58c:	01 c8                	add    %ecx,%eax
    f58e:	0f b6 00             	movzbl (%eax),%eax
    f591:	88 02                	mov    %al,(%edx)
    f593:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f597:	8b 45 10             	mov    0x10(%ebp),%eax
    f59a:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    f59d:	75 d6                	jne    f575 <readChunk_tRNS+0x2e>
    f59f:	e9 ff 00 00 00       	jmp    f6a3 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    f5a4:	8b 45 08             	mov    0x8(%ebp),%eax
    f5a7:	8b 00                	mov    (%eax),%eax
    f5a9:	85 c0                	test   %eax,%eax
    f5ab:	75 59                	jne    f606 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    f5ad:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    f5b1:	74 0a                	je     f5bd <readChunk_tRNS+0x76>
    f5b3:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f5b8:	e9 eb 00 00 00       	jmp    f6a8 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    f5bd:	8b 45 08             	mov    0x8(%ebp),%eax
    f5c0:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    f5c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5ca:	0f b6 00             	movzbl (%eax),%eax
    f5cd:	0f b6 c0             	movzbl %al,%eax
    f5d0:	c1 e0 08             	shl    $0x8,%eax
    f5d3:	89 c2                	mov    %eax,%edx
    f5d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5d8:	83 c0 01             	add    $0x1,%eax
    f5db:	0f b6 00             	movzbl (%eax),%eax
    f5de:	0f b6 c0             	movzbl %al,%eax
    f5e1:	01 c2                	add    %eax,%edx
    f5e3:	8b 45 08             	mov    0x8(%ebp),%eax
    f5e6:	89 50 1c             	mov    %edx,0x1c(%eax)
    f5e9:	8b 45 08             	mov    0x8(%ebp),%eax
    f5ec:	8b 50 1c             	mov    0x1c(%eax),%edx
    f5ef:	8b 45 08             	mov    0x8(%ebp),%eax
    f5f2:	89 50 18             	mov    %edx,0x18(%eax)
    f5f5:	8b 45 08             	mov    0x8(%ebp),%eax
    f5f8:	8b 50 18             	mov    0x18(%eax),%edx
    f5fb:	8b 45 08             	mov    0x8(%ebp),%eax
    f5fe:	89 50 14             	mov    %edx,0x14(%eax)
    f601:	e9 9d 00 00 00       	jmp    f6a3 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    f606:	8b 45 08             	mov    0x8(%ebp),%eax
    f609:	8b 00                	mov    (%eax),%eax
    f60b:	83 f8 02             	cmp    $0x2,%eax
    f60e:	0f 85 88 00 00 00    	jne    f69c <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    f614:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    f618:	74 0a                	je     f624 <readChunk_tRNS+0xdd>
    f61a:	b8 29 00 00 00       	mov    $0x29,%eax
    f61f:	e9 84 00 00 00       	jmp    f6a8 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    f624:	8b 45 08             	mov    0x8(%ebp),%eax
    f627:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    f62e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f631:	0f b6 00             	movzbl (%eax),%eax
    f634:	0f b6 c0             	movzbl %al,%eax
    f637:	c1 e0 08             	shl    $0x8,%eax
    f63a:	89 c2                	mov    %eax,%edx
    f63c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f63f:	83 c0 01             	add    $0x1,%eax
    f642:	0f b6 00             	movzbl (%eax),%eax
    f645:	0f b6 c0             	movzbl %al,%eax
    f648:	01 c2                	add    %eax,%edx
    f64a:	8b 45 08             	mov    0x8(%ebp),%eax
    f64d:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    f650:	8b 45 0c             	mov    0xc(%ebp),%eax
    f653:	83 c0 02             	add    $0x2,%eax
    f656:	0f b6 00             	movzbl (%eax),%eax
    f659:	0f b6 c0             	movzbl %al,%eax
    f65c:	c1 e0 08             	shl    $0x8,%eax
    f65f:	89 c2                	mov    %eax,%edx
    f661:	8b 45 0c             	mov    0xc(%ebp),%eax
    f664:	83 c0 03             	add    $0x3,%eax
    f667:	0f b6 00             	movzbl (%eax),%eax
    f66a:	0f b6 c0             	movzbl %al,%eax
    f66d:	01 c2                	add    %eax,%edx
    f66f:	8b 45 08             	mov    0x8(%ebp),%eax
    f672:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    f675:	8b 45 0c             	mov    0xc(%ebp),%eax
    f678:	83 c0 04             	add    $0x4,%eax
    f67b:	0f b6 00             	movzbl (%eax),%eax
    f67e:	0f b6 c0             	movzbl %al,%eax
    f681:	c1 e0 08             	shl    $0x8,%eax
    f684:	89 c2                	mov    %eax,%edx
    f686:	8b 45 0c             	mov    0xc(%ebp),%eax
    f689:	83 c0 05             	add    $0x5,%eax
    f68c:	0f b6 00             	movzbl (%eax),%eax
    f68f:	0f b6 c0             	movzbl %al,%eax
    f692:	01 c2                	add    %eax,%edx
    f694:	8b 45 08             	mov    0x8(%ebp),%eax
    f697:	89 50 1c             	mov    %edx,0x1c(%eax)
    f69a:	eb 07                	jmp    f6a3 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    f69c:	b8 2a 00 00 00       	mov    $0x2a,%eax
    f6a1:	eb 05                	jmp    f6a8 <readChunk_tRNS+0x161>

  return 0; /* OK */
    f6a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f6a8:	c9                   	leave  
    f6a9:	c3                   	ret    

0000f6aa <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f6aa:	55                   	push   %ebp
    f6ab:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    f6ad:	8b 45 08             	mov    0x8(%ebp),%eax
    f6b0:	8b 40 0c             	mov    0xc(%eax),%eax
    f6b3:	83 f8 03             	cmp    $0x3,%eax
    f6b6:	75 63                	jne    f71b <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    f6b8:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f6bc:	74 0a                	je     f6c8 <readChunk_bKGD+0x1e>
    f6be:	b8 2b 00 00 00       	mov    $0x2b,%eax
    f6c3:	e9 63 01 00 00       	jmp    f82b <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    f6c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6cb:	0f b6 00             	movzbl (%eax),%eax
    f6ce:	0f b6 d0             	movzbl %al,%edx
    f6d1:	8b 45 08             	mov    0x8(%ebp),%eax
    f6d4:	8b 40 18             	mov    0x18(%eax),%eax
    f6d7:	39 c2                	cmp    %eax,%edx
    f6d9:	7c 0a                	jl     f6e5 <readChunk_bKGD+0x3b>
    f6db:	b8 67 00 00 00       	mov    $0x67,%eax
    f6e0:	e9 46 01 00 00       	jmp    f82b <readChunk_bKGD+0x181>

    info->background_defined = 1;
    f6e5:	8b 45 08             	mov    0x8(%ebp),%eax
    f6e8:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    f6ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6f2:	0f b6 00             	movzbl (%eax),%eax
    f6f5:	0f b6 d0             	movzbl %al,%edx
    f6f8:	8b 45 08             	mov    0x8(%ebp),%eax
    f6fb:	89 50 38             	mov    %edx,0x38(%eax)
    f6fe:	8b 45 08             	mov    0x8(%ebp),%eax
    f701:	8b 50 38             	mov    0x38(%eax),%edx
    f704:	8b 45 08             	mov    0x8(%ebp),%eax
    f707:	89 50 34             	mov    %edx,0x34(%eax)
    f70a:	8b 45 08             	mov    0x8(%ebp),%eax
    f70d:	8b 50 34             	mov    0x34(%eax),%edx
    f710:	8b 45 08             	mov    0x8(%ebp),%eax
    f713:	89 50 30             	mov    %edx,0x30(%eax)
    f716:	e9 0b 01 00 00       	jmp    f826 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    f71b:	8b 45 08             	mov    0x8(%ebp),%eax
    f71e:	8b 40 0c             	mov    0xc(%eax),%eax
    f721:	85 c0                	test   %eax,%eax
    f723:	74 0b                	je     f730 <readChunk_bKGD+0x86>
    f725:	8b 45 08             	mov    0x8(%ebp),%eax
    f728:	8b 40 0c             	mov    0xc(%eax),%eax
    f72b:	83 f8 04             	cmp    $0x4,%eax
    f72e:	75 59                	jne    f789 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    f730:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    f734:	74 0a                	je     f740 <readChunk_bKGD+0x96>
    f736:	b8 2c 00 00 00       	mov    $0x2c,%eax
    f73b:	e9 eb 00 00 00       	jmp    f82b <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    f740:	8b 45 08             	mov    0x8(%ebp),%eax
    f743:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    f74a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f74d:	0f b6 00             	movzbl (%eax),%eax
    f750:	0f b6 c0             	movzbl %al,%eax
    f753:	c1 e0 08             	shl    $0x8,%eax
    f756:	89 c2                	mov    %eax,%edx
    f758:	8b 45 0c             	mov    0xc(%ebp),%eax
    f75b:	83 c0 01             	add    $0x1,%eax
    f75e:	0f b6 00             	movzbl (%eax),%eax
    f761:	0f b6 c0             	movzbl %al,%eax
    f764:	01 c2                	add    %eax,%edx
    f766:	8b 45 08             	mov    0x8(%ebp),%eax
    f769:	89 50 38             	mov    %edx,0x38(%eax)
    f76c:	8b 45 08             	mov    0x8(%ebp),%eax
    f76f:	8b 50 38             	mov    0x38(%eax),%edx
    f772:	8b 45 08             	mov    0x8(%ebp),%eax
    f775:	89 50 34             	mov    %edx,0x34(%eax)
    f778:	8b 45 08             	mov    0x8(%ebp),%eax
    f77b:	8b 50 34             	mov    0x34(%eax),%edx
    f77e:	8b 45 08             	mov    0x8(%ebp),%eax
    f781:	89 50 30             	mov    %edx,0x30(%eax)
    f784:	e9 9d 00 00 00       	jmp    f826 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    f789:	8b 45 08             	mov    0x8(%ebp),%eax
    f78c:	8b 40 0c             	mov    0xc(%eax),%eax
    f78f:	83 f8 02             	cmp    $0x2,%eax
    f792:	74 0f                	je     f7a3 <readChunk_bKGD+0xf9>
    f794:	8b 45 08             	mov    0x8(%ebp),%eax
    f797:	8b 40 0c             	mov    0xc(%eax),%eax
    f79a:	83 f8 06             	cmp    $0x6,%eax
    f79d:	0f 85 83 00 00 00    	jne    f826 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    f7a3:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    f7a7:	74 07                	je     f7b0 <readChunk_bKGD+0x106>
    f7a9:	b8 2d 00 00 00       	mov    $0x2d,%eax
    f7ae:	eb 7b                	jmp    f82b <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    f7b0:	8b 45 08             	mov    0x8(%ebp),%eax
    f7b3:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    f7ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7bd:	0f b6 00             	movzbl (%eax),%eax
    f7c0:	0f b6 c0             	movzbl %al,%eax
    f7c3:	c1 e0 08             	shl    $0x8,%eax
    f7c6:	89 c2                	mov    %eax,%edx
    f7c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7cb:	83 c0 01             	add    $0x1,%eax
    f7ce:	0f b6 00             	movzbl (%eax),%eax
    f7d1:	0f b6 c0             	movzbl %al,%eax
    f7d4:	01 c2                	add    %eax,%edx
    f7d6:	8b 45 08             	mov    0x8(%ebp),%eax
    f7d9:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    f7dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7df:	83 c0 02             	add    $0x2,%eax
    f7e2:	0f b6 00             	movzbl (%eax),%eax
    f7e5:	0f b6 c0             	movzbl %al,%eax
    f7e8:	c1 e0 08             	shl    $0x8,%eax
    f7eb:	89 c2                	mov    %eax,%edx
    f7ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7f0:	83 c0 03             	add    $0x3,%eax
    f7f3:	0f b6 00             	movzbl (%eax),%eax
    f7f6:	0f b6 c0             	movzbl %al,%eax
    f7f9:	01 c2                	add    %eax,%edx
    f7fb:	8b 45 08             	mov    0x8(%ebp),%eax
    f7fe:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    f801:	8b 45 0c             	mov    0xc(%ebp),%eax
    f804:	83 c0 04             	add    $0x4,%eax
    f807:	0f b6 00             	movzbl (%eax),%eax
    f80a:	0f b6 c0             	movzbl %al,%eax
    f80d:	c1 e0 08             	shl    $0x8,%eax
    f810:	89 c2                	mov    %eax,%edx
    f812:	8b 45 0c             	mov    0xc(%ebp),%eax
    f815:	83 c0 05             	add    $0x5,%eax
    f818:	0f b6 00             	movzbl (%eax),%eax
    f81b:	0f b6 c0             	movzbl %al,%eax
    f81e:	01 c2                	add    %eax,%edx
    f820:	8b 45 08             	mov    0x8(%ebp),%eax
    f823:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    f826:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f82b:	5d                   	pop    %ebp
    f82c:	c3                   	ret    

0000f82d <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f82d:	55                   	push   %ebp
    f82e:	89 e5                	mov    %esp,%ebp
    f830:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    f833:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    f83a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f841:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    f848:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f84c:	0f 85 06 01 00 00    	jne    f958 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    f852:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    f859:	eb 04                	jmp    f85f <readChunk_tEXt+0x32>
    f85b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    f85f:	8b 45 10             	mov    0x10(%ebp),%eax
    f862:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f865:	73 0f                	jae    f876 <readChunk_tEXt+0x49>
    f867:	8b 55 0c             	mov    0xc(%ebp),%edx
    f86a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f86d:	01 d0                	add    %edx,%eax
    f86f:	0f b6 00             	movzbl (%eax),%eax
    f872:	84 c0                	test   %al,%al
    f874:	75 e5                	jne    f85b <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    f876:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    f87a:	74 06                	je     f882 <readChunk_tEXt+0x55>
    f87c:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    f880:	76 0c                	jbe    f88e <readChunk_tEXt+0x61>
    f882:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    f889:	e9 ca 00 00 00       	jmp    f958 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    f88e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f891:	83 c0 01             	add    $0x1,%eax
    f894:	83 ec 0c             	sub    $0xc,%esp
    f897:	50                   	push   %eax
    f898:	e8 73 4b ff ff       	call   4410 <lodepng_malloc>
    f89d:	83 c4 10             	add    $0x10,%esp
    f8a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    f8a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f8a7:	75 0c                	jne    f8b5 <readChunk_tEXt+0x88>
    f8a9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f8b0:	e9 a3 00 00 00       	jmp    f958 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    f8b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8b8:	83 ec 04             	sub    $0x4,%esp
    f8bb:	50                   	push   %eax
    f8bc:	ff 75 0c             	pushl  0xc(%ebp)
    f8bf:	ff 75 f0             	pushl  -0x10(%ebp)
    f8c2:	e8 87 4b ff ff       	call   444e <lodepng_memcpy>
    f8c7:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    f8ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8d0:	01 d0                	add    %edx,%eax
    f8d2:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    f8d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8d8:	83 c0 01             	add    $0x1,%eax
    f8db:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    f8de:	8b 45 10             	mov    0x10(%ebp),%eax
    f8e1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    f8e4:	72 08                	jb     f8ee <readChunk_tEXt+0xc1>
    f8e6:	8b 45 10             	mov    0x10(%ebp),%eax
    f8e9:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    f8ec:	eb 05                	jmp    f8f3 <readChunk_tEXt+0xc6>
    f8ee:	b8 00 00 00 00       	mov    $0x0,%eax
    f8f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    f8f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8f9:	83 c0 01             	add    $0x1,%eax
    f8fc:	83 ec 0c             	sub    $0xc,%esp
    f8ff:	50                   	push   %eax
    f900:	e8 0b 4b ff ff       	call   4410 <lodepng_malloc>
    f905:	83 c4 10             	add    $0x10,%esp
    f908:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    f90b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f90f:	75 09                	jne    f91a <readChunk_tEXt+0xed>
    f911:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f918:	eb 3e                	jmp    f958 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    f91a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f91d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f920:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f923:	01 ca                	add    %ecx,%edx
    f925:	83 ec 04             	sub    $0x4,%esp
    f928:	50                   	push   %eax
    f929:	52                   	push   %edx
    f92a:	ff 75 ec             	pushl  -0x14(%ebp)
    f92d:	e8 1c 4b ff ff       	call   444e <lodepng_memcpy>
    f932:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    f935:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f938:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f93b:	01 d0                	add    %edx,%eax
    f93d:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    f940:	83 ec 04             	sub    $0x4,%esp
    f943:	ff 75 ec             	pushl  -0x14(%ebp)
    f946:	ff 75 f0             	pushl  -0x10(%ebp)
    f949:	ff 75 08             	pushl  0x8(%ebp)
    f94c:	e8 3f ac ff ff       	call   a590 <lodepng_add_text>
    f951:	83 c4 10             	add    $0x10,%esp
    f954:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    f957:	90                   	nop
  }

  lodepng_free(key);
    f958:	83 ec 0c             	sub    $0xc,%esp
    f95b:	ff 75 f0             	pushl  -0x10(%ebp)
    f95e:	e8 ce 4a ff ff       	call   4431 <lodepng_free>
    f963:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    f966:	83 ec 0c             	sub    $0xc,%esp
    f969:	ff 75 ec             	pushl  -0x14(%ebp)
    f96c:	e8 c0 4a ff ff       	call   4431 <lodepng_free>
    f971:	83 c4 10             	add    $0x10,%esp

  return error;
    f974:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f977:	c9                   	leave  
    f978:	c3                   	ret    

0000f979 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f979:	55                   	push   %ebp
    f97a:	89 e5                	mov    %esp,%ebp
    f97c:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    f97f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f986:	8b 45 0c             	mov    0xc(%ebp),%eax
    f989:	8b 10                	mov    (%eax),%edx
    f98b:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f98e:	8b 50 04             	mov    0x4(%eax),%edx
    f991:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f994:	8b 50 08             	mov    0x8(%eax),%edx
    f997:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f99a:	8b 50 0c             	mov    0xc(%eax),%edx
    f99d:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f9a0:	8b 50 10             	mov    0x10(%eax),%edx
    f9a3:	89 55 e0             	mov    %edx,-0x20(%ebp)
    f9a6:	8b 40 14             	mov    0x14(%eax),%eax
    f9a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    f9ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    f9b3:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    f9ba:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    f9c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f9c5:	0f 85 48 01 00 00    	jne    fb13 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f9cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f9d2:	eb 04                	jmp    f9d8 <readChunk_zTXt+0x5f>
    f9d4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f9d8:	8b 45 14             	mov    0x14(%ebp),%eax
    f9db:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f9de:	73 0f                	jae    f9ef <readChunk_zTXt+0x76>
    f9e0:	8b 55 10             	mov    0x10(%ebp),%edx
    f9e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f9e6:	01 d0                	add    %edx,%eax
    f9e8:	0f b6 00             	movzbl (%eax),%eax
    f9eb:	84 c0                	test   %al,%al
    f9ed:	75 e5                	jne    f9d4 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    f9ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f9f2:	8d 50 02             	lea    0x2(%eax),%edx
    f9f5:	8b 45 14             	mov    0x14(%ebp),%eax
    f9f8:	39 c2                	cmp    %eax,%edx
    f9fa:	72 0c                	jb     fa08 <readChunk_zTXt+0x8f>
    f9fc:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    fa03:	e9 0b 01 00 00       	jmp    fb13 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    fa08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fa0c:	74 06                	je     fa14 <readChunk_zTXt+0x9b>
    fa0e:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    fa12:	76 0c                	jbe    fa20 <readChunk_zTXt+0xa7>
    fa14:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    fa1b:	e9 f3 00 00 00       	jmp    fb13 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    fa20:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa23:	83 c0 01             	add    $0x1,%eax
    fa26:	83 ec 0c             	sub    $0xc,%esp
    fa29:	50                   	push   %eax
    fa2a:	e8 e1 49 ff ff       	call   4410 <lodepng_malloc>
    fa2f:	83 c4 10             	add    $0x10,%esp
    fa32:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    fa35:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    fa39:	75 0c                	jne    fa47 <readChunk_zTXt+0xce>
    fa3b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    fa42:	e9 cc 00 00 00       	jmp    fb13 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    fa47:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa4a:	83 ec 04             	sub    $0x4,%esp
    fa4d:	50                   	push   %eax
    fa4e:	ff 75 10             	pushl  0x10(%ebp)
    fa51:	ff 75 ec             	pushl  -0x14(%ebp)
    fa54:	e8 f5 49 ff ff       	call   444e <lodepng_memcpy>
    fa59:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    fa5c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fa5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa62:	01 d0                	add    %edx,%eax
    fa64:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    fa67:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa6a:	8d 50 01             	lea    0x1(%eax),%edx
    fa6d:	8b 45 10             	mov    0x10(%ebp),%eax
    fa70:	01 d0                	add    %edx,%eax
    fa72:	0f b6 00             	movzbl (%eax),%eax
    fa75:	84 c0                	test   %al,%al
    fa77:	74 0c                	je     fa85 <readChunk_zTXt+0x10c>
    fa79:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    fa80:	e9 8e 00 00 00       	jmp    fb13 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    fa85:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa88:	83 c0 02             	add    $0x2,%eax
    fa8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    fa8e:	8b 45 14             	mov    0x14(%ebp),%eax
    fa91:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    fa94:	76 09                	jbe    fa9f <readChunk_zTXt+0x126>
    fa96:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    fa9d:	eb 74                	jmp    fb13 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    fa9f:	8b 45 14             	mov    0x14(%ebp),%eax
    faa2:	2b 45 e8             	sub    -0x18(%ebp),%eax
    faa5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    faa8:	8b 45 0c             	mov    0xc(%ebp),%eax
    faab:	8b 40 30             	mov    0x30(%eax),%eax
    faae:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    fab1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fab4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fab7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    faba:	01 d1                	add    %edx,%ecx
    fabc:	83 ec 08             	sub    $0x8,%esp
    fabf:	8d 55 d0             	lea    -0x30(%ebp),%edx
    fac2:	52                   	push   %edx
    fac3:	50                   	push   %eax
    fac4:	51                   	push   %ecx
    fac5:	6a 00                	push   $0x0
    fac7:	8d 45 c8             	lea    -0x38(%ebp),%eax
    faca:	50                   	push   %eax
    facb:	8d 45 cc             	lea    -0x34(%ebp),%eax
    face:	50                   	push   %eax
    facf:	e8 f7 93 ff ff       	call   8ecb <zlib_decompress>
    fad4:	83 c4 20             	add    $0x20,%esp
    fad7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    fada:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fade:	74 11                	je     faf1 <readChunk_zTXt+0x178>
    fae0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fae3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    fae6:	39 c2                	cmp    %eax,%edx
    fae8:	7d 07                	jge    faf1 <readChunk_zTXt+0x178>
    faea:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    faf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    faf5:	75 1b                	jne    fb12 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    faf7:	8b 55 c8             	mov    -0x38(%ebp),%edx
    fafa:	8b 45 cc             	mov    -0x34(%ebp),%eax
    fafd:	52                   	push   %edx
    fafe:	50                   	push   %eax
    faff:	ff 75 ec             	pushl  -0x14(%ebp)
    fb02:	ff 75 08             	pushl  0x8(%ebp)
    fb05:	e8 60 a9 ff ff       	call   a46a <lodepng_add_text_sized>
    fb0a:	83 c4 10             	add    $0x10,%esp
    fb0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    fb10:	eb 01                	jmp    fb13 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    fb12:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    fb13:	83 ec 0c             	sub    $0xc,%esp
    fb16:	ff 75 ec             	pushl  -0x14(%ebp)
    fb19:	e8 13 49 ff ff       	call   4431 <lodepng_free>
    fb1e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    fb21:	8b 45 cc             	mov    -0x34(%ebp),%eax
    fb24:	83 ec 0c             	sub    $0xc,%esp
    fb27:	50                   	push   %eax
    fb28:	e8 04 49 ff ff       	call   4431 <lodepng_free>
    fb2d:	83 c4 10             	add    $0x10,%esp

  return error;
    fb30:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    fb33:	c9                   	leave  
    fb34:	c3                   	ret    

0000fb35 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    fb35:	55                   	push   %ebp
    fb36:	89 e5                	mov    %esp,%ebp
    fb38:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    fb3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    fb42:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb45:	8b 10                	mov    (%eax),%edx
    fb47:	89 55 c0             	mov    %edx,-0x40(%ebp)
    fb4a:	8b 50 04             	mov    0x4(%eax),%edx
    fb4d:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    fb50:	8b 50 08             	mov    0x8(%eax),%edx
    fb53:	89 55 c8             	mov    %edx,-0x38(%ebp)
    fb56:	8b 50 0c             	mov    0xc(%eax),%edx
    fb59:	89 55 cc             	mov    %edx,-0x34(%ebp)
    fb5c:	8b 50 10             	mov    0x10(%eax),%edx
    fb5f:	89 55 d0             	mov    %edx,-0x30(%ebp)
    fb62:	8b 40 14             	mov    0x14(%eax),%eax
    fb65:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    fb68:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    fb6f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    fb76:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    fb7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fb81:	0f 85 d5 02 00 00    	jne    fe5c <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    fb87:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    fb8b:	7f 0c                	jg     fb99 <readChunk_iTXt+0x64>
    fb8d:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    fb94:	e9 c3 02 00 00       	jmp    fe5c <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    fb99:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    fba0:	eb 04                	jmp    fba6 <readChunk_iTXt+0x71>
    fba2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    fba6:	8b 45 14             	mov    0x14(%ebp),%eax
    fba9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    fbac:	73 0f                	jae    fbbd <readChunk_iTXt+0x88>
    fbae:	8b 55 10             	mov    0x10(%ebp),%edx
    fbb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fbb4:	01 d0                	add    %edx,%eax
    fbb6:	0f b6 00             	movzbl (%eax),%eax
    fbb9:	84 c0                	test   %al,%al
    fbbb:	75 e5                	jne    fba2 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    fbbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fbc0:	8d 50 03             	lea    0x3(%eax),%edx
    fbc3:	8b 45 14             	mov    0x14(%ebp),%eax
    fbc6:	39 c2                	cmp    %eax,%edx
    fbc8:	72 0c                	jb     fbd6 <readChunk_iTXt+0xa1>
    fbca:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    fbd1:	e9 86 02 00 00       	jmp    fe5c <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    fbd6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    fbda:	74 06                	je     fbe2 <readChunk_iTXt+0xad>
    fbdc:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    fbe0:	76 0c                	jbe    fbee <readChunk_iTXt+0xb9>
    fbe2:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    fbe9:	e9 6e 02 00 00       	jmp    fe5c <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    fbee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fbf1:	83 c0 01             	add    $0x1,%eax
    fbf4:	83 ec 0c             	sub    $0xc,%esp
    fbf7:	50                   	push   %eax
    fbf8:	e8 13 48 ff ff       	call   4410 <lodepng_malloc>
    fbfd:	83 c4 10             	add    $0x10,%esp
    fc00:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    fc03:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    fc07:	75 0c                	jne    fc15 <readChunk_iTXt+0xe0>
    fc09:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    fc10:	e9 47 02 00 00       	jmp    fe5c <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    fc15:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fc18:	83 ec 04             	sub    $0x4,%esp
    fc1b:	50                   	push   %eax
    fc1c:	ff 75 10             	pushl  0x10(%ebp)
    fc1f:	ff 75 e8             	pushl  -0x18(%ebp)
    fc22:	e8 27 48 ff ff       	call   444e <lodepng_memcpy>
    fc27:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    fc2a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fc2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fc30:	01 d0                	add    %edx,%eax
    fc32:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    fc35:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fc38:	8d 50 01             	lea    0x1(%eax),%edx
    fc3b:	8b 45 10             	mov    0x10(%ebp),%eax
    fc3e:	01 d0                	add    %edx,%eax
    fc40:	0f b6 00             	movzbl (%eax),%eax
    fc43:	0f b6 c0             	movzbl %al,%eax
    fc46:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    fc49:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fc4c:	8d 50 02             	lea    0x2(%eax),%edx
    fc4f:	8b 45 10             	mov    0x10(%ebp),%eax
    fc52:	01 d0                	add    %edx,%eax
    fc54:	0f b6 00             	movzbl (%eax),%eax
    fc57:	84 c0                	test   %al,%al
    fc59:	74 0c                	je     fc67 <readChunk_iTXt+0x132>
    fc5b:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    fc62:	e9 f5 01 00 00       	jmp    fe5c <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    fc67:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fc6a:	83 c0 03             	add    $0x3,%eax
    fc6d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    fc70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    fc77:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fc7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fc7d:	eb 08                	jmp    fc87 <readChunk_iTXt+0x152>
    fc7f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    fc83:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    fc87:	8b 45 14             	mov    0x14(%ebp),%eax
    fc8a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    fc8d:	73 0f                	jae    fc9e <readChunk_iTXt+0x169>
    fc8f:	8b 55 10             	mov    0x10(%ebp),%edx
    fc92:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fc95:	01 d0                	add    %edx,%eax
    fc97:	0f b6 00             	movzbl (%eax),%eax
    fc9a:	84 c0                	test   %al,%al
    fc9c:	75 e1                	jne    fc7f <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    fc9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fca1:	83 c0 01             	add    $0x1,%eax
    fca4:	83 ec 0c             	sub    $0xc,%esp
    fca7:	50                   	push   %eax
    fca8:	e8 63 47 ff ff       	call   4410 <lodepng_malloc>
    fcad:	83 c4 10             	add    $0x10,%esp
    fcb0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    fcb3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    fcb7:	75 0c                	jne    fcc5 <readChunk_iTXt+0x190>
    fcb9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    fcc0:	e9 97 01 00 00       	jmp    fe5c <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    fcc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fcc8:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fccb:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fcce:	01 ca                	add    %ecx,%edx
    fcd0:	83 ec 04             	sub    $0x4,%esp
    fcd3:	50                   	push   %eax
    fcd4:	52                   	push   %edx
    fcd5:	ff 75 e4             	pushl  -0x1c(%ebp)
    fcd8:	e8 71 47 ff ff       	call   444e <lodepng_memcpy>
    fcdd:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    fce0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fce3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fce6:	01 d0                	add    %edx,%eax
    fce8:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    fceb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fcee:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fcf1:	01 d0                	add    %edx,%eax
    fcf3:	83 c0 01             	add    $0x1,%eax
    fcf6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    fcf9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    fd00:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fd03:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fd06:	eb 08                	jmp    fd10 <readChunk_iTXt+0x1db>
    fd08:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    fd0c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    fd10:	8b 45 14             	mov    0x14(%ebp),%eax
    fd13:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    fd16:	73 0f                	jae    fd27 <readChunk_iTXt+0x1f2>
    fd18:	8b 55 10             	mov    0x10(%ebp),%edx
    fd1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fd1e:	01 d0                	add    %edx,%eax
    fd20:	0f b6 00             	movzbl (%eax),%eax
    fd23:	84 c0                	test   %al,%al
    fd25:	75 e1                	jne    fd08 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    fd27:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fd2a:	83 c0 01             	add    $0x1,%eax
    fd2d:	83 ec 0c             	sub    $0xc,%esp
    fd30:	50                   	push   %eax
    fd31:	e8 da 46 ff ff       	call   4410 <lodepng_malloc>
    fd36:	83 c4 10             	add    $0x10,%esp
    fd39:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    fd3c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    fd40:	75 0c                	jne    fd4e <readChunk_iTXt+0x219>
    fd42:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    fd49:	e9 0e 01 00 00       	jmp    fe5c <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    fd4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fd51:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fd54:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fd57:	01 ca                	add    %ecx,%edx
    fd59:	83 ec 04             	sub    $0x4,%esp
    fd5c:	50                   	push   %eax
    fd5d:	52                   	push   %edx
    fd5e:	ff 75 e0             	pushl  -0x20(%ebp)
    fd61:	e8 e8 46 ff ff       	call   444e <lodepng_memcpy>
    fd66:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    fd69:	8b 55 e0             	mov    -0x20(%ebp),%edx
    fd6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fd6f:	01 d0                	add    %edx,%eax
    fd71:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    fd74:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fd77:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fd7a:	01 d0                	add    %edx,%eax
    fd7c:	83 c0 01             	add    $0x1,%eax
    fd7f:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    fd82:	8b 45 14             	mov    0x14(%ebp),%eax
    fd85:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    fd88:	72 08                	jb     fd92 <readChunk_iTXt+0x25d>
    fd8a:	8b 45 14             	mov    0x14(%ebp),%eax
    fd8d:	2b 45 d8             	sub    -0x28(%ebp),%eax
    fd90:	eb 05                	jmp    fd97 <readChunk_iTXt+0x262>
    fd92:	b8 00 00 00 00       	mov    $0x0,%eax
    fd97:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    fd9a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    fd9e:	0f 84 90 00 00 00    	je     fe34 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    fda4:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    fdab:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    fdb2:	8b 45 0c             	mov    0xc(%ebp),%eax
    fdb5:	8b 40 30             	mov    0x30(%eax),%eax
    fdb8:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    fdbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fdbe:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fdc1:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fdc4:	01 d1                	add    %edx,%ecx
    fdc6:	83 ec 08             	sub    $0x8,%esp
    fdc9:	8d 55 c0             	lea    -0x40(%ebp),%edx
    fdcc:	52                   	push   %edx
    fdcd:	50                   	push   %eax
    fdce:	51                   	push   %ecx
    fdcf:	6a 00                	push   $0x0
    fdd1:	8d 45 b8             	lea    -0x48(%ebp),%eax
    fdd4:	50                   	push   %eax
    fdd5:	8d 45 bc             	lea    -0x44(%ebp),%eax
    fdd8:	50                   	push   %eax
    fdd9:	e8 ed 90 ff ff       	call   8ecb <zlib_decompress>
    fdde:	83 c4 20             	add    $0x20,%esp
    fde1:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    fde4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fde8:	74 11                	je     fdfb <readChunk_iTXt+0x2c6>
    fdea:	8b 55 c8             	mov    -0x38(%ebp),%edx
    fded:	8b 45 b8             	mov    -0x48(%ebp),%eax
    fdf0:	39 c2                	cmp    %eax,%edx
    fdf2:	7d 07                	jge    fdfb <readChunk_iTXt+0x2c6>
    fdf4:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    fdfb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fdff:	75 22                	jne    fe23 <readChunk_iTXt+0x2ee>
    fe01:	8b 55 b8             	mov    -0x48(%ebp),%edx
    fe04:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fe07:	83 ec 08             	sub    $0x8,%esp
    fe0a:	52                   	push   %edx
    fe0b:	50                   	push   %eax
    fe0c:	ff 75 e0             	pushl  -0x20(%ebp)
    fe0f:	ff 75 e4             	pushl  -0x1c(%ebp)
    fe12:	ff 75 e8             	pushl  -0x18(%ebp)
    fe15:	ff 75 08             	pushl  0x8(%ebp)
    fe18:	e8 94 a9 ff ff       	call   a7b1 <lodepng_add_itext_sized>
    fe1d:	83 c4 20             	add    $0x20,%esp
    fe20:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    fe23:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fe26:	83 ec 0c             	sub    $0xc,%esp
    fe29:	50                   	push   %eax
    fe2a:	e8 02 46 ff ff       	call   4431 <lodepng_free>
    fe2f:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    fe32:	eb 27                	jmp    fe5b <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    fe34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fe37:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fe3a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fe3d:	01 ca                	add    %ecx,%edx
    fe3f:	83 ec 08             	sub    $0x8,%esp
    fe42:	50                   	push   %eax
    fe43:	52                   	push   %edx
    fe44:	ff 75 e0             	pushl  -0x20(%ebp)
    fe47:	ff 75 e4             	pushl  -0x1c(%ebp)
    fe4a:	ff 75 e8             	pushl  -0x18(%ebp)
    fe4d:	ff 75 08             	pushl  0x8(%ebp)
    fe50:	e8 5c a9 ff ff       	call   a7b1 <lodepng_add_itext_sized>
    fe55:	83 c4 20             	add    $0x20,%esp
    fe58:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    fe5b:	90                   	nop
  }

  lodepng_free(key);
    fe5c:	83 ec 0c             	sub    $0xc,%esp
    fe5f:	ff 75 e8             	pushl  -0x18(%ebp)
    fe62:	e8 ca 45 ff ff       	call   4431 <lodepng_free>
    fe67:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    fe6a:	83 ec 0c             	sub    $0xc,%esp
    fe6d:	ff 75 e4             	pushl  -0x1c(%ebp)
    fe70:	e8 bc 45 ff ff       	call   4431 <lodepng_free>
    fe75:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    fe78:	83 ec 0c             	sub    $0xc,%esp
    fe7b:	ff 75 e0             	pushl  -0x20(%ebp)
    fe7e:	e8 ae 45 ff ff       	call   4431 <lodepng_free>
    fe83:	83 c4 10             	add    $0x10,%esp

  return error;
    fe86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    fe89:	c9                   	leave  
    fe8a:	c3                   	ret    

0000fe8b <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    fe8b:	55                   	push   %ebp
    fe8c:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    fe8e:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    fe92:	74 0a                	je     fe9e <readChunk_tIME+0x13>
    fe94:	b8 49 00 00 00       	mov    $0x49,%eax
    fe99:	e9 8b 00 00 00       	jmp    ff29 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    fe9e:	8b 45 08             	mov    0x8(%ebp),%eax
    fea1:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    fea8:	8b 45 0c             	mov    0xc(%ebp),%eax
    feab:	0f b6 00             	movzbl (%eax),%eax
    feae:	0f b6 c0             	movzbl %al,%eax
    feb1:	c1 e0 08             	shl    $0x8,%eax
    feb4:	89 c2                	mov    %eax,%edx
    feb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    feb9:	83 c0 01             	add    $0x1,%eax
    febc:	0f b6 00             	movzbl (%eax),%eax
    febf:	0f b6 c0             	movzbl %al,%eax
    fec2:	01 c2                	add    %eax,%edx
    fec4:	8b 45 08             	mov    0x8(%ebp),%eax
    fec7:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    feca:	8b 45 0c             	mov    0xc(%ebp),%eax
    fecd:	83 c0 02             	add    $0x2,%eax
    fed0:	0f b6 00             	movzbl (%eax),%eax
    fed3:	0f b6 d0             	movzbl %al,%edx
    fed6:	8b 45 08             	mov    0x8(%ebp),%eax
    fed9:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    fedc:	8b 45 0c             	mov    0xc(%ebp),%eax
    fedf:	83 c0 03             	add    $0x3,%eax
    fee2:	0f b6 00             	movzbl (%eax),%eax
    fee5:	0f b6 d0             	movzbl %al,%edx
    fee8:	8b 45 08             	mov    0x8(%ebp),%eax
    feeb:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    feee:	8b 45 0c             	mov    0xc(%ebp),%eax
    fef1:	83 c0 04             	add    $0x4,%eax
    fef4:	0f b6 00             	movzbl (%eax),%eax
    fef7:	0f b6 d0             	movzbl %al,%edx
    fefa:	8b 45 08             	mov    0x8(%ebp),%eax
    fefd:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    ff00:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff03:	83 c0 05             	add    $0x5,%eax
    ff06:	0f b6 00             	movzbl (%eax),%eax
    ff09:	0f b6 d0             	movzbl %al,%edx
    ff0c:	8b 45 08             	mov    0x8(%ebp),%eax
    ff0f:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    ff12:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff15:	83 c0 06             	add    $0x6,%eax
    ff18:	0f b6 00             	movzbl (%eax),%eax
    ff1b:	0f b6 d0             	movzbl %al,%edx
    ff1e:	8b 45 08             	mov    0x8(%ebp),%eax
    ff21:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    ff24:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ff29:	5d                   	pop    %ebp
    ff2a:	c3                   	ret    

0000ff2b <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ff2b:	55                   	push   %ebp
    ff2c:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    ff2e:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    ff32:	74 0a                	je     ff3e <readChunk_pHYs+0x13>
    ff34:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ff39:	e9 ba 00 00 00       	jmp    fff8 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ff3e:	8b 45 08             	mov    0x8(%ebp),%eax
    ff41:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ff48:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff4b:	0f b6 00             	movzbl (%eax),%eax
    ff4e:	0f b6 c0             	movzbl %al,%eax
    ff51:	c1 e0 08             	shl    $0x8,%eax
    ff54:	89 c2                	mov    %eax,%edx
    ff56:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff59:	83 c0 01             	add    $0x1,%eax
    ff5c:	0f b6 00             	movzbl (%eax),%eax
    ff5f:	0f b6 c0             	movzbl %al,%eax
    ff62:	01 d0                	add    %edx,%eax
    ff64:	c1 e0 08             	shl    $0x8,%eax
    ff67:	89 c2                	mov    %eax,%edx
    ff69:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff6c:	83 c0 02             	add    $0x2,%eax
    ff6f:	0f b6 00             	movzbl (%eax),%eax
    ff72:	0f b6 c0             	movzbl %al,%eax
    ff75:	01 d0                	add    %edx,%eax
    ff77:	c1 e0 08             	shl    $0x8,%eax
    ff7a:	89 c2                	mov    %eax,%edx
    ff7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff7f:	83 c0 03             	add    $0x3,%eax
    ff82:	0f b6 00             	movzbl (%eax),%eax
    ff85:	0f b6 c0             	movzbl %al,%eax
    ff88:	01 c2                	add    %eax,%edx
    ff8a:	8b 45 08             	mov    0x8(%ebp),%eax
    ff8d:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    ff90:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff93:	83 c0 04             	add    $0x4,%eax
    ff96:	0f b6 00             	movzbl (%eax),%eax
    ff99:	0f b6 c0             	movzbl %al,%eax
    ff9c:	c1 e0 08             	shl    $0x8,%eax
    ff9f:	89 c2                	mov    %eax,%edx
    ffa1:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffa4:	83 c0 05             	add    $0x5,%eax
    ffa7:	0f b6 00             	movzbl (%eax),%eax
    ffaa:	0f b6 c0             	movzbl %al,%eax
    ffad:	01 d0                	add    %edx,%eax
    ffaf:	c1 e0 08             	shl    $0x8,%eax
    ffb2:	89 c2                	mov    %eax,%edx
    ffb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffb7:	83 c0 06             	add    $0x6,%eax
    ffba:	0f b6 00             	movzbl (%eax),%eax
    ffbd:	0f b6 c0             	movzbl %al,%eax
    ffc0:	01 d0                	add    %edx,%eax
    ffc2:	c1 e0 08             	shl    $0x8,%eax
    ffc5:	89 c2                	mov    %eax,%edx
    ffc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffca:	83 c0 07             	add    $0x7,%eax
    ffcd:	0f b6 00             	movzbl (%eax),%eax
    ffd0:	0f b6 c0             	movzbl %al,%eax
    ffd3:	01 c2                	add    %eax,%edx
    ffd5:	8b 45 08             	mov    0x8(%ebp),%eax
    ffd8:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    ffde:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffe1:	83 c0 08             	add    $0x8,%eax
    ffe4:	0f b6 00             	movzbl (%eax),%eax
    ffe7:	0f b6 d0             	movzbl %al,%edx
    ffea:	8b 45 08             	mov    0x8(%ebp),%eax
    ffed:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    fff3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fff8:	5d                   	pop    %ebp
    fff9:	c3                   	ret    

0000fffa <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    fffa:	55                   	push   %ebp
    fffb:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    fffd:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
   10001:	74 07                	je     1000a <readChunk_gAMA+0x10>
   10003:	b8 60 00 00 00       	mov    $0x60,%eax
   10008:	eb 5d                	jmp    10067 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
   1000a:	8b 45 08             	mov    0x8(%ebp),%eax
   1000d:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
   10014:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
   10017:	8b 45 0c             	mov    0xc(%ebp),%eax
   1001a:	0f b6 00             	movzbl (%eax),%eax
   1001d:	0f b6 c0             	movzbl %al,%eax
   10020:	c1 e0 08             	shl    $0x8,%eax
   10023:	89 c2                	mov    %eax,%edx
   10025:	8b 45 0c             	mov    0xc(%ebp),%eax
   10028:	83 c0 01             	add    $0x1,%eax
   1002b:	0f b6 00             	movzbl (%eax),%eax
   1002e:	0f b6 c0             	movzbl %al,%eax
   10031:	01 d0                	add    %edx,%eax
   10033:	c1 e0 08             	shl    $0x8,%eax
   10036:	89 c2                	mov    %eax,%edx
   10038:	8b 45 0c             	mov    0xc(%ebp),%eax
   1003b:	83 c0 02             	add    $0x2,%eax
   1003e:	0f b6 00             	movzbl (%eax),%eax
   10041:	0f b6 c0             	movzbl %al,%eax
   10044:	01 d0                	add    %edx,%eax
   10046:	c1 e0 08             	shl    $0x8,%eax
   10049:	89 c2                	mov    %eax,%edx
   1004b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1004e:	83 c0 03             	add    $0x3,%eax
   10051:	0f b6 00             	movzbl (%eax),%eax
   10054:	0f b6 c0             	movzbl %al,%eax
   10057:	01 c2                	add    %eax,%edx
   10059:	8b 45 08             	mov    0x8(%ebp),%eax
   1005c:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
   10062:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10067:	5d                   	pop    %ebp
   10068:	c3                   	ret    

00010069 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   10069:	55                   	push   %ebp
   1006a:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
   1006c:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
   10070:	74 0a                	je     1007c <readChunk_cHRM+0x13>
   10072:	b8 61 00 00 00       	mov    $0x61,%eax
   10077:	e9 7f 02 00 00       	jmp    102fb <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
   1007c:	8b 45 08             	mov    0x8(%ebp),%eax
   1007f:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10086:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
   10089:	8b 45 0c             	mov    0xc(%ebp),%eax
   1008c:	0f b6 00             	movzbl (%eax),%eax
   1008f:	0f b6 c0             	movzbl %al,%eax
   10092:	c1 e0 08             	shl    $0x8,%eax
   10095:	89 c2                	mov    %eax,%edx
   10097:	8b 45 0c             	mov    0xc(%ebp),%eax
   1009a:	83 c0 01             	add    $0x1,%eax
   1009d:	0f b6 00             	movzbl (%eax),%eax
   100a0:	0f b6 c0             	movzbl %al,%eax
   100a3:	01 d0                	add    %edx,%eax
   100a5:	c1 e0 08             	shl    $0x8,%eax
   100a8:	89 c2                	mov    %eax,%edx
   100aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   100ad:	83 c0 02             	add    $0x2,%eax
   100b0:	0f b6 00             	movzbl (%eax),%eax
   100b3:	0f b6 c0             	movzbl %al,%eax
   100b6:	01 d0                	add    %edx,%eax
   100b8:	c1 e0 08             	shl    $0x8,%eax
   100bb:	89 c2                	mov    %eax,%edx
   100bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   100c0:	83 c0 03             	add    $0x3,%eax
   100c3:	0f b6 00             	movzbl (%eax),%eax
   100c6:	0f b6 c0             	movzbl %al,%eax
   100c9:	01 c2                	add    %eax,%edx
   100cb:	8b 45 08             	mov    0x8(%ebp),%eax
   100ce:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
   100d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   100d7:	83 c0 04             	add    $0x4,%eax
   100da:	0f b6 00             	movzbl (%eax),%eax
   100dd:	0f b6 c0             	movzbl %al,%eax
   100e0:	c1 e0 08             	shl    $0x8,%eax
   100e3:	89 c2                	mov    %eax,%edx
   100e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   100e8:	83 c0 05             	add    $0x5,%eax
   100eb:	0f b6 00             	movzbl (%eax),%eax
   100ee:	0f b6 c0             	movzbl %al,%eax
   100f1:	01 d0                	add    %edx,%eax
   100f3:	c1 e0 08             	shl    $0x8,%eax
   100f6:	89 c2                	mov    %eax,%edx
   100f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   100fb:	83 c0 06             	add    $0x6,%eax
   100fe:	0f b6 00             	movzbl (%eax),%eax
   10101:	0f b6 c0             	movzbl %al,%eax
   10104:	01 d0                	add    %edx,%eax
   10106:	c1 e0 08             	shl    $0x8,%eax
   10109:	89 c2                	mov    %eax,%edx
   1010b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1010e:	83 c0 07             	add    $0x7,%eax
   10111:	0f b6 00             	movzbl (%eax),%eax
   10114:	0f b6 c0             	movzbl %al,%eax
   10117:	01 c2                	add    %eax,%edx
   10119:	8b 45 08             	mov    0x8(%ebp),%eax
   1011c:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
   10122:	8b 45 0c             	mov    0xc(%ebp),%eax
   10125:	83 c0 08             	add    $0x8,%eax
   10128:	0f b6 00             	movzbl (%eax),%eax
   1012b:	0f b6 c0             	movzbl %al,%eax
   1012e:	c1 e0 08             	shl    $0x8,%eax
   10131:	89 c2                	mov    %eax,%edx
   10133:	8b 45 0c             	mov    0xc(%ebp),%eax
   10136:	83 c0 09             	add    $0x9,%eax
   10139:	0f b6 00             	movzbl (%eax),%eax
   1013c:	0f b6 c0             	movzbl %al,%eax
   1013f:	01 d0                	add    %edx,%eax
   10141:	c1 e0 08             	shl    $0x8,%eax
   10144:	89 c2                	mov    %eax,%edx
   10146:	8b 45 0c             	mov    0xc(%ebp),%eax
   10149:	83 c0 0a             	add    $0xa,%eax
   1014c:	0f b6 00             	movzbl (%eax),%eax
   1014f:	0f b6 c0             	movzbl %al,%eax
   10152:	01 d0                	add    %edx,%eax
   10154:	c1 e0 08             	shl    $0x8,%eax
   10157:	89 c2                	mov    %eax,%edx
   10159:	8b 45 0c             	mov    0xc(%ebp),%eax
   1015c:	83 c0 0b             	add    $0xb,%eax
   1015f:	0f b6 00             	movzbl (%eax),%eax
   10162:	0f b6 c0             	movzbl %al,%eax
   10165:	01 c2                	add    %eax,%edx
   10167:	8b 45 08             	mov    0x8(%ebp),%eax
   1016a:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
   10170:	8b 45 0c             	mov    0xc(%ebp),%eax
   10173:	83 c0 0c             	add    $0xc,%eax
   10176:	0f b6 00             	movzbl (%eax),%eax
   10179:	0f b6 c0             	movzbl %al,%eax
   1017c:	c1 e0 08             	shl    $0x8,%eax
   1017f:	89 c2                	mov    %eax,%edx
   10181:	8b 45 0c             	mov    0xc(%ebp),%eax
   10184:	83 c0 0d             	add    $0xd,%eax
   10187:	0f b6 00             	movzbl (%eax),%eax
   1018a:	0f b6 c0             	movzbl %al,%eax
   1018d:	01 d0                	add    %edx,%eax
   1018f:	c1 e0 08             	shl    $0x8,%eax
   10192:	89 c2                	mov    %eax,%edx
   10194:	8b 45 0c             	mov    0xc(%ebp),%eax
   10197:	83 c0 0e             	add    $0xe,%eax
   1019a:	0f b6 00             	movzbl (%eax),%eax
   1019d:	0f b6 c0             	movzbl %al,%eax
   101a0:	01 d0                	add    %edx,%eax
   101a2:	c1 e0 08             	shl    $0x8,%eax
   101a5:	89 c2                	mov    %eax,%edx
   101a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   101aa:	83 c0 0f             	add    $0xf,%eax
   101ad:	0f b6 00             	movzbl (%eax),%eax
   101b0:	0f b6 c0             	movzbl %al,%eax
   101b3:	01 c2                	add    %eax,%edx
   101b5:	8b 45 08             	mov    0x8(%ebp),%eax
   101b8:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
   101be:	8b 45 0c             	mov    0xc(%ebp),%eax
   101c1:	83 c0 10             	add    $0x10,%eax
   101c4:	0f b6 00             	movzbl (%eax),%eax
   101c7:	0f b6 c0             	movzbl %al,%eax
   101ca:	c1 e0 08             	shl    $0x8,%eax
   101cd:	89 c2                	mov    %eax,%edx
   101cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   101d2:	83 c0 11             	add    $0x11,%eax
   101d5:	0f b6 00             	movzbl (%eax),%eax
   101d8:	0f b6 c0             	movzbl %al,%eax
   101db:	01 d0                	add    %edx,%eax
   101dd:	c1 e0 08             	shl    $0x8,%eax
   101e0:	89 c2                	mov    %eax,%edx
   101e2:	8b 45 0c             	mov    0xc(%ebp),%eax
   101e5:	83 c0 12             	add    $0x12,%eax
   101e8:	0f b6 00             	movzbl (%eax),%eax
   101eb:	0f b6 c0             	movzbl %al,%eax
   101ee:	01 d0                	add    %edx,%eax
   101f0:	c1 e0 08             	shl    $0x8,%eax
   101f3:	89 c2                	mov    %eax,%edx
   101f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   101f8:	83 c0 13             	add    $0x13,%eax
   101fb:	0f b6 00             	movzbl (%eax),%eax
   101fe:	0f b6 c0             	movzbl %al,%eax
   10201:	01 c2                	add    %eax,%edx
   10203:	8b 45 08             	mov    0x8(%ebp),%eax
   10206:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
   1020c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1020f:	83 c0 14             	add    $0x14,%eax
   10212:	0f b6 00             	movzbl (%eax),%eax
   10215:	0f b6 c0             	movzbl %al,%eax
   10218:	c1 e0 08             	shl    $0x8,%eax
   1021b:	89 c2                	mov    %eax,%edx
   1021d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10220:	83 c0 15             	add    $0x15,%eax
   10223:	0f b6 00             	movzbl (%eax),%eax
   10226:	0f b6 c0             	movzbl %al,%eax
   10229:	01 d0                	add    %edx,%eax
   1022b:	c1 e0 08             	shl    $0x8,%eax
   1022e:	89 c2                	mov    %eax,%edx
   10230:	8b 45 0c             	mov    0xc(%ebp),%eax
   10233:	83 c0 16             	add    $0x16,%eax
   10236:	0f b6 00             	movzbl (%eax),%eax
   10239:	0f b6 c0             	movzbl %al,%eax
   1023c:	01 d0                	add    %edx,%eax
   1023e:	c1 e0 08             	shl    $0x8,%eax
   10241:	89 c2                	mov    %eax,%edx
   10243:	8b 45 0c             	mov    0xc(%ebp),%eax
   10246:	83 c0 17             	add    $0x17,%eax
   10249:	0f b6 00             	movzbl (%eax),%eax
   1024c:	0f b6 c0             	movzbl %al,%eax
   1024f:	01 c2                	add    %eax,%edx
   10251:	8b 45 08             	mov    0x8(%ebp),%eax
   10254:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
   1025a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1025d:	83 c0 18             	add    $0x18,%eax
   10260:	0f b6 00             	movzbl (%eax),%eax
   10263:	0f b6 c0             	movzbl %al,%eax
   10266:	c1 e0 08             	shl    $0x8,%eax
   10269:	89 c2                	mov    %eax,%edx
   1026b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1026e:	83 c0 19             	add    $0x19,%eax
   10271:	0f b6 00             	movzbl (%eax),%eax
   10274:	0f b6 c0             	movzbl %al,%eax
   10277:	01 d0                	add    %edx,%eax
   10279:	c1 e0 08             	shl    $0x8,%eax
   1027c:	89 c2                	mov    %eax,%edx
   1027e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10281:	83 c0 1a             	add    $0x1a,%eax
   10284:	0f b6 00             	movzbl (%eax),%eax
   10287:	0f b6 c0             	movzbl %al,%eax
   1028a:	01 d0                	add    %edx,%eax
   1028c:	c1 e0 08             	shl    $0x8,%eax
   1028f:	89 c2                	mov    %eax,%edx
   10291:	8b 45 0c             	mov    0xc(%ebp),%eax
   10294:	83 c0 1b             	add    $0x1b,%eax
   10297:	0f b6 00             	movzbl (%eax),%eax
   1029a:	0f b6 c0             	movzbl %al,%eax
   1029d:	01 c2                	add    %eax,%edx
   1029f:	8b 45 08             	mov    0x8(%ebp),%eax
   102a2:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
   102a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   102ab:	83 c0 1c             	add    $0x1c,%eax
   102ae:	0f b6 00             	movzbl (%eax),%eax
   102b1:	0f b6 c0             	movzbl %al,%eax
   102b4:	c1 e0 08             	shl    $0x8,%eax
   102b7:	89 c2                	mov    %eax,%edx
   102b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   102bc:	83 c0 1d             	add    $0x1d,%eax
   102bf:	0f b6 00             	movzbl (%eax),%eax
   102c2:	0f b6 c0             	movzbl %al,%eax
   102c5:	01 d0                	add    %edx,%eax
   102c7:	c1 e0 08             	shl    $0x8,%eax
   102ca:	89 c2                	mov    %eax,%edx
   102cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   102cf:	83 c0 1e             	add    $0x1e,%eax
   102d2:	0f b6 00             	movzbl (%eax),%eax
   102d5:	0f b6 c0             	movzbl %al,%eax
   102d8:	01 d0                	add    %edx,%eax
   102da:	c1 e0 08             	shl    $0x8,%eax
   102dd:	89 c2                	mov    %eax,%edx
   102df:	8b 45 0c             	mov    0xc(%ebp),%eax
   102e2:	83 c0 1f             	add    $0x1f,%eax
   102e5:	0f b6 00             	movzbl (%eax),%eax
   102e8:	0f b6 c0             	movzbl %al,%eax
   102eb:	01 c2                	add    %eax,%edx
   102ed:	8b 45 08             	mov    0x8(%ebp),%eax
   102f0:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
   102f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   102fb:	5d                   	pop    %ebp
   102fc:	c3                   	ret    

000102fd <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   102fd:	55                   	push   %ebp
   102fe:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
   10300:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
   10304:	74 07                	je     1030d <readChunk_sRGB+0x10>
   10306:	b8 62 00 00 00       	mov    $0x62,%eax
   1030b:	eb 24                	jmp    10331 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
   1030d:	8b 45 08             	mov    0x8(%ebp),%eax
   10310:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
   10317:	00 00 00 
  info->srgb_intent = data[0];
   1031a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1031d:	0f b6 00             	movzbl (%eax),%eax
   10320:	0f b6 d0             	movzbl %al,%edx
   10323:	8b 45 08             	mov    0x8(%ebp),%eax
   10326:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
   1032c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10331:	5d                   	pop    %ebp
   10332:	c3                   	ret    

00010333 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   10333:	55                   	push   %ebp
   10334:	89 e5                	mov    %esp,%ebp
   10336:	53                   	push   %ebx
   10337:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   1033a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
   10341:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   10348:	8b 45 0c             	mov    0xc(%ebp),%eax
   1034b:	8b 10                	mov    (%eax),%edx
   1034d:	89 55 cc             	mov    %edx,-0x34(%ebp)
   10350:	8b 50 04             	mov    0x4(%eax),%edx
   10353:	89 55 d0             	mov    %edx,-0x30(%ebp)
   10356:	8b 50 08             	mov    0x8(%eax),%edx
   10359:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   1035c:	8b 50 0c             	mov    0xc(%eax),%edx
   1035f:	89 55 d8             	mov    %edx,-0x28(%ebp)
   10362:	8b 50 10             	mov    0x10(%eax),%edx
   10365:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10368:	8b 40 14             	mov    0x14(%eax),%eax
   1036b:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
   1036e:	8b 45 08             	mov    0x8(%ebp),%eax
   10371:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
   10378:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
   1037b:	8b 45 08             	mov    0x8(%ebp),%eax
   1037e:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   10384:	85 c0                	test   %eax,%eax
   10386:	74 0e                	je     10396 <readChunk_iCCP+0x63>
   10388:	83 ec 0c             	sub    $0xc,%esp
   1038b:	ff 75 08             	pushl  0x8(%ebp)
   1038e:	e8 ca a6 ff ff       	call   aa5d <lodepng_clear_icc>
   10393:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   10396:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1039d:	eb 04                	jmp    103a3 <readChunk_iCCP+0x70>
   1039f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   103a3:	8b 45 14             	mov    0x14(%ebp),%eax
   103a6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   103a9:	73 0f                	jae    103ba <readChunk_iCCP+0x87>
   103ab:	8b 55 10             	mov    0x10(%ebp),%edx
   103ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
   103b1:	01 d0                	add    %edx,%eax
   103b3:	0f b6 00             	movzbl (%eax),%eax
   103b6:	84 c0                	test   %al,%al
   103b8:	75 e5                	jne    1039f <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
   103ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
   103bd:	8d 50 02             	lea    0x2(%eax),%edx
   103c0:	8b 45 14             	mov    0x14(%ebp),%eax
   103c3:	39 c2                	cmp    %eax,%edx
   103c5:	72 0a                	jb     103d1 <readChunk_iCCP+0x9e>
   103c7:	b8 4b 00 00 00       	mov    $0x4b,%eax
   103cc:	e9 46 01 00 00       	jmp    10517 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
   103d1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   103d5:	74 06                	je     103dd <readChunk_iCCP+0xaa>
   103d7:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   103db:	76 0a                	jbe    103e7 <readChunk_iCCP+0xb4>
   103dd:	b8 59 00 00 00       	mov    $0x59,%eax
   103e2:	e9 30 01 00 00       	jmp    10517 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
   103e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   103ea:	83 c0 01             	add    $0x1,%eax
   103ed:	83 ec 0c             	sub    $0xc,%esp
   103f0:	50                   	push   %eax
   103f1:	e8 1a 40 ff ff       	call   4410 <lodepng_malloc>
   103f6:	83 c4 10             	add    $0x10,%esp
   103f9:	89 c2                	mov    %eax,%edx
   103fb:	8b 45 08             	mov    0x8(%ebp),%eax
   103fe:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
   10404:	8b 45 08             	mov    0x8(%ebp),%eax
   10407:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1040d:	85 c0                	test   %eax,%eax
   1040f:	75 0a                	jne    1041b <readChunk_iCCP+0xe8>
   10411:	b8 53 00 00 00       	mov    $0x53,%eax
   10416:	e9 fc 00 00 00       	jmp    10517 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
   1041b:	8b 45 08             	mov    0x8(%ebp),%eax
   1041e:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   10424:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10427:	01 d0                	add    %edx,%eax
   10429:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
   1042c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10433:	eb 1f                	jmp    10454 <readChunk_iCCP+0x121>
   10435:	8b 45 08             	mov    0x8(%ebp),%eax
   10438:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   1043e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10441:	01 d0                	add    %edx,%eax
   10443:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10446:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10449:	01 ca                	add    %ecx,%edx
   1044b:	0f b6 12             	movzbl (%edx),%edx
   1044e:	88 10                	mov    %dl,(%eax)
   10450:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10454:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10457:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1045a:	75 d9                	jne    10435 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
   1045c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1045f:	8d 50 01             	lea    0x1(%eax),%edx
   10462:	8b 45 10             	mov    0x10(%ebp),%eax
   10465:	01 d0                	add    %edx,%eax
   10467:	0f b6 00             	movzbl (%eax),%eax
   1046a:	84 c0                	test   %al,%al
   1046c:	74 0a                	je     10478 <readChunk_iCCP+0x145>
   1046e:	b8 48 00 00 00       	mov    $0x48,%eax
   10473:	e9 9f 00 00 00       	jmp    10517 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
   10478:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1047b:	83 c0 02             	add    $0x2,%eax
   1047e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
   10481:	8b 45 14             	mov    0x14(%ebp),%eax
   10484:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   10487:	76 0a                	jbe    10493 <readChunk_iCCP+0x160>
   10489:	b8 4b 00 00 00       	mov    $0x4b,%eax
   1048e:	e9 84 00 00 00       	jmp    10517 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
   10493:	8b 45 14             	mov    0x14(%ebp),%eax
   10496:	2b 45 e8             	sub    -0x18(%ebp),%eax
   10499:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
   1049c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1049f:	8b 40 34             	mov    0x34(%eax),%eax
   104a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
   104a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   104a8:	8b 4d 10             	mov    0x10(%ebp),%ecx
   104ab:	8b 55 e8             	mov    -0x18(%ebp),%edx
   104ae:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
   104b1:	8b 55 08             	mov    0x8(%ebp),%edx
   104b4:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
   104ba:	83 ec 08             	sub    $0x8,%esp
   104bd:	8d 55 cc             	lea    -0x34(%ebp),%edx
   104c0:	52                   	push   %edx
   104c1:	50                   	push   %eax
   104c2:	53                   	push   %ebx
   104c3:	6a 00                	push   $0x0
   104c5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   104c8:	50                   	push   %eax
   104c9:	51                   	push   %ecx
   104ca:	e8 fc 89 ff ff       	call   8ecb <zlib_decompress>
   104cf:	83 c4 20             	add    $0x20,%esp
   104d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
   104d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   104d9:	74 11                	je     104ec <readChunk_iCCP+0x1b9>
   104db:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   104de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   104e1:	39 c2                	cmp    %eax,%edx
   104e3:	7d 07                	jge    104ec <readChunk_iCCP+0x1b9>
   104e5:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
   104ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   104ef:	89 c2                	mov    %eax,%edx
   104f1:	8b 45 08             	mov    0x8(%ebp),%eax
   104f4:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
   104fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   104fe:	75 14                	jne    10514 <readChunk_iCCP+0x1e1>
   10500:	8b 45 08             	mov    0x8(%ebp),%eax
   10503:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
   10509:	85 c0                	test   %eax,%eax
   1050b:	75 07                	jne    10514 <readChunk_iCCP+0x1e1>
   1050d:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
   10514:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10517:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1051a:	c9                   	leave  
   1051b:	c3                   	ret    

0001051c <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
   1051c:	55                   	push   %ebp
   1051d:	89 e5                	mov    %esp,%ebp
   1051f:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
   10522:	8b 55 0c             	mov    0xc(%ebp),%edx
   10525:	8b 45 10             	mov    0x10(%ebp),%eax
   10528:	01 d0                	add    %edx,%eax
   1052a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
   1052d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
   10534:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
   1053b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1053e:	83 c0 04             	add    $0x4,%eax
   10541:	3b 45 14             	cmp    0x14(%ebp),%eax
   10544:	7e 0a                	jle    10550 <lodepng_inspect_chunk+0x34>
   10546:	b8 1e 00 00 00       	mov    $0x1e,%eax
   1054b:	e9 43 03 00 00       	jmp    10893 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
   10550:	ff 75 ec             	pushl  -0x14(%ebp)
   10553:	e8 3a 8e ff ff       	call   9392 <lodepng_chunk_length>
   10558:	83 c4 04             	add    $0x4,%esp
   1055b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
   1055e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10561:	85 c0                	test   %eax,%eax
   10563:	79 0a                	jns    1056f <lodepng_inspect_chunk+0x53>
   10565:	b8 3f 00 00 00       	mov    $0x3f,%eax
   1056a:	e9 24 03 00 00       	jmp    10893 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
   1056f:	ff 75 ec             	pushl  -0x14(%ebp)
   10572:	e8 53 8f ff ff       	call   94ca <lodepng_chunk_data_const>
   10577:	83 c4 04             	add    $0x4,%esp
   1057a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
   1057d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10580:	8d 50 04             	lea    0x4(%eax),%edx
   10583:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10586:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10589:	8b 55 14             	mov    0x14(%ebp),%edx
   1058c:	8b 45 10             	mov    0x10(%ebp),%eax
   1058f:	01 d0                	add    %edx,%eax
   10591:	39 c1                	cmp    %eax,%ecx
   10593:	76 0a                	jbe    1059f <lodepng_inspect_chunk+0x83>
   10595:	b8 1e 00 00 00       	mov    $0x1e,%eax
   1059a:	e9 f4 02 00 00       	jmp    10893 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   1059f:	68 28 b1 01 00       	push   $0x1b128
   105a4:	ff 75 ec             	pushl  -0x14(%ebp)
   105a7:	e8 33 8e ff ff       	call   93df <lodepng_chunk_type_equals>
   105ac:	83 c4 08             	add    $0x8,%esp
   105af:	84 c0                	test   %al,%al
   105b1:	74 24                	je     105d7 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   105b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   105b6:	8b 55 08             	mov    0x8(%ebp),%edx
   105b9:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   105bf:	83 ec 04             	sub    $0x4,%esp
   105c2:	50                   	push   %eax
   105c3:	ff 75 e4             	pushl  -0x1c(%ebp)
   105c6:	52                   	push   %edx
   105c7:	e8 5b ee ff ff       	call   f427 <readChunk_PLTE>
   105cc:	83 c4 10             	add    $0x10,%esp
   105cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
   105d2:	e9 8a 02 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   105d7:	83 ec 08             	sub    $0x8,%esp
   105da:	68 2d b1 01 00       	push   $0x1b12d
   105df:	ff 75 ec             	pushl  -0x14(%ebp)
   105e2:	e8 f8 8d ff ff       	call   93df <lodepng_chunk_type_equals>
   105e7:	83 c4 10             	add    $0x10,%esp
   105ea:	84 c0                	test   %al,%al
   105ec:	74 24                	je     10612 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   105ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   105f1:	8b 55 08             	mov    0x8(%ebp),%edx
   105f4:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   105fa:	83 ec 04             	sub    $0x4,%esp
   105fd:	50                   	push   %eax
   105fe:	ff 75 e4             	pushl  -0x1c(%ebp)
   10601:	52                   	push   %edx
   10602:	e8 40 ef ff ff       	call   f547 <readChunk_tRNS>
   10607:	83 c4 10             	add    $0x10,%esp
   1060a:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1060d:	e9 4f 02 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   10612:	83 ec 08             	sub    $0x8,%esp
   10615:	68 32 b1 01 00       	push   $0x1b132
   1061a:	ff 75 ec             	pushl  -0x14(%ebp)
   1061d:	e8 bd 8d ff ff       	call   93df <lodepng_chunk_type_equals>
   10622:	83 c4 10             	add    $0x10,%esp
   10625:	84 c0                	test   %al,%al
   10627:	74 24                	je     1064d <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
   10629:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1062c:	8b 55 08             	mov    0x8(%ebp),%edx
   1062f:	81 c2 98 00 00 00    	add    $0x98,%edx
   10635:	83 ec 04             	sub    $0x4,%esp
   10638:	50                   	push   %eax
   10639:	ff 75 e4             	pushl  -0x1c(%ebp)
   1063c:	52                   	push   %edx
   1063d:	e8 68 f0 ff ff       	call   f6aa <readChunk_bKGD>
   10642:	83 c4 10             	add    $0x10,%esp
   10645:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10648:	e9 14 02 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   1064d:	83 ec 08             	sub    $0x8,%esp
   10650:	68 37 b1 01 00       	push   $0x1b137
   10655:	ff 75 ec             	pushl  -0x14(%ebp)
   10658:	e8 82 8d ff ff       	call   93df <lodepng_chunk_type_equals>
   1065d:	83 c4 10             	add    $0x10,%esp
   10660:	84 c0                	test   %al,%al
   10662:	74 24                	je     10688 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
   10664:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10667:	8b 55 08             	mov    0x8(%ebp),%edx
   1066a:	81 c2 98 00 00 00    	add    $0x98,%edx
   10670:	83 ec 04             	sub    $0x4,%esp
   10673:	50                   	push   %eax
   10674:	ff 75 e4             	pushl  -0x1c(%ebp)
   10677:	52                   	push   %edx
   10678:	e8 b0 f1 ff ff       	call   f82d <readChunk_tEXt>
   1067d:	83 c4 10             	add    $0x10,%esp
   10680:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10683:	e9 d9 01 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   10688:	83 ec 08             	sub    $0x8,%esp
   1068b:	68 3c b1 01 00       	push   $0x1b13c
   10690:	ff 75 ec             	pushl  -0x14(%ebp)
   10693:	e8 47 8d ff ff       	call   93df <lodepng_chunk_type_equals>
   10698:	83 c4 10             	add    $0x10,%esp
   1069b:	84 c0                	test   %al,%al
   1069d:	74 25                	je     106c4 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   1069f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   106a2:	8b 45 08             	mov    0x8(%ebp),%eax
   106a5:	8b 4d 08             	mov    0x8(%ebp),%ecx
   106a8:	81 c1 98 00 00 00    	add    $0x98,%ecx
   106ae:	52                   	push   %edx
   106af:	ff 75 e4             	pushl  -0x1c(%ebp)
   106b2:	50                   	push   %eax
   106b3:	51                   	push   %ecx
   106b4:	e8 c0 f2 ff ff       	call   f979 <readChunk_zTXt>
   106b9:	83 c4 10             	add    $0x10,%esp
   106bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
   106bf:	e9 9d 01 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   106c4:	83 ec 08             	sub    $0x8,%esp
   106c7:	68 41 b1 01 00       	push   $0x1b141
   106cc:	ff 75 ec             	pushl  -0x14(%ebp)
   106cf:	e8 0b 8d ff ff       	call   93df <lodepng_chunk_type_equals>
   106d4:	83 c4 10             	add    $0x10,%esp
   106d7:	84 c0                	test   %al,%al
   106d9:	74 25                	je     10700 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   106db:	8b 55 e8             	mov    -0x18(%ebp),%edx
   106de:	8b 45 08             	mov    0x8(%ebp),%eax
   106e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
   106e4:	81 c1 98 00 00 00    	add    $0x98,%ecx
   106ea:	52                   	push   %edx
   106eb:	ff 75 e4             	pushl  -0x1c(%ebp)
   106ee:	50                   	push   %eax
   106ef:	51                   	push   %ecx
   106f0:	e8 40 f4 ff ff       	call   fb35 <readChunk_iTXt>
   106f5:	83 c4 10             	add    $0x10,%esp
   106f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
   106fb:	e9 61 01 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   10700:	83 ec 08             	sub    $0x8,%esp
   10703:	68 46 b1 01 00       	push   $0x1b146
   10708:	ff 75 ec             	pushl  -0x14(%ebp)
   1070b:	e8 cf 8c ff ff       	call   93df <lodepng_chunk_type_equals>
   10710:	83 c4 10             	add    $0x10,%esp
   10713:	84 c0                	test   %al,%al
   10715:	74 24                	je     1073b <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
   10717:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1071a:	8b 55 08             	mov    0x8(%ebp),%edx
   1071d:	81 c2 98 00 00 00    	add    $0x98,%edx
   10723:	83 ec 04             	sub    $0x4,%esp
   10726:	50                   	push   %eax
   10727:	ff 75 e4             	pushl  -0x1c(%ebp)
   1072a:	52                   	push   %edx
   1072b:	e8 5b f7 ff ff       	call   fe8b <readChunk_tIME>
   10730:	83 c4 10             	add    $0x10,%esp
   10733:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10736:	e9 26 01 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   1073b:	83 ec 08             	sub    $0x8,%esp
   1073e:	68 4b b1 01 00       	push   $0x1b14b
   10743:	ff 75 ec             	pushl  -0x14(%ebp)
   10746:	e8 94 8c ff ff       	call   93df <lodepng_chunk_type_equals>
   1074b:	83 c4 10             	add    $0x10,%esp
   1074e:	84 c0                	test   %al,%al
   10750:	74 24                	je     10776 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
   10752:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10755:	8b 55 08             	mov    0x8(%ebp),%edx
   10758:	81 c2 98 00 00 00    	add    $0x98,%edx
   1075e:	83 ec 04             	sub    $0x4,%esp
   10761:	50                   	push   %eax
   10762:	ff 75 e4             	pushl  -0x1c(%ebp)
   10765:	52                   	push   %edx
   10766:	e8 c0 f7 ff ff       	call   ff2b <readChunk_pHYs>
   1076b:	83 c4 10             	add    $0x10,%esp
   1076e:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10771:	e9 eb 00 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   10776:	83 ec 08             	sub    $0x8,%esp
   10779:	68 50 b1 01 00       	push   $0x1b150
   1077e:	ff 75 ec             	pushl  -0x14(%ebp)
   10781:	e8 59 8c ff ff       	call   93df <lodepng_chunk_type_equals>
   10786:	83 c4 10             	add    $0x10,%esp
   10789:	84 c0                	test   %al,%al
   1078b:	74 24                	je     107b1 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
   1078d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10790:	8b 55 08             	mov    0x8(%ebp),%edx
   10793:	81 c2 98 00 00 00    	add    $0x98,%edx
   10799:	83 ec 04             	sub    $0x4,%esp
   1079c:	50                   	push   %eax
   1079d:	ff 75 e4             	pushl  -0x1c(%ebp)
   107a0:	52                   	push   %edx
   107a1:	e8 54 f8 ff ff       	call   fffa <readChunk_gAMA>
   107a6:	83 c4 10             	add    $0x10,%esp
   107a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
   107ac:	e9 b0 00 00 00       	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   107b1:	83 ec 08             	sub    $0x8,%esp
   107b4:	68 55 b1 01 00       	push   $0x1b155
   107b9:	ff 75 ec             	pushl  -0x14(%ebp)
   107bc:	e8 1e 8c ff ff       	call   93df <lodepng_chunk_type_equals>
   107c1:	83 c4 10             	add    $0x10,%esp
   107c4:	84 c0                	test   %al,%al
   107c6:	74 21                	je     107e9 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
   107c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   107cb:	8b 55 08             	mov    0x8(%ebp),%edx
   107ce:	81 c2 98 00 00 00    	add    $0x98,%edx
   107d4:	83 ec 04             	sub    $0x4,%esp
   107d7:	50                   	push   %eax
   107d8:	ff 75 e4             	pushl  -0x1c(%ebp)
   107db:	52                   	push   %edx
   107dc:	e8 88 f8 ff ff       	call   10069 <readChunk_cHRM>
   107e1:	83 c4 10             	add    $0x10,%esp
   107e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
   107e7:	eb 78                	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   107e9:	83 ec 08             	sub    $0x8,%esp
   107ec:	68 5a b1 01 00       	push   $0x1b15a
   107f1:	ff 75 ec             	pushl  -0x14(%ebp)
   107f4:	e8 e6 8b ff ff       	call   93df <lodepng_chunk_type_equals>
   107f9:	83 c4 10             	add    $0x10,%esp
   107fc:	84 c0                	test   %al,%al
   107fe:	74 21                	je     10821 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10800:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10803:	8b 55 08             	mov    0x8(%ebp),%edx
   10806:	81 c2 98 00 00 00    	add    $0x98,%edx
   1080c:	83 ec 04             	sub    $0x4,%esp
   1080f:	50                   	push   %eax
   10810:	ff 75 e4             	pushl  -0x1c(%ebp)
   10813:	52                   	push   %edx
   10814:	e8 e4 fa ff ff       	call   102fd <readChunk_sRGB>
   10819:	83 c4 10             	add    $0x10,%esp
   1081c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1081f:	eb 40                	jmp    10861 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   10821:	83 ec 08             	sub    $0x8,%esp
   10824:	68 5f b1 01 00       	push   $0x1b15f
   10829:	ff 75 ec             	pushl  -0x14(%ebp)
   1082c:	e8 ae 8b ff ff       	call   93df <lodepng_chunk_type_equals>
   10831:	83 c4 10             	add    $0x10,%esp
   10834:	84 c0                	test   %al,%al
   10836:	74 22                	je     1085a <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   10838:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1083b:	8b 45 08             	mov    0x8(%ebp),%eax
   1083e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   10841:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10847:	52                   	push   %edx
   10848:	ff 75 e4             	pushl  -0x1c(%ebp)
   1084b:	50                   	push   %eax
   1084c:	51                   	push   %ecx
   1084d:	e8 e1 fa ff ff       	call   10333 <readChunk_iCCP>
   10852:	83 c4 10             	add    $0x10,%esp
   10855:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10858:	eb 07                	jmp    10861 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
   1085a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
   10861:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10865:	75 29                	jne    10890 <lodepng_inspect_chunk+0x374>
   10867:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1086b:	75 23                	jne    10890 <lodepng_inspect_chunk+0x374>
   1086d:	8b 45 08             	mov    0x8(%ebp),%eax
   10870:	8b 40 18             	mov    0x18(%eax),%eax
   10873:	85 c0                	test   %eax,%eax
   10875:	75 19                	jne    10890 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
   10877:	83 ec 0c             	sub    $0xc,%esp
   1087a:	ff 75 ec             	pushl  -0x14(%ebp)
   1087d:	e8 53 8c ff ff       	call   94d5 <lodepng_chunk_check_crc>
   10882:	83 c4 10             	add    $0x10,%esp
   10885:	85 c0                	test   %eax,%eax
   10887:	74 07                	je     10890 <lodepng_inspect_chunk+0x374>
   10889:	b8 39 00 00 00       	mov    $0x39,%eax
   1088e:	eb 03                	jmp    10893 <lodepng_inspect_chunk+0x377>
  }

  return error;
   10890:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   10893:	c9                   	leave  
   10894:	c3                   	ret    

00010895 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
   10895:	55                   	push   %ebp
   10896:	89 e5                	mov    %esp,%ebp
   10898:	56                   	push   %esi
   10899:	53                   	push   %ebx
   1089a:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
   1089d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
   108a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
   108a8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
   108af:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   108b6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
   108bd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
   108c4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
   108cb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
   108d2:	8b 45 08             	mov    0x8(%ebp),%eax
   108d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   108db:	8b 45 10             	mov    0x10(%ebp),%eax
   108de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   108e4:	8b 45 10             	mov    0x10(%ebp),%eax
   108e7:	8b 10                	mov    (%eax),%edx
   108e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ec:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
   108ee:	83 ec 0c             	sub    $0xc,%esp
   108f1:	ff 75 1c             	pushl  0x1c(%ebp)
   108f4:	ff 75 18             	pushl  0x18(%ebp)
   108f7:	ff 75 14             	pushl  0x14(%ebp)
   108fa:	ff 75 10             	pushl  0x10(%ebp)
   108fd:	ff 75 0c             	pushl  0xc(%ebp)
   10900:	e8 d3 da ff ff       	call   e3d8 <lodepng_inspect>
   10905:	83 c4 20             	add    $0x20,%esp
   10908:	89 c2                	mov    %eax,%edx
   1090a:	8b 45 14             	mov    0x14(%ebp),%eax
   1090d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
   10913:	8b 45 14             	mov    0x14(%ebp),%eax
   10916:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1091c:	85 c0                	test   %eax,%eax
   1091e:	0f 85 24 0a 00 00    	jne    11348 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
   10924:	8b 45 14             	mov    0x14(%ebp),%eax
   10927:	8d 58 78             	lea    0x78(%eax),%ebx
   1092a:	8b 45 14             	mov    0x14(%ebp),%eax
   1092d:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   10933:	8b 45 10             	mov    0x10(%ebp),%eax
   10936:	8b 10                	mov    (%eax),%edx
   10938:	8b 45 0c             	mov    0xc(%ebp),%eax
   1093b:	8b 00                	mov    (%eax),%eax
   1093d:	53                   	push   %ebx
   1093e:	51                   	push   %ecx
   1093f:	52                   	push   %edx
   10940:	50                   	push   %eax
   10941:	e8 76 97 ff ff       	call   a0bc <lodepng_pixel_overflow>
   10946:	83 c4 10             	add    $0x10,%esp
   10949:	85 c0                	test   %eax,%eax
   1094b:	74 12                	je     1095f <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
   1094d:	8b 45 14             	mov    0x14(%ebp),%eax
   10950:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
   10957:	00 00 00 
   1095a:	e9 ea 09 00 00       	jmp    11349 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
   1095f:	83 ec 0c             	sub    $0xc,%esp
   10962:	ff 75 1c             	pushl  0x1c(%ebp)
   10965:	e8 a6 3a ff ff       	call   4410 <lodepng_malloc>
   1096a:	83 c4 10             	add    $0x10,%esp
   1096d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
   10970:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   10974:	75 12                	jne    10988 <decodeGeneric+0xf3>
   10976:	8b 45 14             	mov    0x14(%ebp),%eax
   10979:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10980:	00 00 00 
   10983:	e9 c1 09 00 00       	jmp    11349 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
   10988:	8b 45 18             	mov    0x18(%ebp),%eax
   1098b:	83 c0 21             	add    $0x21,%eax
   1098e:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   10991:	e9 81 06 00 00       	jmp    11017 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
   10996:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10999:	8b 45 18             	mov    0x18(%ebp),%eax
   1099c:	29 c2                	sub    %eax,%edx
   1099e:	89 d0                	mov    %edx,%eax
   109a0:	83 c0 0c             	add    $0xc,%eax
   109a3:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   109a6:	7f 08                	jg     109b0 <decodeGeneric+0x11b>
   109a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109ab:	3b 45 18             	cmp    0x18(%ebp),%eax
   109ae:	73 20                	jae    109d0 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   109b0:	8b 45 14             	mov    0x14(%ebp),%eax
   109b3:	8b 40 20             	mov    0x20(%eax),%eax
   109b6:	85 c0                	test   %eax,%eax
   109b8:	0f 85 72 06 00 00    	jne    11030 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
   109be:	8b 45 14             	mov    0x14(%ebp),%eax
   109c1:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
   109c8:	00 00 00 
   109cb:	e9 6a 06 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
   109d0:	83 ec 0c             	sub    $0xc,%esp
   109d3:	ff 75 f0             	pushl  -0x10(%ebp)
   109d6:	e8 b7 89 ff ff       	call   9392 <lodepng_chunk_length>
   109db:	83 c4 10             	add    $0x10,%esp
   109de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
   109e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   109e4:	85 c0                	test   %eax,%eax
   109e6:	79 20                	jns    10a08 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   109e8:	8b 45 14             	mov    0x14(%ebp),%eax
   109eb:	8b 40 20             	mov    0x20(%eax),%eax
   109ee:	85 c0                	test   %eax,%eax
   109f0:	0f 85 3d 06 00 00    	jne    11033 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
   109f6:	8b 45 14             	mov    0x14(%ebp),%eax
   109f9:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
   10a00:	00 00 00 
   10a03:	e9 32 06 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
   10a08:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10a0b:	8b 45 18             	mov    0x18(%ebp),%eax
   10a0e:	29 c2                	sub    %eax,%edx
   10a10:	89 d0                	mov    %edx,%eax
   10a12:	89 c2                	mov    %eax,%edx
   10a14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10a17:	01 d0                	add    %edx,%eax
   10a19:	83 c0 0c             	add    $0xc,%eax
   10a1c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   10a1f:	7f 10                	jg     10a31 <decodeGeneric+0x19c>
   10a21:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10a24:	8d 50 0c             	lea    0xc(%eax),%edx
   10a27:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a2a:	01 d0                	add    %edx,%eax
   10a2c:	3b 45 18             	cmp    0x18(%ebp),%eax
   10a2f:	73 12                	jae    10a43 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
   10a31:	8b 45 14             	mov    0x14(%ebp),%eax
   10a34:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
   10a3b:	00 00 00 
   10a3e:	e9 f7 05 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
   10a43:	83 ec 0c             	sub    $0xc,%esp
   10a46:	ff 75 f0             	pushl  -0x10(%ebp)
   10a49:	e8 7c 8a ff ff       	call   94ca <lodepng_chunk_data_const>
   10a4e:	83 c4 10             	add    $0x10,%esp
   10a51:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
   10a54:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
   10a5b:	83 ec 08             	sub    $0x8,%esp
   10a5e:	68 64 b1 01 00       	push   $0x1b164
   10a63:	ff 75 f0             	pushl  -0x10(%ebp)
   10a66:	e8 74 89 ff ff       	call   93df <lodepng_chunk_type_equals>
   10a6b:	83 c4 10             	add    $0x10,%esp
   10a6e:	84 c0                	test   %al,%al
   10a70:	74 79                	je     10aeb <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
   10a72:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10a75:	83 ec 04             	sub    $0x4,%esp
   10a78:	8d 55 bc             	lea    -0x44(%ebp),%edx
   10a7b:	52                   	push   %edx
   10a7c:	50                   	push   %eax
   10a7d:	ff 75 ec             	pushl  -0x14(%ebp)
   10a80:	e8 4f 3a ff ff       	call   44d4 <lodepng_addofl>
   10a85:	83 c4 10             	add    $0x10,%esp
   10a88:	85 c0                	test   %eax,%eax
   10a8a:	74 12                	je     10a9e <decodeGeneric+0x209>
   10a8c:	8b 45 14             	mov    0x14(%ebp),%eax
   10a8f:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   10a96:	00 00 00 
   10a99:	e9 9c 05 00 00       	jmp    1103a <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
   10a9e:	8b 45 bc             	mov    -0x44(%ebp),%eax
   10aa1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   10aa4:	7e 13                	jle    10ab9 <decodeGeneric+0x224>
   10aa6:	8b 45 14             	mov    0x14(%ebp),%eax
   10aa9:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   10ab0:	00 00 00 
   10ab3:	90                   	nop
   10ab4:	e9 81 05 00 00       	jmp    1103a <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
   10ab9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10abc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   10abf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10ac2:	01 ca                	add    %ecx,%edx
   10ac4:	83 ec 04             	sub    $0x4,%esp
   10ac7:	50                   	push   %eax
   10ac8:	ff 75 d0             	pushl  -0x30(%ebp)
   10acb:	52                   	push   %edx
   10acc:	e8 7d 39 ff ff       	call   444e <lodepng_memcpy>
   10ad1:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
   10ad4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10ad7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10ada:	01 d0                	add    %edx,%eax
   10adc:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
   10adf:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
   10ae6:	e9 db 04 00 00       	jmp    10fc6 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
   10aeb:	83 ec 08             	sub    $0x8,%esp
   10aee:	68 69 b1 01 00       	push   $0x1b169
   10af3:	ff 75 f0             	pushl  -0x10(%ebp)
   10af6:	e8 e4 88 ff ff       	call   93df <lodepng_chunk_type_equals>
   10afb:	83 c4 10             	add    $0x10,%esp
   10afe:	84 c0                	test   %al,%al
   10b00:	74 09                	je     10b0b <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
   10b02:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
   10b06:	e9 bb 04 00 00       	jmp    10fc6 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   10b0b:	83 ec 08             	sub    $0x8,%esp
   10b0e:	68 28 b1 01 00       	push   $0x1b128
   10b13:	ff 75 f0             	pushl  -0x10(%ebp)
   10b16:	e8 c4 88 ff ff       	call   93df <lodepng_chunk_type_equals>
   10b1b:	83 c4 10             	add    $0x10,%esp
   10b1e:	84 c0                	test   %al,%al
   10b20:	74 44                	je     10b66 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   10b22:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10b25:	8b 55 14             	mov    0x14(%ebp),%edx
   10b28:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   10b2e:	83 ec 04             	sub    $0x4,%esp
   10b31:	50                   	push   %eax
   10b32:	ff 75 d0             	pushl  -0x30(%ebp)
   10b35:	52                   	push   %edx
   10b36:	e8 ec e8 ff ff       	call   f427 <readChunk_PLTE>
   10b3b:	83 c4 10             	add    $0x10,%esp
   10b3e:	89 c2                	mov    %eax,%edx
   10b40:	8b 45 14             	mov    0x14(%ebp),%eax
   10b43:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10b49:	8b 45 14             	mov    0x14(%ebp),%eax
   10b4c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10b52:	85 c0                	test   %eax,%eax
   10b54:	0f 85 dc 04 00 00    	jne    11036 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
   10b5a:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
   10b61:	e9 60 04 00 00       	jmp    10fc6 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   10b66:	83 ec 08             	sub    $0x8,%esp
   10b69:	68 2d b1 01 00       	push   $0x1b12d
   10b6e:	ff 75 f0             	pushl  -0x10(%ebp)
   10b71:	e8 69 88 ff ff       	call   93df <lodepng_chunk_type_equals>
   10b76:	83 c4 10             	add    $0x10,%esp
   10b79:	84 c0                	test   %al,%al
   10b7b:	74 3d                	je     10bba <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   10b7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10b80:	8b 55 14             	mov    0x14(%ebp),%edx
   10b83:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   10b89:	83 ec 04             	sub    $0x4,%esp
   10b8c:	50                   	push   %eax
   10b8d:	ff 75 d0             	pushl  -0x30(%ebp)
   10b90:	52                   	push   %edx
   10b91:	e8 b1 e9 ff ff       	call   f547 <readChunk_tRNS>
   10b96:	83 c4 10             	add    $0x10,%esp
   10b99:	89 c2                	mov    %eax,%edx
   10b9b:	8b 45 14             	mov    0x14(%ebp),%eax
   10b9e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10ba4:	8b 45 14             	mov    0x14(%ebp),%eax
   10ba7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10bad:	85 c0                	test   %eax,%eax
   10baf:	0f 84 11 04 00 00    	je     10fc6 <decodeGeneric+0x731>
   10bb5:	e9 80 04 00 00       	jmp    1103a <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   10bba:	83 ec 08             	sub    $0x8,%esp
   10bbd:	68 32 b1 01 00       	push   $0x1b132
   10bc2:	ff 75 f0             	pushl  -0x10(%ebp)
   10bc5:	e8 15 88 ff ff       	call   93df <lodepng_chunk_type_equals>
   10bca:	83 c4 10             	add    $0x10,%esp
   10bcd:	84 c0                	test   %al,%al
   10bcf:	74 3d                	je     10c0e <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
   10bd1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10bd4:	8b 55 14             	mov    0x14(%ebp),%edx
   10bd7:	81 c2 98 00 00 00    	add    $0x98,%edx
   10bdd:	83 ec 04             	sub    $0x4,%esp
   10be0:	50                   	push   %eax
   10be1:	ff 75 d0             	pushl  -0x30(%ebp)
   10be4:	52                   	push   %edx
   10be5:	e8 c0 ea ff ff       	call   f6aa <readChunk_bKGD>
   10bea:	83 c4 10             	add    $0x10,%esp
   10bed:	89 c2                	mov    %eax,%edx
   10bef:	8b 45 14             	mov    0x14(%ebp),%eax
   10bf2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10bf8:	8b 45 14             	mov    0x14(%ebp),%eax
   10bfb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10c01:	85 c0                	test   %eax,%eax
   10c03:	0f 84 bd 03 00 00    	je     10fc6 <decodeGeneric+0x731>
   10c09:	e9 2c 04 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   10c0e:	83 ec 08             	sub    $0x8,%esp
   10c11:	68 37 b1 01 00       	push   $0x1b137
   10c16:	ff 75 f0             	pushl  -0x10(%ebp)
   10c19:	e8 c1 87 ff ff       	call   93df <lodepng_chunk_type_equals>
   10c1e:	83 c4 10             	add    $0x10,%esp
   10c21:	84 c0                	test   %al,%al
   10c23:	74 4b                	je     10c70 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
   10c25:	8b 45 14             	mov    0x14(%ebp),%eax
   10c28:	8b 40 28             	mov    0x28(%eax),%eax
   10c2b:	85 c0                	test   %eax,%eax
   10c2d:	0f 84 93 03 00 00    	je     10fc6 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
   10c33:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10c36:	8b 55 14             	mov    0x14(%ebp),%edx
   10c39:	81 c2 98 00 00 00    	add    $0x98,%edx
   10c3f:	83 ec 04             	sub    $0x4,%esp
   10c42:	50                   	push   %eax
   10c43:	ff 75 d0             	pushl  -0x30(%ebp)
   10c46:	52                   	push   %edx
   10c47:	e8 e1 eb ff ff       	call   f82d <readChunk_tEXt>
   10c4c:	83 c4 10             	add    $0x10,%esp
   10c4f:	89 c2                	mov    %eax,%edx
   10c51:	8b 45 14             	mov    0x14(%ebp),%eax
   10c54:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   10c5a:	8b 45 14             	mov    0x14(%ebp),%eax
   10c5d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10c63:	85 c0                	test   %eax,%eax
   10c65:	0f 84 5b 03 00 00    	je     10fc6 <decodeGeneric+0x731>
   10c6b:	e9 ca 03 00 00       	jmp    1103a <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   10c70:	83 ec 08             	sub    $0x8,%esp
   10c73:	68 3c b1 01 00       	push   $0x1b13c
   10c78:	ff 75 f0             	pushl  -0x10(%ebp)
   10c7b:	e8 5f 87 ff ff       	call   93df <lodepng_chunk_type_equals>
   10c80:	83 c4 10             	add    $0x10,%esp
   10c83:	84 c0                	test   %al,%al
   10c85:	74 4c                	je     10cd3 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
   10c87:	8b 45 14             	mov    0x14(%ebp),%eax
   10c8a:	8b 40 28             	mov    0x28(%eax),%eax
   10c8d:	85 c0                	test   %eax,%eax
   10c8f:	0f 84 31 03 00 00    	je     10fc6 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   10c95:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10c98:	8b 45 14             	mov    0x14(%ebp),%eax
   10c9b:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10c9e:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10ca4:	52                   	push   %edx
   10ca5:	ff 75 d0             	pushl  -0x30(%ebp)
   10ca8:	50                   	push   %eax
   10ca9:	51                   	push   %ecx
   10caa:	e8 ca ec ff ff       	call   f979 <readChunk_zTXt>
   10caf:	83 c4 10             	add    $0x10,%esp
   10cb2:	89 c2                	mov    %eax,%edx
   10cb4:	8b 45 14             	mov    0x14(%ebp),%eax
   10cb7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   10cbd:	8b 45 14             	mov    0x14(%ebp),%eax
   10cc0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10cc6:	85 c0                	test   %eax,%eax
   10cc8:	0f 84 f8 02 00 00    	je     10fc6 <decodeGeneric+0x731>
   10cce:	e9 67 03 00 00       	jmp    1103a <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   10cd3:	83 ec 08             	sub    $0x8,%esp
   10cd6:	68 41 b1 01 00       	push   $0x1b141
   10cdb:	ff 75 f0             	pushl  -0x10(%ebp)
   10cde:	e8 fc 86 ff ff       	call   93df <lodepng_chunk_type_equals>
   10ce3:	83 c4 10             	add    $0x10,%esp
   10ce6:	84 c0                	test   %al,%al
   10ce8:	74 4c                	je     10d36 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
   10cea:	8b 45 14             	mov    0x14(%ebp),%eax
   10ced:	8b 40 28             	mov    0x28(%eax),%eax
   10cf0:	85 c0                	test   %eax,%eax
   10cf2:	0f 84 ce 02 00 00    	je     10fc6 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   10cf8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10cfb:	8b 45 14             	mov    0x14(%ebp),%eax
   10cfe:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10d01:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10d07:	52                   	push   %edx
   10d08:	ff 75 d0             	pushl  -0x30(%ebp)
   10d0b:	50                   	push   %eax
   10d0c:	51                   	push   %ecx
   10d0d:	e8 23 ee ff ff       	call   fb35 <readChunk_iTXt>
   10d12:	83 c4 10             	add    $0x10,%esp
   10d15:	89 c2                	mov    %eax,%edx
   10d17:	8b 45 14             	mov    0x14(%ebp),%eax
   10d1a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   10d20:	8b 45 14             	mov    0x14(%ebp),%eax
   10d23:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10d29:	85 c0                	test   %eax,%eax
   10d2b:	0f 84 95 02 00 00    	je     10fc6 <decodeGeneric+0x731>
   10d31:	e9 04 03 00 00       	jmp    1103a <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   10d36:	83 ec 08             	sub    $0x8,%esp
   10d39:	68 46 b1 01 00       	push   $0x1b146
   10d3e:	ff 75 f0             	pushl  -0x10(%ebp)
   10d41:	e8 99 86 ff ff       	call   93df <lodepng_chunk_type_equals>
   10d46:	83 c4 10             	add    $0x10,%esp
   10d49:	84 c0                	test   %al,%al
   10d4b:	74 3d                	je     10d8a <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   10d4d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10d50:	8b 55 14             	mov    0x14(%ebp),%edx
   10d53:	81 c2 98 00 00 00    	add    $0x98,%edx
   10d59:	83 ec 04             	sub    $0x4,%esp
   10d5c:	50                   	push   %eax
   10d5d:	ff 75 d0             	pushl  -0x30(%ebp)
   10d60:	52                   	push   %edx
   10d61:	e8 25 f1 ff ff       	call   fe8b <readChunk_tIME>
   10d66:	83 c4 10             	add    $0x10,%esp
   10d69:	89 c2                	mov    %eax,%edx
   10d6b:	8b 45 14             	mov    0x14(%ebp),%eax
   10d6e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10d74:	8b 45 14             	mov    0x14(%ebp),%eax
   10d77:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10d7d:	85 c0                	test   %eax,%eax
   10d7f:	0f 84 41 02 00 00    	je     10fc6 <decodeGeneric+0x731>
   10d85:	e9 b0 02 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   10d8a:	83 ec 08             	sub    $0x8,%esp
   10d8d:	68 4b b1 01 00       	push   $0x1b14b
   10d92:	ff 75 f0             	pushl  -0x10(%ebp)
   10d95:	e8 45 86 ff ff       	call   93df <lodepng_chunk_type_equals>
   10d9a:	83 c4 10             	add    $0x10,%esp
   10d9d:	84 c0                	test   %al,%al
   10d9f:	74 3d                	je     10dde <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   10da1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10da4:	8b 55 14             	mov    0x14(%ebp),%edx
   10da7:	81 c2 98 00 00 00    	add    $0x98,%edx
   10dad:	83 ec 04             	sub    $0x4,%esp
   10db0:	50                   	push   %eax
   10db1:	ff 75 d0             	pushl  -0x30(%ebp)
   10db4:	52                   	push   %edx
   10db5:	e8 71 f1 ff ff       	call   ff2b <readChunk_pHYs>
   10dba:	83 c4 10             	add    $0x10,%esp
   10dbd:	89 c2                	mov    %eax,%edx
   10dbf:	8b 45 14             	mov    0x14(%ebp),%eax
   10dc2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10dc8:	8b 45 14             	mov    0x14(%ebp),%eax
   10dcb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10dd1:	85 c0                	test   %eax,%eax
   10dd3:	0f 84 ed 01 00 00    	je     10fc6 <decodeGeneric+0x731>
   10dd9:	e9 5c 02 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   10dde:	83 ec 08             	sub    $0x8,%esp
   10de1:	68 50 b1 01 00       	push   $0x1b150
   10de6:	ff 75 f0             	pushl  -0x10(%ebp)
   10de9:	e8 f1 85 ff ff       	call   93df <lodepng_chunk_type_equals>
   10dee:	83 c4 10             	add    $0x10,%esp
   10df1:	84 c0                	test   %al,%al
   10df3:	74 3d                	je     10e32 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   10df5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10df8:	8b 55 14             	mov    0x14(%ebp),%edx
   10dfb:	81 c2 98 00 00 00    	add    $0x98,%edx
   10e01:	83 ec 04             	sub    $0x4,%esp
   10e04:	50                   	push   %eax
   10e05:	ff 75 d0             	pushl  -0x30(%ebp)
   10e08:	52                   	push   %edx
   10e09:	e8 ec f1 ff ff       	call   fffa <readChunk_gAMA>
   10e0e:	83 c4 10             	add    $0x10,%esp
   10e11:	89 c2                	mov    %eax,%edx
   10e13:	8b 45 14             	mov    0x14(%ebp),%eax
   10e16:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10e1c:	8b 45 14             	mov    0x14(%ebp),%eax
   10e1f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10e25:	85 c0                	test   %eax,%eax
   10e27:	0f 84 99 01 00 00    	je     10fc6 <decodeGeneric+0x731>
   10e2d:	e9 08 02 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   10e32:	83 ec 08             	sub    $0x8,%esp
   10e35:	68 55 b1 01 00       	push   $0x1b155
   10e3a:	ff 75 f0             	pushl  -0x10(%ebp)
   10e3d:	e8 9d 85 ff ff       	call   93df <lodepng_chunk_type_equals>
   10e42:	83 c4 10             	add    $0x10,%esp
   10e45:	84 c0                	test   %al,%al
   10e47:	74 3d                	je     10e86 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   10e49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10e4c:	8b 55 14             	mov    0x14(%ebp),%edx
   10e4f:	81 c2 98 00 00 00    	add    $0x98,%edx
   10e55:	83 ec 04             	sub    $0x4,%esp
   10e58:	50                   	push   %eax
   10e59:	ff 75 d0             	pushl  -0x30(%ebp)
   10e5c:	52                   	push   %edx
   10e5d:	e8 07 f2 ff ff       	call   10069 <readChunk_cHRM>
   10e62:	83 c4 10             	add    $0x10,%esp
   10e65:	89 c2                	mov    %eax,%edx
   10e67:	8b 45 14             	mov    0x14(%ebp),%eax
   10e6a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10e70:	8b 45 14             	mov    0x14(%ebp),%eax
   10e73:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10e79:	85 c0                	test   %eax,%eax
   10e7b:	0f 84 45 01 00 00    	je     10fc6 <decodeGeneric+0x731>
   10e81:	e9 b4 01 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   10e86:	83 ec 08             	sub    $0x8,%esp
   10e89:	68 5a b1 01 00       	push   $0x1b15a
   10e8e:	ff 75 f0             	pushl  -0x10(%ebp)
   10e91:	e8 49 85 ff ff       	call   93df <lodepng_chunk_type_equals>
   10e96:	83 c4 10             	add    $0x10,%esp
   10e99:	84 c0                	test   %al,%al
   10e9b:	74 3d                	je     10eda <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10e9d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10ea0:	8b 55 14             	mov    0x14(%ebp),%edx
   10ea3:	81 c2 98 00 00 00    	add    $0x98,%edx
   10ea9:	83 ec 04             	sub    $0x4,%esp
   10eac:	50                   	push   %eax
   10ead:	ff 75 d0             	pushl  -0x30(%ebp)
   10eb0:	52                   	push   %edx
   10eb1:	e8 47 f4 ff ff       	call   102fd <readChunk_sRGB>
   10eb6:	83 c4 10             	add    $0x10,%esp
   10eb9:	89 c2                	mov    %eax,%edx
   10ebb:	8b 45 14             	mov    0x14(%ebp),%eax
   10ebe:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10ec4:	8b 45 14             	mov    0x14(%ebp),%eax
   10ec7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10ecd:	85 c0                	test   %eax,%eax
   10ecf:	0f 84 f1 00 00 00    	je     10fc6 <decodeGeneric+0x731>
   10ed5:	e9 60 01 00 00       	jmp    1103a <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   10eda:	83 ec 08             	sub    $0x8,%esp
   10edd:	68 5f b1 01 00       	push   $0x1b15f
   10ee2:	ff 75 f0             	pushl  -0x10(%ebp)
   10ee5:	e8 f5 84 ff ff       	call   93df <lodepng_chunk_type_equals>
   10eea:	83 c4 10             	add    $0x10,%esp
   10eed:	84 c0                	test   %al,%al
   10eef:	74 3e                	je     10f2f <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   10ef1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10ef4:	8b 45 14             	mov    0x14(%ebp),%eax
   10ef7:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10efa:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10f00:	52                   	push   %edx
   10f01:	ff 75 d0             	pushl  -0x30(%ebp)
   10f04:	50                   	push   %eax
   10f05:	51                   	push   %ecx
   10f06:	e8 28 f4 ff ff       	call   10333 <readChunk_iCCP>
   10f0b:	83 c4 10             	add    $0x10,%esp
   10f0e:	89 c2                	mov    %eax,%edx
   10f10:	8b 45 14             	mov    0x14(%ebp),%eax
   10f13:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10f19:	8b 45 14             	mov    0x14(%ebp),%eax
   10f1c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10f22:	85 c0                	test   %eax,%eax
   10f24:	0f 84 9c 00 00 00    	je     10fc6 <decodeGeneric+0x731>
   10f2a:	e9 0b 01 00 00       	jmp    1103a <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   10f2f:	8b 45 14             	mov    0x14(%ebp),%eax
   10f32:	8b 40 1c             	mov    0x1c(%eax),%eax
   10f35:	85 c0                	test   %eax,%eax
   10f37:	75 24                	jne    10f5d <decodeGeneric+0x6c8>
   10f39:	83 ec 0c             	sub    $0xc,%esp
   10f3c:	ff 75 f0             	pushl  -0x10(%ebp)
   10f3f:	e8 30 85 ff ff       	call   9474 <lodepng_chunk_ancillary>
   10f44:	83 c4 10             	add    $0x10,%esp
   10f47:	84 c0                	test   %al,%al
   10f49:	75 12                	jne    10f5d <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   10f4b:	8b 45 14             	mov    0x14(%ebp),%eax
   10f4e:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   10f55:	00 00 00 
   10f58:	e9 dd 00 00 00       	jmp    1103a <decodeGeneric+0x7a5>
      }

      unknown = 1;
   10f5d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   10f64:	8b 45 14             	mov    0x14(%ebp),%eax
   10f67:	8b 40 2c             	mov    0x2c(%eax),%eax
   10f6a:	85 c0                	test   %eax,%eax
   10f6c:	74 58                	je     10fc6 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   10f6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f71:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   10f74:	83 c0 58             	add    $0x58,%eax
   10f77:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10f7e:	8b 45 14             	mov    0x14(%ebp),%eax
   10f81:	01 d0                	add    %edx,%eax
   10f83:	8d 50 10             	lea    0x10(%eax),%edx
   10f86:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f89:	83 e8 01             	sub    $0x1,%eax
   10f8c:	83 c0 54             	add    $0x54,%eax
   10f8f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10f96:	8b 45 14             	mov    0x14(%ebp),%eax
   10f99:	01 c8                	add    %ecx,%eax
   10f9b:	83 c0 14             	add    $0x14,%eax
   10f9e:	83 ec 04             	sub    $0x4,%esp
   10fa1:	ff 75 f0             	pushl  -0x10(%ebp)
   10fa4:	52                   	push   %edx
   10fa5:	50                   	push   %eax
   10fa6:	e8 15 88 ff ff       	call   97c0 <lodepng_chunk_append>
   10fab:	83 c4 10             	add    $0x10,%esp
   10fae:	89 c2                	mov    %eax,%edx
   10fb0:	8b 45 14             	mov    0x14(%ebp),%eax
   10fb3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10fb9:	8b 45 14             	mov    0x14(%ebp),%eax
   10fbc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10fc2:	85 c0                	test   %eax,%eax
   10fc4:	75 73                	jne    11039 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   10fc6:	8b 45 14             	mov    0x14(%ebp),%eax
   10fc9:	8b 40 18             	mov    0x18(%eax),%eax
   10fcc:	85 c0                	test   %eax,%eax
   10fce:	75 27                	jne    10ff7 <decodeGeneric+0x762>
   10fd0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10fd4:	75 21                	jne    10ff7 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   10fd6:	83 ec 0c             	sub    $0xc,%esp
   10fd9:	ff 75 f0             	pushl  -0x10(%ebp)
   10fdc:	e8 f4 84 ff ff       	call   94d5 <lodepng_chunk_check_crc>
   10fe1:	83 c4 10             	add    $0x10,%esp
   10fe4:	85 c0                	test   %eax,%eax
   10fe6:	74 0f                	je     10ff7 <decodeGeneric+0x762>
   10fe8:	8b 45 14             	mov    0x14(%ebp),%eax
   10feb:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   10ff2:	00 00 00 
   10ff5:	eb 43                	jmp    1103a <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   10ff7:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10ffb:	75 1a                	jne    11017 <decodeGeneric+0x782>
   10ffd:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11000:	8b 45 18             	mov    0x18(%ebp),%eax
   11003:	01 d0                	add    %edx,%eax
   11005:	83 ec 08             	sub    $0x8,%esp
   11008:	50                   	push   %eax
   11009:	ff 75 f0             	pushl  -0x10(%ebp)
   1100c:	e8 3f 86 ff ff       	call   9650 <lodepng_chunk_next_const>
   11011:	83 c4 10             	add    $0x10,%esp
   11014:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   11017:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   1101b:	75 1d                	jne    1103a <decodeGeneric+0x7a5>
   1101d:	8b 45 14             	mov    0x14(%ebp),%eax
   11020:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11026:	85 c0                	test   %eax,%eax
   11028:	0f 84 68 f9 ff ff    	je     10996 <decodeGeneric+0x101>
   1102e:	eb 0a                	jmp    1103a <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   11030:	90                   	nop
   11031:	eb 07                	jmp    1103a <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   11033:	90                   	nop
   11034:	eb 04                	jmp    1103a <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   11036:	90                   	nop
   11037:	eb 01                	jmp    1103a <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   11039:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   1103a:	8b 45 14             	mov    0x14(%ebp),%eax
   1103d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11043:	85 c0                	test   %eax,%eax
   11045:	75 28                	jne    1106f <decodeGeneric+0x7da>
   11047:	8b 45 14             	mov    0x14(%ebp),%eax
   1104a:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   11050:	83 f8 03             	cmp    $0x3,%eax
   11053:	75 1a                	jne    1106f <decodeGeneric+0x7da>
   11055:	8b 45 14             	mov    0x14(%ebp),%eax
   11058:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1105e:	85 c0                	test   %eax,%eax
   11060:	75 0d                	jne    1106f <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   11062:	8b 45 14             	mov    0x14(%ebp),%eax
   11065:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   1106c:	00 00 00 
  }

  if(!state->error) {
   1106f:	8b 45 14             	mov    0x14(%ebp),%eax
   11072:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11078:	85 c0                	test   %eax,%eax
   1107a:	0f 85 d2 01 00 00    	jne    11252 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   11080:	8b 45 14             	mov    0x14(%ebp),%eax
   11083:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11089:	85 c0                	test   %eax,%eax
   1108b:	75 3a                	jne    110c7 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   1108d:	8b 45 14             	mov    0x14(%ebp),%eax
   11090:	05 a4 00 00 00       	add    $0xa4,%eax
   11095:	83 ec 0c             	sub    $0xc,%esp
   11098:	50                   	push   %eax
   11099:	e8 8e 8e ff ff       	call   9f2c <lodepng_get_bpp>
   1109e:	83 c4 10             	add    $0x10,%esp
   110a1:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   110a4:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   110a7:	8b 45 10             	mov    0x10(%ebp),%eax
   110aa:	8b 10                	mov    (%eax),%edx
   110ac:	8b 45 0c             	mov    0xc(%ebp),%eax
   110af:	8b 00                	mov    (%eax),%eax
   110b1:	83 ec 04             	sub    $0x4,%esp
   110b4:	51                   	push   %ecx
   110b5:	52                   	push   %edx
   110b6:	50                   	push   %eax
   110b7:	e8 cf 8f ff ff       	call   a08b <lodepng_get_raw_size_idat>
   110bc:	83 c4 10             	add    $0x10,%esp
   110bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
   110c2:	e9 60 01 00 00       	jmp    11227 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   110c7:	8b 45 14             	mov    0x14(%ebp),%eax
   110ca:	05 a4 00 00 00       	add    $0xa4,%eax
   110cf:	83 ec 0c             	sub    $0xc,%esp
   110d2:	50                   	push   %eax
   110d3:	e8 54 8e ff ff       	call   9f2c <lodepng_get_bpp>
   110d8:	83 c4 10             	add    $0x10,%esp
   110db:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   110de:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   110e5:	8b 45 c8             	mov    -0x38(%ebp),%eax
   110e8:	8b 55 10             	mov    0x10(%ebp),%edx
   110eb:	8b 12                	mov    (%edx),%edx
   110ed:	83 c2 07             	add    $0x7,%edx
   110f0:	89 d1                	mov    %edx,%ecx
   110f2:	c1 e9 03             	shr    $0x3,%ecx
   110f5:	8b 55 0c             	mov    0xc(%ebp),%edx
   110f8:	8b 12                	mov    (%edx),%edx
   110fa:	83 c2 07             	add    $0x7,%edx
   110fd:	c1 ea 03             	shr    $0x3,%edx
   11100:	83 ec 04             	sub    $0x4,%esp
   11103:	50                   	push   %eax
   11104:	51                   	push   %ecx
   11105:	52                   	push   %edx
   11106:	e8 80 8f ff ff       	call   a08b <lodepng_get_raw_size_idat>
   1110b:	83 c4 10             	add    $0x10,%esp
   1110e:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   11111:	8b 45 0c             	mov    0xc(%ebp),%eax
   11114:	8b 00                	mov    (%eax),%eax
   11116:	83 f8 04             	cmp    $0x4,%eax
   11119:	76 2c                	jbe    11147 <decodeGeneric+0x8b2>
   1111b:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1111e:	8b 55 10             	mov    0x10(%ebp),%edx
   11121:	8b 12                	mov    (%edx),%edx
   11123:	83 c2 07             	add    $0x7,%edx
   11126:	89 d1                	mov    %edx,%ecx
   11128:	c1 e9 03             	shr    $0x3,%ecx
   1112b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1112e:	8b 12                	mov    (%edx),%edx
   11130:	83 c2 03             	add    $0x3,%edx
   11133:	c1 ea 03             	shr    $0x3,%edx
   11136:	83 ec 04             	sub    $0x4,%esp
   11139:	50                   	push   %eax
   1113a:	51                   	push   %ecx
   1113b:	52                   	push   %edx
   1113c:	e8 4a 8f ff ff       	call   a08b <lodepng_get_raw_size_idat>
   11141:	83 c4 10             	add    $0x10,%esp
   11144:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   11147:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1114a:	8b 55 10             	mov    0x10(%ebp),%edx
   1114d:	8b 12                	mov    (%edx),%edx
   1114f:	83 c2 03             	add    $0x3,%edx
   11152:	89 d1                	mov    %edx,%ecx
   11154:	c1 e9 03             	shr    $0x3,%ecx
   11157:	8b 55 0c             	mov    0xc(%ebp),%edx
   1115a:	8b 12                	mov    (%edx),%edx
   1115c:	83 c2 03             	add    $0x3,%edx
   1115f:	c1 ea 02             	shr    $0x2,%edx
   11162:	83 ec 04             	sub    $0x4,%esp
   11165:	50                   	push   %eax
   11166:	51                   	push   %ecx
   11167:	52                   	push   %edx
   11168:	e8 1e 8f ff ff       	call   a08b <lodepng_get_raw_size_idat>
   1116d:	83 c4 10             	add    $0x10,%esp
   11170:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   11173:	8b 45 0c             	mov    0xc(%ebp),%eax
   11176:	8b 00                	mov    (%eax),%eax
   11178:	83 f8 02             	cmp    $0x2,%eax
   1117b:	76 2c                	jbe    111a9 <decodeGeneric+0x914>
   1117d:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11180:	8b 55 10             	mov    0x10(%ebp),%edx
   11183:	8b 12                	mov    (%edx),%edx
   11185:	83 c2 03             	add    $0x3,%edx
   11188:	89 d1                	mov    %edx,%ecx
   1118a:	c1 e9 02             	shr    $0x2,%ecx
   1118d:	8b 55 0c             	mov    0xc(%ebp),%edx
   11190:	8b 12                	mov    (%edx),%edx
   11192:	83 c2 01             	add    $0x1,%edx
   11195:	c1 ea 02             	shr    $0x2,%edx
   11198:	83 ec 04             	sub    $0x4,%esp
   1119b:	50                   	push   %eax
   1119c:	51                   	push   %ecx
   1119d:	52                   	push   %edx
   1119e:	e8 e8 8e ff ff       	call   a08b <lodepng_get_raw_size_idat>
   111a3:	83 c4 10             	add    $0x10,%esp
   111a6:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   111a9:	8b 45 c8             	mov    -0x38(%ebp),%eax
   111ac:	8b 55 10             	mov    0x10(%ebp),%edx
   111af:	8b 12                	mov    (%edx),%edx
   111b1:	83 c2 01             	add    $0x1,%edx
   111b4:	89 d1                	mov    %edx,%ecx
   111b6:	c1 e9 02             	shr    $0x2,%ecx
   111b9:	8b 55 0c             	mov    0xc(%ebp),%edx
   111bc:	8b 12                	mov    (%edx),%edx
   111be:	83 c2 01             	add    $0x1,%edx
   111c1:	d1 ea                	shr    %edx
   111c3:	83 ec 04             	sub    $0x4,%esp
   111c6:	50                   	push   %eax
   111c7:	51                   	push   %ecx
   111c8:	52                   	push   %edx
   111c9:	e8 bd 8e ff ff       	call   a08b <lodepng_get_raw_size_idat>
   111ce:	83 c4 10             	add    $0x10,%esp
   111d1:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   111d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   111d7:	8b 00                	mov    (%eax),%eax
   111d9:	83 f8 01             	cmp    $0x1,%eax
   111dc:	76 27                	jbe    11205 <decodeGeneric+0x970>
   111de:	8b 45 c8             	mov    -0x38(%ebp),%eax
   111e1:	8b 55 10             	mov    0x10(%ebp),%edx
   111e4:	8b 12                	mov    (%edx),%edx
   111e6:	83 c2 01             	add    $0x1,%edx
   111e9:	89 d1                	mov    %edx,%ecx
   111eb:	d1 e9                	shr    %ecx
   111ed:	8b 55 0c             	mov    0xc(%ebp),%edx
   111f0:	8b 12                	mov    (%edx),%edx
   111f2:	d1 ea                	shr    %edx
   111f4:	83 ec 04             	sub    $0x4,%esp
   111f7:	50                   	push   %eax
   111f8:	51                   	push   %ecx
   111f9:	52                   	push   %edx
   111fa:	e8 8c 8e ff ff       	call   a08b <lodepng_get_raw_size_idat>
   111ff:	83 c4 10             	add    $0x10,%esp
   11202:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   11205:	8b 55 c8             	mov    -0x38(%ebp),%edx
   11208:	8b 45 10             	mov    0x10(%ebp),%eax
   1120b:	8b 00                	mov    (%eax),%eax
   1120d:	d1 e8                	shr    %eax
   1120f:	89 c1                	mov    %eax,%ecx
   11211:	8b 45 0c             	mov    0xc(%ebp),%eax
   11214:	8b 00                	mov    (%eax),%eax
   11216:	83 ec 04             	sub    $0x4,%esp
   11219:	52                   	push   %edx
   1121a:	51                   	push   %ecx
   1121b:	50                   	push   %eax
   1121c:	e8 6a 8e ff ff       	call   a08b <lodepng_get_raw_size_idat>
   11221:	83 c4 10             	add    $0x10,%esp
   11224:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   11227:	8b 45 14             	mov    0x14(%ebp),%eax
   1122a:	83 ec 08             	sub    $0x8,%esp
   1122d:	50                   	push   %eax
   1122e:	ff 75 ec             	pushl  -0x14(%ebp)
   11231:	ff 75 d8             	pushl  -0x28(%ebp)
   11234:	ff 75 e8             	pushl  -0x18(%ebp)
   11237:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1123a:	50                   	push   %eax
   1123b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   1123e:	50                   	push   %eax
   1123f:	e8 87 7c ff ff       	call   8ecb <zlib_decompress>
   11244:	83 c4 20             	add    $0x20,%esp
   11247:	89 c2                	mov    %eax,%edx
   11249:	8b 45 14             	mov    0x14(%ebp),%eax
   1124c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   11252:	8b 45 14             	mov    0x14(%ebp),%eax
   11255:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1125b:	85 c0                	test   %eax,%eax
   1125d:	75 15                	jne    11274 <decodeGeneric+0x9df>
   1125f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11262:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   11265:	74 0d                	je     11274 <decodeGeneric+0x9df>
   11267:	8b 45 14             	mov    0x14(%ebp),%eax
   1126a:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   11271:	00 00 00 
  lodepng_free(idat);
   11274:	83 ec 0c             	sub    $0xc,%esp
   11277:	ff 75 d8             	pushl  -0x28(%ebp)
   1127a:	e8 b2 31 ff ff       	call   4431 <lodepng_free>
   1127f:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   11282:	8b 45 14             	mov    0x14(%ebp),%eax
   11285:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1128b:	85 c0                	test   %eax,%eax
   1128d:	75 4f                	jne    112de <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   1128f:	8b 45 14             	mov    0x14(%ebp),%eax
   11292:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   11298:	8b 45 10             	mov    0x10(%ebp),%eax
   1129b:	8b 10                	mov    (%eax),%edx
   1129d:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a0:	8b 00                	mov    (%eax),%eax
   112a2:	83 ec 04             	sub    $0x4,%esp
   112a5:	51                   	push   %ecx
   112a6:	52                   	push   %edx
   112a7:	50                   	push   %eax
   112a8:	e8 be 8d ff ff       	call   a06b <lodepng_get_raw_size>
   112ad:	83 c4 10             	add    $0x10,%esp
   112b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   112b3:	83 ec 0c             	sub    $0xc,%esp
   112b6:	ff 75 e4             	pushl  -0x1c(%ebp)
   112b9:	e8 52 31 ff ff       	call   4410 <lodepng_malloc>
   112be:	83 c4 10             	add    $0x10,%esp
   112c1:	89 c2                	mov    %eax,%edx
   112c3:	8b 45 08             	mov    0x8(%ebp),%eax
   112c6:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   112c8:	8b 45 08             	mov    0x8(%ebp),%eax
   112cb:	8b 00                	mov    (%eax),%eax
   112cd:	85 c0                	test   %eax,%eax
   112cf:	75 0d                	jne    112de <decodeGeneric+0xa49>
   112d1:	8b 45 14             	mov    0x14(%ebp),%eax
   112d4:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   112db:	00 00 00 
  }
  if(!state->error) {
   112de:	8b 45 14             	mov    0x14(%ebp),%eax
   112e1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   112e7:	85 c0                	test   %eax,%eax
   112e9:	75 4c                	jne    11337 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   112eb:	8b 45 08             	mov    0x8(%ebp),%eax
   112ee:	8b 00                	mov    (%eax),%eax
   112f0:	83 ec 04             	sub    $0x4,%esp
   112f3:	ff 75 e4             	pushl  -0x1c(%ebp)
   112f6:	6a 00                	push   $0x0
   112f8:	50                   	push   %eax
   112f9:	e8 83 31 ff ff       	call   4481 <lodepng_memset>
   112fe:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   11301:	8b 45 14             	mov    0x14(%ebp),%eax
   11304:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   1130a:	8b 45 10             	mov    0x10(%ebp),%eax
   1130d:	8b 18                	mov    (%eax),%ebx
   1130f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11312:	8b 08                	mov    (%eax),%ecx
   11314:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   11317:	8b 45 08             	mov    0x8(%ebp),%eax
   1131a:	8b 00                	mov    (%eax),%eax
   1131c:	83 ec 0c             	sub    $0xc,%esp
   1131f:	56                   	push   %esi
   11320:	53                   	push   %ebx
   11321:	51                   	push   %ecx
   11322:	52                   	push   %edx
   11323:	50                   	push   %eax
   11324:	e8 05 df ff ff       	call   f22e <postProcessScanlines>
   11329:	83 c4 20             	add    $0x20,%esp
   1132c:	89 c2                	mov    %eax,%edx
   1132e:	8b 45 14             	mov    0x14(%ebp),%eax
   11331:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   11337:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1133a:	83 ec 0c             	sub    $0xc,%esp
   1133d:	50                   	push   %eax
   1133e:	e8 ee 30 ff ff       	call   4431 <lodepng_free>
   11343:	83 c4 10             	add    $0x10,%esp
   11346:	eb 01                	jmp    11349 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   11348:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   11349:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1134c:	5b                   	pop    %ebx
   1134d:	5e                   	pop    %esi
   1134e:	5d                   	pop    %ebp
   1134f:	c3                   	ret    

00011350 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   11350:	55                   	push   %ebp
   11351:	89 e5                	mov    %esp,%ebp
   11353:	56                   	push   %esi
   11354:	53                   	push   %ebx
   11355:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   11358:	8b 45 08             	mov    0x8(%ebp),%eax
   1135b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   11361:	83 ec 08             	sub    $0x8,%esp
   11364:	ff 75 1c             	pushl  0x1c(%ebp)
   11367:	ff 75 18             	pushl  0x18(%ebp)
   1136a:	ff 75 14             	pushl  0x14(%ebp)
   1136d:	ff 75 10             	pushl  0x10(%ebp)
   11370:	ff 75 0c             	pushl  0xc(%ebp)
   11373:	ff 75 08             	pushl  0x8(%ebp)
   11376:	e8 1a f5 ff ff       	call   10895 <decodeGeneric>
   1137b:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   1137e:	8b 45 14             	mov    0x14(%ebp),%eax
   11381:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11387:	85 c0                	test   %eax,%eax
   11389:	74 0e                	je     11399 <lodepng_decode+0x49>
   1138b:	8b 45 14             	mov    0x14(%ebp),%eax
   1138e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11394:	e9 55 01 00 00       	jmp    114ee <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   11399:	8b 45 14             	mov    0x14(%ebp),%eax
   1139c:	8b 40 24             	mov    0x24(%eax),%eax
   1139f:	85 c0                	test   %eax,%eax
   113a1:	74 20                	je     113c3 <lodepng_decode+0x73>
   113a3:	8b 45 14             	mov    0x14(%ebp),%eax
   113a6:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   113ac:	8b 45 14             	mov    0x14(%ebp),%eax
   113af:	83 c0 78             	add    $0x78,%eax
   113b2:	83 ec 08             	sub    $0x8,%esp
   113b5:	52                   	push   %edx
   113b6:	50                   	push   %eax
   113b7:	e8 56 89 ff ff       	call   9d12 <lodepng_color_mode_equal>
   113bc:	83 c4 10             	add    $0x10,%esp
   113bf:	85 c0                	test   %eax,%eax
   113c1:	74 54                	je     11417 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   113c3:	8b 45 14             	mov    0x14(%ebp),%eax
   113c6:	8b 40 24             	mov    0x24(%eax),%eax
   113c9:	85 c0                	test   %eax,%eax
   113cb:	0f 85 13 01 00 00    	jne    114e4 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   113d1:	8b 45 14             	mov    0x14(%ebp),%eax
   113d4:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   113da:	8b 45 14             	mov    0x14(%ebp),%eax
   113dd:	83 c0 78             	add    $0x78,%eax
   113e0:	83 ec 08             	sub    $0x8,%esp
   113e3:	52                   	push   %edx
   113e4:	50                   	push   %eax
   113e5:	e8 3f 88 ff ff       	call   9c29 <lodepng_color_mode_copy>
   113ea:	83 c4 10             	add    $0x10,%esp
   113ed:	89 c2                	mov    %eax,%edx
   113ef:	8b 45 14             	mov    0x14(%ebp),%eax
   113f2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   113f8:	8b 45 14             	mov    0x14(%ebp),%eax
   113fb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11401:	85 c0                	test   %eax,%eax
   11403:	0f 84 db 00 00 00    	je     114e4 <lodepng_decode+0x194>
   11409:	8b 45 14             	mov    0x14(%ebp),%eax
   1140c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11412:	e9 d7 00 00 00       	jmp    114ee <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   11417:	8b 45 08             	mov    0x8(%ebp),%eax
   1141a:	8b 00                	mov    (%eax),%eax
   1141c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   1141f:	8b 45 14             	mov    0x14(%ebp),%eax
   11422:	8b 40 78             	mov    0x78(%eax),%eax
   11425:	83 f8 02             	cmp    $0x2,%eax
   11428:	74 20                	je     1144a <lodepng_decode+0xfa>
   1142a:	8b 45 14             	mov    0x14(%ebp),%eax
   1142d:	8b 40 78             	mov    0x78(%eax),%eax
   11430:	83 f8 06             	cmp    $0x6,%eax
   11433:	74 15                	je     1144a <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   11435:	8b 45 14             	mov    0x14(%ebp),%eax
   11438:	8b 40 7c             	mov    0x7c(%eax),%eax
   1143b:	83 f8 08             	cmp    $0x8,%eax
   1143e:	74 0a                	je     1144a <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   11440:	b8 38 00 00 00       	mov    $0x38,%eax
   11445:	e9 a4 00 00 00       	jmp    114ee <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   1144a:	8b 45 14             	mov    0x14(%ebp),%eax
   1144d:	8d 48 78             	lea    0x78(%eax),%ecx
   11450:	8b 45 10             	mov    0x10(%ebp),%eax
   11453:	8b 10                	mov    (%eax),%edx
   11455:	8b 45 0c             	mov    0xc(%ebp),%eax
   11458:	8b 00                	mov    (%eax),%eax
   1145a:	83 ec 04             	sub    $0x4,%esp
   1145d:	51                   	push   %ecx
   1145e:	52                   	push   %edx
   1145f:	50                   	push   %eax
   11460:	e8 06 8c ff ff       	call   a06b <lodepng_get_raw_size>
   11465:	83 c4 10             	add    $0x10,%esp
   11468:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1146b:	83 ec 0c             	sub    $0xc,%esp
   1146e:	ff 75 f0             	pushl  -0x10(%ebp)
   11471:	e8 9a 2f ff ff       	call   4410 <lodepng_malloc>
   11476:	83 c4 10             	add    $0x10,%esp
   11479:	89 c2                	mov    %eax,%edx
   1147b:	8b 45 08             	mov    0x8(%ebp),%eax
   1147e:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   11480:	8b 45 08             	mov    0x8(%ebp),%eax
   11483:	8b 00                	mov    (%eax),%eax
   11485:	85 c0                	test   %eax,%eax
   11487:	75 0f                	jne    11498 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   11489:	8b 45 14             	mov    0x14(%ebp),%eax
   1148c:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   11493:	00 00 00 
   11496:	eb 3c                	jmp    114d4 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   11498:	8b 45 10             	mov    0x10(%ebp),%eax
   1149b:	8b 08                	mov    (%eax),%ecx
   1149d:	8b 45 0c             	mov    0xc(%ebp),%eax
   114a0:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   114a2:	8b 45 14             	mov    0x14(%ebp),%eax
   114a5:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   114ab:	8b 45 14             	mov    0x14(%ebp),%eax
   114ae:	8d 58 78             	lea    0x78(%eax),%ebx
   114b1:	8b 45 08             	mov    0x8(%ebp),%eax
   114b4:	8b 00                	mov    (%eax),%eax
   114b6:	83 ec 08             	sub    $0x8,%esp
   114b9:	51                   	push   %ecx
   114ba:	52                   	push   %edx
   114bb:	56                   	push   %esi
   114bc:	53                   	push   %ebx
   114bd:	ff 75 f4             	pushl  -0xc(%ebp)
   114c0:	50                   	push   %eax
   114c1:	e8 51 b6 ff ff       	call   cb17 <lodepng_convert>
   114c6:	83 c4 20             	add    $0x20,%esp
   114c9:	89 c2                	mov    %eax,%edx
   114cb:	8b 45 14             	mov    0x14(%ebp),%eax
   114ce:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   114d4:	83 ec 0c             	sub    $0xc,%esp
   114d7:	ff 75 f4             	pushl  -0xc(%ebp)
   114da:	e8 52 2f ff ff       	call   4431 <lodepng_free>
   114df:	83 c4 10             	add    $0x10,%esp
   114e2:	eb 01                	jmp    114e5 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   114e4:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   114e5:	8b 45 14             	mov    0x14(%ebp),%eax
   114e8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   114ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
   114f1:	5b                   	pop    %ebx
   114f2:	5e                   	pop    %esi
   114f3:	5d                   	pop    %ebp
   114f4:	c3                   	ret    

000114f5 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   114f5:	55                   	push   %ebp
   114f6:	89 e5                	mov    %esp,%ebp
   114f8:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   114fe:	83 ec 0c             	sub    $0xc,%esp
   11501:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   11507:	50                   	push   %eax
   11508:	e8 d9 01 00 00       	call   116e6 <lodepng_state_init>
   1150d:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   11510:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11513:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   11519:	8b 45 20             	mov    0x20(%ebp),%eax
   1151c:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   11522:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   11529:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   1152c:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   11533:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   11536:	83 ec 08             	sub    $0x8,%esp
   11539:	ff 75 18             	pushl  0x18(%ebp)
   1153c:	ff 75 14             	pushl  0x14(%ebp)
   1153f:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   11545:	50                   	push   %eax
   11546:	ff 75 10             	pushl  0x10(%ebp)
   11549:	ff 75 0c             	pushl  0xc(%ebp)
   1154c:	ff 75 08             	pushl  0x8(%ebp)
   1154f:	e8 fc fd ff ff       	call   11350 <lodepng_decode>
   11554:	83 c4 20             	add    $0x20,%esp
   11557:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1155a:	83 ec 0c             	sub    $0xc,%esp
   1155d:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   11563:	50                   	push   %eax
   11564:	e8 d7 01 00 00       	call   11740 <lodepng_state_cleanup>
   11569:	83 c4 10             	add    $0x10,%esp
  return error;
   1156c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1156f:	c9                   	leave  
   11570:	c3                   	ret    

00011571 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   11571:	55                   	push   %ebp
   11572:	89 e5                	mov    %esp,%ebp
   11574:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   11577:	83 ec 04             	sub    $0x4,%esp
   1157a:	6a 08                	push   $0x8
   1157c:	6a 06                	push   $0x6
   1157e:	ff 75 18             	pushl  0x18(%ebp)
   11581:	ff 75 14             	pushl  0x14(%ebp)
   11584:	ff 75 10             	pushl  0x10(%ebp)
   11587:	ff 75 0c             	pushl  0xc(%ebp)
   1158a:	ff 75 08             	pushl  0x8(%ebp)
   1158d:	e8 63 ff ff ff       	call   114f5 <lodepng_decode_memory>
   11592:	83 c4 20             	add    $0x20,%esp
}
   11595:	c9                   	leave  
   11596:	c3                   	ret    

00011597 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   11597:	55                   	push   %ebp
   11598:	89 e5                	mov    %esp,%ebp
   1159a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   1159d:	83 ec 04             	sub    $0x4,%esp
   115a0:	6a 08                	push   $0x8
   115a2:	6a 02                	push   $0x2
   115a4:	ff 75 18             	pushl  0x18(%ebp)
   115a7:	ff 75 14             	pushl  0x14(%ebp)
   115aa:	ff 75 10             	pushl  0x10(%ebp)
   115ad:	ff 75 0c             	pushl  0xc(%ebp)
   115b0:	ff 75 08             	pushl  0x8(%ebp)
   115b3:	e8 3d ff ff ff       	call   114f5 <lodepng_decode_memory>
   115b8:	83 c4 20             	add    $0x20,%esp
}
   115bb:	c9                   	leave  
   115bc:	c3                   	ret    

000115bd <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   115bd:	55                   	push   %ebp
   115be:	89 e5                	mov    %esp,%ebp
   115c0:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   115c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   115ca:	8b 45 08             	mov    0x8(%ebp),%eax
   115cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   115d3:	8b 45 10             	mov    0x10(%ebp),%eax
   115d6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   115dc:	8b 45 10             	mov    0x10(%ebp),%eax
   115df:	8b 10                	mov    (%eax),%edx
   115e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   115e4:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   115e6:	83 ec 04             	sub    $0x4,%esp
   115e9:	ff 75 14             	pushl  0x14(%ebp)
   115ec:	8d 45 ec             	lea    -0x14(%ebp),%eax
   115ef:	50                   	push   %eax
   115f0:	8d 45 f0             	lea    -0x10(%ebp),%eax
   115f3:	50                   	push   %eax
   115f4:	e8 70 32 ff ff       	call   4869 <lodepng_load_file>
   115f9:	83 c4 10             	add    $0x10,%esp
   115fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   115ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11603:	75 25                	jne    1162a <lodepng_decode_file+0x6d>
   11605:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11608:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1160b:	83 ec 04             	sub    $0x4,%esp
   1160e:	ff 75 1c             	pushl  0x1c(%ebp)
   11611:	ff 75 18             	pushl  0x18(%ebp)
   11614:	52                   	push   %edx
   11615:	50                   	push   %eax
   11616:	ff 75 10             	pushl  0x10(%ebp)
   11619:	ff 75 0c             	pushl  0xc(%ebp)
   1161c:	ff 75 08             	pushl  0x8(%ebp)
   1161f:	e8 d1 fe ff ff       	call   114f5 <lodepng_decode_memory>
   11624:	83 c4 20             	add    $0x20,%esp
   11627:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1162a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1162d:	83 ec 0c             	sub    $0xc,%esp
   11630:	50                   	push   %eax
   11631:	e8 fb 2d ff ff       	call   4431 <lodepng_free>
   11636:	83 c4 10             	add    $0x10,%esp
  return error;
   11639:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1163c:	c9                   	leave  
   1163d:	c3                   	ret    

0001163e <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   1163e:	55                   	push   %ebp
   1163f:	89 e5                	mov    %esp,%ebp
   11641:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   11644:	83 ec 08             	sub    $0x8,%esp
   11647:	6a 08                	push   $0x8
   11649:	6a 06                	push   $0x6
   1164b:	ff 75 14             	pushl  0x14(%ebp)
   1164e:	ff 75 10             	pushl  0x10(%ebp)
   11651:	ff 75 0c             	pushl  0xc(%ebp)
   11654:	ff 75 08             	pushl  0x8(%ebp)
   11657:	e8 61 ff ff ff       	call   115bd <lodepng_decode_file>
   1165c:	83 c4 20             	add    $0x20,%esp
}
   1165f:	c9                   	leave  
   11660:	c3                   	ret    

00011661 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   11661:	55                   	push   %ebp
   11662:	89 e5                	mov    %esp,%ebp
   11664:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   11667:	83 ec 08             	sub    $0x8,%esp
   1166a:	6a 08                	push   $0x8
   1166c:	6a 02                	push   $0x2
   1166e:	ff 75 14             	pushl  0x14(%ebp)
   11671:	ff 75 10             	pushl  0x10(%ebp)
   11674:	ff 75 0c             	pushl  0xc(%ebp)
   11677:	ff 75 08             	pushl  0x8(%ebp)
   1167a:	e8 3e ff ff ff       	call   115bd <lodepng_decode_file>
   1167f:	83 c4 20             	add    $0x20,%esp
}
   11682:	c9                   	leave  
   11683:	c3                   	ret    

00011684 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   11684:	55                   	push   %ebp
   11685:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   11687:	8b 45 08             	mov    0x8(%ebp),%eax
   1168a:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   11691:	8b 45 08             	mov    0x8(%ebp),%eax
   11694:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   1169b:	8b 45 08             	mov    0x8(%ebp),%eax
   1169e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   116a5:	8b 45 08             	mov    0x8(%ebp),%eax
   116a8:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   116af:	8b 45 08             	mov    0x8(%ebp),%eax
   116b2:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   116b9:	8b 45 08             	mov    0x8(%ebp),%eax
   116bc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   116c3:	8b 45 08             	mov    0x8(%ebp),%eax
   116c6:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   116cd:	8b 45 08             	mov    0x8(%ebp),%eax
   116d0:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   116d7:	8b 45 08             	mov    0x8(%ebp),%eax
   116da:	50                   	push   %eax
   116db:	e8 ff 7a ff ff       	call   91df <lodepng_decompress_settings_init>
   116e0:	83 c4 04             	add    $0x4,%esp
}
   116e3:	90                   	nop
   116e4:	c9                   	leave  
   116e5:	c3                   	ret    

000116e6 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   116e6:	55                   	push   %ebp
   116e7:	89 e5                	mov    %esp,%ebp
   116e9:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   116ec:	8b 45 08             	mov    0x8(%ebp),%eax
   116ef:	50                   	push   %eax
   116f0:	e8 8f ff ff ff       	call   11684 <lodepng_decoder_settings_init>
   116f5:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   116f8:	8b 45 08             	mov    0x8(%ebp),%eax
   116fb:	83 c0 38             	add    $0x38,%eax
   116fe:	83 ec 0c             	sub    $0xc,%esp
   11701:	50                   	push   %eax
   11702:	e8 fc 30 00 00       	call   14803 <lodepng_encoder_settings_init>
   11707:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   1170a:	8b 45 08             	mov    0x8(%ebp),%eax
   1170d:	83 c0 78             	add    $0x78,%eax
   11710:	83 ec 0c             	sub    $0xc,%esp
   11713:	50                   	push   %eax
   11714:	e8 06 84 ff ff       	call   9b1f <lodepng_color_mode_init>
   11719:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   1171c:	8b 45 08             	mov    0x8(%ebp),%eax
   1171f:	05 98 00 00 00       	add    $0x98,%eax
   11724:	83 ec 0c             	sub    $0xc,%esp
   11727:	50                   	push   %eax
   11728:	e8 89 93 ff ff       	call   aab6 <lodepng_info_init>
   1172d:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   11730:	8b 45 08             	mov    0x8(%ebp),%eax
   11733:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   1173a:	00 00 00 
}
   1173d:	90                   	nop
   1173e:	c9                   	leave  
   1173f:	c3                   	ret    

00011740 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   11740:	55                   	push   %ebp
   11741:	89 e5                	mov    %esp,%ebp
   11743:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   11746:	8b 45 08             	mov    0x8(%ebp),%eax
   11749:	83 c0 78             	add    $0x78,%eax
   1174c:	83 ec 0c             	sub    $0xc,%esp
   1174f:	50                   	push   %eax
   11750:	e8 bd 84 ff ff       	call   9c12 <lodepng_color_mode_cleanup>
   11755:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   11758:	8b 45 08             	mov    0x8(%ebp),%eax
   1175b:	05 98 00 00 00       	add    $0x98,%eax
   11760:	83 ec 0c             	sub    $0xc,%esp
   11763:	50                   	push   %eax
   11764:	e8 2e 94 ff ff       	call   ab97 <lodepng_info_cleanup>
   11769:	83 c4 10             	add    $0x10,%esp
}
   1176c:	90                   	nop
   1176d:	c9                   	leave  
   1176e:	c3                   	ret    

0001176f <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   1176f:	55                   	push   %ebp
   11770:	89 e5                	mov    %esp,%ebp
   11772:	57                   	push   %edi
   11773:	56                   	push   %esi
   11774:	53                   	push   %ebx
   11775:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   11778:	83 ec 0c             	sub    $0xc,%esp
   1177b:	ff 75 08             	pushl  0x8(%ebp)
   1177e:	e8 bd ff ff ff       	call   11740 <lodepng_state_cleanup>
   11783:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   11786:	8b 55 08             	mov    0x8(%ebp),%edx
   11789:	8b 45 0c             	mov    0xc(%ebp),%eax
   1178c:	89 c3                	mov    %eax,%ebx
   1178e:	b8 60 00 00 00       	mov    $0x60,%eax
   11793:	89 d7                	mov    %edx,%edi
   11795:	89 de                	mov    %ebx,%esi
   11797:	89 c1                	mov    %eax,%ecx
   11799:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   1179b:	8b 45 08             	mov    0x8(%ebp),%eax
   1179e:	83 c0 78             	add    $0x78,%eax
   117a1:	83 ec 0c             	sub    $0xc,%esp
   117a4:	50                   	push   %eax
   117a5:	e8 75 83 ff ff       	call   9b1f <lodepng_color_mode_init>
   117aa:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   117ad:	8b 45 08             	mov    0x8(%ebp),%eax
   117b0:	05 98 00 00 00       	add    $0x98,%eax
   117b5:	83 ec 0c             	sub    $0xc,%esp
   117b8:	50                   	push   %eax
   117b9:	e8 f8 92 ff ff       	call   aab6 <lodepng_info_init>
   117be:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   117c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   117c4:	8d 50 78             	lea    0x78(%eax),%edx
   117c7:	8b 45 08             	mov    0x8(%ebp),%eax
   117ca:	83 c0 78             	add    $0x78,%eax
   117cd:	83 ec 08             	sub    $0x8,%esp
   117d0:	52                   	push   %edx
   117d1:	50                   	push   %eax
   117d2:	e8 52 84 ff ff       	call   9c29 <lodepng_color_mode_copy>
   117d7:	83 c4 10             	add    $0x10,%esp
   117da:	89 c2                	mov    %eax,%edx
   117dc:	8b 45 08             	mov    0x8(%ebp),%eax
   117df:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   117e5:	8b 45 08             	mov    0x8(%ebp),%eax
   117e8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   117ee:	85 c0                	test   %eax,%eax
   117f0:	75 36                	jne    11828 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   117f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   117f5:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   117fb:	8b 45 08             	mov    0x8(%ebp),%eax
   117fe:	05 98 00 00 00       	add    $0x98,%eax
   11803:	83 ec 08             	sub    $0x8,%esp
   11806:	52                   	push   %edx
   11807:	50                   	push   %eax
   11808:	e8 dd 93 ff ff       	call   abea <lodepng_info_copy>
   1180d:	83 c4 10             	add    $0x10,%esp
   11810:	89 c2                	mov    %eax,%edx
   11812:	8b 45 08             	mov    0x8(%ebp),%eax
   11815:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   1181b:	8b 45 08             	mov    0x8(%ebp),%eax
   1181e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11824:	85 c0                	test   %eax,%eax
   11826:	eb 01                	jmp    11829 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   11828:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   11829:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1182c:	5b                   	pop    %ebx
   1182d:	5e                   	pop    %esi
   1182e:	5f                   	pop    %edi
   1182f:	5d                   	pop    %ebp
   11830:	c3                   	ret    

00011831 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   11831:	55                   	push   %ebp
   11832:	89 e5                	mov    %esp,%ebp
   11834:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   11837:	8b 45 08             	mov    0x8(%ebp),%eax
   1183a:	8b 40 04             	mov    0x4(%eax),%eax
   1183d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   11840:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   11844:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   11848:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   1184c:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   11850:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   11854:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   11858:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   1185c:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   11860:	8b 45 08             	mov    0x8(%ebp),%eax
   11863:	8b 40 04             	mov    0x4(%eax),%eax
   11866:	83 c0 08             	add    $0x8,%eax
   11869:	50                   	push   %eax
   1186a:	ff 75 08             	pushl  0x8(%ebp)
   1186d:	e8 f8 2d ff ff       	call   466a <ucvector_resize>
   11872:	83 c4 08             	add    $0x8,%esp
   11875:	85 c0                	test   %eax,%eax
   11877:	75 07                	jne    11880 <writeSignature+0x4f>
   11879:	b8 53 00 00 00       	mov    $0x53,%eax
   1187e:	eb 1e                	jmp    1189e <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   11880:	8b 45 08             	mov    0x8(%ebp),%eax
   11883:	8b 10                	mov    (%eax),%edx
   11885:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11888:	01 c2                	add    %eax,%edx
   1188a:	6a 08                	push   $0x8
   1188c:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1188f:	50                   	push   %eax
   11890:	52                   	push   %edx
   11891:	e8 b8 2b ff ff       	call   444e <lodepng_memcpy>
   11896:	83 c4 0c             	add    $0xc,%esp
  return 0;
   11899:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1189e:	c9                   	leave  
   1189f:	c3                   	ret    

000118a0 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   118a0:	55                   	push   %ebp
   118a1:	89 e5                	mov    %esp,%ebp
   118a3:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   118a6:	68 0c b1 01 00       	push   $0x1b10c
   118ab:	6a 0d                	push   $0xd
   118ad:	ff 75 08             	pushl  0x8(%ebp)
   118b0:	8d 45 f4             	lea    -0xc(%ebp),%eax
   118b3:	50                   	push   %eax
   118b4:	e8 cf 7f ff ff       	call   9888 <lodepng_chunk_init>
   118b9:	83 c4 10             	add    $0x10,%esp
   118bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
   118bf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   118c3:	74 05                	je     118ca <addChunk_IHDR+0x2a>
   118c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   118c8:	eb 6d                	jmp    11937 <addChunk_IHDR+0x97>
  data = chunk + 8;
   118ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118cd:	83 c0 08             	add    $0x8,%eax
   118d0:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   118d3:	ff 75 0c             	pushl  0xc(%ebp)
   118d6:	ff 75 f8             	pushl  -0x8(%ebp)
   118d9:	e8 f3 2e ff ff       	call   47d1 <lodepng_set32bitInt>
   118de:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   118e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   118e4:	83 c0 04             	add    $0x4,%eax
   118e7:	ff 75 10             	pushl  0x10(%ebp)
   118ea:	50                   	push   %eax
   118eb:	e8 e1 2e ff ff       	call   47d1 <lodepng_set32bitInt>
   118f0:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   118f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   118f6:	83 c0 08             	add    $0x8,%eax
   118f9:	8b 55 18             	mov    0x18(%ebp),%edx
   118fc:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   118fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11901:	83 c0 09             	add    $0x9,%eax
   11904:	8b 55 14             	mov    0x14(%ebp),%edx
   11907:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   11909:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1190c:	83 c0 0a             	add    $0xa,%eax
   1190f:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   11912:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11915:	83 c0 0b             	add    $0xb,%eax
   11918:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   1191b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1191e:	83 c0 0c             	add    $0xc,%eax
   11921:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11924:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   11926:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11929:	50                   	push   %eax
   1192a:	e8 02 7c ff ff       	call   9531 <lodepng_chunk_generate_crc>
   1192f:	83 c4 04             	add    $0x4,%esp
  return 0;
   11932:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11937:	c9                   	leave  
   11938:	c3                   	ret    

00011939 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   11939:	55                   	push   %ebp
   1193a:	89 e5                	mov    %esp,%ebp
   1193c:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   1193f:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   11946:	8b 45 0c             	mov    0xc(%ebp),%eax
   11949:	8b 50 0c             	mov    0xc(%eax),%edx
   1194c:	89 d0                	mov    %edx,%eax
   1194e:	01 c0                	add    %eax,%eax
   11950:	01 d0                	add    %edx,%eax
   11952:	68 28 b1 01 00       	push   $0x1b128
   11957:	50                   	push   %eax
   11958:	ff 75 08             	pushl  0x8(%ebp)
   1195b:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1195e:	50                   	push   %eax
   1195f:	e8 24 7f ff ff       	call   9888 <lodepng_chunk_init>
   11964:	83 c4 10             	add    $0x10,%esp
   11967:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1196a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1196e:	74 08                	je     11978 <addChunk_PLTE+0x3f>
   11970:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11973:	e9 95 00 00 00       	jmp    11a0d <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   11978:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1197f:	eb 70                	jmp    119f1 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   11981:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11984:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11987:	8d 50 01             	lea    0x1(%eax),%edx
   1198a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1198d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   11990:	8b 45 0c             	mov    0xc(%ebp),%eax
   11993:	8b 40 08             	mov    0x8(%eax),%eax
   11996:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11999:	c1 e1 02             	shl    $0x2,%ecx
   1199c:	01 c8                	add    %ecx,%eax
   1199e:	0f b6 00             	movzbl (%eax),%eax
   119a1:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   119a3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   119a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   119a9:	8d 50 01             	lea    0x1(%eax),%edx
   119ac:	89 55 f8             	mov    %edx,-0x8(%ebp)
   119af:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   119b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   119b5:	8b 40 08             	mov    0x8(%eax),%eax
   119b8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   119bb:	c1 e1 02             	shl    $0x2,%ecx
   119be:	83 c1 01             	add    $0x1,%ecx
   119c1:	01 c8                	add    %ecx,%eax
   119c3:	0f b6 00             	movzbl (%eax),%eax
   119c6:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   119c8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   119cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   119ce:	8d 50 01             	lea    0x1(%eax),%edx
   119d1:	89 55 f8             	mov    %edx,-0x8(%ebp)
   119d4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   119d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   119da:	8b 40 08             	mov    0x8(%eax),%eax
   119dd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   119e0:	c1 e1 02             	shl    $0x2,%ecx
   119e3:	83 c1 02             	add    $0x2,%ecx
   119e6:	01 c8                	add    %ecx,%eax
   119e8:	0f b6 00             	movzbl (%eax),%eax
   119eb:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   119ed:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   119f1:	8b 45 0c             	mov    0xc(%ebp),%eax
   119f4:	8b 40 0c             	mov    0xc(%eax),%eax
   119f7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   119fa:	75 85                	jne    11981 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   119fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   119ff:	50                   	push   %eax
   11a00:	e8 2c 7b ff ff       	call   9531 <lodepng_chunk_generate_crc>
   11a05:	83 c4 04             	add    $0x4,%esp
  return 0;
   11a08:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11a0d:	c9                   	leave  
   11a0e:	c3                   	ret    

00011a0f <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   11a0f:	55                   	push   %ebp
   11a10:	89 e5                	mov    %esp,%ebp
   11a12:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   11a15:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   11a1c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a1f:	8b 00                	mov    (%eax),%eax
   11a21:	83 f8 03             	cmp    $0x3,%eax
   11a24:	0f 85 ae 00 00 00    	jne    11ad8 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   11a2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a2d:	8b 40 0c             	mov    0xc(%eax),%eax
   11a30:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   11a33:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a36:	8b 40 0c             	mov    0xc(%eax),%eax
   11a39:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11a3c:	eb 23                	jmp    11a61 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   11a3e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a41:	8b 40 08             	mov    0x8(%eax),%eax
   11a44:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11a47:	83 ea 01             	sub    $0x1,%edx
   11a4a:	c1 e2 02             	shl    $0x2,%edx
   11a4d:	83 c2 03             	add    $0x3,%edx
   11a50:	01 d0                	add    %edx,%eax
   11a52:	0f b6 00             	movzbl (%eax),%eax
   11a55:	3c ff                	cmp    $0xff,%al
   11a57:	75 10                	jne    11a69 <addChunk_tRNS+0x5a>
      --amount;
   11a59:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   11a5d:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   11a61:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11a65:	75 d7                	jne    11a3e <addChunk_tRNS+0x2f>
   11a67:	eb 01                	jmp    11a6a <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   11a69:	90                   	nop
      --amount;
    }
    if(amount) {
   11a6a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11a6e:	0f 84 63 01 00 00    	je     11bd7 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   11a74:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a77:	68 2d b1 01 00       	push   $0x1b12d
   11a7c:	50                   	push   %eax
   11a7d:	ff 75 08             	pushl  0x8(%ebp)
   11a80:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11a83:	50                   	push   %eax
   11a84:	e8 ff 7d ff ff       	call   9888 <lodepng_chunk_init>
   11a89:	83 c4 10             	add    $0x10,%esp
   11a8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11a8f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11a93:	74 08                	je     11a9d <addChunk_tRNS+0x8e>
   11a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a98:	e9 52 01 00 00       	jmp    11bef <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   11a9d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   11aa4:	eb 25                	jmp    11acb <addChunk_tRNS+0xbc>
   11aa6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11aa9:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11aac:	83 c2 08             	add    $0x8,%edx
   11aaf:	01 c2                	add    %eax,%edx
   11ab1:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ab4:	8b 40 08             	mov    0x8(%eax),%eax
   11ab7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11aba:	c1 e1 02             	shl    $0x2,%ecx
   11abd:	83 c1 03             	add    $0x3,%ecx
   11ac0:	01 c8                	add    %ecx,%eax
   11ac2:	0f b6 00             	movzbl (%eax),%eax
   11ac5:	88 02                	mov    %al,(%edx)
   11ac7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   11acb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ace:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   11ad1:	75 d3                	jne    11aa6 <addChunk_tRNS+0x97>
   11ad3:	e9 ff 00 00 00       	jmp    11bd7 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   11ad8:	8b 45 0c             	mov    0xc(%ebp),%eax
   11adb:	8b 00                	mov    (%eax),%eax
   11add:	85 c0                	test   %eax,%eax
   11adf:	75 59                	jne    11b3a <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   11ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ae4:	8b 40 10             	mov    0x10(%eax),%eax
   11ae7:	85 c0                	test   %eax,%eax
   11ae9:	0f 84 e8 00 00 00    	je     11bd7 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   11aef:	68 2d b1 01 00       	push   $0x1b12d
   11af4:	6a 02                	push   $0x2
   11af6:	ff 75 08             	pushl  0x8(%ebp)
   11af9:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11afc:	50                   	push   %eax
   11afd:	e8 86 7d ff ff       	call   9888 <lodepng_chunk_init>
   11b02:	83 c4 10             	add    $0x10,%esp
   11b05:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11b08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11b0c:	74 08                	je     11b16 <addChunk_tRNS+0x107>
   11b0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b11:	e9 d9 00 00 00       	jmp    11bef <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   11b16:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b19:	8d 50 08             	lea    0x8(%eax),%edx
   11b1c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b1f:	8b 40 14             	mov    0x14(%eax),%eax
   11b22:	c1 e8 08             	shr    $0x8,%eax
   11b25:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   11b27:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b2a:	8d 50 09             	lea    0x9(%eax),%edx
   11b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b30:	8b 40 14             	mov    0x14(%eax),%eax
   11b33:	88 02                	mov    %al,(%edx)
   11b35:	e9 9d 00 00 00       	jmp    11bd7 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   11b3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b3d:	8b 00                	mov    (%eax),%eax
   11b3f:	83 f8 02             	cmp    $0x2,%eax
   11b42:	0f 85 8f 00 00 00    	jne    11bd7 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   11b48:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b4b:	8b 40 10             	mov    0x10(%eax),%eax
   11b4e:	85 c0                	test   %eax,%eax
   11b50:	0f 84 81 00 00 00    	je     11bd7 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   11b56:	68 2d b1 01 00       	push   $0x1b12d
   11b5b:	6a 06                	push   $0x6
   11b5d:	ff 75 08             	pushl  0x8(%ebp)
   11b60:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11b63:	50                   	push   %eax
   11b64:	e8 1f 7d ff ff       	call   9888 <lodepng_chunk_init>
   11b69:	83 c4 10             	add    $0x10,%esp
   11b6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
   11b6f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11b73:	74 05                	je     11b7a <addChunk_tRNS+0x16b>
   11b75:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b78:	eb 75                	jmp    11bef <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   11b7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b7d:	8d 50 08             	lea    0x8(%eax),%edx
   11b80:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b83:	8b 40 14             	mov    0x14(%eax),%eax
   11b86:	c1 e8 08             	shr    $0x8,%eax
   11b89:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   11b8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b8e:	8d 50 09             	lea    0x9(%eax),%edx
   11b91:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b94:	8b 40 14             	mov    0x14(%eax),%eax
   11b97:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   11b99:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b9c:	8d 50 0a             	lea    0xa(%eax),%edx
   11b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ba2:	8b 40 18             	mov    0x18(%eax),%eax
   11ba5:	c1 e8 08             	shr    $0x8,%eax
   11ba8:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   11baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bad:	8d 50 0b             	lea    0xb(%eax),%edx
   11bb0:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bb3:	8b 40 18             	mov    0x18(%eax),%eax
   11bb6:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   11bb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bbb:	8d 50 0c             	lea    0xc(%eax),%edx
   11bbe:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bc1:	8b 40 1c             	mov    0x1c(%eax),%eax
   11bc4:	c1 e8 08             	shr    $0x8,%eax
   11bc7:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   11bc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bcc:	8d 50 0d             	lea    0xd(%eax),%edx
   11bcf:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bd2:	8b 40 1c             	mov    0x1c(%eax),%eax
   11bd5:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   11bd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bda:	85 c0                	test   %eax,%eax
   11bdc:	74 0c                	je     11bea <addChunk_tRNS+0x1db>
   11bde:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11be1:	50                   	push   %eax
   11be2:	e8 4a 79 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   11be7:	83 c4 04             	add    $0x4,%esp
  return 0;
   11bea:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11bef:	c9                   	leave  
   11bf0:	c3                   	ret    

00011bf1 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   11bf1:	55                   	push   %ebp
   11bf2:	89 e5                	mov    %esp,%ebp
   11bf4:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   11bf7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   11bfe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   11c05:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   11c0c:	83 ec 0c             	sub    $0xc,%esp
   11c0f:	ff 75 14             	pushl  0x14(%ebp)
   11c12:	ff 75 10             	pushl  0x10(%ebp)
   11c15:	ff 75 0c             	pushl  0xc(%ebp)
   11c18:	8d 45 ec             	lea    -0x14(%ebp),%eax
   11c1b:	50                   	push   %eax
   11c1c:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11c1f:	50                   	push   %eax
   11c20:	e8 fb 74 ff ff       	call   9120 <zlib_compress>
   11c25:	83 c4 20             	add    $0x20,%esp
   11c28:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   11c2b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11c2f:	75 1b                	jne    11c4c <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   11c31:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c34:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11c37:	50                   	push   %eax
   11c38:	68 64 b1 01 00       	push   $0x1b164
   11c3d:	52                   	push   %edx
   11c3e:	ff 75 08             	pushl  0x8(%ebp)
   11c41:	e8 ea 7c ff ff       	call   9930 <lodepng_chunk_createv>
   11c46:	83 c4 10             	add    $0x10,%esp
   11c49:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   11c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c4f:	83 ec 0c             	sub    $0xc,%esp
   11c52:	50                   	push   %eax
   11c53:	e8 d9 27 ff ff       	call   4431 <lodepng_free>
   11c58:	83 c4 10             	add    $0x10,%esp
  return error;
   11c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11c5e:	c9                   	leave  
   11c5f:	c3                   	ret    

00011c60 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   11c60:	55                   	push   %ebp
   11c61:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   11c63:	6a 00                	push   $0x0
   11c65:	68 69 b1 01 00       	push   $0x1b169
   11c6a:	6a 00                	push   $0x0
   11c6c:	ff 75 08             	pushl  0x8(%ebp)
   11c6f:	e8 bc 7c ff ff       	call   9930 <lodepng_chunk_createv>
   11c74:	83 c4 10             	add    $0x10,%esp
}
   11c77:	c9                   	leave  
   11c78:	c3                   	ret    

00011c79 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   11c79:	55                   	push   %ebp
   11c7a:	89 e5                	mov    %esp,%ebp
   11c7c:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   11c7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   11c86:	ff 75 0c             	pushl  0xc(%ebp)
   11c89:	e8 1e 28 ff ff       	call   44ac <lodepng_strlen>
   11c8e:	83 c4 04             	add    $0x4,%esp
   11c91:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11c94:	ff 75 10             	pushl  0x10(%ebp)
   11c97:	e8 10 28 ff ff       	call   44ac <lodepng_strlen>
   11c9c:	83 c4 04             	add    $0x4,%esp
   11c9f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   11ca2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ca5:	8d 50 01             	lea    0x1(%eax),%edx
   11ca8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cab:	01 d0                	add    %edx,%eax
   11cad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11cb0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11cb4:	7e 06                	jle    11cbc <addChunk_tEXt+0x43>
   11cb6:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   11cba:	7e 07                	jle    11cc3 <addChunk_tEXt+0x4a>
   11cbc:	b8 59 00 00 00       	mov    $0x59,%eax
   11cc1:	eb 74                	jmp    11d37 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   11cc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cc6:	68 37 b1 01 00       	push   $0x1b137
   11ccb:	50                   	push   %eax
   11ccc:	ff 75 08             	pushl  0x8(%ebp)
   11ccf:	8d 45 ec             	lea    -0x14(%ebp),%eax
   11cd2:	50                   	push   %eax
   11cd3:	e8 b0 7b ff ff       	call   9888 <lodepng_chunk_init>
   11cd8:	83 c4 10             	add    $0x10,%esp
   11cdb:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11cde:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11ce2:	74 05                	je     11ce9 <addChunk_tEXt+0x70>
   11ce4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ce7:	eb 4e                	jmp    11d37 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   11ce9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cec:	83 c0 08             	add    $0x8,%eax
   11cef:	ff 75 fc             	pushl  -0x4(%ebp)
   11cf2:	ff 75 0c             	pushl  0xc(%ebp)
   11cf5:	50                   	push   %eax
   11cf6:	e8 53 27 ff ff       	call   444e <lodepng_memcpy>
   11cfb:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   11cfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d01:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11d04:	83 c2 08             	add    $0x8,%edx
   11d07:	01 d0                	add    %edx,%eax
   11d09:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   11d0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d0f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11d12:	83 c2 09             	add    $0x9,%edx
   11d15:	01 d0                	add    %edx,%eax
   11d17:	ff 75 f8             	pushl  -0x8(%ebp)
   11d1a:	ff 75 10             	pushl  0x10(%ebp)
   11d1d:	50                   	push   %eax
   11d1e:	e8 2b 27 ff ff       	call   444e <lodepng_memcpy>
   11d23:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   11d26:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d29:	50                   	push   %eax
   11d2a:	e8 02 78 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   11d2f:	83 c4 04             	add    $0x4,%esp
  return 0;
   11d32:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11d37:	c9                   	leave  
   11d38:	c3                   	ret    

00011d39 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   11d39:	55                   	push   %ebp
   11d3a:	89 e5                	mov    %esp,%ebp
   11d3c:	53                   	push   %ebx
   11d3d:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11d40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11d47:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   11d4e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   11d55:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11d5c:	ff 75 10             	pushl  0x10(%ebp)
   11d5f:	e8 48 27 ff ff       	call   44ac <lodepng_strlen>
   11d64:	83 c4 04             	add    $0x4,%esp
   11d67:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   11d6a:	ff 75 0c             	pushl  0xc(%ebp)
   11d6d:	e8 3a 27 ff ff       	call   44ac <lodepng_strlen>
   11d72:	83 c4 04             	add    $0x4,%esp
   11d75:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11d78:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11d7c:	7e 06                	jle    11d84 <addChunk_zTXt+0x4b>
   11d7e:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   11d82:	7e 0a                	jle    11d8e <addChunk_zTXt+0x55>
   11d84:	b8 59 00 00 00       	mov    $0x59,%eax
   11d89:	e9 c8 00 00 00       	jmp    11e56 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   11d8e:	83 ec 0c             	sub    $0xc,%esp
   11d91:	ff 75 14             	pushl  0x14(%ebp)
   11d94:	ff 75 f0             	pushl  -0x10(%ebp)
   11d97:	ff 75 10             	pushl  0x10(%ebp)
   11d9a:	8d 45 dc             	lea    -0x24(%ebp),%eax
   11d9d:	50                   	push   %eax
   11d9e:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11da1:	50                   	push   %eax
   11da2:	e8 79 73 ff ff       	call   9120 <zlib_compress>
   11da7:	83 c4 20             	add    $0x20,%esp
   11daa:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   11dad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11db1:	75 29                	jne    11ddc <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   11db3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11db6:	8d 50 02             	lea    0x2(%eax),%edx
   11db9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11dbc:	01 d0                	add    %edx,%eax
   11dbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   11dc1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11dc4:	68 3c b1 01 00       	push   $0x1b13c
   11dc9:	50                   	push   %eax
   11dca:	ff 75 08             	pushl  0x8(%ebp)
   11dcd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11dd0:	50                   	push   %eax
   11dd1:	e8 b2 7a ff ff       	call   9888 <lodepng_chunk_init>
   11dd6:	83 c4 10             	add    $0x10,%esp
   11dd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11ddc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11de0:	75 62                	jne    11e44 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   11de2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11de5:	83 c0 08             	add    $0x8,%eax
   11de8:	83 ec 04             	sub    $0x4,%esp
   11deb:	ff 75 ec             	pushl  -0x14(%ebp)
   11dee:	ff 75 0c             	pushl  0xc(%ebp)
   11df1:	50                   	push   %eax
   11df2:	e8 57 26 ff ff       	call   444e <lodepng_memcpy>
   11df7:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11dfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11dfd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11e00:	83 c2 08             	add    $0x8,%edx
   11e03:	01 d0                	add    %edx,%eax
   11e05:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11e08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e0b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11e0e:	83 c2 09             	add    $0x9,%edx
   11e11:	01 d0                	add    %edx,%eax
   11e13:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11e16:	8b 55 dc             	mov    -0x24(%ebp),%edx
   11e19:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11e1c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11e1f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   11e22:	83 c3 0a             	add    $0xa,%ebx
   11e25:	01 d9                	add    %ebx,%ecx
   11e27:	83 ec 04             	sub    $0x4,%esp
   11e2a:	52                   	push   %edx
   11e2b:	50                   	push   %eax
   11e2c:	51                   	push   %ecx
   11e2d:	e8 1c 26 ff ff       	call   444e <lodepng_memcpy>
   11e32:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11e35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e38:	83 ec 0c             	sub    $0xc,%esp
   11e3b:	50                   	push   %eax
   11e3c:	e8 f0 76 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   11e41:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11e44:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11e47:	83 ec 0c             	sub    $0xc,%esp
   11e4a:	50                   	push   %eax
   11e4b:	e8 e1 25 ff ff       	call   4431 <lodepng_free>
   11e50:	83 c4 10             	add    $0x10,%esp
  return error;
   11e53:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11e56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11e59:	c9                   	leave  
   11e5a:	c3                   	ret    

00011e5b <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   11e5b:	55                   	push   %ebp
   11e5c:	89 e5                	mov    %esp,%ebp
   11e5e:	53                   	push   %ebx
   11e5f:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   11e62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11e69:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   11e70:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   11e77:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11e7e:	ff 75 1c             	pushl  0x1c(%ebp)
   11e81:	e8 26 26 ff ff       	call   44ac <lodepng_strlen>
   11e86:	83 c4 04             	add    $0x4,%esp
   11e89:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   11e8c:	ff 75 10             	pushl  0x10(%ebp)
   11e8f:	e8 18 26 ff ff       	call   44ac <lodepng_strlen>
   11e94:	83 c4 04             	add    $0x4,%esp
   11e97:	89 45 ec             	mov    %eax,-0x14(%ebp)
   11e9a:	ff 75 14             	pushl  0x14(%ebp)
   11e9d:	e8 0a 26 ff ff       	call   44ac <lodepng_strlen>
   11ea2:	83 c4 04             	add    $0x4,%esp
   11ea5:	89 45 e8             	mov    %eax,-0x18(%ebp)
   11ea8:	ff 75 18             	pushl  0x18(%ebp)
   11eab:	e8 fc 25 ff ff       	call   44ac <lodepng_strlen>
   11eb0:	83 c4 04             	add    $0x4,%esp
   11eb3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11eb6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11eba:	7e 06                	jle    11ec2 <addChunk_iTXt+0x67>
   11ebc:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   11ec0:	7e 0a                	jle    11ecc <addChunk_iTXt+0x71>
   11ec2:	b8 59 00 00 00       	mov    $0x59,%eax
   11ec7:	e9 9a 01 00 00       	jmp    12066 <addChunk_iTXt+0x20b>

  if(compress) {
   11ecc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11ed0:	74 1f                	je     11ef1 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   11ed2:	83 ec 0c             	sub    $0xc,%esp
   11ed5:	ff 75 20             	pushl  0x20(%ebp)
   11ed8:	ff 75 f0             	pushl  -0x10(%ebp)
   11edb:	ff 75 1c             	pushl  0x1c(%ebp)
   11ede:	8d 45 d0             	lea    -0x30(%ebp),%eax
   11ee1:	50                   	push   %eax
   11ee2:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   11ee5:	50                   	push   %eax
   11ee6:	e8 35 72 ff ff       	call   9120 <zlib_compress>
   11eeb:	83 c4 20             	add    $0x20,%esp
   11eee:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   11ef1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11ef5:	75 44                	jne    11f3b <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   11ef7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11efa:	8d 50 03             	lea    0x3(%eax),%edx
   11efd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11f00:	01 d0                	add    %edx,%eax
   11f02:	8d 50 01             	lea    0x1(%eax),%edx
   11f05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f08:	01 d0                	add    %edx,%eax
   11f0a:	8d 50 01             	lea    0x1(%eax),%edx
   11f0d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11f11:	74 05                	je     11f18 <addChunk_iTXt+0xbd>
   11f13:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f16:	eb 03                	jmp    11f1b <addChunk_iTXt+0xc0>
   11f18:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f1b:	01 d0                	add    %edx,%eax
   11f1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   11f20:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11f23:	68 41 b1 01 00       	push   $0x1b141
   11f28:	50                   	push   %eax
   11f29:	ff 75 08             	pushl  0x8(%ebp)
   11f2c:	8d 45 d8             	lea    -0x28(%ebp),%eax
   11f2f:	50                   	push   %eax
   11f30:	e8 53 79 ff ff       	call   9888 <lodepng_chunk_init>
   11f35:	83 c4 10             	add    $0x10,%esp
   11f38:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11f3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11f3f:	0f 85 0f 01 00 00    	jne    12054 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   11f45:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   11f4c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11f4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11f52:	01 d0                	add    %edx,%eax
   11f54:	83 ec 04             	sub    $0x4,%esp
   11f57:	ff 75 ec             	pushl  -0x14(%ebp)
   11f5a:	ff 75 10             	pushl  0x10(%ebp)
   11f5d:	50                   	push   %eax
   11f5e:	e8 eb 24 ff ff       	call   444e <lodepng_memcpy>
   11f63:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   11f66:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11f69:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11f6c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11f6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11f72:	8d 50 01             	lea    0x1(%eax),%edx
   11f75:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11f78:	01 c8                	add    %ecx,%eax
   11f7a:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   11f7d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11f80:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11f83:	8d 50 01             	lea    0x1(%eax),%edx
   11f86:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11f89:	01 c8                	add    %ecx,%eax
   11f8b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11f8f:	0f 95 c2             	setne  %dl
   11f92:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   11f94:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11f97:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11f9a:	8d 50 01             	lea    0x1(%eax),%edx
   11f9d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11fa0:	01 c8                	add    %ecx,%eax
   11fa2:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   11fa5:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11fa8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11fab:	01 d0                	add    %edx,%eax
   11fad:	83 ec 04             	sub    $0x4,%esp
   11fb0:	ff 75 e8             	pushl  -0x18(%ebp)
   11fb3:	ff 75 14             	pushl  0x14(%ebp)
   11fb6:	50                   	push   %eax
   11fb7:	e8 92 24 ff ff       	call   444e <lodepng_memcpy>
   11fbc:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   11fbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11fc2:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11fc5:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11fc8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11fcb:	8d 50 01             	lea    0x1(%eax),%edx
   11fce:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11fd1:	01 c8                	add    %ecx,%eax
   11fd3:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   11fd6:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11fd9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11fdc:	01 d0                	add    %edx,%eax
   11fde:	83 ec 04             	sub    $0x4,%esp
   11fe1:	ff 75 e4             	pushl  -0x1c(%ebp)
   11fe4:	ff 75 18             	pushl  0x18(%ebp)
   11fe7:	50                   	push   %eax
   11fe8:	e8 61 24 ff ff       	call   444e <lodepng_memcpy>
   11fed:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   11ff0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ff3:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11ff6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11ff9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11ffc:	8d 50 01             	lea    0x1(%eax),%edx
   11fff:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12002:	01 c8                	add    %ecx,%eax
   12004:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   12007:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1200b:	74 1e                	je     1202b <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   1200d:	8b 55 d0             	mov    -0x30(%ebp),%edx
   12010:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   12013:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   12016:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12019:	01 d9                	add    %ebx,%ecx
   1201b:	83 ec 04             	sub    $0x4,%esp
   1201e:	52                   	push   %edx
   1201f:	50                   	push   %eax
   12020:	51                   	push   %ecx
   12021:	e8 28 24 ff ff       	call   444e <lodepng_memcpy>
   12026:	83 c4 10             	add    $0x10,%esp
   12029:	eb 1a                	jmp    12045 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   1202b:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1202e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12031:	01 d0                	add    %edx,%eax
   12033:	83 ec 04             	sub    $0x4,%esp
   12036:	ff 75 f0             	pushl  -0x10(%ebp)
   12039:	ff 75 1c             	pushl  0x1c(%ebp)
   1203c:	50                   	push   %eax
   1203d:	e8 0c 24 ff ff       	call   444e <lodepng_memcpy>
   12042:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   12045:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12048:	83 ec 0c             	sub    $0xc,%esp
   1204b:	50                   	push   %eax
   1204c:	e8 e0 74 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   12051:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   12054:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   12057:	83 ec 0c             	sub    $0xc,%esp
   1205a:	50                   	push   %eax
   1205b:	e8 d1 23 ff ff       	call   4431 <lodepng_free>
   12060:	83 c4 10             	add    $0x10,%esp
  return error;
   12063:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   12066:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12069:	c9                   	leave  
   1206a:	c3                   	ret    

0001206b <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   1206b:	55                   	push   %ebp
   1206c:	89 e5                	mov    %esp,%ebp
   1206e:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   12071:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   12078:	8b 45 0c             	mov    0xc(%ebp),%eax
   1207b:	8b 40 0c             	mov    0xc(%eax),%eax
   1207e:	85 c0                	test   %eax,%eax
   12080:	74 0b                	je     1208d <addChunk_bKGD+0x22>
   12082:	8b 45 0c             	mov    0xc(%ebp),%eax
   12085:	8b 40 0c             	mov    0xc(%eax),%eax
   12088:	83 f8 04             	cmp    $0x4,%eax
   1208b:	75 4b                	jne    120d8 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   1208d:	68 32 b1 01 00       	push   $0x1b132
   12092:	6a 02                	push   $0x2
   12094:	ff 75 08             	pushl  0x8(%ebp)
   12097:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1209a:	50                   	push   %eax
   1209b:	e8 e8 77 ff ff       	call   9888 <lodepng_chunk_init>
   120a0:	83 c4 10             	add    $0x10,%esp
   120a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
   120a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   120aa:	74 08                	je     120b4 <addChunk_bKGD+0x49>
   120ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120af:	e9 19 01 00 00       	jmp    121cd <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   120b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120b7:	8d 50 08             	lea    0x8(%eax),%edx
   120ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   120bd:	8b 40 30             	mov    0x30(%eax),%eax
   120c0:	c1 e8 08             	shr    $0x8,%eax
   120c3:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   120c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120c8:	8d 50 09             	lea    0x9(%eax),%edx
   120cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   120ce:	8b 40 30             	mov    0x30(%eax),%eax
   120d1:	88 02                	mov    %al,(%edx)
   120d3:	e9 dd 00 00 00       	jmp    121b5 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   120d8:	8b 45 0c             	mov    0xc(%ebp),%eax
   120db:	8b 40 0c             	mov    0xc(%eax),%eax
   120de:	83 f8 02             	cmp    $0x2,%eax
   120e1:	74 0f                	je     120f2 <addChunk_bKGD+0x87>
   120e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   120e6:	8b 40 0c             	mov    0xc(%eax),%eax
   120e9:	83 f8 06             	cmp    $0x6,%eax
   120ec:	0f 85 86 00 00 00    	jne    12178 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   120f2:	68 32 b1 01 00       	push   $0x1b132
   120f7:	6a 06                	push   $0x6
   120f9:	ff 75 08             	pushl  0x8(%ebp)
   120fc:	8d 45 f0             	lea    -0x10(%ebp),%eax
   120ff:	50                   	push   %eax
   12100:	e8 83 77 ff ff       	call   9888 <lodepng_chunk_init>
   12105:	83 c4 10             	add    $0x10,%esp
   12108:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1210b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1210f:	74 08                	je     12119 <addChunk_bKGD+0xae>
   12111:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12114:	e9 b4 00 00 00       	jmp    121cd <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   12119:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1211c:	8d 50 08             	lea    0x8(%eax),%edx
   1211f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12122:	8b 40 30             	mov    0x30(%eax),%eax
   12125:	c1 e8 08             	shr    $0x8,%eax
   12128:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   1212a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1212d:	8d 50 09             	lea    0x9(%eax),%edx
   12130:	8b 45 0c             	mov    0xc(%ebp),%eax
   12133:	8b 40 30             	mov    0x30(%eax),%eax
   12136:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   12138:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1213b:	8d 50 0a             	lea    0xa(%eax),%edx
   1213e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12141:	8b 40 34             	mov    0x34(%eax),%eax
   12144:	c1 e8 08             	shr    $0x8,%eax
   12147:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   12149:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1214c:	8d 50 0b             	lea    0xb(%eax),%edx
   1214f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12152:	8b 40 34             	mov    0x34(%eax),%eax
   12155:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   12157:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1215a:	8d 50 0c             	lea    0xc(%eax),%edx
   1215d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12160:	8b 40 38             	mov    0x38(%eax),%eax
   12163:	c1 e8 08             	shr    $0x8,%eax
   12166:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   12168:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1216b:	8d 50 0d             	lea    0xd(%eax),%edx
   1216e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12171:	8b 40 38             	mov    0x38(%eax),%eax
   12174:	88 02                	mov    %al,(%edx)
   12176:	eb 3d                	jmp    121b5 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   12178:	8b 45 0c             	mov    0xc(%ebp),%eax
   1217b:	8b 40 0c             	mov    0xc(%eax),%eax
   1217e:	83 f8 03             	cmp    $0x3,%eax
   12181:	75 32                	jne    121b5 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   12183:	68 32 b1 01 00       	push   $0x1b132
   12188:	6a 01                	push   $0x1
   1218a:	ff 75 08             	pushl  0x8(%ebp)
   1218d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   12190:	50                   	push   %eax
   12191:	e8 f2 76 ff ff       	call   9888 <lodepng_chunk_init>
   12196:	83 c4 10             	add    $0x10,%esp
   12199:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1219c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   121a0:	74 05                	je     121a7 <addChunk_bKGD+0x13c>
   121a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121a5:	eb 26                	jmp    121cd <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   121a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121aa:	8d 50 08             	lea    0x8(%eax),%edx
   121ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   121b0:	8b 40 30             	mov    0x30(%eax),%eax
   121b3:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   121b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121b8:	85 c0                	test   %eax,%eax
   121ba:	74 0c                	je     121c8 <addChunk_bKGD+0x15d>
   121bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121bf:	50                   	push   %eax
   121c0:	e8 6c 73 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   121c5:	83 c4 04             	add    $0x4,%esp
  return 0;
   121c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   121cd:	c9                   	leave  
   121ce:	c3                   	ret    

000121cf <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   121cf:	55                   	push   %ebp
   121d0:	89 e5                	mov    %esp,%ebp
   121d2:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   121d5:	68 46 b1 01 00       	push   $0x1b146
   121da:	6a 07                	push   $0x7
   121dc:	ff 75 08             	pushl  0x8(%ebp)
   121df:	8d 45 f8             	lea    -0x8(%ebp),%eax
   121e2:	50                   	push   %eax
   121e3:	e8 a0 76 ff ff       	call   9888 <lodepng_chunk_init>
   121e8:	83 c4 10             	add    $0x10,%esp
   121eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
   121ee:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   121f2:	74 05                	je     121f9 <addChunk_tIME+0x2a>
   121f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121f7:	eb 74                	jmp    1226d <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   121f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   121fc:	8d 50 08             	lea    0x8(%eax),%edx
   121ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   12202:	8b 00                	mov    (%eax),%eax
   12204:	c1 e8 08             	shr    $0x8,%eax
   12207:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   12209:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1220c:	8d 50 09             	lea    0x9(%eax),%edx
   1220f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12212:	8b 00                	mov    (%eax),%eax
   12214:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   12216:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12219:	8d 50 0a             	lea    0xa(%eax),%edx
   1221c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1221f:	8b 40 04             	mov    0x4(%eax),%eax
   12222:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   12224:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12227:	8d 50 0b             	lea    0xb(%eax),%edx
   1222a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1222d:	8b 40 08             	mov    0x8(%eax),%eax
   12230:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   12232:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12235:	8d 50 0c             	lea    0xc(%eax),%edx
   12238:	8b 45 0c             	mov    0xc(%ebp),%eax
   1223b:	8b 40 0c             	mov    0xc(%eax),%eax
   1223e:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   12240:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12243:	8d 50 0d             	lea    0xd(%eax),%edx
   12246:	8b 45 0c             	mov    0xc(%ebp),%eax
   12249:	8b 40 10             	mov    0x10(%eax),%eax
   1224c:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   1224e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12251:	8d 50 0e             	lea    0xe(%eax),%edx
   12254:	8b 45 0c             	mov    0xc(%ebp),%eax
   12257:	8b 40 14             	mov    0x14(%eax),%eax
   1225a:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1225c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1225f:	50                   	push   %eax
   12260:	e8 cc 72 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   12265:	83 c4 04             	add    $0x4,%esp
  return 0;
   12268:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1226d:	c9                   	leave  
   1226e:	c3                   	ret    

0001226f <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   1226f:	55                   	push   %ebp
   12270:	89 e5                	mov    %esp,%ebp
   12272:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   12275:	68 4b b1 01 00       	push   $0x1b14b
   1227a:	6a 09                	push   $0x9
   1227c:	ff 75 08             	pushl  0x8(%ebp)
   1227f:	8d 45 f8             	lea    -0x8(%ebp),%eax
   12282:	50                   	push   %eax
   12283:	e8 00 76 ff ff       	call   9888 <lodepng_chunk_init>
   12288:	83 c4 10             	add    $0x10,%esp
   1228b:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1228e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   12292:	74 05                	je     12299 <addChunk_pHYs+0x2a>
   12294:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12297:	eb 51                	jmp    122ea <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   12299:	8b 45 0c             	mov    0xc(%ebp),%eax
   1229c:	8b 40 7c             	mov    0x7c(%eax),%eax
   1229f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   122a2:	83 c2 08             	add    $0x8,%edx
   122a5:	50                   	push   %eax
   122a6:	52                   	push   %edx
   122a7:	e8 25 25 ff ff       	call   47d1 <lodepng_set32bitInt>
   122ac:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   122af:	8b 45 0c             	mov    0xc(%ebp),%eax
   122b2:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   122b8:	8b 55 f8             	mov    -0x8(%ebp),%edx
   122bb:	83 c2 0c             	add    $0xc,%edx
   122be:	50                   	push   %eax
   122bf:	52                   	push   %edx
   122c0:	e8 0c 25 ff ff       	call   47d1 <lodepng_set32bitInt>
   122c5:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   122c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   122cb:	8d 50 10             	lea    0x10(%eax),%edx
   122ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   122d1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   122d7:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   122d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   122dc:	50                   	push   %eax
   122dd:	e8 4f 72 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   122e2:	83 c4 04             	add    $0x4,%esp
  return 0;
   122e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   122ea:	c9                   	leave  
   122eb:	c3                   	ret    

000122ec <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   122ec:	55                   	push   %ebp
   122ed:	89 e5                	mov    %esp,%ebp
   122ef:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   122f2:	68 50 b1 01 00       	push   $0x1b150
   122f7:	6a 04                	push   $0x4
   122f9:	ff 75 08             	pushl  0x8(%ebp)
   122fc:	8d 45 f8             	lea    -0x8(%ebp),%eax
   122ff:	50                   	push   %eax
   12300:	e8 83 75 ff ff       	call   9888 <lodepng_chunk_init>
   12305:	83 c4 10             	add    $0x10,%esp
   12308:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1230b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1230f:	74 05                	je     12316 <addChunk_gAMA+0x2a>
   12311:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12314:	eb 2a                	jmp    12340 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   12316:	8b 45 0c             	mov    0xc(%ebp),%eax
   12319:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   1231f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12322:	83 c2 08             	add    $0x8,%edx
   12325:	50                   	push   %eax
   12326:	52                   	push   %edx
   12327:	e8 a5 24 ff ff       	call   47d1 <lodepng_set32bitInt>
   1232c:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1232f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12332:	50                   	push   %eax
   12333:	e8 f9 71 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   12338:	83 c4 04             	add    $0x4,%esp
  return 0;
   1233b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12340:	c9                   	leave  
   12341:	c3                   	ret    

00012342 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   12342:	55                   	push   %ebp
   12343:	89 e5                	mov    %esp,%ebp
   12345:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   12348:	68 55 b1 01 00       	push   $0x1b155
   1234d:	6a 20                	push   $0x20
   1234f:	ff 75 08             	pushl  0x8(%ebp)
   12352:	8d 45 f8             	lea    -0x8(%ebp),%eax
   12355:	50                   	push   %eax
   12356:	e8 2d 75 ff ff       	call   9888 <lodepng_chunk_init>
   1235b:	83 c4 10             	add    $0x10,%esp
   1235e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12361:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   12365:	74 08                	je     1236f <addChunk_cHRM+0x2d>
   12367:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1236a:	e9 d9 00 00 00       	jmp    12448 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   1236f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12372:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   12378:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1237b:	83 c2 08             	add    $0x8,%edx
   1237e:	50                   	push   %eax
   1237f:	52                   	push   %edx
   12380:	e8 4c 24 ff ff       	call   47d1 <lodepng_set32bitInt>
   12385:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   12388:	8b 45 0c             	mov    0xc(%ebp),%eax
   1238b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   12391:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12394:	83 c2 0c             	add    $0xc,%edx
   12397:	50                   	push   %eax
   12398:	52                   	push   %edx
   12399:	e8 33 24 ff ff       	call   47d1 <lodepng_set32bitInt>
   1239e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   123a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   123a4:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   123aa:	8b 55 f8             	mov    -0x8(%ebp),%edx
   123ad:	83 c2 10             	add    $0x10,%edx
   123b0:	50                   	push   %eax
   123b1:	52                   	push   %edx
   123b2:	e8 1a 24 ff ff       	call   47d1 <lodepng_set32bitInt>
   123b7:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   123ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   123bd:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   123c3:	8b 55 f8             	mov    -0x8(%ebp),%edx
   123c6:	83 c2 14             	add    $0x14,%edx
   123c9:	50                   	push   %eax
   123ca:	52                   	push   %edx
   123cb:	e8 01 24 ff ff       	call   47d1 <lodepng_set32bitInt>
   123d0:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   123d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   123d6:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   123dc:	8b 55 f8             	mov    -0x8(%ebp),%edx
   123df:	83 c2 18             	add    $0x18,%edx
   123e2:	50                   	push   %eax
   123e3:	52                   	push   %edx
   123e4:	e8 e8 23 ff ff       	call   47d1 <lodepng_set32bitInt>
   123e9:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   123ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   123ef:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   123f5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   123f8:	83 c2 1c             	add    $0x1c,%edx
   123fb:	50                   	push   %eax
   123fc:	52                   	push   %edx
   123fd:	e8 cf 23 ff ff       	call   47d1 <lodepng_set32bitInt>
   12402:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   12405:	8b 45 0c             	mov    0xc(%ebp),%eax
   12408:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1240e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12411:	83 c2 20             	add    $0x20,%edx
   12414:	50                   	push   %eax
   12415:	52                   	push   %edx
   12416:	e8 b6 23 ff ff       	call   47d1 <lodepng_set32bitInt>
   1241b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   1241e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12421:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   12427:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1242a:	83 c2 24             	add    $0x24,%edx
   1242d:	50                   	push   %eax
   1242e:	52                   	push   %edx
   1242f:	e8 9d 23 ff ff       	call   47d1 <lodepng_set32bitInt>
   12434:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   12437:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1243a:	50                   	push   %eax
   1243b:	e8 f1 70 ff ff       	call   9531 <lodepng_chunk_generate_crc>
   12440:	83 c4 04             	add    $0x4,%esp
  return 0;
   12443:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12448:	c9                   	leave  
   12449:	c3                   	ret    

0001244a <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   1244a:	55                   	push   %ebp
   1244b:	89 e5                	mov    %esp,%ebp
   1244d:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   12450:	8b 45 0c             	mov    0xc(%ebp),%eax
   12453:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   12459:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   1245c:	8d 45 ff             	lea    -0x1(%ebp),%eax
   1245f:	50                   	push   %eax
   12460:	68 5a b1 01 00       	push   $0x1b15a
   12465:	6a 01                	push   $0x1
   12467:	ff 75 08             	pushl  0x8(%ebp)
   1246a:	e8 c1 74 ff ff       	call   9930 <lodepng_chunk_createv>
   1246f:	83 c4 10             	add    $0x10,%esp
}
   12472:	c9                   	leave  
   12473:	c3                   	ret    

00012474 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   12474:	55                   	push   %ebp
   12475:	89 e5                	mov    %esp,%ebp
   12477:	53                   	push   %ebx
   12478:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   1247b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   12482:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   12489:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   12490:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   12497:	8b 45 0c             	mov    0xc(%ebp),%eax
   1249a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   124a0:	50                   	push   %eax
   124a1:	e8 06 20 ff ff       	call   44ac <lodepng_strlen>
   124a6:	83 c4 04             	add    $0x4,%esp
   124a9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   124ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   124b0:	7e 06                	jle    124b8 <addChunk_iCCP+0x44>
   124b2:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   124b6:	7e 0a                	jle    124c2 <addChunk_iCCP+0x4e>
   124b8:	b8 59 00 00 00       	mov    $0x59,%eax
   124bd:	e9 df 00 00 00       	jmp    125a1 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   124c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   124c5:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   124cb:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   124cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   124d0:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   124d6:	83 ec 0c             	sub    $0xc,%esp
   124d9:	ff 75 10             	pushl  0x10(%ebp)
   124dc:	52                   	push   %edx
   124dd:	50                   	push   %eax
   124de:	8d 45 e0             	lea    -0x20(%ebp),%eax
   124e1:	50                   	push   %eax
   124e2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   124e5:	50                   	push   %eax
   124e6:	e8 35 6c ff ff       	call   9120 <zlib_compress>
   124eb:	83 c4 20             	add    $0x20,%esp
   124ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   124f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   124f5:	75 29                	jne    12520 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   124f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124fa:	8d 50 02             	lea    0x2(%eax),%edx
   124fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12500:	01 d0                	add    %edx,%eax
   12502:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   12505:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12508:	68 5f b1 01 00       	push   $0x1b15f
   1250d:	50                   	push   %eax
   1250e:	ff 75 08             	pushl  0x8(%ebp)
   12511:	8d 45 e8             	lea    -0x18(%ebp),%eax
   12514:	50                   	push   %eax
   12515:	e8 6e 73 ff ff       	call   9888 <lodepng_chunk_init>
   1251a:	83 c4 10             	add    $0x10,%esp
   1251d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   12520:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12524:	75 69                	jne    1258f <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   12526:	8b 45 0c             	mov    0xc(%ebp),%eax
   12529:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1252f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12532:	83 c2 08             	add    $0x8,%edx
   12535:	83 ec 04             	sub    $0x4,%esp
   12538:	ff 75 f0             	pushl  -0x10(%ebp)
   1253b:	50                   	push   %eax
   1253c:	52                   	push   %edx
   1253d:	e8 0c 1f ff ff       	call   444e <lodepng_memcpy>
   12542:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   12545:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12548:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1254b:	83 c2 08             	add    $0x8,%edx
   1254e:	01 d0                	add    %edx,%eax
   12550:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   12553:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12556:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12559:	83 c2 09             	add    $0x9,%edx
   1255c:	01 d0                	add    %edx,%eax
   1255e:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   12561:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12564:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12567:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1256a:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1256d:	83 c3 0a             	add    $0xa,%ebx
   12570:	01 d9                	add    %ebx,%ecx
   12572:	83 ec 04             	sub    $0x4,%esp
   12575:	52                   	push   %edx
   12576:	50                   	push   %eax
   12577:	51                   	push   %ecx
   12578:	e8 d1 1e ff ff       	call   444e <lodepng_memcpy>
   1257d:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   12580:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12583:	83 ec 0c             	sub    $0xc,%esp
   12586:	50                   	push   %eax
   12587:	e8 a5 6f ff ff       	call   9531 <lodepng_chunk_generate_crc>
   1258c:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1258f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12592:	83 ec 0c             	sub    $0xc,%esp
   12595:	50                   	push   %eax
   12596:	e8 96 1e ff ff       	call   4431 <lodepng_free>
   1259b:	83 c4 10             	add    $0x10,%esp
  return error;
   1259e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   125a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   125a4:	c9                   	leave  
   125a5:	c3                   	ret    

000125a6 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   125a6:	55                   	push   %ebp
   125a7:	89 e5                	mov    %esp,%ebp
   125a9:	56                   	push   %esi
   125aa:	53                   	push   %ebx
   125ab:	83 ec 14             	sub    $0x14,%esp
   125ae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   125b1:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   125b4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   125b8:	83 f8 04             	cmp    $0x4,%eax
   125bb:	0f 87 41 03 00 00    	ja     12902 <filterScanline+0x35c>
   125c1:	8b 04 85 70 b1 01 00 	mov    0x1b170(,%eax,4),%eax
   125c8:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   125ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   125d1:	eb 19                	jmp    125ec <filterScanline+0x46>
   125d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   125d6:	8b 45 08             	mov    0x8(%ebp),%eax
   125d9:	01 c2                	add    %eax,%edx
   125db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   125de:	8b 45 0c             	mov    0xc(%ebp),%eax
   125e1:	01 c8                	add    %ecx,%eax
   125e3:	0f b6 00             	movzbl (%eax),%eax
   125e6:	88 02                	mov    %al,(%edx)
   125e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   125ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   125ef:	3b 45 14             	cmp    0x14(%ebp),%eax
   125f2:	75 df                	jne    125d3 <filterScanline+0x2d>
      break;
   125f4:	e9 0a 03 00 00       	jmp    12903 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   125f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12600:	eb 19                	jmp    1261b <filterScanline+0x75>
   12602:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12605:	8b 45 08             	mov    0x8(%ebp),%eax
   12608:	01 c2                	add    %eax,%edx
   1260a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1260d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12610:	01 c8                	add    %ecx,%eax
   12612:	0f b6 00             	movzbl (%eax),%eax
   12615:	88 02                	mov    %al,(%edx)
   12617:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1261b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1261e:	3b 45 18             	cmp    0x18(%ebp),%eax
   12621:	75 df                	jne    12602 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   12623:	8b 45 18             	mov    0x18(%ebp),%eax
   12626:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12629:	eb 2d                	jmp    12658 <filterScanline+0xb2>
   1262b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1262e:	8b 45 08             	mov    0x8(%ebp),%eax
   12631:	01 c2                	add    %eax,%edx
   12633:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12636:	8b 45 0c             	mov    0xc(%ebp),%eax
   12639:	01 c8                	add    %ecx,%eax
   1263b:	0f b6 08             	movzbl (%eax),%ecx
   1263e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12641:	2b 45 18             	sub    0x18(%ebp),%eax
   12644:	89 c3                	mov    %eax,%ebx
   12646:	8b 45 0c             	mov    0xc(%ebp),%eax
   12649:	01 d8                	add    %ebx,%eax
   1264b:	0f b6 00             	movzbl (%eax),%eax
   1264e:	29 c1                	sub    %eax,%ecx
   12650:	89 c8                	mov    %ecx,%eax
   12652:	88 02                	mov    %al,(%edx)
   12654:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12658:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1265b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1265e:	7c cb                	jl     1262b <filterScanline+0x85>
      break;
   12660:	e9 9e 02 00 00       	jmp    12903 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   12665:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12669:	74 3e                	je     126a9 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   1266b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12672:	eb 28                	jmp    1269c <filterScanline+0xf6>
   12674:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12677:	8b 45 08             	mov    0x8(%ebp),%eax
   1267a:	01 d0                	add    %edx,%eax
   1267c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1267f:	8b 55 0c             	mov    0xc(%ebp),%edx
   12682:	01 ca                	add    %ecx,%edx
   12684:	0f b6 0a             	movzbl (%edx),%ecx
   12687:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1268a:	8b 55 10             	mov    0x10(%ebp),%edx
   1268d:	01 da                	add    %ebx,%edx
   1268f:	0f b6 12             	movzbl (%edx),%edx
   12692:	29 d1                	sub    %edx,%ecx
   12694:	89 ca                	mov    %ecx,%edx
   12696:	88 10                	mov    %dl,(%eax)
   12698:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1269c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1269f:	3b 45 14             	cmp    0x14(%ebp),%eax
   126a2:	75 d0                	jne    12674 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   126a4:	e9 5a 02 00 00       	jmp    12903 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   126a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   126b0:	eb 19                	jmp    126cb <filterScanline+0x125>
   126b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   126b5:	8b 45 08             	mov    0x8(%ebp),%eax
   126b8:	01 c2                	add    %eax,%edx
   126ba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   126bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   126c0:	01 c8                	add    %ecx,%eax
   126c2:	0f b6 00             	movzbl (%eax),%eax
   126c5:	88 02                	mov    %al,(%edx)
   126c7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   126cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   126ce:	3b 45 14             	cmp    0x14(%ebp),%eax
   126d1:	75 df                	jne    126b2 <filterScanline+0x10c>
      }
      break;
   126d3:	e9 2b 02 00 00       	jmp    12903 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   126d8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   126dc:	0f 84 90 00 00 00    	je     12772 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   126e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   126e9:	eb 28                	jmp    12713 <filterScanline+0x16d>
   126eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   126ee:	8b 45 08             	mov    0x8(%ebp),%eax
   126f1:	01 d0                	add    %edx,%eax
   126f3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   126f6:	8b 55 0c             	mov    0xc(%ebp),%edx
   126f9:	01 ca                	add    %ecx,%edx
   126fb:	0f b6 12             	movzbl (%edx),%edx
   126fe:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   12701:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12704:	01 d9                	add    %ebx,%ecx
   12706:	0f b6 09             	movzbl (%ecx),%ecx
   12709:	d0 e9                	shr    %cl
   1270b:	29 ca                	sub    %ecx,%edx
   1270d:	88 10                	mov    %dl,(%eax)
   1270f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12713:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12716:	3b 45 18             	cmp    0x18(%ebp),%eax
   12719:	75 d0                	jne    126eb <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   1271b:	8b 45 18             	mov    0x18(%ebp),%eax
   1271e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12721:	eb 42                	jmp    12765 <filterScanline+0x1bf>
   12723:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12726:	8b 45 08             	mov    0x8(%ebp),%eax
   12729:	01 c2                	add    %eax,%edx
   1272b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1272e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12731:	01 c8                	add    %ecx,%eax
   12733:	0f b6 08             	movzbl (%eax),%ecx
   12736:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12739:	2b 45 18             	sub    0x18(%ebp),%eax
   1273c:	89 c3                	mov    %eax,%ebx
   1273e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12741:	01 d8                	add    %ebx,%eax
   12743:	0f b6 00             	movzbl (%eax),%eax
   12746:	0f b6 d8             	movzbl %al,%ebx
   12749:	8b 75 f4             	mov    -0xc(%ebp),%esi
   1274c:	8b 45 10             	mov    0x10(%ebp),%eax
   1274f:	01 f0                	add    %esi,%eax
   12751:	0f b6 00             	movzbl (%eax),%eax
   12754:	0f b6 c0             	movzbl %al,%eax
   12757:	01 d8                	add    %ebx,%eax
   12759:	d1 f8                	sar    %eax
   1275b:	29 c1                	sub    %eax,%ecx
   1275d:	89 c8                	mov    %ecx,%eax
   1275f:	88 02                	mov    %al,(%edx)
   12761:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12765:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12768:	3b 45 14             	cmp    0x14(%ebp),%eax
   1276b:	7c b6                	jl     12723 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   1276d:	e9 91 01 00 00       	jmp    12903 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   12772:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12779:	eb 19                	jmp    12794 <filterScanline+0x1ee>
   1277b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1277e:	8b 45 08             	mov    0x8(%ebp),%eax
   12781:	01 c2                	add    %eax,%edx
   12783:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12786:	8b 45 0c             	mov    0xc(%ebp),%eax
   12789:	01 c8                	add    %ecx,%eax
   1278b:	0f b6 00             	movzbl (%eax),%eax
   1278e:	88 02                	mov    %al,(%edx)
   12790:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12794:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12797:	3b 45 18             	cmp    0x18(%ebp),%eax
   1279a:	75 df                	jne    1277b <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   1279c:	8b 45 18             	mov    0x18(%ebp),%eax
   1279f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   127a2:	eb 2f                	jmp    127d3 <filterScanline+0x22d>
   127a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   127a7:	8b 45 08             	mov    0x8(%ebp),%eax
   127aa:	01 c2                	add    %eax,%edx
   127ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   127af:	8b 45 0c             	mov    0xc(%ebp),%eax
   127b2:	01 c8                	add    %ecx,%eax
   127b4:	0f b6 08             	movzbl (%eax),%ecx
   127b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   127ba:	2b 45 18             	sub    0x18(%ebp),%eax
   127bd:	89 c3                	mov    %eax,%ebx
   127bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   127c2:	01 d8                	add    %ebx,%eax
   127c4:	0f b6 00             	movzbl (%eax),%eax
   127c7:	d0 e8                	shr    %al
   127c9:	29 c1                	sub    %eax,%ecx
   127cb:	89 c8                	mov    %ecx,%eax
   127cd:	88 02                	mov    %al,(%edx)
   127cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   127d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   127d6:	3b 45 14             	cmp    0x14(%ebp),%eax
   127d9:	7c c9                	jl     127a4 <filterScanline+0x1fe>
      }
      break;
   127db:	e9 23 01 00 00       	jmp    12903 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   127e0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   127e4:	0f 84 af 00 00 00    	je     12899 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   127ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   127f1:	eb 28                	jmp    1281b <filterScanline+0x275>
   127f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   127f6:	8b 45 08             	mov    0x8(%ebp),%eax
   127f9:	01 d0                	add    %edx,%eax
   127fb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   127fe:	8b 55 0c             	mov    0xc(%ebp),%edx
   12801:	01 ca                	add    %ecx,%edx
   12803:	0f b6 0a             	movzbl (%edx),%ecx
   12806:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   12809:	8b 55 10             	mov    0x10(%ebp),%edx
   1280c:	01 da                	add    %ebx,%edx
   1280e:	0f b6 12             	movzbl (%edx),%edx
   12811:	29 d1                	sub    %edx,%ecx
   12813:	89 ca                	mov    %ecx,%edx
   12815:	88 10                	mov    %dl,(%eax)
   12817:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1281b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1281e:	3b 45 18             	cmp    0x18(%ebp),%eax
   12821:	75 d0                	jne    127f3 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   12823:	8b 45 18             	mov    0x18(%ebp),%eax
   12826:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12829:	eb 64                	jmp    1288f <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   1282b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1282e:	8b 45 08             	mov    0x8(%ebp),%eax
   12831:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   12834:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12837:	8b 45 0c             	mov    0xc(%ebp),%eax
   1283a:	01 d0                	add    %edx,%eax
   1283c:	0f b6 00             	movzbl (%eax),%eax
   1283f:	88 45 e7             	mov    %al,-0x19(%ebp)
   12842:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12845:	2b 45 18             	sub    0x18(%ebp),%eax
   12848:	89 c2                	mov    %eax,%edx
   1284a:	8b 45 10             	mov    0x10(%ebp),%eax
   1284d:	01 d0                	add    %edx,%eax
   1284f:	0f b6 00             	movzbl (%eax),%eax
   12852:	0f b6 c8             	movzbl %al,%ecx
   12855:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12858:	8b 45 10             	mov    0x10(%ebp),%eax
   1285b:	01 d0                	add    %edx,%eax
   1285d:	0f b6 00             	movzbl (%eax),%eax
   12860:	0f b6 d0             	movzbl %al,%edx
   12863:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12866:	2b 45 18             	sub    0x18(%ebp),%eax
   12869:	89 c6                	mov    %eax,%esi
   1286b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1286e:	01 f0                	add    %esi,%eax
   12870:	0f b6 00             	movzbl (%eax),%eax
   12873:	0f b6 c0             	movzbl %al,%eax
   12876:	51                   	push   %ecx
   12877:	52                   	push   %edx
   12878:	50                   	push   %eax
   12879:	e8 49 b8 ff ff       	call   e0c7 <paethPredictor>
   1287e:	83 c4 0c             	add    $0xc,%esp
   12881:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   12885:	29 c1                	sub    %eax,%ecx
   12887:	89 c8                	mov    %ecx,%eax
   12889:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   1288b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1288f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12892:	3b 45 14             	cmp    0x14(%ebp),%eax
   12895:	7c 94                	jl     1282b <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   12897:	eb 6a                	jmp    12903 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   12899:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   128a0:	eb 19                	jmp    128bb <filterScanline+0x315>
   128a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   128a5:	8b 45 08             	mov    0x8(%ebp),%eax
   128a8:	01 c2                	add    %eax,%edx
   128aa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   128ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   128b0:	01 c8                	add    %ecx,%eax
   128b2:	0f b6 00             	movzbl (%eax),%eax
   128b5:	88 02                	mov    %al,(%edx)
   128b7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   128bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   128be:	3b 45 18             	cmp    0x18(%ebp),%eax
   128c1:	75 df                	jne    128a2 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   128c3:	8b 45 18             	mov    0x18(%ebp),%eax
   128c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
   128c9:	eb 2d                	jmp    128f8 <filterScanline+0x352>
   128cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   128ce:	8b 45 08             	mov    0x8(%ebp),%eax
   128d1:	01 c2                	add    %eax,%edx
   128d3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   128d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   128d9:	01 c8                	add    %ecx,%eax
   128db:	0f b6 08             	movzbl (%eax),%ecx
   128de:	8b 45 f4             	mov    -0xc(%ebp),%eax
   128e1:	2b 45 18             	sub    0x18(%ebp),%eax
   128e4:	89 c3                	mov    %eax,%ebx
   128e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   128e9:	01 d8                	add    %ebx,%eax
   128eb:	0f b6 00             	movzbl (%eax),%eax
   128ee:	29 c1                	sub    %eax,%ecx
   128f0:	89 c8                	mov    %ecx,%eax
   128f2:	88 02                	mov    %al,(%edx)
   128f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   128f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   128fb:	3b 45 14             	cmp    0x14(%ebp),%eax
   128fe:	7c cb                	jl     128cb <filterScanline+0x325>
      }
      break;
   12900:	eb 01                	jmp    12903 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   12902:	90                   	nop
  }
}
   12903:	8d 65 f8             	lea    -0x8(%ebp),%esp
   12906:	5b                   	pop    %ebx
   12907:	5e                   	pop    %esi
   12908:	5d                   	pop    %ebp
   12909:	c3                   	ret    

0001290a <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   1290a:	55                   	push   %ebp
   1290b:	89 e5                	mov    %esp,%ebp
   1290d:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   12910:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   12917:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   1291e:	7e 08                	jle    12928 <ilog2+0x1e>
   12920:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   12924:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   12928:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   1292f:	7e 08                	jle    12939 <ilog2+0x2f>
   12931:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   12935:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   12939:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   1293d:	7e 08                	jle    12947 <ilog2+0x3d>
   1293f:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   12943:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   12947:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   1294b:	7e 08                	jle    12955 <ilog2+0x4b>
   1294d:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   12951:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   12955:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   12959:	7e 04                	jle    1295f <ilog2+0x55>
   1295b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   1295f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12962:	c9                   	leave  
   12963:	c3                   	ret    

00012964 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   12964:	55                   	push   %ebp
   12965:	89 e5                	mov    %esp,%ebp
   12967:	56                   	push   %esi
   12968:	53                   	push   %ebx
   12969:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   1296c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   12970:	75 07                	jne    12979 <ilog2i+0x15>
   12972:	b8 00 00 00 00       	mov    $0x0,%eax
   12977:	eb 30                	jmp    129a9 <ilog2i+0x45>
  l = ilog2(i);
   12979:	ff 75 08             	pushl  0x8(%ebp)
   1297c:	e8 89 ff ff ff       	call   1290a <ilog2>
   12981:	83 c4 04             	add    $0x4,%esp
   12984:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   12987:	8b 45 08             	mov    0x8(%ebp),%eax
   1298a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1298e:	89 c3                	mov    %eax,%ebx
   12990:	8b 55 08             	mov    0x8(%ebp),%edx
   12993:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12996:	be 01 00 00 00       	mov    $0x1,%esi
   1299b:	89 c1                	mov    %eax,%ecx
   1299d:	d3 e6                	shl    %cl,%esi
   1299f:	89 f0                	mov    %esi,%eax
   129a1:	29 c2                	sub    %eax,%edx
   129a3:	89 d0                	mov    %edx,%eax
   129a5:	01 c0                	add    %eax,%eax
   129a7:	01 d8                	add    %ebx,%eax
}
   129a9:	8d 65 f8             	lea    -0x8(%ebp),%esp
   129ac:	5b                   	pop    %ebx
   129ad:	5e                   	pop    %esi
   129ae:	5d                   	pop    %ebp
   129af:	c3                   	ret    

000129b0 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   129b0:	55                   	push   %ebp
   129b1:	89 e5                	mov    %esp,%ebp
   129b3:	53                   	push   %ebx
   129b4:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   129ba:	ff 75 18             	pushl  0x18(%ebp)
   129bd:	e8 6a 75 ff ff       	call   9f2c <lodepng_get_bpp>
   129c2:	83 c4 04             	add    $0x4,%esp
   129c5:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   129c8:	ff 75 b8             	pushl  -0x48(%ebp)
   129cb:	6a 01                	push   $0x1
   129cd:	ff 75 10             	pushl  0x10(%ebp)
   129d0:	e8 b6 76 ff ff       	call   a08b <lodepng_get_raw_size_idat>
   129d5:	83 c4 0c             	add    $0xc,%esp
   129d8:	83 e8 01             	sub    $0x1,%eax
   129db:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   129de:	8b 45 b8             	mov    -0x48(%ebp),%eax
   129e1:	83 c0 07             	add    $0x7,%eax
   129e4:	c1 e8 03             	shr    $0x3,%eax
   129e7:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   129ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   129f1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   129f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129fb:	8b 40 2c             	mov    0x2c(%eax),%eax
   129fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   12a01:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a04:	8b 40 28             	mov    0x28(%eax),%eax
   12a07:	85 c0                	test   %eax,%eax
   12a09:	74 1c                	je     12a27 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   12a0b:	8b 45 18             	mov    0x18(%ebp),%eax
   12a0e:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   12a10:	83 f8 03             	cmp    $0x3,%eax
   12a13:	74 0b                	je     12a20 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   12a15:	8b 45 18             	mov    0x18(%ebp),%eax
   12a18:	8b 40 04             	mov    0x4(%eax),%eax
   12a1b:	83 f8 07             	cmp    $0x7,%eax
   12a1e:	77 07                	ja     12a27 <filter+0x77>
   12a20:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   12a27:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   12a2b:	75 0a                	jne    12a37 <filter+0x87>
   12a2d:	b8 1f 00 00 00       	mov    $0x1f,%eax
   12a32:	e9 5b 07 00 00       	jmp    13192 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   12a37:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   12a3b:	77 7b                	ja     12ab8 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   12a3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12a40:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   12a43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12a4a:	eb 5f                	jmp    12aab <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   12a4c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12a4f:	83 c0 01             	add    $0x1,%eax
   12a52:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12a56:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   12a59:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12a5c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12a60:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   12a63:	8b 55 9c             	mov    -0x64(%ebp),%edx
   12a66:	8b 45 08             	mov    0x8(%ebp),%eax
   12a69:	01 c2                	add    %eax,%edx
   12a6b:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   12a6f:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   12a71:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   12a75:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   12a78:	8b 55 0c             	mov    0xc(%ebp),%edx
   12a7b:	01 d1                	add    %edx,%ecx
   12a7d:	8b 55 9c             	mov    -0x64(%ebp),%edx
   12a80:	8d 5a 01             	lea    0x1(%edx),%ebx
   12a83:	8b 55 08             	mov    0x8(%ebp),%edx
   12a86:	01 da                	add    %ebx,%edx
   12a88:	50                   	push   %eax
   12a89:	ff 75 b0             	pushl  -0x50(%ebp)
   12a8c:	ff 75 b4             	pushl  -0x4c(%ebp)
   12a8f:	ff 75 f4             	pushl  -0xc(%ebp)
   12a92:	51                   	push   %ecx
   12a93:	52                   	push   %edx
   12a94:	e8 0d fb ff ff       	call   125a6 <filterScanline>
   12a99:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   12a9c:	8b 55 98             	mov    -0x68(%ebp),%edx
   12a9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12aa2:	01 d0                	add    %edx,%eax
   12aa4:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   12aa7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12aab:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12aae:	3b 45 14             	cmp    0x14(%ebp),%eax
   12ab1:	75 99                	jne    12a4c <filter+0x9c>
   12ab3:	e9 d7 06 00 00       	jmp    1318f <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   12ab8:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   12abc:	0f 85 e3 01 00 00    	jne    12ca5 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   12ac2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   12ac9:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   12acd:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   12ad1:	eb 2d                	jmp    12b00 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   12ad3:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   12ad7:	83 ec 0c             	sub    $0xc,%esp
   12ada:	ff 75 b4             	pushl  -0x4c(%ebp)
   12add:	e8 2e 19 ff ff       	call   4410 <lodepng_malloc>
   12ae2:	83 c4 10             	add    $0x10,%esp
   12ae5:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12ae9:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12aed:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   12af1:	85 c0                	test   %eax,%eax
   12af3:	75 07                	jne    12afc <filter+0x14c>
   12af5:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   12afc:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   12b00:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12b04:	75 cd                	jne    12ad3 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   12b06:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12b0a:	0f 85 6c 01 00 00    	jne    12c7c <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   12b10:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12b17:	e9 54 01 00 00       	jmp    12c70 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12b1c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   12b20:	e9 d5 00 00 00       	jmp    12bfa <filter+0x24a>
          size_t sum = 0;
   12b25:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   12b2c:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   12b30:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12b33:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12b37:	89 c1                	mov    %eax,%ecx
   12b39:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b3c:	01 c1                	add    %eax,%ecx
   12b3e:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12b42:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   12b46:	83 ec 08             	sub    $0x8,%esp
   12b49:	52                   	push   %edx
   12b4a:	ff 75 b0             	pushl  -0x50(%ebp)
   12b4d:	ff 75 b4             	pushl  -0x4c(%ebp)
   12b50:	ff 75 f4             	pushl  -0xc(%ebp)
   12b53:	51                   	push   %ecx
   12b54:	50                   	push   %eax
   12b55:	e8 4c fa ff ff       	call   125a6 <filterScanline>
   12b5a:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   12b5d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   12b61:	75 2d                	jne    12b90 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   12b63:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12b6a:	eb 1a                	jmp    12b86 <filter+0x1d6>
   12b6c:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12b70:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   12b74:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12b77:	01 d0                	add    %edx,%eax
   12b79:	0f b6 00             	movzbl (%eax),%eax
   12b7c:	0f b6 c0             	movzbl %al,%eax
   12b7f:	01 45 d8             	add    %eax,-0x28(%ebp)
   12b82:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12b86:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12b89:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12b8c:	75 de                	jne    12b6c <filter+0x1bc>
   12b8e:	eb 4b                	jmp    12bdb <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   12b90:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12b97:	eb 3a                	jmp    12bd3 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   12b99:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12b9d:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   12ba1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12ba4:	01 d0                	add    %edx,%eax
   12ba6:	0f b6 00             	movzbl (%eax),%eax
   12ba9:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   12bac:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   12bb0:	84 c0                	test   %al,%al
   12bb2:	78 06                	js     12bba <filter+0x20a>
   12bb4:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   12bb8:	eb 0d                	jmp    12bc7 <filter+0x217>
   12bba:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   12bbe:	ba ff 00 00 00       	mov    $0xff,%edx
   12bc3:	29 c2                	sub    %eax,%edx
   12bc5:	89 d0                	mov    %edx,%eax
   12bc7:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12bca:	01 d0                	add    %edx,%eax
   12bcc:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   12bcf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12bd3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12bd6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12bd9:	75 be                	jne    12b99 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   12bdb:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   12bdf:	74 08                	je     12be9 <filter+0x239>
   12be1:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12be4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   12be7:	7d 0d                	jge    12bf6 <filter+0x246>
            bestType = type;
   12be9:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12bed:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   12bf0:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12bf3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12bf6:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   12bfa:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12bfe:	0f 85 21 ff ff ff    	jne    12b25 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   12c04:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12c07:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12c0b:	89 c2                	mov    %eax,%edx
   12c0d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c10:	01 d0                	add    %edx,%eax
   12c12:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12c15:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12c18:	83 c0 01             	add    $0x1,%eax
   12c1b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12c1f:	89 c2                	mov    %eax,%edx
   12c21:	8b 45 08             	mov    0x8(%ebp),%eax
   12c24:	01 c2                	add    %eax,%edx
   12c26:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   12c2a:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12c2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12c33:	eb 2f                	jmp    12c64 <filter+0x2b4>
   12c35:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12c38:	83 c0 01             	add    $0x1,%eax
   12c3b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12c3f:	89 c2                	mov    %eax,%edx
   12c41:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12c44:	01 d0                	add    %edx,%eax
   12c46:	8d 50 01             	lea    0x1(%eax),%edx
   12c49:	8b 45 08             	mov    0x8(%ebp),%eax
   12c4c:	01 c2                	add    %eax,%edx
   12c4e:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   12c52:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   12c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12c59:	01 c8                	add    %ecx,%eax
   12c5b:	0f b6 00             	movzbl (%eax),%eax
   12c5e:	88 02                	mov    %al,(%edx)
   12c60:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12c64:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12c67:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12c6a:	75 c9                	jne    12c35 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   12c6c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12c73:	3b 45 14             	cmp    0x14(%ebp),%eax
   12c76:	0f 85 a0 fe ff ff    	jne    12b1c <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12c7c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   12c80:	eb 18                	jmp    12c9a <filter+0x2ea>
   12c82:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12c86:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   12c8a:	83 ec 0c             	sub    $0xc,%esp
   12c8d:	50                   	push   %eax
   12c8e:	e8 9e 17 ff ff       	call   4431 <lodepng_free>
   12c93:	83 c4 10             	add    $0x10,%esp
   12c96:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   12c9a:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12c9e:	75 e2                	jne    12c82 <filter+0x2d2>
   12ca0:	e9 ea 04 00 00       	jmp    1318f <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   12ca5:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   12ca9:	0f 85 17 02 00 00    	jne    12ec6 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   12caf:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   12cb6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   12cbd:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12cc4:	eb 33                	jmp    12cf9 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   12cc6:	83 ec 0c             	sub    $0xc,%esp
   12cc9:	ff 75 b4             	pushl  -0x4c(%ebp)
   12ccc:	e8 3f 17 ff ff       	call   4410 <lodepng_malloc>
   12cd1:	83 c4 10             	add    $0x10,%esp
   12cd4:	89 c2                	mov    %eax,%edx
   12cd6:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12cd9:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12ce0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12ce3:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12cea:	85 c0                	test   %eax,%eax
   12cec:	75 07                	jne    12cf5 <filter+0x345>
   12cee:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   12cf5:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12cf9:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12cfd:	75 c7                	jne    12cc6 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   12cff:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12d03:	0f 85 8f 01 00 00    	jne    12e98 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   12d09:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12d10:	e9 77 01 00 00       	jmp    12e8c <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12d15:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12d1c:	e9 f4 00 00 00       	jmp    12e15 <filter+0x465>
          size_t sum = 0;
   12d21:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   12d28:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12d2b:	0f b6 d0             	movzbl %al,%edx
   12d2e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12d31:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12d35:	89 c1                	mov    %eax,%ecx
   12d37:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d3a:	01 c1                	add    %eax,%ecx
   12d3c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12d3f:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12d46:	83 ec 08             	sub    $0x8,%esp
   12d49:	52                   	push   %edx
   12d4a:	ff 75 b0             	pushl  -0x50(%ebp)
   12d4d:	ff 75 b4             	pushl  -0x4c(%ebp)
   12d50:	ff 75 f4             	pushl  -0xc(%ebp)
   12d53:	51                   	push   %ecx
   12d54:	50                   	push   %eax
   12d55:	e8 4c f8 ff ff       	call   125a6 <filterScanline>
   12d5a:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   12d5d:	83 ec 04             	sub    $0x4,%esp
   12d60:	68 00 04 00 00       	push   $0x400
   12d65:	6a 00                	push   $0x0
   12d67:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   12d6d:	50                   	push   %eax
   12d6e:	e8 0e 17 ff ff       	call   4481 <lodepng_memset>
   12d73:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   12d76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12d7d:	eb 2a                	jmp    12da9 <filter+0x3f9>
   12d7f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12d82:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   12d89:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12d8c:	01 d0                	add    %edx,%eax
   12d8e:	0f b6 00             	movzbl (%eax),%eax
   12d91:	0f b6 c0             	movzbl %al,%eax
   12d94:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   12d9b:	83 c2 01             	add    $0x1,%edx
   12d9e:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   12da5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12da9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12dac:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12daf:	75 ce                	jne    12d7f <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   12db1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12db4:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   12dbb:	8d 50 01             	lea    0x1(%eax),%edx
   12dbe:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12dc1:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   12dc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12dcf:	eb 1d                	jmp    12dee <filter+0x43e>
            sum += ilog2i(count[x]);
   12dd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12dd4:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   12ddb:	83 ec 0c             	sub    $0xc,%esp
   12dde:	50                   	push   %eax
   12ddf:	e8 80 fb ff ff       	call   12964 <ilog2i>
   12de4:	83 c4 10             	add    $0x10,%esp
   12de7:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   12dea:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12dee:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   12df5:	75 da                	jne    12dd1 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   12df7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   12dfb:	74 08                	je     12e05 <filter+0x455>
   12dfd:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12e00:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   12e03:	7e 0c                	jle    12e11 <filter+0x461>
            bestType = type;
   12e05:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12e08:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   12e0b:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12e0e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12e11:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12e15:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12e19:	0f 85 02 ff ff ff    	jne    12d21 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   12e1f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12e22:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12e26:	89 c2                	mov    %eax,%edx
   12e28:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e2b:	01 d0                	add    %edx,%eax
   12e2d:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12e30:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12e33:	83 c0 01             	add    $0x1,%eax
   12e36:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12e3a:	89 c2                	mov    %eax,%edx
   12e3c:	8b 45 08             	mov    0x8(%ebp),%eax
   12e3f:	01 d0                	add    %edx,%eax
   12e41:	8b 55 cc             	mov    -0x34(%ebp),%edx
   12e44:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12e46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12e4d:	eb 31                	jmp    12e80 <filter+0x4d0>
   12e4f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12e52:	83 c0 01             	add    $0x1,%eax
   12e55:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12e59:	89 c2                	mov    %eax,%edx
   12e5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e5e:	01 d0                	add    %edx,%eax
   12e60:	8d 50 01             	lea    0x1(%eax),%edx
   12e63:	8b 45 08             	mov    0x8(%ebp),%eax
   12e66:	01 c2                	add    %eax,%edx
   12e68:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12e6b:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   12e72:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e75:	01 c8                	add    %ecx,%eax
   12e77:	0f b6 00             	movzbl (%eax),%eax
   12e7a:	88 02                	mov    %al,(%edx)
   12e7c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12e80:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12e83:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12e86:	75 c7                	jne    12e4f <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   12e88:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12e8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12e8f:	3b 45 14             	cmp    0x14(%ebp),%eax
   12e92:	0f 85 7d fe ff ff    	jne    12d15 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12e98:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12e9f:	eb 1a                	jmp    12ebb <filter+0x50b>
   12ea1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12ea4:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12eab:	83 ec 0c             	sub    $0xc,%esp
   12eae:	50                   	push   %eax
   12eaf:	e8 7d 15 ff ff       	call   4431 <lodepng_free>
   12eb4:	83 c4 10             	add    $0x10,%esp
   12eb7:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12ebb:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12ebf:	75 e0                	jne    12ea1 <filter+0x4f1>
   12ec1:	e9 c9 02 00 00       	jmp    1318f <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   12ec6:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   12eca:	0f 85 89 00 00 00    	jne    12f59 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   12ed0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12ed7:	eb 73                	jmp    12f4c <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   12ed9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12edc:	83 c0 01             	add    $0x1,%eax
   12edf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12ee3:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   12ee6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12ee9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12eed:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   12ef0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ef3:	8b 50 30             	mov    0x30(%eax),%edx
   12ef6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12ef9:	01 d0                	add    %edx,%eax
   12efb:	0f b6 00             	movzbl (%eax),%eax
   12efe:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   12f01:	8b 55 a8             	mov    -0x58(%ebp),%edx
   12f04:	8b 45 08             	mov    0x8(%ebp),%eax
   12f07:	01 c2                	add    %eax,%edx
   12f09:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   12f0d:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   12f0f:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   12f13:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   12f16:	8b 55 0c             	mov    0xc(%ebp),%edx
   12f19:	01 d1                	add    %edx,%ecx
   12f1b:	8b 55 a8             	mov    -0x58(%ebp),%edx
   12f1e:	8d 5a 01             	lea    0x1(%edx),%ebx
   12f21:	8b 55 08             	mov    0x8(%ebp),%edx
   12f24:	01 da                	add    %ebx,%edx
   12f26:	83 ec 08             	sub    $0x8,%esp
   12f29:	50                   	push   %eax
   12f2a:	ff 75 b0             	pushl  -0x50(%ebp)
   12f2d:	ff 75 b4             	pushl  -0x4c(%ebp)
   12f30:	ff 75 f4             	pushl  -0xc(%ebp)
   12f33:	51                   	push   %ecx
   12f34:	52                   	push   %edx
   12f35:	e8 6c f6 ff ff       	call   125a6 <filterScanline>
   12f3a:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   12f3d:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12f40:	8b 45 0c             	mov    0xc(%ebp),%eax
   12f43:	01 d0                	add    %edx,%eax
   12f45:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   12f48:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12f4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12f4f:	3b 45 14             	cmp    0x14(%ebp),%eax
   12f52:	75 85                	jne    12ed9 <filter+0x529>
   12f54:	e9 36 02 00 00       	jmp    1318f <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   12f59:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   12f5d:	0f 85 25 02 00 00    	jne    13188 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   12f63:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   12f6a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12f71:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   12f78:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f7b:	83 ec 04             	sub    $0x4,%esp
   12f7e:	6a 24                	push   $0x24
   12f80:	50                   	push   %eax
   12f81:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   12f87:	50                   	push   %eax
   12f88:	e8 c1 14 ff ff       	call   444e <lodepng_memcpy>
   12f8d:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   12f90:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   12f97:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   12f9a:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   12fa1:	00 00 00 
    zlibsettings.custom_deflate = 0;
   12fa4:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   12fab:	00 00 00 
    for(type = 0; type != 5; ++type) {
   12fae:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12fb5:	eb 33                	jmp    12fea <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   12fb7:	83 ec 0c             	sub    $0xc,%esp
   12fba:	ff 75 b4             	pushl  -0x4c(%ebp)
   12fbd:	e8 4e 14 ff ff       	call   4410 <lodepng_malloc>
   12fc2:	83 c4 10             	add    $0x10,%esp
   12fc5:	89 c2                	mov    %eax,%edx
   12fc7:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12fca:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12fd1:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12fd4:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12fdb:	85 c0                	test   %eax,%eax
   12fdd:	75 07                	jne    12fe6 <filter+0x636>
   12fdf:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   12fe6:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12fea:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12fee:	75 c7                	jne    12fb7 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   12ff0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12ff4:	0f 85 63 01 00 00    	jne    1315d <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12ffa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   13001:	e9 4b 01 00 00       	jmp    13151 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   13006:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1300d:	e9 c8 00 00 00       	jmp    130da <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   13012:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13015:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   13018:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1301b:	0f b6 d0             	movzbl %al,%edx
   1301e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13021:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   13025:	89 c1                	mov    %eax,%ecx
   13027:	8b 45 0c             	mov    0xc(%ebp),%eax
   1302a:	01 c1                	add    %eax,%ecx
   1302c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1302f:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   13036:	83 ec 08             	sub    $0x8,%esp
   13039:	52                   	push   %edx
   1303a:	ff 75 b0             	pushl  -0x50(%ebp)
   1303d:	ff 75 b4             	pushl  -0x4c(%ebp)
   13040:	ff 75 f4             	pushl  -0xc(%ebp)
   13043:	51                   	push   %ecx
   13044:	50                   	push   %eax
   13045:	e8 5c f5 ff ff       	call   125a6 <filterScanline>
   1304a:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   1304d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13050:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   13057:	00 00 00 00 
          dummy = 0;
   1305b:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   13062:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   13065:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13068:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1306b:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   13072:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   13078:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   1307b:	c1 e3 02             	shl    $0x2,%ebx
   1307e:	01 cb                	add    %ecx,%ebx
   13080:	83 ec 0c             	sub    $0xc,%esp
   13083:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   13089:	51                   	push   %ecx
   1308a:	52                   	push   %edx
   1308b:	50                   	push   %eax
   1308c:	53                   	push   %ebx
   1308d:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   13093:	50                   	push   %eax
   13094:	e8 87 60 ff ff       	call   9120 <zlib_compress>
   13099:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   1309c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   130a2:	83 ec 0c             	sub    $0xc,%esp
   130a5:	50                   	push   %eax
   130a6:	e8 86 13 ff ff       	call   4431 <lodepng_free>
   130ab:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   130ae:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   130b2:	74 0f                	je     130c3 <filter+0x713>
   130b4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   130b7:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   130be:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   130c1:	7d 13                	jge    130d6 <filter+0x726>
            bestType = type;
   130c3:	8b 45 c0             	mov    -0x40(%ebp),%eax
   130c6:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   130c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
   130cc:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   130d3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   130d6:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   130da:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   130de:	0f 85 2e ff ff ff    	jne    13012 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   130e4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   130e7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   130eb:	89 c2                	mov    %eax,%edx
   130ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   130f0:	01 d0                	add    %edx,%eax
   130f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   130f5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   130f8:	83 c0 01             	add    $0x1,%eax
   130fb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   130ff:	89 c2                	mov    %eax,%edx
   13101:	8b 45 08             	mov    0x8(%ebp),%eax
   13104:	01 d0                	add    %edx,%eax
   13106:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13109:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1310b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13112:	eb 31                	jmp    13145 <filter+0x795>
   13114:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13117:	83 c0 01             	add    $0x1,%eax
   1311a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1311e:	89 c2                	mov    %eax,%edx
   13120:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13123:	01 d0                	add    %edx,%eax
   13125:	8d 50 01             	lea    0x1(%eax),%edx
   13128:	8b 45 08             	mov    0x8(%ebp),%eax
   1312b:	01 c2                	add    %eax,%edx
   1312d:	8b 45 bc             	mov    -0x44(%ebp),%eax
   13130:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   13137:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1313a:	01 c8                	add    %ecx,%eax
   1313c:	0f b6 00             	movzbl (%eax),%eax
   1313f:	88 02                	mov    %al,(%edx)
   13141:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13145:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   13148:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1314b:	75 c7                	jne    13114 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   1314d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   13151:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13154:	3b 45 14             	cmp    0x14(%ebp),%eax
   13157:	0f 85 a9 fe ff ff    	jne    13006 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1315d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   13164:	eb 1a                	jmp    13180 <filter+0x7d0>
   13166:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13169:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   13170:	83 ec 0c             	sub    $0xc,%esp
   13173:	50                   	push   %eax
   13174:	e8 b8 12 ff ff       	call   4431 <lodepng_free>
   13179:	83 c4 10             	add    $0x10,%esp
   1317c:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   13180:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   13184:	75 e0                	jne    13166 <filter+0x7b6>
   13186:	eb 07                	jmp    1318f <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   13188:	b8 58 00 00 00       	mov    $0x58,%eax
   1318d:	eb 03                	jmp    13192 <filter+0x7e2>

  return error;
   1318f:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   13192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   13195:	c9                   	leave  
   13196:	c3                   	ret    

00013197 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   13197:	55                   	push   %ebp
   13198:	89 e5                	mov    %esp,%ebp
   1319a:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   1319d:	8b 45 10             	mov    0x10(%ebp),%eax
   131a0:	2b 45 14             	sub    0x14(%ebp),%eax
   131a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   131a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   131ad:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   131b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   131bb:	eb 65                	jmp    13222 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   131bd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   131c4:	eb 2a                	jmp    131f0 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   131c6:	ff 75 0c             	pushl  0xc(%ebp)
   131c9:	8d 45 e8             	lea    -0x18(%ebp),%eax
   131cc:	50                   	push   %eax
   131cd:	e8 9d 60 ff ff       	call   926f <readBitFromReversedStream>
   131d2:	83 c4 08             	add    $0x8,%esp
   131d5:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   131d8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   131dc:	50                   	push   %eax
   131dd:	ff 75 08             	pushl  0x8(%ebp)
   131e0:	8d 45 ec             	lea    -0x14(%ebp),%eax
   131e3:	50                   	push   %eax
   131e4:	e8 08 61 ff ff       	call   92f1 <setBitOfReversedStream>
   131e9:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   131ec:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   131f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   131f3:	3b 45 14             	cmp    0x14(%ebp),%eax
   131f6:	7c ce                	jl     131c6 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   131f8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   131ff:	eb 15                	jmp    13216 <addPaddingBits+0x7f>
   13201:	6a 00                	push   $0x0
   13203:	ff 75 08             	pushl  0x8(%ebp)
   13206:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13209:	50                   	push   %eax
   1320a:	e8 e2 60 ff ff       	call   92f1 <setBitOfReversedStream>
   1320f:	83 c4 0c             	add    $0xc,%esp
   13212:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   13216:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13219:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1321c:	75 e3                	jne    13201 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   1321e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13222:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13225:	3b 45 18             	cmp    0x18(%ebp),%eax
   13228:	75 93                	jne    131bd <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   1322a:	90                   	nop
   1322b:	c9                   	leave  
   1322c:	c3                   	ret    

0001322d <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   1322d:	55                   	push   %ebp
   1322e:	89 e5                	mov    %esp,%ebp
   13230:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   13236:	ff 75 18             	pushl  0x18(%ebp)
   13239:	ff 75 14             	pushl  0x14(%ebp)
   1323c:	ff 75 10             	pushl  0x10(%ebp)
   1323f:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   13245:	50                   	push   %eax
   13246:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   1324c:	50                   	push   %eax
   1324d:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   13253:	50                   	push   %eax
   13254:	8d 45 94             	lea    -0x6c(%ebp),%eax
   13257:	50                   	push   %eax
   13258:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1325b:	50                   	push   %eax
   1325c:	e8 fc ae ff ff       	call   e15d <Adam7_getpassvalues>
   13261:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   13264:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   13268:	0f 86 0a 01 00 00    	jbe    13378 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   1326e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13275:	e9 ef 00 00 00       	jmp    13369 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1327a:	8b 45 18             	mov    0x18(%ebp),%eax
   1327d:	c1 e8 03             	shr    $0x3,%eax
   13280:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   13283:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1328a:	e9 c6 00 00 00       	jmp    13355 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   1328f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13296:	e9 a6 00 00 00       	jmp    13341 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   1329b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1329e:	8b 14 85 b8 b0 01 00 	mov    0x1b0b8(,%eax,4),%edx
   132a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   132a8:	8b 04 85 f0 b0 01 00 	mov    0x1b0f0(,%eax,4),%eax
   132af:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   132b3:	01 d0                	add    %edx,%eax
   132b5:	0f af 45 10          	imul   0x10(%ebp),%eax
   132b9:	89 c2                	mov    %eax,%edx
   132bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   132be:	8b 04 85 d4 b0 01 00 	mov    0x1b0d4(,%eax,4),%eax
   132c5:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   132c9:	01 c2                	add    %eax,%edx
   132cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   132ce:	8b 04 85 9c b0 01 00 	mov    0x1b09c(,%eax,4),%eax
   132d5:	01 c2                	add    %eax,%edx
   132d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   132da:	0f af c2             	imul   %edx,%eax
   132dd:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   132e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   132e3:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   132ea:	89 c1                	mov    %eax,%ecx
   132ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
   132ef:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   132f3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   132f7:	89 c2                	mov    %eax,%edx
   132f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   132fc:	01 c2                	add    %eax,%edx
   132fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13301:	0f af c2             	imul   %edx,%eax
   13304:	01 c8                	add    %ecx,%eax
   13306:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   13309:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13310:	eb 23                	jmp    13335 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   13312:	8b 55 d8             	mov    -0x28(%ebp),%edx
   13315:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13318:	01 c2                	add    %eax,%edx
   1331a:	8b 45 08             	mov    0x8(%ebp),%eax
   1331d:	01 c2                	add    %eax,%edx
   1331f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   13322:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13325:	01 c1                	add    %eax,%ecx
   13327:	8b 45 0c             	mov    0xc(%ebp),%eax
   1332a:	01 c8                	add    %ecx,%eax
   1332c:	0f b6 00             	movzbl (%eax),%eax
   1332f:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   13331:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13335:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13338:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1333b:	72 d5                	jb     13312 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1333d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   13341:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13344:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   13348:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1334b:	0f 87 4a ff ff ff    	ja     1329b <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   13351:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13355:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13358:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1335c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1335f:	0f 87 2a ff ff ff    	ja     1328f <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   13365:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13369:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1336d:	0f 85 07 ff ff ff    	jne    1327a <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   13373:	e9 22 01 00 00       	jmp    1349a <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   13378:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1337f:	e9 0c 01 00 00       	jmp    13490 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   13384:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13387:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1338b:	0f af 45 18          	imul   0x18(%ebp),%eax
   1338f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   13392:	8b 45 18             	mov    0x18(%ebp),%eax
   13395:	0f af 45 10          	imul   0x10(%ebp),%eax
   13399:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1339c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   133a3:	e9 d4 00 00 00       	jmp    1347c <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   133a8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   133af:	e9 b4 00 00 00       	jmp    13468 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   133b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   133b7:	8b 14 85 b8 b0 01 00 	mov    0x1b0b8(,%eax,4),%edx
   133be:	8b 45 fc             	mov    -0x4(%ebp),%eax
   133c1:	8b 04 85 f0 b0 01 00 	mov    0x1b0f0(,%eax,4),%eax
   133c8:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   133cc:	01 d0                	add    %edx,%eax
   133ce:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   133d2:	89 c2                	mov    %eax,%edx
   133d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   133d7:	8b 0c 85 9c b0 01 00 	mov    0x1b09c(,%eax,4),%ecx
   133de:	8b 45 fc             	mov    -0x4(%ebp),%eax
   133e1:	8b 04 85 d4 b0 01 00 	mov    0x1b0d4(,%eax,4),%eax
   133e8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   133ec:	01 c8                	add    %ecx,%eax
   133ee:	0f af 45 18          	imul   0x18(%ebp),%eax
   133f2:	01 d0                	add    %edx,%eax
   133f4:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   133fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   133fd:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   13404:	c1 e0 03             	shl    $0x3,%eax
   13407:	89 c1                	mov    %eax,%ecx
   13409:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1340c:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   13410:	89 c2                	mov    %eax,%edx
   13412:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13415:	0f af 45 18          	imul   0x18(%ebp),%eax
   13419:	01 d0                	add    %edx,%eax
   1341b:	01 c8                	add    %ecx,%eax
   1341d:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   13423:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1342a:	eb 30                	jmp    1345c <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   1342c:	ff 75 0c             	pushl  0xc(%ebp)
   1342f:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   13435:	50                   	push   %eax
   13436:	e8 34 5e ff ff       	call   926f <readBitFromReversedStream>
   1343b:	83 c4 08             	add    $0x8,%esp
   1343e:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   13441:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   13445:	50                   	push   %eax
   13446:	ff 75 08             	pushl  0x8(%ebp)
   13449:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   1344f:	50                   	push   %eax
   13450:	e8 9c 5e ff ff       	call   92f1 <setBitOfReversedStream>
   13455:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   13458:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1345c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1345f:	3b 45 18             	cmp    0x18(%ebp),%eax
   13462:	72 c8                	jb     1342c <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   13464:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   13468:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1346b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1346f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   13472:	0f 87 3c ff ff ff    	ja     133b4 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   13478:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1347c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1347f:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   13483:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   13486:	0f 87 1c ff ff ff    	ja     133a8 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1348c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13490:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   13494:	0f 85 ea fe ff ff    	jne    13384 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1349a:	90                   	nop
   1349b:	c9                   	leave  
   1349c:	c3                   	ret    

0001349d <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   1349d:	55                   	push   %ebp
   1349e:	89 e5                	mov    %esp,%ebp
   134a0:	57                   	push   %edi
   134a1:	56                   	push   %esi
   134a2:	53                   	push   %ebx
   134a3:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   134a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134ac:	83 c0 0c             	add    $0xc,%eax
   134af:	50                   	push   %eax
   134b0:	e8 77 6a ff ff       	call   9f2c <lodepng_get_bpp>
   134b5:	83 c4 04             	add    $0x4,%esp
   134b8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   134bb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   134c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134c5:	8b 40 08             	mov    0x8(%eax),%eax
   134c8:	85 c0                	test   %eax,%eax
   134ca:	0f 85 49 01 00 00    	jne    13619 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   134d0:	8b 45 14             	mov    0x14(%ebp),%eax
   134d3:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   134d7:	83 c0 07             	add    $0x7,%eax
   134da:	c1 e8 03             	shr    $0x3,%eax
   134dd:	83 c0 01             	add    $0x1,%eax
   134e0:	0f af 45 18          	imul   0x18(%ebp),%eax
   134e4:	89 c2                	mov    %eax,%edx
   134e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   134e9:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   134eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   134ee:	8b 00                	mov    (%eax),%eax
   134f0:	83 ec 0c             	sub    $0xc,%esp
   134f3:	50                   	push   %eax
   134f4:	e8 17 0f ff ff       	call   4410 <lodepng_malloc>
   134f9:	83 c4 10             	add    $0x10,%esp
   134fc:	89 c2                	mov    %eax,%edx
   134fe:	8b 45 08             	mov    0x8(%ebp),%eax
   13501:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   13503:	8b 45 08             	mov    0x8(%ebp),%eax
   13506:	8b 00                	mov    (%eax),%eax
   13508:	85 c0                	test   %eax,%eax
   1350a:	75 10                	jne    1351c <preProcessScanlines+0x7f>
   1350c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1350f:	8b 00                	mov    (%eax),%eax
   13511:	85 c0                	test   %eax,%eax
   13513:	74 07                	je     1351c <preProcessScanlines+0x7f>
   13515:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   1351c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13520:	0f 85 fb 02 00 00    	jne    13821 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   13526:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1352a:	0f 87 bd 00 00 00    	ja     135ed <preProcessScanlines+0x150>
   13530:	8b 45 14             	mov    0x14(%ebp),%eax
   13533:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13537:	89 c2                	mov    %eax,%edx
   13539:	8b 45 14             	mov    0x14(%ebp),%eax
   1353c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13540:	83 c0 07             	add    $0x7,%eax
   13543:	c1 e8 03             	shr    $0x3,%eax
   13546:	c1 e0 03             	shl    $0x3,%eax
   13549:	39 c2                	cmp    %eax,%edx
   1354b:	0f 84 9c 00 00 00    	je     135ed <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   13551:	8b 45 14             	mov    0x14(%ebp),%eax
   13554:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13558:	83 c0 07             	add    $0x7,%eax
   1355b:	c1 e8 03             	shr    $0x3,%eax
   1355e:	0f af 45 18          	imul   0x18(%ebp),%eax
   13562:	83 ec 0c             	sub    $0xc,%esp
   13565:	50                   	push   %eax
   13566:	e8 a5 0e ff ff       	call   4410 <lodepng_malloc>
   1356b:	83 c4 10             	add    $0x10,%esp
   1356e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   13571:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   13575:	75 07                	jne    1357e <preProcessScanlines+0xe1>
   13577:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   1357e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13582:	75 56                	jne    135da <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   13584:	8b 45 14             	mov    0x14(%ebp),%eax
   13587:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1358b:	89 c2                	mov    %eax,%edx
   1358d:	8b 45 14             	mov    0x14(%ebp),%eax
   13590:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13594:	83 c0 07             	add    $0x7,%eax
   13597:	c1 e8 03             	shr    $0x3,%eax
   1359a:	c1 e0 03             	shl    $0x3,%eax
   1359d:	83 ec 0c             	sub    $0xc,%esp
   135a0:	ff 75 18             	pushl  0x18(%ebp)
   135a3:	52                   	push   %edx
   135a4:	50                   	push   %eax
   135a5:	ff 75 10             	pushl  0x10(%ebp)
   135a8:	ff 75 d8             	pushl  -0x28(%ebp)
   135ab:	e8 e7 fb ff ff       	call   13197 <addPaddingBits>
   135b0:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   135b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135b6:	8d 50 0c             	lea    0xc(%eax),%edx
   135b9:	8b 45 08             	mov    0x8(%ebp),%eax
   135bc:	8b 00                	mov    (%eax),%eax
   135be:	83 ec 08             	sub    $0x8,%esp
   135c1:	ff 75 20             	pushl  0x20(%ebp)
   135c4:	52                   	push   %edx
   135c5:	ff 75 18             	pushl  0x18(%ebp)
   135c8:	ff 75 14             	pushl  0x14(%ebp)
   135cb:	ff 75 d8             	pushl  -0x28(%ebp)
   135ce:	50                   	push   %eax
   135cf:	e8 dc f3 ff ff       	call   129b0 <filter>
   135d4:	83 c4 20             	add    $0x20,%esp
   135d7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   135da:	83 ec 0c             	sub    $0xc,%esp
   135dd:	ff 75 d8             	pushl  -0x28(%ebp)
   135e0:	e8 4c 0e ff ff       	call   4431 <lodepng_free>
   135e5:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   135e8:	e9 34 02 00 00       	jmp    13821 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   135ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135f0:	8d 50 0c             	lea    0xc(%eax),%edx
   135f3:	8b 45 08             	mov    0x8(%ebp),%eax
   135f6:	8b 00                	mov    (%eax),%eax
   135f8:	83 ec 08             	sub    $0x8,%esp
   135fb:	ff 75 20             	pushl  0x20(%ebp)
   135fe:	52                   	push   %edx
   135ff:	ff 75 18             	pushl  0x18(%ebp)
   13602:	ff 75 14             	pushl  0x14(%ebp)
   13605:	ff 75 10             	pushl  0x10(%ebp)
   13608:	50                   	push   %eax
   13609:	e8 a2 f3 ff ff       	call   129b0 <filter>
   1360e:	83 c4 20             	add    $0x20,%esp
   13611:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   13614:	e9 08 02 00 00       	jmp    13821 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   13619:	ff 75 dc             	pushl  -0x24(%ebp)
   1361c:	ff 75 18             	pushl  0x18(%ebp)
   1361f:	ff 75 14             	pushl  0x14(%ebp)
   13622:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   13628:	50                   	push   %eax
   13629:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   1362f:	50                   	push   %eax
   13630:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   13636:	50                   	push   %eax
   13637:	8d 45 98             	lea    -0x68(%ebp),%eax
   1363a:	50                   	push   %eax
   1363b:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   1363e:	50                   	push   %eax
   1363f:	e8 19 ab ff ff       	call   e15d <Adam7_getpassvalues>
   13644:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   13647:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   1364d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13650:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   13652:	8b 45 0c             	mov    0xc(%ebp),%eax
   13655:	8b 00                	mov    (%eax),%eax
   13657:	83 ec 0c             	sub    $0xc,%esp
   1365a:	50                   	push   %eax
   1365b:	e8 b0 0d ff ff       	call   4410 <lodepng_malloc>
   13660:	83 c4 10             	add    $0x10,%esp
   13663:	89 c2                	mov    %eax,%edx
   13665:	8b 45 08             	mov    0x8(%ebp),%eax
   13668:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   1366a:	8b 45 08             	mov    0x8(%ebp),%eax
   1366d:	8b 00                	mov    (%eax),%eax
   1366f:	85 c0                	test   %eax,%eax
   13671:	75 07                	jne    1367a <preProcessScanlines+0x1dd>
   13673:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   1367a:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1367d:	83 ec 0c             	sub    $0xc,%esp
   13680:	50                   	push   %eax
   13681:	e8 8a 0d ff ff       	call   4410 <lodepng_malloc>
   13686:	83 c4 10             	add    $0x10,%esp
   13689:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   1368c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   13690:	75 0e                	jne    136a0 <preProcessScanlines+0x203>
   13692:	8b 45 94             	mov    -0x6c(%ebp),%eax
   13695:	85 c0                	test   %eax,%eax
   13697:	74 07                	je     136a0 <preProcessScanlines+0x203>
   13699:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   136a0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   136a4:	0f 85 69 01 00 00    	jne    13813 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   136aa:	83 ec 0c             	sub    $0xc,%esp
   136ad:	ff 75 dc             	pushl  -0x24(%ebp)
   136b0:	ff 75 18             	pushl  0x18(%ebp)
   136b3:	ff 75 14             	pushl  0x14(%ebp)
   136b6:	ff 75 10             	pushl  0x10(%ebp)
   136b9:	ff 75 d4             	pushl  -0x2c(%ebp)
   136bc:	e8 6c fb ff ff       	call   1322d <Adam7_interlace>
   136c1:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   136c4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   136cb:	e9 36 01 00 00       	jmp    13806 <preProcessScanlines+0x369>
        if(bpp < 8) {
   136d0:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   136d4:	0f 87 d6 00 00 00    	ja     137b0 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   136da:	8b 45 e0             	mov    -0x20(%ebp),%eax
   136dd:	83 c0 01             	add    $0x1,%eax
   136e0:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   136e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   136ea:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   136f1:	29 c2                	sub    %eax,%edx
   136f3:	89 d0                	mov    %edx,%eax
   136f5:	83 ec 0c             	sub    $0xc,%esp
   136f8:	50                   	push   %eax
   136f9:	e8 12 0d ff ff       	call   4410 <lodepng_malloc>
   136fe:	83 c4 10             	add    $0x10,%esp
   13701:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   13704:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   13708:	75 0c                	jne    13716 <preProcessScanlines+0x279>
   1370a:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   13711:	e9 fd 00 00 00       	jmp    13813 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   13716:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13719:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1371d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   13720:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   13724:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   13728:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1372a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1372d:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   13731:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   13735:	83 c2 07             	add    $0x7,%edx
   13738:	c1 ea 03             	shr    $0x3,%edx
   1373b:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1373e:	89 d1                	mov    %edx,%ecx
   13740:	8b 55 e0             	mov    -0x20(%ebp),%edx
   13743:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   1374a:	89 d6                	mov    %edx,%esi
   1374c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1374f:	01 f2                	add    %esi,%edx
   13751:	83 ec 0c             	sub    $0xc,%esp
   13754:	50                   	push   %eax
   13755:	53                   	push   %ebx
   13756:	51                   	push   %ecx
   13757:	52                   	push   %edx
   13758:	ff 75 d0             	pushl  -0x30(%ebp)
   1375b:	e8 37 fa ff ff       	call   13197 <addPaddingBits>
   13760:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   13763:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13766:	8d 58 0c             	lea    0xc(%eax),%ebx
   13769:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1376c:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   13770:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13773:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   13777:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1377a:	8b 31                	mov    (%ecx),%esi
   1377c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1377f:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   13786:	01 f1                	add    %esi,%ecx
   13788:	83 ec 08             	sub    $0x8,%esp
   1378b:	ff 75 20             	pushl  0x20(%ebp)
   1378e:	53                   	push   %ebx
   1378f:	52                   	push   %edx
   13790:	50                   	push   %eax
   13791:	ff 75 d0             	pushl  -0x30(%ebp)
   13794:	51                   	push   %ecx
   13795:	e8 16 f2 ff ff       	call   129b0 <filter>
   1379a:	83 c4 20             	add    $0x20,%esp
   1379d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   137a0:	83 ec 0c             	sub    $0xc,%esp
   137a3:	ff 75 d0             	pushl  -0x30(%ebp)
   137a6:	e8 86 0c ff ff       	call   4431 <lodepng_free>
   137ab:	83 c4 10             	add    $0x10,%esp
   137ae:	eb 4c                	jmp    137fc <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   137b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137b3:	8d 70 0c             	lea    0xc(%eax),%esi
   137b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   137b9:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   137bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   137c0:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   137c4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   137c7:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   137ce:	89 cb                	mov    %ecx,%ebx
   137d0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   137d3:	01 cb                	add    %ecx,%ebx
   137d5:	8b 4d 08             	mov    0x8(%ebp),%ecx
   137d8:	8b 39                	mov    (%ecx),%edi
   137da:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   137dd:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   137e4:	01 f9                	add    %edi,%ecx
   137e6:	83 ec 08             	sub    $0x8,%esp
   137e9:	ff 75 20             	pushl  0x20(%ebp)
   137ec:	56                   	push   %esi
   137ed:	52                   	push   %edx
   137ee:	50                   	push   %eax
   137ef:	53                   	push   %ebx
   137f0:	51                   	push   %ecx
   137f1:	e8 ba f1 ff ff       	call   129b0 <filter>
   137f6:	83 c4 20             	add    $0x20,%esp
   137f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   137fc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13800:	75 10                	jne    13812 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   13802:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   13806:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   1380a:	0f 85 c0 fe ff ff    	jne    136d0 <preProcessScanlines+0x233>
   13810:	eb 01                	jmp    13813 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   13812:	90                   	nop
      }
    }

    lodepng_free(adam7);
   13813:	83 ec 0c             	sub    $0xc,%esp
   13816:	ff 75 d4             	pushl  -0x2c(%ebp)
   13819:	e8 13 0c ff ff       	call   4431 <lodepng_free>
   1381e:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   13821:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   13824:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13827:	5b                   	pop    %ebx
   13828:	5e                   	pop    %esi
   13829:	5f                   	pop    %edi
   1382a:	5d                   	pop    %ebp
   1382b:	c3                   	ret    

0001382c <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   1382c:	55                   	push   %ebp
   1382d:	89 e5                	mov    %esp,%ebp
   1382f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   13832:	8b 45 0c             	mov    0xc(%ebp),%eax
   13835:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   13838:	eb 47                	jmp    13881 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   1383a:	8b 45 08             	mov    0x8(%ebp),%eax
   1383d:	8d 50 04             	lea    0x4(%eax),%edx
   13840:	8b 45 08             	mov    0x8(%ebp),%eax
   13843:	ff 75 fc             	pushl  -0x4(%ebp)
   13846:	52                   	push   %edx
   13847:	50                   	push   %eax
   13848:	e8 73 5f ff ff       	call   97c0 <lodepng_chunk_append>
   1384d:	83 c4 0c             	add    $0xc,%esp
   13850:	89 45 f8             	mov    %eax,-0x8(%ebp)
   13853:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   13857:	74 05                	je     1385e <addUnknownChunks+0x32>
   13859:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1385c:	eb 37                	jmp    13895 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   1385e:	8b 45 08             	mov    0x8(%ebp),%eax
   13861:	8b 50 04             	mov    0x4(%eax),%edx
   13864:	8b 45 08             	mov    0x8(%ebp),%eax
   13867:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   1386a:	8b 55 10             	mov    0x10(%ebp),%edx
   1386d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13870:	01 d0                	add    %edx,%eax
   13872:	50                   	push   %eax
   13873:	ff 75 fc             	pushl  -0x4(%ebp)
   13876:	e8 ff 5c ff ff       	call   957a <lodepng_chunk_next>
   1387b:	83 c4 08             	add    $0x8,%esp
   1387e:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   13881:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13884:	8b 45 0c             	mov    0xc(%ebp),%eax
   13887:	29 c2                	sub    %eax,%edx
   13889:	89 d0                	mov    %edx,%eax
   1388b:	3b 45 10             	cmp    0x10(%ebp),%eax
   1388e:	7c aa                	jl     1383a <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   13890:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13895:	c9                   	leave  
   13896:	c3                   	ret    

00013897 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   13897:	55                   	push   %ebp
   13898:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   1389a:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   1389e:	77 07                	ja     138a7 <isGrayICCProfile+0x10>
   138a0:	b8 00 00 00 00       	mov    $0x0,%eax
   138a5:	eb 40                	jmp    138e7 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   138a7:	8b 45 08             	mov    0x8(%ebp),%eax
   138aa:	83 c0 10             	add    $0x10,%eax
   138ad:	0f b6 00             	movzbl (%eax),%eax
   138b0:	3c 47                	cmp    $0x47,%al
   138b2:	75 2e                	jne    138e2 <isGrayICCProfile+0x4b>
   138b4:	8b 45 08             	mov    0x8(%ebp),%eax
   138b7:	83 c0 11             	add    $0x11,%eax
   138ba:	0f b6 00             	movzbl (%eax),%eax
   138bd:	3c 52                	cmp    $0x52,%al
   138bf:	75 21                	jne    138e2 <isGrayICCProfile+0x4b>
   138c1:	8b 45 08             	mov    0x8(%ebp),%eax
   138c4:	83 c0 12             	add    $0x12,%eax
   138c7:	0f b6 00             	movzbl (%eax),%eax
   138ca:	3c 41                	cmp    $0x41,%al
   138cc:	75 14                	jne    138e2 <isGrayICCProfile+0x4b>
   138ce:	8b 45 08             	mov    0x8(%ebp),%eax
   138d1:	83 c0 13             	add    $0x13,%eax
   138d4:	0f b6 00             	movzbl (%eax),%eax
   138d7:	3c 59                	cmp    $0x59,%al
   138d9:	75 07                	jne    138e2 <isGrayICCProfile+0x4b>
   138db:	b8 01 00 00 00       	mov    $0x1,%eax
   138e0:	eb 05                	jmp    138e7 <isGrayICCProfile+0x50>
   138e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   138e7:	5d                   	pop    %ebp
   138e8:	c3                   	ret    

000138e9 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   138e9:	55                   	push   %ebp
   138ea:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   138ec:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   138f0:	77 07                	ja     138f9 <isRGBICCProfile+0x10>
   138f2:	b8 00 00 00 00       	mov    $0x0,%eax
   138f7:	eb 40                	jmp    13939 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   138f9:	8b 45 08             	mov    0x8(%ebp),%eax
   138fc:	83 c0 10             	add    $0x10,%eax
   138ff:	0f b6 00             	movzbl (%eax),%eax
   13902:	3c 52                	cmp    $0x52,%al
   13904:	75 2e                	jne    13934 <isRGBICCProfile+0x4b>
   13906:	8b 45 08             	mov    0x8(%ebp),%eax
   13909:	83 c0 11             	add    $0x11,%eax
   1390c:	0f b6 00             	movzbl (%eax),%eax
   1390f:	3c 47                	cmp    $0x47,%al
   13911:	75 21                	jne    13934 <isRGBICCProfile+0x4b>
   13913:	8b 45 08             	mov    0x8(%ebp),%eax
   13916:	83 c0 12             	add    $0x12,%eax
   13919:	0f b6 00             	movzbl (%eax),%eax
   1391c:	3c 42                	cmp    $0x42,%al
   1391e:	75 14                	jne    13934 <isRGBICCProfile+0x4b>
   13920:	8b 45 08             	mov    0x8(%ebp),%eax
   13923:	83 c0 13             	add    $0x13,%eax
   13926:	0f b6 00             	movzbl (%eax),%eax
   13929:	3c 20                	cmp    $0x20,%al
   1392b:	75 07                	jne    13934 <isRGBICCProfile+0x4b>
   1392d:	b8 01 00 00 00       	mov    $0x1,%eax
   13932:	eb 05                	jmp    13939 <isRGBICCProfile+0x50>
   13934:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13939:	5d                   	pop    %ebp
   1393a:	c3                   	ret    

0001393b <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   1393b:	55                   	push   %ebp
   1393c:	89 e5                	mov    %esp,%ebp
   1393e:	57                   	push   %edi
   1393f:	56                   	push   %esi
   13940:	53                   	push   %ebx
   13941:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   13947:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   1394e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   13955:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13958:	6a 00                	push   $0x0
   1395a:	6a 00                	push   $0x0
   1395c:	50                   	push   %eax
   1395d:	e8 6f 0d ff ff       	call   46d1 <ucvector_init>
   13962:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   13965:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13968:	05 98 00 00 00       	add    $0x98,%eax
   1396d:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   13970:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13976:	50                   	push   %eax
   13977:	e8 3a 71 ff ff       	call   aab6 <lodepng_info_init>
   1397c:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   1397f:	8b 45 08             	mov    0x8(%ebp),%eax
   13982:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   13988:	8b 45 0c             	mov    0xc(%ebp),%eax
   1398b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   13991:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13994:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   1399b:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   1399e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   139a1:	8b 40 0c             	mov    0xc(%eax),%eax
   139a4:	83 f8 03             	cmp    $0x3,%eax
   139a7:	74 0a                	je     139b3 <lodepng_encode+0x78>
   139a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139ac:	8b 40 6c             	mov    0x6c(%eax),%eax
   139af:	85 c0                	test   %eax,%eax
   139b1:	74 29                	je     139dc <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   139b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   139b6:	8b 40 18             	mov    0x18(%eax),%eax
   139b9:	85 c0                	test   %eax,%eax
   139bb:	74 0d                	je     139ca <lodepng_encode+0x8f>
   139bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   139c0:	8b 40 18             	mov    0x18(%eax),%eax
   139c3:	3d 00 01 00 00       	cmp    $0x100,%eax
   139c8:	7e 12                	jle    139dc <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   139ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139cd:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   139d4:	00 00 00 
    goto cleanup;
   139d7:	e9 78 0c 00 00       	jmp    14654 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   139dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139df:	8b 40 38             	mov    0x38(%eax),%eax
   139e2:	83 f8 02             	cmp    $0x2,%eax
   139e5:	76 12                	jbe    139f9 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   139e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139ea:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   139f1:	00 00 00 
    goto cleanup;
   139f4:	e9 5b 0c 00 00       	jmp    14654 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   139f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   139fc:	8b 40 08             	mov    0x8(%eax),%eax
   139ff:	83 f8 01             	cmp    $0x1,%eax
   13a02:	76 12                	jbe    13a16 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   13a04:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a07:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   13a0e:	00 00 00 
    goto cleanup;
   13a11:	e9 3e 0c 00 00       	jmp    14654 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   13a16:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a19:	8b 50 10             	mov    0x10(%eax),%edx
   13a1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a1f:	8b 40 0c             	mov    0xc(%eax),%eax
   13a22:	52                   	push   %edx
   13a23:	50                   	push   %eax
   13a24:	e8 a4 5f ff ff       	call   99cd <checkColorValidity>
   13a29:	83 c4 08             	add    $0x8,%esp
   13a2c:	89 c2                	mov    %eax,%edx
   13a2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a31:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13a37:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a3a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a40:	85 c0                	test   %eax,%eax
   13a42:	0f 85 c6 0b 00 00    	jne    1460e <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   13a48:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a4b:	8b 50 7c             	mov    0x7c(%eax),%edx
   13a4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a51:	8b 40 78             	mov    0x78(%eax),%eax
   13a54:	52                   	push   %edx
   13a55:	50                   	push   %eax
   13a56:	e8 72 5f ff ff       	call   99cd <checkColorValidity>
   13a5b:	83 c4 08             	add    $0x8,%esp
   13a5e:	89 c2                	mov    %eax,%edx
   13a60:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a63:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13a69:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a6c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a72:	85 c0                	test   %eax,%eax
   13a74:	0f 85 97 0b 00 00    	jne    14611 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   13a7a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a7d:	05 98 00 00 00       	add    $0x98,%eax
   13a82:	83 ec 08             	sub    $0x8,%esp
   13a85:	50                   	push   %eax
   13a86:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13a8c:	50                   	push   %eax
   13a8d:	e8 58 71 ff ff       	call   abea <lodepng_info_copy>
   13a92:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   13a95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a98:	8b 40 5c             	mov    0x5c(%eax),%eax
   13a9b:	85 c0                	test   %eax,%eax
   13a9d:	0f 84 3c 02 00 00    	je     13cdf <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   13aa3:	83 ec 0c             	sub    $0xc,%esp
   13aa6:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   13aac:	50                   	push   %eax
   13aad:	e8 5f 96 ff ff       	call   d111 <lodepng_color_stats_init>
   13ab2:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   13ab5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13ab8:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13abe:	85 c0                	test   %eax,%eax
   13ac0:	74 2d                	je     13aef <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   13ac2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13ac5:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13acb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13ace:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   13ad4:	83 ec 08             	sub    $0x8,%esp
   13ad7:	52                   	push   %edx
   13ad8:	50                   	push   %eax
   13ad9:	e8 b9 fd ff ff       	call   13897 <isGrayICCProfile>
   13ade:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   13ae1:	85 c0                	test   %eax,%eax
   13ae3:	74 0a                	je     13aef <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   13ae5:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   13aec:	00 00 00 
    }
    if(info_png->iccp_defined &&
   13aef:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13af2:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13af8:	85 c0                	test   %eax,%eax
   13afa:	74 2d                	je     13b29 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   13afc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13aff:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13b05:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13b08:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   13b0e:	83 ec 08             	sub    $0x8,%esp
   13b11:	52                   	push   %edx
   13b12:	50                   	push   %eax
   13b13:	e8 d1 fd ff ff       	call   138e9 <isRGBICCProfile>
   13b18:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   13b1b:	85 c0                	test   %eax,%eax
   13b1d:	74 0a                	je     13b29 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   13b1f:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   13b26:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   13b29:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b2c:	83 c0 78             	add    $0x78,%eax
   13b2f:	83 ec 0c             	sub    $0xc,%esp
   13b32:	50                   	push   %eax
   13b33:	ff 75 18             	pushl  0x18(%ebp)
   13b36:	ff 75 14             	pushl  0x14(%ebp)
   13b39:	ff 75 10             	pushl  0x10(%ebp)
   13b3c:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   13b42:	50                   	push   %eax
   13b43:	e8 e0 96 ff ff       	call   d228 <lodepng_compute_color_stats>
   13b48:	83 c4 20             	add    $0x20,%esp
   13b4b:	89 c2                	mov    %eax,%edx
   13b4d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b50:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13b56:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b59:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13b5f:	85 c0                	test   %eax,%eax
   13b61:	0f 85 ad 0a 00 00    	jne    14614 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   13b67:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13b6a:	8b 40 2c             	mov    0x2c(%eax),%eax
   13b6d:	85 c0                	test   %eax,%eax
   13b6f:	0f 84 be 00 00 00    	je     13c33 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   13b75:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   13b7c:	00 00 00 
   13b7f:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   13b86:	00 00 00 
   13b89:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   13b90:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   13b93:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   13b99:	83 ec 04             	sub    $0x4,%esp
   13b9c:	6a 10                	push   $0x10
   13b9e:	6a 02                	push   $0x2
   13ba0:	50                   	push   %eax
   13ba1:	e8 15 61 ff ff       	call   9cbb <lodepng_color_mode_make>
   13ba6:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   13ba9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13bac:	8d 58 0c             	lea    0xc(%eax),%ebx
   13baf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13bb2:	8b 48 38             	mov    0x38(%eax),%ecx
   13bb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13bb8:	8b 50 34             	mov    0x34(%eax),%edx
   13bbb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13bbe:	8b 40 30             	mov    0x30(%eax),%eax
   13bc1:	53                   	push   %ebx
   13bc2:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   13bc8:	53                   	push   %ebx
   13bc9:	51                   	push   %ecx
   13bca:	52                   	push   %edx
   13bcb:	50                   	push   %eax
   13bcc:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   13bd2:	50                   	push   %eax
   13bd3:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   13bd9:	50                   	push   %eax
   13bda:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   13be0:	50                   	push   %eax
   13be1:	e8 8a 92 ff ff       	call   ce70 <lodepng_convert_rgb>
   13be6:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   13be9:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   13bef:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   13bf5:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   13bfb:	83 ec 0c             	sub    $0xc,%esp
   13bfe:	68 ff ff 00 00       	push   $0xffff
   13c03:	51                   	push   %ecx
   13c04:	52                   	push   %edx
   13c05:	50                   	push   %eax
   13c06:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   13c0c:	50                   	push   %eax
   13c0d:	e8 26 a1 ff ff       	call   dd38 <lodepng_color_stats_add>
   13c12:	83 c4 20             	add    $0x20,%esp
   13c15:	89 c2                	mov    %eax,%edx
   13c17:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c1a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13c20:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c23:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13c29:	85 c0                	test   %eax,%eax
   13c2b:	74 06                	je     13c33 <lodepng_encode+0x2f8>
   13c2d:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13c2e:	e9 e1 09 00 00       	jmp    14614 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   13c33:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c36:	8d 50 78             	lea    0x78(%eax),%edx
   13c39:	83 ec 04             	sub    $0x4,%esp
   13c3c:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   13c42:	50                   	push   %eax
   13c43:	52                   	push   %edx
   13c44:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13c4a:	83 c0 0c             	add    $0xc,%eax
   13c4d:	50                   	push   %eax
   13c4e:	e8 79 a1 ff ff       	call   ddcc <auto_choose_color>
   13c53:	83 c4 10             	add    $0x10,%esp
   13c56:	89 c2                	mov    %eax,%edx
   13c58:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c5b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13c61:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c64:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13c6a:	85 c0                	test   %eax,%eax
   13c6c:	0f 85 a5 09 00 00    	jne    14617 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   13c72:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13c75:	8b 40 2c             	mov    0x2c(%eax),%eax
   13c78:	85 c0                	test   %eax,%eax
   13c7a:	74 63                	je     13cdf <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   13c7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13c7f:	8d 58 0c             	lea    0xc(%eax),%ebx
   13c82:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13c85:	8b 48 38             	mov    0x38(%eax),%ecx
   13c88:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13c8b:	8b 50 34             	mov    0x34(%eax),%edx
   13c8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13c91:	8b 40 30             	mov    0x30(%eax),%eax
   13c94:	53                   	push   %ebx
   13c95:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   13c9b:	83 c3 0c             	add    $0xc,%ebx
   13c9e:	53                   	push   %ebx
   13c9f:	51                   	push   %ecx
   13ca0:	52                   	push   %edx
   13ca1:	50                   	push   %eax
   13ca2:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13ca8:	83 c0 38             	add    $0x38,%eax
   13cab:	50                   	push   %eax
   13cac:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13cb2:	83 c0 34             	add    $0x34,%eax
   13cb5:	50                   	push   %eax
   13cb6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13cbc:	83 c0 30             	add    $0x30,%eax
   13cbf:	50                   	push   %eax
   13cc0:	e8 ab 91 ff ff       	call   ce70 <lodepng_convert_rgb>
   13cc5:	83 c4 20             	add    $0x20,%esp
   13cc8:	85 c0                	test   %eax,%eax
   13cca:	74 13                	je     13cdf <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   13ccc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ccf:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   13cd6:	00 00 00 
        goto cleanup;
   13cd9:	90                   	nop
   13cda:	e9 75 09 00 00       	jmp    14654 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   13cdf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13ce2:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13ce8:	85 c0                	test   %eax,%eax
   13cea:	0f 84 b2 00 00 00    	je     13da2 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   13cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13cf3:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13cf9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13cfc:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   13d02:	83 ec 08             	sub    $0x8,%esp
   13d05:	52                   	push   %edx
   13d06:	50                   	push   %eax
   13d07:	e8 8b fb ff ff       	call   13897 <isGrayICCProfile>
   13d0c:	83 c4 10             	add    $0x10,%esp
   13d0f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   13d12:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13d15:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13d1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13d1e:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   13d24:	83 ec 08             	sub    $0x8,%esp
   13d27:	52                   	push   %edx
   13d28:	50                   	push   %eax
   13d29:	e8 bb fb ff ff       	call   138e9 <isRGBICCProfile>
   13d2e:	83 c4 10             	add    $0x10,%esp
   13d31:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   13d34:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13d3a:	85 c0                	test   %eax,%eax
   13d3c:	74 0b                	je     13d49 <lodepng_encode+0x40e>
   13d3e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13d44:	83 f8 04             	cmp    $0x4,%eax
   13d47:	75 07                	jne    13d50 <lodepng_encode+0x415>
   13d49:	b8 01 00 00 00       	mov    $0x1,%eax
   13d4e:	eb 05                	jmp    13d55 <lodepng_encode+0x41a>
   13d50:	b8 00 00 00 00       	mov    $0x0,%eax
   13d55:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   13d58:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   13d5c:	75 18                	jne    13d76 <lodepng_encode+0x43b>
   13d5e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   13d62:	75 12                	jne    13d76 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   13d64:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d67:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   13d6e:	00 00 00 
      goto cleanup;
   13d71:	e9 de 08 00 00       	jmp    14654 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   13d76:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13d79:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   13d7c:	74 24                	je     13da2 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   13d7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d81:	8b 40 5c             	mov    0x5c(%eax),%eax
   13d84:	85 c0                	test   %eax,%eax
   13d86:	74 07                	je     13d8f <lodepng_encode+0x454>
   13d88:	ba 66 00 00 00       	mov    $0x66,%edx
   13d8d:	eb 05                	jmp    13d94 <lodepng_encode+0x459>
   13d8f:	ba 65 00 00 00       	mov    $0x65,%edx
   13d94:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d97:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   13d9d:	e9 b2 08 00 00       	jmp    14654 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   13da2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13da5:	83 c0 78             	add    $0x78,%eax
   13da8:	83 ec 08             	sub    $0x8,%esp
   13dab:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   13db1:	83 c2 0c             	add    $0xc,%edx
   13db4:	52                   	push   %edx
   13db5:	50                   	push   %eax
   13db6:	e8 57 5f ff ff       	call   9d12 <lodepng_color_mode_equal>
   13dbb:	83 c4 10             	add    $0x10,%esp
   13dbe:	85 c0                	test   %eax,%eax
   13dc0:	0f 85 f8 00 00 00    	jne    13ebe <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   13dc6:	8b 55 14             	mov    0x14(%ebp),%edx
   13dc9:	8b 45 18             	mov    0x18(%ebp),%eax
   13dcc:	89 d3                	mov    %edx,%ebx
   13dce:	0f af d8             	imul   %eax,%ebx
   13dd1:	83 ec 0c             	sub    $0xc,%esp
   13dd4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13dda:	83 c0 0c             	add    $0xc,%eax
   13ddd:	50                   	push   %eax
   13dde:	e8 49 61 ff ff       	call   9f2c <lodepng_get_bpp>
   13de3:	83 c4 10             	add    $0x10,%esp
   13de6:	0f af c3             	imul   %ebx,%eax
   13de9:	83 c0 07             	add    $0x7,%eax
   13dec:	c1 e8 03             	shr    $0x3,%eax
   13def:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   13df2:	83 ec 0c             	sub    $0xc,%esp
   13df5:	ff 75 cc             	pushl  -0x34(%ebp)
   13df8:	e8 13 06 ff ff       	call   4410 <lodepng_malloc>
   13dfd:	83 c4 10             	add    $0x10,%esp
   13e00:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   13e03:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   13e07:	75 13                	jne    13e1c <lodepng_encode+0x4e1>
   13e09:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   13e0d:	74 0d                	je     13e1c <lodepng_encode+0x4e1>
   13e0f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e12:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   13e19:	00 00 00 
    if(!state->error) {
   13e1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e1f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13e25:	85 c0                	test   %eax,%eax
   13e27:	75 33                	jne    13e5c <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   13e29:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e2c:	83 c0 78             	add    $0x78,%eax
   13e2f:	83 ec 08             	sub    $0x8,%esp
   13e32:	ff 75 18             	pushl  0x18(%ebp)
   13e35:	ff 75 14             	pushl  0x14(%ebp)
   13e38:	50                   	push   %eax
   13e39:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13e3f:	83 c0 0c             	add    $0xc,%eax
   13e42:	50                   	push   %eax
   13e43:	ff 75 10             	pushl  0x10(%ebp)
   13e46:	ff 75 c8             	pushl  -0x38(%ebp)
   13e49:	e8 c9 8c ff ff       	call   cb17 <lodepng_convert>
   13e4e:	83 c4 20             	add    $0x20,%esp
   13e51:	89 c2                	mov    %eax,%edx
   13e53:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e56:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   13e5c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e5f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13e65:	85 c0                	test   %eax,%eax
   13e67:	75 35                	jne    13e9e <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   13e69:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e6c:	83 c0 38             	add    $0x38,%eax
   13e6f:	83 ec 04             	sub    $0x4,%esp
   13e72:	50                   	push   %eax
   13e73:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13e79:	50                   	push   %eax
   13e7a:	ff 75 18             	pushl  0x18(%ebp)
   13e7d:	ff 75 14             	pushl  0x14(%ebp)
   13e80:	ff 75 c8             	pushl  -0x38(%ebp)
   13e83:	8d 45 bc             	lea    -0x44(%ebp),%eax
   13e86:	50                   	push   %eax
   13e87:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13e8a:	50                   	push   %eax
   13e8b:	e8 0d f6 ff ff       	call   1349d <preProcessScanlines>
   13e90:	83 c4 20             	add    $0x20,%esp
   13e93:	89 c2                	mov    %eax,%edx
   13e95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e98:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   13e9e:	83 ec 0c             	sub    $0xc,%esp
   13ea1:	ff 75 c8             	pushl  -0x38(%ebp)
   13ea4:	e8 88 05 ff ff       	call   4431 <lodepng_free>
   13ea9:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   13eac:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13eaf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13eb5:	85 c0                	test   %eax,%eax
   13eb7:	74 4b                	je     13f04 <lodepng_encode+0x5c9>
   13eb9:	e9 96 07 00 00       	jmp    14654 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   13ebe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ec1:	83 c0 38             	add    $0x38,%eax
   13ec4:	83 ec 04             	sub    $0x4,%esp
   13ec7:	50                   	push   %eax
   13ec8:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13ece:	50                   	push   %eax
   13ecf:	ff 75 18             	pushl  0x18(%ebp)
   13ed2:	ff 75 14             	pushl  0x14(%ebp)
   13ed5:	ff 75 10             	pushl  0x10(%ebp)
   13ed8:	8d 45 bc             	lea    -0x44(%ebp),%eax
   13edb:	50                   	push   %eax
   13edc:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13edf:	50                   	push   %eax
   13ee0:	e8 b8 f5 ff ff       	call   1349d <preProcessScanlines>
   13ee5:	83 c4 20             	add    $0x20,%esp
   13ee8:	89 c2                	mov    %eax,%edx
   13eea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13eed:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13ef3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ef6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13efc:	85 c0                	test   %eax,%eax
   13efe:	0f 85 16 07 00 00    	jne    1461a <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   13f04:	83 ec 0c             	sub    $0xc,%esp
   13f07:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13f0a:	50                   	push   %eax
   13f0b:	e8 21 d9 ff ff       	call   11831 <writeSignature>
   13f10:	83 c4 10             	add    $0x10,%esp
   13f13:	89 c2                	mov    %eax,%edx
   13f15:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f18:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13f1e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f21:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13f27:	85 c0                	test   %eax,%eax
   13f29:	0f 85 ee 06 00 00    	jne    1461d <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   13f2f:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   13f35:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   13f3b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13f41:	83 ec 08             	sub    $0x8,%esp
   13f44:	51                   	push   %ecx
   13f45:	52                   	push   %edx
   13f46:	50                   	push   %eax
   13f47:	ff 75 18             	pushl  0x18(%ebp)
   13f4a:	ff 75 14             	pushl  0x14(%ebp)
   13f4d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13f50:	50                   	push   %eax
   13f51:	e8 4a d9 ff ff       	call   118a0 <addChunk_IHDR>
   13f56:	83 c4 20             	add    $0x20,%esp
   13f59:	89 c2                	mov    %eax,%edx
   13f5b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f5e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13f64:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f67:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13f6d:	85 c0                	test   %eax,%eax
   13f6f:	0f 85 ab 06 00 00    	jne    14620 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   13f75:	8b 45 98             	mov    -0x68(%ebp),%eax
   13f78:	85 c0                	test   %eax,%eax
   13f7a:	74 33                	je     13faf <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   13f7c:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   13f7f:	8b 45 98             	mov    -0x68(%ebp),%eax
   13f82:	83 ec 04             	sub    $0x4,%esp
   13f85:	52                   	push   %edx
   13f86:	50                   	push   %eax
   13f87:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13f8a:	50                   	push   %eax
   13f8b:	e8 9c f8 ff ff       	call   1382c <addUnknownChunks>
   13f90:	83 c4 10             	add    $0x10,%esp
   13f93:	89 c2                	mov    %eax,%edx
   13f95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f98:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13f9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fa1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13fa7:	85 c0                	test   %eax,%eax
   13fa9:	0f 85 74 06 00 00    	jne    14623 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   13faf:	8b 45 88             	mov    -0x78(%ebp),%eax
   13fb2:	85 c0                	test   %eax,%eax
   13fb4:	74 39                	je     13fef <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   13fb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fb9:	83 c0 38             	add    $0x38,%eax
   13fbc:	83 ec 04             	sub    $0x4,%esp
   13fbf:	50                   	push   %eax
   13fc0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13fc6:	50                   	push   %eax
   13fc7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13fca:	50                   	push   %eax
   13fcb:	e8 a4 e4 ff ff       	call   12474 <addChunk_iCCP>
   13fd0:	83 c4 10             	add    $0x10,%esp
   13fd3:	89 c2                	mov    %eax,%edx
   13fd5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fd8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13fde:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fe1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13fe7:	85 c0                	test   %eax,%eax
   13fe9:	0f 85 37 06 00 00    	jne    14626 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   13fef:	8b 45 80             	mov    -0x80(%ebp),%eax
   13ff2:	85 c0                	test   %eax,%eax
   13ff4:	74 32                	je     14028 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   13ff6:	83 ec 08             	sub    $0x8,%esp
   13ff9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13fff:	50                   	push   %eax
   14000:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14003:	50                   	push   %eax
   14004:	e8 41 e4 ff ff       	call   1244a <addChunk_sRGB>
   14009:	83 c4 10             	add    $0x10,%esp
   1400c:	89 c2                	mov    %eax,%edx
   1400e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14011:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14017:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1401a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14020:	85 c0                	test   %eax,%eax
   14022:	0f 85 01 06 00 00    	jne    14629 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   14028:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   1402e:	85 c0                	test   %eax,%eax
   14030:	74 32                	je     14064 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   14032:	83 ec 08             	sub    $0x8,%esp
   14035:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1403b:	50                   	push   %eax
   1403c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1403f:	50                   	push   %eax
   14040:	e8 a7 e2 ff ff       	call   122ec <addChunk_gAMA>
   14045:	83 c4 10             	add    $0x10,%esp
   14048:	89 c2                	mov    %eax,%edx
   1404a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1404d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14053:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14056:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1405c:	85 c0                	test   %eax,%eax
   1405e:	0f 85 c8 05 00 00    	jne    1462c <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   14064:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   1406a:	85 c0                	test   %eax,%eax
   1406c:	74 32                	je     140a0 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   1406e:	83 ec 08             	sub    $0x8,%esp
   14071:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14077:	50                   	push   %eax
   14078:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1407b:	50                   	push   %eax
   1407c:	e8 c1 e2 ff ff       	call   12342 <addChunk_cHRM>
   14081:	83 c4 10             	add    $0x10,%esp
   14084:	89 c2                	mov    %eax,%edx
   14086:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14089:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1408f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14092:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14098:	85 c0                	test   %eax,%eax
   1409a:	0f 85 8f 05 00 00    	jne    1462f <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   140a0:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   140a6:	83 f8 03             	cmp    $0x3,%eax
   140a9:	75 35                	jne    140e0 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   140ab:	83 ec 08             	sub    $0x8,%esp
   140ae:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   140b4:	83 c0 0c             	add    $0xc,%eax
   140b7:	50                   	push   %eax
   140b8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   140bb:	50                   	push   %eax
   140bc:	e8 78 d8 ff ff       	call   11939 <addChunk_PLTE>
   140c1:	83 c4 10             	add    $0x10,%esp
   140c4:	89 c2                	mov    %eax,%edx
   140c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   140c9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   140cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   140d2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   140d8:	85 c0                	test   %eax,%eax
   140da:	0f 85 52 05 00 00    	jne    14632 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   140e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   140e3:	8b 40 6c             	mov    0x6c(%eax),%eax
   140e6:	85 c0                	test   %eax,%eax
   140e8:	74 4b                	je     14135 <lodepng_encode+0x7fa>
   140ea:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   140f0:	83 f8 02             	cmp    $0x2,%eax
   140f3:	74 0b                	je     14100 <lodepng_encode+0x7c5>
   140f5:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   140fb:	83 f8 06             	cmp    $0x6,%eax
   140fe:	75 35                	jne    14135 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   14100:	83 ec 08             	sub    $0x8,%esp
   14103:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14109:	83 c0 0c             	add    $0xc,%eax
   1410c:	50                   	push   %eax
   1410d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14110:	50                   	push   %eax
   14111:	e8 23 d8 ff ff       	call   11939 <addChunk_PLTE>
   14116:	83 c4 10             	add    $0x10,%esp
   14119:	89 c2                	mov    %eax,%edx
   1411b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1411e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14124:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14127:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1412d:	85 c0                	test   %eax,%eax
   1412f:	0f 85 00 05 00 00    	jne    14635 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   14135:	83 ec 08             	sub    $0x8,%esp
   14138:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1413e:	83 c0 0c             	add    $0xc,%eax
   14141:	50                   	push   %eax
   14142:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14145:	50                   	push   %eax
   14146:	e8 c4 d8 ff ff       	call   11a0f <addChunk_tRNS>
   1414b:	83 c4 10             	add    $0x10,%esp
   1414e:	89 c2                	mov    %eax,%edx
   14150:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14153:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   14159:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1415c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14162:	85 c0                	test   %eax,%eax
   14164:	0f 85 ce 04 00 00    	jne    14638 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   1416a:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   14170:	85 c0                	test   %eax,%eax
   14172:	74 32                	je     141a6 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   14174:	83 ec 08             	sub    $0x8,%esp
   14177:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1417d:	50                   	push   %eax
   1417e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14181:	50                   	push   %eax
   14182:	e8 e4 de ff ff       	call   1206b <addChunk_bKGD>
   14187:	83 c4 10             	add    $0x10,%esp
   1418a:	89 c2                	mov    %eax,%edx
   1418c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1418f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14195:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14198:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1419e:	85 c0                	test   %eax,%eax
   141a0:	0f 85 95 04 00 00    	jne    1463b <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   141a6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   141ac:	85 c0                	test   %eax,%eax
   141ae:	74 32                	je     141e2 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   141b0:	83 ec 08             	sub    $0x8,%esp
   141b3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   141b9:	50                   	push   %eax
   141ba:	8d 45 b0             	lea    -0x50(%ebp),%eax
   141bd:	50                   	push   %eax
   141be:	e8 ac e0 ff ff       	call   1226f <addChunk_pHYs>
   141c3:	83 c4 10             	add    $0x10,%esp
   141c6:	89 c2                	mov    %eax,%edx
   141c8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   141cb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   141d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   141d4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   141da:	85 c0                	test   %eax,%eax
   141dc:	0f 85 5c 04 00 00    	jne    1463e <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   141e2:	8b 45 9c             	mov    -0x64(%ebp),%eax
   141e5:	85 c0                	test   %eax,%eax
   141e7:	74 33                	je     1421c <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   141e9:	8b 55 a8             	mov    -0x58(%ebp),%edx
   141ec:	8b 45 9c             	mov    -0x64(%ebp),%eax
   141ef:	83 ec 04             	sub    $0x4,%esp
   141f2:	52                   	push   %edx
   141f3:	50                   	push   %eax
   141f4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   141f7:	50                   	push   %eax
   141f8:	e8 2f f6 ff ff       	call   1382c <addUnknownChunks>
   141fd:	83 c4 10             	add    $0x10,%esp
   14200:	89 c2                	mov    %eax,%edx
   14202:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14205:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1420b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1420e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14214:	85 c0                	test   %eax,%eax
   14216:	0f 85 25 04 00 00    	jne    14641 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   1421c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1421f:	8d 48 38             	lea    0x38(%eax),%ecx
   14222:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14225:	8b 45 c0             	mov    -0x40(%ebp),%eax
   14228:	51                   	push   %ecx
   14229:	52                   	push   %edx
   1422a:	50                   	push   %eax
   1422b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1422e:	50                   	push   %eax
   1422f:	e8 bd d9 ff ff       	call   11bf1 <addChunk_IDAT>
   14234:	83 c4 10             	add    $0x10,%esp
   14237:	89 c2                	mov    %eax,%edx
   14239:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1423c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   14242:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14245:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1424b:	85 c0                	test   %eax,%eax
   1424d:	0f 85 f1 03 00 00    	jne    14644 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   14253:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   14259:	85 c0                	test   %eax,%eax
   1425b:	74 35                	je     14292 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   1425d:	83 ec 08             	sub    $0x8,%esp
   14260:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   14266:	83 c0 60             	add    $0x60,%eax
   14269:	50                   	push   %eax
   1426a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1426d:	50                   	push   %eax
   1426e:	e8 5c df ff ff       	call   121cf <addChunk_tIME>
   14273:	83 c4 10             	add    $0x10,%esp
   14276:	89 c2                	mov    %eax,%edx
   14278:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1427b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14281:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14284:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1428a:	85 c0                	test   %eax,%eax
   1428c:	0f 85 b5 03 00 00    	jne    14647 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   14292:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14299:	e9 12 01 00 00       	jmp    143b0 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   1429e:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   142a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   142a7:	c1 e2 02             	shl    $0x2,%edx
   142aa:	01 d0                	add    %edx,%eax
   142ac:	8b 00                	mov    (%eax),%eax
   142ae:	83 ec 0c             	sub    $0xc,%esp
   142b1:	50                   	push   %eax
   142b2:	e8 f5 01 ff ff       	call   44ac <lodepng_strlen>
   142b7:	83 c4 10             	add    $0x10,%esp
   142ba:	83 f8 4f             	cmp    $0x4f,%eax
   142bd:	7e 12                	jle    142d1 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   142bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   142c2:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   142c9:	00 00 00 
        goto cleanup;
   142cc:	e9 83 03 00 00       	jmp    14654 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   142d1:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   142d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   142da:	c1 e2 02             	shl    $0x2,%edx
   142dd:	01 d0                	add    %edx,%eax
   142df:	8b 00                	mov    (%eax),%eax
   142e1:	83 ec 0c             	sub    $0xc,%esp
   142e4:	50                   	push   %eax
   142e5:	e8 c2 01 ff ff       	call   44ac <lodepng_strlen>
   142ea:	83 c4 10             	add    $0x10,%esp
   142ed:	85 c0                	test   %eax,%eax
   142ef:	7f 12                	jg     14303 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   142f1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   142f4:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   142fb:	00 00 00 
        goto cleanup;
   142fe:	e9 51 03 00 00       	jmp    14654 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   14303:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14306:	8b 40 74             	mov    0x74(%eax),%eax
   14309:	85 c0                	test   %eax,%eax
   1430b:	74 52                	je     1435f <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   1430d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14310:	8d 48 38             	lea    0x38(%eax),%ecx
   14313:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   14319:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1431c:	c1 e2 02             	shl    $0x2,%edx
   1431f:	01 d0                	add    %edx,%eax
   14321:	8b 10                	mov    (%eax),%edx
   14323:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   14329:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   1432c:	c1 e3 02             	shl    $0x2,%ebx
   1432f:	01 d8                	add    %ebx,%eax
   14331:	8b 00                	mov    (%eax),%eax
   14333:	51                   	push   %ecx
   14334:	52                   	push   %edx
   14335:	50                   	push   %eax
   14336:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14339:	50                   	push   %eax
   1433a:	e8 fa d9 ff ff       	call   11d39 <addChunk_zTXt>
   1433f:	83 c4 10             	add    $0x10,%esp
   14342:	89 c2                	mov    %eax,%edx
   14344:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14347:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1434d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14350:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14356:	85 c0                	test   %eax,%eax
   14358:	74 52                	je     143ac <lodepng_encode+0xa71>
   1435a:	e9 f5 02 00 00       	jmp    14654 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   1435f:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   14365:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14368:	c1 e2 02             	shl    $0x2,%edx
   1436b:	01 d0                	add    %edx,%eax
   1436d:	8b 10                	mov    (%eax),%edx
   1436f:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   14375:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   14378:	c1 e1 02             	shl    $0x2,%ecx
   1437b:	01 c8                	add    %ecx,%eax
   1437d:	8b 00                	mov    (%eax),%eax
   1437f:	83 ec 04             	sub    $0x4,%esp
   14382:	52                   	push   %edx
   14383:	50                   	push   %eax
   14384:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14387:	50                   	push   %eax
   14388:	e8 ec d8 ff ff       	call   11c79 <addChunk_tEXt>
   1438d:	83 c4 10             	add    $0x10,%esp
   14390:	89 c2                	mov    %eax,%edx
   14392:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14395:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1439b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1439e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   143a4:	85 c0                	test   %eax,%eax
   143a6:	0f 85 9e 02 00 00    	jne    1464a <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   143ac:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   143b0:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   143b6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   143b9:	0f 85 df fe ff ff    	jne    1429e <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   143bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   143c2:	8b 40 70             	mov    0x70(%eax),%eax
   143c5:	85 c0                	test   %eax,%eax
   143c7:	0f 84 e3 00 00 00    	je     144b0 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   143cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   143d4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   143db:	e9 85 00 00 00       	jmp    14465 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   143e0:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   143e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   143e9:	c1 e2 02             	shl    $0x2,%edx
   143ec:	01 d0                	add    %edx,%eax
   143ee:	8b 00                	mov    (%eax),%eax
   143f0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   143f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   143f6:	0f b6 00             	movzbl (%eax),%eax
   143f9:	3c 4c                	cmp    $0x4c,%al
   143fb:	75 64                	jne    14461 <lodepng_encode+0xb26>
   143fd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14400:	83 c0 01             	add    $0x1,%eax
   14403:	0f b6 00             	movzbl (%eax),%eax
   14406:	3c 6f                	cmp    $0x6f,%al
   14408:	75 57                	jne    14461 <lodepng_encode+0xb26>
   1440a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1440d:	83 c0 02             	add    $0x2,%eax
   14410:	0f b6 00             	movzbl (%eax),%eax
   14413:	3c 64                	cmp    $0x64,%al
   14415:	75 4a                	jne    14461 <lodepng_encode+0xb26>
   14417:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1441a:	83 c0 03             	add    $0x3,%eax
   1441d:	0f b6 00             	movzbl (%eax),%eax
   14420:	3c 65                	cmp    $0x65,%al
   14422:	75 3d                	jne    14461 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   14424:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14427:	83 c0 04             	add    $0x4,%eax
   1442a:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   1442d:	3c 50                	cmp    $0x50,%al
   1442f:	75 30                	jne    14461 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   14431:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14434:	83 c0 05             	add    $0x5,%eax
   14437:	0f b6 00             	movzbl (%eax),%eax
   1443a:	3c 4e                	cmp    $0x4e,%al
   1443c:	75 23                	jne    14461 <lodepng_encode+0xb26>
   1443e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   14441:	83 c0 06             	add    $0x6,%eax
   14444:	0f b6 00             	movzbl (%eax),%eax
   14447:	3c 47                	cmp    $0x47,%al
   14449:	75 16                	jne    14461 <lodepng_encode+0xb26>
   1444b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1444e:	83 c0 07             	add    $0x7,%eax
   14451:	0f b6 00             	movzbl (%eax),%eax
   14454:	84 c0                	test   %al,%al
   14456:	75 09                	jne    14461 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   14458:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   1445f:	eb 13                	jmp    14474 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   14461:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14465:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1446b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1446e:	0f 85 6c ff ff ff    	jne    143e0 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   14474:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14478:	75 36                	jne    144b0 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   1447a:	a1 00 f7 01 00       	mov    0x1f700,%eax
   1447f:	83 ec 04             	sub    $0x4,%esp
   14482:	50                   	push   %eax
   14483:	68 84 b1 01 00       	push   $0x1b184
   14488:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1448b:	50                   	push   %eax
   1448c:	e8 e8 d7 ff ff       	call   11c79 <addChunk_tEXt>
   14491:	83 c4 10             	add    $0x10,%esp
   14494:	89 c2                	mov    %eax,%edx
   14496:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14499:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1449f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   144a2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   144a8:	85 c0                	test   %eax,%eax
   144aa:	0f 85 9d 01 00 00    	jne    1464d <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   144b0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   144b7:	e9 e6 00 00 00       	jmp    145a2 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   144bc:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   144c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   144c5:	c1 e2 02             	shl    $0x2,%edx
   144c8:	01 d0                	add    %edx,%eax
   144ca:	8b 00                	mov    (%eax),%eax
   144cc:	83 ec 0c             	sub    $0xc,%esp
   144cf:	50                   	push   %eax
   144d0:	e8 d7 ff fe ff       	call   44ac <lodepng_strlen>
   144d5:	83 c4 10             	add    $0x10,%esp
   144d8:	83 f8 4f             	cmp    $0x4f,%eax
   144db:	7e 12                	jle    144ef <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   144dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   144e0:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   144e7:	00 00 00 
        goto cleanup;
   144ea:	e9 65 01 00 00       	jmp    14654 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   144ef:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   144f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   144f8:	c1 e2 02             	shl    $0x2,%edx
   144fb:	01 d0                	add    %edx,%eax
   144fd:	8b 00                	mov    (%eax),%eax
   144ff:	83 ec 0c             	sub    $0xc,%esp
   14502:	50                   	push   %eax
   14503:	e8 a4 ff fe ff       	call   44ac <lodepng_strlen>
   14508:	83 c4 10             	add    $0x10,%esp
   1450b:	85 c0                	test   %eax,%eax
   1450d:	7f 12                	jg     14521 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   1450f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14512:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   14519:	00 00 00 
        goto cleanup;
   1451c:	e9 33 01 00 00       	jmp    14654 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   14521:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14524:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14527:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   1452d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14530:	c1 e2 02             	shl    $0x2,%edx
   14533:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14535:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14537:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   1453d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14540:	c1 e2 02             	shl    $0x2,%edx
   14543:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14545:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14547:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   1454d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14550:	c1 e2 02             	shl    $0x2,%edx
   14553:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14555:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   14557:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1455d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14560:	c1 e2 02             	shl    $0x2,%edx
   14563:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14565:	8b 10                	mov    (%eax),%edx
   14567:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1456a:	8b 40 74             	mov    0x74(%eax),%eax
   1456d:	83 ec 04             	sub    $0x4,%esp
   14570:	57                   	push   %edi
   14571:	56                   	push   %esi
   14572:	53                   	push   %ebx
   14573:	51                   	push   %ecx
   14574:	52                   	push   %edx
   14575:	50                   	push   %eax
   14576:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14579:	50                   	push   %eax
   1457a:	e8 dc d8 ff ff       	call   11e5b <addChunk_iTXt>
   1457f:	83 c4 20             	add    $0x20,%esp
   14582:	89 c2                	mov    %eax,%edx
   14584:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14587:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1458d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14590:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14596:	85 c0                	test   %eax,%eax
   14598:	0f 85 b2 00 00 00    	jne    14650 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   1459e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   145a2:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   145a8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   145ab:	0f 85 0b ff ff ff    	jne    144bc <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   145b1:	8b 45 a0             	mov    -0x60(%ebp),%eax
   145b4:	85 c0                	test   %eax,%eax
   145b6:	74 2f                	je     145e7 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   145b8:	8b 55 ac             	mov    -0x54(%ebp),%edx
   145bb:	8b 45 a0             	mov    -0x60(%ebp),%eax
   145be:	83 ec 04             	sub    $0x4,%esp
   145c1:	52                   	push   %edx
   145c2:	50                   	push   %eax
   145c3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   145c6:	50                   	push   %eax
   145c7:	e8 60 f2 ff ff       	call   1382c <addUnknownChunks>
   145cc:	83 c4 10             	add    $0x10,%esp
   145cf:	89 c2                	mov    %eax,%edx
   145d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145d4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   145da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145dd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   145e3:	85 c0                	test   %eax,%eax
   145e5:	75 6c                	jne    14653 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   145e7:	83 ec 0c             	sub    $0xc,%esp
   145ea:	8d 45 b0             	lea    -0x50(%ebp),%eax
   145ed:	50                   	push   %eax
   145ee:	e8 6d d6 ff ff       	call   11c60 <addChunk_IEND>
   145f3:	83 c4 10             	add    $0x10,%esp
   145f6:	89 c2                	mov    %eax,%edx
   145f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   145fb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   14601:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14604:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1460a:	85 c0                	test   %eax,%eax
   1460c:	eb 46                	jmp    14654 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1460e:	90                   	nop
   1460f:	eb 43                	jmp    14654 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   14611:	90                   	nop
   14612:	eb 40                	jmp    14654 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   14614:	90                   	nop
   14615:	eb 3d                	jmp    14654 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   14617:	90                   	nop
   14618:	eb 3a                	jmp    14654 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   1461a:	90                   	nop
   1461b:	eb 37                	jmp    14654 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   1461d:	90                   	nop
   1461e:	eb 34                	jmp    14654 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   14620:	90                   	nop
   14621:	eb 31                	jmp    14654 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   14623:	90                   	nop
   14624:	eb 2e                	jmp    14654 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   14626:	90                   	nop
   14627:	eb 2b                	jmp    14654 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   14629:	90                   	nop
   1462a:	eb 28                	jmp    14654 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   1462c:	90                   	nop
   1462d:	eb 25                	jmp    14654 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   1462f:	90                   	nop
   14630:	eb 22                	jmp    14654 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   14632:	90                   	nop
   14633:	eb 1f                	jmp    14654 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   14635:	90                   	nop
   14636:	eb 1c                	jmp    14654 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   14638:	90                   	nop
   14639:	eb 19                	jmp    14654 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   1463b:	90                   	nop
   1463c:	eb 16                	jmp    14654 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   1463e:	90                   	nop
   1463f:	eb 13                	jmp    14654 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   14641:	90                   	nop
   14642:	eb 10                	jmp    14654 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   14644:	90                   	nop
   14645:	eb 0d                	jmp    14654 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   14647:	90                   	nop
   14648:	eb 0a                	jmp    14654 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   1464a:	90                   	nop
   1464b:	eb 07                	jmp    14654 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   1464d:	90                   	nop
   1464e:	eb 04                	jmp    14654 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   14650:	90                   	nop
   14651:	eb 01                	jmp    14654 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   14653:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   14654:	83 ec 0c             	sub    $0xc,%esp
   14657:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1465d:	50                   	push   %eax
   1465e:	e8 34 65 ff ff       	call   ab97 <lodepng_info_cleanup>
   14663:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   14666:	8b 45 c0             	mov    -0x40(%ebp),%eax
   14669:	83 ec 0c             	sub    $0xc,%esp
   1466c:	50                   	push   %eax
   1466d:	e8 bf fd fe ff       	call   4431 <lodepng_free>
   14672:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   14675:	8b 55 b0             	mov    -0x50(%ebp),%edx
   14678:	8b 45 08             	mov    0x8(%ebp),%eax
   1467b:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   1467d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   14680:	8b 45 0c             	mov    0xc(%ebp),%eax
   14683:	89 10                	mov    %edx,(%eax)

  return state->error;
   14685:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14688:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   1468e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14691:	5b                   	pop    %ebx
   14692:	5e                   	pop    %esi
   14693:	5f                   	pop    %edi
   14694:	5d                   	pop    %ebp
   14695:	c3                   	ret    

00014696 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   14696:	55                   	push   %ebp
   14697:	89 e5                	mov    %esp,%ebp
   14699:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   1469f:	83 ec 0c             	sub    $0xc,%esp
   146a2:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   146a8:	50                   	push   %eax
   146a9:	e8 38 d0 ff ff       	call   116e6 <lodepng_state_init>
   146ae:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   146b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   146b4:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   146ba:	8b 45 20             	mov    0x20(%ebp),%eax
   146bd:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   146c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   146c6:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   146cc:	8b 45 20             	mov    0x20(%ebp),%eax
   146cf:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   146d5:	83 ec 08             	sub    $0x8,%esp
   146d8:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   146de:	50                   	push   %eax
   146df:	ff 75 18             	pushl  0x18(%ebp)
   146e2:	ff 75 14             	pushl  0x14(%ebp)
   146e5:	ff 75 10             	pushl  0x10(%ebp)
   146e8:	ff 75 0c             	pushl  0xc(%ebp)
   146eb:	ff 75 08             	pushl  0x8(%ebp)
   146ee:	e8 48 f2 ff ff       	call   1393b <lodepng_encode>
   146f3:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   146f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   146fc:	83 ec 0c             	sub    $0xc,%esp
   146ff:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   14705:	50                   	push   %eax
   14706:	e8 35 d0 ff ff       	call   11740 <lodepng_state_cleanup>
   1470b:	83 c4 10             	add    $0x10,%esp
  return error;
   1470e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14711:	c9                   	leave  
   14712:	c3                   	ret    

00014713 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   14713:	55                   	push   %ebp
   14714:	89 e5                	mov    %esp,%ebp
   14716:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   14719:	83 ec 04             	sub    $0x4,%esp
   1471c:	6a 08                	push   $0x8
   1471e:	6a 06                	push   $0x6
   14720:	ff 75 18             	pushl  0x18(%ebp)
   14723:	ff 75 14             	pushl  0x14(%ebp)
   14726:	ff 75 10             	pushl  0x10(%ebp)
   14729:	ff 75 0c             	pushl  0xc(%ebp)
   1472c:	ff 75 08             	pushl  0x8(%ebp)
   1472f:	e8 62 ff ff ff       	call   14696 <lodepng_encode_memory>
   14734:	83 c4 20             	add    $0x20,%esp
}
   14737:	c9                   	leave  
   14738:	c3                   	ret    

00014739 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   14739:	55                   	push   %ebp
   1473a:	89 e5                	mov    %esp,%ebp
   1473c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   1473f:	83 ec 04             	sub    $0x4,%esp
   14742:	6a 08                	push   $0x8
   14744:	6a 02                	push   $0x2
   14746:	ff 75 18             	pushl  0x18(%ebp)
   14749:	ff 75 14             	pushl  0x14(%ebp)
   1474c:	ff 75 10             	pushl  0x10(%ebp)
   1474f:	ff 75 0c             	pushl  0xc(%ebp)
   14752:	ff 75 08             	pushl  0x8(%ebp)
   14755:	e8 3c ff ff ff       	call   14696 <lodepng_encode_memory>
   1475a:	83 c4 20             	add    $0x20,%esp
}
   1475d:	c9                   	leave  
   1475e:	c3                   	ret    

0001475f <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   1475f:	55                   	push   %ebp
   14760:	89 e5                	mov    %esp,%ebp
   14762:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   14765:	83 ec 04             	sub    $0x4,%esp
   14768:	ff 75 1c             	pushl  0x1c(%ebp)
   1476b:	ff 75 18             	pushl  0x18(%ebp)
   1476e:	ff 75 14             	pushl  0x14(%ebp)
   14771:	ff 75 10             	pushl  0x10(%ebp)
   14774:	ff 75 0c             	pushl  0xc(%ebp)
   14777:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1477a:	50                   	push   %eax
   1477b:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1477e:	50                   	push   %eax
   1477f:	e8 12 ff ff ff       	call   14696 <lodepng_encode_memory>
   14784:	83 c4 20             	add    $0x20,%esp
   14787:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   1478a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1478e:	75 19                	jne    147a9 <lodepng_encode_file+0x4a>
   14790:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14793:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14796:	83 ec 04             	sub    $0x4,%esp
   14799:	ff 75 08             	pushl  0x8(%ebp)
   1479c:	52                   	push   %edx
   1479d:	50                   	push   %eax
   1479e:	e8 36 01 ff ff       	call   48d9 <lodepng_save_file>
   147a3:	83 c4 10             	add    $0x10,%esp
   147a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   147a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147ac:	83 ec 0c             	sub    $0xc,%esp
   147af:	50                   	push   %eax
   147b0:	e8 7c fc fe ff       	call   4431 <lodepng_free>
   147b5:	83 c4 10             	add    $0x10,%esp
  return error;
   147b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   147bb:	c9                   	leave  
   147bc:	c3                   	ret    

000147bd <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   147bd:	55                   	push   %ebp
   147be:	89 e5                	mov    %esp,%ebp
   147c0:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   147c3:	83 ec 08             	sub    $0x8,%esp
   147c6:	6a 08                	push   $0x8
   147c8:	6a 06                	push   $0x6
   147ca:	ff 75 14             	pushl  0x14(%ebp)
   147cd:	ff 75 10             	pushl  0x10(%ebp)
   147d0:	ff 75 0c             	pushl  0xc(%ebp)
   147d3:	ff 75 08             	pushl  0x8(%ebp)
   147d6:	e8 84 ff ff ff       	call   1475f <lodepng_encode_file>
   147db:	83 c4 20             	add    $0x20,%esp
}
   147de:	c9                   	leave  
   147df:	c3                   	ret    

000147e0 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   147e0:	55                   	push   %ebp
   147e1:	89 e5                	mov    %esp,%ebp
   147e3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   147e6:	83 ec 08             	sub    $0x8,%esp
   147e9:	6a 08                	push   $0x8
   147eb:	6a 02                	push   $0x2
   147ed:	ff 75 14             	pushl  0x14(%ebp)
   147f0:	ff 75 10             	pushl  0x10(%ebp)
   147f3:	ff 75 0c             	pushl  0xc(%ebp)
   147f6:	ff 75 08             	pushl  0x8(%ebp)
   147f9:	e8 61 ff ff ff       	call   1475f <lodepng_encode_file>
   147fe:	83 c4 20             	add    $0x20,%esp
}
   14801:	c9                   	leave  
   14802:	c3                   	ret    

00014803 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   14803:	55                   	push   %ebp
   14804:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   14806:	8b 45 08             	mov    0x8(%ebp),%eax
   14809:	50                   	push   %eax
   1480a:	e8 71 49 ff ff       	call   9180 <lodepng_compress_settings_init>
   1480f:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   14812:	8b 45 08             	mov    0x8(%ebp),%eax
   14815:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   1481c:	8b 45 08             	mov    0x8(%ebp),%eax
   1481f:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   14826:	8b 45 08             	mov    0x8(%ebp),%eax
   14829:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   14830:	8b 45 08             	mov    0x8(%ebp),%eax
   14833:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   1483a:	8b 45 08             	mov    0x8(%ebp),%eax
   1483d:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   14844:	8b 45 08             	mov    0x8(%ebp),%eax
   14847:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   1484e:	8b 45 08             	mov    0x8(%ebp),%eax
   14851:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   14858:	90                   	nop
   14859:	c9                   	leave  
   1485a:	c3                   	ret    

0001485b <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   1485b:	55                   	push   %ebp
   1485c:	89 e5                	mov    %esp,%ebp
  switch(code) {
   1485e:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   14862:	0f 87 c1 03 00 00    	ja     14c29 <lodepng_error_text+0x3ce>
   14868:	8b 45 08             	mov    0x8(%ebp),%eax
   1486b:	c1 e0 02             	shl    $0x2,%eax
   1486e:	05 c0 c4 01 00       	add    $0x1c4c0,%eax
   14873:	8b 00                	mov    (%eax),%eax
   14875:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   14877:	b8 8c b1 01 00       	mov    $0x1b18c,%eax
   1487c:	e9 ad 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   14881:	b8 a9 b1 01 00       	mov    $0x1b1a9,%eax
   14886:	e9 a3 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   1488b:	b8 bc b1 01 00       	mov    $0x1b1bc,%eax
   14890:	e9 99 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   14895:	b8 f4 b1 01 00       	mov    $0x1b1f4,%eax
   1489a:	e9 8f 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   1489f:	b8 2c b2 01 00       	mov    $0x1b22c,%eax
   148a4:	e9 85 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   148a9:	b8 2c b2 01 00       	mov    $0x1b22c,%eax
   148ae:	e9 7b 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   148b3:	b8 2c b2 01 00       	mov    $0x1b22c,%eax
   148b8:	e9 71 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   148bd:	b8 5c b2 01 00       	mov    $0x1b25c,%eax
   148c2:	e9 67 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   148c7:	b8 90 b2 01 00       	mov    $0x1b290,%eax
   148cc:	e9 5d 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   148d1:	b8 c4 b2 01 00       	mov    $0x1b2c4,%eax
   148d6:	e9 53 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   148db:	b8 90 b2 01 00       	mov    $0x1b290,%eax
   148e0:	e9 49 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   148e5:	b8 ec b2 01 00       	mov    $0x1b2ec,%eax
   148ea:	e9 3f 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   148ef:	b8 24 b3 01 00       	mov    $0x1b324,%eax
   148f4:	e9 35 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   148f9:	b8 90 b2 01 00       	mov    $0x1b290,%eax
   148fe:	e9 2b 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   14903:	b8 5c b3 01 00       	mov    $0x1b35c,%eax
   14908:	e9 21 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   1490d:	b8 8c b3 01 00       	mov    $0x1b38c,%eax
   14912:	e9 17 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   14917:	b8 ac b3 01 00       	mov    $0x1b3ac,%eax
   1491c:	e9 0d 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   14921:	b8 d8 b3 01 00       	mov    $0x1b3d8,%eax
   14926:	e9 03 03 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   1492b:	b8 18 b4 01 00       	mov    $0x1b418,%eax
   14930:	e9 f9 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   14935:	b8 40 b4 01 00       	mov    $0x1b440,%eax
   1493a:	e9 ef 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   1493f:	b8 74 b4 01 00       	mov    $0x1b474,%eax
   14944:	e9 e5 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   14949:	b8 98 b4 01 00       	mov    $0x1b498,%eax
   1494e:	e9 db 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   14953:	b8 d0 b4 01 00       	mov    $0x1b4d0,%eax
   14958:	e9 d1 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   1495d:	b8 f0 b4 01 00       	mov    $0x1b4f0,%eax
   14962:	e9 c7 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   14967:	b8 0f b5 01 00       	mov    $0x1b50f,%eax
   1496c:	e9 bd 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   14971:	b8 29 b5 01 00       	mov    $0x1b529,%eax
   14976:	e9 b3 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   1497b:	b8 48 b5 01 00       	mov    $0x1b548,%eax
   14980:	e9 a9 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   14985:	b8 84 b5 01 00       	mov    $0x1b584,%eax
   1498a:	e9 9f 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   1498f:	b8 a8 b5 01 00       	mov    $0x1b5a8,%eax
   14994:	e9 95 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   14999:	b8 d4 b5 01 00       	mov    $0x1b5d4,%eax
   1499e:	e9 8b 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   149a3:	b8 f8 b5 01 00       	mov    $0x1b5f8,%eax
   149a8:	e9 81 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   149ad:	b8 38 b6 01 00       	mov    $0x1b638,%eax
   149b2:	e9 77 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   149b7:	b8 68 b6 01 00       	mov    $0x1b668,%eax
   149bc:	e9 6d 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   149c1:	b8 90 b6 01 00       	mov    $0x1b690,%eax
   149c6:	e9 63 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   149cb:	b8 d4 b6 01 00       	mov    $0x1b6d4,%eax
   149d0:	e9 59 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   149d5:	b8 00 b7 01 00       	mov    $0x1b700,%eax
   149da:	e9 4f 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   149df:	b8 30 b7 01 00       	mov    $0x1b730,%eax
   149e4:	e9 45 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   149e9:	b8 58 b7 01 00       	mov    $0x1b758,%eax
   149ee:	e9 3b 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   149f3:	b8 a0 b7 01 00       	mov    $0x1b7a0,%eax
   149f8:	e9 31 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   149fd:	b8 a0 b7 01 00       	mov    $0x1b7a0,%eax
   14a02:	e9 27 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   14a07:	b8 dc b7 01 00       	mov    $0x1b7dc,%eax
   14a0c:	e9 1d 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   14a11:	b8 10 b8 01 00       	mov    $0x1b810,%eax
   14a16:	e9 13 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   14a1b:	b8 33 b8 01 00       	mov    $0x1b833,%eax
   14a20:	e9 09 02 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   14a25:	b8 50 b8 01 00       	mov    $0x1b850,%eax
   14a2a:	e9 ff 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   14a2f:	b8 8c b8 01 00       	mov    $0x1b88c,%eax
   14a34:	e9 f5 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   14a39:	b8 bc b8 01 00       	mov    $0x1b8bc,%eax
   14a3e:	e9 eb 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   14a43:	b8 08 b9 01 00       	mov    $0x1b908,%eax
   14a48:	e9 e1 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   14a4d:	b8 40 b9 01 00       	mov    $0x1b940,%eax
   14a52:	e9 d7 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   14a57:	b8 80 b9 01 00       	mov    $0x1b980,%eax
   14a5c:	e9 cd 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   14a61:	b8 ac b9 01 00       	mov    $0x1b9ac,%eax
   14a66:	e9 c3 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   14a6b:	b8 f8 b9 01 00       	mov    $0x1b9f8,%eax
   14a70:	e9 b9 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   14a75:	b8 4c ba 01 00       	mov    $0x1ba4c,%eax
   14a7a:	e9 af 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   14a7f:	b8 80 ba 01 00       	mov    $0x1ba80,%eax
   14a84:	e9 a5 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   14a89:	b8 d0 ba 01 00       	mov    $0x1bad0,%eax
   14a8e:	e9 9b 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   14a93:	b8 0c bb 01 00       	mov    $0x1bb0c,%eax
   14a98:	e9 91 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   14a9d:	b8 6c bb 01 00       	mov    $0x1bb6c,%eax
   14aa2:	e9 87 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   14aa7:	b8 cc bb 01 00       	mov    $0x1bbcc,%eax
   14aac:	e9 7d 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   14ab1:	b8 28 bc 01 00       	mov    $0x1bc28,%eax
   14ab6:	e9 73 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   14abb:	b8 6c bc 01 00       	mov    $0x1bc6c,%eax
   14ac0:	e9 69 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   14ac5:	b8 a8 bc 01 00       	mov    $0x1bca8,%eax
   14aca:	e9 5f 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   14acf:	b8 05 bd 01 00       	mov    $0x1bd05,%eax
   14ad4:	e9 55 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   14ad9:	b8 1d bd 01 00       	mov    $0x1bd1d,%eax
   14ade:	e9 4b 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   14ae3:	b8 38 bd 01 00       	mov    $0x1bd38,%eax
   14ae8:	e9 41 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   14aed:	b8 74 bd 01 00       	mov    $0x1bd74,%eax
   14af2:	e9 37 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   14af7:	b8 a4 bd 01 00       	mov    $0x1bda4,%eax
   14afc:	e9 2d 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   14b01:	b8 c4 bd 01 00       	mov    $0x1bdc4,%eax
   14b06:	e9 23 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   14b0b:	b8 e4 bd 01 00       	mov    $0x1bde4,%eax
   14b10:	e9 19 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   14b15:	b8 04 be 01 00       	mov    $0x1be04,%eax
   14b1a:	e9 0f 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   14b1f:	b8 28 be 01 00       	mov    $0x1be28,%eax
   14b24:	e9 05 01 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   14b29:	b8 50 be 01 00       	mov    $0x1be50,%eax
   14b2e:	e9 fb 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   14b33:	b8 ad be 01 00       	mov    $0x1bead,%eax
   14b38:	e9 f1 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   14b3d:	b8 c8 be 01 00       	mov    $0x1bec8,%eax
   14b42:	e9 e7 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   14b47:	b8 04 bf 01 00       	mov    $0x1bf04,%eax
   14b4c:	e9 dd 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   14b51:	b8 38 bf 01 00       	mov    $0x1bf38,%eax
   14b56:	e9 d3 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   14b5b:	b8 8c bf 01 00       	mov    $0x1bf8c,%eax
   14b60:	e9 c9 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   14b65:	b8 d8 bf 01 00       	mov    $0x1bfd8,%eax
   14b6a:	e9 bf 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   14b6f:	b8 14 c0 01 00       	mov    $0x1c014,%eax
   14b74:	e9 b5 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   14b79:	b8 38 c0 01 00       	mov    $0x1c038,%eax
   14b7e:	e9 ab 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   14b83:	b8 58 c0 01 00       	mov    $0x1c058,%eax
   14b88:	e9 a1 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   14b8d:	b8 80 c0 01 00       	mov    $0x1c080,%eax
   14b92:	e9 97 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   14b97:	b8 a0 c0 01 00       	mov    $0x1c0a0,%eax
   14b9c:	e9 8d 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   14ba1:	b8 cc c0 01 00       	mov    $0x1c0cc,%eax
   14ba6:	e9 83 00 00 00       	jmp    14c2e <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   14bab:	b8 fb c0 01 00       	mov    $0x1c0fb,%eax
   14bb0:	eb 7c                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   14bb2:	b8 13 c1 01 00       	mov    $0x1c113,%eax
   14bb7:	eb 75                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   14bb9:	b8 2b c1 01 00       	mov    $0x1c12b,%eax
   14bbe:	eb 6e                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   14bc0:	b8 43 c1 01 00       	mov    $0x1c143,%eax
   14bc5:	eb 67                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   14bc7:	b8 64 c1 01 00       	mov    $0x1c164,%eax
   14bcc:	eb 60                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   14bce:	b8 b4 c1 01 00       	mov    $0x1c1b4,%eax
   14bd3:	eb 59                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   14bd5:	b8 08 c2 01 00       	mov    $0x1c208,%eax
   14bda:	eb 52                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   14bdc:	b8 5c c2 01 00       	mov    $0x1c25c,%eax
   14be1:	eb 4b                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   14be3:	b8 a4 c2 01 00       	mov    $0x1c2a4,%eax
   14be8:	eb 44                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   14bea:	b8 e8 c2 01 00       	mov    $0x1c2e8,%eax
   14bef:	eb 3d                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   14bf1:	b8 04 c3 01 00       	mov    $0x1c304,%eax
   14bf6:	eb 36                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   14bf8:	b8 3c c3 01 00       	mov    $0x1c33c,%eax
   14bfd:	eb 2f                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   14bff:	b8 90 c3 01 00       	mov    $0x1c390,%eax
   14c04:	eb 28                	jmp    14c2e <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   14c06:	b8 c0 c3 01 00       	mov    $0x1c3c0,%eax
   14c0b:	eb 21                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   14c0d:	b8 10 c4 01 00       	mov    $0x1c410,%eax
   14c12:	eb 1a                	jmp    14c2e <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   14c14:	b8 3c c4 01 00       	mov    $0x1c43c,%eax
   14c19:	eb 13                	jmp    14c2e <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   14c1b:	b8 68 c4 01 00       	mov    $0x1c468,%eax
   14c20:	eb 0c                	jmp    14c2e <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   14c22:	b8 8c c4 01 00       	mov    $0x1c48c,%eax
   14c27:	eb 05                	jmp    14c2e <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   14c29:	b8 ab c4 01 00       	mov    $0x1c4ab,%eax
}
   14c2e:	5d                   	pop    %ebp
   14c2f:	c3                   	ret    

00014c30 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   14c30:	55                   	push   %ebp
   14c31:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   14c33:	8b 45 08             	mov    0x8(%ebp),%eax
   14c36:	8b 40 28             	mov    0x28(%eax),%eax
   14c39:	83 f8 01             	cmp    $0x1,%eax
   14c3c:	75 08                	jne    14c46 <GetImage+0x16>
   14c3e:	8b 45 08             	mov    0x8(%ebp),%eax
   14c41:	8b 40 54             	mov    0x54(%eax),%eax
   14c44:	eb 09                	jmp    14c4f <GetImage+0x1f>
   14c46:	8b 45 08             	mov    0x8(%ebp),%eax
   14c49:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   14c4f:	5d                   	pop    %ebp
   14c50:	c3                   	ret    

00014c51 <GetWidth>:

int GetWidth(Context* ctx){
   14c51:	55                   	push   %ebp
   14c52:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   14c54:	8b 45 08             	mov    0x8(%ebp),%eax
   14c57:	8b 40 10             	mov    0x10(%eax),%eax
}
   14c5a:	5d                   	pop    %ebp
   14c5b:	c3                   	ret    

00014c5c <GetHeight>:

int GetHeight(Context* ctx){
   14c5c:	55                   	push   %ebp
   14c5d:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   14c5f:	8b 45 08             	mov    0x8(%ebp),%eax
   14c62:	8b 40 14             	mov    0x14(%eax),%eax
}
   14c65:	5d                   	pop    %ebp
   14c66:	c3                   	ret    

00014c67 <GetImageSize>:

uint GetImageSize(Context* ctx){
   14c67:	55                   	push   %ebp
   14c68:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   14c6a:	8b 45 08             	mov    0x8(%ebp),%eax
   14c6d:	8b 50 10             	mov    0x10(%eax),%edx
   14c70:	8b 45 08             	mov    0x8(%ebp),%eax
   14c73:	8b 40 14             	mov    0x14(%eax),%eax
   14c76:	0f af d0             	imul   %eax,%edx
   14c79:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7c:	8b 40 28             	mov    0x28(%eax),%eax
   14c7f:	0f af c2             	imul   %edx,%eax
}
   14c82:	5d                   	pop    %ebp
   14c83:	c3                   	ret    

00014c84 <_Clip>:

uchar _Clip(const int x){
   14c84:	55                   	push   %ebp
   14c85:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   14c87:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14c8b:	78 15                	js     14ca2 <_Clip+0x1e>
   14c8d:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   14c94:	7f 05                	jg     14c9b <_Clip+0x17>
   14c96:	8b 45 08             	mov    0x8(%ebp),%eax
   14c99:	eb 0c                	jmp    14ca7 <_Clip+0x23>
   14c9b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14ca0:	eb 05                	jmp    14ca7 <_Clip+0x23>
   14ca2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14ca7:	5d                   	pop    %ebp
   14ca8:	c3                   	ret    

00014ca9 <_Skip>:

void _Skip(Context* ctx, int c){
   14ca9:	55                   	push   %ebp
   14caa:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   14cac:	8b 45 08             	mov    0x8(%ebp),%eax
   14caf:	8b 50 04             	mov    0x4(%eax),%edx
   14cb2:	8b 45 0c             	mov    0xc(%ebp),%eax
   14cb5:	01 c2                	add    %eax,%edx
   14cb7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cba:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   14cbd:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc0:	8b 40 08             	mov    0x8(%eax),%eax
   14cc3:	2b 45 0c             	sub    0xc(%ebp),%eax
   14cc6:	89 c2                	mov    %eax,%edx
   14cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   14ccb:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   14cce:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd1:	8b 40 0c             	mov    0xc(%eax),%eax
   14cd4:	2b 45 0c             	sub    0xc(%ebp),%eax
   14cd7:	89 c2                	mov    %eax,%edx
   14cd9:	8b 45 08             	mov    0x8(%ebp),%eax
   14cdc:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   14cdf:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce2:	8b 40 08             	mov    0x8(%eax),%eax
   14ce5:	85 c0                	test   %eax,%eax
   14ce7:	79 09                	jns    14cf2 <_Skip+0x49>
   14ce9:	8b 45 08             	mov    0x8(%ebp),%eax
   14cec:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   14cf2:	90                   	nop
   14cf3:	5d                   	pop    %ebp
   14cf4:	c3                   	ret    

00014cf5 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   14cf5:	55                   	push   %ebp
   14cf6:	89 e5                	mov    %esp,%ebp
   14cf8:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   14cfb:	8b 45 08             	mov    0x8(%ebp),%eax
   14cfe:	8b 40 08             	mov    0x8(%eax),%eax
   14d01:	83 f8 01             	cmp    $0x1,%eax
   14d04:	7f 0b                	jg     14d11 <_DecodeLength+0x1c>
   14d06:	8b 45 08             	mov    0x8(%ebp),%eax
   14d09:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14d0f:	eb 45                	jmp    14d56 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   14d11:	8b 45 08             	mov    0x8(%ebp),%eax
   14d14:	8b 40 04             	mov    0x4(%eax),%eax
   14d17:	83 ec 0c             	sub    $0xc,%esp
   14d1a:	50                   	push   %eax
   14d1b:	e8 38 00 00 00       	call   14d58 <_Decode2Bytes>
   14d20:	83 c4 10             	add    $0x10,%esp
   14d23:	89 c2                	mov    %eax,%edx
   14d25:	8b 45 08             	mov    0x8(%ebp),%eax
   14d28:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   14d2b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d2e:	8b 50 0c             	mov    0xc(%eax),%edx
   14d31:	8b 45 08             	mov    0x8(%ebp),%eax
   14d34:	8b 40 08             	mov    0x8(%eax),%eax
   14d37:	39 c2                	cmp    %eax,%edx
   14d39:	7e 0b                	jle    14d46 <_DecodeLength+0x51>
   14d3b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d3e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14d44:	eb 10                	jmp    14d56 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   14d46:	83 ec 08             	sub    $0x8,%esp
   14d49:	6a 02                	push   $0x2
   14d4b:	ff 75 08             	pushl  0x8(%ebp)
   14d4e:	e8 56 ff ff ff       	call   14ca9 <_Skip>
   14d53:	83 c4 10             	add    $0x10,%esp
}
   14d56:	c9                   	leave  
   14d57:	c3                   	ret    

00014d58 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   14d58:	55                   	push   %ebp
   14d59:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   14d5b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d5e:	0f b6 00             	movzbl (%eax),%eax
   14d61:	0f b6 c0             	movzbl %al,%eax
   14d64:	c1 e0 08             	shl    $0x8,%eax
   14d67:	89 c2                	mov    %eax,%edx
   14d69:	8b 45 08             	mov    0x8(%ebp),%eax
   14d6c:	83 c0 01             	add    $0x1,%eax
   14d6f:	0f b6 00             	movzbl (%eax),%eax
   14d72:	0f b6 c0             	movzbl %al,%eax
   14d75:	09 d0                	or     %edx,%eax
}
   14d77:	5d                   	pop    %ebp
   14d78:	c3                   	ret    

00014d79 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   14d79:	55                   	push   %ebp
   14d7a:	89 e5                	mov    %esp,%ebp
   14d7c:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   14d7f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d82:	8b 55 10             	mov    0x10(%ebp),%edx
   14d85:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   14d88:	8b 45 14             	mov    0x14(%ebp),%eax
   14d8b:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   14d90:	89 c2                	mov    %eax,%edx
   14d92:	8b 45 08             	mov    0x8(%ebp),%eax
   14d95:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   14d98:	8b 45 08             	mov    0x8(%ebp),%eax
   14d9b:	8b 40 08             	mov    0x8(%eax),%eax
   14d9e:	83 f8 01             	cmp    $0x1,%eax
   14da1:	7e 1d                	jle    14dc0 <_DecodeJPEG+0x47>
   14da3:	8b 45 08             	mov    0x8(%ebp),%eax
   14da6:	8b 40 04             	mov    0x4(%eax),%eax
   14da9:	0f b6 00             	movzbl (%eax),%eax
   14dac:	3c ff                	cmp    $0xff,%al
   14dae:	75 10                	jne    14dc0 <_DecodeJPEG+0x47>
   14db0:	8b 45 08             	mov    0x8(%ebp),%eax
   14db3:	8b 40 04             	mov    0x4(%eax),%eax
   14db6:	83 c0 01             	add    $0x1,%eax
   14db9:	0f b6 00             	movzbl (%eax),%eax
   14dbc:	3c d8                	cmp    $0xd8,%al
   14dbe:	74 0a                	je     14dca <_DecodeJPEG+0x51>
   14dc0:	b8 01 00 00 00       	mov    $0x1,%eax
   14dc5:	e9 56 01 00 00       	jmp    14f20 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   14dca:	6a 02                	push   $0x2
   14dcc:	ff 75 08             	pushl  0x8(%ebp)
   14dcf:	e8 d5 fe ff ff       	call   14ca9 <_Skip>
   14dd4:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   14dd7:	e9 0a 01 00 00       	jmp    14ee6 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   14ddc:	8b 45 08             	mov    0x8(%ebp),%eax
   14ddf:	8b 40 08             	mov    0x8(%eax),%eax
   14de2:	85 c0                	test   %eax,%eax
   14de4:	78 0d                	js     14df3 <_DecodeJPEG+0x7a>
   14de6:	8b 45 08             	mov    0x8(%ebp),%eax
   14de9:	8b 40 04             	mov    0x4(%eax),%eax
   14dec:	0f b6 00             	movzbl (%eax),%eax
   14def:	3c ff                	cmp    $0xff,%al
   14df1:	74 0a                	je     14dfd <_DecodeJPEG+0x84>
   14df3:	b8 05 00 00 00       	mov    $0x5,%eax
   14df8:	e9 23 01 00 00       	jmp    14f20 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   14dfd:	6a 02                	push   $0x2
   14dff:	ff 75 08             	pushl  0x8(%ebp)
   14e02:	e8 a2 fe ff ff       	call   14ca9 <_Skip>
   14e07:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   14e0a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e0d:	8b 40 04             	mov    0x4(%eax),%eax
   14e10:	83 e8 01             	sub    $0x1,%eax
   14e13:	0f b6 00             	movzbl (%eax),%eax
   14e16:	0f b6 c0             	movzbl %al,%eax
   14e19:	3d da 00 00 00       	cmp    $0xda,%eax
   14e1e:	74 71                	je     14e91 <_DecodeJPEG+0x118>
   14e20:	3d da 00 00 00       	cmp    $0xda,%eax
   14e25:	7f 10                	jg     14e37 <_DecodeJPEG+0xbe>
   14e27:	3d c0 00 00 00       	cmp    $0xc0,%eax
   14e2c:	74 20                	je     14e4e <_DecodeJPEG+0xd5>
   14e2e:	3d c4 00 00 00       	cmp    $0xc4,%eax
   14e33:	74 2c                	je     14e61 <_DecodeJPEG+0xe8>
   14e35:	eb 7d                	jmp    14eb4 <_DecodeJPEG+0x13b>
   14e37:	3d dd 00 00 00       	cmp    $0xdd,%eax
   14e3c:	74 43                	je     14e81 <_DecodeJPEG+0x108>
   14e3e:	3d fe 00 00 00       	cmp    $0xfe,%eax
   14e43:	74 5f                	je     14ea4 <_DecodeJPEG+0x12b>
   14e45:	3d db 00 00 00       	cmp    $0xdb,%eax
   14e4a:	74 25                	je     14e71 <_DecodeJPEG+0xf8>
   14e4c:	eb 66                	jmp    14eb4 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   14e4e:	83 ec 0c             	sub    $0xc,%esp
   14e51:	ff 75 08             	pushl  0x8(%ebp)
   14e54:	e8 c9 00 00 00       	call   14f22 <_DecodeSOF>
   14e59:	83 c4 10             	add    $0x10,%esp
   14e5c:	e9 85 00 00 00       	jmp    14ee6 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   14e61:	83 ec 0c             	sub    $0xc,%esp
   14e64:	ff 75 08             	pushl  0x8(%ebp)
   14e67:	e8 28 05 00 00       	call   15394 <_DecodeDHT>
   14e6c:	83 c4 10             	add    $0x10,%esp
   14e6f:	eb 75                	jmp    14ee6 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   14e71:	83 ec 0c             	sub    $0xc,%esp
   14e74:	ff 75 08             	pushl  0x8(%ebp)
   14e77:	e8 05 07 00 00       	call   15581 <_DecodeDQT>
   14e7c:	83 c4 10             	add    $0x10,%esp
   14e7f:	eb 65                	jmp    14ee6 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   14e81:	83 ec 0c             	sub    $0xc,%esp
   14e84:	ff 75 08             	pushl  0x8(%ebp)
   14e87:	e8 ff 07 00 00       	call   1568b <_DecodeDRI>
   14e8c:	83 c4 10             	add    $0x10,%esp
   14e8f:	eb 55                	jmp    14ee6 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   14e91:	83 ec 08             	sub    $0x8,%esp
   14e94:	ff 75 0c             	pushl  0xc(%ebp)
   14e97:	ff 75 08             	pushl  0x8(%ebp)
   14e9a:	e8 56 08 00 00       	call   156f5 <_DecodeSOS>
   14e9f:	83 c4 10             	add    $0x10,%esp
   14ea2:	eb 42                	jmp    14ee6 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   14ea4:	83 ec 0c             	sub    $0xc,%esp
   14ea7:	ff 75 08             	pushl  0x8(%ebp)
   14eaa:	e8 a8 15 00 00       	call   16457 <_SkipMarker>
   14eaf:	83 c4 10             	add    $0x10,%esp
   14eb2:	eb 32                	jmp    14ee6 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   14eb4:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb7:	8b 40 04             	mov    0x4(%eax),%eax
   14eba:	83 e8 01             	sub    $0x1,%eax
   14ebd:	0f b6 00             	movzbl (%eax),%eax
   14ec0:	0f b6 c0             	movzbl %al,%eax
   14ec3:	25 f0 00 00 00       	and    $0xf0,%eax
   14ec8:	3d e0 00 00 00       	cmp    $0xe0,%eax
   14ecd:	75 10                	jne    14edf <_DecodeJPEG+0x166>
   14ecf:	83 ec 0c             	sub    $0xc,%esp
   14ed2:	ff 75 08             	pushl  0x8(%ebp)
   14ed5:	e8 7d 15 00 00       	call   16457 <_SkipMarker>
   14eda:	83 c4 10             	add    $0x10,%esp
   14edd:	eb 07                	jmp    14ee6 <_DecodeJPEG+0x16d>
                else return Unsupported;
   14edf:	b8 02 00 00 00       	mov    $0x2,%eax
   14ee4:	eb 3a                	jmp    14f20 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   14ee6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ee9:	8b 00                	mov    (%eax),%eax
   14eeb:	85 c0                	test   %eax,%eax
   14eed:	0f 84 e9 fe ff ff    	je     14ddc <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   14ef3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ef6:	8b 00                	mov    (%eax),%eax
   14ef8:	83 f8 06             	cmp    $0x6,%eax
   14efb:	74 07                	je     14f04 <_DecodeJPEG+0x18b>
   14efd:	8b 45 08             	mov    0x8(%ebp),%eax
   14f00:	8b 00                	mov    (%eax),%eax
   14f02:	eb 1c                	jmp    14f20 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   14f04:	8b 45 08             	mov    0x8(%ebp),%eax
   14f07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   14f0d:	83 ec 0c             	sub    $0xc,%esp
   14f10:	ff 75 08             	pushl  0x8(%ebp)
   14f13:	e8 6b 15 00 00       	call   16483 <_Convert>
   14f18:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   14f1b:	8b 45 08             	mov    0x8(%ebp),%eax
   14f1e:	8b 00                	mov    (%eax),%eax
 }
   14f20:	c9                   	leave  
   14f21:	c3                   	ret    

00014f22 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   14f22:	55                   	push   %ebp
   14f23:	89 e5                	mov    %esp,%ebp
   14f25:	53                   	push   %ebx
   14f26:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   14f29:	83 ec 0c             	sub    $0xc,%esp
   14f2c:	ff 75 08             	pushl  0x8(%ebp)
   14f2f:	e8 c1 fd ff ff       	call   14cf5 <_DecodeLength>
   14f34:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   14f37:	8b 45 08             	mov    0x8(%ebp),%eax
   14f3a:	8b 00                	mov    (%eax),%eax
   14f3c:	85 c0                	test   %eax,%eax
   14f3e:	0f 85 4a 04 00 00    	jne    1538e <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   14f44:	8b 45 08             	mov    0x8(%ebp),%eax
   14f47:	8b 40 0c             	mov    0xc(%eax),%eax
   14f4a:	83 f8 08             	cmp    $0x8,%eax
   14f4d:	7f 0e                	jg     14f5d <_DecodeSOF+0x3b>
   14f4f:	8b 45 08             	mov    0x8(%ebp),%eax
   14f52:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14f58:	e9 32 04 00 00       	jmp    1538f <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   14f5d:	8b 45 08             	mov    0x8(%ebp),%eax
   14f60:	8b 40 04             	mov    0x4(%eax),%eax
   14f63:	0f b6 00             	movzbl (%eax),%eax
   14f66:	3c 08                	cmp    $0x8,%al
   14f68:	74 0e                	je     14f78 <_DecodeSOF+0x56>
   14f6a:	8b 45 08             	mov    0x8(%ebp),%eax
   14f6d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14f73:	e9 17 04 00 00       	jmp    1538f <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   14f78:	8b 45 08             	mov    0x8(%ebp),%eax
   14f7b:	8b 40 04             	mov    0x4(%eax),%eax
   14f7e:	83 c0 01             	add    $0x1,%eax
   14f81:	83 ec 0c             	sub    $0xc,%esp
   14f84:	50                   	push   %eax
   14f85:	e8 ce fd ff ff       	call   14d58 <_Decode2Bytes>
   14f8a:	83 c4 10             	add    $0x10,%esp
   14f8d:	89 c2                	mov    %eax,%edx
   14f8f:	8b 45 08             	mov    0x8(%ebp),%eax
   14f92:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   14f95:	8b 45 08             	mov    0x8(%ebp),%eax
   14f98:	8b 40 04             	mov    0x4(%eax),%eax
   14f9b:	83 c0 03             	add    $0x3,%eax
   14f9e:	83 ec 0c             	sub    $0xc,%esp
   14fa1:	50                   	push   %eax
   14fa2:	e8 b1 fd ff ff       	call   14d58 <_Decode2Bytes>
   14fa7:	83 c4 10             	add    $0x10,%esp
   14faa:	89 c2                	mov    %eax,%edx
   14fac:	8b 45 08             	mov    0x8(%ebp),%eax
   14faf:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   14fb2:	8b 45 08             	mov    0x8(%ebp),%eax
   14fb5:	8b 40 04             	mov    0x4(%eax),%eax
   14fb8:	83 c0 05             	add    $0x5,%eax
   14fbb:	0f b6 00             	movzbl (%eax),%eax
   14fbe:	0f b6 d0             	movzbl %al,%edx
   14fc1:	8b 45 08             	mov    0x8(%ebp),%eax
   14fc4:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   14fc7:	83 ec 08             	sub    $0x8,%esp
   14fca:	6a 06                	push   $0x6
   14fcc:	ff 75 08             	pushl  0x8(%ebp)
   14fcf:	e8 d5 fc ff ff       	call   14ca9 <_Skip>
   14fd4:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   14fd7:	8b 45 08             	mov    0x8(%ebp),%eax
   14fda:	8b 40 28             	mov    0x28(%eax),%eax
   14fdd:	83 f8 01             	cmp    $0x1,%eax
   14fe0:	74 13                	je     14ff5 <_DecodeSOF+0xd3>
   14fe2:	83 f8 03             	cmp    $0x3,%eax
   14fe5:	74 0e                	je     14ff5 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   14fe7:	8b 45 08             	mov    0x8(%ebp),%eax
   14fea:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14ff0:	e9 9a 03 00 00       	jmp    1538f <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   14ff5:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   14ff6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff9:	8b 48 0c             	mov    0xc(%eax),%ecx
   14ffc:	8b 45 08             	mov    0x8(%ebp),%eax
   14fff:	8b 50 28             	mov    0x28(%eax),%edx
   15002:	89 d0                	mov    %edx,%eax
   15004:	01 c0                	add    %eax,%eax
   15006:	01 d0                	add    %edx,%eax
   15008:	39 c1                	cmp    %eax,%ecx
   1500a:	7d 0e                	jge    1501a <_DecodeSOF+0xf8>
   1500c:	8b 45 08             	mov    0x8(%ebp),%eax
   1500f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15015:	e9 75 03 00 00       	jmp    1538f <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   1501a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15021:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15028:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1502f:	8b 45 08             	mov    0x8(%ebp),%eax
   15032:	83 c0 2c             	add    $0x2c,%eax
   15035:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15038:	e9 50 01 00 00       	jmp    1518d <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   1503d:	8b 45 08             	mov    0x8(%ebp),%eax
   15040:	8b 40 04             	mov    0x4(%eax),%eax
   15043:	0f b6 00             	movzbl (%eax),%eax
   15046:	0f b6 d0             	movzbl %al,%edx
   15049:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1504c:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   1504e:	8b 45 08             	mov    0x8(%ebp),%eax
   15051:	8b 40 04             	mov    0x4(%eax),%eax
   15054:	83 c0 01             	add    $0x1,%eax
   15057:	0f b6 00             	movzbl (%eax),%eax
   1505a:	c0 e8 04             	shr    $0x4,%al
   1505d:	0f b6 d0             	movzbl %al,%edx
   15060:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15063:	89 50 04             	mov    %edx,0x4(%eax)
   15066:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15069:	8b 40 04             	mov    0x4(%eax),%eax
   1506c:	85 c0                	test   %eax,%eax
   1506e:	75 0e                	jne    1507e <_DecodeSOF+0x15c>
   15070:	8b 45 08             	mov    0x8(%ebp),%eax
   15073:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15079:	e9 11 03 00 00       	jmp    1538f <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   1507e:	8b 45 08             	mov    0x8(%ebp),%eax
   15081:	8b 40 04             	mov    0x4(%eax),%eax
   15084:	83 c0 01             	add    $0x1,%eax
   15087:	0f b6 00             	movzbl (%eax),%eax
   1508a:	0f b6 c0             	movzbl %al,%eax
   1508d:	83 e0 0f             	and    $0xf,%eax
   15090:	89 c2                	mov    %eax,%edx
   15092:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15095:	89 50 08             	mov    %edx,0x8(%eax)
   15098:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1509b:	8b 40 08             	mov    0x8(%eax),%eax
   1509e:	85 c0                	test   %eax,%eax
   150a0:	75 0e                	jne    150b0 <_DecodeSOF+0x18e>
   150a2:	8b 45 08             	mov    0x8(%ebp),%eax
   150a5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   150ab:	e9 df 02 00 00       	jmp    1538f <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   150b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150b3:	8b 50 04             	mov    0x4(%eax),%edx
   150b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150b9:	8b 40 04             	mov    0x4(%eax),%eax
   150bc:	83 e8 01             	sub    $0x1,%eax
   150bf:	21 d0                	and    %edx,%eax
   150c1:	85 c0                	test   %eax,%eax
   150c3:	74 0e                	je     150d3 <_DecodeSOF+0x1b1>
   150c5:	8b 45 08             	mov    0x8(%ebp),%eax
   150c8:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   150ce:	e9 bc 02 00 00       	jmp    1538f <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   150d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150d6:	8b 50 08             	mov    0x8(%eax),%edx
   150d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150dc:	8b 40 08             	mov    0x8(%eax),%eax
   150df:	83 e8 01             	sub    $0x1,%eax
   150e2:	21 d0                	and    %edx,%eax
   150e4:	85 c0                	test   %eax,%eax
   150e6:	74 0e                	je     150f6 <_DecodeSOF+0x1d4>
   150e8:	8b 45 08             	mov    0x8(%ebp),%eax
   150eb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   150f1:	e9 99 02 00 00       	jmp    1538f <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   150f6:	8b 45 08             	mov    0x8(%ebp),%eax
   150f9:	8b 40 04             	mov    0x4(%eax),%eax
   150fc:	83 c0 02             	add    $0x2,%eax
   150ff:	0f b6 00             	movzbl (%eax),%eax
   15102:	0f b6 d0             	movzbl %al,%edx
   15105:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15108:	89 50 18             	mov    %edx,0x18(%eax)
   1510b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1510e:	8b 40 18             	mov    0x18(%eax),%eax
   15111:	25 fc 00 00 00       	and    $0xfc,%eax
   15116:	85 c0                	test   %eax,%eax
   15118:	74 0e                	je     15128 <_DecodeSOF+0x206>
   1511a:	8b 45 08             	mov    0x8(%ebp),%eax
   1511d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15123:	e9 67 02 00 00       	jmp    1538f <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   15128:	83 ec 08             	sub    $0x8,%esp
   1512b:	6a 03                	push   $0x3
   1512d:	ff 75 08             	pushl  0x8(%ebp)
   15130:	e8 74 fb ff ff       	call   14ca9 <_Skip>
   15135:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   15138:	8b 45 08             	mov    0x8(%ebp),%eax
   1513b:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   15141:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15144:	8b 40 18             	mov    0x18(%eax),%eax
   15147:	bb 01 00 00 00       	mov    $0x1,%ebx
   1514c:	89 c1                	mov    %eax,%ecx
   1514e:	d3 e3                	shl    %cl,%ebx
   15150:	89 d8                	mov    %ebx,%eax
   15152:	09 c2                	or     %eax,%edx
   15154:	8b 45 08             	mov    0x8(%ebp),%eax
   15157:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   1515d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15160:	8b 40 04             	mov    0x4(%eax),%eax
   15163:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15166:	7e 09                	jle    15171 <_DecodeSOF+0x24f>
   15168:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1516b:	8b 40 04             	mov    0x4(%eax),%eax
   1516e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   15171:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15174:	8b 40 08             	mov    0x8(%eax),%eax
   15177:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1517a:	7e 09                	jle    15185 <_DecodeSOF+0x263>
   1517c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1517f:	8b 40 08             	mov    0x8(%eax),%eax
   15182:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15185:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15189:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1518d:	8b 45 08             	mov    0x8(%ebp),%eax
   15190:	8b 40 28             	mov    0x28(%eax),%eax
   15193:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15196:	0f 8f a1 fe ff ff    	jg     1503d <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   1519c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1519f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   151a6:	8b 45 08             	mov    0x8(%ebp),%eax
   151a9:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   151ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151af:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   151b6:	8b 45 08             	mov    0x8(%ebp),%eax
   151b9:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   151bc:	8b 45 08             	mov    0x8(%ebp),%eax
   151bf:	8b 50 10             	mov    0x10(%eax),%edx
   151c2:	8b 45 08             	mov    0x8(%ebp),%eax
   151c5:	8b 40 20             	mov    0x20(%eax),%eax
   151c8:	01 d0                	add    %edx,%eax
   151ca:	8d 48 ff             	lea    -0x1(%eax),%ecx
   151cd:	8b 45 08             	mov    0x8(%ebp),%eax
   151d0:	8b 58 20             	mov    0x20(%eax),%ebx
   151d3:	89 c8                	mov    %ecx,%eax
   151d5:	99                   	cltd   
   151d6:	f7 fb                	idiv   %ebx
   151d8:	89 c2                	mov    %eax,%edx
   151da:	8b 45 08             	mov    0x8(%ebp),%eax
   151dd:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   151e0:	8b 45 08             	mov    0x8(%ebp),%eax
   151e3:	8b 50 14             	mov    0x14(%eax),%edx
   151e6:	8b 45 08             	mov    0x8(%ebp),%eax
   151e9:	8b 40 24             	mov    0x24(%eax),%eax
   151ec:	01 d0                	add    %edx,%eax
   151ee:	8d 48 ff             	lea    -0x1(%eax),%ecx
   151f1:	8b 45 08             	mov    0x8(%ebp),%eax
   151f4:	8b 58 24             	mov    0x24(%eax),%ebx
   151f7:	89 c8                	mov    %ecx,%eax
   151f9:	99                   	cltd   
   151fa:	f7 fb                	idiv   %ebx
   151fc:	89 c2                	mov    %eax,%edx
   151fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15201:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   15204:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1520b:	8b 45 08             	mov    0x8(%ebp),%eax
   1520e:	83 c0 2c             	add    $0x2c,%eax
   15211:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15214:	e9 fd 00 00 00       	jmp    15316 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   15219:	8b 45 08             	mov    0x8(%ebp),%eax
   1521c:	8b 50 10             	mov    0x10(%eax),%edx
   1521f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15222:	8b 40 04             	mov    0x4(%eax),%eax
   15225:	0f af d0             	imul   %eax,%edx
   15228:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1522b:	01 d0                	add    %edx,%eax
   1522d:	83 e8 01             	sub    $0x1,%eax
   15230:	99                   	cltd   
   15231:	f7 7d ec             	idivl  -0x14(%ebp)
   15234:	89 c2                	mov    %eax,%edx
   15236:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15239:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   1523c:	8b 45 08             	mov    0x8(%ebp),%eax
   1523f:	8b 50 14             	mov    0x14(%eax),%edx
   15242:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15245:	8b 40 08             	mov    0x8(%eax),%eax
   15248:	0f af d0             	imul   %eax,%edx
   1524b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1524e:	01 d0                	add    %edx,%eax
   15250:	83 e8 01             	sub    $0x1,%eax
   15253:	99                   	cltd   
   15254:	f7 7d f0             	idivl  -0x10(%ebp)
   15257:	89 c2                	mov    %eax,%edx
   15259:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1525c:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   1525f:	8b 45 08             	mov    0x8(%ebp),%eax
   15262:	8b 50 18             	mov    0x18(%eax),%edx
   15265:	8b 45 08             	mov    0x8(%ebp),%eax
   15268:	8b 40 20             	mov    0x20(%eax),%eax
   1526b:	0f af d0             	imul   %eax,%edx
   1526e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15271:	8b 40 04             	mov    0x4(%eax),%eax
   15274:	0f af c2             	imul   %edx,%eax
   15277:	99                   	cltd   
   15278:	f7 7d ec             	idivl  -0x14(%ebp)
   1527b:	89 c2                	mov    %eax,%edx
   1527d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15280:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   15283:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15286:	8b 40 0c             	mov    0xc(%eax),%eax
   15289:	83 f8 02             	cmp    $0x2,%eax
   1528c:	7f 0b                	jg     15299 <_DecodeSOF+0x377>
   1528e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15291:	8b 40 04             	mov    0x4(%eax),%eax
   15294:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15297:	75 16                	jne    152af <_DecodeSOF+0x38d>
   15299:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1529c:	8b 40 10             	mov    0x10(%eax),%eax
   1529f:	83 f8 02             	cmp    $0x2,%eax
   152a2:	7f 19                	jg     152bd <_DecodeSOF+0x39b>
   152a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152a7:	8b 40 08             	mov    0x8(%eax),%eax
   152aa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   152ad:	74 0e                	je     152bd <_DecodeSOF+0x39b>
   152af:	8b 45 08             	mov    0x8(%ebp),%eax
   152b2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   152b8:	e9 d2 00 00 00       	jmp    1538f <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   152bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152c0:	8b 48 14             	mov    0x14(%eax),%ecx
   152c3:	8b 45 08             	mov    0x8(%ebp),%eax
   152c6:	8b 50 1c             	mov    0x1c(%eax),%edx
   152c9:	8b 45 08             	mov    0x8(%ebp),%eax
   152cc:	8b 40 24             	mov    0x24(%eax),%eax
   152cf:	0f af d0             	imul   %eax,%edx
   152d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152d5:	8b 40 08             	mov    0x8(%eax),%eax
   152d8:	0f af c2             	imul   %edx,%eax
   152db:	99                   	cltd   
   152dc:	f7 7d f0             	idivl  -0x10(%ebp)
   152df:	0f af c1             	imul   %ecx,%eax
   152e2:	83 ec 0c             	sub    $0xc,%esp
   152e5:	50                   	push   %eax
   152e6:	e8 45 c5 fe ff       	call   1830 <malloc>
   152eb:	83 c4 10             	add    $0x10,%esp
   152ee:	89 c2                	mov    %eax,%edx
   152f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152f3:	89 50 28             	mov    %edx,0x28(%eax)
   152f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152f9:	8b 40 28             	mov    0x28(%eax),%eax
   152fc:	85 c0                	test   %eax,%eax
   152fe:	75 0e                	jne    1530e <_DecodeSOF+0x3ec>
   15300:	8b 45 08             	mov    0x8(%ebp),%eax
   15303:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15309:	e9 81 00 00 00       	jmp    1538f <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1530e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15312:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   15316:	8b 45 08             	mov    0x8(%ebp),%eax
   15319:	8b 40 28             	mov    0x28(%eax),%eax
   1531c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1531f:	0f 8f f4 fe ff ff    	jg     15219 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   15325:	8b 45 08             	mov    0x8(%ebp),%eax
   15328:	8b 40 28             	mov    0x28(%eax),%eax
   1532b:	83 f8 03             	cmp    $0x3,%eax
   1532e:	75 47                	jne    15377 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   15330:	8b 45 08             	mov    0x8(%ebp),%eax
   15333:	8b 50 10             	mov    0x10(%eax),%edx
   15336:	8b 45 08             	mov    0x8(%ebp),%eax
   15339:	8b 40 14             	mov    0x14(%eax),%eax
   1533c:	0f af d0             	imul   %eax,%edx
   1533f:	8b 45 08             	mov    0x8(%ebp),%eax
   15342:	8b 40 28             	mov    0x28(%eax),%eax
   15345:	0f af c2             	imul   %edx,%eax
   15348:	83 ec 0c             	sub    $0xc,%esp
   1534b:	50                   	push   %eax
   1534c:	e8 df c4 fe ff       	call   1830 <malloc>
   15351:	83 c4 10             	add    $0x10,%esp
   15354:	89 c2                	mov    %eax,%edx
   15356:	8b 45 08             	mov    0x8(%ebp),%eax
   15359:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   1535f:	8b 45 08             	mov    0x8(%ebp),%eax
   15362:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15368:	85 c0                	test   %eax,%eax
   1536a:	75 0b                	jne    15377 <_DecodeSOF+0x455>
   1536c:	8b 45 08             	mov    0x8(%ebp),%eax
   1536f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15375:	eb 18                	jmp    1538f <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   15377:	8b 45 08             	mov    0x8(%ebp),%eax
   1537a:	8b 40 0c             	mov    0xc(%eax),%eax
   1537d:	83 ec 08             	sub    $0x8,%esp
   15380:	50                   	push   %eax
   15381:	ff 75 08             	pushl  0x8(%ebp)
   15384:	e8 20 f9 ff ff       	call   14ca9 <_Skip>
   15389:	83 c4 10             	add    $0x10,%esp
   1538c:	eb 01                	jmp    1538f <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   1538e:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   1538f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15392:	c9                   	leave  
   15393:	c3                   	ret    

00015394 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   15394:	55                   	push   %ebp
   15395:	89 e5                	mov    %esp,%ebp
   15397:	53                   	push   %ebx
   15398:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   1539b:	83 ec 0c             	sub    $0xc,%esp
   1539e:	ff 75 08             	pushl  0x8(%ebp)
   153a1:	e8 4f f9 ff ff       	call   14cf5 <_DecodeLength>
   153a6:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   153a9:	8b 45 08             	mov    0x8(%ebp),%eax
   153ac:	8b 00                	mov    (%eax),%eax
   153ae:	85 c0                	test   %eax,%eax
   153b0:	0f 85 c5 01 00 00    	jne    1557b <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   153b6:	e9 9c 01 00 00       	jmp    15557 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   153bb:	8b 45 08             	mov    0x8(%ebp),%eax
   153be:	8b 40 04             	mov    0x4(%eax),%eax
   153c1:	0f b6 00             	movzbl (%eax),%eax
   153c4:	0f b6 c0             	movzbl %al,%eax
   153c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   153ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   153cd:	25 ec 00 00 00       	and    $0xec,%eax
   153d2:	85 c0                	test   %eax,%eax
   153d4:	74 0e                	je     153e4 <_DecodeDHT+0x50>
   153d6:	8b 45 08             	mov    0x8(%ebp),%eax
   153d9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   153df:	e9 98 01 00 00       	jmp    1557c <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   153e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   153e7:	83 e0 02             	and    $0x2,%eax
   153ea:	85 c0                	test   %eax,%eax
   153ec:	74 0e                	je     153fc <_DecodeDHT+0x68>
   153ee:	8b 45 08             	mov    0x8(%ebp),%eax
   153f1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   153f7:	e9 80 01 00 00       	jmp    1557c <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   153fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   153ff:	c1 f8 03             	sar    $0x3,%eax
   15402:	0b 45 f4             	or     -0xc(%ebp),%eax
   15405:	83 e0 03             	and    $0x3,%eax
   15408:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1540b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   15412:	eb 1c                	jmp    15430 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   15414:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15417:	8d 50 ff             	lea    -0x1(%eax),%edx
   1541a:	8b 45 08             	mov    0x8(%ebp),%eax
   1541d:	8b 48 04             	mov    0x4(%eax),%ecx
   15420:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15423:	01 c8                	add    %ecx,%eax
   15425:	0f b6 00             	movzbl (%eax),%eax
   15428:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   1542c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15430:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   15434:	7e de                	jle    15414 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   15436:	83 ec 08             	sub    $0x8,%esp
   15439:	6a 11                	push   $0x11
   1543b:	ff 75 08             	pushl  0x8(%ebp)
   1543e:	e8 66 f8 ff ff       	call   14ca9 <_Skip>
   15443:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   15446:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15449:	c1 e0 11             	shl    $0x11,%eax
   1544c:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   15452:	8b 45 08             	mov    0x8(%ebp),%eax
   15455:	01 d0                	add    %edx,%eax
   15457:	83 c0 08             	add    $0x8,%eax
   1545a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   1545d:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   15464:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15467:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1546a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   15471:	e9 be 00 00 00       	jmp    15534 <_DecodeDHT+0x1a0>
            spread >>= 1;
   15476:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   15479:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1547c:	83 e8 01             	sub    $0x1,%eax
   1547f:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   15484:	0f b6 c0             	movzbl %al,%eax
   15487:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1548a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1548e:	0f 84 9b 00 00 00    	je     1552f <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   15494:	8b 45 08             	mov    0x8(%ebp),%eax
   15497:	8b 40 0c             	mov    0xc(%eax),%eax
   1549a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1549d:	7d 0e                	jge    154ad <_DecodeDHT+0x119>
   1549f:	8b 45 08             	mov    0x8(%ebp),%eax
   154a2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   154a8:	e9 cf 00 00 00       	jmp    1557c <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   154ad:	b8 10 00 00 00       	mov    $0x10,%eax
   154b2:	2b 45 f0             	sub    -0x10(%ebp),%eax
   154b5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   154b8:	89 c1                	mov    %eax,%ecx
   154ba:	d3 e2                	shl    %cl,%edx
   154bc:	89 d0                	mov    %edx,%eax
   154be:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   154c1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   154c5:	79 0e                	jns    154d5 <_DecodeDHT+0x141>
   154c7:	8b 45 08             	mov    0x8(%ebp),%eax
   154ca:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   154d0:	e9 a7 00 00 00       	jmp    1557c <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   154d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   154dc:	eb 36                	jmp    15514 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   154de:	8b 45 08             	mov    0x8(%ebp),%eax
   154e1:	8b 50 04             	mov    0x4(%eax),%edx
   154e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   154e7:	01 d0                	add    %edx,%eax
   154e9:	0f b6 00             	movzbl (%eax),%eax
   154ec:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   154ee:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   154f1:	eb 14                	jmp    15507 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   154f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154f6:	89 c2                	mov    %eax,%edx
   154f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   154fb:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   154fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15500:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   15503:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   15507:	89 d8                	mov    %ebx,%eax
   15509:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1550c:	85 c0                	test   %eax,%eax
   1550e:	75 e3                	jne    154f3 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   15510:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15514:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15517:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1551a:	7c c2                	jl     154de <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   1551c:	83 ec 08             	sub    $0x8,%esp
   1551f:	ff 75 e0             	pushl  -0x20(%ebp)
   15522:	ff 75 08             	pushl  0x8(%ebp)
   15525:	e8 7f f7 ff ff       	call   14ca9 <_Skip>
   1552a:	83 c4 10             	add    $0x10,%esp
   1552d:	eb 01                	jmp    15530 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   1552f:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   15530:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15534:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   15538:	0f 8e 38 ff ff ff    	jle    15476 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1553e:	eb 0a                	jmp    1554a <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   15540:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15543:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   15546:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1554a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1554d:	8d 50 ff             	lea    -0x1(%eax),%edx
   15550:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15553:	85 c0                	test   %eax,%eax
   15555:	75 e9                	jne    15540 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   15557:	8b 45 08             	mov    0x8(%ebp),%eax
   1555a:	8b 40 0c             	mov    0xc(%eax),%eax
   1555d:	83 f8 10             	cmp    $0x10,%eax
   15560:	0f 8f 55 fe ff ff    	jg     153bb <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   15566:	8b 45 08             	mov    0x8(%ebp),%eax
   15569:	8b 40 0c             	mov    0xc(%eax),%eax
   1556c:	85 c0                	test   %eax,%eax
   1556e:	74 0c                	je     1557c <_DecodeDHT+0x1e8>
   15570:	8b 45 08             	mov    0x8(%ebp),%eax
   15573:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15579:	eb 01                	jmp    1557c <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   1557b:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1557c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1557f:	c9                   	leave  
   15580:	c3                   	ret    

00015581 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   15581:	55                   	push   %ebp
   15582:	89 e5                	mov    %esp,%ebp
   15584:	53                   	push   %ebx
   15585:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   15588:	83 ec 0c             	sub    $0xc,%esp
   1558b:	ff 75 08             	pushl  0x8(%ebp)
   1558e:	e8 62 f7 ff ff       	call   14cf5 <_DecodeLength>
   15593:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   15596:	8b 45 08             	mov    0x8(%ebp),%eax
   15599:	8b 00                	mov    (%eax),%eax
   1559b:	85 c0                	test   %eax,%eax
   1559d:	0f 85 e2 00 00 00    	jne    15685 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   155a3:	e9 b8 00 00 00       	jmp    15660 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   155a8:	8b 45 08             	mov    0x8(%ebp),%eax
   155ab:	8b 40 04             	mov    0x4(%eax),%eax
   155ae:	0f b6 00             	movzbl (%eax),%eax
   155b1:	0f b6 c0             	movzbl %al,%eax
   155b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   155b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155ba:	25 ec 00 00 00       	and    $0xec,%eax
   155bf:	85 c0                	test   %eax,%eax
   155c1:	74 0e                	je     155d1 <_DecodeDQT+0x50>
   155c3:	8b 45 08             	mov    0x8(%ebp),%eax
   155c6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   155cc:	e9 b5 00 00 00       	jmp    15686 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   155d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155d4:	83 e0 10             	and    $0x10,%eax
   155d7:	85 c0                	test   %eax,%eax
   155d9:	74 0e                	je     155e9 <_DecodeDQT+0x68>
   155db:	8b 45 08             	mov    0x8(%ebp),%eax
   155de:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   155e4:	e9 9d 00 00 00       	jmp    15686 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   155e9:	8b 45 08             	mov    0x8(%ebp),%eax
   155ec:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   155f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155f5:	bb 01 00 00 00       	mov    $0x1,%ebx
   155fa:	89 c1                	mov    %eax,%ecx
   155fc:	d3 e3                	shl    %cl,%ebx
   155fe:	89 d8                	mov    %ebx,%eax
   15600:	09 c2                	or     %eax,%edx
   15602:	8b 45 08             	mov    0x8(%ebp),%eax
   15605:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   1560b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1560e:	c1 e0 06             	shl    $0x6,%eax
   15611:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   15617:	8b 45 08             	mov    0x8(%ebp),%eax
   1561a:	01 d0                	add    %edx,%eax
   1561c:	83 c0 08             	add    $0x8,%eax
   1561f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   15622:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15629:	eb 1f                	jmp    1564a <_DecodeDQT+0xc9>
   1562b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1562e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15631:	01 c2                	add    %eax,%edx
   15633:	8b 45 08             	mov    0x8(%ebp),%eax
   15636:	8b 40 04             	mov    0x4(%eax),%eax
   15639:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1563c:	83 c1 01             	add    $0x1,%ecx
   1563f:	01 c8                	add    %ecx,%eax
   15641:	0f b6 00             	movzbl (%eax),%eax
   15644:	88 02                	mov    %al,(%edx)
   15646:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1564a:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1564e:	7e db                	jle    1562b <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   15650:	83 ec 08             	sub    $0x8,%esp
   15653:	6a 41                	push   $0x41
   15655:	ff 75 08             	pushl  0x8(%ebp)
   15658:	e8 4c f6 ff ff       	call   14ca9 <_Skip>
   1565d:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   15660:	8b 45 08             	mov    0x8(%ebp),%eax
   15663:	8b 40 0c             	mov    0xc(%eax),%eax
   15666:	83 f8 40             	cmp    $0x40,%eax
   15669:	0f 8f 39 ff ff ff    	jg     155a8 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1566f:	8b 45 08             	mov    0x8(%ebp),%eax
   15672:	8b 40 0c             	mov    0xc(%eax),%eax
   15675:	85 c0                	test   %eax,%eax
   15677:	74 0d                	je     15686 <_DecodeDQT+0x105>
   15679:	8b 45 08             	mov    0x8(%ebp),%eax
   1567c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15682:	90                   	nop
   15683:	eb 01                	jmp    15686 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   15685:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   15686:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15689:	c9                   	leave  
   1568a:	c3                   	ret    

0001568b <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   1568b:	55                   	push   %ebp
   1568c:	89 e5                	mov    %esp,%ebp
   1568e:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15691:	83 ec 0c             	sub    $0xc,%esp
   15694:	ff 75 08             	pushl  0x8(%ebp)
   15697:	e8 59 f6 ff ff       	call   14cf5 <_DecodeLength>
   1569c:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1569f:	8b 45 08             	mov    0x8(%ebp),%eax
   156a2:	8b 00                	mov    (%eax),%eax
   156a4:	85 c0                	test   %eax,%eax
   156a6:	75 4a                	jne    156f2 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   156a8:	8b 45 08             	mov    0x8(%ebp),%eax
   156ab:	8b 40 0c             	mov    0xc(%eax),%eax
   156ae:	83 f8 01             	cmp    $0x1,%eax
   156b1:	7f 0b                	jg     156be <_DecodeDRI+0x33>
   156b3:	8b 45 08             	mov    0x8(%ebp),%eax
   156b6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   156bc:	eb 35                	jmp    156f3 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   156be:	8b 45 08             	mov    0x8(%ebp),%eax
   156c1:	8b 40 04             	mov    0x4(%eax),%eax
   156c4:	83 ec 0c             	sub    $0xc,%esp
   156c7:	50                   	push   %eax
   156c8:	e8 8b f6 ff ff       	call   14d58 <_Decode2Bytes>
   156cd:	83 c4 10             	add    $0x10,%esp
   156d0:	89 c2                	mov    %eax,%edx
   156d2:	8b 45 08             	mov    0x8(%ebp),%eax
   156d5:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   156db:	8b 45 08             	mov    0x8(%ebp),%eax
   156de:	8b 40 0c             	mov    0xc(%eax),%eax
   156e1:	83 ec 08             	sub    $0x8,%esp
   156e4:	50                   	push   %eax
   156e5:	ff 75 08             	pushl  0x8(%ebp)
   156e8:	e8 bc f5 ff ff       	call   14ca9 <_Skip>
   156ed:	83 c4 10             	add    $0x10,%esp
   156f0:	eb 01                	jmp    156f3 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   156f2:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   156f3:	c9                   	leave  
   156f4:	c3                   	ret    

000156f5 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   156f5:	55                   	push   %ebp
   156f6:	89 e5                	mov    %esp,%ebp
   156f8:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   156fb:	8b 45 08             	mov    0x8(%ebp),%eax
   156fe:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   15704:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15707:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   1570e:	83 ec 0c             	sub    $0xc,%esp
   15711:	ff 75 08             	pushl  0x8(%ebp)
   15714:	e8 dc f5 ff ff       	call   14cf5 <_DecodeLength>
   15719:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1571c:	8b 45 08             	mov    0x8(%ebp),%eax
   1571f:	8b 00                	mov    (%eax),%eax
   15721:	85 c0                	test   %eax,%eax
   15723:	0f 85 c2 02 00 00    	jne    159eb <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   15729:	8b 45 08             	mov    0x8(%ebp),%eax
   1572c:	8b 50 0c             	mov    0xc(%eax),%edx
   1572f:	8b 45 08             	mov    0x8(%ebp),%eax
   15732:	8b 40 28             	mov    0x28(%eax),%eax
   15735:	83 c0 02             	add    $0x2,%eax
   15738:	01 c0                	add    %eax,%eax
   1573a:	39 c2                	cmp    %eax,%edx
   1573c:	7c 16                	jl     15754 <_DecodeSOS+0x5f>
   1573e:	8b 45 08             	mov    0x8(%ebp),%eax
   15741:	8b 40 04             	mov    0x4(%eax),%eax
   15744:	0f b6 00             	movzbl (%eax),%eax
   15747:	0f b6 d0             	movzbl %al,%edx
   1574a:	8b 45 08             	mov    0x8(%ebp),%eax
   1574d:	8b 40 28             	mov    0x28(%eax),%eax
   15750:	39 c2                	cmp    %eax,%edx
   15752:	74 0e                	je     15762 <_DecodeSOS+0x6d>
   15754:	8b 45 08             	mov    0x8(%ebp),%eax
   15757:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1575d:	e9 8d 02 00 00       	jmp    159ef <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   15762:	83 ec 08             	sub    $0x8,%esp
   15765:	6a 01                	push   $0x1
   15767:	ff 75 08             	pushl  0x8(%ebp)
   1576a:	e8 3a f5 ff ff       	call   14ca9 <_Skip>
   1576f:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15772:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15779:	8b 45 08             	mov    0x8(%ebp),%eax
   1577c:	83 c0 2c             	add    $0x2c,%eax
   1577f:	89 45 dc             	mov    %eax,-0x24(%ebp)
   15782:	e9 ba 00 00 00       	jmp    15841 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   15787:	8b 45 08             	mov    0x8(%ebp),%eax
   1578a:	8b 40 04             	mov    0x4(%eax),%eax
   1578d:	0f b6 00             	movzbl (%eax),%eax
   15790:	0f b6 d0             	movzbl %al,%edx
   15793:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15796:	8b 00                	mov    (%eax),%eax
   15798:	39 c2                	cmp    %eax,%edx
   1579a:	74 0e                	je     157aa <_DecodeSOS+0xb5>
   1579c:	8b 45 08             	mov    0x8(%ebp),%eax
   1579f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   157a5:	e9 45 02 00 00       	jmp    159ef <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   157aa:	8b 45 08             	mov    0x8(%ebp),%eax
   157ad:	8b 40 04             	mov    0x4(%eax),%eax
   157b0:	83 c0 01             	add    $0x1,%eax
   157b3:	0f b6 00             	movzbl (%eax),%eax
   157b6:	0f b6 c0             	movzbl %al,%eax
   157b9:	25 ec 00 00 00       	and    $0xec,%eax
   157be:	85 c0                	test   %eax,%eax
   157c0:	74 0e                	je     157d0 <_DecodeSOS+0xdb>
   157c2:	8b 45 08             	mov    0x8(%ebp),%eax
   157c5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   157cb:	e9 1f 02 00 00       	jmp    159ef <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   157d0:	8b 45 08             	mov    0x8(%ebp),%eax
   157d3:	8b 40 04             	mov    0x4(%eax),%eax
   157d6:	83 c0 01             	add    $0x1,%eax
   157d9:	0f b6 00             	movzbl (%eax),%eax
   157dc:	0f b6 c0             	movzbl %al,%eax
   157df:	83 e0 02             	and    $0x2,%eax
   157e2:	85 c0                	test   %eax,%eax
   157e4:	74 0e                	je     157f4 <_DecodeSOS+0xff>
   157e6:	8b 45 08             	mov    0x8(%ebp),%eax
   157e9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   157ef:	e9 fb 01 00 00       	jmp    159ef <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   157f4:	8b 45 08             	mov    0x8(%ebp),%eax
   157f7:	8b 40 04             	mov    0x4(%eax),%eax
   157fa:	83 c0 01             	add    $0x1,%eax
   157fd:	0f b6 00             	movzbl (%eax),%eax
   15800:	c0 e8 04             	shr    $0x4,%al
   15803:	0f b6 d0             	movzbl %al,%edx
   15806:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15809:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   1580c:	8b 45 08             	mov    0x8(%ebp),%eax
   1580f:	8b 40 04             	mov    0x4(%eax),%eax
   15812:	83 c0 01             	add    $0x1,%eax
   15815:	0f b6 00             	movzbl (%eax),%eax
   15818:	0f b6 c0             	movzbl %al,%eax
   1581b:	83 e0 01             	and    $0x1,%eax
   1581e:	83 c8 02             	or     $0x2,%eax
   15821:	89 c2                	mov    %eax,%edx
   15823:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15826:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   15829:	83 ec 08             	sub    $0x8,%esp
   1582c:	6a 02                	push   $0x2
   1582e:	ff 75 08             	pushl  0x8(%ebp)
   15831:	e8 73 f4 ff ff       	call   14ca9 <_Skip>
   15836:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15839:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1583d:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   15841:	8b 45 08             	mov    0x8(%ebp),%eax
   15844:	8b 40 28             	mov    0x28(%eax),%eax
   15847:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1584a:	0f 8f 37 ff ff ff    	jg     15787 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   15850:	8b 45 08             	mov    0x8(%ebp),%eax
   15853:	8b 40 04             	mov    0x4(%eax),%eax
   15856:	0f b6 00             	movzbl (%eax),%eax
   15859:	84 c0                	test   %al,%al
   1585b:	75 10                	jne    1586d <_DecodeSOS+0x178>
   1585d:	8b 45 08             	mov    0x8(%ebp),%eax
   15860:	8b 40 04             	mov    0x4(%eax),%eax
   15863:	83 c0 01             	add    $0x1,%eax
   15866:	0f b6 00             	movzbl (%eax),%eax
   15869:	3c 3f                	cmp    $0x3f,%al
   1586b:	74 0e                	je     1587b <_DecodeSOS+0x186>
   1586d:	8b 45 08             	mov    0x8(%ebp),%eax
   15870:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15876:	e9 74 01 00 00       	jmp    159ef <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   1587b:	8b 45 08             	mov    0x8(%ebp),%eax
   1587e:	8b 40 04             	mov    0x4(%eax),%eax
   15881:	83 c0 02             	add    $0x2,%eax
   15884:	0f b6 00             	movzbl (%eax),%eax
   15887:	84 c0                	test   %al,%al
   15889:	74 0e                	je     15899 <_DecodeSOS+0x1a4>
   1588b:	8b 45 08             	mov    0x8(%ebp),%eax
   1588e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   15894:	e9 56 01 00 00       	jmp    159ef <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   15899:	8b 45 08             	mov    0x8(%ebp),%eax
   1589c:	8b 40 0c             	mov    0xc(%eax),%eax
   1589f:	83 ec 08             	sub    $0x8,%esp
   158a2:	50                   	push   %eax
   158a3:	ff 75 08             	pushl  0x8(%ebp)
   158a6:	e8 fe f3 ff ff       	call   14ca9 <_Skip>
   158ab:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   158ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   158b5:	e9 17 01 00 00       	jmp    159d1 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   158ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   158c1:	e9 f8 00 00 00       	jmp    159be <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   158c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   158cd:	8b 45 08             	mov    0x8(%ebp),%eax
   158d0:	83 c0 2c             	add    $0x2c,%eax
   158d3:	89 45 dc             	mov    %eax,-0x24(%ebp)
   158d6:	e9 8d 00 00 00       	jmp    15968 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   158db:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   158e2:	eb 71                	jmp    15955 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   158e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   158eb:	eb 59                	jmp    15946 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   158ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
   158f0:	8b 50 28             	mov    0x28(%eax),%edx
   158f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   158f6:	8b 40 08             	mov    0x8(%eax),%eax
   158f9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   158fd:	89 c1                	mov    %eax,%ecx
   158ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15902:	01 c1                	add    %eax,%ecx
   15904:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15907:	8b 40 14             	mov    0x14(%eax),%eax
   1590a:	0f af c8             	imul   %eax,%ecx
   1590d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15910:	8b 40 04             	mov    0x4(%eax),%eax
   15913:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   15917:	01 c1                	add    %eax,%ecx
   15919:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1591c:	01 c8                	add    %ecx,%eax
   1591e:	c1 e0 03             	shl    $0x3,%eax
   15921:	01 d0                	add    %edx,%eax
   15923:	50                   	push   %eax
   15924:	ff 75 dc             	pushl  -0x24(%ebp)
   15927:	ff 75 0c             	pushl  0xc(%ebp)
   1592a:	ff 75 08             	pushl  0x8(%ebp)
   1592d:	e8 bf 00 00 00       	call   159f1 <_DecodeBlock>
   15932:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   15935:	8b 45 08             	mov    0x8(%ebp),%eax
   15938:	8b 00                	mov    (%eax),%eax
   1593a:	85 c0                	test   %eax,%eax
   1593c:	0f 85 ac 00 00 00    	jne    159ee <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   15942:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   15946:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15949:	8b 40 04             	mov    0x4(%eax),%eax
   1594c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1594f:	7f 9c                	jg     158ed <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   15951:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15955:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15958:	8b 40 08             	mov    0x8(%eax),%eax
   1595b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1595e:	7f 84                	jg     158e4 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   15960:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15964:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   15968:	8b 45 08             	mov    0x8(%ebp),%eax
   1596b:	8b 40 28             	mov    0x28(%eax),%eax
   1596e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15971:	0f 8f 64 ff ff ff    	jg     158db <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   15977:	8b 45 08             	mov    0x8(%ebp),%eax
   1597a:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   15980:	85 c0                	test   %eax,%eax
   15982:	74 36                	je     159ba <_DecodeSOS+0x2c5>
   15984:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   15988:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1598c:	75 2c                	jne    159ba <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   1598e:	83 ec 0c             	sub    $0xc,%esp
   15991:	ff 75 08             	pushl  0x8(%ebp)
   15994:	e8 9f 0a 00 00       	call   16438 <_ByteAlign>
   15999:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   1599c:	83 ec 08             	sub    $0x8,%esp
   1599f:	6a 10                	push   $0x10
   159a1:	ff 75 08             	pushl  0x8(%ebp)
   159a4:	e8 ce 04 00 00       	call   15e77 <_GetBits>
   159a9:	83 c4 10             	add    $0x10,%esp
   159ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   159af:	8b 45 08             	mov    0x8(%ebp),%eax
   159b2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   159b8:	eb 35                	jmp    159ef <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   159ba:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   159be:	8b 45 08             	mov    0x8(%ebp),%eax
   159c1:	8b 40 18             	mov    0x18(%eax),%eax
   159c4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   159c7:	0f 8f f9 fe ff ff    	jg     158c6 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   159cd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   159d1:	8b 45 08             	mov    0x8(%ebp),%eax
   159d4:	8b 40 1c             	mov    0x1c(%eax),%eax
   159d7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   159da:	0f 8f da fe ff ff    	jg     158ba <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   159e0:	8b 45 08             	mov    0x8(%ebp),%eax
   159e3:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   159e9:	eb 04                	jmp    159ef <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   159eb:	90                   	nop
   159ec:	eb 01                	jmp    159ef <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   159ee:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   159ef:	c9                   	leave  
   159f0:	c3                   	ret    

000159f1 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   159f1:	55                   	push   %ebp
   159f2:	89 e5                	mov    %esp,%ebp
   159f4:	53                   	push   %ebx
   159f5:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   159f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   159ff:	8b 45 08             	mov    0x8(%ebp),%eax
   15a02:	05 c0 01 08 00       	add    $0x801c0,%eax
   15a07:	83 ec 04             	sub    $0x4,%esp
   15a0a:	68 00 01 00 00       	push   $0x100
   15a0f:	6a 00                	push   $0x0
   15a11:	50                   	push   %eax
   15a12:	e8 04 b8 fe ff       	call   121b <memset>
   15a17:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   15a1a:	8b 45 10             	mov    0x10(%ebp),%eax
   15a1d:	8b 40 20             	mov    0x20(%eax),%eax
   15a20:	c1 e0 11             	shl    $0x11,%eax
   15a23:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   15a29:	8b 45 08             	mov    0x8(%ebp),%eax
   15a2c:	01 d0                	add    %edx,%eax
   15a2e:	83 c0 08             	add    $0x8,%eax
   15a31:	83 ec 04             	sub    $0x4,%esp
   15a34:	6a 00                	push   $0x0
   15a36:	50                   	push   %eax
   15a37:	ff 75 08             	pushl  0x8(%ebp)
   15a3a:	e8 86 01 00 00       	call   15bc5 <_GetVLC>
   15a3f:	83 c4 10             	add    $0x10,%esp
   15a42:	89 c2                	mov    %eax,%edx
   15a44:	8b 45 10             	mov    0x10(%ebp),%eax
   15a47:	8b 40 24             	mov    0x24(%eax),%eax
   15a4a:	01 c2                	add    %eax,%edx
   15a4c:	8b 45 10             	mov    0x10(%ebp),%eax
   15a4f:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   15a52:	8b 45 10             	mov    0x10(%ebp),%eax
   15a55:	8b 50 24             	mov    0x24(%eax),%edx
   15a58:	8b 45 10             	mov    0x10(%ebp),%eax
   15a5b:	8b 48 18             	mov    0x18(%eax),%ecx
   15a5e:	8b 45 08             	mov    0x8(%ebp),%eax
   15a61:	c1 e1 06             	shl    $0x6,%ecx
   15a64:	01 c8                	add    %ecx,%eax
   15a66:	05 b8 00 00 00       	add    $0xb8,%eax
   15a6b:	0f b6 00             	movzbl (%eax),%eax
   15a6e:	0f b6 c0             	movzbl %al,%eax
   15a71:	0f af d0             	imul   %eax,%edx
   15a74:	8b 45 08             	mov    0x8(%ebp),%eax
   15a77:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   15a7d:	8b 45 10             	mov    0x10(%ebp),%eax
   15a80:	8b 40 1c             	mov    0x1c(%eax),%eax
   15a83:	c1 e0 11             	shl    $0x11,%eax
   15a86:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   15a8c:	8b 45 08             	mov    0x8(%ebp),%eax
   15a8f:	01 d0                	add    %edx,%eax
   15a91:	8d 50 08             	lea    0x8(%eax),%edx
   15a94:	83 ec 04             	sub    $0x4,%esp
   15a97:	8d 45 ef             	lea    -0x11(%ebp),%eax
   15a9a:	50                   	push   %eax
   15a9b:	52                   	push   %edx
   15a9c:	ff 75 08             	pushl  0x8(%ebp)
   15a9f:	e8 21 01 00 00       	call   15bc5 <_GetVLC>
   15aa4:	83 c4 10             	add    $0x10,%esp
   15aa7:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   15aaa:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15aae:	84 c0                	test   %al,%al
   15ab0:	0f 84 92 00 00 00    	je     15b48 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   15ab6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15aba:	0f b6 c0             	movzbl %al,%eax
   15abd:	83 e0 0f             	and    $0xf,%eax
   15ac0:	85 c0                	test   %eax,%eax
   15ac2:	75 16                	jne    15ada <_DecodeBlock+0xe9>
   15ac4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15ac8:	3c f0                	cmp    $0xf0,%al
   15aca:	74 0e                	je     15ada <_DecodeBlock+0xe9>
   15acc:	8b 45 08             	mov    0x8(%ebp),%eax
   15acf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15ad5:	e9 e6 00 00 00       	jmp    15bc0 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   15ada:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15ade:	c0 e8 04             	shr    $0x4,%al
   15ae1:	0f b6 c0             	movzbl %al,%eax
   15ae4:	83 c0 01             	add    $0x1,%eax
   15ae7:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   15aea:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   15aee:	7e 0e                	jle    15afe <_DecodeBlock+0x10d>
   15af0:	8b 45 08             	mov    0x8(%ebp),%eax
   15af3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15af9:	e9 c2 00 00 00       	jmp    15bc0 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   15afe:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b01:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b04:	01 d0                	add    %edx,%eax
   15b06:	0f b6 00             	movzbl (%eax),%eax
   15b09:	0f be c8             	movsbl %al,%ecx
   15b0c:	8b 45 10             	mov    0x10(%ebp),%eax
   15b0f:	8b 50 18             	mov    0x18(%eax),%edx
   15b12:	8b 45 08             	mov    0x8(%ebp),%eax
   15b15:	c1 e2 06             	shl    $0x6,%edx
   15b18:	01 c2                	add    %eax,%edx
   15b1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b1d:	01 d0                	add    %edx,%eax
   15b1f:	05 b8 00 00 00       	add    $0xb8,%eax
   15b24:	0f b6 00             	movzbl (%eax),%eax
   15b27:	0f b6 c0             	movzbl %al,%eax
   15b2a:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   15b2e:	89 c2                	mov    %eax,%edx
   15b30:	8b 45 08             	mov    0x8(%ebp),%eax
   15b33:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   15b39:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   15b3c:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   15b40:	0f 8e 37 ff ff ff    	jle    15a7d <_DecodeBlock+0x8c>
   15b46:	eb 01                	jmp    15b49 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   15b48:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   15b49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15b50:	eb 24                	jmp    15b76 <_DecodeBlock+0x185>
   15b52:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b55:	05 70 00 02 00       	add    $0x20070,%eax
   15b5a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   15b61:	8b 45 08             	mov    0x8(%ebp),%eax
   15b64:	01 d0                	add    %edx,%eax
   15b66:	83 ec 0c             	sub    $0xc,%esp
   15b69:	50                   	push   %eax
   15b6a:	e8 32 03 00 00       	call   15ea1 <_RowIDCT>
   15b6f:	83 c4 10             	add    $0x10,%esp
   15b72:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   15b76:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   15b7a:	7e d6                	jle    15b52 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   15b7c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15b83:	eb 35                	jmp    15bba <_DecodeBlock+0x1c9>
   15b85:	8b 45 10             	mov    0x10(%ebp),%eax
   15b88:	8b 40 14             	mov    0x14(%eax),%eax
   15b8b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15b8e:	8b 55 14             	mov    0x14(%ebp),%edx
   15b91:	01 d1                	add    %edx,%ecx
   15b93:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b96:	81 c2 70 00 02 00    	add    $0x20070,%edx
   15b9c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   15ba3:	8b 55 08             	mov    0x8(%ebp),%edx
   15ba6:	01 da                	add    %ebx,%edx
   15ba8:	83 ec 04             	sub    $0x4,%esp
   15bab:	50                   	push   %eax
   15bac:	51                   	push   %ecx
   15bad:	52                   	push   %edx
   15bae:	e8 7b 05 00 00       	call   1612e <_ColIDCT>
   15bb3:	83 c4 10             	add    $0x10,%esp
   15bb6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15bba:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   15bbe:	7e c5                	jle    15b85 <_DecodeBlock+0x194>
}
   15bc0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15bc3:	c9                   	leave  
   15bc4:	c3                   	ret    

00015bc5 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   15bc5:	55                   	push   %ebp
   15bc6:	89 e5                	mov    %esp,%ebp
   15bc8:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   15bcb:	83 ec 08             	sub    $0x8,%esp
   15bce:	6a 10                	push   $0x10
   15bd0:	ff 75 08             	pushl  0x8(%ebp)
   15bd3:	e8 c2 00 00 00       	call   15c9a <_ShowBits>
   15bd8:	83 c4 10             	add    $0x10,%esp
   15bdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   15bde:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15be1:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15be4:	8b 45 0c             	mov    0xc(%ebp),%eax
   15be7:	01 d0                	add    %edx,%eax
   15be9:	0f b6 00             	movzbl (%eax),%eax
   15bec:	0f b6 c0             	movzbl %al,%eax
   15bef:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   15bf2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15bf6:	75 13                	jne    15c0b <_GetVLC+0x46>
   15bf8:	8b 45 08             	mov    0x8(%ebp),%eax
   15bfb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15c01:	b8 00 00 00 00       	mov    $0x0,%eax
   15c06:	e9 8d 00 00 00       	jmp    15c98 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   15c0b:	83 ec 08             	sub    $0x8,%esp
   15c0e:	ff 75 f0             	pushl  -0x10(%ebp)
   15c11:	ff 75 08             	pushl  0x8(%ebp)
   15c14:	e8 25 02 00 00       	call   15e3e <_SkipBits>
   15c19:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   15c1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c1f:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15c22:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c25:	01 d0                	add    %edx,%eax
   15c27:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   15c2b:	0f b6 c0             	movzbl %al,%eax
   15c2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   15c31:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15c35:	74 0a                	je     15c41 <_GetVLC+0x7c>
   15c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c3a:	89 c2                	mov    %eax,%edx
   15c3c:	8b 45 10             	mov    0x10(%ebp),%eax
   15c3f:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   15c41:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c44:	83 e0 0f             	and    $0xf,%eax
   15c47:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   15c4a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15c4e:	75 07                	jne    15c57 <_GetVLC+0x92>
   15c50:	b8 00 00 00 00       	mov    $0x0,%eax
   15c55:	eb 41                	jmp    15c98 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   15c57:	83 ec 08             	sub    $0x8,%esp
   15c5a:	ff 75 f0             	pushl  -0x10(%ebp)
   15c5d:	ff 75 08             	pushl  0x8(%ebp)
   15c60:	e8 12 02 00 00       	call   15e77 <_GetBits>
   15c65:	83 c4 10             	add    $0x10,%esp
   15c68:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   15c6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c6e:	83 e8 01             	sub    $0x1,%eax
   15c71:	ba 01 00 00 00       	mov    $0x1,%edx
   15c76:	89 c1                	mov    %eax,%ecx
   15c78:	d3 e2                	shl    %cl,%edx
   15c7a:	89 d0                	mov    %edx,%eax
   15c7c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15c7f:	7e 14                	jle    15c95 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   15c81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c84:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   15c89:	89 c1                	mov    %eax,%ecx
   15c8b:	d3 e2                	shl    %cl,%edx
   15c8d:	89 d0                	mov    %edx,%eax
   15c8f:	83 c0 01             	add    $0x1,%eax
   15c92:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   15c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   15c98:	c9                   	leave  
   15c99:	c3                   	ret    

00015c9a <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   15c9a:	55                   	push   %ebp
   15c9b:	89 e5                	mov    %esp,%ebp
   15c9d:	53                   	push   %ebx
   15c9e:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   15ca1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15ca5:	0f 85 4f 01 00 00    	jne    15dfa <_ShowBits+0x160>
   15cab:	b8 00 00 00 00       	mov    $0x0,%eax
   15cb0:	e9 83 01 00 00       	jmp    15e38 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   15cb5:	8b 45 08             	mov    0x8(%ebp),%eax
   15cb8:	8b 40 08             	mov    0x8(%eax),%eax
   15cbb:	85 c0                	test   %eax,%eax
   15cbd:	7f 33                	jg     15cf2 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   15cbf:	8b 45 08             	mov    0x8(%ebp),%eax
   15cc2:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   15cc8:	c1 e0 08             	shl    $0x8,%eax
   15ccb:	0c ff                	or     $0xff,%al
   15ccd:	89 c2                	mov    %eax,%edx
   15ccf:	8b 45 08             	mov    0x8(%ebp),%eax
   15cd2:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   15cd8:	8b 45 08             	mov    0x8(%ebp),%eax
   15cdb:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15ce1:	8d 50 08             	lea    0x8(%eax),%edx
   15ce4:	8b 45 08             	mov    0x8(%ebp),%eax
   15ce7:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   15ced:	e9 08 01 00 00       	jmp    15dfa <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   15cf2:	8b 45 08             	mov    0x8(%ebp),%eax
   15cf5:	8b 40 04             	mov    0x4(%eax),%eax
   15cf8:	8d 48 01             	lea    0x1(%eax),%ecx
   15cfb:	8b 55 08             	mov    0x8(%ebp),%edx
   15cfe:	89 4a 04             	mov    %ecx,0x4(%edx)
   15d01:	0f b6 00             	movzbl (%eax),%eax
   15d04:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   15d07:	8b 45 08             	mov    0x8(%ebp),%eax
   15d0a:	8b 40 08             	mov    0x8(%eax),%eax
   15d0d:	8d 50 ff             	lea    -0x1(%eax),%edx
   15d10:	8b 45 08             	mov    0x8(%ebp),%eax
   15d13:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   15d16:	8b 45 08             	mov    0x8(%ebp),%eax
   15d19:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15d1f:	8d 50 08             	lea    0x8(%eax),%edx
   15d22:	8b 45 08             	mov    0x8(%ebp),%eax
   15d25:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   15d2b:	8b 45 08             	mov    0x8(%ebp),%eax
   15d2e:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   15d34:	c1 e0 08             	shl    $0x8,%eax
   15d37:	89 c2                	mov    %eax,%edx
   15d39:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   15d3d:	09 c2                	or     %eax,%edx
   15d3f:	8b 45 08             	mov    0x8(%ebp),%eax
   15d42:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   15d48:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   15d4c:	0f 85 a8 00 00 00    	jne    15dfa <_ShowBits+0x160>
            if(ctx->size){
   15d52:	8b 45 08             	mov    0x8(%ebp),%eax
   15d55:	8b 40 08             	mov    0x8(%eax),%eax
   15d58:	85 c0                	test   %eax,%eax
   15d5a:	0f 84 91 00 00 00    	je     15df1 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   15d60:	8b 45 08             	mov    0x8(%ebp),%eax
   15d63:	8b 40 04             	mov    0x4(%eax),%eax
   15d66:	8d 48 01             	lea    0x1(%eax),%ecx
   15d69:	8b 55 08             	mov    0x8(%ebp),%edx
   15d6c:	89 4a 04             	mov    %ecx,0x4(%edx)
   15d6f:	0f b6 00             	movzbl (%eax),%eax
   15d72:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   15d75:	8b 45 08             	mov    0x8(%ebp),%eax
   15d78:	8b 40 08             	mov    0x8(%eax),%eax
   15d7b:	8d 50 ff             	lea    -0x1(%eax),%edx
   15d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   15d81:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   15d84:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15d88:	85 c0                	test   %eax,%eax
   15d8a:	74 62                	je     15dee <_ShowBits+0x154>
   15d8c:	3d d9 00 00 00       	cmp    $0xd9,%eax
   15d91:	75 0c                	jne    15d9f <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   15d93:	8b 45 08             	mov    0x8(%ebp),%eax
   15d96:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   15d9d:	eb 5b                	jmp    15dfa <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   15d9f:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15da3:	25 f8 00 00 00       	and    $0xf8,%eax
   15da8:	3d d0 00 00 00       	cmp    $0xd0,%eax
   15dad:	74 0b                	je     15dba <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   15daf:	8b 45 08             	mov    0x8(%ebp),%eax
   15db2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15db8:	eb 40                	jmp    15dfa <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   15dba:	8b 45 08             	mov    0x8(%ebp),%eax
   15dbd:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   15dc3:	c1 e0 08             	shl    $0x8,%eax
   15dc6:	89 c2                	mov    %eax,%edx
   15dc8:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15dcc:	09 c2                	or     %eax,%edx
   15dce:	8b 45 08             	mov    0x8(%ebp),%eax
   15dd1:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   15dd7:	8b 45 08             	mov    0x8(%ebp),%eax
   15dda:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15de0:	8d 50 08             	lea    0x8(%eax),%edx
   15de3:	8b 45 08             	mov    0x8(%ebp),%eax
   15de6:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   15dec:	eb 0c                	jmp    15dfa <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   15dee:	90                   	nop
   15def:	eb 09                	jmp    15dfa <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   15df1:	8b 45 08             	mov    0x8(%ebp),%eax
   15df4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   15dfa:	8b 45 08             	mov    0x8(%ebp),%eax
   15dfd:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15e03:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15e06:	0f 8c a9 fe ff ff    	jl     15cb5 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   15e0c:	8b 45 08             	mov    0x8(%ebp),%eax
   15e0f:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   15e15:	8b 45 08             	mov    0x8(%ebp),%eax
   15e18:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15e1e:	2b 45 0c             	sub    0xc(%ebp),%eax
   15e21:	89 c1                	mov    %eax,%ecx
   15e23:	d3 fa                	sar    %cl,%edx
   15e25:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e28:	bb 01 00 00 00       	mov    $0x1,%ebx
   15e2d:	89 c1                	mov    %eax,%ecx
   15e2f:	d3 e3                	shl    %cl,%ebx
   15e31:	89 d8                	mov    %ebx,%eax
   15e33:	83 e8 01             	sub    $0x1,%eax
   15e36:	21 d0                	and    %edx,%eax
}
   15e38:	83 c4 10             	add    $0x10,%esp
   15e3b:	5b                   	pop    %ebx
   15e3c:	5d                   	pop    %ebp
   15e3d:	c3                   	ret    

00015e3e <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   15e3e:	55                   	push   %ebp
   15e3f:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   15e41:	8b 45 08             	mov    0x8(%ebp),%eax
   15e44:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15e4a:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15e4d:	7d 0e                	jge    15e5d <_SkipBits+0x1f>
   15e4f:	ff 75 0c             	pushl  0xc(%ebp)
   15e52:	ff 75 08             	pushl  0x8(%ebp)
   15e55:	e8 40 fe ff ff       	call   15c9a <_ShowBits>
   15e5a:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   15e5d:	8b 45 08             	mov    0x8(%ebp),%eax
   15e60:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15e66:	2b 45 0c             	sub    0xc(%ebp),%eax
   15e69:	89 c2                	mov    %eax,%edx
   15e6b:	8b 45 08             	mov    0x8(%ebp),%eax
   15e6e:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15e74:	90                   	nop
   15e75:	c9                   	leave  
   15e76:	c3                   	ret    

00015e77 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   15e77:	55                   	push   %ebp
   15e78:	89 e5                	mov    %esp,%ebp
   15e7a:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   15e7d:	ff 75 0c             	pushl  0xc(%ebp)
   15e80:	ff 75 08             	pushl  0x8(%ebp)
   15e83:	e8 12 fe ff ff       	call   15c9a <_ShowBits>
   15e88:	83 c4 08             	add    $0x8,%esp
   15e8b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   15e8e:	ff 75 0c             	pushl  0xc(%ebp)
   15e91:	ff 75 08             	pushl  0x8(%ebp)
   15e94:	e8 a5 ff ff ff       	call   15e3e <_SkipBits>
   15e99:	83 c4 08             	add    $0x8,%esp
    return res;
   15e9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   15e9f:	c9                   	leave  
   15ea0:	c3                   	ret    

00015ea1 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   15ea1:	55                   	push   %ebp
   15ea2:	89 e5                	mov    %esp,%ebp
   15ea4:	57                   	push   %edi
   15ea5:	56                   	push   %esi
   15ea6:	53                   	push   %ebx
   15ea7:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15eaa:	8b 45 08             	mov    0x8(%ebp),%eax
   15ead:	83 c0 10             	add    $0x10,%eax
   15eb0:	8b 00                	mov    (%eax),%eax
   15eb2:	c1 e0 0b             	shl    $0xb,%eax
   15eb5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   15eb8:	8b 45 08             	mov    0x8(%ebp),%eax
   15ebb:	8b 40 18             	mov    0x18(%eax),%eax
   15ebe:	89 45 ec             	mov    %eax,-0x14(%ebp)
   15ec1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ec4:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   15ec7:	8b 55 08             	mov    0x8(%ebp),%edx
   15eca:	8b 52 08             	mov    0x8(%edx),%edx
   15ecd:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15ed0:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   15ed3:	8b 55 08             	mov    0x8(%ebp),%edx
   15ed6:	8b 52 04             	mov    0x4(%edx),%edx
   15ed9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15edc:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   15edf:	8b 55 08             	mov    0x8(%ebp),%edx
   15ee2:	8b 52 1c             	mov    0x1c(%edx),%edx
   15ee5:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15ee8:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   15eeb:	8b 55 08             	mov    0x8(%ebp),%edx
   15eee:	8b 52 14             	mov    0x14(%edx),%edx
   15ef1:	89 55 dc             	mov    %edx,-0x24(%ebp)
   15ef4:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   15ef7:	8b 55 08             	mov    0x8(%ebp),%edx
   15efa:	8b 52 0c             	mov    0xc(%edx),%edx
   15efd:	89 55 d8             	mov    %edx,-0x28(%ebp)
   15f00:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15f03:	85 c0                	test   %eax,%eax
   15f05:	75 68                	jne    15f6f <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   15f07:	8b 45 08             	mov    0x8(%ebp),%eax
   15f0a:	8d 48 04             	lea    0x4(%eax),%ecx
   15f0d:	8b 45 08             	mov    0x8(%ebp),%eax
   15f10:	8d 58 08             	lea    0x8(%eax),%ebx
   15f13:	8b 45 08             	mov    0x8(%ebp),%eax
   15f16:	8d 70 0c             	lea    0xc(%eax),%esi
   15f19:	8b 45 08             	mov    0x8(%ebp),%eax
   15f1c:	8d 78 10             	lea    0x10(%eax),%edi
   15f1f:	8b 45 08             	mov    0x8(%ebp),%eax
   15f22:	83 c0 14             	add    $0x14,%eax
   15f25:	89 45 c0             	mov    %eax,-0x40(%ebp)
   15f28:	8b 45 08             	mov    0x8(%ebp),%eax
   15f2b:	83 c0 18             	add    $0x18,%eax
   15f2e:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15f31:	8b 45 08             	mov    0x8(%ebp),%eax
   15f34:	8d 50 1c             	lea    0x1c(%eax),%edx
   15f37:	8b 45 08             	mov    0x8(%ebp),%eax
   15f3a:	8b 00                	mov    (%eax),%eax
   15f3c:	c1 e0 03             	shl    $0x3,%eax
   15f3f:	89 02                	mov    %eax,(%edx)
   15f41:	8b 02                	mov    (%edx),%eax
   15f43:	8b 55 bc             	mov    -0x44(%ebp),%edx
   15f46:	89 02                	mov    %eax,(%edx)
   15f48:	89 d0                	mov    %edx,%eax
   15f4a:	8b 00                	mov    (%eax),%eax
   15f4c:	8b 55 c0             	mov    -0x40(%ebp),%edx
   15f4f:	89 02                	mov    %eax,(%edx)
   15f51:	89 d0                	mov    %edx,%eax
   15f53:	8b 00                	mov    (%eax),%eax
   15f55:	89 07                	mov    %eax,(%edi)
   15f57:	8b 07                	mov    (%edi),%eax
   15f59:	89 06                	mov    %eax,(%esi)
   15f5b:	8b 06                	mov    (%esi),%eax
   15f5d:	89 03                	mov    %eax,(%ebx)
   15f5f:	8b 03                	mov    (%ebx),%eax
   15f61:	89 01                	mov    %eax,(%ecx)
   15f63:	8b 11                	mov    (%ecx),%edx
   15f65:	8b 45 08             	mov    0x8(%ebp),%eax
   15f68:	89 10                	mov    %edx,(%eax)
        return;
   15f6a:	e9 b7 01 00 00       	jmp    16126 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   15f6f:	8b 45 08             	mov    0x8(%ebp),%eax
   15f72:	8b 00                	mov    (%eax),%eax
   15f74:	c1 e0 0b             	shl    $0xb,%eax
   15f77:	83 e8 80             	sub    $0xffffff80,%eax
   15f7a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   15f7d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15f80:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f83:	01 d0                	add    %edx,%eax
   15f85:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15f8b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   15f8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15f91:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   15f97:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15f9a:	01 d0                	add    %edx,%eax
   15f9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   15f9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15fa2:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15fa8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15fab:	01 d0                	add    %edx,%eax
   15fad:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   15fb0:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15fb3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15fb6:	01 d0                	add    %edx,%eax
   15fb8:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15fbe:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   15fc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15fc4:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15fca:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15fcd:	01 d0                	add    %edx,%eax
   15fcf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   15fd2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15fd5:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15fdb:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15fde:	01 d0                	add    %edx,%eax
   15fe0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   15fe3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15fe6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15fe9:	01 d0                	add    %edx,%eax
   15feb:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   15fee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ff1:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   15ff4:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15ff7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15ffa:	01 d0                	add    %edx,%eax
   15ffc:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   16002:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   16005:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16008:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1600e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16011:	01 d0                	add    %edx,%eax
   16013:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   16016:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16019:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1601f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16022:	01 d0                	add    %edx,%eax
   16024:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   16027:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1602a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1602d:	01 d0                	add    %edx,%eax
   1602f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   16032:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16035:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   16038:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1603b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1603e:	01 d0                	add    %edx,%eax
   16040:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   16043:	8b 45 d8             	mov    -0x28(%ebp),%eax
   16046:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   16049:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1604c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1604f:	01 d0                	add    %edx,%eax
   16051:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   16054:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16057:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   1605a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1605d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16060:	01 d0                	add    %edx,%eax
   16062:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   16065:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16068:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1606b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1606e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16071:	01 d0                	add    %edx,%eax
   16073:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   16079:	83 e8 80             	sub    $0xffffff80,%eax
   1607c:	c1 f8 08             	sar    $0x8,%eax
   1607f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   16082:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16085:	2b 45 e0             	sub    -0x20(%ebp),%eax
   16088:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1608e:	83 e8 80             	sub    $0xffffff80,%eax
   16091:	c1 f8 08             	sar    $0x8,%eax
   16094:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   16097:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1609a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1609d:	01 d0                	add    %edx,%eax
   1609f:	c1 f8 08             	sar    $0x8,%eax
   160a2:	89 c2                	mov    %eax,%edx
   160a4:	8b 45 08             	mov    0x8(%ebp),%eax
   160a7:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   160a9:	8b 45 08             	mov    0x8(%ebp),%eax
   160ac:	83 c0 04             	add    $0x4,%eax
   160af:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   160b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   160b5:	01 ca                	add    %ecx,%edx
   160b7:	c1 fa 08             	sar    $0x8,%edx
   160ba:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   160bc:	8b 45 08             	mov    0x8(%ebp),%eax
   160bf:	83 c0 08             	add    $0x8,%eax
   160c2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   160c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   160c8:	01 ca                	add    %ecx,%edx
   160ca:	c1 fa 08             	sar    $0x8,%edx
   160cd:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   160cf:	8b 45 08             	mov    0x8(%ebp),%eax
   160d2:	83 c0 0c             	add    $0xc,%eax
   160d5:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   160d8:	8b 55 dc             	mov    -0x24(%ebp),%edx
   160db:	01 ca                	add    %ecx,%edx
   160dd:	c1 fa 08             	sar    $0x8,%edx
   160e0:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   160e2:	8b 45 08             	mov    0x8(%ebp),%eax
   160e5:	8d 50 10             	lea    0x10(%eax),%edx
   160e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   160eb:	2b 45 dc             	sub    -0x24(%ebp),%eax
   160ee:	c1 f8 08             	sar    $0x8,%eax
   160f1:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   160f3:	8b 45 08             	mov    0x8(%ebp),%eax
   160f6:	8d 50 14             	lea    0x14(%eax),%edx
   160f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   160fc:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   160ff:	c1 f8 08             	sar    $0x8,%eax
   16102:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   16104:	8b 45 08             	mov    0x8(%ebp),%eax
   16107:	8d 50 18             	lea    0x18(%eax),%edx
   1610a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1610d:	2b 45 ec             	sub    -0x14(%ebp),%eax
   16110:	c1 f8 08             	sar    $0x8,%eax
   16113:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   16115:	8b 45 08             	mov    0x8(%ebp),%eax
   16118:	8d 50 1c             	lea    0x1c(%eax),%edx
   1611b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1611e:	2b 45 f0             	sub    -0x10(%ebp),%eax
   16121:	c1 f8 08             	sar    $0x8,%eax
   16124:	89 02                	mov    %eax,(%edx)
}
   16126:	83 c4 38             	add    $0x38,%esp
   16129:	5b                   	pop    %ebx
   1612a:	5e                   	pop    %esi
   1612b:	5f                   	pop    %edi
   1612c:	5d                   	pop    %ebp
   1612d:	c3                   	ret    

0001612e <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   1612e:	55                   	push   %ebp
   1612f:	89 e5                	mov    %esp,%ebp
   16131:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   16134:	8b 45 08             	mov    0x8(%ebp),%eax
   16137:	83 e8 80             	sub    $0xffffff80,%eax
   1613a:	8b 00                	mov    (%eax),%eax
   1613c:	c1 e0 08             	shl    $0x8,%eax
   1613f:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   16142:	8b 45 08             	mov    0x8(%ebp),%eax
   16145:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1614b:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1614e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16151:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   16154:	8b 55 08             	mov    0x8(%ebp),%edx
   16157:	8b 52 40             	mov    0x40(%edx),%edx
   1615a:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1615d:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   16160:	8b 55 08             	mov    0x8(%ebp),%edx
   16163:	8b 52 20             	mov    0x20(%edx),%edx
   16166:	89 55 ec             	mov    %edx,-0x14(%ebp)
   16169:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   1616c:	8b 55 08             	mov    0x8(%ebp),%edx
   1616f:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   16175:	89 55 e8             	mov    %edx,-0x18(%ebp)
   16178:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   1617b:	8b 55 08             	mov    0x8(%ebp),%edx
   1617e:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   16184:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   16187:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1618a:	8b 55 08             	mov    0x8(%ebp),%edx
   1618d:	8b 52 60             	mov    0x60(%edx),%edx
   16190:	89 55 e0             	mov    %edx,-0x20(%ebp)
   16193:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   16196:	85 c0                	test   %eax,%eax
   16198:	75 45                	jne    161df <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   1619a:	8b 45 08             	mov    0x8(%ebp),%eax
   1619d:	8b 00                	mov    (%eax),%eax
   1619f:	83 c0 20             	add    $0x20,%eax
   161a2:	c1 f8 06             	sar    $0x6,%eax
   161a5:	83 e8 80             	sub    $0xffffff80,%eax
   161a8:	50                   	push   %eax
   161a9:	e8 d6 ea ff ff       	call   14c84 <_Clip>
   161ae:	83 c4 04             	add    $0x4,%esp
   161b1:	0f b6 c0             	movzbl %al,%eax
   161b4:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   161b7:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   161be:	eb 14                	jmp    161d4 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   161c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   161c3:	89 c2                	mov    %eax,%edx
   161c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   161c8:	88 10                	mov    %dl,(%eax)
            out += stride;
   161ca:	8b 45 10             	mov    0x10(%ebp),%eax
   161cd:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   161d0:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   161d4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   161d8:	75 e6                	jne    161c0 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   161da:	e9 57 02 00 00       	jmp    16436 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   161df:	8b 45 08             	mov    0x8(%ebp),%eax
   161e2:	8b 00                	mov    (%eax),%eax
   161e4:	c1 e0 08             	shl    $0x8,%eax
   161e7:	05 00 20 00 00       	add    $0x2000,%eax
   161ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   161ef:	8b 55 ec             	mov    -0x14(%ebp),%edx
   161f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   161f5:	01 d0                	add    %edx,%eax
   161f7:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   161fd:	83 c0 04             	add    $0x4,%eax
   16200:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   16203:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16206:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1620c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1620f:	01 d0                	add    %edx,%eax
   16211:	c1 f8 03             	sar    $0x3,%eax
   16214:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   16217:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1621a:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   16220:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16223:	01 d0                	add    %edx,%eax
   16225:	c1 f8 03             	sar    $0x3,%eax
   16228:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   1622b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1622e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16231:	01 d0                	add    %edx,%eax
   16233:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   16239:	83 c0 04             	add    $0x4,%eax
   1623c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   1623f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16242:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   16248:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1624b:	01 d0                	add    %edx,%eax
   1624d:	c1 f8 03             	sar    $0x3,%eax
   16250:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   16253:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16256:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1625c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1625f:	01 d0                	add    %edx,%eax
   16261:	c1 f8 03             	sar    $0x3,%eax
   16264:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   16267:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1626a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1626d:	01 d0                	add    %edx,%eax
   1626f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   16272:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16275:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   16278:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1627b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1627e:	01 d0                	add    %edx,%eax
   16280:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   16286:	83 c0 04             	add    $0x4,%eax
   16289:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   1628c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1628f:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   16295:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16298:	01 d0                	add    %edx,%eax
   1629a:	c1 f8 03             	sar    $0x3,%eax
   1629d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   162a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162a3:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   162a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   162ac:	01 d0                	add    %edx,%eax
   162ae:	c1 f8 03             	sar    $0x3,%eax
   162b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   162b4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   162b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   162ba:	01 d0                	add    %edx,%eax
   162bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   162bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   162c2:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   162c5:	8b 55 e8             	mov    -0x18(%ebp),%edx
   162c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   162cb:	01 d0                	add    %edx,%eax
   162cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   162d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   162d3:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   162d6:	8b 55 dc             	mov    -0x24(%ebp),%edx
   162d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162dc:	01 d0                	add    %edx,%eax
   162de:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   162e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162e4:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   162e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   162ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162ed:	01 d0                	add    %edx,%eax
   162ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   162f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162f5:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   162f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   162fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   162fe:	01 d0                	add    %edx,%eax
   16300:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   16306:	83 e8 80             	sub    $0xffffff80,%eax
   16309:	c1 f8 08             	sar    $0x8,%eax
   1630c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   1630f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16312:	2b 45 e8             	sub    -0x18(%ebp),%eax
   16315:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1631b:	83 e8 80             	sub    $0xffffff80,%eax
   1631e:	c1 f8 08             	sar    $0x8,%eax
   16321:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   16324:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16327:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1632a:	01 d0                	add    %edx,%eax
   1632c:	c1 f8 0e             	sar    $0xe,%eax
   1632f:	83 e8 80             	sub    $0xffffff80,%eax
   16332:	50                   	push   %eax
   16333:	e8 4c e9 ff ff       	call   14c84 <_Clip>
   16338:	83 c4 04             	add    $0x4,%esp
   1633b:	89 c2                	mov    %eax,%edx
   1633d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16340:	88 10                	mov    %dl,(%eax)
   16342:	8b 45 10             	mov    0x10(%ebp),%eax
   16345:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   16348:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1634b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1634e:	01 d0                	add    %edx,%eax
   16350:	c1 f8 0e             	sar    $0xe,%eax
   16353:	83 e8 80             	sub    $0xffffff80,%eax
   16356:	50                   	push   %eax
   16357:	e8 28 e9 ff ff       	call   14c84 <_Clip>
   1635c:	83 c4 04             	add    $0x4,%esp
   1635f:	89 c2                	mov    %eax,%edx
   16361:	8b 45 0c             	mov    0xc(%ebp),%eax
   16364:	88 10                	mov    %dl,(%eax)
   16366:	8b 45 10             	mov    0x10(%ebp),%eax
   16369:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   1636c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1636f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16372:	01 d0                	add    %edx,%eax
   16374:	c1 f8 0e             	sar    $0xe,%eax
   16377:	83 e8 80             	sub    $0xffffff80,%eax
   1637a:	50                   	push   %eax
   1637b:	e8 04 e9 ff ff       	call   14c84 <_Clip>
   16380:	83 c4 04             	add    $0x4,%esp
   16383:	89 c2                	mov    %eax,%edx
   16385:	8b 45 0c             	mov    0xc(%ebp),%eax
   16388:	88 10                	mov    %dl,(%eax)
   1638a:	8b 45 10             	mov    0x10(%ebp),%eax
   1638d:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   16390:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16393:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16396:	01 d0                	add    %edx,%eax
   16398:	c1 f8 0e             	sar    $0xe,%eax
   1639b:	83 e8 80             	sub    $0xffffff80,%eax
   1639e:	50                   	push   %eax
   1639f:	e8 e0 e8 ff ff       	call   14c84 <_Clip>
   163a4:	83 c4 04             	add    $0x4,%esp
   163a7:	89 c2                	mov    %eax,%edx
   163a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   163ac:	88 10                	mov    %dl,(%eax)
   163ae:	8b 45 10             	mov    0x10(%ebp),%eax
   163b1:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   163b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   163b7:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   163ba:	c1 f8 0e             	sar    $0xe,%eax
   163bd:	83 e8 80             	sub    $0xffffff80,%eax
   163c0:	50                   	push   %eax
   163c1:	e8 be e8 ff ff       	call   14c84 <_Clip>
   163c6:	83 c4 04             	add    $0x4,%esp
   163c9:	89 c2                	mov    %eax,%edx
   163cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   163ce:	88 10                	mov    %dl,(%eax)
   163d0:	8b 45 10             	mov    0x10(%ebp),%eax
   163d3:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   163d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   163d9:	2b 45 ec             	sub    -0x14(%ebp),%eax
   163dc:	c1 f8 0e             	sar    $0xe,%eax
   163df:	83 e8 80             	sub    $0xffffff80,%eax
   163e2:	50                   	push   %eax
   163e3:	e8 9c e8 ff ff       	call   14c84 <_Clip>
   163e8:	83 c4 04             	add    $0x4,%esp
   163eb:	89 c2                	mov    %eax,%edx
   163ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   163f0:	88 10                	mov    %dl,(%eax)
   163f2:	8b 45 10             	mov    0x10(%ebp),%eax
   163f5:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   163f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   163fb:	2b 45 f4             	sub    -0xc(%ebp),%eax
   163fe:	c1 f8 0e             	sar    $0xe,%eax
   16401:	83 e8 80             	sub    $0xffffff80,%eax
   16404:	50                   	push   %eax
   16405:	e8 7a e8 ff ff       	call   14c84 <_Clip>
   1640a:	83 c4 04             	add    $0x4,%esp
   1640d:	89 c2                	mov    %eax,%edx
   1640f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16412:	88 10                	mov    %dl,(%eax)
   16414:	8b 45 10             	mov    0x10(%ebp),%eax
   16417:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   1641a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1641d:	2b 45 f8             	sub    -0x8(%ebp),%eax
   16420:	c1 f8 0e             	sar    $0xe,%eax
   16423:	83 e8 80             	sub    $0xffffff80,%eax
   16426:	50                   	push   %eax
   16427:	e8 58 e8 ff ff       	call   14c84 <_Clip>
   1642c:	83 c4 04             	add    $0x4,%esp
   1642f:	89 c2                	mov    %eax,%edx
   16431:	8b 45 0c             	mov    0xc(%ebp),%eax
   16434:	88 10                	mov    %dl,(%eax)
}
   16436:	c9                   	leave  
   16437:	c3                   	ret    

00016438 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   16438:	55                   	push   %ebp
   16439:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   1643b:	8b 45 08             	mov    0x8(%ebp),%eax
   1643e:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   16444:	25 f8 00 00 00       	and    $0xf8,%eax
   16449:	89 c2                	mov    %eax,%edx
   1644b:	8b 45 08             	mov    0x8(%ebp),%eax
   1644e:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   16454:	90                   	nop
   16455:	5d                   	pop    %ebp
   16456:	c3                   	ret    

00016457 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   16457:	55                   	push   %ebp
   16458:	89 e5                	mov    %esp,%ebp
   1645a:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1645d:	83 ec 0c             	sub    $0xc,%esp
   16460:	ff 75 08             	pushl  0x8(%ebp)
   16463:	e8 8d e8 ff ff       	call   14cf5 <_DecodeLength>
   16468:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   1646b:	8b 45 08             	mov    0x8(%ebp),%eax
   1646e:	8b 40 0c             	mov    0xc(%eax),%eax
   16471:	83 ec 08             	sub    $0x8,%esp
   16474:	50                   	push   %eax
   16475:	ff 75 08             	pushl  0x8(%ebp)
   16478:	e8 2c e8 ff ff       	call   14ca9 <_Skip>
   1647d:	83 c4 10             	add    $0x10,%esp
}
   16480:	90                   	nop
   16481:	c9                   	leave  
   16482:	c3                   	ret    

00016483 <_Convert>:

void _Convert(Context* ctx){
   16483:	55                   	push   %ebp
   16484:	89 e5                	mov    %esp,%ebp
   16486:	57                   	push   %edi
   16487:	56                   	push   %esi
   16488:	53                   	push   %ebx
   16489:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1648c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   16493:	8b 45 08             	mov    0x8(%ebp),%eax
   16496:	83 c0 2c             	add    $0x2c,%eax
   16499:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1649c:	e9 b2 00 00 00       	jmp    16553 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   164a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   164a4:	8b 50 0c             	mov    0xc(%eax),%edx
   164a7:	8b 45 08             	mov    0x8(%ebp),%eax
   164aa:	8b 40 10             	mov    0x10(%eax),%eax
   164ad:	39 c2                	cmp    %eax,%edx
   164af:	7d 11                	jge    164c2 <_Convert+0x3f>
   164b1:	83 ec 08             	sub    $0x8,%esp
   164b4:	ff 75 e0             	pushl  -0x20(%ebp)
   164b7:	ff 75 08             	pushl  0x8(%ebp)
   164ba:	e8 79 02 00 00       	call   16738 <_UpsampleH>
   164bf:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   164c2:	8b 45 08             	mov    0x8(%ebp),%eax
   164c5:	8b 00                	mov    (%eax),%eax
   164c7:	85 c0                	test   %eax,%eax
   164c9:	0f 85 5d 02 00 00    	jne    1672c <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   164cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
   164d2:	8b 50 10             	mov    0x10(%eax),%edx
   164d5:	8b 45 08             	mov    0x8(%ebp),%eax
   164d8:	8b 40 14             	mov    0x14(%eax),%eax
   164db:	39 c2                	cmp    %eax,%edx
   164dd:	7d 11                	jge    164f0 <_Convert+0x6d>
   164df:	83 ec 08             	sub    $0x8,%esp
   164e2:	ff 75 e0             	pushl  -0x20(%ebp)
   164e5:	ff 75 08             	pushl  0x8(%ebp)
   164e8:	e8 db 05 00 00       	call   16ac8 <_UpsampleV>
   164ed:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   164f0:	8b 45 08             	mov    0x8(%ebp),%eax
   164f3:	8b 00                	mov    (%eax),%eax
   164f5:	85 c0                	test   %eax,%eax
   164f7:	0f 85 32 02 00 00    	jne    1672f <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   164fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16500:	8b 50 0c             	mov    0xc(%eax),%edx
   16503:	8b 45 08             	mov    0x8(%ebp),%eax
   16506:	8b 40 10             	mov    0x10(%eax),%eax
   16509:	39 c2                	cmp    %eax,%edx
   1650b:	7c 94                	jl     164a1 <_Convert+0x1e>
   1650d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16510:	8b 50 10             	mov    0x10(%eax),%edx
   16513:	8b 45 08             	mov    0x8(%ebp),%eax
   16516:	8b 40 14             	mov    0x14(%eax),%eax
   16519:	39 c2                	cmp    %eax,%edx
   1651b:	7c 84                	jl     164a1 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   1651d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16520:	8b 50 0c             	mov    0xc(%eax),%edx
   16523:	8b 45 08             	mov    0x8(%ebp),%eax
   16526:	8b 40 10             	mov    0x10(%eax),%eax
   16529:	39 c2                	cmp    %eax,%edx
   1652b:	7c 10                	jl     1653d <_Convert+0xba>
   1652d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16530:	8b 50 10             	mov    0x10(%eax),%edx
   16533:	8b 45 08             	mov    0x8(%ebp),%eax
   16536:	8b 40 14             	mov    0x14(%eax),%eax
   16539:	39 c2                	cmp    %eax,%edx
   1653b:	7d 0e                	jge    1654b <_Convert+0xc8>
   1653d:	8b 45 08             	mov    0x8(%ebp),%eax
   16540:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   16546:	e9 e5 01 00 00       	jmp    16730 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1654b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1654f:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   16553:	8b 45 08             	mov    0x8(%ebp),%eax
   16556:	8b 40 28             	mov    0x28(%eax),%eax
   16559:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1655c:	7f 9f                	jg     164fd <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   1655e:	8b 45 08             	mov    0x8(%ebp),%eax
   16561:	8b 40 28             	mov    0x28(%eax),%eax
   16564:	83 f8 03             	cmp    $0x3,%eax
   16567:	0f 85 3d 01 00 00    	jne    166aa <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   1656d:	8b 45 08             	mov    0x8(%ebp),%eax
   16570:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   16576:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   16579:	8b 45 08             	mov    0x8(%ebp),%eax
   1657c:	8b 40 54             	mov    0x54(%eax),%eax
   1657f:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   16582:	8b 45 08             	mov    0x8(%ebp),%eax
   16585:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1658b:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   1658e:	8b 45 08             	mov    0x8(%ebp),%eax
   16591:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   16597:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   1659a:	8b 45 08             	mov    0x8(%ebp),%eax
   1659d:	8b 40 14             	mov    0x14(%eax),%eax
   165a0:	89 45 d8             	mov    %eax,-0x28(%ebp)
   165a3:	e9 f3 00 00 00       	jmp    1669b <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   165a8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   165af:	e9 b6 00 00 00       	jmp    1666a <_Convert+0x1e7>
                register int y = py[x] << 8;
   165b4:	8b 55 dc             	mov    -0x24(%ebp),%edx
   165b7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   165ba:	01 d0                	add    %edx,%eax
   165bc:	0f b6 00             	movzbl (%eax),%eax
   165bf:	0f b6 c0             	movzbl %al,%eax
   165c2:	c1 e0 08             	shl    $0x8,%eax
   165c5:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   165c7:	8b 55 dc             	mov    -0x24(%ebp),%edx
   165ca:	8b 45 cc             	mov    -0x34(%ebp),%eax
   165cd:	01 d0                	add    %edx,%eax
   165cf:	0f b6 00             	movzbl (%eax),%eax
   165d2:	0f b6 c0             	movzbl %al,%eax
   165d5:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   165d8:	8b 55 dc             	mov    -0x24(%ebp),%edx
   165db:	8b 45 c8             	mov    -0x38(%ebp),%eax
   165de:	01 d0                	add    %edx,%eax
   165e0:	0f b6 00             	movzbl (%eax),%eax
   165e3:	0f b6 c0             	movzbl %al,%eax
   165e6:	83 c0 80             	add    $0xffffff80,%eax
   165e9:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   165eb:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   165ee:	8d 46 01             	lea    0x1(%esi),%eax
   165f1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   165f4:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   165f7:	89 c8                	mov    %ecx,%eax
   165f9:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   165ff:	01 d8                	add    %ebx,%eax
   16601:	83 e8 80             	sub    $0xffffff80,%eax
   16604:	c1 f8 08             	sar    $0x8,%eax
   16607:	83 ec 0c             	sub    $0xc,%esp
   1660a:	50                   	push   %eax
   1660b:	e8 74 e6 ff ff       	call   14c84 <_Clip>
   16610:	83 c4 10             	add    $0x10,%esp
   16613:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   16615:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   16618:	8d 46 01             	lea    0x1(%esi),%eax
   1661b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1661e:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   16621:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   16624:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   1662b:	01 d0                	add    %edx,%eax
   1662d:	83 e8 80             	sub    $0xffffff80,%eax
   16630:	c1 f8 08             	sar    $0x8,%eax
   16633:	83 ec 0c             	sub    $0xc,%esp
   16636:	50                   	push   %eax
   16637:	e8 48 e6 ff ff       	call   14c84 <_Clip>
   1663c:	83 c4 10             	add    $0x10,%esp
   1663f:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   16641:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   16644:	8d 46 01             	lea    0x1(%esi),%eax
   16647:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1664a:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   16650:	01 d8                	add    %ebx,%eax
   16652:	83 e8 80             	sub    $0xffffff80,%eax
   16655:	c1 f8 08             	sar    $0x8,%eax
   16658:	83 ec 0c             	sub    $0xc,%esp
   1665b:	50                   	push   %eax
   1665c:	e8 23 e6 ff ff       	call   14c84 <_Clip>
   16661:	83 c4 10             	add    $0x10,%esp
   16664:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   16666:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1666a:	8b 45 08             	mov    0x8(%ebp),%eax
   1666d:	8b 40 10             	mov    0x10(%eax),%eax
   16670:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   16673:	0f 8f 3b ff ff ff    	jg     165b4 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   16679:	8b 45 08             	mov    0x8(%ebp),%eax
   1667c:	8b 40 40             	mov    0x40(%eax),%eax
   1667f:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   16682:	8b 45 08             	mov    0x8(%ebp),%eax
   16685:	8b 40 6c             	mov    0x6c(%eax),%eax
   16688:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   1668b:	8b 45 08             	mov    0x8(%ebp),%eax
   1668e:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   16694:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   16697:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   1669b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1669f:	0f 85 03 ff ff ff    	jne    165a8 <_Convert+0x125>
   166a5:	e9 86 00 00 00       	jmp    16730 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   166aa:	8b 45 08             	mov    0x8(%ebp),%eax
   166ad:	8b 50 38             	mov    0x38(%eax),%edx
   166b0:	8b 45 08             	mov    0x8(%ebp),%eax
   166b3:	8b 40 40             	mov    0x40(%eax),%eax
   166b6:	39 c2                	cmp    %eax,%edx
   166b8:	74 76                	je     16730 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   166ba:	8b 45 08             	mov    0x8(%ebp),%eax
   166bd:	8b 50 54             	mov    0x54(%eax),%edx
   166c0:	8b 45 08             	mov    0x8(%ebp),%eax
   166c3:	8b 40 40             	mov    0x40(%eax),%eax
   166c6:	01 d0                	add    %edx,%eax
   166c8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   166cb:	8b 45 08             	mov    0x8(%ebp),%eax
   166ce:	8b 50 54             	mov    0x54(%eax),%edx
   166d1:	8b 45 08             	mov    0x8(%ebp),%eax
   166d4:	8b 40 38             	mov    0x38(%eax),%eax
   166d7:	01 d0                	add    %edx,%eax
   166d9:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   166dc:	8b 45 08             	mov    0x8(%ebp),%eax
   166df:	8b 40 3c             	mov    0x3c(%eax),%eax
   166e2:	83 e8 01             	sub    $0x1,%eax
   166e5:	89 45 bc             	mov    %eax,-0x44(%ebp)
   166e8:	eb 2e                	jmp    16718 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   166ea:	8b 45 08             	mov    0x8(%ebp),%eax
   166ed:	8b 40 38             	mov    0x38(%eax),%eax
   166f0:	83 ec 04             	sub    $0x4,%esp
   166f3:	50                   	push   %eax
   166f4:	ff 75 c4             	pushl  -0x3c(%ebp)
   166f7:	ff 75 c0             	pushl  -0x40(%ebp)
   166fa:	e8 72 ac fe ff       	call   1371 <memmove>
   166ff:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   16702:	8b 45 08             	mov    0x8(%ebp),%eax
   16705:	8b 40 40             	mov    0x40(%eax),%eax
   16708:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   1670b:	8b 45 08             	mov    0x8(%ebp),%eax
   1670e:	8b 40 38             	mov    0x38(%eax),%eax
   16711:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   16714:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   16718:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   1671c:	75 cc                	jne    166ea <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   1671e:	8b 45 08             	mov    0x8(%ebp),%eax
   16721:	8b 50 38             	mov    0x38(%eax),%edx
   16724:	8b 45 08             	mov    0x8(%ebp),%eax
   16727:	89 50 40             	mov    %edx,0x40(%eax)
   1672a:	eb 04                	jmp    16730 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   1672c:	90                   	nop
   1672d:	eb 01                	jmp    16730 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   1672f:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   16730:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16733:	5b                   	pop    %ebx
   16734:	5e                   	pop    %esi
   16735:	5f                   	pop    %edi
   16736:	5d                   	pop    %ebp
   16737:	c3                   	ret    

00016738 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   16738:	55                   	push   %ebp
   16739:	89 e5                	mov    %esp,%ebp
   1673b:	53                   	push   %ebx
   1673c:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   1673f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16742:	8b 40 0c             	mov    0xc(%eax),%eax
   16745:	83 e8 03             	sub    $0x3,%eax
   16748:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   1674b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1674e:	8b 50 0c             	mov    0xc(%eax),%edx
   16751:	8b 45 0c             	mov    0xc(%ebp),%eax
   16754:	8b 40 10             	mov    0x10(%eax),%eax
   16757:	0f af c2             	imul   %edx,%eax
   1675a:	01 c0                	add    %eax,%eax
   1675c:	83 ec 0c             	sub    $0xc,%esp
   1675f:	50                   	push   %eax
   16760:	e8 cb b0 fe ff       	call   1830 <malloc>
   16765:	83 c4 10             	add    $0x10,%esp
   16768:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1676b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1676f:	75 0e                	jne    1677f <_UpsampleH+0x47>
   16771:	8b 45 08             	mov    0x8(%ebp),%eax
   16774:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1677a:	e9 44 03 00 00       	jmp    16ac3 <_UpsampleH+0x38b>
    lin = c->pixels;
   1677f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16782:	8b 40 28             	mov    0x28(%eax),%eax
   16785:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   16788:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1678b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   1678e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16791:	8b 40 10             	mov    0x10(%eax),%eax
   16794:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   16797:	e9 e0 02 00 00       	jmp    16a7c <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   1679c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1679f:	0f b6 00             	movzbl (%eax),%eax
   167a2:	0f b6 c0             	movzbl %al,%eax
   167a5:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   167ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   167ae:	83 c0 01             	add    $0x1,%eax
   167b1:	0f b6 00             	movzbl (%eax),%eax
   167b4:	0f b6 c0             	movzbl %al,%eax
   167b7:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   167ba:	01 d0                	add    %edx,%eax
   167bc:	83 ec 0c             	sub    $0xc,%esp
   167bf:	50                   	push   %eax
   167c0:	e8 c4 06 00 00       	call   16e89 <CF>
   167c5:	83 c4 10             	add    $0x10,%esp
   167c8:	89 c2                	mov    %eax,%edx
   167ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   167cd:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   167cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   167d2:	8d 58 01             	lea    0x1(%eax),%ebx
   167d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   167d8:	0f b6 00             	movzbl (%eax),%eax
   167db:	0f b6 c0             	movzbl %al,%eax
   167de:	6b c8 68             	imul   $0x68,%eax,%ecx
   167e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   167e4:	83 c0 01             	add    $0x1,%eax
   167e7:	0f b6 00             	movzbl (%eax),%eax
   167ea:	0f b6 d0             	movzbl %al,%edx
   167ed:	89 d0                	mov    %edx,%eax
   167ef:	01 c0                	add    %eax,%eax
   167f1:	01 d0                	add    %edx,%eax
   167f3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   167fa:	01 d0                	add    %edx,%eax
   167fc:	01 c1                	add    %eax,%ecx
   167fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16801:	83 c0 02             	add    $0x2,%eax
   16804:	0f b6 00             	movzbl (%eax),%eax
   16807:	0f b6 d0             	movzbl %al,%edx
   1680a:	89 d0                	mov    %edx,%eax
   1680c:	01 c0                	add    %eax,%eax
   1680e:	01 d0                	add    %edx,%eax
   16810:	f7 d8                	neg    %eax
   16812:	01 c8                	add    %ecx,%eax
   16814:	83 ec 0c             	sub    $0xc,%esp
   16817:	50                   	push   %eax
   16818:	e8 6c 06 00 00       	call   16e89 <CF>
   1681d:	83 c4 10             	add    $0x10,%esp
   16820:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   16822:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16825:	8d 58 02             	lea    0x2(%eax),%ebx
   16828:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1682b:	0f b6 00             	movzbl (%eax),%eax
   1682e:	0f b6 c0             	movzbl %al,%eax
   16831:	c1 e0 02             	shl    $0x2,%eax
   16834:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1683b:	29 c2                	sub    %eax,%edx
   1683d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16840:	83 c0 01             	add    $0x1,%eax
   16843:	0f b6 00             	movzbl (%eax),%eax
   16846:	0f b6 c0             	movzbl %al,%eax
   16849:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1684c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1684f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16852:	83 c0 02             	add    $0x2,%eax
   16855:	0f b6 00             	movzbl (%eax),%eax
   16858:	0f b6 d0             	movzbl %al,%edx
   1685b:	89 d0                	mov    %edx,%eax
   1685d:	c1 e0 03             	shl    $0x3,%eax
   16860:	01 d0                	add    %edx,%eax
   16862:	f7 d8                	neg    %eax
   16864:	01 c8                	add    %ecx,%eax
   16866:	83 ec 0c             	sub    $0xc,%esp
   16869:	50                   	push   %eax
   1686a:	e8 1a 06 00 00       	call   16e89 <CF>
   1686f:	83 c4 10             	add    $0x10,%esp
   16872:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   16874:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1687b:	e9 fa 00 00 00       	jmp    1697a <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   16880:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16883:	01 c0                	add    %eax,%eax
   16885:	8d 50 03             	lea    0x3(%eax),%edx
   16888:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1688b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1688e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16891:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16894:	01 d0                	add    %edx,%eax
   16896:	0f b6 00             	movzbl (%eax),%eax
   16899:	0f b6 d0             	movzbl %al,%edx
   1689c:	89 d0                	mov    %edx,%eax
   1689e:	c1 e0 03             	shl    $0x3,%eax
   168a1:	01 d0                	add    %edx,%eax
   168a3:	f7 d8                	neg    %eax
   168a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   168a8:	8d 4a 01             	lea    0x1(%edx),%ecx
   168ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
   168ae:	01 ca                	add    %ecx,%edx
   168b0:	0f b6 12             	movzbl (%edx),%edx
   168b3:	0f b6 d2             	movzbl %dl,%edx
   168b6:	6b d2 6f             	imul   $0x6f,%edx,%edx
   168b9:	01 c2                	add    %eax,%edx
   168bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   168be:	8d 48 02             	lea    0x2(%eax),%ecx
   168c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   168c4:	01 c8                	add    %ecx,%eax
   168c6:	0f b6 00             	movzbl (%eax),%eax
   168c9:	0f b6 c0             	movzbl %al,%eax
   168cc:	6b c0 1d             	imul   $0x1d,%eax,%eax
   168cf:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   168d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   168d5:	8d 50 03             	lea    0x3(%eax),%edx
   168d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   168db:	01 d0                	add    %edx,%eax
   168dd:	0f b6 00             	movzbl (%eax),%eax
   168e0:	0f b6 d0             	movzbl %al,%edx
   168e3:	89 d0                	mov    %edx,%eax
   168e5:	01 c0                	add    %eax,%eax
   168e7:	01 d0                	add    %edx,%eax
   168e9:	f7 d8                	neg    %eax
   168eb:	01 c8                	add    %ecx,%eax
   168ed:	83 ec 0c             	sub    $0xc,%esp
   168f0:	50                   	push   %eax
   168f1:	e8 93 05 00 00       	call   16e89 <CF>
   168f6:	83 c4 10             	add    $0x10,%esp
   168f9:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   168fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   168fe:	01 c0                	add    %eax,%eax
   16900:	8d 50 04             	lea    0x4(%eax),%edx
   16903:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16906:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   16909:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1690c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1690f:	01 d0                	add    %edx,%eax
   16911:	0f b6 00             	movzbl (%eax),%eax
   16914:	0f b6 d0             	movzbl %al,%edx
   16917:	89 d0                	mov    %edx,%eax
   16919:	01 c0                	add    %eax,%eax
   1691b:	01 d0                	add    %edx,%eax
   1691d:	f7 d8                	neg    %eax
   1691f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16922:	8d 4a 01             	lea    0x1(%edx),%ecx
   16925:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16928:	01 ca                	add    %ecx,%edx
   1692a:	0f b6 12             	movzbl (%edx),%edx
   1692d:	0f b6 d2             	movzbl %dl,%edx
   16930:	6b d2 1d             	imul   $0x1d,%edx,%edx
   16933:	01 c2                	add    %eax,%edx
   16935:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16938:	8d 48 02             	lea    0x2(%eax),%ecx
   1693b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1693e:	01 c8                	add    %ecx,%eax
   16940:	0f b6 00             	movzbl (%eax),%eax
   16943:	0f b6 c0             	movzbl %al,%eax
   16946:	6b c0 6f             	imul   $0x6f,%eax,%eax
   16949:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1694c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1694f:	8d 50 03             	lea    0x3(%eax),%edx
   16952:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16955:	01 d0                	add    %edx,%eax
   16957:	0f b6 00             	movzbl (%eax),%eax
   1695a:	0f b6 d0             	movzbl %al,%edx
   1695d:	89 d0                	mov    %edx,%eax
   1695f:	c1 e0 03             	shl    $0x3,%eax
   16962:	01 d0                	add    %edx,%eax
   16964:	f7 d8                	neg    %eax
   16966:	01 c8                	add    %ecx,%eax
   16968:	83 ec 0c             	sub    $0xc,%esp
   1696b:	50                   	push   %eax
   1696c:	e8 18 05 00 00       	call   16e89 <CF>
   16971:	83 c4 10             	add    $0x10,%esp
   16974:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   16976:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1697a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1697d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16980:	0f 8c fa fe ff ff    	jl     16880 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   16986:	8b 45 0c             	mov    0xc(%ebp),%eax
   16989:	8b 40 14             	mov    0x14(%eax),%eax
   1698c:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   1698f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16992:	8b 40 0c             	mov    0xc(%eax),%eax
   16995:	01 c0                	add    %eax,%eax
   16997:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   1699a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1699d:	8d 58 fd             	lea    -0x3(%eax),%ebx
   169a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   169a3:	83 e8 01             	sub    $0x1,%eax
   169a6:	0f b6 00             	movzbl (%eax),%eax
   169a9:	0f b6 c0             	movzbl %al,%eax
   169ac:	c1 e0 02             	shl    $0x2,%eax
   169af:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   169b6:	29 c2                	sub    %eax,%edx
   169b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   169bb:	83 e8 02             	sub    $0x2,%eax
   169be:	0f b6 00             	movzbl (%eax),%eax
   169c1:	0f b6 c0             	movzbl %al,%eax
   169c4:	6b c0 6d             	imul   $0x6d,%eax,%eax
   169c7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   169ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   169cd:	83 e8 03             	sub    $0x3,%eax
   169d0:	0f b6 00             	movzbl (%eax),%eax
   169d3:	0f b6 d0             	movzbl %al,%edx
   169d6:	89 d0                	mov    %edx,%eax
   169d8:	c1 e0 03             	shl    $0x3,%eax
   169db:	01 d0                	add    %edx,%eax
   169dd:	f7 d8                	neg    %eax
   169df:	01 c8                	add    %ecx,%eax
   169e1:	83 ec 0c             	sub    $0xc,%esp
   169e4:	50                   	push   %eax
   169e5:	e8 9f 04 00 00       	call   16e89 <CF>
   169ea:	83 c4 10             	add    $0x10,%esp
   169ed:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   169ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   169f2:	8d 58 fe             	lea    -0x2(%eax),%ebx
   169f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   169f8:	83 e8 01             	sub    $0x1,%eax
   169fb:	0f b6 00             	movzbl (%eax),%eax
   169fe:	0f b6 c0             	movzbl %al,%eax
   16a01:	6b c8 68             	imul   $0x68,%eax,%ecx
   16a04:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16a07:	83 e8 02             	sub    $0x2,%eax
   16a0a:	0f b6 00             	movzbl (%eax),%eax
   16a0d:	0f b6 d0             	movzbl %al,%edx
   16a10:	89 d0                	mov    %edx,%eax
   16a12:	01 c0                	add    %eax,%eax
   16a14:	01 d0                	add    %edx,%eax
   16a16:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16a1d:	01 d0                	add    %edx,%eax
   16a1f:	01 c1                	add    %eax,%ecx
   16a21:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16a24:	83 e8 03             	sub    $0x3,%eax
   16a27:	0f b6 00             	movzbl (%eax),%eax
   16a2a:	0f b6 d0             	movzbl %al,%edx
   16a2d:	89 d0                	mov    %edx,%eax
   16a2f:	01 c0                	add    %eax,%eax
   16a31:	01 d0                	add    %edx,%eax
   16a33:	f7 d8                	neg    %eax
   16a35:	01 c8                	add    %ecx,%eax
   16a37:	83 ec 0c             	sub    $0xc,%esp
   16a3a:	50                   	push   %eax
   16a3b:	e8 49 04 00 00       	call   16e89 <CF>
   16a40:	83 c4 10             	add    $0x10,%esp
   16a43:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   16a45:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16a48:	8d 58 ff             	lea    -0x1(%eax),%ebx
   16a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16a4e:	83 e8 01             	sub    $0x1,%eax
   16a51:	0f b6 00             	movzbl (%eax),%eax
   16a54:	0f b6 c0             	movzbl %al,%eax
   16a57:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   16a5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16a60:	83 e8 02             	sub    $0x2,%eax
   16a63:	0f b6 00             	movzbl (%eax),%eax
   16a66:	0f b6 c0             	movzbl %al,%eax
   16a69:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16a6c:	01 d0                	add    %edx,%eax
   16a6e:	83 ec 0c             	sub    $0xc,%esp
   16a71:	50                   	push   %eax
   16a72:	e8 12 04 00 00       	call   16e89 <CF>
   16a77:	83 c4 10             	add    $0x10,%esp
   16a7a:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   16a7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16a7f:	8d 50 ff             	lea    -0x1(%eax),%edx
   16a82:	89 55 e8             	mov    %edx,-0x18(%ebp)
   16a85:	85 c0                	test   %eax,%eax
   16a87:	0f 85 0f fd ff ff    	jne    1679c <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   16a8d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a90:	8b 40 0c             	mov    0xc(%eax),%eax
   16a93:	8d 14 00             	lea    (%eax,%eax,1),%edx
   16a96:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a99:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   16a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a9f:	8b 50 0c             	mov    0xc(%eax),%edx
   16aa2:	8b 45 0c             	mov    0xc(%ebp),%eax
   16aa5:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16aa8:	8b 45 0c             	mov    0xc(%ebp),%eax
   16aab:	8b 40 28             	mov    0x28(%eax),%eax
   16aae:	83 ec 0c             	sub    $0xc,%esp
   16ab1:	50                   	push   %eax
   16ab2:	e8 37 ac fe ff       	call   16ee <free>
   16ab7:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16aba:	8b 45 0c             	mov    0xc(%ebp),%eax
   16abd:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16ac0:	89 50 28             	mov    %edx,0x28(%eax)
}
   16ac3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   16ac6:	c9                   	leave  
   16ac7:	c3                   	ret    

00016ac8 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   16ac8:	55                   	push   %ebp
   16ac9:	89 e5                	mov    %esp,%ebp
   16acb:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   16ace:	8b 45 0c             	mov    0xc(%ebp),%eax
   16ad1:	8b 40 0c             	mov    0xc(%eax),%eax
   16ad4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   16ad7:	8b 45 0c             	mov    0xc(%ebp),%eax
   16ada:	8b 40 14             	mov    0x14(%eax),%eax
   16add:	89 45 e0             	mov    %eax,-0x20(%ebp)
   16ae0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16ae3:	01 c0                	add    %eax,%eax
   16ae5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   16ae8:	8b 45 0c             	mov    0xc(%ebp),%eax
   16aeb:	8b 50 0c             	mov    0xc(%eax),%edx
   16aee:	8b 45 0c             	mov    0xc(%ebp),%eax
   16af1:	8b 40 10             	mov    0x10(%eax),%eax
   16af4:	0f af c2             	imul   %edx,%eax
   16af7:	01 c0                	add    %eax,%eax
   16af9:	83 ec 0c             	sub    $0xc,%esp
   16afc:	50                   	push   %eax
   16afd:	e8 2e ad fe ff       	call   1830 <malloc>
   16b02:	83 c4 10             	add    $0x10,%esp
   16b05:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   16b08:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   16b0c:	75 0e                	jne    16b1c <_UpsampleV+0x54>
   16b0e:	8b 45 08             	mov    0x8(%ebp),%eax
   16b11:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   16b17:	e9 6b 03 00 00       	jmp    16e87 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   16b1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   16b23:	e9 1d 03 00 00       	jmp    16e45 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   16b28:	8b 45 0c             	mov    0xc(%ebp),%eax
   16b2b:	8b 50 28             	mov    0x28(%eax),%edx
   16b2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16b31:	01 d0                	add    %edx,%eax
   16b33:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   16b36:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16b39:	8b 45 d8             	mov    -0x28(%ebp),%eax
   16b3c:	01 d0                	add    %edx,%eax
   16b3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   16b41:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16b44:	0f b6 00             	movzbl (%eax),%eax
   16b47:	0f b6 c0             	movzbl %al,%eax
   16b4a:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   16b50:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   16b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16b56:	01 c8                	add    %ecx,%eax
   16b58:	0f b6 00             	movzbl (%eax),%eax
   16b5b:	0f b6 c0             	movzbl %al,%eax
   16b5e:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16b61:	01 d0                	add    %edx,%eax
   16b63:	83 ec 0c             	sub    $0xc,%esp
   16b66:	50                   	push   %eax
   16b67:	e8 1d 03 00 00       	call   16e89 <CF>
   16b6c:	83 c4 10             	add    $0x10,%esp
   16b6f:	89 c2                	mov    %eax,%edx
   16b71:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16b74:	88 10                	mov    %dl,(%eax)
   16b76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16b79:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   16b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16b7f:	0f b6 00             	movzbl (%eax),%eax
   16b82:	0f b6 c0             	movzbl %al,%eax
   16b85:	6b c8 68             	imul   $0x68,%eax,%ecx
   16b88:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16b8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16b8e:	01 d0                	add    %edx,%eax
   16b90:	0f b6 00             	movzbl (%eax),%eax
   16b93:	0f b6 d0             	movzbl %al,%edx
   16b96:	89 d0                	mov    %edx,%eax
   16b98:	01 c0                	add    %eax,%eax
   16b9a:	01 d0                	add    %edx,%eax
   16b9c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16ba3:	01 d0                	add    %edx,%eax
   16ba5:	01 c1                	add    %eax,%ecx
   16ba7:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16bad:	01 d0                	add    %edx,%eax
   16baf:	0f b6 00             	movzbl (%eax),%eax
   16bb2:	0f b6 d0             	movzbl %al,%edx
   16bb5:	89 d0                	mov    %edx,%eax
   16bb7:	01 c0                	add    %eax,%eax
   16bb9:	01 d0                	add    %edx,%eax
   16bbb:	f7 d8                	neg    %eax
   16bbd:	01 c8                	add    %ecx,%eax
   16bbf:	83 ec 0c             	sub    $0xc,%esp
   16bc2:	50                   	push   %eax
   16bc3:	e8 c1 02 00 00       	call   16e89 <CF>
   16bc8:	83 c4 10             	add    $0x10,%esp
   16bcb:	89 c2                	mov    %eax,%edx
   16bcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16bd0:	88 10                	mov    %dl,(%eax)
   16bd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16bd5:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   16bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16bdb:	0f b6 00             	movzbl (%eax),%eax
   16bde:	0f b6 c0             	movzbl %al,%eax
   16be1:	c1 e0 02             	shl    $0x2,%eax
   16be4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16beb:	89 d1                	mov    %edx,%ecx
   16bed:	29 c1                	sub    %eax,%ecx
   16bef:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16bf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16bf5:	01 d0                	add    %edx,%eax
   16bf7:	0f b6 00             	movzbl (%eax),%eax
   16bfa:	0f b6 c0             	movzbl %al,%eax
   16bfd:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16c00:	01 c1                	add    %eax,%ecx
   16c02:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16c05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16c08:	01 d0                	add    %edx,%eax
   16c0a:	0f b6 00             	movzbl (%eax),%eax
   16c0d:	0f b6 d0             	movzbl %al,%edx
   16c10:	89 d0                	mov    %edx,%eax
   16c12:	c1 e0 03             	shl    $0x3,%eax
   16c15:	01 d0                	add    %edx,%eax
   16c17:	f7 d8                	neg    %eax
   16c19:	01 c8                	add    %ecx,%eax
   16c1b:	83 ec 0c             	sub    $0xc,%esp
   16c1e:	50                   	push   %eax
   16c1f:	e8 65 02 00 00       	call   16e89 <CF>
   16c24:	83 c4 10             	add    $0x10,%esp
   16c27:	89 c2                	mov    %eax,%edx
   16c29:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16c2c:	88 10                	mov    %dl,(%eax)
   16c2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16c31:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   16c34:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16c37:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   16c3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   16c3d:	8b 40 10             	mov    0x10(%eax),%eax
   16c40:	83 e8 03             	sub    $0x3,%eax
   16c43:	89 45 e8             	mov    %eax,-0x18(%ebp)
   16c46:	e9 e6 00 00 00       	jmp    16d31 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   16c4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16c4e:	f7 d8                	neg    %eax
   16c50:	89 c2                	mov    %eax,%edx
   16c52:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16c55:	01 d0                	add    %edx,%eax
   16c57:	0f b6 00             	movzbl (%eax),%eax
   16c5a:	0f b6 d0             	movzbl %al,%edx
   16c5d:	89 d0                	mov    %edx,%eax
   16c5f:	c1 e0 03             	shl    $0x3,%eax
   16c62:	01 d0                	add    %edx,%eax
   16c64:	f7 d8                	neg    %eax
   16c66:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16c69:	0f b6 12             	movzbl (%edx),%edx
   16c6c:	0f b6 d2             	movzbl %dl,%edx
   16c6f:	6b d2 6f             	imul   $0x6f,%edx,%edx
   16c72:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   16c75:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16c78:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16c7b:	01 d0                	add    %edx,%eax
   16c7d:	0f b6 00             	movzbl (%eax),%eax
   16c80:	0f b6 c0             	movzbl %al,%eax
   16c83:	6b c0 1d             	imul   $0x1d,%eax,%eax
   16c86:	01 c1                	add    %eax,%ecx
   16c88:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16c8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16c8e:	01 d0                	add    %edx,%eax
   16c90:	0f b6 00             	movzbl (%eax),%eax
   16c93:	0f b6 d0             	movzbl %al,%edx
   16c96:	89 d0                	mov    %edx,%eax
   16c98:	01 c0                	add    %eax,%eax
   16c9a:	01 d0                	add    %edx,%eax
   16c9c:	f7 d8                	neg    %eax
   16c9e:	01 c8                	add    %ecx,%eax
   16ca0:	83 ec 0c             	sub    $0xc,%esp
   16ca3:	50                   	push   %eax
   16ca4:	e8 e0 01 00 00       	call   16e89 <CF>
   16ca9:	83 c4 10             	add    $0x10,%esp
   16cac:	89 c2                	mov    %eax,%edx
   16cae:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16cb1:	88 10                	mov    %dl,(%eax)
   16cb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16cb6:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   16cb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16cbc:	f7 d8                	neg    %eax
   16cbe:	89 c2                	mov    %eax,%edx
   16cc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16cc3:	01 d0                	add    %edx,%eax
   16cc5:	0f b6 00             	movzbl (%eax),%eax
   16cc8:	0f b6 d0             	movzbl %al,%edx
   16ccb:	89 d0                	mov    %edx,%eax
   16ccd:	01 c0                	add    %eax,%eax
   16ccf:	01 d0                	add    %edx,%eax
   16cd1:	f7 d8                	neg    %eax
   16cd3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16cd6:	0f b6 12             	movzbl (%edx),%edx
   16cd9:	0f b6 d2             	movzbl %dl,%edx
   16cdc:	6b d2 1d             	imul   $0x1d,%edx,%edx
   16cdf:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   16ce2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16ce5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ce8:	01 d0                	add    %edx,%eax
   16cea:	0f b6 00             	movzbl (%eax),%eax
   16ced:	0f b6 c0             	movzbl %al,%eax
   16cf0:	6b c0 6f             	imul   $0x6f,%eax,%eax
   16cf3:	01 c1                	add    %eax,%ecx
   16cf5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16cf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16cfb:	01 d0                	add    %edx,%eax
   16cfd:	0f b6 00             	movzbl (%eax),%eax
   16d00:	0f b6 d0             	movzbl %al,%edx
   16d03:	89 d0                	mov    %edx,%eax
   16d05:	c1 e0 03             	shl    $0x3,%eax
   16d08:	01 d0                	add    %edx,%eax
   16d0a:	f7 d8                	neg    %eax
   16d0c:	01 c8                	add    %ecx,%eax
   16d0e:	83 ec 0c             	sub    $0xc,%esp
   16d11:	50                   	push   %eax
   16d12:	e8 72 01 00 00       	call   16e89 <CF>
   16d17:	83 c4 10             	add    $0x10,%esp
   16d1a:	89 c2                	mov    %eax,%edx
   16d1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16d1f:	88 10                	mov    %dl,(%eax)
   16d21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16d24:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   16d27:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16d2a:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   16d2d:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   16d31:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   16d35:	0f 85 10 ff ff ff    	jne    16c4b <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   16d3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16d3e:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   16d41:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16d44:	0f b6 00             	movzbl (%eax),%eax
   16d47:	0f b6 c0             	movzbl %al,%eax
   16d4a:	c1 e0 02             	shl    $0x2,%eax
   16d4d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16d54:	29 c2                	sub    %eax,%edx
   16d56:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16d59:	f7 d8                	neg    %eax
   16d5b:	89 c1                	mov    %eax,%ecx
   16d5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16d60:	01 c8                	add    %ecx,%eax
   16d62:	0f b6 00             	movzbl (%eax),%eax
   16d65:	0f b6 c0             	movzbl %al,%eax
   16d68:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16d6b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16d6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16d71:	f7 d8                	neg    %eax
   16d73:	89 c2                	mov    %eax,%edx
   16d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16d78:	01 d0                	add    %edx,%eax
   16d7a:	0f b6 00             	movzbl (%eax),%eax
   16d7d:	0f b6 d0             	movzbl %al,%edx
   16d80:	89 d0                	mov    %edx,%eax
   16d82:	c1 e0 03             	shl    $0x3,%eax
   16d85:	01 d0                	add    %edx,%eax
   16d87:	f7 d8                	neg    %eax
   16d89:	01 c8                	add    %ecx,%eax
   16d8b:	83 ec 0c             	sub    $0xc,%esp
   16d8e:	50                   	push   %eax
   16d8f:	e8 f5 00 00 00       	call   16e89 <CF>
   16d94:	83 c4 10             	add    $0x10,%esp
   16d97:	89 c2                	mov    %eax,%edx
   16d99:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16d9c:	88 10                	mov    %dl,(%eax)
   16d9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16da1:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   16da4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16da7:	0f b6 00             	movzbl (%eax),%eax
   16daa:	0f b6 c0             	movzbl %al,%eax
   16dad:	6b c8 68             	imul   $0x68,%eax,%ecx
   16db0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16db3:	f7 d8                	neg    %eax
   16db5:	89 c2                	mov    %eax,%edx
   16db7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16dba:	01 d0                	add    %edx,%eax
   16dbc:	0f b6 00             	movzbl (%eax),%eax
   16dbf:	0f b6 d0             	movzbl %al,%edx
   16dc2:	89 d0                	mov    %edx,%eax
   16dc4:	01 c0                	add    %eax,%eax
   16dc6:	01 d0                	add    %edx,%eax
   16dc8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16dcf:	01 d0                	add    %edx,%eax
   16dd1:	01 c1                	add    %eax,%ecx
   16dd3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16dd6:	f7 d8                	neg    %eax
   16dd8:	89 c2                	mov    %eax,%edx
   16dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ddd:	01 d0                	add    %edx,%eax
   16ddf:	0f b6 00             	movzbl (%eax),%eax
   16de2:	0f b6 d0             	movzbl %al,%edx
   16de5:	89 d0                	mov    %edx,%eax
   16de7:	01 c0                	add    %eax,%eax
   16de9:	01 d0                	add    %edx,%eax
   16deb:	f7 d8                	neg    %eax
   16ded:	01 c8                	add    %ecx,%eax
   16def:	83 ec 0c             	sub    $0xc,%esp
   16df2:	50                   	push   %eax
   16df3:	e8 91 00 00 00       	call   16e89 <CF>
   16df8:	83 c4 10             	add    $0x10,%esp
   16dfb:	89 c2                	mov    %eax,%edx
   16dfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16e00:	88 10                	mov    %dl,(%eax)
   16e02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16e05:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   16e08:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e0b:	0f b6 00             	movzbl (%eax),%eax
   16e0e:	0f b6 c0             	movzbl %al,%eax
   16e11:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   16e17:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16e1a:	f7 d8                	neg    %eax
   16e1c:	89 c1                	mov    %eax,%ecx
   16e1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e21:	01 c8                	add    %ecx,%eax
   16e23:	0f b6 00             	movzbl (%eax),%eax
   16e26:	0f b6 c0             	movzbl %al,%eax
   16e29:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16e2c:	01 d0                	add    %edx,%eax
   16e2e:	83 ec 0c             	sub    $0xc,%esp
   16e31:	50                   	push   %eax
   16e32:	e8 52 00 00 00       	call   16e89 <CF>
   16e37:	83 c4 10             	add    $0x10,%esp
   16e3a:	89 c2                	mov    %eax,%edx
   16e3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16e3f:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   16e41:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   16e45:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16e48:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16e4b:	0f 8c d7 fc ff ff    	jl     16b28 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   16e51:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e54:	8b 40 10             	mov    0x10(%eax),%eax
   16e57:	8d 14 00             	lea    (%eax,%eax,1),%edx
   16e5a:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e5d:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   16e60:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e63:	8b 50 0c             	mov    0xc(%eax),%edx
   16e66:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e69:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16e6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e6f:	8b 40 28             	mov    0x28(%eax),%eax
   16e72:	83 ec 0c             	sub    $0xc,%esp
   16e75:	50                   	push   %eax
   16e76:	e8 73 a8 fe ff       	call   16ee <free>
   16e7b:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16e7e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e81:	8b 55 d8             	mov    -0x28(%ebp),%edx
   16e84:	89 50 28             	mov    %edx,0x28(%eax)
}
   16e87:	c9                   	leave  
   16e88:	c3                   	ret    

00016e89 <CF>:

uchar CF(const int x){
   16e89:	55                   	push   %ebp
   16e8a:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   16e8c:	8b 45 08             	mov    0x8(%ebp),%eax
   16e8f:	83 c0 40             	add    $0x40,%eax
   16e92:	c1 f8 07             	sar    $0x7,%eax
   16e95:	50                   	push   %eax
   16e96:	e8 e9 dd ff ff       	call   14c84 <_Clip>
   16e9b:	83 c4 04             	add    $0x4,%esp
}
   16e9e:	c9                   	leave  
   16e9f:	c3                   	ret    
