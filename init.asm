
_init：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:

char *argv[] = { "desktop", 0 };

int
main(void)
{
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	51                   	push   %ecx
       e:	83 ec 14             	sub    $0x14,%esp
  int pid, wpid;

  if(open("console", O_RDWR) < 0){
      11:	83 ec 08             	sub    $0x8,%esp
      14:	6a 02                	push   $0x2
      16:	68 68 5e 01 00       	push   $0x15e68
      1b:	e8 78 03 00 00       	call   398 <open>
      20:	83 c4 10             	add    $0x10,%esp
      23:	85 c0                	test   %eax,%eax
      25:	79 26                	jns    4d <main+0x4d>
    mknod("console", 1, 1);
      27:	83 ec 04             	sub    $0x4,%esp
      2a:	6a 01                	push   $0x1
      2c:	6a 01                	push   $0x1
      2e:	68 68 5e 01 00       	push   $0x15e68
      33:	e8 68 03 00 00       	call   3a0 <mknod>
      38:	83 c4 10             	add    $0x10,%esp
    open("console", O_RDWR);
      3b:	83 ec 08             	sub    $0x8,%esp
      3e:	6a 02                	push   $0x2
      40:	68 68 5e 01 00       	push   $0x15e68
      45:	e8 4e 03 00 00       	call   398 <open>
      4a:	83 c4 10             	add    $0x10,%esp
  }
  dup(0);  // stdout
      4d:	83 ec 0c             	sub    $0xc,%esp
      50:	6a 00                	push   $0x0
      52:	e8 79 03 00 00       	call   3d0 <dup>
      57:	83 c4 10             	add    $0x10,%esp
  dup(0);  // stderr
      5a:	83 ec 0c             	sub    $0xc,%esp
      5d:	6a 00                	push   $0x0
      5f:	e8 6c 03 00 00       	call   3d0 <dup>
      64:	83 c4 10             	add    $0x10,%esp

  for(;;){
    printf(1, "init: starting sh\n");
      67:	83 ec 08             	sub    $0x8,%esp
      6a:	68 70 5e 01 00       	push   $0x15e70
      6f:	6a 01                	push   $0x1
      71:	e8 89 04 00 00       	call   4ff <printf>
      76:	83 c4 10             	add    $0x10,%esp
    pid = fork();
      79:	e8 d2 02 00 00       	call   350 <fork>
      7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(pid < 0){
      81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
      85:	79 17                	jns    9e <main+0x9e>
      printf(1, "init: fork failed\n");
      87:	83 ec 08             	sub    $0x8,%esp
      8a:	68 83 5e 01 00       	push   $0x15e83
      8f:	6a 01                	push   $0x1
      91:	e8 69 04 00 00       	call   4ff <printf>
      96:	83 c4 10             	add    $0x10,%esp
      exit();
      99:	e8 ba 02 00 00       	call   358 <exit>
    }
    if(pid == 0){
      9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
      a2:	75 3e                	jne    e2 <main+0xe2>
      exec("desktop", argv);
      a4:	83 ec 08             	sub    $0x8,%esp
      a7:	68 c0 e1 01 00       	push   $0x1e1c0
      ac:	68 60 5e 01 00       	push   $0x15e60
      b1:	e8 da 02 00 00       	call   390 <exec>
      b6:	83 c4 10             	add    $0x10,%esp
      printf(1, "init: exec desktop failed\n");
      b9:	83 ec 08             	sub    $0x8,%esp
      bc:	68 96 5e 01 00       	push   $0x15e96
      c1:	6a 01                	push   $0x1
      c3:	e8 37 04 00 00       	call   4ff <printf>
      c8:	83 c4 10             	add    $0x10,%esp
      exit();
      cb:	e8 88 02 00 00       	call   358 <exit>
    }
    while((wpid=wait()) >= 0 && wpid != pid)
      printf(1, "zombie!\n");
      d0:	83 ec 08             	sub    $0x8,%esp
      d3:	68 b1 5e 01 00       	push   $0x15eb1
      d8:	6a 01                	push   $0x1
      da:	e8 20 04 00 00       	call   4ff <printf>
      df:	83 c4 10             	add    $0x10,%esp
    if(pid == 0){
      exec("desktop", argv);
      printf(1, "init: exec desktop failed\n");
      exit();
    }
    while((wpid=wait()) >= 0 && wpid != pid)
      e2:	e8 79 02 00 00       	call   360 <wait>
      e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
      ee:	0f 88 73 ff ff ff    	js     67 <main+0x67>
      f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
      f7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
      fa:	75 d4                	jne    d0 <main+0xd0>
      printf(1, "zombie!\n");
  }
      fc:	e9 66 ff ff ff       	jmp    67 <main+0x67>

00000101 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     101:	55                   	push   %ebp
     102:	89 e5                	mov    %esp,%ebp
     104:	57                   	push   %edi
     105:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     106:	8b 4d 08             	mov    0x8(%ebp),%ecx
     109:	8b 55 10             	mov    0x10(%ebp),%edx
     10c:	8b 45 0c             	mov    0xc(%ebp),%eax
     10f:	89 cb                	mov    %ecx,%ebx
     111:	89 df                	mov    %ebx,%edi
     113:	89 d1                	mov    %edx,%ecx
     115:	fc                   	cld    
     116:	f3 aa                	rep stos %al,%es:(%edi)
     118:	89 ca                	mov    %ecx,%edx
     11a:	89 fb                	mov    %edi,%ebx
     11c:	89 5d 08             	mov    %ebx,0x8(%ebp)
     11f:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     122:	90                   	nop
     123:	5b                   	pop    %ebx
     124:	5f                   	pop    %edi
     125:	5d                   	pop    %ebp
     126:	c3                   	ret    

00000127 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     127:	55                   	push   %ebp
     128:	89 e5                	mov    %esp,%ebp
     12a:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     12d:	8b 45 08             	mov    0x8(%ebp),%eax
     130:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     133:	90                   	nop
     134:	8b 45 08             	mov    0x8(%ebp),%eax
     137:	8d 50 01             	lea    0x1(%eax),%edx
     13a:	89 55 08             	mov    %edx,0x8(%ebp)
     13d:	8b 55 0c             	mov    0xc(%ebp),%edx
     140:	8d 4a 01             	lea    0x1(%edx),%ecx
     143:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     146:	0f b6 12             	movzbl (%edx),%edx
     149:	88 10                	mov    %dl,(%eax)
     14b:	0f b6 00             	movzbl (%eax),%eax
     14e:	84 c0                	test   %al,%al
     150:	75 e2                	jne    134 <strcpy+0xd>
    ;
  return os;
     152:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     155:	c9                   	leave  
     156:	c3                   	ret    

00000157 <strcmp>:

int
strcmp(const char *p, const char *q)
{
     157:	55                   	push   %ebp
     158:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     15a:	eb 08                	jmp    164 <strcmp+0xd>
    p++, q++;
     15c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     160:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     164:	8b 45 08             	mov    0x8(%ebp),%eax
     167:	0f b6 00             	movzbl (%eax),%eax
     16a:	84 c0                	test   %al,%al
     16c:	74 10                	je     17e <strcmp+0x27>
     16e:	8b 45 08             	mov    0x8(%ebp),%eax
     171:	0f b6 10             	movzbl (%eax),%edx
     174:	8b 45 0c             	mov    0xc(%ebp),%eax
     177:	0f b6 00             	movzbl (%eax),%eax
     17a:	38 c2                	cmp    %al,%dl
     17c:	74 de                	je     15c <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     17e:	8b 45 08             	mov    0x8(%ebp),%eax
     181:	0f b6 00             	movzbl (%eax),%eax
     184:	0f b6 d0             	movzbl %al,%edx
     187:	8b 45 0c             	mov    0xc(%ebp),%eax
     18a:	0f b6 00             	movzbl (%eax),%eax
     18d:	0f b6 c0             	movzbl %al,%eax
     190:	29 c2                	sub    %eax,%edx
     192:	89 d0                	mov    %edx,%eax
}
     194:	5d                   	pop    %ebp
     195:	c3                   	ret    

00000196 <strlen>:

uint
strlen(char *s)
{
     196:	55                   	push   %ebp
     197:	89 e5                	mov    %esp,%ebp
     199:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     19c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     1a3:	eb 04                	jmp    1a9 <strlen+0x13>
     1a5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     1a9:	8b 55 fc             	mov    -0x4(%ebp),%edx
     1ac:	8b 45 08             	mov    0x8(%ebp),%eax
     1af:	01 d0                	add    %edx,%eax
     1b1:	0f b6 00             	movzbl (%eax),%eax
     1b4:	84 c0                	test   %al,%al
     1b6:	75 ed                	jne    1a5 <strlen+0xf>
    ;
  return n;
     1b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     1bb:	c9                   	leave  
     1bc:	c3                   	ret    

000001bd <memset>:

void*
memset(void *dst, int c, uint n)
{
     1bd:	55                   	push   %ebp
     1be:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     1c0:	8b 45 10             	mov    0x10(%ebp),%eax
     1c3:	50                   	push   %eax
     1c4:	ff 75 0c             	pushl  0xc(%ebp)
     1c7:	ff 75 08             	pushl  0x8(%ebp)
     1ca:	e8 32 ff ff ff       	call   101 <stosb>
     1cf:	83 c4 0c             	add    $0xc,%esp
  return dst;
     1d2:	8b 45 08             	mov    0x8(%ebp),%eax
}
     1d5:	c9                   	leave  
     1d6:	c3                   	ret    

000001d7 <strchr>:

char*
strchr(const char *s, char c)
{
     1d7:	55                   	push   %ebp
     1d8:	89 e5                	mov    %esp,%ebp
     1da:	83 ec 04             	sub    $0x4,%esp
     1dd:	8b 45 0c             	mov    0xc(%ebp),%eax
     1e0:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     1e3:	eb 14                	jmp    1f9 <strchr+0x22>
    if(*s == c)
     1e5:	8b 45 08             	mov    0x8(%ebp),%eax
     1e8:	0f b6 00             	movzbl (%eax),%eax
     1eb:	3a 45 fc             	cmp    -0x4(%ebp),%al
     1ee:	75 05                	jne    1f5 <strchr+0x1e>
      return (char*)s;
     1f0:	8b 45 08             	mov    0x8(%ebp),%eax
     1f3:	eb 13                	jmp    208 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     1f5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     1f9:	8b 45 08             	mov    0x8(%ebp),%eax
     1fc:	0f b6 00             	movzbl (%eax),%eax
     1ff:	84 c0                	test   %al,%al
     201:	75 e2                	jne    1e5 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     203:	b8 00 00 00 00       	mov    $0x0,%eax
}
     208:	c9                   	leave  
     209:	c3                   	ret    

0000020a <gets>:

char*
gets(char *buf, int max)
{
     20a:	55                   	push   %ebp
     20b:	89 e5                	mov    %esp,%ebp
     20d:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     210:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     217:	eb 42                	jmp    25b <gets+0x51>
    cc = read(0, &c, 1);
     219:	83 ec 04             	sub    $0x4,%esp
     21c:	6a 01                	push   $0x1
     21e:	8d 45 ef             	lea    -0x11(%ebp),%eax
     221:	50                   	push   %eax
     222:	6a 00                	push   $0x0
     224:	e8 47 01 00 00       	call   370 <read>
     229:	83 c4 10             	add    $0x10,%esp
     22c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     22f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     233:	7e 33                	jle    268 <gets+0x5e>
      break;
    buf[i++] = c;
     235:	8b 45 f4             	mov    -0xc(%ebp),%eax
     238:	8d 50 01             	lea    0x1(%eax),%edx
     23b:	89 55 f4             	mov    %edx,-0xc(%ebp)
     23e:	89 c2                	mov    %eax,%edx
     240:	8b 45 08             	mov    0x8(%ebp),%eax
     243:	01 c2                	add    %eax,%edx
     245:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     249:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     24b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     24f:	3c 0a                	cmp    $0xa,%al
     251:	74 16                	je     269 <gets+0x5f>
     253:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     257:	3c 0d                	cmp    $0xd,%al
     259:	74 0e                	je     269 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     25b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     25e:	83 c0 01             	add    $0x1,%eax
     261:	3b 45 0c             	cmp    0xc(%ebp),%eax
     264:	7c b3                	jl     219 <gets+0xf>
     266:	eb 01                	jmp    269 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     268:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     269:	8b 55 f4             	mov    -0xc(%ebp),%edx
     26c:	8b 45 08             	mov    0x8(%ebp),%eax
     26f:	01 d0                	add    %edx,%eax
     271:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     274:	8b 45 08             	mov    0x8(%ebp),%eax
}
     277:	c9                   	leave  
     278:	c3                   	ret    

00000279 <stat>:

int
stat(char *n, struct stat *st)
{
     279:	55                   	push   %ebp
     27a:	89 e5                	mov    %esp,%ebp
     27c:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     27f:	83 ec 08             	sub    $0x8,%esp
     282:	6a 00                	push   $0x0
     284:	ff 75 08             	pushl  0x8(%ebp)
     287:	e8 0c 01 00 00       	call   398 <open>
     28c:	83 c4 10             	add    $0x10,%esp
     28f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     292:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     296:	79 07                	jns    29f <stat+0x26>
    return -1;
     298:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     29d:	eb 25                	jmp    2c4 <stat+0x4b>
  r = fstat(fd, st);
     29f:	83 ec 08             	sub    $0x8,%esp
     2a2:	ff 75 0c             	pushl  0xc(%ebp)
     2a5:	ff 75 f4             	pushl  -0xc(%ebp)
     2a8:	e8 03 01 00 00       	call   3b0 <fstat>
     2ad:	83 c4 10             	add    $0x10,%esp
     2b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     2b3:	83 ec 0c             	sub    $0xc,%esp
     2b6:	ff 75 f4             	pushl  -0xc(%ebp)
     2b9:	e8 c2 00 00 00       	call   380 <close>
     2be:	83 c4 10             	add    $0x10,%esp
  return r;
     2c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     2c4:	c9                   	leave  
     2c5:	c3                   	ret    

000002c6 <atoi>:

int
atoi(const char *s)
{
     2c6:	55                   	push   %ebp
     2c7:	89 e5                	mov    %esp,%ebp
     2c9:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     2cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     2d3:	eb 25                	jmp    2fa <atoi+0x34>
    n = n*10 + *s++ - '0';
     2d5:	8b 55 fc             	mov    -0x4(%ebp),%edx
     2d8:	89 d0                	mov    %edx,%eax
     2da:	c1 e0 02             	shl    $0x2,%eax
     2dd:	01 d0                	add    %edx,%eax
     2df:	01 c0                	add    %eax,%eax
     2e1:	89 c1                	mov    %eax,%ecx
     2e3:	8b 45 08             	mov    0x8(%ebp),%eax
     2e6:	8d 50 01             	lea    0x1(%eax),%edx
     2e9:	89 55 08             	mov    %edx,0x8(%ebp)
     2ec:	0f b6 00             	movzbl (%eax),%eax
     2ef:	0f be c0             	movsbl %al,%eax
     2f2:	01 c8                	add    %ecx,%eax
     2f4:	83 e8 30             	sub    $0x30,%eax
     2f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     2fa:	8b 45 08             	mov    0x8(%ebp),%eax
     2fd:	0f b6 00             	movzbl (%eax),%eax
     300:	3c 2f                	cmp    $0x2f,%al
     302:	7e 0a                	jle    30e <atoi+0x48>
     304:	8b 45 08             	mov    0x8(%ebp),%eax
     307:	0f b6 00             	movzbl (%eax),%eax
     30a:	3c 39                	cmp    $0x39,%al
     30c:	7e c7                	jle    2d5 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     30e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     311:	c9                   	leave  
     312:	c3                   	ret    

00000313 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     313:	55                   	push   %ebp
     314:	89 e5                	mov    %esp,%ebp
     316:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     319:	8b 45 08             	mov    0x8(%ebp),%eax
     31c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     31f:	8b 45 0c             	mov    0xc(%ebp),%eax
     322:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     325:	eb 17                	jmp    33e <memmove+0x2b>
    *dst++ = *src++;
     327:	8b 45 fc             	mov    -0x4(%ebp),%eax
     32a:	8d 50 01             	lea    0x1(%eax),%edx
     32d:	89 55 fc             	mov    %edx,-0x4(%ebp)
     330:	8b 55 f8             	mov    -0x8(%ebp),%edx
     333:	8d 4a 01             	lea    0x1(%edx),%ecx
     336:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     339:	0f b6 12             	movzbl (%edx),%edx
     33c:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     33e:	8b 45 10             	mov    0x10(%ebp),%eax
     341:	8d 50 ff             	lea    -0x1(%eax),%edx
     344:	89 55 10             	mov    %edx,0x10(%ebp)
     347:	85 c0                	test   %eax,%eax
     349:	7f dc                	jg     327 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     34b:	8b 45 08             	mov    0x8(%ebp),%eax
}
     34e:	c9                   	leave  
     34f:	c3                   	ret    

00000350 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     350:	b8 01 00 00 00       	mov    $0x1,%eax
     355:	cd 40                	int    $0x40
     357:	c3                   	ret    

00000358 <exit>:
SYSCALL(exit)
     358:	b8 02 00 00 00       	mov    $0x2,%eax
     35d:	cd 40                	int    $0x40
     35f:	c3                   	ret    

00000360 <wait>:
SYSCALL(wait)
     360:	b8 03 00 00 00       	mov    $0x3,%eax
     365:	cd 40                	int    $0x40
     367:	c3                   	ret    

00000368 <pipe>:
SYSCALL(pipe)
     368:	b8 04 00 00 00       	mov    $0x4,%eax
     36d:	cd 40                	int    $0x40
     36f:	c3                   	ret    

00000370 <read>:
SYSCALL(read)
     370:	b8 05 00 00 00       	mov    $0x5,%eax
     375:	cd 40                	int    $0x40
     377:	c3                   	ret    

00000378 <write>:
SYSCALL(write)
     378:	b8 10 00 00 00       	mov    $0x10,%eax
     37d:	cd 40                	int    $0x40
     37f:	c3                   	ret    

00000380 <close>:
SYSCALL(close)
     380:	b8 15 00 00 00       	mov    $0x15,%eax
     385:	cd 40                	int    $0x40
     387:	c3                   	ret    

00000388 <kill>:
SYSCALL(kill)
     388:	b8 06 00 00 00       	mov    $0x6,%eax
     38d:	cd 40                	int    $0x40
     38f:	c3                   	ret    

00000390 <exec>:
SYSCALL(exec)
     390:	b8 07 00 00 00       	mov    $0x7,%eax
     395:	cd 40                	int    $0x40
     397:	c3                   	ret    

00000398 <open>:
SYSCALL(open)
     398:	b8 0f 00 00 00       	mov    $0xf,%eax
     39d:	cd 40                	int    $0x40
     39f:	c3                   	ret    

000003a0 <mknod>:
SYSCALL(mknod)
     3a0:	b8 11 00 00 00       	mov    $0x11,%eax
     3a5:	cd 40                	int    $0x40
     3a7:	c3                   	ret    

000003a8 <unlink>:
SYSCALL(unlink)
     3a8:	b8 12 00 00 00       	mov    $0x12,%eax
     3ad:	cd 40                	int    $0x40
     3af:	c3                   	ret    

000003b0 <fstat>:
SYSCALL(fstat)
     3b0:	b8 08 00 00 00       	mov    $0x8,%eax
     3b5:	cd 40                	int    $0x40
     3b7:	c3                   	ret    

000003b8 <link>:
SYSCALL(link)
     3b8:	b8 13 00 00 00       	mov    $0x13,%eax
     3bd:	cd 40                	int    $0x40
     3bf:	c3                   	ret    

000003c0 <mkdir>:
SYSCALL(mkdir)
     3c0:	b8 14 00 00 00       	mov    $0x14,%eax
     3c5:	cd 40                	int    $0x40
     3c7:	c3                   	ret    

000003c8 <chdir>:
SYSCALL(chdir)
     3c8:	b8 09 00 00 00       	mov    $0x9,%eax
     3cd:	cd 40                	int    $0x40
     3cf:	c3                   	ret    

000003d0 <dup>:
SYSCALL(dup)
     3d0:	b8 0a 00 00 00       	mov    $0xa,%eax
     3d5:	cd 40                	int    $0x40
     3d7:	c3                   	ret    

000003d8 <getpid>:
SYSCALL(getpid)
     3d8:	b8 0b 00 00 00       	mov    $0xb,%eax
     3dd:	cd 40                	int    $0x40
     3df:	c3                   	ret    

000003e0 <sbrk>:
SYSCALL(sbrk)
     3e0:	b8 0c 00 00 00       	mov    $0xc,%eax
     3e5:	cd 40                	int    $0x40
     3e7:	c3                   	ret    

000003e8 <sleep>:
SYSCALL(sleep)
     3e8:	b8 0d 00 00 00       	mov    $0xd,%eax
     3ed:	cd 40                	int    $0x40
     3ef:	c3                   	ret    

000003f0 <uptime>:
SYSCALL(uptime)
     3f0:	b8 0e 00 00 00       	mov    $0xe,%eax
     3f5:	cd 40                	int    $0x40
     3f7:	c3                   	ret    

000003f8 <createwindow>:
SYSCALL(createwindow)
     3f8:	b8 16 00 00 00       	mov    $0x16,%eax
     3fd:	cd 40                	int    $0x40
     3ff:	c3                   	ret    

00000400 <repaintwindow>:
SYSCALL(repaintwindow)
     400:	b8 17 00 00 00       	mov    $0x17,%eax
     405:	cd 40                	int    $0x40
     407:	c3                   	ret    

00000408 <getmessage>:
SYSCALL(getmessage)
     408:	b8 18 00 00 00       	mov    $0x18,%eax
     40d:	cd 40                	int    $0x40
     40f:	c3                   	ret    

00000410 <settimer>:
SYSCALL(settimer)
     410:	b8 19 00 00 00       	mov    $0x19,%eax
     415:	cd 40                	int    $0x40
     417:	c3                   	ret    

00000418 <updatewindow>:
SYSCALL(updatewindow)
     418:	b8 1a 00 00 00       	mov    $0x1a,%eax
     41d:	cd 40                	int    $0x40
     41f:	c3                   	ret    

00000420 <destroywindow>:
SYSCALL(destroywindow)
     420:	b8 1b 00 00 00       	mov    $0x1b,%eax
     425:	cd 40                	int    $0x40
     427:	c3                   	ret    

00000428 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     428:	55                   	push   %ebp
     429:	89 e5                	mov    %esp,%ebp
     42b:	83 ec 18             	sub    $0x18,%esp
     42e:	8b 45 0c             	mov    0xc(%ebp),%eax
     431:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     434:	83 ec 04             	sub    $0x4,%esp
     437:	6a 01                	push   $0x1
     439:	8d 45 f4             	lea    -0xc(%ebp),%eax
     43c:	50                   	push   %eax
     43d:	ff 75 08             	pushl  0x8(%ebp)
     440:	e8 33 ff ff ff       	call   378 <write>
     445:	83 c4 10             	add    $0x10,%esp
}
     448:	90                   	nop
     449:	c9                   	leave  
     44a:	c3                   	ret    

0000044b <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     44b:	55                   	push   %ebp
     44c:	89 e5                	mov    %esp,%ebp
     44e:	53                   	push   %ebx
     44f:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     452:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     459:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     45d:	74 17                	je     476 <printint+0x2b>
     45f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     463:	79 11                	jns    476 <printint+0x2b>
    neg = 1;
     465:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     46c:	8b 45 0c             	mov    0xc(%ebp),%eax
     46f:	f7 d8                	neg    %eax
     471:	89 45 ec             	mov    %eax,-0x14(%ebp)
     474:	eb 06                	jmp    47c <printint+0x31>
  } else {
    x = xx;
     476:	8b 45 0c             	mov    0xc(%ebp),%eax
     479:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     47c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     483:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     486:	8d 41 01             	lea    0x1(%ecx),%eax
     489:	89 45 f4             	mov    %eax,-0xc(%ebp)
     48c:	8b 5d 10             	mov    0x10(%ebp),%ebx
     48f:	8b 45 ec             	mov    -0x14(%ebp),%eax
     492:	ba 00 00 00 00       	mov    $0x0,%edx
     497:	f7 f3                	div    %ebx
     499:	89 d0                	mov    %edx,%eax
     49b:	0f b6 80 c8 e1 01 00 	movzbl 0x1e1c8(%eax),%eax
     4a2:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     4a6:	8b 5d 10             	mov    0x10(%ebp),%ebx
     4a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
     4ac:	ba 00 00 00 00       	mov    $0x0,%edx
     4b1:	f7 f3                	div    %ebx
     4b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
     4b6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     4ba:	75 c7                	jne    483 <printint+0x38>
  if(neg)
     4bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     4c0:	74 2d                	je     4ef <printint+0xa4>
    buf[i++] = '-';
     4c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4c5:	8d 50 01             	lea    0x1(%eax),%edx
     4c8:	89 55 f4             	mov    %edx,-0xc(%ebp)
     4cb:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     4d0:	eb 1d                	jmp    4ef <printint+0xa4>
    putc(fd, buf[i]);
     4d2:	8d 55 dc             	lea    -0x24(%ebp),%edx
     4d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4d8:	01 d0                	add    %edx,%eax
     4da:	0f b6 00             	movzbl (%eax),%eax
     4dd:	0f be c0             	movsbl %al,%eax
     4e0:	83 ec 08             	sub    $0x8,%esp
     4e3:	50                   	push   %eax
     4e4:	ff 75 08             	pushl  0x8(%ebp)
     4e7:	e8 3c ff ff ff       	call   428 <putc>
     4ec:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     4ef:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     4f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     4f7:	79 d9                	jns    4d2 <printint+0x87>
    putc(fd, buf[i]);
}
     4f9:	90                   	nop
     4fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     4fd:	c9                   	leave  
     4fe:	c3                   	ret    

000004ff <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     4ff:	55                   	push   %ebp
     500:	89 e5                	mov    %esp,%ebp
     502:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     505:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     50c:	8d 45 0c             	lea    0xc(%ebp),%eax
     50f:	83 c0 04             	add    $0x4,%eax
     512:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     515:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     51c:	e9 59 01 00 00       	jmp    67a <printf+0x17b>
    c = fmt[i] & 0xff;
     521:	8b 55 0c             	mov    0xc(%ebp),%edx
     524:	8b 45 f0             	mov    -0x10(%ebp),%eax
     527:	01 d0                	add    %edx,%eax
     529:	0f b6 00             	movzbl (%eax),%eax
     52c:	0f be c0             	movsbl %al,%eax
     52f:	25 ff 00 00 00       	and    $0xff,%eax
     534:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     537:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     53b:	75 2c                	jne    569 <printf+0x6a>
      if(c == '%'){
     53d:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     541:	75 0c                	jne    54f <printf+0x50>
        state = '%';
     543:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     54a:	e9 27 01 00 00       	jmp    676 <printf+0x177>
      } else {
        putc(fd, c);
     54f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     552:	0f be c0             	movsbl %al,%eax
     555:	83 ec 08             	sub    $0x8,%esp
     558:	50                   	push   %eax
     559:	ff 75 08             	pushl  0x8(%ebp)
     55c:	e8 c7 fe ff ff       	call   428 <putc>
     561:	83 c4 10             	add    $0x10,%esp
     564:	e9 0d 01 00 00       	jmp    676 <printf+0x177>
      }
    } else if(state == '%'){
     569:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     56d:	0f 85 03 01 00 00    	jne    676 <printf+0x177>
      if(c == 'd'){
     573:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     577:	75 1e                	jne    597 <printf+0x98>
        printint(fd, *ap, 10, 1);
     579:	8b 45 e8             	mov    -0x18(%ebp),%eax
     57c:	8b 00                	mov    (%eax),%eax
     57e:	6a 01                	push   $0x1
     580:	6a 0a                	push   $0xa
     582:	50                   	push   %eax
     583:	ff 75 08             	pushl  0x8(%ebp)
     586:	e8 c0 fe ff ff       	call   44b <printint>
     58b:	83 c4 10             	add    $0x10,%esp
        ap++;
     58e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     592:	e9 d8 00 00 00       	jmp    66f <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     597:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     59b:	74 06                	je     5a3 <printf+0xa4>
     59d:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     5a1:	75 1e                	jne    5c1 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     5a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
     5a6:	8b 00                	mov    (%eax),%eax
     5a8:	6a 00                	push   $0x0
     5aa:	6a 10                	push   $0x10
     5ac:	50                   	push   %eax
     5ad:	ff 75 08             	pushl  0x8(%ebp)
     5b0:	e8 96 fe ff ff       	call   44b <printint>
     5b5:	83 c4 10             	add    $0x10,%esp
        ap++;
     5b8:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     5bc:	e9 ae 00 00 00       	jmp    66f <printf+0x170>
      } else if(c == 's'){
     5c1:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     5c5:	75 43                	jne    60a <printf+0x10b>
        s = (char*)*ap;
     5c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
     5ca:	8b 00                	mov    (%eax),%eax
     5cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     5cf:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     5d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     5d7:	75 25                	jne    5fe <printf+0xff>
          s = "(null)";
     5d9:	c7 45 f4 ba 5e 01 00 	movl   $0x15eba,-0xc(%ebp)
        while(*s != 0){
     5e0:	eb 1c                	jmp    5fe <printf+0xff>
          putc(fd, *s);
     5e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
     5e5:	0f b6 00             	movzbl (%eax),%eax
     5e8:	0f be c0             	movsbl %al,%eax
     5eb:	83 ec 08             	sub    $0x8,%esp
     5ee:	50                   	push   %eax
     5ef:	ff 75 08             	pushl  0x8(%ebp)
     5f2:	e8 31 fe ff ff       	call   428 <putc>
     5f7:	83 c4 10             	add    $0x10,%esp
          s++;
     5fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     5fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
     601:	0f b6 00             	movzbl (%eax),%eax
     604:	84 c0                	test   %al,%al
     606:	75 da                	jne    5e2 <printf+0xe3>
     608:	eb 65                	jmp    66f <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     60a:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     60e:	75 1d                	jne    62d <printf+0x12e>
        putc(fd, *ap);
     610:	8b 45 e8             	mov    -0x18(%ebp),%eax
     613:	8b 00                	mov    (%eax),%eax
     615:	0f be c0             	movsbl %al,%eax
     618:	83 ec 08             	sub    $0x8,%esp
     61b:	50                   	push   %eax
     61c:	ff 75 08             	pushl  0x8(%ebp)
     61f:	e8 04 fe ff ff       	call   428 <putc>
     624:	83 c4 10             	add    $0x10,%esp
        ap++;
     627:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     62b:	eb 42                	jmp    66f <printf+0x170>
      } else if(c == '%'){
     62d:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     631:	75 17                	jne    64a <printf+0x14b>
        putc(fd, c);
     633:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     636:	0f be c0             	movsbl %al,%eax
     639:	83 ec 08             	sub    $0x8,%esp
     63c:	50                   	push   %eax
     63d:	ff 75 08             	pushl  0x8(%ebp)
     640:	e8 e3 fd ff ff       	call   428 <putc>
     645:	83 c4 10             	add    $0x10,%esp
     648:	eb 25                	jmp    66f <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     64a:	83 ec 08             	sub    $0x8,%esp
     64d:	6a 25                	push   $0x25
     64f:	ff 75 08             	pushl  0x8(%ebp)
     652:	e8 d1 fd ff ff       	call   428 <putc>
     657:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     65a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     65d:	0f be c0             	movsbl %al,%eax
     660:	83 ec 08             	sub    $0x8,%esp
     663:	50                   	push   %eax
     664:	ff 75 08             	pushl  0x8(%ebp)
     667:	e8 bc fd ff ff       	call   428 <putc>
     66c:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     66f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     676:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     67a:	8b 55 0c             	mov    0xc(%ebp),%edx
     67d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     680:	01 d0                	add    %edx,%eax
     682:	0f b6 00             	movzbl (%eax),%eax
     685:	84 c0                	test   %al,%al
     687:	0f 85 94 fe ff ff    	jne    521 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     68d:	90                   	nop
     68e:	c9                   	leave  
     68f:	c3                   	ret    

00000690 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     690:	55                   	push   %ebp
     691:	89 e5                	mov    %esp,%ebp
     693:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     696:	8b 45 08             	mov    0x8(%ebp),%eax
     699:	83 e8 08             	sub    $0x8,%eax
     69c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     69f:	a1 08 e6 01 00       	mov    0x1e608,%eax
     6a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
     6a7:	eb 24                	jmp    6cd <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     6a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6ac:	8b 00                	mov    (%eax),%eax
     6ae:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     6b1:	77 12                	ja     6c5 <free+0x35>
     6b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6b6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     6b9:	77 24                	ja     6df <free+0x4f>
     6bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6be:	8b 00                	mov    (%eax),%eax
     6c0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6c3:	77 1a                	ja     6df <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     6c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6c8:	8b 00                	mov    (%eax),%eax
     6ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
     6cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6d0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     6d3:	76 d4                	jbe    6a9 <free+0x19>
     6d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6d8:	8b 00                	mov    (%eax),%eax
     6da:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6dd:	76 ca                	jbe    6a9 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     6df:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6e2:	8b 40 04             	mov    0x4(%eax),%eax
     6e5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     6ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6ef:	01 c2                	add    %eax,%edx
     6f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6f4:	8b 00                	mov    (%eax),%eax
     6f6:	39 c2                	cmp    %eax,%edx
     6f8:	75 24                	jne    71e <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     6fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6fd:	8b 50 04             	mov    0x4(%eax),%edx
     700:	8b 45 fc             	mov    -0x4(%ebp),%eax
     703:	8b 00                	mov    (%eax),%eax
     705:	8b 40 04             	mov    0x4(%eax),%eax
     708:	01 c2                	add    %eax,%edx
     70a:	8b 45 f8             	mov    -0x8(%ebp),%eax
     70d:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     710:	8b 45 fc             	mov    -0x4(%ebp),%eax
     713:	8b 00                	mov    (%eax),%eax
     715:	8b 10                	mov    (%eax),%edx
     717:	8b 45 f8             	mov    -0x8(%ebp),%eax
     71a:	89 10                	mov    %edx,(%eax)
     71c:	eb 0a                	jmp    728 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     71e:	8b 45 fc             	mov    -0x4(%ebp),%eax
     721:	8b 10                	mov    (%eax),%edx
     723:	8b 45 f8             	mov    -0x8(%ebp),%eax
     726:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     728:	8b 45 fc             	mov    -0x4(%ebp),%eax
     72b:	8b 40 04             	mov    0x4(%eax),%eax
     72e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     735:	8b 45 fc             	mov    -0x4(%ebp),%eax
     738:	01 d0                	add    %edx,%eax
     73a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     73d:	75 20                	jne    75f <free+0xcf>
    p->s.size += bp->s.size;
     73f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     742:	8b 50 04             	mov    0x4(%eax),%edx
     745:	8b 45 f8             	mov    -0x8(%ebp),%eax
     748:	8b 40 04             	mov    0x4(%eax),%eax
     74b:	01 c2                	add    %eax,%edx
     74d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     750:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     753:	8b 45 f8             	mov    -0x8(%ebp),%eax
     756:	8b 10                	mov    (%eax),%edx
     758:	8b 45 fc             	mov    -0x4(%ebp),%eax
     75b:	89 10                	mov    %edx,(%eax)
     75d:	eb 08                	jmp    767 <free+0xd7>
  } else
    p->s.ptr = bp;
     75f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     762:	8b 55 f8             	mov    -0x8(%ebp),%edx
     765:	89 10                	mov    %edx,(%eax)
  freep = p;
     767:	8b 45 fc             	mov    -0x4(%ebp),%eax
     76a:	a3 08 e6 01 00       	mov    %eax,0x1e608
}
     76f:	90                   	nop
     770:	c9                   	leave  
     771:	c3                   	ret    

00000772 <morecore>:

static Header*
morecore(uint nu)
{
     772:	55                   	push   %ebp
     773:	89 e5                	mov    %esp,%ebp
     775:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     778:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     77f:	77 07                	ja     788 <morecore+0x16>
    nu = 4096;
     781:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     788:	8b 45 08             	mov    0x8(%ebp),%eax
     78b:	c1 e0 03             	shl    $0x3,%eax
     78e:	83 ec 0c             	sub    $0xc,%esp
     791:	50                   	push   %eax
     792:	e8 49 fc ff ff       	call   3e0 <sbrk>
     797:	83 c4 10             	add    $0x10,%esp
     79a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     79d:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     7a1:	75 07                	jne    7aa <morecore+0x38>
    return 0;
     7a3:	b8 00 00 00 00       	mov    $0x0,%eax
     7a8:	eb 26                	jmp    7d0 <morecore+0x5e>
  hp = (Header*)p;
     7aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     7b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7b3:	8b 55 08             	mov    0x8(%ebp),%edx
     7b6:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     7b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7bc:	83 c0 08             	add    $0x8,%eax
     7bf:	83 ec 0c             	sub    $0xc,%esp
     7c2:	50                   	push   %eax
     7c3:	e8 c8 fe ff ff       	call   690 <free>
     7c8:	83 c4 10             	add    $0x10,%esp
  return freep;
     7cb:	a1 08 e6 01 00       	mov    0x1e608,%eax
}
     7d0:	c9                   	leave  
     7d1:	c3                   	ret    

000007d2 <malloc>:

void*
malloc(uint nbytes)
{
     7d2:	55                   	push   %ebp
     7d3:	89 e5                	mov    %esp,%ebp
     7d5:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     7d8:	8b 45 08             	mov    0x8(%ebp),%eax
     7db:	83 c0 07             	add    $0x7,%eax
     7de:	c1 e8 03             	shr    $0x3,%eax
     7e1:	83 c0 01             	add    $0x1,%eax
     7e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     7e7:	a1 08 e6 01 00       	mov    0x1e608,%eax
     7ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
     7ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     7f3:	75 23                	jne    818 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     7f5:	c7 45 f0 00 e6 01 00 	movl   $0x1e600,-0x10(%ebp)
     7fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7ff:	a3 08 e6 01 00       	mov    %eax,0x1e608
     804:	a1 08 e6 01 00       	mov    0x1e608,%eax
     809:	a3 00 e6 01 00       	mov    %eax,0x1e600
    base.s.size = 0;
     80e:	c7 05 04 e6 01 00 00 	movl   $0x0,0x1e604
     815:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     818:	8b 45 f0             	mov    -0x10(%ebp),%eax
     81b:	8b 00                	mov    (%eax),%eax
     81d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     820:	8b 45 f4             	mov    -0xc(%ebp),%eax
     823:	8b 40 04             	mov    0x4(%eax),%eax
     826:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     829:	72 4d                	jb     878 <malloc+0xa6>
      if(p->s.size == nunits)
     82b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     82e:	8b 40 04             	mov    0x4(%eax),%eax
     831:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     834:	75 0c                	jne    842 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     836:	8b 45 f4             	mov    -0xc(%ebp),%eax
     839:	8b 10                	mov    (%eax),%edx
     83b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     83e:	89 10                	mov    %edx,(%eax)
     840:	eb 26                	jmp    868 <malloc+0x96>
      else {
        p->s.size -= nunits;
     842:	8b 45 f4             	mov    -0xc(%ebp),%eax
     845:	8b 40 04             	mov    0x4(%eax),%eax
     848:	2b 45 ec             	sub    -0x14(%ebp),%eax
     84b:	89 c2                	mov    %eax,%edx
     84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     850:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     853:	8b 45 f4             	mov    -0xc(%ebp),%eax
     856:	8b 40 04             	mov    0x4(%eax),%eax
     859:	c1 e0 03             	shl    $0x3,%eax
     85c:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     85f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     862:	8b 55 ec             	mov    -0x14(%ebp),%edx
     865:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     868:	8b 45 f0             	mov    -0x10(%ebp),%eax
     86b:	a3 08 e6 01 00       	mov    %eax,0x1e608
      return (void*)(p + 1);
     870:	8b 45 f4             	mov    -0xc(%ebp),%eax
     873:	83 c0 08             	add    $0x8,%eax
     876:	eb 3b                	jmp    8b3 <malloc+0xe1>
    }
    if(p == freep)
     878:	a1 08 e6 01 00       	mov    0x1e608,%eax
     87d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     880:	75 1e                	jne    8a0 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     882:	83 ec 0c             	sub    $0xc,%esp
     885:	ff 75 ec             	pushl  -0x14(%ebp)
     888:	e8 e5 fe ff ff       	call   772 <morecore>
     88d:	83 c4 10             	add    $0x10,%esp
     890:	89 45 f4             	mov    %eax,-0xc(%ebp)
     893:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     897:	75 07                	jne    8a0 <malloc+0xce>
        return 0;
     899:	b8 00 00 00 00       	mov    $0x0,%eax
     89e:	eb 13                	jmp    8b3 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     8a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
     8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8a9:	8b 00                	mov    (%eax),%eax
     8ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     8ae:	e9 6d ff ff ff       	jmp    820 <malloc+0x4e>
}
     8b3:	c9                   	leave  
     8b4:	c3                   	ret    

000008b5 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     8b5:	55                   	push   %ebp
     8b6:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     8b8:	a1 0c e6 01 00       	mov    0x1e60c,%eax
     8bd:	83 c0 01             	add    $0x1,%eax
     8c0:	a3 0c e6 01 00       	mov    %eax,0x1e60c
    g_seed = (214013*g_seed+2531011);
     8c5:	a1 0c e6 01 00       	mov    0x1e60c,%eax
     8ca:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     8d0:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     8d5:	a3 0c e6 01 00       	mov    %eax,0x1e60c
    return (g_seed>>16)&0x7FFF;
     8da:	a1 0c e6 01 00       	mov    0x1e60c,%eax
     8df:	c1 e8 10             	shr    $0x10,%eax
     8e2:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     8e7:	5d                   	pop    %ebp
     8e8:	c3                   	ret    

000008e9 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     8e9:	55                   	push   %ebp
     8ea:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     8ec:	d9 45 08             	flds   0x8(%ebp)
     8ef:	d9 ee                	fldz   
     8f1:	d9 c9                	fxch   %st(1)
     8f3:	df e9                	fucomip %st(1),%st
     8f5:	dd d8                	fstp   %st(0)
     8f7:	76 05                	jbe    8fe <abs+0x15>
     8f9:	d9 45 08             	flds   0x8(%ebp)
     8fc:	eb 05                	jmp    903 <abs+0x1a>
	return -x;
     8fe:	d9 45 08             	flds   0x8(%ebp)
     901:	d9 e0                	fchs   
}
     903:	5d                   	pop    %ebp
     904:	c3                   	ret    

00000905 <pow>:

float pow(float a, int b)
{
     905:	55                   	push   %ebp
     906:	89 e5                	mov    %esp,%ebp
     908:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     90b:	d9 45 08             	flds   0x8(%ebp)
     90e:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     911:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     915:	7e 17                	jle    92e <pow+0x29>
		while (--b)
     917:	eb 09                	jmp    922 <pow+0x1d>
			r *= a;
     919:	d9 45 fc             	flds   -0x4(%ebp)
     91c:	d8 4d 08             	fmuls  0x8(%ebp)
     91f:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     922:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     926:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     92a:	75 ed                	jne    919 <pow+0x14>
     92c:	eb 2a                	jmp    958 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     92e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     932:	79 1f                	jns    953 <pow+0x4e>
		while (++b)
     934:	eb 09                	jmp    93f <pow+0x3a>
			r *= a;
     936:	d9 45 fc             	flds   -0x4(%ebp)
     939:	d8 4d 08             	fmuls  0x8(%ebp)
     93c:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     93f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     943:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     947:	75 ed                	jne    936 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     949:	d9 e8                	fld1   
     94b:	d8 75 fc             	fdivs  -0x4(%ebp)
     94e:	d9 5d fc             	fstps  -0x4(%ebp)
     951:	eb 05                	jmp    958 <pow+0x53>
	}
	else r = 0;
     953:	d9 ee                	fldz   
     955:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     958:	d9 45 fc             	flds   -0x4(%ebp)
}
     95b:	c9                   	leave  
     95c:	c3                   	ret    

0000095d <sqrt>:

float sqrt(float number) {
     95d:	55                   	push   %ebp
     95e:	89 e5                	mov    %esp,%ebp
     960:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     963:	d9 ee                	fldz   
     965:	d9 45 08             	flds   0x8(%ebp)
     968:	d9 c9                	fxch   %st(1)
     96a:	df e9                	fucomip %st(1),%st
     96c:	dd d8                	fstp   %st(0)
     96e:	76 06                	jbe    976 <sqrt+0x19>
		return -1;
     970:	d9 e8                	fld1   
     972:	d9 e0                	fchs   
     974:	eb 3a                	jmp    9b0 <sqrt+0x53>
	}

	new_guess = 1;
     976:	d9 e8                	fld1   
     978:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     97b:	d9 45 fc             	flds   -0x4(%ebp)
     97e:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     981:	d9 45 08             	flds   0x8(%ebp)
     984:	d8 75 f8             	fdivs  -0x8(%ebp)
     987:	d8 45 f8             	fadds  -0x8(%ebp)
     98a:	d9 05 c8 5e 01 00    	flds   0x15ec8
     990:	de f9                	fdivrp %st,%st(1)
     992:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     995:	d9 45 fc             	flds   -0x4(%ebp)
     998:	d9 45 f8             	flds   -0x8(%ebp)
     99b:	df e9                	fucomip %st(1),%st
     99d:	dd d8                	fstp   %st(0)
     99f:	7a da                	jp     97b <sqrt+0x1e>
     9a1:	d9 45 fc             	flds   -0x4(%ebp)
     9a4:	d9 45 f8             	flds   -0x8(%ebp)
     9a7:	df e9                	fucomip %st(1),%st
     9a9:	dd d8                	fstp   %st(0)
     9ab:	75 ce                	jne    97b <sqrt+0x1e>

	return new_guess;
     9ad:	d9 45 fc             	flds   -0x4(%ebp)
}
     9b0:	c9                   	leave  
     9b1:	c3                   	ret    

000009b2 <cos>:

float cos(float x)
{
     9b2:	55                   	push   %ebp
     9b3:	89 e5                	mov    %esp,%ebp
     9b5:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     9b8:	d9 e8                	fld1   
     9ba:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     9bd:	d9 45 08             	flds   0x8(%ebp)
     9c0:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     9c6:	d9 c9                	fxch   %st(1)
     9c8:	df e9                	fucomip %st(1),%st
     9ca:	dd d8                	fstp   %st(0)
     9cc:	77 0f                	ja     9dd <cos+0x2b>
     9ce:	d9 45 08             	flds   0x8(%ebp)
     9d1:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     9d7:	df e9                	fucomip %st(1),%st
     9d9:	dd d8                	fstp   %st(0)
     9db:	76 3c                	jbe    a19 <cos+0x67>
     9dd:	d9 45 08             	flds   0x8(%ebp)
     9e0:	d9 45 08             	flds   0x8(%ebp)
     9e3:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     9e9:	de f9                	fdivrp %st,%st(1)
     9eb:	d9 7d e2             	fnstcw -0x1e(%ebp)
     9ee:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     9f2:	b4 0c                	mov    $0xc,%ah
     9f4:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     9f8:	d9 6d e0             	fldcw  -0x20(%ebp)
     9fb:	db 5d dc             	fistpl -0x24(%ebp)
     9fe:	d9 6d e2             	fldcw  -0x1e(%ebp)
     a01:	8b 45 dc             	mov    -0x24(%ebp),%eax
     a04:	01 c0                	add    %eax,%eax
     a06:	89 45 d8             	mov    %eax,-0x28(%ebp)
     a09:	db 45 d8             	fildl  -0x28(%ebp)
     a0c:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     a12:	de c9                	fmulp  %st,%st(1)
     a14:	de e9                	fsubrp %st,%st(1)
     a16:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     a19:	d9 45 08             	flds   0x8(%ebp)
     a1c:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     a22:	d9 c9                	fxch   %st(1)
     a24:	df e9                	fucomip %st(1),%st
     a26:	dd d8                	fstp   %st(0)
     a28:	76 0e                	jbe    a38 <cos+0x86>
     a2a:	d9 45 08             	flds   0x8(%ebp)
     a2d:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     a33:	de e9                	fsubrp %st,%st(1)
     a35:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     a38:	d9 45 08             	flds   0x8(%ebp)
     a3b:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     a41:	df e9                	fucomip %st(1),%st
     a43:	dd d8                	fstp   %st(0)
     a45:	76 0e                	jbe    a55 <cos+0xa3>
     a47:	d9 45 08             	flds   0x8(%ebp)
     a4a:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     a50:	de c1                	faddp  %st,%st(1)
     a52:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     a55:	d9 45 08             	flds   0x8(%ebp)
     a58:	dd 05 f0 5e 01 00    	fldl   0x15ef0
     a5e:	d9 c9                	fxch   %st(1)
     a60:	df e9                	fucomip %st(1),%st
     a62:	dd d8                	fstp   %st(0)
     a64:	76 16                	jbe    a7c <cos+0xca>
    {
        x -= PI;
     a66:	d9 45 08             	flds   0x8(%ebp)
     a69:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     a6f:	de e9                	fsubrp %st,%st(1)
     a71:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     a74:	d9 45 f4             	flds   -0xc(%ebp)
     a77:	d9 e0                	fchs   
     a79:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     a7c:	d9 45 08             	flds   0x8(%ebp)
     a7f:	dd 05 f8 5e 01 00    	fldl   0x15ef8
     a85:	df e9                	fucomip %st(1),%st
     a87:	dd d8                	fstp   %st(0)
     a89:	76 16                	jbe    aa1 <cos+0xef>
    {
        x += PI;
     a8b:	d9 45 08             	flds   0x8(%ebp)
     a8e:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     a94:	de c1                	faddp  %st,%st(1)
     a96:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     a99:	d9 45 f4             	flds   -0xc(%ebp)
     a9c:	d9 e0                	fchs   
     a9e:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     aa1:	d9 45 08             	flds   0x8(%ebp)
     aa4:	dd 05 00 5f 01 00    	fldl   0x15f00
     aaa:	d9 c9                	fxch   %st(1)
     aac:	df e9                	fucomip %st(1),%st
     aae:	dd d8                	fstp   %st(0)
     ab0:	76 28                	jbe    ada <cos+0x128>
     ab2:	d9 45 08             	flds   0x8(%ebp)
     ab5:	dd 05 f0 5e 01 00    	fldl   0x15ef0
     abb:	de e1                	fsubp  %st,%st(1)
     abd:	d9 5d e4             	fstps  -0x1c(%ebp)
     ac0:	d9 45 e4             	flds   -0x1c(%ebp)
     ac3:	83 ec 0c             	sub    $0xc,%esp
     ac6:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     aca:	d9 1c 24             	fstps  (%esp)
     acd:	e8 83 00 00 00       	call   b55 <sin>
     ad2:	83 c4 10             	add    $0x10,%esp
     ad5:	d8 4d f4             	fmuls  -0xc(%ebp)
     ad8:	eb 79                	jmp    b53 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     ada:	83 ec 08             	sub    $0x8,%esp
     add:	6a 02                	push   $0x2
     adf:	ff 75 08             	pushl  0x8(%ebp)
     ae2:	e8 1e fe ff ff       	call   905 <pow>
     ae7:	83 c4 10             	add    $0x10,%esp
     aea:	d9 05 c8 5e 01 00    	flds   0x15ec8
     af0:	de f9                	fdivrp %st,%st(1)
     af2:	d9 e8                	fld1   
     af4:	de e1                	fsubp  %st,%st(1)
     af6:	d9 5d d8             	fstps  -0x28(%ebp)
     af9:	83 ec 08             	sub    $0x8,%esp
     afc:	6a 04                	push   $0x4
     afe:	ff 75 08             	pushl  0x8(%ebp)
     b01:	e8 ff fd ff ff       	call   905 <pow>
     b06:	83 c4 10             	add    $0x10,%esp
     b09:	d9 05 08 5f 01 00    	flds   0x15f08
     b0f:	de f9                	fdivrp %st,%st(1)
     b11:	d8 45 d8             	fadds  -0x28(%ebp)
     b14:	d9 5d d8             	fstps  -0x28(%ebp)
     b17:	83 ec 08             	sub    $0x8,%esp
     b1a:	6a 06                	push   $0x6
     b1c:	ff 75 08             	pushl  0x8(%ebp)
     b1f:	e8 e1 fd ff ff       	call   905 <pow>
     b24:	83 c4 10             	add    $0x10,%esp
     b27:	d9 05 0c 5f 01 00    	flds   0x15f0c
     b2d:	de f9                	fdivrp %st,%st(1)
     b2f:	d8 6d d8             	fsubrs -0x28(%ebp)
     b32:	d9 5d d8             	fstps  -0x28(%ebp)
     b35:	83 ec 08             	sub    $0x8,%esp
     b38:	6a 08                	push   $0x8
     b3a:	ff 75 08             	pushl  0x8(%ebp)
     b3d:	e8 c3 fd ff ff       	call   905 <pow>
     b42:	83 c4 10             	add    $0x10,%esp
     b45:	d9 05 10 5f 01 00    	flds   0x15f10
     b4b:	de f9                	fdivrp %st,%st(1)
     b4d:	d8 45 d8             	fadds  -0x28(%ebp)
     b50:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     b53:	c9                   	leave  
     b54:	c3                   	ret    

00000b55 <sin>:

float sin(float x)
{
     b55:	55                   	push   %ebp
     b56:	89 e5                	mov    %esp,%ebp
     b58:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     b5b:	d9 e8                	fld1   
     b5d:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     b60:	d9 45 08             	flds   0x8(%ebp)
     b63:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     b69:	d9 c9                	fxch   %st(1)
     b6b:	df e9                	fucomip %st(1),%st
     b6d:	dd d8                	fstp   %st(0)
     b6f:	77 0f                	ja     b80 <sin+0x2b>
     b71:	d9 45 08             	flds   0x8(%ebp)
     b74:	dd 05 d8 5e 01 00    	fldl   0x15ed8
     b7a:	df e9                	fucomip %st(1),%st
     b7c:	dd d8                	fstp   %st(0)
     b7e:	76 3c                	jbe    bbc <sin+0x67>
     b80:	d9 45 08             	flds   0x8(%ebp)
     b83:	d9 45 08             	flds   0x8(%ebp)
     b86:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     b8c:	de f9                	fdivrp %st,%st(1)
     b8e:	d9 7d e2             	fnstcw -0x1e(%ebp)
     b91:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     b95:	b4 0c                	mov    $0xc,%ah
     b97:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     b9b:	d9 6d e0             	fldcw  -0x20(%ebp)
     b9e:	db 5d dc             	fistpl -0x24(%ebp)
     ba1:	d9 6d e2             	fldcw  -0x1e(%ebp)
     ba4:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ba7:	01 c0                	add    %eax,%eax
     ba9:	89 45 d8             	mov    %eax,-0x28(%ebp)
     bac:	db 45 d8             	fildl  -0x28(%ebp)
     baf:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     bb5:	de c9                	fmulp  %st,%st(1)
     bb7:	de e9                	fsubrp %st,%st(1)
     bb9:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     bbc:	d9 45 08             	flds   0x8(%ebp)
     bbf:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     bc5:	d9 c9                	fxch   %st(1)
     bc7:	df e9                	fucomip %st(1),%st
     bc9:	dd d8                	fstp   %st(0)
     bcb:	76 0e                	jbe    bdb <sin+0x86>
     bcd:	d9 45 08             	flds   0x8(%ebp)
     bd0:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     bd6:	de e9                	fsubrp %st,%st(1)
     bd8:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     bdb:	d9 45 08             	flds   0x8(%ebp)
     bde:	dd 05 e8 5e 01 00    	fldl   0x15ee8
     be4:	df e9                	fucomip %st(1),%st
     be6:	dd d8                	fstp   %st(0)
     be8:	76 0e                	jbe    bf8 <sin+0xa3>
     bea:	d9 45 08             	flds   0x8(%ebp)
     bed:	dd 05 d0 5e 01 00    	fldl   0x15ed0
     bf3:	de c1                	faddp  %st,%st(1)
     bf5:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     bf8:	d9 45 08             	flds   0x8(%ebp)
     bfb:	dd 05 f0 5e 01 00    	fldl   0x15ef0
     c01:	d9 c9                	fxch   %st(1)
     c03:	df e9                	fucomip %st(1),%st
     c05:	dd d8                	fstp   %st(0)
     c07:	76 16                	jbe    c1f <sin+0xca>
    {
        x -= PI;
     c09:	d9 45 08             	flds   0x8(%ebp)
     c0c:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     c12:	de e9                	fsubrp %st,%st(1)
     c14:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c17:	d9 45 f4             	flds   -0xc(%ebp)
     c1a:	d9 e0                	fchs   
     c1c:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     c1f:	d9 45 08             	flds   0x8(%ebp)
     c22:	dd 05 f8 5e 01 00    	fldl   0x15ef8
     c28:	df e9                	fucomip %st(1),%st
     c2a:	dd d8                	fstp   %st(0)
     c2c:	76 16                	jbe    c44 <sin+0xef>
    {
        x += PI;
     c2e:	d9 45 08             	flds   0x8(%ebp)
     c31:	dd 05 e0 5e 01 00    	fldl   0x15ee0
     c37:	de c1                	faddp  %st,%st(1)
     c39:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c3c:	d9 45 f4             	flds   -0xc(%ebp)
     c3f:	d9 e0                	fchs   
     c41:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     c44:	d9 ee                	fldz   
     c46:	d9 45 08             	flds   0x8(%ebp)
     c49:	d9 c9                	fxch   %st(1)
     c4b:	df e9                	fucomip %st(1),%st
     c4d:	dd d8                	fstp   %st(0)
     c4f:	76 10                	jbe    c61 <sin+0x10c>
    {
        x *= -1;
     c51:	d9 45 08             	flds   0x8(%ebp)
     c54:	d9 e0                	fchs   
     c56:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c59:	d9 45 f4             	flds   -0xc(%ebp)
     c5c:	d9 e0                	fchs   
     c5e:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     c61:	d9 45 08             	flds   0x8(%ebp)
     c64:	dd 05 00 5f 01 00    	fldl   0x15f00
     c6a:	d9 c9                	fxch   %st(1)
     c6c:	df e9                	fucomip %st(1),%st
     c6e:	dd d8                	fstp   %st(0)
     c70:	76 28                	jbe    c9a <sin+0x145>
     c72:	d9 45 08             	flds   0x8(%ebp)
     c75:	dd 05 f0 5e 01 00    	fldl   0x15ef0
     c7b:	de e1                	fsubp  %st,%st(1)
     c7d:	d9 5d e4             	fstps  -0x1c(%ebp)
     c80:	d9 45 e4             	flds   -0x1c(%ebp)
     c83:	83 ec 0c             	sub    $0xc,%esp
     c86:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     c8a:	d9 1c 24             	fstps  (%esp)
     c8d:	e8 20 fd ff ff       	call   9b2 <cos>
     c92:	83 c4 10             	add    $0x10,%esp
     c95:	d8 4d f4             	fmuls  -0xc(%ebp)
     c98:	eb 7a                	jmp    d14 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     c9a:	83 ec 08             	sub    $0x8,%esp
     c9d:	6a 03                	push   $0x3
     c9f:	ff 75 08             	pushl  0x8(%ebp)
     ca2:	e8 5e fc ff ff       	call   905 <pow>
     ca7:	83 c4 10             	add    $0x10,%esp
     caa:	d9 05 14 5f 01 00    	flds   0x15f14
     cb0:	de f9                	fdivrp %st,%st(1)
     cb2:	d9 45 08             	flds   0x8(%ebp)
     cb5:	de e1                	fsubp  %st,%st(1)
     cb7:	d9 5d d8             	fstps  -0x28(%ebp)
     cba:	83 ec 08             	sub    $0x8,%esp
     cbd:	6a 05                	push   $0x5
     cbf:	ff 75 08             	pushl  0x8(%ebp)
     cc2:	e8 3e fc ff ff       	call   905 <pow>
     cc7:	83 c4 10             	add    $0x10,%esp
     cca:	d9 05 18 5f 01 00    	flds   0x15f18
     cd0:	de f9                	fdivrp %st,%st(1)
     cd2:	d8 45 d8             	fadds  -0x28(%ebp)
     cd5:	d9 5d d8             	fstps  -0x28(%ebp)
     cd8:	83 ec 08             	sub    $0x8,%esp
     cdb:	6a 07                	push   $0x7
     cdd:	ff 75 08             	pushl  0x8(%ebp)
     ce0:	e8 20 fc ff ff       	call   905 <pow>
     ce5:	83 c4 10             	add    $0x10,%esp
     ce8:	d9 05 1c 5f 01 00    	flds   0x15f1c
     cee:	de f9                	fdivrp %st,%st(1)
     cf0:	d8 6d d8             	fsubrs -0x28(%ebp)
     cf3:	d9 5d d8             	fstps  -0x28(%ebp)
     cf6:	83 ec 08             	sub    $0x8,%esp
     cf9:	6a 09                	push   $0x9
     cfb:	ff 75 08             	pushl  0x8(%ebp)
     cfe:	e8 02 fc ff ff       	call   905 <pow>
     d03:	83 c4 10             	add    $0x10,%esp
     d06:	d9 05 20 5f 01 00    	flds   0x15f20
     d0c:	de f9                	fdivrp %st,%st(1)
     d0e:	d8 45 d8             	fadds  -0x28(%ebp)
     d11:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     d14:	c9                   	leave  
     d15:	c3                   	ret    

00000d16 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     d16:	55                   	push   %ebp
     d17:	89 e5                	mov    %esp,%ebp
     d19:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     d1c:	83 ec 04             	sub    $0x4,%esp
     d1f:	6a 0e                	push   $0xe
     d21:	ff 75 0c             	pushl  0xc(%ebp)
     d24:	ff 75 08             	pushl  0x8(%ebp)
     d27:	e8 44 f6 ff ff       	call   370 <read>
     d2c:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     d2f:	83 ec 04             	sub    $0x4,%esp
     d32:	6a 28                	push   $0x28
     d34:	ff 75 10             	pushl  0x10(%ebp)
     d37:	ff 75 08             	pushl  0x8(%ebp)
     d3a:	e8 31 f6 ff ff       	call   370 <read>
     d3f:	83 c4 10             	add    $0x10,%esp
}
     d42:	90                   	nop
     d43:	c9                   	leave  
     d44:	c3                   	ret    

00000d45 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     d45:	55                   	push   %ebp
     d46:	89 e5                	mov    %esp,%ebp
     d48:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     d4e:	83 ec 08             	sub    $0x8,%esp
     d51:	6a 00                	push   $0x0
     d53:	ff 75 08             	pushl  0x8(%ebp)
     d56:	e8 3d f6 ff ff       	call   398 <open>
     d5b:	83 c4 10             	add    $0x10,%esp
     d5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     d61:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     d65:	79 0a                	jns    d71 <readBitmapFile+0x2c>
        return -1;
     d67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     d6c:	e9 6e 01 00 00       	jmp    edf <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     d71:	83 ec 04             	sub    $0x4,%esp
     d74:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     d77:	50                   	push   %eax
     d78:	8d 45 ca             	lea    -0x36(%ebp),%eax
     d7b:	50                   	push   %eax
     d7c:	ff 75 ec             	pushl  -0x14(%ebp)
     d7f:	e8 92 ff ff ff       	call   d16 <readBitmapHeader>
     d84:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     d87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     d8a:	83 e8 36             	sub    $0x36,%eax
     d8d:	83 ec 04             	sub    $0x4,%esp
     d90:	50                   	push   %eax
     d91:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     d97:	50                   	push   %eax
     d98:	ff 75 ec             	pushl  -0x14(%ebp)
     d9b:	e8 d0 f5 ff ff       	call   370 <read>
     da0:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     da3:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     da6:	8b 45 14             	mov    0x14(%ebp),%eax
     da9:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     dab:	8b 55 aa             	mov    -0x56(%ebp),%edx
     dae:	8b 45 10             	mov    0x10(%ebp),%eax
     db1:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     db3:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     db6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     db9:	8b 45 aa             	mov    -0x56(%ebp),%eax
     dbc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     dbf:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     dc3:	0f b7 c0             	movzwl %ax,%eax
     dc6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     dc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
     dcc:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     dd0:	8d 50 07             	lea    0x7(%eax),%edx
     dd3:	85 c0                	test   %eax,%eax
     dd5:	0f 48 c2             	cmovs  %edx,%eax
     dd8:	c1 f8 03             	sar    $0x3,%eax
     ddb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     dde:	8b 45 0c             	mov    0xc(%ebp),%eax
     de1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     de4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     de7:	83 e8 01             	sub    $0x1,%eax
     dea:	89 45 f4             	mov    %eax,-0xc(%ebp)
     ded:	e9 d0 00 00 00       	jmp    ec2 <readBitmapFile+0x17d>
        if (bits == 32) {
     df2:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     df6:	75 22                	jne    e1a <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     dfb:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     dff:	89 c2                	mov    %eax,%edx
     e01:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e04:	01 d0                	add    %edx,%eax
     e06:	83 ec 04             	sub    $0x4,%esp
     e09:	ff 75 dc             	pushl  -0x24(%ebp)
     e0c:	50                   	push   %eax
     e0d:	ff 75 ec             	pushl  -0x14(%ebp)
     e10:	e8 5b f5 ff ff       	call   370 <read>
     e15:	83 c4 10             	add    $0x10,%esp
     e18:	eb 65                	jmp    e7f <readBitmapFile+0x13a>
        } else {
            int j = 0;
     e1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     e21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     e28:	eb 4d                	jmp    e77 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     e2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e2d:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     e31:	c1 e0 02             	shl    $0x2,%eax
     e34:	89 c2                	mov    %eax,%edx
     e36:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e39:	c1 e0 02             	shl    $0x2,%eax
     e3c:	01 c2                	add    %eax,%edx
     e3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e41:	01 d0                	add    %edx,%eax
     e43:	83 ec 04             	sub    $0x4,%esp
     e46:	6a 03                	push   $0x3
     e48:	50                   	push   %eax
     e49:	ff 75 ec             	pushl  -0x14(%ebp)
     e4c:	e8 1f f5 ff ff       	call   370 <read>
     e51:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     e54:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e57:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     e5b:	c1 e0 02             	shl    $0x2,%eax
     e5e:	89 c2                	mov    %eax,%edx
     e60:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e63:	c1 e0 02             	shl    $0x2,%eax
     e66:	01 d0                	add    %edx,%eax
     e68:	8d 50 03             	lea    0x3(%eax),%edx
     e6b:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e6e:	01 d0                	add    %edx,%eax
     e70:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     e73:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     e77:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e7a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     e7d:	7c ab                	jl     e2a <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     e7f:	8b 45 dc             	mov    -0x24(%ebp),%eax
     e82:	99                   	cltd   
     e83:	c1 ea 1e             	shr    $0x1e,%edx
     e86:	01 d0                	add    %edx,%eax
     e88:	83 e0 03             	and    $0x3,%eax
     e8b:	29 d0                	sub    %edx,%eax
     e8d:	85 c0                	test   %eax,%eax
     e8f:	7e 2d                	jle    ebe <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     e91:	8b 45 dc             	mov    -0x24(%ebp),%eax
     e94:	99                   	cltd   
     e95:	c1 ea 1e             	shr    $0x1e,%edx
     e98:	01 d0                	add    %edx,%eax
     e9a:	83 e0 03             	and    $0x3,%eax
     e9d:	29 d0                	sub    %edx,%eax
     e9f:	ba 04 00 00 00       	mov    $0x4,%edx
     ea4:	29 c2                	sub    %eax,%edx
     ea6:	89 d0                	mov    %edx,%eax
     ea8:	83 ec 04             	sub    $0x4,%esp
     eab:	50                   	push   %eax
     eac:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     eb2:	50                   	push   %eax
     eb3:	ff 75 ec             	pushl  -0x14(%ebp)
     eb6:	e8 b5 f4 ff ff       	call   370 <read>
     ebb:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     ebe:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     ec2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     ec6:	0f 89 26 ff ff ff    	jns    df2 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     ecc:	83 ec 0c             	sub    $0xc,%esp
     ecf:	ff 75 ec             	pushl  -0x14(%ebp)
     ed2:	e8 a9 f4 ff ff       	call   380 <close>
     ed7:	83 c4 10             	add    $0x10,%esp
    return 0;
     eda:	b8 00 00 00 00       	mov    $0x0,%eax
}
     edf:	c9                   	leave  
     ee0:	c3                   	ret    

00000ee1 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     ee1:	55                   	push   %ebp
     ee2:	89 e5                	mov    %esp,%ebp
     ee4:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     eea:	83 ec 08             	sub    $0x8,%esp
     eed:	6a 00                	push   $0x0
     eef:	ff 75 08             	pushl  0x8(%ebp)
     ef2:	e8 a1 f4 ff ff       	call   398 <open>
     ef7:	83 c4 10             	add    $0x10,%esp
     efa:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     efd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     f01:	79 0a                	jns    f0d <read24BitmapFile+0x2c>
        return -1;
     f03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     f08:	e9 66 01 00 00       	jmp    1073 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     f0d:	83 ec 04             	sub    $0x4,%esp
     f10:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     f13:	50                   	push   %eax
     f14:	8d 45 ca             	lea    -0x36(%ebp),%eax
     f17:	50                   	push   %eax
     f18:	ff 75 ec             	pushl  -0x14(%ebp)
     f1b:	e8 f6 fd ff ff       	call   d16 <readBitmapHeader>
     f20:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     f23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     f26:	83 e8 36             	sub    $0x36,%eax
     f29:	83 ec 04             	sub    $0x4,%esp
     f2c:	50                   	push   %eax
     f2d:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     f33:	50                   	push   %eax
     f34:	ff 75 ec             	pushl  -0x14(%ebp)
     f37:	e8 34 f4 ff ff       	call   370 <read>
     f3c:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     f3f:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     f42:	8b 45 14             	mov    0x14(%ebp),%eax
     f45:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     f47:	8b 55 aa             	mov    -0x56(%ebp),%edx
     f4a:	8b 45 10             	mov    0x10(%ebp),%eax
     f4d:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     f4f:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     f52:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     f55:	8b 45 aa             	mov    -0x56(%ebp),%eax
     f58:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     f5b:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     f5f:	0f b7 c0             	movzwl %ax,%eax
     f62:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     f65:	8b 55 e8             	mov    -0x18(%ebp),%edx
     f68:	89 d0                	mov    %edx,%eax
     f6a:	01 c0                	add    %eax,%eax
     f6c:	01 d0                	add    %edx,%eax
     f6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     f71:	8b 45 0c             	mov    0xc(%ebp),%eax
     f74:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     f77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     f7a:	83 e8 01             	sub    $0x1,%eax
     f7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
     f80:	e9 d1 00 00 00       	jmp    1056 <read24BitmapFile+0x175>
        if (bits == 24) {
     f85:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     f89:	75 22                	jne    fad <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f8e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     f92:	89 c2                	mov    %eax,%edx
     f94:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f97:	01 d0                	add    %edx,%eax
     f99:	83 ec 04             	sub    $0x4,%esp
     f9c:	ff 75 dc             	pushl  -0x24(%ebp)
     f9f:	50                   	push   %eax
     fa0:	ff 75 ec             	pushl  -0x14(%ebp)
     fa3:	e8 c8 f3 ff ff       	call   370 <read>
     fa8:	83 c4 10             	add    $0x10,%esp
     fab:	eb 66                	jmp    1013 <read24BitmapFile+0x132>
        } else {
            int j = 0;
     fad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     fb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     fbb:	eb 4e                	jmp    100b <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
     fbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fc0:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     fc4:	89 c2                	mov    %eax,%edx
     fc6:	89 d0                	mov    %edx,%eax
     fc8:	01 c0                	add    %eax,%eax
     fca:	01 d0                	add    %edx,%eax
     fcc:	89 c1                	mov    %eax,%ecx
     fce:	8b 55 f0             	mov    -0x10(%ebp),%edx
     fd1:	89 d0                	mov    %edx,%eax
     fd3:	01 c0                	add    %eax,%eax
     fd5:	01 d0                	add    %edx,%eax
     fd7:	8d 14 01             	lea    (%ecx,%eax,1),%edx
     fda:	8b 45 d8             	mov    -0x28(%ebp),%eax
     fdd:	01 d0                	add    %edx,%eax
     fdf:	83 ec 04             	sub    $0x4,%esp
     fe2:	6a 03                	push   $0x3
     fe4:	50                   	push   %eax
     fe5:	ff 75 ec             	pushl  -0x14(%ebp)
     fe8:	e8 83 f3 ff ff       	call   370 <read>
     fed:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
     ff0:	83 ec 04             	sub    $0x4,%esp
     ff3:	6a 01                	push   $0x1
     ff5:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     ffb:	50                   	push   %eax
     ffc:	ff 75 ec             	pushl  -0x14(%ebp)
     fff:	e8 6c f3 ff ff       	call   370 <read>
    1004:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1007:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    100b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    100e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1011:	7c aa                	jl     fbd <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1013:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1016:	99                   	cltd   
    1017:	c1 ea 1e             	shr    $0x1e,%edx
    101a:	01 d0                	add    %edx,%eax
    101c:	83 e0 03             	and    $0x3,%eax
    101f:	29 d0                	sub    %edx,%eax
    1021:	85 c0                	test   %eax,%eax
    1023:	7e 2d                	jle    1052 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1025:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1028:	99                   	cltd   
    1029:	c1 ea 1e             	shr    $0x1e,%edx
    102c:	01 d0                	add    %edx,%eax
    102e:	83 e0 03             	and    $0x3,%eax
    1031:	29 d0                	sub    %edx,%eax
    1033:	ba 04 00 00 00       	mov    $0x4,%edx
    1038:	29 c2                	sub    %eax,%edx
    103a:	89 d0                	mov    %edx,%eax
    103c:	83 ec 04             	sub    $0x4,%esp
    103f:	50                   	push   %eax
    1040:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1046:	50                   	push   %eax
    1047:	ff 75 ec             	pushl  -0x14(%ebp)
    104a:	e8 21 f3 ff ff       	call   370 <read>
    104f:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1052:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1056:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    105a:	0f 89 25 ff ff ff    	jns    f85 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1060:	83 ec 0c             	sub    $0xc,%esp
    1063:	ff 75 ec             	pushl  -0x14(%ebp)
    1066:	e8 15 f3 ff ff       	call   380 <close>
    106b:	83 c4 10             	add    $0x10,%esp
    return 0;
    106e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1073:	c9                   	leave  
    1074:	c3                   	ret    

00001075 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    1075:	55                   	push   %ebp
    1076:	89 e5                	mov    %esp,%ebp
    1078:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    107b:	8b 55 10             	mov    0x10(%ebp),%edx
    107e:	89 d0                	mov    %edx,%eax
    1080:	01 c0                	add    %eax,%eax
    1082:	01 d0                	add    %edx,%eax
    1084:	c1 e0 03             	shl    $0x3,%eax
    1087:	83 c0 1f             	add    $0x1f,%eax
    108a:	8d 50 1f             	lea    0x1f(%eax),%edx
    108d:	85 c0                	test   %eax,%eax
    108f:	0f 48 c2             	cmovs  %edx,%eax
    1092:	c1 f8 05             	sar    $0x5,%eax
    1095:	c1 e0 02             	shl    $0x2,%eax
    1098:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    109b:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    10a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10a4:	0f af 45 0c          	imul   0xc(%ebp),%eax
    10a8:	83 c0 36             	add    $0x36,%eax
    10ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    10ae:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    10b4:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    10ba:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    10c1:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    10c8:	8b 45 10             	mov    0x10(%ebp),%eax
    10cb:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    10ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    10d1:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    10d4:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    10da:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    10e0:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    10e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10ea:	0f af 45 0c          	imul   0xc(%ebp),%eax
    10ee:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    10f1:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    10f8:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    10ff:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1106:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    110d:	83 ec 04             	sub    $0x4,%esp
    1110:	6a 0e                	push   $0xe
    1112:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1115:	50                   	push   %eax
    1116:	ff 75 08             	pushl  0x8(%ebp)
    1119:	e8 5a f2 ff ff       	call   378 <write>
    111e:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1121:	83 ec 04             	sub    $0x4,%esp
    1124:	6a 28                	push   $0x28
    1126:	8d 45 be             	lea    -0x42(%ebp),%eax
    1129:	50                   	push   %eax
    112a:	ff 75 08             	pushl  0x8(%ebp)
    112d:	e8 46 f2 ff ff       	call   378 <write>
    1132:	83 c4 10             	add    $0x10,%esp
}
    1135:	90                   	nop
    1136:	c9                   	leave  
    1137:	c3                   	ret    

00001138 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    1138:	55                   	push   %ebp
    1139:	89 e5                	mov    %esp,%ebp
    113b:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    113e:	83 ec 08             	sub    $0x8,%esp
    1141:	68 02 02 00 00       	push   $0x202
    1146:	ff 75 08             	pushl  0x8(%ebp)
    1149:	e8 4a f2 ff ff       	call   398 <open>
    114e:	83 c4 10             	add    $0x10,%esp
    1151:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    1154:	8b 55 14             	mov    0x14(%ebp),%edx
    1157:	89 d0                	mov    %edx,%eax
    1159:	01 c0                	add    %eax,%eax
    115b:	01 d0                	add    %edx,%eax
    115d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    1160:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    1164:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    1168:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    116c:	83 ec 04             	sub    $0x4,%esp
    116f:	ff 75 14             	pushl  0x14(%ebp)
    1172:	ff 75 10             	pushl  0x10(%ebp)
    1175:	ff 75 f0             	pushl  -0x10(%ebp)
    1178:	e8 f8 fe ff ff       	call   1075 <write24BitmapFileHeader>
    117d:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    1180:	8b 45 10             	mov    0x10(%ebp),%eax
    1183:	83 e8 01             	sub    $0x1,%eax
    1186:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1189:	eb 66                	jmp    11f1 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    118b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    118e:	0f af 45 14          	imul   0x14(%ebp),%eax
    1192:	89 c2                	mov    %eax,%edx
    1194:	89 d0                	mov    %edx,%eax
    1196:	01 c0                	add    %eax,%eax
    1198:	01 c2                	add    %eax,%edx
    119a:	8b 45 0c             	mov    0xc(%ebp),%eax
    119d:	01 d0                	add    %edx,%eax
    119f:	83 ec 04             	sub    $0x4,%esp
    11a2:	ff 75 ec             	pushl  -0x14(%ebp)
    11a5:	50                   	push   %eax
    11a6:	ff 75 f0             	pushl  -0x10(%ebp)
    11a9:	e8 ca f1 ff ff       	call   378 <write>
    11ae:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    11b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    11b4:	99                   	cltd   
    11b5:	c1 ea 1e             	shr    $0x1e,%edx
    11b8:	01 d0                	add    %edx,%eax
    11ba:	83 e0 03             	and    $0x3,%eax
    11bd:	29 d0                	sub    %edx,%eax
    11bf:	85 c0                	test   %eax,%eax
    11c1:	7e 2a                	jle    11ed <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    11c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    11c6:	99                   	cltd   
    11c7:	c1 ea 1e             	shr    $0x1e,%edx
    11ca:	01 d0                	add    %edx,%eax
    11cc:	83 e0 03             	and    $0x3,%eax
    11cf:	29 d0                	sub    %edx,%eax
    11d1:	ba 04 00 00 00       	mov    $0x4,%edx
    11d6:	29 c2                	sub    %eax,%edx
    11d8:	89 d0                	mov    %edx,%eax
    11da:	83 ec 04             	sub    $0x4,%esp
    11dd:	50                   	push   %eax
    11de:	8d 45 e9             	lea    -0x17(%ebp),%eax
    11e1:	50                   	push   %eax
    11e2:	ff 75 f0             	pushl  -0x10(%ebp)
    11e5:	e8 8e f1 ff ff       	call   378 <write>
    11ea:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    11ed:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    11f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    11f5:	79 94                	jns    118b <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    11f7:	83 ec 0c             	sub    $0xc,%esp
    11fa:	ff 75 f0             	pushl  -0x10(%ebp)
    11fd:	e8 7e f1 ff ff       	call   380 <close>
    1202:	83 c4 10             	add    $0x10,%esp
    return 0;
    1205:	b8 00 00 00 00       	mov    $0x0,%eax
    120a:	c9                   	leave  
    120b:	c3                   	ret    

0000120c <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    120c:	55                   	push   %ebp
    120d:	89 e5                	mov    %esp,%ebp
    120f:	57                   	push   %edi
    1210:	56                   	push   %esi
    1211:	53                   	push   %ebx
    1212:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1215:	8b 45 08             	mov    0x8(%ebp),%eax
    1218:	8b 50 10             	mov    0x10(%eax),%edx
    121b:	8b 40 0c             	mov    0xc(%eax),%eax
    121e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1221:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1224:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1227:	8b 55 e0             	mov    -0x20(%ebp),%edx
    122a:	83 c2 1e             	add    $0x1e,%edx
    122d:	0f af d0             	imul   %eax,%edx
    1230:	89 d0                	mov    %edx,%eax
    1232:	01 c0                	add    %eax,%eax
    1234:	01 d0                	add    %edx,%eax
    1236:	83 ec 0c             	sub    $0xc,%esp
    1239:	50                   	push   %eax
    123a:	e8 93 f5 ff ff       	call   7d2 <malloc>
    123f:	83 c4 10             	add    $0x10,%esp
    1242:	89 c2                	mov    %eax,%edx
    1244:	8b 45 08             	mov    0x8(%ebp),%eax
    1247:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    124a:	8b 45 08             	mov    0x8(%ebp),%eax
    124d:	8b 40 1c             	mov    0x1c(%eax),%eax
    1250:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1253:	6b d2 5a             	imul   $0x5a,%edx,%edx
    1256:	01 c2                	add    %eax,%edx
    1258:	8b 45 08             	mov    0x8(%ebp),%eax
    125b:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    125e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1261:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1264:	0f af d0             	imul   %eax,%edx
    1267:	89 d0                	mov    %edx,%eax
    1269:	01 c0                	add    %eax,%eax
    126b:	01 d0                	add    %edx,%eax
    126d:	89 c2                	mov    %eax,%edx
    126f:	8b 45 08             	mov    0x8(%ebp),%eax
    1272:	8b 40 18             	mov    0x18(%eax),%eax
    1275:	83 ec 04             	sub    $0x4,%esp
    1278:	52                   	push   %edx
    1279:	68 ff 00 00 00       	push   $0xff
    127e:	50                   	push   %eax
    127f:	e8 39 ef ff ff       	call   1bd <memset>
    1284:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    1287:	8b 45 08             	mov    0x8(%ebp),%eax
    128a:	8b 78 1c             	mov    0x1c(%eax),%edi
    128d:	8b 45 08             	mov    0x8(%ebp),%eax
    1290:	8b 70 14             	mov    0x14(%eax),%esi
    1293:	8b 45 08             	mov    0x8(%ebp),%eax
    1296:	8b 58 0c             	mov    0xc(%eax),%ebx
    1299:	8b 45 08             	mov    0x8(%ebp),%eax
    129c:	8b 48 10             	mov    0x10(%eax),%ecx
    129f:	8b 45 08             	mov    0x8(%ebp),%eax
    12a2:	8b 50 08             	mov    0x8(%eax),%edx
    12a5:	8b 45 08             	mov    0x8(%ebp),%eax
    12a8:	8b 40 04             	mov    0x4(%eax),%eax
    12ab:	83 ec 08             	sub    $0x8,%esp
    12ae:	57                   	push   %edi
    12af:	56                   	push   %esi
    12b0:	53                   	push   %ebx
    12b1:	51                   	push   %ecx
    12b2:	52                   	push   %edx
    12b3:	50                   	push   %eax
    12b4:	e8 3f f1 ff ff       	call   3f8 <createwindow>
    12b9:	83 c4 20             	add    $0x20,%esp
    12bc:	89 c2                	mov    %eax,%edx
    12be:	8b 45 08             	mov    0x8(%ebp),%eax
    12c1:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    12c3:	8b 45 08             	mov    0x8(%ebp),%eax
    12c6:	8b 00                	mov    (%eax),%eax
}
    12c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
    12cb:	5b                   	pop    %ebx
    12cc:	5e                   	pop    %esi
    12cd:	5f                   	pop    %edi
    12ce:	5d                   	pop    %ebp
    12cf:	c3                   	ret    

000012d0 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    12d0:	55                   	push   %ebp
    12d1:	89 e5                	mov    %esp,%ebp
    12d3:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    12d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    12dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    12e4:	8b 45 08             	mov    0x8(%ebp),%eax
    12e7:	8b 40 18             	mov    0x18(%eax),%eax
    12ea:	ff 75 1c             	pushl  0x1c(%ebp)
    12ed:	ff 75 18             	pushl  0x18(%ebp)
    12f0:	ff 75 1c             	pushl  0x1c(%ebp)
    12f3:	ff 75 18             	pushl  0x18(%ebp)
    12f6:	8b 55 08             	mov    0x8(%ebp),%edx
    12f9:	ff 72 10             	pushl  0x10(%edx)
    12fc:	ff 72 0c             	pushl  0xc(%edx)
    12ff:	ff 75 f4             	pushl  -0xc(%ebp)
    1302:	ff 75 f0             	pushl  -0x10(%ebp)
    1305:	ff 75 14             	pushl  0x14(%ebp)
    1308:	ff 75 10             	pushl  0x10(%ebp)
    130b:	ff 75 0c             	pushl  0xc(%ebp)
    130e:	50                   	push   %eax
    130f:	e8 d5 07 00 00       	call   1ae9 <drawBitmap>
    1314:	83 c4 30             	add    $0x30,%esp
    return 0;
    1317:	b8 00 00 00 00       	mov    $0x0,%eax
}
    131c:	c9                   	leave  
    131d:	c3                   	ret    

0000131e <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    131e:	55                   	push   %ebp
    131f:	89 e5                	mov    %esp,%ebp
    1321:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1324:	8b 45 08             	mov    0x8(%ebp),%eax
    1327:	8b 40 18             	mov    0x18(%eax),%eax
    132a:	ff 75 2c             	pushl  0x2c(%ebp)
    132d:	ff 75 28             	pushl  0x28(%ebp)
    1330:	ff 75 24             	pushl  0x24(%ebp)
    1333:	ff 75 20             	pushl  0x20(%ebp)
    1336:	8b 55 08             	mov    0x8(%ebp),%edx
    1339:	ff 72 10             	pushl  0x10(%edx)
    133c:	ff 72 0c             	pushl  0xc(%edx)
    133f:	ff 75 1c             	pushl  0x1c(%ebp)
    1342:	ff 75 18             	pushl  0x18(%ebp)
    1345:	ff 75 14             	pushl  0x14(%ebp)
    1348:	ff 75 10             	pushl  0x10(%ebp)
    134b:	ff 75 0c             	pushl  0xc(%ebp)
    134e:	50                   	push   %eax
    134f:	e8 95 07 00 00       	call   1ae9 <drawBitmap>
    1354:	83 c4 30             	add    $0x30,%esp
    return 0;
    1357:	b8 00 00 00 00       	mov    $0x0,%eax
}
    135c:	c9                   	leave  
    135d:	c3                   	ret    

0000135e <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    135e:	55                   	push   %ebp
    135f:	89 e5                	mov    %esp,%ebp
    1361:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1364:	8b 45 08             	mov    0x8(%ebp),%eax
    1367:	8b 40 18             	mov    0x18(%eax),%eax
    136a:	ff 75 2c             	pushl  0x2c(%ebp)
    136d:	ff 75 28             	pushl  0x28(%ebp)
    1370:	ff 75 24             	pushl  0x24(%ebp)
    1373:	ff 75 20             	pushl  0x20(%ebp)
    1376:	8b 55 08             	mov    0x8(%ebp),%edx
    1379:	ff 72 10             	pushl  0x10(%edx)
    137c:	ff 72 0c             	pushl  0xc(%edx)
    137f:	ff 75 1c             	pushl  0x1c(%ebp)
    1382:	ff 75 18             	pushl  0x18(%ebp)
    1385:	ff 75 14             	pushl  0x14(%ebp)
    1388:	ff 75 10             	pushl  0x10(%ebp)
    138b:	ff 75 0c             	pushl  0xc(%ebp)
    138e:	50                   	push   %eax
    138f:	e8 75 08 00 00       	call   1c09 <drawTransparentBitmap>
    1394:	83 c4 30             	add    $0x30,%esp
    return 0;
    1397:	b8 00 00 00 00       	mov    $0x0,%eax
}
    139c:	c9                   	leave  
    139d:	c3                   	ret    

0000139e <api_repaint>:

int api_repaint(Window* wnd)
{
    139e:	55                   	push   %ebp
    139f:	89 e5                	mov    %esp,%ebp
    13a1:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    13a4:	8b 45 08             	mov    0x8(%ebp),%eax
    13a7:	8b 00                	mov    (%eax),%eax
    13a9:	83 ec 0c             	sub    $0xc,%esp
    13ac:	50                   	push   %eax
    13ad:	e8 4e f0 ff ff       	call   400 <repaintwindow>
    13b2:	83 c4 10             	add    $0x10,%esp
    return 0;
    13b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13ba:	c9                   	leave  
    13bb:	c3                   	ret    

000013bc <api_update>:

int api_update(Window* wnd, Rect rect)
{
    13bc:	55                   	push   %ebp
    13bd:	89 e5                	mov    %esp,%ebp
    13bf:	56                   	push   %esi
    13c0:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    13c1:	8b 75 18             	mov    0x18(%ebp),%esi
    13c4:	8b 5d 14             	mov    0x14(%ebp),%ebx
    13c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    13ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    13cd:	8b 45 08             	mov    0x8(%ebp),%eax
    13d0:	8b 00                	mov    (%eax),%eax
    13d2:	83 ec 0c             	sub    $0xc,%esp
    13d5:	56                   	push   %esi
    13d6:	53                   	push   %ebx
    13d7:	51                   	push   %ecx
    13d8:	52                   	push   %edx
    13d9:	50                   	push   %eax
    13da:	e8 39 f0 ff ff       	call   418 <updatewindow>
    13df:	83 c4 20             	add    $0x20,%esp
    return 0;
    13e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13e7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    13ea:	5b                   	pop    %ebx
    13eb:	5e                   	pop    %esi
    13ec:	5d                   	pop    %ebp
    13ed:	c3                   	ret    

000013ee <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    13ee:	55                   	push   %ebp
    13ef:	89 e5                	mov    %esp,%ebp
    13f1:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    13f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    13fb:	8b 45 08             	mov    0x8(%ebp),%eax
    13fe:	8b 00                	mov    (%eax),%eax
    1400:	83 ec 08             	sub    $0x8,%esp
    1403:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1406:	52                   	push   %edx
    1407:	50                   	push   %eax
    1408:	e8 fb ef ff ff       	call   408 <getmessage>
    140d:	83 c4 10             	add    $0x10,%esp
    1410:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1413:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1417:	74 e2                	je     13fb <api_exec+0xd>
        {
            pf(&msg);
    1419:	83 ec 0c             	sub    $0xc,%esp
    141c:	8d 45 c8             	lea    -0x38(%ebp),%eax
    141f:	50                   	push   %eax
    1420:	8b 45 0c             	mov    0xc(%ebp),%eax
    1423:	ff d0                	call   *%eax
    1425:	83 c4 10             	add    $0x10,%esp
        }
    }
    1428:	eb d1                	jmp    13fb <api_exec+0xd>

0000142a <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    142a:	55                   	push   %ebp
    142b:	89 e5                	mov    %esp,%ebp
    142d:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1430:	8b 45 08             	mov    0x8(%ebp),%eax
    1433:	8b 00                	mov    (%eax),%eax
    1435:	83 ec 08             	sub    $0x8,%esp
    1438:	ff 75 0c             	pushl  0xc(%ebp)
    143b:	50                   	push   %eax
    143c:	e8 cf ef ff ff       	call   410 <settimer>
    1441:	83 c4 10             	add    $0x10,%esp
    return 0;
    1444:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1449:	c9                   	leave  
    144a:	c3                   	ret    

0000144b <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    144b:	55                   	push   %ebp
    144c:	89 e5                	mov    %esp,%ebp
    144e:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    1451:	8b 45 08             	mov    0x8(%ebp),%eax
    1454:	8b 50 18             	mov    0x18(%eax),%edx
    1457:	ff 75 18             	pushl  0x18(%ebp)
    145a:	ff 75 14             	pushl  0x14(%ebp)
    145d:	83 ec 04             	sub    $0x4,%esp
    1460:	89 e0                	mov    %esp,%eax
    1462:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    1466:	66 89 08             	mov    %cx,(%eax)
    1469:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    146d:	88 48 02             	mov    %cl,0x2(%eax)
    1470:	8b 45 08             	mov    0x8(%ebp),%eax
    1473:	ff 70 10             	pushl  0x10(%eax)
    1476:	ff 70 0c             	pushl  0xc(%eax)
    1479:	ff 75 10             	pushl  0x10(%ebp)
    147c:	ff 75 0c             	pushl  0xc(%ebp)
    147f:	52                   	push   %edx
    1480:	e8 6f 04 00 00       	call   18f4 <drawRect>
    1485:	83 c4 20             	add    $0x20,%esp
    return 0;
    1488:	b8 00 00 00 00       	mov    $0x0,%eax
}
    148d:	c9                   	leave  
    148e:	c3                   	ret    

0000148f <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    148f:	55                   	push   %ebp
    1490:	89 e5                	mov    %esp,%ebp
    1492:	83 ec 28             	sub    $0x28,%esp
    1495:	8b 45 14             	mov    0x14(%ebp),%eax
    1498:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    149b:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    149f:	8b 45 0c             	mov    0xc(%ebp),%eax
    14a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    14a5:	8b 45 10             	mov    0x10(%ebp),%eax
    14a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    14ab:	8b 45 08             	mov    0x8(%ebp),%eax
    14ae:	8b 40 18             	mov    0x18(%eax),%eax
    14b1:	83 ec 04             	sub    $0x4,%esp
    14b4:	ff 75 18             	pushl  0x18(%ebp)
    14b7:	52                   	push   %edx
    14b8:	8b 55 08             	mov    0x8(%ebp),%edx
    14bb:	ff 72 10             	pushl  0x10(%edx)
    14be:	ff 72 0c             	pushl  0xc(%edx)
    14c1:	ff 75 f4             	pushl  -0xc(%ebp)
    14c4:	ff 75 f0             	pushl  -0x10(%ebp)
    14c7:	50                   	push   %eax
    14c8:	e8 d4 02 00 00       	call   17a1 <drawCharacter>
    14cd:	83 c4 20             	add    $0x20,%esp
    return 0;
    14d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14d5:	c9                   	leave  
    14d6:	c3                   	ret    

000014d7 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    14d7:	55                   	push   %ebp
    14d8:	89 e5                	mov    %esp,%ebp
    14da:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    14dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    14e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    14e3:	8b 45 10             	mov    0x10(%ebp),%eax
    14e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    14e9:	8b 45 08             	mov    0x8(%ebp),%eax
    14ec:	8b 40 18             	mov    0x18(%eax),%eax
    14ef:	83 ec 04             	sub    $0x4,%esp
    14f2:	ff 75 18             	pushl  0x18(%ebp)
    14f5:	ff 75 14             	pushl  0x14(%ebp)
    14f8:	8b 55 08             	mov    0x8(%ebp),%edx
    14fb:	ff 72 10             	pushl  0x10(%edx)
    14fe:	ff 72 0c             	pushl  0xc(%edx)
    1501:	ff 75 f4             	pushl  -0xc(%ebp)
    1504:	ff 75 f0             	pushl  -0x10(%ebp)
    1507:	50                   	push   %eax
    1508:	e8 8e 03 00 00       	call   189b <drawString>
    150d:	83 c4 20             	add    $0x20,%esp
    return 0;
    1510:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1515:	c9                   	leave  
    1516:	c3                   	ret    

00001517 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    1517:	55                   	push   %ebp
    1518:	89 e5                	mov    %esp,%ebp
    151a:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    151d:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1521:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1525:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    1529:	83 ec 08             	sub    $0x8,%esp
    152c:	83 ec 04             	sub    $0x4,%esp
    152f:	89 e0                	mov    %esp,%eax
    1531:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    1535:	66 89 10             	mov    %dx,(%eax)
    1538:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    153c:	88 50 02             	mov    %dl,0x2(%eax)
    153f:	ff 75 18             	pushl  0x18(%ebp)
    1542:	ff 75 14             	pushl  0x14(%ebp)
    1545:	ff 75 10             	pushl  0x10(%ebp)
    1548:	ff 75 0c             	pushl  0xc(%ebp)
    154b:	ff 75 08             	pushl  0x8(%ebp)
    154e:	e8 f8 fe ff ff       	call   144b <api_drawRect>
    1553:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    1556:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    155a:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    155e:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    1562:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    1566:	8b 45 10             	mov    0x10(%ebp),%eax
    1569:	8d 50 0a             	lea    0xa(%eax),%edx
    156c:	8b 45 0c             	mov    0xc(%ebp),%eax
    156f:	83 c0 0a             	add    $0xa,%eax
    1572:	83 ec 0c             	sub    $0xc,%esp
    1575:	ff 75 f4             	pushl  -0xc(%ebp)
    1578:	ff 75 1c             	pushl  0x1c(%ebp)
    157b:	52                   	push   %edx
    157c:	50                   	push   %eax
    157d:	ff 75 08             	pushl  0x8(%ebp)
    1580:	e8 52 ff ff ff       	call   14d7 <api_drawString>
    1585:	83 c4 20             	add    $0x20,%esp
    return 0;
    1588:	b8 00 00 00 00       	mov    $0x0,%eax
}
    158d:	c9                   	leave  
    158e:	c3                   	ret    

0000158f <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    158f:	55                   	push   %ebp
    1590:	89 e5                	mov    %esp,%ebp
    1592:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    1595:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    159c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    15a3:	8b 45 08             	mov    0x8(%ebp),%eax
    15a6:	8b 40 18             	mov    0x18(%eax),%eax
    15a9:	ff 75 1c             	pushl  0x1c(%ebp)
    15ac:	ff 75 18             	pushl  0x18(%ebp)
    15af:	ff 75 1c             	pushl  0x1c(%ebp)
    15b2:	ff 75 18             	pushl  0x18(%ebp)
    15b5:	8b 55 08             	mov    0x8(%ebp),%edx
    15b8:	ff 72 10             	pushl  0x10(%edx)
    15bb:	ff 72 0c             	pushl  0xc(%edx)
    15be:	ff 75 f4             	pushl  -0xc(%ebp)
    15c1:	ff 75 f0             	pushl  -0x10(%ebp)
    15c4:	ff 75 14             	pushl  0x14(%ebp)
    15c7:	ff 75 10             	pushl  0x10(%ebp)
    15ca:	ff 75 0c             	pushl  0xc(%ebp)
    15cd:	50                   	push   %eax
    15ce:	e8 16 05 00 00       	call   1ae9 <drawBitmap>
    15d3:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    15d6:	8b 45 08             	mov    0x8(%ebp),%eax
    15d9:	8b 40 18             	mov    0x18(%eax),%eax
    15dc:	ff 75 28             	pushl  0x28(%ebp)
    15df:	ff 75 1c             	pushl  0x1c(%ebp)
    15e2:	ff 75 18             	pushl  0x18(%ebp)
    15e5:	8b 55 08             	mov    0x8(%ebp),%edx
    15e8:	ff 72 10             	pushl  0x10(%edx)
    15eb:	ff 72 0c             	pushl  0xc(%edx)
    15ee:	ff 75 14             	pushl  0x14(%ebp)
    15f1:	ff 75 10             	pushl  0x10(%ebp)
    15f4:	50                   	push   %eax
    15f5:	e8 99 07 00 00       	call   1d93 <colorShift>
    15fa:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    15fd:	8b 45 08             	mov    0x8(%ebp),%eax
    1600:	8b 50 18             	mov    0x18(%eax),%edx
    1603:	83 ec 0c             	sub    $0xc,%esp
    1606:	ff 75 20             	pushl  0x20(%ebp)
    1609:	ff 75 1c             	pushl  0x1c(%ebp)
    160c:	ff 75 18             	pushl  0x18(%ebp)
    160f:	83 ec 04             	sub    $0x4,%esp
    1612:	89 e0                	mov    %esp,%eax
    1614:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    1618:	66 89 08             	mov    %cx,(%eax)
    161b:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    161f:	88 48 02             	mov    %cl,0x2(%eax)
    1622:	8b 45 08             	mov    0x8(%ebp),%eax
    1625:	ff 70 10             	pushl  0x10(%eax)
    1628:	ff 70 0c             	pushl  0xc(%eax)
    162b:	ff 75 14             	pushl  0x14(%ebp)
    162e:	ff 75 10             	pushl  0x10(%ebp)
    1631:	52                   	push   %edx
    1632:	e8 6d 03 00 00       	call   19a4 <drawBorder>
    1637:	83 c4 30             	add    $0x30,%esp
    return 0;
    163a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    163f:	c9                   	leave  
    1640:	c3                   	ret    

00001641 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    1641:	55                   	push   %ebp
    1642:	89 e5                	mov    %esp,%ebp
    1644:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    1647:	8b 45 08             	mov    0x8(%ebp),%eax
    164a:	8b 00                	mov    (%eax),%eax
    164c:	83 ec 0c             	sub    $0xc,%esp
    164f:	50                   	push   %eax
    1650:	e8 cb ed ff ff       	call   420 <destroywindow>
    1655:	83 c4 10             	add    $0x10,%esp
    return 0;
    1658:	b8 00 00 00 00       	mov    $0x0,%eax
    165d:	c9                   	leave  
    165e:	c3                   	ret    

0000165f <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    165f:	55                   	push   %ebp
    1660:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    1662:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1666:	8b 45 08             	mov    0x8(%ebp),%eax
    1669:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    166c:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1670:	8b 45 08             	mov    0x8(%ebp),%eax
    1673:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    1676:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    167a:	8b 45 08             	mov    0x8(%ebp),%eax
    167d:	88 10                	mov    %dl,(%eax)
}
    167f:	90                   	nop
    1680:	5d                   	pop    %ebp
    1681:	c3                   	ret    

00001682 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    1682:	55                   	push   %ebp
    1683:	89 e5                	mov    %esp,%ebp
    1685:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    1688:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    168c:	3c ff                	cmp    $0xff,%al
    168e:	75 22                	jne    16b2 <drawPointAlpha+0x30>
        color->R = origin.R;
    1690:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    1694:	8b 45 08             	mov    0x8(%ebp),%eax
    1697:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    169a:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    169e:	8b 45 08             	mov    0x8(%ebp),%eax
    16a1:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    16a4:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    16a8:	8b 45 08             	mov    0x8(%ebp),%eax
    16ab:	88 10                	mov    %dl,(%eax)
        return;
    16ad:	e9 ed 00 00 00       	jmp    179f <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    16b2:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    16b6:	84 c0                	test   %al,%al
    16b8:	0f 84 e0 00 00 00    	je     179e <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    16be:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    16c2:	0f b6 c0             	movzbl %al,%eax
    16c5:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    16c9:	df 45 e4             	fild   -0x1c(%ebp)
    16cc:	d9 05 80 9d 01 00    	flds   0x19d80
    16d2:	de f9                	fdivrp %st,%st(1)
    16d4:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    16d7:	8b 45 08             	mov    0x8(%ebp),%eax
    16da:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    16de:	0f b6 c0             	movzbl %al,%eax
    16e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16e4:	db 45 e4             	fildl  -0x1c(%ebp)
    16e7:	d9 e8                	fld1   
    16e9:	d8 65 fc             	fsubs  -0x4(%ebp)
    16ec:	de c9                	fmulp  %st,%st(1)
    16ee:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    16f2:	0f b6 c0             	movzbl %al,%eax
    16f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16f8:	db 45 e4             	fildl  -0x1c(%ebp)
    16fb:	d8 4d fc             	fmuls  -0x4(%ebp)
    16fe:	de c1                	faddp  %st,%st(1)
    1700:	d9 7d ee             	fnstcw -0x12(%ebp)
    1703:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1707:	b4 0c                	mov    $0xc,%ah
    1709:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    170d:	d9 6d ec             	fldcw  -0x14(%ebp)
    1710:	df 5d ea             	fistp  -0x16(%ebp)
    1713:	d9 6d ee             	fldcw  -0x12(%ebp)
    1716:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    171a:	89 c2                	mov    %eax,%edx
    171c:	8b 45 08             	mov    0x8(%ebp),%eax
    171f:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1722:	8b 45 08             	mov    0x8(%ebp),%eax
    1725:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1729:	0f b6 c0             	movzbl %al,%eax
    172c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    172f:	db 45 e4             	fildl  -0x1c(%ebp)
    1732:	d9 e8                	fld1   
    1734:	d8 65 fc             	fsubs  -0x4(%ebp)
    1737:	de c9                	fmulp  %st,%st(1)
    1739:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    173d:	0f b6 c0             	movzbl %al,%eax
    1740:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1743:	db 45 e4             	fildl  -0x1c(%ebp)
    1746:	d8 4d fc             	fmuls  -0x4(%ebp)
    1749:	de c1                	faddp  %st,%st(1)
    174b:	d9 6d ec             	fldcw  -0x14(%ebp)
    174e:	df 5d ea             	fistp  -0x16(%ebp)
    1751:	d9 6d ee             	fldcw  -0x12(%ebp)
    1754:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1758:	89 c2                	mov    %eax,%edx
    175a:	8b 45 08             	mov    0x8(%ebp),%eax
    175d:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    1760:	8b 45 08             	mov    0x8(%ebp),%eax
    1763:	0f b6 00             	movzbl (%eax),%eax
    1766:	0f b6 c0             	movzbl %al,%eax
    1769:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    176c:	db 45 e4             	fildl  -0x1c(%ebp)
    176f:	d9 e8                	fld1   
    1771:	d8 65 fc             	fsubs  -0x4(%ebp)
    1774:	de c9                	fmulp  %st,%st(1)
    1776:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    177a:	0f b6 c0             	movzbl %al,%eax
    177d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1780:	db 45 e4             	fildl  -0x1c(%ebp)
    1783:	d8 4d fc             	fmuls  -0x4(%ebp)
    1786:	de c1                	faddp  %st,%st(1)
    1788:	d9 6d ec             	fldcw  -0x14(%ebp)
    178b:	df 5d ea             	fistp  -0x16(%ebp)
    178e:	d9 6d ee             	fldcw  -0x12(%ebp)
    1791:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1795:	89 c2                	mov    %eax,%edx
    1797:	8b 45 08             	mov    0x8(%ebp),%eax
    179a:	88 10                	mov    %dl,(%eax)
    179c:	eb 01                	jmp    179f <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    179e:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    179f:	c9                   	leave  
    17a0:	c3                   	ret    

000017a1 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    17a1:	55                   	push   %ebp
    17a2:	89 e5                	mov    %esp,%ebp
    17a4:	83 ec 14             	sub    $0x14,%esp
    17a7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    17aa:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    17ad:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    17b1:	83 e8 20             	sub    $0x20,%eax
    17b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    17b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    17bb:	0f 88 d7 00 00 00    	js     1898 <drawCharacter+0xf7>
    17c1:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    17c5:	0f 8f cd 00 00 00    	jg     1898 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    17cb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    17d2:	e9 b5 00 00 00       	jmp    188c <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    17d7:	8b 55 10             	mov    0x10(%ebp),%edx
    17da:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17dd:	01 c2                	add    %eax,%edx
    17df:	8b 45 14             	mov    0x14(%ebp),%eax
    17e2:	39 c2                	cmp    %eax,%edx
    17e4:	0f 8f af 00 00 00    	jg     1899 <drawCharacter+0xf8>
    17ea:	8b 55 10             	mov    0x10(%ebp),%edx
    17ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17f0:	01 d0                	add    %edx,%eax
    17f2:	85 c0                	test   %eax,%eax
    17f4:	0f 88 9f 00 00 00    	js     1899 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    17fa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1801:	eb 7b                	jmp    187e <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1803:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1806:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1809:	89 d0                	mov    %edx,%eax
    180b:	c1 e0 03             	shl    $0x3,%eax
    180e:	01 d0                	add    %edx,%eax
    1810:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1816:	01 c2                	add    %eax,%edx
    1818:	8b 45 f8             	mov    -0x8(%ebp),%eax
    181b:	01 d0                	add    %edx,%eax
    181d:	05 60 61 01 00       	add    $0x16160,%eax
    1822:	0f b6 00             	movzbl (%eax),%eax
    1825:	3c 01                	cmp    $0x1,%al
    1827:	75 51                	jne    187a <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1829:	8b 55 0c             	mov    0xc(%ebp),%edx
    182c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    182f:	01 c2                	add    %eax,%edx
    1831:	8b 45 18             	mov    0x18(%ebp),%eax
    1834:	39 c2                	cmp    %eax,%edx
    1836:	7f 50                	jg     1888 <drawCharacter+0xe7>
    1838:	8b 55 0c             	mov    0xc(%ebp),%edx
    183b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    183e:	01 d0                	add    %edx,%eax
    1840:	85 c0                	test   %eax,%eax
    1842:	78 44                	js     1888 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1844:	8b 55 10             	mov    0x10(%ebp),%edx
    1847:	8b 45 fc             	mov    -0x4(%ebp),%eax
    184a:	01 c2                	add    %eax,%edx
    184c:	8b 45 18             	mov    0x18(%ebp),%eax
    184f:	0f af c2             	imul   %edx,%eax
    1852:	89 c2                	mov    %eax,%edx
    1854:	8b 45 0c             	mov    0xc(%ebp),%eax
    1857:	01 c2                	add    %eax,%edx
    1859:	8b 45 f8             	mov    -0x8(%ebp),%eax
    185c:	01 c2                	add    %eax,%edx
    185e:	89 d0                	mov    %edx,%eax
    1860:	01 c0                	add    %eax,%eax
    1862:	01 c2                	add    %eax,%edx
    1864:	8b 45 08             	mov    0x8(%ebp),%eax
    1867:	01 d0                	add    %edx,%eax
    1869:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    186c:	ff 75 20             	pushl  0x20(%ebp)
    186f:	ff 75 f0             	pushl  -0x10(%ebp)
    1872:	e8 0b fe ff ff       	call   1682 <drawPointAlpha>
    1877:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    187a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    187e:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1882:	0f 8e 7b ff ff ff    	jle    1803 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1888:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    188c:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1890:	0f 8e 41 ff ff ff    	jle    17d7 <drawCharacter+0x36>
    1896:	eb 01                	jmp    1899 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1898:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1899:	c9                   	leave  
    189a:	c3                   	ret    

0000189b <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    189b:	55                   	push   %ebp
    189c:	89 e5                	mov    %esp,%ebp
    189e:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    18a1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    18a8:	eb 3d                	jmp    18e7 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    18aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    18ad:	0f b6 00             	movzbl (%eax),%eax
    18b0:	0f be c0             	movsbl %al,%eax
    18b3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    18b6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    18b9:	01 ca                	add    %ecx,%edx
    18bb:	89 55 f4             	mov    %edx,-0xc(%ebp)
    18be:	8b 55 10             	mov    0x10(%ebp),%edx
    18c1:	89 55 f8             	mov    %edx,-0x8(%ebp)
    18c4:	ff 75 20             	pushl  0x20(%ebp)
    18c7:	50                   	push   %eax
    18c8:	ff 75 18             	pushl  0x18(%ebp)
    18cb:	ff 75 14             	pushl  0x14(%ebp)
    18ce:	ff 75 f8             	pushl  -0x8(%ebp)
    18d1:	ff 75 f4             	pushl  -0xc(%ebp)
    18d4:	ff 75 08             	pushl  0x8(%ebp)
    18d7:	e8 c5 fe ff ff       	call   17a1 <drawCharacter>
    18dc:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    18df:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    18e3:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    18e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    18ea:	0f b6 00             	movzbl (%eax),%eax
    18ed:	84 c0                	test   %al,%al
    18ef:	75 b9                	jne    18aa <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    18f1:	90                   	nop
    18f2:	c9                   	leave  
    18f3:	c3                   	ret    

000018f4 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    18f4:	55                   	push   %ebp
    18f5:	89 e5                	mov    %esp,%ebp
    18f7:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    18fa:	8b 45 20             	mov    0x20(%ebp),%eax
    18fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1900:	8b 45 24             	mov    0x24(%ebp),%eax
    1903:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1906:	8b 55 14             	mov    0x14(%ebp),%edx
    1909:	8b 45 10             	mov    0x10(%ebp),%eax
    190c:	29 c2                	sub    %eax,%edx
    190e:	89 d0                	mov    %edx,%eax
    1910:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1913:	7d 0d                	jge    1922 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1915:	8b 55 14             	mov    0x14(%ebp),%edx
    1918:	8b 45 10             	mov    0x10(%ebp),%eax
    191b:	29 c2                	sub    %eax,%edx
    191d:	89 d0                	mov    %edx,%eax
    191f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1922:	8b 55 18             	mov    0x18(%ebp),%edx
    1925:	8b 45 0c             	mov    0xc(%ebp),%eax
    1928:	29 c2                	sub    %eax,%edx
    192a:	89 d0                	mov    %edx,%eax
    192c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    192f:	7d 0d                	jge    193e <drawRect+0x4a>
        draw_w = s.w - p.x;
    1931:	8b 55 18             	mov    0x18(%ebp),%edx
    1934:	8b 45 0c             	mov    0xc(%ebp),%eax
    1937:	29 c2                	sub    %eax,%edx
    1939:	89 d0                	mov    %edx,%eax
    193b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    193e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1945:	eb 52                	jmp    1999 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1947:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    194e:	eb 3d                	jmp    198d <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    1950:	8b 55 10             	mov    0x10(%ebp),%edx
    1953:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1956:	01 c2                	add    %eax,%edx
    1958:	8b 45 18             	mov    0x18(%ebp),%eax
    195b:	0f af c2             	imul   %edx,%eax
    195e:	89 c2                	mov    %eax,%edx
    1960:	8b 45 0c             	mov    0xc(%ebp),%eax
    1963:	01 c2                	add    %eax,%edx
    1965:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1968:	01 c2                	add    %eax,%edx
    196a:	89 d0                	mov    %edx,%eax
    196c:	01 c0                	add    %eax,%eax
    196e:	01 c2                	add    %eax,%edx
    1970:	8b 45 08             	mov    0x8(%ebp),%eax
    1973:	01 d0                	add    %edx,%eax
    1975:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1978:	8b 45 ec             	mov    -0x14(%ebp),%eax
    197b:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    197f:	66 89 10             	mov    %dx,(%eax)
    1982:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1986:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1989:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    198d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1990:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1993:	7c bb                	jl     1950 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1995:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1999:	8b 45 f4             	mov    -0xc(%ebp),%eax
    199c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    199f:	7c a6                	jl     1947 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    19a1:	90                   	nop
    19a2:	c9                   	leave  
    19a3:	c3                   	ret    

000019a4 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    19a4:	55                   	push   %ebp
    19a5:	89 e5                	mov    %esp,%ebp
    19a7:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    19aa:	8b 45 28             	mov    0x28(%ebp),%eax
    19ad:	89 45 c8             	mov    %eax,-0x38(%ebp)
    19b0:	8b 45 24             	mov    0x24(%ebp),%eax
    19b3:	89 45 cc             	mov    %eax,-0x34(%ebp)
    19b6:	ff 75 cc             	pushl  -0x34(%ebp)
    19b9:	ff 75 c8             	pushl  -0x38(%ebp)
    19bc:	83 ec 04             	sub    $0x4,%esp
    19bf:	89 e0                	mov    %esp,%eax
    19c1:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19c5:	66 89 10             	mov    %dx,(%eax)
    19c8:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19cc:	88 50 02             	mov    %dl,0x2(%eax)
    19cf:	ff 75 18             	pushl  0x18(%ebp)
    19d2:	ff 75 14             	pushl  0x14(%ebp)
    19d5:	ff 75 10             	pushl  0x10(%ebp)
    19d8:	ff 75 0c             	pushl  0xc(%ebp)
    19db:	ff 75 08             	pushl  0x8(%ebp)
    19de:	e8 11 ff ff ff       	call   18f4 <drawRect>
    19e3:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    19e6:	8b 45 28             	mov    0x28(%ebp),%eax
    19e9:	89 45 d0             	mov    %eax,-0x30(%ebp)
    19ec:	8b 45 24             	mov    0x24(%ebp),%eax
    19ef:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    19f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    19f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    19f8:	8b 55 10             	mov    0x10(%ebp),%edx
    19fb:	8b 45 20             	mov    0x20(%ebp),%eax
    19fe:	01 d0                	add    %edx,%eax
    1a00:	2b 45 28             	sub    0x28(%ebp),%eax
    1a03:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1a06:	ff 75 d4             	pushl  -0x2c(%ebp)
    1a09:	ff 75 d0             	pushl  -0x30(%ebp)
    1a0c:	83 ec 04             	sub    $0x4,%esp
    1a0f:	89 e0                	mov    %esp,%eax
    1a11:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a15:	66 89 10             	mov    %dx,(%eax)
    1a18:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a1c:	88 50 02             	mov    %dl,0x2(%eax)
    1a1f:	ff 75 18             	pushl  0x18(%ebp)
    1a22:	ff 75 14             	pushl  0x14(%ebp)
    1a25:	ff 75 dc             	pushl  -0x24(%ebp)
    1a28:	ff 75 d8             	pushl  -0x28(%ebp)
    1a2b:	ff 75 08             	pushl  0x8(%ebp)
    1a2e:	e8 c1 fe ff ff       	call   18f4 <drawRect>
    1a33:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1a36:	8b 45 20             	mov    0x20(%ebp),%eax
    1a39:	8b 55 28             	mov    0x28(%ebp),%edx
    1a3c:	01 d2                	add    %edx,%edx
    1a3e:	29 d0                	sub    %edx,%eax
    1a40:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1a43:	8b 45 28             	mov    0x28(%ebp),%eax
    1a46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a49:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a4c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1a4f:	8b 55 10             	mov    0x10(%ebp),%edx
    1a52:	8b 45 28             	mov    0x28(%ebp),%eax
    1a55:	01 d0                	add    %edx,%eax
    1a57:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1a5a:	ff 75 e4             	pushl  -0x1c(%ebp)
    1a5d:	ff 75 e0             	pushl  -0x20(%ebp)
    1a60:	83 ec 04             	sub    $0x4,%esp
    1a63:	89 e0                	mov    %esp,%eax
    1a65:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a69:	66 89 10             	mov    %dx,(%eax)
    1a6c:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a70:	88 50 02             	mov    %dl,0x2(%eax)
    1a73:	ff 75 18             	pushl  0x18(%ebp)
    1a76:	ff 75 14             	pushl  0x14(%ebp)
    1a79:	ff 75 ec             	pushl  -0x14(%ebp)
    1a7c:	ff 75 e8             	pushl  -0x18(%ebp)
    1a7f:	ff 75 08             	pushl  0x8(%ebp)
    1a82:	e8 6d fe ff ff       	call   18f4 <drawRect>
    1a87:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1a8a:	8b 45 20             	mov    0x20(%ebp),%eax
    1a8d:	8b 55 28             	mov    0x28(%ebp),%edx
    1a90:	01 d2                	add    %edx,%edx
    1a92:	29 d0                	sub    %edx,%eax
    1a94:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1a97:	8b 45 28             	mov    0x28(%ebp),%eax
    1a9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1a9d:	8b 55 0c             	mov    0xc(%ebp),%edx
    1aa0:	8b 45 24             	mov    0x24(%ebp),%eax
    1aa3:	01 d0                	add    %edx,%eax
    1aa5:	2b 45 28             	sub    0x28(%ebp),%eax
    1aa8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1aab:	8b 55 10             	mov    0x10(%ebp),%edx
    1aae:	8b 45 28             	mov    0x28(%ebp),%eax
    1ab1:	01 d0                	add    %edx,%eax
    1ab3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1ab6:	ff 75 f4             	pushl  -0xc(%ebp)
    1ab9:	ff 75 f0             	pushl  -0x10(%ebp)
    1abc:	83 ec 04             	sub    $0x4,%esp
    1abf:	89 e0                	mov    %esp,%eax
    1ac1:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1ac5:	66 89 10             	mov    %dx,(%eax)
    1ac8:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1acc:	88 50 02             	mov    %dl,0x2(%eax)
    1acf:	ff 75 18             	pushl  0x18(%ebp)
    1ad2:	ff 75 14             	pushl  0x14(%ebp)
    1ad5:	ff 75 fc             	pushl  -0x4(%ebp)
    1ad8:	ff 75 f8             	pushl  -0x8(%ebp)
    1adb:	ff 75 08             	pushl  0x8(%ebp)
    1ade:	e8 11 fe ff ff       	call   18f4 <drawRect>
    1ae3:	83 c4 20             	add    $0x20,%esp
}
    1ae6:	90                   	nop
    1ae7:	c9                   	leave  
    1ae8:	c3                   	ret    

00001ae9 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1ae9:	55                   	push   %ebp
    1aea:	89 e5                	mov    %esp,%ebp
    1aec:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1aef:	8b 45 30             	mov    0x30(%ebp),%eax
    1af2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1af5:	8b 45 34             	mov    0x34(%ebp),%eax
    1af8:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1afb:	8b 55 20             	mov    0x20(%ebp),%edx
    1afe:	8b 45 14             	mov    0x14(%ebp),%eax
    1b01:	29 c2                	sub    %eax,%edx
    1b03:	89 d0                	mov    %edx,%eax
    1b05:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b08:	7d 0d                	jge    1b17 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1b0a:	8b 55 20             	mov    0x20(%ebp),%edx
    1b0d:	8b 45 14             	mov    0x14(%ebp),%eax
    1b10:	29 c2                	sub    %eax,%edx
    1b12:	89 d0                	mov    %edx,%eax
    1b14:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1b17:	8b 55 28             	mov    0x28(%ebp),%edx
    1b1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b1d:	29 c2                	sub    %eax,%edx
    1b1f:	89 d0                	mov    %edx,%eax
    1b21:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b24:	7d 0d                	jge    1b33 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1b26:	8b 55 28             	mov    0x28(%ebp),%edx
    1b29:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b2c:	29 c2                	sub    %eax,%edx
    1b2e:	89 d0                	mov    %edx,%eax
    1b30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1b33:	8b 55 24             	mov    0x24(%ebp),%edx
    1b36:	8b 45 10             	mov    0x10(%ebp),%eax
    1b39:	29 c2                	sub    %eax,%edx
    1b3b:	89 d0                	mov    %edx,%eax
    1b3d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1b40:	7d 0d                	jge    1b4f <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1b42:	8b 55 24             	mov    0x24(%ebp),%edx
    1b45:	8b 45 10             	mov    0x10(%ebp),%eax
    1b48:	29 c2                	sub    %eax,%edx
    1b4a:	89 d0                	mov    %edx,%eax
    1b4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1b4f:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1b52:	8b 45 18             	mov    0x18(%ebp),%eax
    1b55:	29 c2                	sub    %eax,%edx
    1b57:	89 d0                	mov    %edx,%eax
    1b59:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1b5c:	7d 0d                	jge    1b6b <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1b5e:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1b61:	8b 45 18             	mov    0x18(%ebp),%eax
    1b64:	29 c2                	sub    %eax,%edx
    1b66:	89 d0                	mov    %edx,%eax
    1b68:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1b6b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1b72:	e9 83 00 00 00       	jmp    1bfa <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1b77:	8b 55 14             	mov    0x14(%ebp),%edx
    1b7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b7d:	01 d0                	add    %edx,%eax
    1b7f:	85 c0                	test   %eax,%eax
    1b81:	78 72                	js     1bf5 <drawBitmap+0x10c>
    1b83:	8b 55 14             	mov    0x14(%ebp),%edx
    1b86:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b89:	01 c2                	add    %eax,%edx
    1b8b:	8b 45 20             	mov    0x20(%ebp),%eax
    1b8e:	39 c2                	cmp    %eax,%edx
    1b90:	7d 63                	jge    1bf5 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1b92:	8b 55 14             	mov    0x14(%ebp),%edx
    1b95:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b98:	01 c2                	add    %eax,%edx
    1b9a:	8b 45 24             	mov    0x24(%ebp),%eax
    1b9d:	0f af c2             	imul   %edx,%eax
    1ba0:	89 c2                	mov    %eax,%edx
    1ba2:	8b 45 10             	mov    0x10(%ebp),%eax
    1ba5:	01 c2                	add    %eax,%edx
    1ba7:	89 d0                	mov    %edx,%eax
    1ba9:	01 c0                	add    %eax,%eax
    1bab:	01 c2                	add    %eax,%edx
    1bad:	8b 45 08             	mov    0x8(%ebp),%eax
    1bb0:	01 d0                	add    %edx,%eax
    1bb2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1bb5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1bb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bbb:	01 c2                	add    %eax,%edx
    1bbd:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1bc0:	0f af c2             	imul   %edx,%eax
    1bc3:	89 c2                	mov    %eax,%edx
    1bc5:	8b 45 18             	mov    0x18(%ebp),%eax
    1bc8:	01 c2                	add    %eax,%edx
    1bca:	89 d0                	mov    %edx,%eax
    1bcc:	01 c0                	add    %eax,%eax
    1bce:	01 c2                	add    %eax,%edx
    1bd0:	8b 45 0c             	mov    0xc(%ebp),%eax
    1bd3:	01 d0                	add    %edx,%eax
    1bd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1bd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1bdb:	89 d0                	mov    %edx,%eax
    1bdd:	01 c0                	add    %eax,%eax
    1bdf:	01 d0                	add    %edx,%eax
    1be1:	83 ec 04             	sub    $0x4,%esp
    1be4:	50                   	push   %eax
    1be5:	ff 75 e4             	pushl  -0x1c(%ebp)
    1be8:	ff 75 e8             	pushl  -0x18(%ebp)
    1beb:	e8 23 e7 ff ff       	call   313 <memmove>
    1bf0:	83 c4 10             	add    $0x10,%esp
    1bf3:	eb 01                	jmp    1bf6 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1bf5:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1bf6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1bfa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bfd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1c00:	0f 8c 71 ff ff ff    	jl     1b77 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1c06:	90                   	nop
    1c07:	c9                   	leave  
    1c08:	c3                   	ret    

00001c09 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1c09:	55                   	push   %ebp
    1c0a:	89 e5                	mov    %esp,%ebp
    1c0c:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1c0f:	8b 45 30             	mov    0x30(%ebp),%eax
    1c12:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1c15:	8b 45 34             	mov    0x34(%ebp),%eax
    1c18:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1c1b:	8b 55 20             	mov    0x20(%ebp),%edx
    1c1e:	8b 45 14             	mov    0x14(%ebp),%eax
    1c21:	29 c2                	sub    %eax,%edx
    1c23:	89 d0                	mov    %edx,%eax
    1c25:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1c28:	7d 0d                	jge    1c37 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1c2a:	8b 55 20             	mov    0x20(%ebp),%edx
    1c2d:	8b 45 14             	mov    0x14(%ebp),%eax
    1c30:	29 c2                	sub    %eax,%edx
    1c32:	89 d0                	mov    %edx,%eax
    1c34:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1c37:	8b 55 28             	mov    0x28(%ebp),%edx
    1c3a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c3d:	29 c2                	sub    %eax,%edx
    1c3f:	89 d0                	mov    %edx,%eax
    1c41:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1c44:	7d 0d                	jge    1c53 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1c46:	8b 55 28             	mov    0x28(%ebp),%edx
    1c49:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c4c:	29 c2                	sub    %eax,%edx
    1c4e:	89 d0                	mov    %edx,%eax
    1c50:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1c53:	8b 55 24             	mov    0x24(%ebp),%edx
    1c56:	8b 45 10             	mov    0x10(%ebp),%eax
    1c59:	29 c2                	sub    %eax,%edx
    1c5b:	89 d0                	mov    %edx,%eax
    1c5d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1c60:	7d 0d                	jge    1c6f <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1c62:	8b 55 24             	mov    0x24(%ebp),%edx
    1c65:	8b 45 10             	mov    0x10(%ebp),%eax
    1c68:	29 c2                	sub    %eax,%edx
    1c6a:	89 d0                	mov    %edx,%eax
    1c6c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1c6f:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c72:	8b 45 18             	mov    0x18(%ebp),%eax
    1c75:	29 c2                	sub    %eax,%edx
    1c77:	89 d0                	mov    %edx,%eax
    1c79:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1c7c:	7d 0d                	jge    1c8b <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1c7e:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c81:	8b 45 18             	mov    0x18(%ebp),%eax
    1c84:	29 c2                	sub    %eax,%edx
    1c86:	89 d0                	mov    %edx,%eax
    1c88:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1c8b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1c92:	e9 b8 00 00 00       	jmp    1d4f <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1c97:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1c9e:	e9 9c 00 00 00       	jmp    1d3f <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1ca3:	8b 55 14             	mov    0x14(%ebp),%edx
    1ca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ca9:	01 c2                	add    %eax,%edx
    1cab:	8b 45 24             	mov    0x24(%ebp),%eax
    1cae:	0f af c2             	imul   %edx,%eax
    1cb1:	89 c2                	mov    %eax,%edx
    1cb3:	8b 45 10             	mov    0x10(%ebp),%eax
    1cb6:	01 c2                	add    %eax,%edx
    1cb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1cbb:	01 c2                	add    %eax,%edx
    1cbd:	89 d0                	mov    %edx,%eax
    1cbf:	01 c0                	add    %eax,%eax
    1cc1:	01 c2                	add    %eax,%edx
    1cc3:	8b 45 08             	mov    0x8(%ebp),%eax
    1cc6:	01 d0                	add    %edx,%eax
    1cc8:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1ccb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1cce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1cd1:	01 c2                	add    %eax,%edx
    1cd3:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1cd6:	0f af c2             	imul   %edx,%eax
    1cd9:	89 c2                	mov    %eax,%edx
    1cdb:	8b 45 18             	mov    0x18(%ebp),%eax
    1cde:	01 c2                	add    %eax,%edx
    1ce0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ce3:	01 c2                	add    %eax,%edx
    1ce5:	89 d0                	mov    %edx,%eax
    1ce7:	01 c0                	add    %eax,%eax
    1ce9:	01 c2                	add    %eax,%edx
    1ceb:	8b 45 0c             	mov    0xc(%ebp),%eax
    1cee:	01 d0                	add    %edx,%eax
    1cf0:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1cf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1cf6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1cfa:	3c ff                	cmp    $0xff,%al
    1cfc:	75 15                	jne    1d13 <drawTransparentBitmap+0x10a>
    1cfe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d01:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1d05:	3c ff                	cmp    $0xff,%al
    1d07:	75 0a                	jne    1d13 <drawTransparentBitmap+0x10a>
    1d09:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d0c:	0f b6 00             	movzbl (%eax),%eax
    1d0f:	3c ff                	cmp    $0xff,%al
    1d11:	74 27                	je     1d3a <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1d13:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d16:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1d1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d1d:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1d20:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d23:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1d27:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d2a:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1d2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d30:	0f b6 10             	movzbl (%eax),%edx
    1d33:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d36:	88 10                	mov    %dl,(%eax)
    1d38:	eb 01                	jmp    1d3b <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1d3a:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1d3b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1d3f:	8b 45 34             	mov    0x34(%ebp),%eax
    1d42:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1d45:	0f 8f 58 ff ff ff    	jg     1ca3 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1d4b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1d4f:	8b 45 30             	mov    0x30(%ebp),%eax
    1d52:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1d55:	0f 8f 3c ff ff ff    	jg     1c97 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1d5b:	90                   	nop
    1d5c:	c9                   	leave  
    1d5d:	c3                   	ret    

00001d5e <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1d5e:	55                   	push   %ebp
    1d5f:	89 e5                	mov    %esp,%ebp
    1d61:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1d64:	ff 75 24             	pushl  0x24(%ebp)
    1d67:	ff 75 20             	pushl  0x20(%ebp)
    1d6a:	ff 75 1c             	pushl  0x1c(%ebp)
    1d6d:	ff 75 18             	pushl  0x18(%ebp)
    1d70:	ff 75 1c             	pushl  0x1c(%ebp)
    1d73:	ff 75 18             	pushl  0x18(%ebp)
    1d76:	ff 75 14             	pushl  0x14(%ebp)
    1d79:	ff 75 10             	pushl  0x10(%ebp)
    1d7c:	ff 75 14             	pushl  0x14(%ebp)
    1d7f:	ff 75 10             	pushl  0x10(%ebp)
    1d82:	ff 75 0c             	pushl  0xc(%ebp)
    1d85:	ff 75 08             	pushl  0x8(%ebp)
    1d88:	e8 5c fd ff ff       	call   1ae9 <drawBitmap>
    1d8d:	83 c4 30             	add    $0x30,%esp
}
    1d90:	90                   	nop
    1d91:	c9                   	leave  
    1d92:	c3                   	ret    

00001d93 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1d93:	55                   	push   %ebp
    1d94:	89 e5                	mov    %esp,%ebp
    1d96:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1d99:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1d9f:	8b 45 20             	mov    0x20(%ebp),%eax
    1da2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1da5:	8b 55 14             	mov    0x14(%ebp),%edx
    1da8:	8b 45 10             	mov    0x10(%ebp),%eax
    1dab:	29 c2                	sub    %eax,%edx
    1dad:	89 d0                	mov    %edx,%eax
    1daf:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1db2:	7d 0d                	jge    1dc1 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1db4:	8b 55 14             	mov    0x14(%ebp),%edx
    1db7:	8b 45 10             	mov    0x10(%ebp),%eax
    1dba:	29 c2                	sub    %eax,%edx
    1dbc:	89 d0                	mov    %edx,%eax
    1dbe:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1dc1:	8b 55 18             	mov    0x18(%ebp),%edx
    1dc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    1dc7:	29 c2                	sub    %eax,%edx
    1dc9:	89 d0                	mov    %edx,%eax
    1dcb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1dce:	7d 0d                	jge    1ddd <colorShift+0x4a>
        draw_w = s.w - p.x;
    1dd0:	8b 55 18             	mov    0x18(%ebp),%edx
    1dd3:	8b 45 0c             	mov    0xc(%ebp),%eax
    1dd6:	29 c2                	sub    %eax,%edx
    1dd8:	89 d0                	mov    %edx,%eax
    1dda:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1ddd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1de4:	e9 fc 00 00 00       	jmp    1ee5 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1de9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1df0:	e9 e0 00 00 00       	jmp    1ed5 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1df5:	8b 55 10             	mov    0x10(%ebp),%edx
    1df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1dfb:	01 c2                	add    %eax,%edx
    1dfd:	8b 45 18             	mov    0x18(%ebp),%eax
    1e00:	0f af c2             	imul   %edx,%eax
    1e03:	89 c2                	mov    %eax,%edx
    1e05:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e08:	01 c2                	add    %eax,%edx
    1e0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e0d:	01 c2                	add    %eax,%edx
    1e0f:	89 d0                	mov    %edx,%eax
    1e11:	01 c0                	add    %eax,%eax
    1e13:	01 c2                	add    %eax,%edx
    1e15:	8b 45 08             	mov    0x8(%ebp),%eax
    1e18:	01 d0                	add    %edx,%eax
    1e1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1e1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e20:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1e24:	3c c8                	cmp    $0xc8,%al
    1e26:	0f 86 a5 00 00 00    	jbe    1ed1 <colorShift+0x13e>
    1e2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e2f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1e33:	3c c8                	cmp    $0xc8,%al
    1e35:	0f 86 96 00 00 00    	jbe    1ed1 <colorShift+0x13e>
    1e3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e3e:	0f b6 00             	movzbl (%eax),%eax
    1e41:	3c c8                	cmp    $0xc8,%al
    1e43:	0f 86 88 00 00 00    	jbe    1ed1 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1e49:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e4c:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1e50:	0f b6 d0             	movzbl %al,%edx
    1e53:	8b 45 24             	mov    0x24(%ebp),%eax
    1e56:	01 d0                	add    %edx,%eax
    1e58:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e5e:	89 d0                	mov    %edx,%eax
    1e60:	c1 f8 1f             	sar    $0x1f,%eax
    1e63:	c1 e8 18             	shr    $0x18,%eax
    1e66:	01 c2                	add    %eax,%edx
    1e68:	0f b6 d2             	movzbl %dl,%edx
    1e6b:	29 c2                	sub    %eax,%edx
    1e6d:	89 d0                	mov    %edx,%eax
    1e6f:	89 c2                	mov    %eax,%edx
    1e71:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e74:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1e77:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e7a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1e7e:	0f b6 d0             	movzbl %al,%edx
    1e81:	8b 45 24             	mov    0x24(%ebp),%eax
    1e84:	01 d0                	add    %edx,%eax
    1e86:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e8c:	89 d0                	mov    %edx,%eax
    1e8e:	c1 f8 1f             	sar    $0x1f,%eax
    1e91:	c1 e8 18             	shr    $0x18,%eax
    1e94:	01 c2                	add    %eax,%edx
    1e96:	0f b6 d2             	movzbl %dl,%edx
    1e99:	29 c2                	sub    %eax,%edx
    1e9b:	89 d0                	mov    %edx,%eax
    1e9d:	89 c2                	mov    %eax,%edx
    1e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ea2:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1ea5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ea8:	0f b6 00             	movzbl (%eax),%eax
    1eab:	0f b6 d0             	movzbl %al,%edx
    1eae:	8b 45 24             	mov    0x24(%ebp),%eax
    1eb1:	01 d0                	add    %edx,%eax
    1eb3:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1eb9:	89 d0                	mov    %edx,%eax
    1ebb:	c1 f8 1f             	sar    $0x1f,%eax
    1ebe:	c1 e8 18             	shr    $0x18,%eax
    1ec1:	01 c2                	add    %eax,%edx
    1ec3:	0f b6 d2             	movzbl %dl,%edx
    1ec6:	29 c2                	sub    %eax,%edx
    1ec8:	89 d0                	mov    %edx,%eax
    1eca:	89 c2                	mov    %eax,%edx
    1ecc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ecf:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1ed1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1ed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ed8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1edb:	0f 8c 14 ff ff ff    	jl     1df5 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1ee1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1ee5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ee8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1eeb:	0f 8c f8 fe ff ff    	jl     1de9 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1ef1:	90                   	nop
    1ef2:	c9                   	leave  
    1ef3:	c3                   	ret    

00001ef4 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1ef4:	55                   	push   %ebp
    1ef5:	89 e5                	mov    %esp,%ebp
    1ef7:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1efa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1f01:	e9 fb 00 00 00       	jmp    2001 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1f06:	8b 55 14             	mov    0x14(%ebp),%edx
    1f09:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f0c:	01 c2                	add    %eax,%edx
    1f0e:	0f b7 05 16 e6 01 00 	movzwl 0x1e616,%eax
    1f15:	0f b7 c0             	movzwl %ax,%eax
    1f18:	39 c2                	cmp    %eax,%edx
    1f1a:	0f 8f eb 00 00 00    	jg     200b <drawMouse+0x117>
    1f20:	8b 55 14             	mov    0x14(%ebp),%edx
    1f23:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f26:	01 d0                	add    %edx,%eax
    1f28:	85 c0                	test   %eax,%eax
    1f2a:	0f 88 db 00 00 00    	js     200b <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f30:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1f37:	e9 b7 00 00 00       	jmp    1ff3 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1f3c:	8b 55 10             	mov    0x10(%ebp),%edx
    1f3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f42:	01 c2                	add    %eax,%edx
    1f44:	0f b7 05 14 e6 01 00 	movzwl 0x1e614,%eax
    1f4b:	0f b7 c0             	movzwl %ax,%eax
    1f4e:	39 c2                	cmp    %eax,%edx
    1f50:	0f 8f a7 00 00 00    	jg     1ffd <drawMouse+0x109>
    1f56:	8b 55 10             	mov    0x10(%ebp),%edx
    1f59:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f5c:	01 d0                	add    %edx,%eax
    1f5e:	85 c0                	test   %eax,%eax
    1f60:	0f 88 97 00 00 00    	js     1ffd <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1f66:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1f69:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1f6c:	89 d0                	mov    %edx,%eax
    1f6e:	c1 e0 04             	shl    $0x4,%eax
    1f71:	29 d0                	sub    %edx,%eax
    1f73:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1f79:	01 c2                	add    %eax,%edx
    1f7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f7e:	01 d0                	add    %edx,%eax
    1f80:	05 40 5f 01 00       	add    $0x15f40,%eax
    1f85:	0f b6 00             	movzbl (%eax),%eax
    1f88:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1f8b:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1f8f:	74 5e                	je     1fef <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1f91:	8b 55 14             	mov    0x14(%ebp),%edx
    1f94:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f97:	01 c2                	add    %eax,%edx
    1f99:	0f b7 05 14 e6 01 00 	movzwl 0x1e614,%eax
    1fa0:	0f b7 c0             	movzwl %ax,%eax
    1fa3:	0f af c2             	imul   %edx,%eax
    1fa6:	89 c2                	mov    %eax,%edx
    1fa8:	8b 45 10             	mov    0x10(%ebp),%eax
    1fab:	01 c2                	add    %eax,%edx
    1fad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1fb0:	01 c2                	add    %eax,%edx
    1fb2:	89 d0                	mov    %edx,%eax
    1fb4:	01 c0                	add    %eax,%eax
    1fb6:	01 c2                	add    %eax,%edx
    1fb8:	8b 45 08             	mov    0x8(%ebp),%eax
    1fbb:	01 d0                	add    %edx,%eax
    1fbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    1fc0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    1fc4:	8d 50 ff             	lea    -0x1(%eax),%edx
    1fc7:	89 d0                	mov    %edx,%eax
    1fc9:	01 c0                	add    %eax,%eax
    1fcb:	01 d0                	add    %edx,%eax
    1fcd:	05 1c e6 01 00       	add    $0x1e61c,%eax
    1fd2:	83 ec 04             	sub    $0x4,%esp
    1fd5:	89 e2                	mov    %esp,%edx
    1fd7:	0f b7 08             	movzwl (%eax),%ecx
    1fda:	66 89 0a             	mov    %cx,(%edx)
    1fdd:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1fe1:	88 42 02             	mov    %al,0x2(%edx)
    1fe4:	ff 75 f0             	pushl  -0x10(%ebp)
    1fe7:	e8 73 f6 ff ff       	call   165f <drawPoint>
    1fec:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1fef:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1ff3:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    1ff7:	0f 8e 3f ff ff ff    	jle    1f3c <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1ffd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2001:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    2005:	0f 8e fb fe ff ff    	jle    1f06 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    200b:	90                   	nop
    200c:	c9                   	leave  
    200d:	c3                   	ret    

0000200e <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    200e:	55                   	push   %ebp
    200f:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    2011:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    2015:	78 1b                	js     2032 <getColor+0x24>
    2017:	8b 45 08             	mov    0x8(%ebp),%eax
    201a:	8b 40 04             	mov    0x4(%eax),%eax
    201d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2020:	7c 10                	jl     2032 <getColor+0x24>
    2022:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    2026:	78 0a                	js     2032 <getColor+0x24>
    2028:	8b 45 08             	mov    0x8(%ebp),%eax
    202b:	8b 00                	mov    (%eax),%eax
    202d:	3b 45 10             	cmp    0x10(%ebp),%eax
    2030:	7d 10                	jge    2042 <getColor+0x34>
    {
        *isInPic = 1;
    2032:	8b 45 14             	mov    0x14(%ebp),%eax
    2035:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    203b:	b8 d9 e1 01 00       	mov    $0x1e1d9,%eax
    2040:	eb 44                	jmp    2086 <getColor+0x78>
    }

    if (y == pic->height)
    2042:	8b 45 08             	mov    0x8(%ebp),%eax
    2045:	8b 40 04             	mov    0x4(%eax),%eax
    2048:	3b 45 0c             	cmp    0xc(%ebp),%eax
    204b:	75 04                	jne    2051 <getColor+0x43>
        y--;
    204d:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    2051:	8b 45 08             	mov    0x8(%ebp),%eax
    2054:	8b 00                	mov    (%eax),%eax
    2056:	3b 45 10             	cmp    0x10(%ebp),%eax
    2059:	75 04                	jne    205f <getColor+0x51>
        x--;
    205b:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    205f:	8b 45 14             	mov    0x14(%ebp),%eax
    2062:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    2068:	8b 45 08             	mov    0x8(%ebp),%eax
    206b:	8b 48 08             	mov    0x8(%eax),%ecx
    206e:	8b 45 08             	mov    0x8(%ebp),%eax
    2071:	8b 00                	mov    (%eax),%eax
    2073:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2077:	89 c2                	mov    %eax,%edx
    2079:	8b 45 10             	mov    0x10(%ebp),%eax
    207c:	01 c2                	add    %eax,%edx
    207e:	89 d0                	mov    %edx,%eax
    2080:	01 c0                	add    %eax,%eax
    2082:	01 d0                	add    %edx,%eax
    2084:	01 c8                	add    %ecx,%eax
}
    2086:	5d                   	pop    %ebp
    2087:	c3                   	ret    

00002088 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    2088:	55                   	push   %ebp
    2089:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    208b:	8b 45 08             	mov    0x8(%ebp),%eax
    208e:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2092:	8b 45 0c             	mov    0xc(%ebp),%eax
    2095:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    2098:	8b 45 08             	mov    0x8(%ebp),%eax
    209b:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    209f:	8b 45 0c             	mov    0xc(%ebp),%eax
    20a2:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    20a5:	8b 45 08             	mov    0x8(%ebp),%eax
    20a8:	0f b6 10             	movzbl (%eax),%edx
    20ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    20ae:	88 10                	mov    %dl,(%eax)

    return 1;
    20b0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    20b5:	5d                   	pop    %ebp
    20b6:	c3                   	ret    

000020b7 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    20b7:	55                   	push   %ebp
    20b8:	89 e5                	mov    %esp,%ebp
    20ba:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    20bd:	d9 45 10             	flds   0x10(%ebp)
    20c0:	d9 7d be             	fnstcw -0x42(%ebp)
    20c3:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    20c7:	b4 0c                	mov    $0xc,%ah
    20c9:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    20cd:	d9 6d bc             	fldcw  -0x44(%ebp)
    20d0:	db 5d fc             	fistpl -0x4(%ebp)
    20d3:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    20d6:	d9 45 0c             	flds   0xc(%ebp)
    20d9:	d9 6d bc             	fldcw  -0x44(%ebp)
    20dc:	db 5d f8             	fistpl -0x8(%ebp)
    20df:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    20e2:	db 45 fc             	fildl  -0x4(%ebp)
    20e5:	d9 45 10             	flds   0x10(%ebp)
    20e8:	d9 c9                	fxch   %st(1)
    20ea:	df e9                	fucomip %st(1),%st
    20ec:	dd d8                	fstp   %st(0)
    20ee:	76 04                	jbe    20f4 <mixColor+0x3d>
        x--;
    20f0:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    20f4:	db 45 f8             	fildl  -0x8(%ebp)
    20f7:	d9 45 0c             	flds   0xc(%ebp)
    20fa:	d9 c9                	fxch   %st(1)
    20fc:	df e9                	fucomip %st(1),%st
    20fe:	dd d8                	fstp   %st(0)
    2100:	76 04                	jbe    2106 <mixColor+0x4f>
        y--;
    2102:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2106:	8d 45 c0             	lea    -0x40(%ebp),%eax
    2109:	50                   	push   %eax
    210a:	ff 75 fc             	pushl  -0x4(%ebp)
    210d:	ff 75 f8             	pushl  -0x8(%ebp)
    2110:	ff 75 08             	pushl  0x8(%ebp)
    2113:	e8 f6 fe ff ff       	call   200e <getColor>
    2118:	83 c4 10             	add    $0x10,%esp
    211b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    211e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2121:	83 c0 01             	add    $0x1,%eax
    2124:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2127:	83 c2 04             	add    $0x4,%edx
    212a:	52                   	push   %edx
    212b:	ff 75 fc             	pushl  -0x4(%ebp)
    212e:	50                   	push   %eax
    212f:	ff 75 08             	pushl  0x8(%ebp)
    2132:	e8 d7 fe ff ff       	call   200e <getColor>
    2137:	83 c4 10             	add    $0x10,%esp
    213a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    213d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2140:	83 c0 01             	add    $0x1,%eax
    2143:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2146:	83 c2 08             	add    $0x8,%edx
    2149:	52                   	push   %edx
    214a:	50                   	push   %eax
    214b:	ff 75 f8             	pushl  -0x8(%ebp)
    214e:	ff 75 08             	pushl  0x8(%ebp)
    2151:	e8 b8 fe ff ff       	call   200e <getColor>
    2156:	83 c4 10             	add    $0x10,%esp
    2159:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    215c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    215f:	8d 50 01             	lea    0x1(%eax),%edx
    2162:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2165:	83 c0 01             	add    $0x1,%eax
    2168:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    216b:	83 c1 0c             	add    $0xc,%ecx
    216e:	51                   	push   %ecx
    216f:	52                   	push   %edx
    2170:	50                   	push   %eax
    2171:	ff 75 08             	pushl  0x8(%ebp)
    2174:	e8 95 fe ff ff       	call   200e <getColor>
    2179:	83 c4 10             	add    $0x10,%esp
    217c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    217f:	db 45 fc             	fildl  -0x4(%ebp)
    2182:	d9 45 10             	flds   0x10(%ebp)
    2185:	de e1                	fsubp  %st,%st(1)
    2187:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    218a:	db 45 f8             	fildl  -0x8(%ebp)
    218d:	d9 45 0c             	flds   0xc(%ebp)
    2190:	de e1                	fsubp  %st,%st(1)
    2192:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2195:	d9 45 e4             	flds   -0x1c(%ebp)
    2198:	d8 4d e0             	fmuls  -0x20(%ebp)
    219b:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    219e:	d9 e8                	fld1   
    21a0:	d8 65 e0             	fsubs  -0x20(%ebp)
    21a3:	d8 4d e4             	fmuls  -0x1c(%ebp)
    21a6:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    21a9:	d9 e8                	fld1   
    21ab:	d8 65 e4             	fsubs  -0x1c(%ebp)
    21ae:	d8 4d e0             	fmuls  -0x20(%ebp)
    21b1:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    21b4:	d9 e8                	fld1   
    21b6:	d8 65 e4             	fsubs  -0x1c(%ebp)
    21b9:	d9 e8                	fld1   
    21bb:	d8 65 e0             	fsubs  -0x20(%ebp)
    21be:	de c9                	fmulp  %st,%st(1)
    21c0:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    21c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21c6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    21ca:	0f b6 c0             	movzbl %al,%eax
    21cd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21d0:	db 45 b4             	fildl  -0x4c(%ebp)
    21d3:	d8 4d d0             	fmuls  -0x30(%ebp)
    21d6:	8b 45 c0             	mov    -0x40(%ebp),%eax
    21d9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21dc:	db 45 b4             	fildl  -0x4c(%ebp)
    21df:	de c9                	fmulp  %st,%st(1)
    21e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21e4:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    21e8:	0f b6 c0             	movzbl %al,%eax
    21eb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21ee:	db 45 b4             	fildl  -0x4c(%ebp)
    21f1:	d8 4d d4             	fmuls  -0x2c(%ebp)
    21f4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    21f7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21fa:	db 45 b4             	fildl  -0x4c(%ebp)
    21fd:	de c9                	fmulp  %st,%st(1)
    21ff:	de c1                	faddp  %st,%st(1)
    2201:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2204:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2208:	0f b6 c0             	movzbl %al,%eax
    220b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    220e:	db 45 b4             	fildl  -0x4c(%ebp)
    2211:	d8 4d d8             	fmuls  -0x28(%ebp)
    2214:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2217:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    221a:	db 45 b4             	fildl  -0x4c(%ebp)
    221d:	de c9                	fmulp  %st,%st(1)
    221f:	de c1                	faddp  %st,%st(1)
    2221:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2224:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2228:	0f b6 c0             	movzbl %al,%eax
    222b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    222e:	db 45 b4             	fildl  -0x4c(%ebp)
    2231:	d8 4d dc             	fmuls  -0x24(%ebp)
    2234:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2237:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    223a:	db 45 b4             	fildl  -0x4c(%ebp)
    223d:	de c9                	fmulp  %st,%st(1)
    223f:	de c1                	faddp  %st,%st(1)
    2241:	d9 7d be             	fnstcw -0x42(%ebp)
    2244:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2248:	b4 0c                	mov    $0xc,%ah
    224a:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    224e:	d9 6d bc             	fldcw  -0x44(%ebp)
    2251:	db 5d b8             	fistpl -0x48(%ebp)
    2254:	d9 6d be             	fldcw  -0x42(%ebp)
    2257:	8b 45 b8             	mov    -0x48(%ebp),%eax
    225a:	89 c2                	mov    %eax,%edx
    225c:	8b 45 14             	mov    0x14(%ebp),%eax
    225f:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    2262:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2265:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2269:	0f b6 c0             	movzbl %al,%eax
    226c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    226f:	db 45 b4             	fildl  -0x4c(%ebp)
    2272:	d8 4d d0             	fmuls  -0x30(%ebp)
    2275:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2278:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    227b:	db 45 b4             	fildl  -0x4c(%ebp)
    227e:	de c9                	fmulp  %st,%st(1)
    2280:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2283:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2287:	0f b6 c0             	movzbl %al,%eax
    228a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    228d:	db 45 b4             	fildl  -0x4c(%ebp)
    2290:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2293:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2296:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2299:	db 45 b4             	fildl  -0x4c(%ebp)
    229c:	de c9                	fmulp  %st,%st(1)
    229e:	de c1                	faddp  %st,%st(1)
    22a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    22a3:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    22a7:	0f b6 c0             	movzbl %al,%eax
    22aa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ad:	db 45 b4             	fildl  -0x4c(%ebp)
    22b0:	d8 4d d8             	fmuls  -0x28(%ebp)
    22b3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    22b6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22b9:	db 45 b4             	fildl  -0x4c(%ebp)
    22bc:	de c9                	fmulp  %st,%st(1)
    22be:	de c1                	faddp  %st,%st(1)
    22c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    22c3:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    22c7:	0f b6 c0             	movzbl %al,%eax
    22ca:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22cd:	db 45 b4             	fildl  -0x4c(%ebp)
    22d0:	d8 4d dc             	fmuls  -0x24(%ebp)
    22d3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    22d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22d9:	db 45 b4             	fildl  -0x4c(%ebp)
    22dc:	de c9                	fmulp  %st,%st(1)
    22de:	de c1                	faddp  %st,%st(1)
    22e0:	d9 6d bc             	fldcw  -0x44(%ebp)
    22e3:	db 5d b8             	fistpl -0x48(%ebp)
    22e6:	d9 6d be             	fldcw  -0x42(%ebp)
    22e9:	8b 45 b8             	mov    -0x48(%ebp),%eax
    22ec:	89 c2                	mov    %eax,%edx
    22ee:	8b 45 14             	mov    0x14(%ebp),%eax
    22f1:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    22f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    22f7:	0f b6 00             	movzbl (%eax),%eax
    22fa:	0f b6 c0             	movzbl %al,%eax
    22fd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2300:	db 45 b4             	fildl  -0x4c(%ebp)
    2303:	d8 4d d0             	fmuls  -0x30(%ebp)
    2306:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2309:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    230c:	db 45 b4             	fildl  -0x4c(%ebp)
    230f:	de c9                	fmulp  %st,%st(1)
    2311:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2314:	0f b6 00             	movzbl (%eax),%eax
    2317:	0f b6 c0             	movzbl %al,%eax
    231a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    231d:	db 45 b4             	fildl  -0x4c(%ebp)
    2320:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2323:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2326:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2329:	db 45 b4             	fildl  -0x4c(%ebp)
    232c:	de c9                	fmulp  %st,%st(1)
    232e:	de c1                	faddp  %st,%st(1)
    2330:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2333:	0f b6 00             	movzbl (%eax),%eax
    2336:	0f b6 c0             	movzbl %al,%eax
    2339:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    233c:	db 45 b4             	fildl  -0x4c(%ebp)
    233f:	d8 4d d8             	fmuls  -0x28(%ebp)
    2342:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2345:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2348:	db 45 b4             	fildl  -0x4c(%ebp)
    234b:	de c9                	fmulp  %st,%st(1)
    234d:	de c1                	faddp  %st,%st(1)
    234f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2352:	0f b6 00             	movzbl (%eax),%eax
    2355:	0f b6 c0             	movzbl %al,%eax
    2358:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    235b:	db 45 b4             	fildl  -0x4c(%ebp)
    235e:	d8 4d dc             	fmuls  -0x24(%ebp)
    2361:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2364:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2367:	db 45 b4             	fildl  -0x4c(%ebp)
    236a:	de c9                	fmulp  %st,%st(1)
    236c:	de c1                	faddp  %st,%st(1)
    236e:	d9 6d bc             	fldcw  -0x44(%ebp)
    2371:	db 5d b8             	fistpl -0x48(%ebp)
    2374:	d9 6d be             	fldcw  -0x42(%ebp)
    2377:	8b 45 b8             	mov    -0x48(%ebp),%eax
    237a:	89 c2                	mov    %eax,%edx
    237c:	8b 45 14             	mov    0x14(%ebp),%eax
    237f:	88 10                	mov    %dl,(%eax)

    return 1;
    2381:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2386:	c9                   	leave  
    2387:	c3                   	ret    

00002388 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    2388:	55                   	push   %ebp
    2389:	89 e5                	mov    %esp,%ebp
    238b:	53                   	push   %ebx
    238c:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    238f:	8b 45 10             	mov    0x10(%ebp),%eax
    2392:	c1 f8 10             	sar    $0x10,%eax
    2395:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    2398:	8b 45 0c             	mov    0xc(%ebp),%eax
    239b:	c1 f8 10             	sar    $0x10,%eax
    239e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    23a1:	8d 45 bc             	lea    -0x44(%ebp),%eax
    23a4:	50                   	push   %eax
    23a5:	ff 75 f8             	pushl  -0x8(%ebp)
    23a8:	ff 75 f4             	pushl  -0xc(%ebp)
    23ab:	ff 75 08             	pushl  0x8(%ebp)
    23ae:	e8 5b fc ff ff       	call   200e <getColor>
    23b3:	83 c4 10             	add    $0x10,%esp
    23b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    23b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    23bc:	83 c0 01             	add    $0x1,%eax
    23bf:	8d 55 bc             	lea    -0x44(%ebp),%edx
    23c2:	83 c2 04             	add    $0x4,%edx
    23c5:	52                   	push   %edx
    23c6:	ff 75 f8             	pushl  -0x8(%ebp)
    23c9:	50                   	push   %eax
    23ca:	ff 75 08             	pushl  0x8(%ebp)
    23cd:	e8 3c fc ff ff       	call   200e <getColor>
    23d2:	83 c4 10             	add    $0x10,%esp
    23d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    23d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    23db:	83 c0 01             	add    $0x1,%eax
    23de:	8d 55 bc             	lea    -0x44(%ebp),%edx
    23e1:	83 c2 08             	add    $0x8,%edx
    23e4:	52                   	push   %edx
    23e5:	50                   	push   %eax
    23e6:	ff 75 f4             	pushl  -0xc(%ebp)
    23e9:	ff 75 08             	pushl  0x8(%ebp)
    23ec:	e8 1d fc ff ff       	call   200e <getColor>
    23f1:	83 c4 10             	add    $0x10,%esp
    23f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    23f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    23fa:	8d 50 01             	lea    0x1(%eax),%edx
    23fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2400:	83 c0 01             	add    $0x1,%eax
    2403:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2406:	83 c1 0c             	add    $0xc,%ecx
    2409:	51                   	push   %ecx
    240a:	52                   	push   %edx
    240b:	50                   	push   %eax
    240c:	ff 75 08             	pushl  0x8(%ebp)
    240f:	e8 fa fb ff ff       	call   200e <getColor>
    2414:	83 c4 10             	add    $0x10,%esp
    2417:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    241a:	8b 45 10             	mov    0x10(%ebp),%eax
    241d:	0f b7 c0             	movzwl %ax,%eax
    2420:	c1 f8 08             	sar    $0x8,%eax
    2423:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2426:	8b 45 0c             	mov    0xc(%ebp),%eax
    2429:	0f b7 c0             	movzwl %ax,%eax
    242c:	c1 f8 08             	sar    $0x8,%eax
    242f:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2432:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2435:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2439:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    243c:	b8 ff 00 00 00       	mov    $0xff,%eax
    2441:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2444:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2448:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    244b:	b8 ff 00 00 00       	mov    $0xff,%eax
    2450:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2453:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2457:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    245a:	b8 ff 00 00 00       	mov    $0xff,%eax
    245f:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2462:	89 c2                	mov    %eax,%edx
    2464:	b8 ff 00 00 00       	mov    $0xff,%eax
    2469:	2b 45 dc             	sub    -0x24(%ebp),%eax
    246c:	0f af c2             	imul   %edx,%eax
    246f:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    2472:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2475:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2479:	0f b6 c0             	movzbl %al,%eax
    247c:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2480:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2483:	0f af d0             	imul   %eax,%edx
    2486:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2489:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    248d:	0f b6 c0             	movzbl %al,%eax
    2490:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2494:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2497:	0f af c1             	imul   %ecx,%eax
    249a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    249d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    24a0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24a4:	0f b6 c0             	movzbl %al,%eax
    24a7:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    24ab:	8b 55 c8             	mov    -0x38(%ebp),%edx
    24ae:	0f af d0             	imul   %eax,%edx
    24b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24b4:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24b8:	0f b6 c0             	movzbl %al,%eax
    24bb:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    24bf:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    24c2:	0f af c1             	imul   %ecx,%eax
    24c5:	01 d0                	add    %edx,%eax
    24c7:	01 d8                	add    %ebx,%eax
    24c9:	c1 e8 10             	shr    $0x10,%eax
    24cc:	89 c2                	mov    %eax,%edx
    24ce:	8b 45 14             	mov    0x14(%ebp),%eax
    24d1:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    24d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24d7:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24db:	0f b6 c0             	movzbl %al,%eax
    24de:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    24e2:	8b 55 bc             	mov    -0x44(%ebp),%edx
    24e5:	0f af d0             	imul   %eax,%edx
    24e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24eb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24ef:	0f b6 c0             	movzbl %al,%eax
    24f2:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    24f6:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    24f9:	0f af c1             	imul   %ecx,%eax
    24fc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    24ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2502:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2506:	0f b6 c0             	movzbl %al,%eax
    2509:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    250d:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2510:	0f af d0             	imul   %eax,%edx
    2513:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2516:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    251a:	0f b6 c0             	movzbl %al,%eax
    251d:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2521:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2524:	0f af c1             	imul   %ecx,%eax
    2527:	01 d0                	add    %edx,%eax
    2529:	01 d8                	add    %ebx,%eax
    252b:	c1 e8 10             	shr    $0x10,%eax
    252e:	89 c2                	mov    %eax,%edx
    2530:	8b 45 14             	mov    0x14(%ebp),%eax
    2533:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    2536:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2539:	0f b6 00             	movzbl (%eax),%eax
    253c:	0f b6 c0             	movzbl %al,%eax
    253f:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2543:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2546:	0f af d0             	imul   %eax,%edx
    2549:	8b 45 ec             	mov    -0x14(%ebp),%eax
    254c:	0f b6 00             	movzbl (%eax),%eax
    254f:	0f b6 c0             	movzbl %al,%eax
    2552:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2556:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2559:	0f af c1             	imul   %ecx,%eax
    255c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    255f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2562:	0f b6 00             	movzbl (%eax),%eax
    2565:	0f b6 c0             	movzbl %al,%eax
    2568:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    256c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    256f:	0f af d0             	imul   %eax,%edx
    2572:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2575:	0f b6 00             	movzbl (%eax),%eax
    2578:	0f b6 c0             	movzbl %al,%eax
    257b:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    257f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2582:	0f af c1             	imul   %ecx,%eax
    2585:	01 d0                	add    %edx,%eax
    2587:	01 d8                	add    %ebx,%eax
    2589:	c1 e8 10             	shr    $0x10,%eax
    258c:	89 c2                	mov    %eax,%edx
    258e:	8b 45 14             	mov    0x14(%ebp),%eax
    2591:	88 10                	mov    %dl,(%eax)
}
    2593:	90                   	nop
    2594:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2597:	c9                   	leave  
    2598:	c3                   	ret    

00002599 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    2599:	55                   	push   %ebp
    259a:	89 e5                	mov    %esp,%ebp
    259c:	53                   	push   %ebx
    259d:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    25a0:	8b 45 08             	mov    0x8(%ebp),%eax
    25a3:	8b 00                	mov    (%eax),%eax
    25a5:	c1 e0 10             	shl    $0x10,%eax
    25a8:	89 c1                	mov    %eax,%ecx
    25aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    25ad:	8b 18                	mov    (%eax),%ebx
    25af:	89 c8                	mov    %ecx,%eax
    25b1:	99                   	cltd   
    25b2:	f7 fb                	idiv   %ebx
    25b4:	83 c0 01             	add    $0x1,%eax
    25b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    25ba:	8b 45 08             	mov    0x8(%ebp),%eax
    25bd:	8b 40 04             	mov    0x4(%eax),%eax
    25c0:	c1 e0 10             	shl    $0x10,%eax
    25c3:	89 c1                	mov    %eax,%ecx
    25c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    25c8:	8b 58 04             	mov    0x4(%eax),%ebx
    25cb:	89 c8                	mov    %ecx,%eax
    25cd:	99                   	cltd   
    25ce:	f7 fb                	idiv   %ebx
    25d0:	83 c0 01             	add    $0x1,%eax
    25d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    25d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25d9:	d1 f8                	sar    %eax
    25db:	2d 00 80 00 00       	sub    $0x8000,%eax
    25e0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    25e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25e6:	d1 f8                	sar    %eax
    25e8:	2d 00 80 00 00       	sub    $0x8000,%eax
    25ed:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    25f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    25f3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    25f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    25fd:	eb 5d                	jmp    265c <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    25ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2602:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2605:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    260c:	eb 3a                	jmp    2648 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    260e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2611:	8b 48 08             	mov    0x8(%eax),%ecx
    2614:	8b 45 0c             	mov    0xc(%ebp),%eax
    2617:	8b 00                	mov    (%eax),%eax
    2619:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    261d:	89 c2                	mov    %eax,%edx
    261f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2622:	01 c2                	add    %eax,%edx
    2624:	89 d0                	mov    %edx,%eax
    2626:	01 c0                	add    %eax,%eax
    2628:	01 d0                	add    %edx,%eax
    262a:	01 c8                	add    %ecx,%eax
    262c:	50                   	push   %eax
    262d:	ff 75 f0             	pushl  -0x10(%ebp)
    2630:	ff 75 f8             	pushl  -0x8(%ebp)
    2633:	ff 75 08             	pushl  0x8(%ebp)
    2636:	e8 4d fd ff ff       	call   2388 <mixColorInt>
    263b:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    263e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2641:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2644:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2648:	8b 45 0c             	mov    0xc(%ebp),%eax
    264b:	8b 00                	mov    (%eax),%eax
    264d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2650:	7f bc                	jg     260e <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    2652:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2655:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    2658:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    265c:	8b 45 0c             	mov    0xc(%ebp),%eax
    265f:	8b 40 04             	mov    0x4(%eax),%eax
    2662:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2665:	7f 98                	jg     25ff <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    2667:	b8 01 00 00 00       	mov    $0x1,%eax
}
    266c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    266f:	c9                   	leave  
    2670:	c3                   	ret    

00002671 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    2671:	55                   	push   %ebp
    2672:	89 e5                	mov    %esp,%ebp
    2674:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    2677:	8b 45 08             	mov    0x8(%ebp),%eax
    267a:	8b 00                	mov    (%eax),%eax
    267c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    267f:	db 45 e4             	fildl  -0x1c(%ebp)
    2682:	8b 45 0c             	mov    0xc(%ebp),%eax
    2685:	8b 00                	mov    (%eax),%eax
    2687:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    268a:	db 45 e4             	fildl  -0x1c(%ebp)
    268d:	de f9                	fdivrp %st,%st(1)
    268f:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    2692:	8b 45 08             	mov    0x8(%ebp),%eax
    2695:	8b 40 04             	mov    0x4(%eax),%eax
    2698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    269b:	db 45 e4             	fildl  -0x1c(%ebp)
    269e:	8b 45 0c             	mov    0xc(%ebp),%eax
    26a1:	8b 40 04             	mov    0x4(%eax),%eax
    26a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    26a7:	db 45 e4             	fildl  -0x1c(%ebp)
    26aa:	de f9                	fdivrp %st,%st(1)
    26ac:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    26af:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    26b6:	eb 5e                	jmp    2716 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    26b8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    26bf:	eb 47                	jmp    2708 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    26c1:	db 45 f8             	fildl  -0x8(%ebp)
    26c4:	d8 4d f4             	fmuls  -0xc(%ebp)
    26c7:	d9 7d ee             	fnstcw -0x12(%ebp)
    26ca:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    26ce:	b4 0c                	mov    $0xc,%ah
    26d0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    26d4:	d9 6d ec             	fldcw  -0x14(%ebp)
    26d7:	db 5d e8             	fistpl -0x18(%ebp)
    26da:	d9 6d ee             	fldcw  -0x12(%ebp)
    26dd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    26e0:	db 45 fc             	fildl  -0x4(%ebp)
    26e3:	d8 4d f0             	fmuls  -0x10(%ebp)
    26e6:	d9 6d ec             	fldcw  -0x14(%ebp)
    26e9:	db 5d e8             	fistpl -0x18(%ebp)
    26ec:	d9 6d ee             	fldcw  -0x12(%ebp)
    26ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
    26f2:	6a 00                	push   $0x0
    26f4:	52                   	push   %edx
    26f5:	50                   	push   %eax
    26f6:	ff 75 08             	pushl  0x8(%ebp)
    26f9:	e8 10 f9 ff ff       	call   200e <getColor>
    26fe:	83 c4 10             	add    $0x10,%esp
    2701:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2704:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2708:	8b 45 0c             	mov    0xc(%ebp),%eax
    270b:	8b 00                	mov    (%eax),%eax
    270d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2710:	7f af                	jg     26c1 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2712:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2716:	8b 45 0c             	mov    0xc(%ebp),%eax
    2719:	8b 40 04             	mov    0x4(%eax),%eax
    271c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    271f:	7f 97                	jg     26b8 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2721:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2726:	c9                   	leave  
    2727:	c3                   	ret    

00002728 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2728:	55                   	push   %ebp
    2729:	89 e5                	mov    %esp,%ebp
    272b:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    272e:	8b 45 08             	mov    0x8(%ebp),%eax
    2731:	8b 00                	mov    (%eax),%eax
    2733:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2736:	db 45 e0             	fildl  -0x20(%ebp)
    2739:	d9 5d e0             	fstps  -0x20(%ebp)
    273c:	83 ec 0c             	sub    $0xc,%esp
    273f:	ff 75 10             	pushl  0x10(%ebp)
    2742:	e8 6b e2 ff ff       	call   9b2 <cos>
    2747:	83 c4 10             	add    $0x10,%esp
    274a:	d9 5d dc             	fstps  -0x24(%ebp)
    274d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2750:	83 ec 0c             	sub    $0xc,%esp
    2753:	50                   	push   %eax
    2754:	e8 90 e1 ff ff       	call   8e9 <abs>
    2759:	83 c4 10             	add    $0x10,%esp
    275c:	d8 4d e0             	fmuls  -0x20(%ebp)
    275f:	d9 5d e0             	fstps  -0x20(%ebp)
    2762:	8b 45 0c             	mov    0xc(%ebp),%eax
    2765:	8b 00                	mov    (%eax),%eax
    2767:	89 45 dc             	mov    %eax,-0x24(%ebp)
    276a:	db 45 dc             	fildl  -0x24(%ebp)
    276d:	d9 5d dc             	fstps  -0x24(%ebp)
    2770:	83 ec 0c             	sub    $0xc,%esp
    2773:	ff 75 10             	pushl  0x10(%ebp)
    2776:	e8 da e3 ff ff       	call   b55 <sin>
    277b:	83 c4 10             	add    $0x10,%esp
    277e:	d9 5d d8             	fstps  -0x28(%ebp)
    2781:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2784:	83 ec 0c             	sub    $0xc,%esp
    2787:	50                   	push   %eax
    2788:	e8 5c e1 ff ff       	call   8e9 <abs>
    278d:	83 c4 10             	add    $0x10,%esp
    2790:	d8 4d dc             	fmuls  -0x24(%ebp)
    2793:	d8 45 e0             	fadds  -0x20(%ebp)
    2796:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2799:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    279d:	b4 0c                	mov    $0xc,%ah
    279f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    27a3:	d9 6d e4             	fldcw  -0x1c(%ebp)
    27a6:	db 5d f4             	fistpl -0xc(%ebp)
    27a9:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    27ac:	8b 45 08             	mov    0x8(%ebp),%eax
    27af:	8b 00                	mov    (%eax),%eax
    27b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    27b4:	db 45 e0             	fildl  -0x20(%ebp)
    27b7:	d9 5d e0             	fstps  -0x20(%ebp)
    27ba:	83 ec 0c             	sub    $0xc,%esp
    27bd:	ff 75 10             	pushl  0x10(%ebp)
    27c0:	e8 90 e3 ff ff       	call   b55 <sin>
    27c5:	83 c4 10             	add    $0x10,%esp
    27c8:	d9 5d dc             	fstps  -0x24(%ebp)
    27cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    27ce:	83 ec 0c             	sub    $0xc,%esp
    27d1:	50                   	push   %eax
    27d2:	e8 12 e1 ff ff       	call   8e9 <abs>
    27d7:	83 c4 10             	add    $0x10,%esp
    27da:	d8 4d e0             	fmuls  -0x20(%ebp)
    27dd:	d9 5d e0             	fstps  -0x20(%ebp)
    27e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    27e3:	8b 00                	mov    (%eax),%eax
    27e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    27e8:	db 45 dc             	fildl  -0x24(%ebp)
    27eb:	d9 5d dc             	fstps  -0x24(%ebp)
    27ee:	83 ec 0c             	sub    $0xc,%esp
    27f1:	ff 75 10             	pushl  0x10(%ebp)
    27f4:	e8 b9 e1 ff ff       	call   9b2 <cos>
    27f9:	83 c4 10             	add    $0x10,%esp
    27fc:	d9 5d d8             	fstps  -0x28(%ebp)
    27ff:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2802:	83 ec 0c             	sub    $0xc,%esp
    2805:	50                   	push   %eax
    2806:	e8 de e0 ff ff       	call   8e9 <abs>
    280b:	83 c4 10             	add    $0x10,%esp
    280e:	d8 4d dc             	fmuls  -0x24(%ebp)
    2811:	d8 45 e0             	fadds  -0x20(%ebp)
    2814:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2817:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    281b:	b4 0c                	mov    $0xc,%ah
    281d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2821:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2824:	db 5d f0             	fistpl -0x10(%ebp)
    2827:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    282a:	8b 45 0c             	mov    0xc(%ebp),%eax
    282d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2830:	89 10                	mov    %edx,(%eax)
    *width = w;
    2832:	8b 45 08             	mov    0x8(%ebp),%eax
    2835:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2838:	89 10                	mov    %edx,(%eax)
    return 1;
    283a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    283f:	c9                   	leave  
    2840:	c3                   	ret    

00002841 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    2841:	55                   	push   %ebp
    2842:	89 e5                	mov    %esp,%ebp
    2844:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2847:	8b 45 08             	mov    0x8(%ebp),%eax
    284a:	8b 40 04             	mov    0x4(%eax),%eax
    284d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2850:	db 45 c4             	fildl  -0x3c(%ebp)
    2853:	d9 05 84 9d 01 00    	flds   0x19d84
    2859:	de f9                	fdivrp %st,%st(1)
    285b:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    285e:	8b 45 08             	mov    0x8(%ebp),%eax
    2861:	8b 00                	mov    (%eax),%eax
    2863:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2866:	db 45 c4             	fildl  -0x3c(%ebp)
    2869:	d9 05 84 9d 01 00    	flds   0x19d84
    286f:	de f9                	fdivrp %st,%st(1)
    2871:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2874:	8b 45 0c             	mov    0xc(%ebp),%eax
    2877:	8b 50 04             	mov    0x4(%eax),%edx
    287a:	8b 45 08             	mov    0x8(%ebp),%eax
    287d:	8b 40 04             	mov    0x4(%eax),%eax
    2880:	29 c2                	sub    %eax,%edx
    2882:	89 d0                	mov    %edx,%eax
    2884:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2887:	db 45 c4             	fildl  -0x3c(%ebp)
    288a:	d9 05 84 9d 01 00    	flds   0x19d84
    2890:	de f9                	fdivrp %st,%st(1)
    2892:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2895:	8b 45 0c             	mov    0xc(%ebp),%eax
    2898:	8b 10                	mov    (%eax),%edx
    289a:	8b 45 08             	mov    0x8(%ebp),%eax
    289d:	8b 00                	mov    (%eax),%eax
    289f:	29 c2                	sub    %eax,%edx
    28a1:	89 d0                	mov    %edx,%eax
    28a3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28a6:	db 45 c4             	fildl  -0x3c(%ebp)
    28a9:	d9 05 84 9d 01 00    	flds   0x19d84
    28af:	de f9                	fdivrp %st,%st(1)
    28b1:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    28b4:	d9 45 10             	flds   0x10(%ebp)
    28b7:	d9 e0                	fchs   
    28b9:	83 ec 0c             	sub    $0xc,%esp
    28bc:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    28c0:	d9 1c 24             	fstps  (%esp)
    28c3:	e8 ea e0 ff ff       	call   9b2 <cos>
    28c8:	83 c4 10             	add    $0x10,%esp
    28cb:	d9 5d c4             	fstps  -0x3c(%ebp)
    28ce:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    28d1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    28d4:	d9 45 10             	flds   0x10(%ebp)
    28d7:	d9 e0                	fchs   
    28d9:	83 ec 0c             	sub    $0xc,%esp
    28dc:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    28e0:	d9 1c 24             	fstps  (%esp)
    28e3:	e8 6d e2 ff ff       	call   b55 <sin>
    28e8:	83 c4 10             	add    $0x10,%esp
    28eb:	d9 5d c4             	fstps  -0x3c(%ebp)
    28ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    28f1:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    28f4:	d9 ee                	fldz   
    28f6:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    28f9:	d9 ee                	fldz   
    28fb:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    28fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2905:	e9 28 01 00 00       	jmp    2a32 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    290a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2911:	e9 0a 01 00 00       	jmp    2a20 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2916:	db 45 f4             	fildl  -0xc(%ebp)
    2919:	d8 65 e4             	fsubs  -0x1c(%ebp)
    291c:	d8 65 ec             	fsubs  -0x14(%ebp)
    291f:	d8 4d dc             	fmuls  -0x24(%ebp)
    2922:	db 45 f0             	fildl  -0x10(%ebp)
    2925:	d8 65 e0             	fsubs  -0x20(%ebp)
    2928:	d8 65 e8             	fsubs  -0x18(%ebp)
    292b:	d8 4d d8             	fmuls  -0x28(%ebp)
    292e:	de c1                	faddp  %st,%st(1)
    2930:	d8 45 ec             	fadds  -0x14(%ebp)
    2933:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2936:	db 45 f0             	fildl  -0x10(%ebp)
    2939:	d8 65 e0             	fsubs  -0x20(%ebp)
    293c:	d8 65 e8             	fsubs  -0x18(%ebp)
    293f:	d8 4d dc             	fmuls  -0x24(%ebp)
    2942:	db 45 f4             	fildl  -0xc(%ebp)
    2945:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2948:	d8 65 ec             	fsubs  -0x14(%ebp)
    294b:	d8 4d d8             	fmuls  -0x28(%ebp)
    294e:	de e9                	fsubrp %st,%st(1)
    2950:	d8 45 e8             	fadds  -0x18(%ebp)
    2953:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2956:	d9 45 d4             	flds   -0x2c(%ebp)
    2959:	d9 ee                	fldz   
    295b:	d9 c9                	fxch   %st(1)
    295d:	df e9                	fucomip %st(1),%st
    295f:	dd d8                	fstp   %st(0)
    2961:	0f 93 c0             	setae  %al
    2964:	83 f0 01             	xor    $0x1,%eax
    2967:	84 c0                	test   %al,%al
    2969:	75 52                	jne    29bd <picTurn+0x17c>
    296b:	8b 45 08             	mov    0x8(%ebp),%eax
    296e:	8b 40 04             	mov    0x4(%eax),%eax
    2971:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2974:	db 45 c4             	fildl  -0x3c(%ebp)
    2977:	d9 45 d4             	flds   -0x2c(%ebp)
    297a:	d9 c9                	fxch   %st(1)
    297c:	df e9                	fucomip %st(1),%st
    297e:	dd d8                	fstp   %st(0)
    2980:	0f 97 c0             	seta   %al
    2983:	83 f0 01             	xor    $0x1,%eax
    2986:	84 c0                	test   %al,%al
    2988:	75 33                	jne    29bd <picTurn+0x17c>
    298a:	d9 45 d0             	flds   -0x30(%ebp)
    298d:	d9 ee                	fldz   
    298f:	d9 c9                	fxch   %st(1)
    2991:	df e9                	fucomip %st(1),%st
    2993:	dd d8                	fstp   %st(0)
    2995:	0f 93 c0             	setae  %al
    2998:	83 f0 01             	xor    $0x1,%eax
    299b:	84 c0                	test   %al,%al
    299d:	75 1e                	jne    29bd <picTurn+0x17c>
    299f:	8b 45 08             	mov    0x8(%ebp),%eax
    29a2:	8b 00                	mov    (%eax),%eax
    29a4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    29a7:	db 45 c4             	fildl  -0x3c(%ebp)
    29aa:	d9 45 d0             	flds   -0x30(%ebp)
    29ad:	d9 c9                	fxch   %st(1)
    29af:	df e9                	fucomip %st(1),%st
    29b1:	dd d8                	fstp   %st(0)
    29b3:	0f 97 c0             	seta   %al
    29b6:	83 f0 01             	xor    $0x1,%eax
    29b9:	84 c0                	test   %al,%al
    29bb:	74 2f                	je     29ec <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    29bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    29c0:	8b 48 08             	mov    0x8(%eax),%ecx
    29c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    29c6:	8b 00                	mov    (%eax),%eax
    29c8:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    29cc:	89 c2                	mov    %eax,%edx
    29ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    29d1:	01 c2                	add    %eax,%edx
    29d3:	89 d0                	mov    %edx,%eax
    29d5:	01 c0                	add    %eax,%eax
    29d7:	01 d0                	add    %edx,%eax
    29d9:	01 c8                	add    %ecx,%eax
    29db:	83 ec 08             	sub    $0x8,%esp
    29de:	50                   	push   %eax
    29df:	68 d9 e1 01 00       	push   $0x1e1d9
    29e4:	e8 9f f6 ff ff       	call   2088 <setColor>
    29e9:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    29ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    29ef:	8b 48 08             	mov    0x8(%eax),%ecx
    29f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    29f5:	8b 00                	mov    (%eax),%eax
    29f7:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    29fb:	89 c2                	mov    %eax,%edx
    29fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a00:	01 c2                	add    %eax,%edx
    2a02:	89 d0                	mov    %edx,%eax
    2a04:	01 c0                	add    %eax,%eax
    2a06:	01 d0                	add    %edx,%eax
    2a08:	01 c8                	add    %ecx,%eax
    2a0a:	50                   	push   %eax
    2a0b:	ff 75 d0             	pushl  -0x30(%ebp)
    2a0e:	ff 75 d4             	pushl  -0x2c(%ebp)
    2a11:	ff 75 08             	pushl  0x8(%ebp)
    2a14:	e8 9e f6 ff ff       	call   20b7 <mixColor>
    2a19:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2a1c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2a20:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a23:	8b 00                	mov    (%eax),%eax
    2a25:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a28:	0f 8f e8 fe ff ff    	jg     2916 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2a2e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a32:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a35:	8b 40 04             	mov    0x4(%eax),%eax
    2a38:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2a3b:	0f 8f c9 fe ff ff    	jg     290a <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2a41:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a46:	c9                   	leave  
    2a47:	c3                   	ret    

00002a48 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2a48:	55                   	push   %ebp
    2a49:	89 e5                	mov    %esp,%ebp
    2a4b:	53                   	push   %ebx
    2a4c:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2a4f:	8b 45 08             	mov    0x8(%ebp),%eax
    2a52:	8b 10                	mov    (%eax),%edx
    2a54:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a57:	8b 00                	mov    (%eax),%eax
    2a59:	39 c2                	cmp    %eax,%edx
    2a5b:	75 10                	jne    2a6d <picRollingOver+0x25>
    2a5d:	8b 45 08             	mov    0x8(%ebp),%eax
    2a60:	8b 50 04             	mov    0x4(%eax),%edx
    2a63:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a66:	8b 40 04             	mov    0x4(%eax),%eax
    2a69:	39 c2                	cmp    %eax,%edx
    2a6b:	74 0a                	je     2a77 <picRollingOver+0x2f>
        return 0;
    2a6d:	b8 00 00 00 00       	mov    $0x0,%eax
    2a72:	e9 88 00 00 00       	jmp    2aff <picRollingOver+0xb7>

    int h = src->height;
    2a77:	8b 45 08             	mov    0x8(%ebp),%eax
    2a7a:	8b 40 04             	mov    0x4(%eax),%eax
    2a7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2a80:	8b 45 08             	mov    0x8(%ebp),%eax
    2a83:	8b 00                	mov    (%eax),%eax
    2a85:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2a88:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2a8f:	eb 61                	jmp    2af2 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2a91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2a98:	eb 4c                	jmp    2ae6 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2a9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a9d:	8b 48 08             	mov    0x8(%eax),%ecx
    2aa0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2aa3:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2aa6:	83 e8 01             	sub    $0x1,%eax
    2aa9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2aad:	89 c2                	mov    %eax,%edx
    2aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ab2:	01 c2                	add    %eax,%edx
    2ab4:	89 d0                	mov    %edx,%eax
    2ab6:	01 c0                	add    %eax,%eax
    2ab8:	01 d0                	add    %edx,%eax
    2aba:	01 c1                	add    %eax,%ecx
    2abc:	8b 45 08             	mov    0x8(%ebp),%eax
    2abf:	8b 58 08             	mov    0x8(%eax),%ebx
    2ac2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ac5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ac9:	89 c2                	mov    %eax,%edx
    2acb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ace:	01 c2                	add    %eax,%edx
    2ad0:	89 d0                	mov    %edx,%eax
    2ad2:	01 c0                	add    %eax,%eax
    2ad4:	01 d0                	add    %edx,%eax
    2ad6:	01 d8                	add    %ebx,%eax
    2ad8:	51                   	push   %ecx
    2ad9:	50                   	push   %eax
    2ada:	e8 a9 f5 ff ff       	call   2088 <setColor>
    2adf:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2ae2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2ae6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ae9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2aec:	7c ac                	jl     2a9a <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2aee:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2af2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2af5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2af8:	7c 97                	jl     2a91 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2afa:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2aff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b02:	c9                   	leave  
    2b03:	c3                   	ret    

00002b04 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2b04:	55                   	push   %ebp
    2b05:	89 e5                	mov    %esp,%ebp
    2b07:	53                   	push   %ebx
    2b08:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2b0b:	8b 45 08             	mov    0x8(%ebp),%eax
    2b0e:	8b 10                	mov    (%eax),%edx
    2b10:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b13:	8b 00                	mov    (%eax),%eax
    2b15:	39 c2                	cmp    %eax,%edx
    2b17:	75 10                	jne    2b29 <picTurnAround+0x25>
    2b19:	8b 45 08             	mov    0x8(%ebp),%eax
    2b1c:	8b 50 04             	mov    0x4(%eax),%edx
    2b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b22:	8b 40 04             	mov    0x4(%eax),%eax
    2b25:	39 c2                	cmp    %eax,%edx
    2b27:	74 0a                	je     2b33 <picTurnAround+0x2f>
        return 0;
    2b29:	b8 00 00 00 00       	mov    $0x0,%eax
    2b2e:	e9 88 00 00 00       	jmp    2bbb <picTurnAround+0xb7>

    int h = src->height;
    2b33:	8b 45 08             	mov    0x8(%ebp),%eax
    2b36:	8b 40 04             	mov    0x4(%eax),%eax
    2b39:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2b3c:	8b 45 08             	mov    0x8(%ebp),%eax
    2b3f:	8b 00                	mov    (%eax),%eax
    2b41:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2b44:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2b4b:	eb 61                	jmp    2bae <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2b4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2b54:	eb 4c                	jmp    2ba2 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2b56:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b59:	8b 48 08             	mov    0x8(%eax),%ecx
    2b5c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b5f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b63:	89 c2                	mov    %eax,%edx
    2b65:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2b68:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2b6b:	01 c2                	add    %eax,%edx
    2b6d:	89 d0                	mov    %edx,%eax
    2b6f:	01 c0                	add    %eax,%eax
    2b71:	01 d0                	add    %edx,%eax
    2b73:	83 e8 03             	sub    $0x3,%eax
    2b76:	01 c1                	add    %eax,%ecx
    2b78:	8b 45 08             	mov    0x8(%ebp),%eax
    2b7b:	8b 58 08             	mov    0x8(%eax),%ebx
    2b7e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b81:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b85:	89 c2                	mov    %eax,%edx
    2b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b8a:	01 c2                	add    %eax,%edx
    2b8c:	89 d0                	mov    %edx,%eax
    2b8e:	01 c0                	add    %eax,%eax
    2b90:	01 d0                	add    %edx,%eax
    2b92:	01 d8                	add    %ebx,%eax
    2b94:	51                   	push   %ecx
    2b95:	50                   	push   %eax
    2b96:	e8 ed f4 ff ff       	call   2088 <setColor>
    2b9b:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2b9e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2ba2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ba5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2ba8:	7c ac                	jl     2b56 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2baa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2bae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2bb1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2bb4:	7c 97                	jl     2b4d <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2bb6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2bbb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2bbe:	c9                   	leave  
    2bbf:	c3                   	ret    

00002bc0 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2bc0:	55                   	push   %ebp
    2bc1:	89 e5                	mov    %esp,%ebp
    2bc3:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2bc6:	83 ec 0c             	sub    $0xc,%esp
    2bc9:	ff 75 08             	pushl  0x8(%ebp)
    2bcc:	e8 c5 d5 ff ff       	call   196 <strlen>
    2bd1:	83 c4 10             	add    $0x10,%esp
    2bd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2bd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bda:	8d 50 ff             	lea    -0x1(%eax),%edx
    2bdd:	8b 45 08             	mov    0x8(%ebp),%eax
    2be0:	01 d0                	add    %edx,%eax
    2be2:	0f b6 00             	movzbl (%eax),%eax
    2be5:	3c 67                	cmp    $0x67,%al
    2be7:	75 2b                	jne    2c14 <type+0x54>
    2be9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bec:	8d 50 fe             	lea    -0x2(%eax),%edx
    2bef:	8b 45 08             	mov    0x8(%ebp),%eax
    2bf2:	01 d0                	add    %edx,%eax
    2bf4:	0f b6 00             	movzbl (%eax),%eax
    2bf7:	3c 70                	cmp    $0x70,%al
    2bf9:	75 19                	jne    2c14 <type+0x54>
    2bfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bfe:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c01:	8b 45 08             	mov    0x8(%ebp),%eax
    2c04:	01 d0                	add    %edx,%eax
    2c06:	0f b6 00             	movzbl (%eax),%eax
    2c09:	3c 6a                	cmp    $0x6a,%al
    2c0b:	75 07                	jne    2c14 <type+0x54>
    2c0d:	b8 00 00 00 00       	mov    $0x0,%eax
    2c12:	eb 7f                	jmp    2c93 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2c14:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c17:	8d 50 ff             	lea    -0x1(%eax),%edx
    2c1a:	8b 45 08             	mov    0x8(%ebp),%eax
    2c1d:	01 d0                	add    %edx,%eax
    2c1f:	0f b6 00             	movzbl (%eax),%eax
    2c22:	3c 70                	cmp    $0x70,%al
    2c24:	75 2b                	jne    2c51 <type+0x91>
    2c26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c29:	8d 50 fe             	lea    -0x2(%eax),%edx
    2c2c:	8b 45 08             	mov    0x8(%ebp),%eax
    2c2f:	01 d0                	add    %edx,%eax
    2c31:	0f b6 00             	movzbl (%eax),%eax
    2c34:	3c 6d                	cmp    $0x6d,%al
    2c36:	75 19                	jne    2c51 <type+0x91>
    2c38:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c3b:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c3e:	8b 45 08             	mov    0x8(%ebp),%eax
    2c41:	01 d0                	add    %edx,%eax
    2c43:	0f b6 00             	movzbl (%eax),%eax
    2c46:	3c 62                	cmp    $0x62,%al
    2c48:	75 07                	jne    2c51 <type+0x91>
    2c4a:	b8 01 00 00 00       	mov    $0x1,%eax
    2c4f:	eb 42                	jmp    2c93 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c54:	8d 50 ff             	lea    -0x1(%eax),%edx
    2c57:	8b 45 08             	mov    0x8(%ebp),%eax
    2c5a:	01 d0                	add    %edx,%eax
    2c5c:	0f b6 00             	movzbl (%eax),%eax
    2c5f:	3c 67                	cmp    $0x67,%al
    2c61:	75 2b                	jne    2c8e <type+0xce>
    2c63:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c66:	8d 50 fe             	lea    -0x2(%eax),%edx
    2c69:	8b 45 08             	mov    0x8(%ebp),%eax
    2c6c:	01 d0                	add    %edx,%eax
    2c6e:	0f b6 00             	movzbl (%eax),%eax
    2c71:	3c 6e                	cmp    $0x6e,%al
    2c73:	75 19                	jne    2c8e <type+0xce>
    2c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c78:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c7b:	8b 45 08             	mov    0x8(%ebp),%eax
    2c7e:	01 d0                	add    %edx,%eax
    2c80:	0f b6 00             	movzbl (%eax),%eax
    2c83:	3c 70                	cmp    $0x70,%al
    2c85:	75 07                	jne    2c8e <type+0xce>
    2c87:	b8 02 00 00 00       	mov    $0x2,%eax
    2c8c:	eb 05                	jmp    2c93 <type+0xd3>
    else return NONE;
    2c8e:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2c93:	c9                   	leave  
    2c94:	c3                   	ret    

00002c95 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2c95:	55                   	push   %ebp
    2c96:	89 e5                	mov    %esp,%ebp
    2c98:	56                   	push   %esi
    2c99:	53                   	push   %ebx
    2c9a:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2c9d:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2ca4:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2cab:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2cb2:	83 ec 08             	sub    $0x8,%esp
    2cb5:	6a 00                	push   $0x0
    2cb7:	ff 75 0c             	pushl  0xc(%ebp)
    2cba:	e8 d9 d6 ff ff       	call   398 <open>
    2cbf:	83 c4 10             	add    $0x10,%esp
    2cc2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2cc5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2cc9:	79 2c                	jns    2cf7 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2ccb:	83 ec 08             	sub    $0x8,%esp
    2cce:	ff 75 0c             	pushl  0xc(%ebp)
    2cd1:	68 88 9d 01 00       	push   $0x19d88
    2cd6:	e8 24 d8 ff ff       	call   4ff <printf>
    2cdb:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2cde:	8b 45 08             	mov    0x8(%ebp),%eax
    2ce1:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2ce4:	89 10                	mov    %edx,(%eax)
    2ce6:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2ce9:	89 50 04             	mov    %edx,0x4(%eax)
    2cec:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2cef:	89 50 08             	mov    %edx,0x8(%eax)
    2cf2:	e9 2d 02 00 00       	jmp    2f24 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2cf7:	83 ec 04             	sub    $0x4,%esp
    2cfa:	6a 0e                	push   $0xe
    2cfc:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2cff:	50                   	push   %eax
    2d00:	ff 75 ec             	pushl  -0x14(%ebp)
    2d03:	e8 68 d6 ff ff       	call   370 <read>
    2d08:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2d0b:	83 ec 04             	sub    $0x4,%esp
    2d0e:	6a 28                	push   $0x28
    2d10:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2d13:	50                   	push   %eax
    2d14:	ff 75 ec             	pushl  -0x14(%ebp)
    2d17:	e8 54 d6 ff ff       	call   370 <read>
    2d1c:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2d1f:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2d23:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2d26:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2d2a:	0f b7 d8             	movzwl %ax,%ebx
    2d2d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2d30:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2d33:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2d37:	0f b7 c0             	movzwl %ax,%eax
    2d3a:	83 ec 04             	sub    $0x4,%esp
    2d3d:	6a 36                	push   $0x36
    2d3f:	56                   	push   %esi
    2d40:	53                   	push   %ebx
    2d41:	51                   	push   %ecx
    2d42:	52                   	push   %edx
    2d43:	50                   	push   %eax
    2d44:	68 98 9d 01 00       	push   $0x19d98
    2d49:	e8 b1 d7 ff ff       	call   4ff <printf>
    2d4e:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2d51:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2d54:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2d57:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2d5a:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2d5d:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2d60:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d63:	0f af c2             	imul   %edx,%eax
    2d66:	89 c2                	mov    %eax,%edx
    2d68:	89 d0                	mov    %edx,%eax
    2d6a:	01 c0                	add    %eax,%eax
    2d6c:	01 d0                	add    %edx,%eax
    2d6e:	83 ec 0c             	sub    $0xc,%esp
    2d71:	50                   	push   %eax
    2d72:	e8 5b da ff ff       	call   7d2 <malloc>
    2d77:	83 c4 10             	add    $0x10,%esp
    2d7a:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2d7d:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2d81:	0f b7 c0             	movzwl %ax,%eax
    2d84:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2d87:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d8a:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2d8e:	83 c0 1f             	add    $0x1f,%eax
    2d91:	c1 f8 05             	sar    $0x5,%eax
    2d94:	c1 e0 02             	shl    $0x2,%eax
    2d97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2d9a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d9d:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2da1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2da4:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2da7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2daa:	83 ec 08             	sub    $0x8,%esp
    2dad:	52                   	push   %edx
    2dae:	50                   	push   %eax
    2daf:	ff 75 e8             	pushl  -0x18(%ebp)
    2db2:	ff 75 e0             	pushl  -0x20(%ebp)
    2db5:	ff 75 e4             	pushl  -0x1c(%ebp)
    2db8:	68 c0 9d 01 00       	push   $0x19dc0
    2dbd:	e8 3d d7 ff ff       	call   4ff <printf>
    2dc2:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2dc5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2dc8:	83 e8 36             	sub    $0x36,%eax
    2dcb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2dce:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2dd1:	83 ec 0c             	sub    $0xc,%esp
    2dd4:	50                   	push   %eax
    2dd5:	e8 f8 d9 ff ff       	call   7d2 <malloc>
    2dda:	83 c4 10             	add    $0x10,%esp
    2ddd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2de0:	83 ec 04             	sub    $0x4,%esp
    2de3:	ff 75 dc             	pushl  -0x24(%ebp)
    2de6:	ff 75 d8             	pushl  -0x28(%ebp)
    2de9:	ff 75 ec             	pushl  -0x14(%ebp)
    2dec:	e8 7f d5 ff ff       	call   370 <read>
    2df1:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2df4:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2df7:	83 ec 0c             	sub    $0xc,%esp
    2dfa:	50                   	push   %eax
    2dfb:	e8 d2 d9 ff ff       	call   7d2 <malloc>
    2e00:	83 c4 10             	add    $0x10,%esp
    2e03:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2e06:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2e09:	83 ec 04             	sub    $0x4,%esp
    2e0c:	50                   	push   %eax
    2e0d:	ff 75 d4             	pushl  -0x2c(%ebp)
    2e10:	ff 75 ec             	pushl  -0x14(%ebp)
    2e13:	e8 58 d5 ff ff       	call   370 <read>
    2e18:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2e1b:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2e1f:	66 c1 e8 03          	shr    $0x3,%ax
    2e23:	0f b7 c0             	movzwl %ax,%eax
    2e26:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2e29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2e30:	e9 c1 00 00 00       	jmp    2ef6 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2e35:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e38:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2e3b:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e3e:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e41:	0f af c2             	imul   %edx,%eax
    2e44:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2e47:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e4a:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2e4e:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2e51:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2e58:	e9 89 00 00 00       	jmp    2ee6 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2e5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e60:	83 c0 01             	add    $0x1,%eax
    2e63:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2e67:	89 c2                	mov    %eax,%edx
    2e69:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2e6c:	01 d0                	add    %edx,%eax
    2e6e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2e71:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e74:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e77:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e7a:	01 c8                	add    %ecx,%eax
    2e7c:	89 c1                	mov    %eax,%ecx
    2e7e:	89 c8                	mov    %ecx,%eax
    2e80:	01 c0                	add    %eax,%eax
    2e82:	01 c8                	add    %ecx,%eax
    2e84:	01 c2                	add    %eax,%edx
    2e86:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e89:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2e8c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e8f:	01 c8                	add    %ecx,%eax
    2e91:	0f b6 00             	movzbl (%eax),%eax
    2e94:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2e97:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e9a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ea0:	01 c8                	add    %ecx,%eax
    2ea2:	89 c1                	mov    %eax,%ecx
    2ea4:	89 c8                	mov    %ecx,%eax
    2ea6:	01 c0                	add    %eax,%eax
    2ea8:	01 c8                	add    %ecx,%eax
    2eaa:	01 c2                	add    %eax,%edx
    2eac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2eaf:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2eb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2eb5:	01 c8                	add    %ecx,%eax
    2eb7:	0f b6 00             	movzbl (%eax),%eax
    2eba:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2ebd:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2ec0:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2ec3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ec6:	01 c8                	add    %ecx,%eax
    2ec8:	89 c1                	mov    %eax,%ecx
    2eca:	89 c8                	mov    %ecx,%eax
    2ecc:	01 c0                	add    %eax,%eax
    2ece:	01 c8                	add    %ecx,%eax
    2ed0:	01 c2                	add    %eax,%edx
    2ed2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2ed5:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2ed8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2edb:	01 c8                	add    %ecx,%eax
    2edd:	0f b6 00             	movzbl (%eax),%eax
    2ee0:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2ee2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2ee6:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2ee9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2eec:	0f 8f 6b ff ff ff    	jg     2e5d <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2ef2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2ef6:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2ef9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2efc:	0f 8f 33 ff ff ff    	jg     2e35 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2f02:	83 ec 0c             	sub    $0xc,%esp
    2f05:	ff 75 ec             	pushl  -0x14(%ebp)
    2f08:	e8 73 d4 ff ff       	call   380 <close>
    2f0d:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2f10:	8b 45 08             	mov    0x8(%ebp),%eax
    2f13:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2f16:	89 10                	mov    %edx,(%eax)
    2f18:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2f1b:	89 50 04             	mov    %edx,0x4(%eax)
    2f1e:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f21:	89 50 08             	mov    %edx,0x8(%eax)
}
    2f24:	8b 45 08             	mov    0x8(%ebp),%eax
    2f27:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2f2a:	5b                   	pop    %ebx
    2f2b:	5e                   	pop    %esi
    2f2c:	5d                   	pop    %ebp
    2f2d:	c2 04 00             	ret    $0x4

00002f30 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2f30:	55                   	push   %ebp
    2f31:	89 e5                	mov    %esp,%ebp
    2f33:	53                   	push   %ebx
    2f34:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2f37:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2f3b:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2f3f:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2f43:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2f47:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2f4b:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2f4f:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2f53:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2f57:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2f5b:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2f5f:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2f63:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2f67:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2f6b:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2f6f:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2f73:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2f77:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2f7b:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2f7f:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2f83:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2f87:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2f8b:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2f8f:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2f93:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2f97:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2f9b:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2f9f:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2fa3:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2fa7:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2fab:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    2faf:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    2fb3:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    2fb7:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    2fbb:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    2fbf:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    2fc3:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    2fc7:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    2fcb:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    2fcf:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    2fd3:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    2fd7:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    2fdb:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    2fdf:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    2fe3:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    2fe7:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    2feb:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    2fef:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    2ff3:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    2ff7:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    2ffb:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    2fff:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    3003:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    3007:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    300b:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    300f:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3013:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    3017:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    301b:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    301f:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3023:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    3027:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    302b:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    302f:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3033:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    3037:	83 ec 0c             	sub    $0xc,%esp
    303a:	68 c8 02 08 00       	push   $0x802c8
    303f:	e8 8e d7 ff ff       	call   7d2 <malloc>
    3044:	83 c4 10             	add    $0x10,%esp
    3047:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    304a:	83 ec 04             	sub    $0x4,%esp
    304d:	68 c8 02 08 00       	push   $0x802c8
    3052:	6a 00                	push   $0x0
    3054:	ff 75 f0             	pushl  -0x10(%ebp)
    3057:	e8 61 d1 ff ff       	call   1bd <memset>
    305c:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    305f:	83 ec 08             	sub    $0x8,%esp
    3062:	6a 00                	push   $0x0
    3064:	ff 75 0c             	pushl  0xc(%ebp)
    3067:	e8 2c d3 ff ff       	call   398 <open>
    306c:	83 c4 10             	add    $0x10,%esp
    306f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    3072:	83 ec 0c             	sub    $0xc,%esp
    3075:	68 40 42 0f 00       	push   $0xf4240
    307a:	e8 53 d7 ff ff       	call   7d2 <malloc>
    307f:	83 c4 10             	add    $0x10,%esp
    3082:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    3085:	83 ec 04             	sub    $0x4,%esp
    3088:	68 40 42 0f 00       	push   $0xf4240
    308d:	ff 75 e8             	pushl  -0x18(%ebp)
    3090:	ff 75 ec             	pushl  -0x14(%ebp)
    3093:	e8 d8 d2 ff ff       	call   370 <read>
    3098:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    309b:	83 ec 0c             	sub    $0xc,%esp
    309e:	ff 75 ec             	pushl  -0x14(%ebp)
    30a1:	e8 da d2 ff ff       	call   380 <close>
    30a6:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    30a9:	68 40 42 0f 00       	push   $0xf4240
    30ae:	ff 75 e8             	pushl  -0x18(%ebp)
    30b1:	8d 45 9c             	lea    -0x64(%ebp),%eax
    30b4:	50                   	push   %eax
    30b5:	ff 75 f0             	pushl  -0x10(%ebp)
    30b8:	e8 5e 0c 01 00       	call   13d1b <_DecodeJPEG>
    30bd:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    30c0:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    30c7:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    30ce:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    30d5:	83 ec 0c             	sub    $0xc,%esp
    30d8:	ff 75 f0             	pushl  -0x10(%ebp)
    30db:	e8 29 0b 01 00       	call   13c09 <GetImageSize>
    30e0:	83 c4 10             	add    $0x10,%esp
    30e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    30e6:	83 ec 0c             	sub    $0xc,%esp
    30e9:	ff 75 f0             	pushl  -0x10(%ebp)
    30ec:	e8 e1 0a 01 00       	call   13bd2 <GetImage>
    30f1:	83 c4 10             	add    $0x10,%esp
    30f4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    30f7:	83 ec 0c             	sub    $0xc,%esp
    30fa:	ff 75 f0             	pushl  -0x10(%ebp)
    30fd:	e8 f1 0a 01 00       	call   13bf3 <GetWidth>
    3102:	83 c4 10             	add    $0x10,%esp
    3105:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3108:	83 ec 0c             	sub    $0xc,%esp
    310b:	ff 75 f0             	pushl  -0x10(%ebp)
    310e:	e8 eb 0a 01 00       	call   13bfe <GetHeight>
    3113:	83 c4 10             	add    $0x10,%esp
    3116:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    3119:	8b 55 90             	mov    -0x70(%ebp),%edx
    311c:	8b 45 94             	mov    -0x6c(%ebp),%eax
    311f:	0f af c2             	imul   %edx,%eax
    3122:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3125:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3128:	89 d0                	mov    %edx,%eax
    312a:	01 c0                	add    %eax,%eax
    312c:	01 d0                	add    %edx,%eax
    312e:	83 ec 0c             	sub    $0xc,%esp
    3131:	50                   	push   %eax
    3132:	e8 9b d6 ff ff       	call   7d2 <malloc>
    3137:	83 c4 10             	add    $0x10,%esp
    313a:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    313d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3144:	e9 9c 00 00 00       	jmp    31e5 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    3149:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    314c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    314f:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3154:	89 c8                	mov    %ecx,%eax
    3156:	f7 ea                	imul   %edx
    3158:	89 c8                	mov    %ecx,%eax
    315a:	c1 f8 1f             	sar    $0x1f,%eax
    315d:	29 c2                	sub    %eax,%edx
    315f:	89 d0                	mov    %edx,%eax
    3161:	89 c2                	mov    %eax,%edx
    3163:	89 d0                	mov    %edx,%eax
    3165:	01 c0                	add    %eax,%eax
    3167:	01 d0                	add    %edx,%eax
    3169:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    316c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    316f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3172:	01 c8                	add    %ecx,%eax
    3174:	0f b6 00             	movzbl (%eax),%eax
    3177:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    317a:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    317d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3180:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3185:	89 c8                	mov    %ecx,%eax
    3187:	f7 ea                	imul   %edx
    3189:	89 c8                	mov    %ecx,%eax
    318b:	c1 f8 1f             	sar    $0x1f,%eax
    318e:	29 c2                	sub    %eax,%edx
    3190:	89 d0                	mov    %edx,%eax
    3192:	89 c2                	mov    %eax,%edx
    3194:	89 d0                	mov    %edx,%eax
    3196:	01 c0                	add    %eax,%eax
    3198:	01 d0                	add    %edx,%eax
    319a:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    319d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31a0:	8d 48 01             	lea    0x1(%eax),%ecx
    31a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31a6:	01 c8                	add    %ecx,%eax
    31a8:	0f b6 00             	movzbl (%eax),%eax
    31ab:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    31ae:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    31b1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    31b4:	ba 56 55 55 55       	mov    $0x55555556,%edx
    31b9:	89 c8                	mov    %ecx,%eax
    31bb:	f7 ea                	imul   %edx
    31bd:	89 c8                	mov    %ecx,%eax
    31bf:	c1 f8 1f             	sar    $0x1f,%eax
    31c2:	29 c2                	sub    %eax,%edx
    31c4:	89 d0                	mov    %edx,%eax
    31c6:	89 c2                	mov    %eax,%edx
    31c8:	89 d0                	mov    %edx,%eax
    31ca:	01 c0                	add    %eax,%eax
    31cc:	01 d0                	add    %edx,%eax
    31ce:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    31d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31d4:	8d 48 02             	lea    0x2(%eax),%ecx
    31d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31da:	01 c8                	add    %ecx,%eax
    31dc:	0f b6 00             	movzbl (%eax),%eax
    31df:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    31e1:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    31e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31e8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    31eb:	0f 8c 58 ff ff ff    	jl     3149 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    31f1:	8b 45 08             	mov    0x8(%ebp),%eax
    31f4:	8b 55 90             	mov    -0x70(%ebp),%edx
    31f7:	89 10                	mov    %edx,(%eax)
    31f9:	8b 55 94             	mov    -0x6c(%ebp),%edx
    31fc:	89 50 04             	mov    %edx,0x4(%eax)
    31ff:	8b 55 98             	mov    -0x68(%ebp),%edx
    3202:	89 50 08             	mov    %edx,0x8(%eax)
}
    3205:	8b 45 08             	mov    0x8(%ebp),%eax
    3208:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    320b:	c9                   	leave  
    320c:	c2 04 00             	ret    $0x4

0000320f <LoadPng>:

PBitmap LoadPng(char* filename){
    320f:	55                   	push   %ebp
    3210:	89 e5                	mov    %esp,%ebp
    3212:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3215:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    321c:	ff 75 0c             	pushl  0xc(%ebp)
    321f:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3222:	50                   	push   %eax
    3223:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3226:	50                   	push   %eax
    3227:	8d 45 e8             	lea    -0x18(%ebp),%eax
    322a:	50                   	push   %eax
    322b:	e8 d3 d3 00 00       	call   10603 <lodepng_decode24_file>
    3230:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3233:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3236:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    3239:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    323c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    323f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    3246:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3249:	8b 45 d8             	mov    -0x28(%ebp),%eax
    324c:	0f af c2             	imul   %edx,%eax
    324f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    3252:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3255:	89 d0                	mov    %edx,%eax
    3257:	01 c0                	add    %eax,%eax
    3259:	01 d0                	add    %edx,%eax
    325b:	83 ec 0c             	sub    $0xc,%esp
    325e:	50                   	push   %eax
    325f:	e8 6e d5 ff ff       	call   7d2 <malloc>
    3264:	83 c4 10             	add    $0x10,%esp
    3267:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    326a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3271:	e9 87 00 00 00       	jmp    32fd <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    3276:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3279:	8b 55 f4             	mov    -0xc(%ebp),%edx
    327c:	89 d0                	mov    %edx,%eax
    327e:	01 c0                	add    %eax,%eax
    3280:	01 d0                	add    %edx,%eax
    3282:	01 c8                	add    %ecx,%eax
    3284:	0f b6 00             	movzbl (%eax),%eax
    3287:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    328a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    328d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3290:	89 d0                	mov    %edx,%eax
    3292:	01 c0                	add    %eax,%eax
    3294:	01 d0                	add    %edx,%eax
    3296:	83 c0 01             	add    $0x1,%eax
    3299:	01 c8                	add    %ecx,%eax
    329b:	0f b6 00             	movzbl (%eax),%eax
    329e:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    32a1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    32a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32a7:	89 d0                	mov    %edx,%eax
    32a9:	01 c0                	add    %eax,%eax
    32ab:	01 d0                	add    %edx,%eax
    32ad:	83 c0 02             	add    $0x2,%eax
    32b0:	01 c8                	add    %ecx,%eax
    32b2:	0f b6 00             	movzbl (%eax),%eax
    32b5:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    32b8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    32bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32be:	89 d0                	mov    %edx,%eax
    32c0:	01 c0                	add    %eax,%eax
    32c2:	01 d0                	add    %edx,%eax
    32c4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    32c7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    32cb:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    32ce:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    32d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32d4:	89 d0                	mov    %edx,%eax
    32d6:	01 c0                	add    %eax,%eax
    32d8:	01 d0                	add    %edx,%eax
    32da:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    32dd:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    32e1:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    32e4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    32e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32ea:	89 d0                	mov    %edx,%eax
    32ec:	01 c0                	add    %eax,%eax
    32ee:	01 d0                	add    %edx,%eax
    32f0:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    32f3:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    32f7:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    32f9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    32fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3300:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3303:	0f 8c 6d ff ff ff    	jl     3276 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    3309:	8b 45 e8             	mov    -0x18(%ebp),%eax
    330c:	83 ec 0c             	sub    $0xc,%esp
    330f:	50                   	push   %eax
    3310:	e8 7b d3 ff ff       	call   690 <free>
    3315:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3318:	8b 45 08             	mov    0x8(%ebp),%eax
    331b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    331e:	89 10                	mov    %edx,(%eax)
    3320:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3323:	89 50 04             	mov    %edx,0x4(%eax)
    3326:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3329:	89 50 08             	mov    %edx,0x8(%eax)

}
    332c:	8b 45 08             	mov    0x8(%ebp),%eax
    332f:	c9                   	leave  
    3330:	c2 04 00             	ret    $0x4

00003333 <LoadImg>:

PBitmap LoadImg(char* filename){
    3333:	55                   	push   %ebp
    3334:	89 e5                	mov    %esp,%ebp
    3336:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    3339:	83 ec 0c             	sub    $0xc,%esp
    333c:	ff 75 0c             	pushl  0xc(%ebp)
    333f:	e8 7c f8 ff ff       	call   2bc0 <type>
    3344:	83 c4 10             	add    $0x10,%esp
    3347:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    334a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    334d:	83 f8 01             	cmp    $0x1,%eax
    3350:	74 1d                	je     336f <LoadImg+0x3c>
    3352:	83 f8 02             	cmp    $0x2,%eax
    3355:	74 2c                	je     3383 <LoadImg+0x50>
    3357:	85 c0                	test   %eax,%eax
    3359:	75 3c                	jne    3397 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    335b:	8b 45 08             	mov    0x8(%ebp),%eax
    335e:	83 ec 08             	sub    $0x8,%esp
    3361:	ff 75 0c             	pushl  0xc(%ebp)
    3364:	50                   	push   %eax
    3365:	e8 c6 fb ff ff       	call   2f30 <LoadJpeg>
    336a:	83 c4 0c             	add    $0xc,%esp
    336d:	eb 3c                	jmp    33ab <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    336f:	8b 45 08             	mov    0x8(%ebp),%eax
    3372:	83 ec 08             	sub    $0x8,%esp
    3375:	ff 75 0c             	pushl  0xc(%ebp)
    3378:	50                   	push   %eax
    3379:	e8 17 f9 ff ff       	call   2c95 <LoadBmp>
    337e:	83 c4 0c             	add    $0xc,%esp
    3381:	eb 28                	jmp    33ab <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    3383:	8b 45 08             	mov    0x8(%ebp),%eax
    3386:	83 ec 08             	sub    $0x8,%esp
    3389:	ff 75 0c             	pushl  0xc(%ebp)
    338c:	50                   	push   %eax
    338d:	e8 7d fe ff ff       	call   320f <LoadPng>
    3392:	83 c4 0c             	add    $0xc,%esp
    3395:	eb 14                	jmp    33ab <LoadImg+0x78>

        default: return bmp;
    3397:	8b 45 08             	mov    0x8(%ebp),%eax
    339a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    339d:	89 10                	mov    %edx,(%eax)
    339f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    33a2:	89 50 04             	mov    %edx,0x4(%eax)
    33a5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    33a8:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    33ab:	8b 45 08             	mov    0x8(%ebp),%eax
    33ae:	c9                   	leave  
    33af:	c2 04 00             	ret    $0x4

000033b2 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    33b2:	55                   	push   %ebp
    33b3:	89 e5                	mov    %esp,%ebp
    33b5:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    33b8:	8b 45 08             	mov    0x8(%ebp),%eax
    33bb:	83 ec 0c             	sub    $0xc,%esp
    33be:	50                   	push   %eax
    33bf:	e8 0e d4 ff ff       	call   7d2 <malloc>
    33c4:	83 c4 10             	add    $0x10,%esp
}
    33c7:	c9                   	leave  
    33c8:	c3                   	ret    

000033c9 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    33c9:	55                   	push   %ebp
    33ca:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    33cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    33d1:	5d                   	pop    %ebp
    33d2:	c3                   	ret    

000033d3 <lodepng_free>:

static void lodepng_free(void* ptr) {
    33d3:	55                   	push   %ebp
    33d4:	89 e5                	mov    %esp,%ebp
    33d6:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    33d9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    33dd:	74 0e                	je     33ed <lodepng_free+0x1a>
    free(ptr);
    33df:	83 ec 0c             	sub    $0xc,%esp
    33e2:	ff 75 08             	pushl  0x8(%ebp)
    33e5:	e8 a6 d2 ff ff       	call   690 <free>
    33ea:	83 c4 10             	add    $0x10,%esp
}
    33ed:	90                   	nop
    33ee:	c9                   	leave  
    33ef:	c3                   	ret    

000033f0 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    33f0:	55                   	push   %ebp
    33f1:	89 e5                	mov    %esp,%ebp
    33f3:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    33f6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    33fd:	eb 19                	jmp    3418 <lodepng_memcpy+0x28>
    33ff:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3402:	8b 45 08             	mov    0x8(%ebp),%eax
    3405:	01 c2                	add    %eax,%edx
    3407:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    340a:	8b 45 0c             	mov    0xc(%ebp),%eax
    340d:	01 c8                	add    %ecx,%eax
    340f:	0f b6 00             	movzbl (%eax),%eax
    3412:	88 02                	mov    %al,(%edx)
    3414:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3418:	8b 45 fc             	mov    -0x4(%ebp),%eax
    341b:	3b 45 10             	cmp    0x10(%ebp),%eax
    341e:	7c df                	jl     33ff <lodepng_memcpy+0xf>
}
    3420:	90                   	nop
    3421:	c9                   	leave  
    3422:	c3                   	ret    

00003423 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3423:	55                   	push   %ebp
    3424:	89 e5                	mov    %esp,%ebp
    3426:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    3429:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3430:	eb 11                	jmp    3443 <lodepng_memset+0x20>
    3432:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3435:	8b 45 08             	mov    0x8(%ebp),%eax
    3438:	01 d0                	add    %edx,%eax
    343a:	8b 55 0c             	mov    0xc(%ebp),%edx
    343d:	88 10                	mov    %dl,(%eax)
    343f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3443:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3446:	3b 45 10             	cmp    0x10(%ebp),%eax
    3449:	7c e7                	jl     3432 <lodepng_memset+0xf>
}
    344b:	90                   	nop
    344c:	c9                   	leave  
    344d:	c3                   	ret    

0000344e <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    344e:	55                   	push   %ebp
    344f:	89 e5                	mov    %esp,%ebp
    3451:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3454:	8b 45 08             	mov    0x8(%ebp),%eax
    3457:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    345a:	eb 04                	jmp    3460 <lodepng_strlen+0x12>
    345c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3460:	8b 45 08             	mov    0x8(%ebp),%eax
    3463:	0f b6 00             	movzbl (%eax),%eax
    3466:	84 c0                	test   %al,%al
    3468:	75 f2                	jne    345c <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    346a:	8b 55 08             	mov    0x8(%ebp),%edx
    346d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3470:	29 c2                	sub    %eax,%edx
    3472:	89 d0                	mov    %edx,%eax
}
    3474:	c9                   	leave  
    3475:	c3                   	ret    

00003476 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    3476:	55                   	push   %ebp
    3477:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    3479:	8b 55 08             	mov    0x8(%ebp),%edx
    347c:	8b 45 0c             	mov    0xc(%ebp),%eax
    347f:	01 c2                	add    %eax,%edx
    3481:	8b 45 10             	mov    0x10(%ebp),%eax
    3484:	89 10                	mov    %edx,(%eax)
  return *result < a;
    3486:	8b 45 10             	mov    0x10(%ebp),%eax
    3489:	8b 00                	mov    (%eax),%eax
    348b:	3b 45 08             	cmp    0x8(%ebp),%eax
    348e:	0f 9c c0             	setl   %al
    3491:	0f b6 c0             	movzbl %al,%eax
}
    3494:	5d                   	pop    %ebp
    3495:	c3                   	ret    

00003496 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3496:	55                   	push   %ebp
    3497:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    3499:	8b 45 08             	mov    0x8(%ebp),%eax
    349c:	0f af 45 0c          	imul   0xc(%ebp),%eax
    34a0:	89 c2                	mov    %eax,%edx
    34a2:	8b 45 10             	mov    0x10(%ebp),%eax
    34a5:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    34a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    34ab:	74 15                	je     34c2 <lodepng_mulofl+0x2c>
    34ad:	8b 45 10             	mov    0x10(%ebp),%eax
    34b0:	8b 00                	mov    (%eax),%eax
    34b2:	99                   	cltd   
    34b3:	f7 7d 08             	idivl  0x8(%ebp)
    34b6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    34b9:	74 07                	je     34c2 <lodepng_mulofl+0x2c>
    34bb:	b8 01 00 00 00       	mov    $0x1,%eax
    34c0:	eb 05                	jmp    34c7 <lodepng_mulofl+0x31>
    34c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    34c7:	5d                   	pop    %ebp
    34c8:	c3                   	ret    

000034c9 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    34c9:	55                   	push   %ebp
    34ca:	89 e5                	mov    %esp,%ebp
    34cc:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    34cf:	8d 45 fc             	lea    -0x4(%ebp),%eax
    34d2:	50                   	push   %eax
    34d3:	ff 75 0c             	pushl  0xc(%ebp)
    34d6:	ff 75 08             	pushl  0x8(%ebp)
    34d9:	e8 98 ff ff ff       	call   3476 <lodepng_addofl>
    34de:	83 c4 0c             	add    $0xc,%esp
    34e1:	85 c0                	test   %eax,%eax
    34e3:	74 07                	je     34ec <lodepng_gtofl+0x23>
    34e5:	b8 01 00 00 00       	mov    $0x1,%eax
    34ea:	eb 0c                	jmp    34f8 <lodepng_gtofl+0x2f>
  return d > c;
    34ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34ef:	3b 45 10             	cmp    0x10(%ebp),%eax
    34f2:	0f 9f c0             	setg   %al
    34f5:	0f b6 c0             	movzbl %al,%eax
}
    34f8:	c9                   	leave  
    34f9:	c3                   	ret    

000034fa <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    34fa:	55                   	push   %ebp
    34fb:	89 e5                	mov    %esp,%ebp
    34fd:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3500:	8b 45 08             	mov    0x8(%ebp),%eax
    3503:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    350a:	8b 45 08             	mov    0x8(%ebp),%eax
    350d:	8b 50 08             	mov    0x8(%eax),%edx
    3510:	8b 45 08             	mov    0x8(%ebp),%eax
    3513:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3516:	8b 45 08             	mov    0x8(%ebp),%eax
    3519:	8b 00                	mov    (%eax),%eax
    351b:	83 ec 0c             	sub    $0xc,%esp
    351e:	50                   	push   %eax
    351f:	e8 af fe ff ff       	call   33d3 <lodepng_free>
    3524:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    3527:	8b 45 08             	mov    0x8(%ebp),%eax
    352a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3530:	90                   	nop
    3531:	c9                   	leave  
    3532:	c3                   	ret    

00003533 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3533:	55                   	push   %ebp
    3534:	89 e5                	mov    %esp,%ebp
    3536:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    3539:	8b 45 0c             	mov    0xc(%ebp),%eax
    353c:	c1 e0 02             	shl    $0x2,%eax
    353f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3542:	8b 45 08             	mov    0x8(%ebp),%eax
    3545:	8b 40 08             	mov    0x8(%eax),%eax
    3548:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    354b:	7d 46                	jge    3593 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    354d:	8b 45 08             	mov    0x8(%ebp),%eax
    3550:	8b 40 08             	mov    0x8(%eax),%eax
    3553:	d1 f8                	sar    %eax
    3555:	89 c2                	mov    %eax,%edx
    3557:	8b 45 fc             	mov    -0x4(%ebp),%eax
    355a:	01 d0                	add    %edx,%eax
    355c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    355f:	8b 45 08             	mov    0x8(%ebp),%eax
    3562:	8b 00                	mov    (%eax),%eax
    3564:	ff 75 f8             	pushl  -0x8(%ebp)
    3567:	50                   	push   %eax
    3568:	e8 5c fe ff ff       	call   33c9 <lodepng_realloc>
    356d:	83 c4 08             	add    $0x8,%esp
    3570:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    3573:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3577:	74 13                	je     358c <uivector_resize+0x59>
      p->allocsize = newsize;
    3579:	8b 45 08             	mov    0x8(%ebp),%eax
    357c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    357f:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    3582:	8b 45 08             	mov    0x8(%ebp),%eax
    3585:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3588:	89 10                	mov    %edx,(%eax)
    358a:	eb 07                	jmp    3593 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    358c:	b8 00 00 00 00       	mov    $0x0,%eax
    3591:	eb 0e                	jmp    35a1 <uivector_resize+0x6e>
  }
  p->size = size;
    3593:	8b 45 08             	mov    0x8(%ebp),%eax
    3596:	8b 55 0c             	mov    0xc(%ebp),%edx
    3599:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    359c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    35a1:	c9                   	leave  
    35a2:	c3                   	ret    

000035a3 <uivector_init>:

static void uivector_init(uivector* p) {
    35a3:	55                   	push   %ebp
    35a4:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    35a6:	8b 45 08             	mov    0x8(%ebp),%eax
    35a9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    35af:	8b 45 08             	mov    0x8(%ebp),%eax
    35b2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    35b9:	8b 45 08             	mov    0x8(%ebp),%eax
    35bc:	8b 50 08             	mov    0x8(%eax),%edx
    35bf:	8b 45 08             	mov    0x8(%ebp),%eax
    35c2:	89 50 04             	mov    %edx,0x4(%eax)
}
    35c5:	90                   	nop
    35c6:	5d                   	pop    %ebp
    35c7:	c3                   	ret    

000035c8 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    35c8:	55                   	push   %ebp
    35c9:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    35cb:	8b 45 08             	mov    0x8(%ebp),%eax
    35ce:	8b 40 04             	mov    0x4(%eax),%eax
    35d1:	83 c0 01             	add    $0x1,%eax
    35d4:	50                   	push   %eax
    35d5:	ff 75 08             	pushl  0x8(%ebp)
    35d8:	e8 56 ff ff ff       	call   3533 <uivector_resize>
    35dd:	83 c4 08             	add    $0x8,%esp
    35e0:	85 c0                	test   %eax,%eax
    35e2:	75 07                	jne    35eb <uivector_push_back+0x23>
    35e4:	b8 00 00 00 00       	mov    $0x0,%eax
    35e9:	eb 1f                	jmp    360a <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    35eb:	8b 45 08             	mov    0x8(%ebp),%eax
    35ee:	8b 10                	mov    (%eax),%edx
    35f0:	8b 45 08             	mov    0x8(%ebp),%eax
    35f3:	8b 40 04             	mov    0x4(%eax),%eax
    35f6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    35fb:	c1 e0 02             	shl    $0x2,%eax
    35fe:	01 c2                	add    %eax,%edx
    3600:	8b 45 0c             	mov    0xc(%ebp),%eax
    3603:	89 02                	mov    %eax,(%edx)
  return 1;
    3605:	b8 01 00 00 00       	mov    $0x1,%eax
}
    360a:	c9                   	leave  
    360b:	c3                   	ret    

0000360c <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    360c:	55                   	push   %ebp
    360d:	89 e5                	mov    %esp,%ebp
    360f:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3612:	8b 45 08             	mov    0x8(%ebp),%eax
    3615:	8b 40 08             	mov    0x8(%eax),%eax
    3618:	3b 45 0c             	cmp    0xc(%ebp),%eax
    361b:	7d 46                	jge    3663 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    361d:	8b 45 08             	mov    0x8(%ebp),%eax
    3620:	8b 40 08             	mov    0x8(%eax),%eax
    3623:	d1 f8                	sar    %eax
    3625:	89 c2                	mov    %eax,%edx
    3627:	8b 45 0c             	mov    0xc(%ebp),%eax
    362a:	01 d0                	add    %edx,%eax
    362c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    362f:	8b 45 08             	mov    0x8(%ebp),%eax
    3632:	8b 00                	mov    (%eax),%eax
    3634:	ff 75 fc             	pushl  -0x4(%ebp)
    3637:	50                   	push   %eax
    3638:	e8 8c fd ff ff       	call   33c9 <lodepng_realloc>
    363d:	83 c4 08             	add    $0x8,%esp
    3640:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3643:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    3647:	74 13                	je     365c <ucvector_resize+0x50>
      p->allocsize = newsize;
    3649:	8b 45 08             	mov    0x8(%ebp),%eax
    364c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    364f:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    3652:	8b 45 08             	mov    0x8(%ebp),%eax
    3655:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3658:	89 10                	mov    %edx,(%eax)
    365a:	eb 07                	jmp    3663 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    365c:	b8 00 00 00 00       	mov    $0x0,%eax
    3661:	eb 0e                	jmp    3671 <ucvector_resize+0x65>
  }
  p->size = size;
    3663:	8b 45 08             	mov    0x8(%ebp),%eax
    3666:	8b 55 0c             	mov    0xc(%ebp),%edx
    3669:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    366c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3671:	c9                   	leave  
    3672:	c3                   	ret    

00003673 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    3673:	55                   	push   %ebp
    3674:	89 e5                	mov    %esp,%ebp
    3676:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    3679:	8b 45 0c             	mov    0xc(%ebp),%eax
    367c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    367f:	8b 45 10             	mov    0x10(%ebp),%eax
    3682:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3685:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3688:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    368b:	8b 45 08             	mov    0x8(%ebp),%eax
    368e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3691:	89 10                	mov    %edx,(%eax)
    3693:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3696:	89 50 04             	mov    %edx,0x4(%eax)
    3699:	8b 55 fc             	mov    -0x4(%ebp),%edx
    369c:	89 50 08             	mov    %edx,0x8(%eax)
}
    369f:	8b 45 08             	mov    0x8(%ebp),%eax
    36a2:	c9                   	leave  
    36a3:	c2 04 00             	ret    $0x4

000036a6 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    36a6:	55                   	push   %ebp
    36a7:	89 e5                	mov    %esp,%ebp
    36a9:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    36ac:	8b 45 08             	mov    0x8(%ebp),%eax
    36af:	8b 00                	mov    (%eax),%eax
    36b1:	83 ec 0c             	sub    $0xc,%esp
    36b4:	50                   	push   %eax
    36b5:	e8 19 fd ff ff       	call   33d3 <lodepng_free>
    36ba:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    36bd:	8b 45 08             	mov    0x8(%ebp),%eax
    36c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    36c6:	90                   	nop
    36c7:	c9                   	leave  
    36c8:	c3                   	ret    

000036c9 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    36c9:	55                   	push   %ebp
    36ca:	89 e5                	mov    %esp,%ebp
    36cc:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    36cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    36d2:	83 c0 01             	add    $0x1,%eax
    36d5:	83 ec 0c             	sub    $0xc,%esp
    36d8:	50                   	push   %eax
    36d9:	e8 d4 fc ff ff       	call   33b2 <lodepng_malloc>
    36de:	83 c4 10             	add    $0x10,%esp
    36e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    36e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    36e8:	74 1f                	je     3709 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    36ea:	83 ec 04             	sub    $0x4,%esp
    36ed:	ff 75 0c             	pushl  0xc(%ebp)
    36f0:	ff 75 08             	pushl  0x8(%ebp)
    36f3:	ff 75 f4             	pushl  -0xc(%ebp)
    36f6:	e8 f5 fc ff ff       	call   33f0 <lodepng_memcpy>
    36fb:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    36fe:	8b 55 0c             	mov    0xc(%ebp),%edx
    3701:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3704:	01 d0                	add    %edx,%eax
    3706:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    3709:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    370c:	c9                   	leave  
    370d:	c3                   	ret    

0000370e <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    370e:	55                   	push   %ebp
    370f:	89 e5                	mov    %esp,%ebp
    3711:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3714:	ff 75 08             	pushl  0x8(%ebp)
    3717:	e8 32 fd ff ff       	call   344e <lodepng_strlen>
    371c:	83 c4 04             	add    $0x4,%esp
    371f:	83 ec 08             	sub    $0x8,%esp
    3722:	50                   	push   %eax
    3723:	ff 75 08             	pushl  0x8(%ebp)
    3726:	e8 9e ff ff ff       	call   36c9 <alloc_string_sized>
    372b:	83 c4 10             	add    $0x10,%esp
}
    372e:	c9                   	leave  
    372f:	c3                   	ret    

00003730 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3730:	55                   	push   %ebp
    3731:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3733:	8b 45 08             	mov    0x8(%ebp),%eax
    3736:	0f b6 00             	movzbl (%eax),%eax
    3739:	0f b6 c0             	movzbl %al,%eax
    373c:	c1 e0 18             	shl    $0x18,%eax
    373f:	89 c2                	mov    %eax,%edx
    3741:	8b 45 08             	mov    0x8(%ebp),%eax
    3744:	83 c0 01             	add    $0x1,%eax
    3747:	0f b6 00             	movzbl (%eax),%eax
    374a:	0f b6 c0             	movzbl %al,%eax
    374d:	c1 e0 10             	shl    $0x10,%eax
    3750:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3752:	8b 45 08             	mov    0x8(%ebp),%eax
    3755:	83 c0 02             	add    $0x2,%eax
    3758:	0f b6 00             	movzbl (%eax),%eax
    375b:	0f b6 c0             	movzbl %al,%eax
    375e:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3761:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3763:	8b 45 08             	mov    0x8(%ebp),%eax
    3766:	83 c0 03             	add    $0x3,%eax
    3769:	0f b6 00             	movzbl (%eax),%eax
    376c:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    376f:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    3771:	5d                   	pop    %ebp
    3772:	c3                   	ret    

00003773 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    3773:	55                   	push   %ebp
    3774:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    3776:	8b 45 0c             	mov    0xc(%ebp),%eax
    3779:	c1 e8 18             	shr    $0x18,%eax
    377c:	89 c2                	mov    %eax,%edx
    377e:	8b 45 08             	mov    0x8(%ebp),%eax
    3781:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    3783:	8b 45 08             	mov    0x8(%ebp),%eax
    3786:	83 c0 01             	add    $0x1,%eax
    3789:	8b 55 0c             	mov    0xc(%ebp),%edx
    378c:	c1 ea 10             	shr    $0x10,%edx
    378f:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    3791:	8b 45 08             	mov    0x8(%ebp),%eax
    3794:	83 c0 02             	add    $0x2,%eax
    3797:	8b 55 0c             	mov    0xc(%ebp),%edx
    379a:	c1 ea 08             	shr    $0x8,%edx
    379d:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    379f:	8b 45 08             	mov    0x8(%ebp),%eax
    37a2:	83 c0 03             	add    $0x3,%eax
    37a5:	8b 55 0c             	mov    0xc(%ebp),%edx
    37a8:	88 10                	mov    %dl,(%eax)
}
    37aa:	90                   	nop
    37ab:	5d                   	pop    %ebp
    37ac:	c3                   	ret    

000037ad <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    37ad:	55                   	push   %ebp
    37ae:	89 e5                	mov    %esp,%ebp
    37b0:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    37b3:	83 ec 08             	sub    $0x8,%esp
    37b6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    37b9:	50                   	push   %eax
    37ba:	ff 75 08             	pushl  0x8(%ebp)
    37bd:	e8 b7 ca ff ff       	call   279 <stat>
    37c2:	83 c4 10             	add    $0x10,%esp
  return s.size;
    37c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    37c8:	c9                   	leave  
    37c9:	c3                   	ret    

000037ca <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    37ca:	55                   	push   %ebp
    37cb:	89 e5                	mov    %esp,%ebp
    37cd:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    37d0:	83 ec 08             	sub    $0x8,%esp
    37d3:	6a 00                	push   $0x0
    37d5:	ff 75 10             	pushl  0x10(%ebp)
    37d8:	e8 bb cb ff ff       	call   398 <open>
    37dd:	83 c4 10             	add    $0x10,%esp
    37e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    37e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37e7:	79 07                	jns    37f0 <lodepng_buffer_file+0x26>
  {
      return -1;
    37e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    37ee:	eb 19                	jmp    3809 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    37f0:	83 ec 04             	sub    $0x4,%esp
    37f3:	ff 75 0c             	pushl  0xc(%ebp)
    37f6:	ff 75 08             	pushl  0x8(%ebp)
    37f9:	ff 75 f4             	pushl  -0xc(%ebp)
    37fc:	e8 6f cb ff ff       	call   370 <read>
    3801:	83 c4 10             	add    $0x10,%esp
  return 0;
    3804:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3809:	c9                   	leave  
    380a:	c3                   	ret    

0000380b <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    380b:	55                   	push   %ebp
    380c:	89 e5                	mov    %esp,%ebp
    380e:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3811:	83 ec 0c             	sub    $0xc,%esp
    3814:	ff 75 10             	pushl  0x10(%ebp)
    3817:	e8 91 ff ff ff       	call   37ad <lodepng_filesize>
    381c:	83 c4 10             	add    $0x10,%esp
    381f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3822:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3826:	79 07                	jns    382f <lodepng_load_file+0x24>
    3828:	b8 4e 00 00 00       	mov    $0x4e,%eax
    382d:	eb 4a                	jmp    3879 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    382f:	8b 45 0c             	mov    0xc(%ebp),%eax
    3832:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3835:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3837:	83 ec 0c             	sub    $0xc,%esp
    383a:	ff 75 f4             	pushl  -0xc(%ebp)
    383d:	e8 70 fb ff ff       	call   33b2 <lodepng_malloc>
    3842:	83 c4 10             	add    $0x10,%esp
    3845:	89 c2                	mov    %eax,%edx
    3847:	8b 45 08             	mov    0x8(%ebp),%eax
    384a:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    384c:	8b 45 08             	mov    0x8(%ebp),%eax
    384f:	8b 00                	mov    (%eax),%eax
    3851:	85 c0                	test   %eax,%eax
    3853:	75 0d                	jne    3862 <lodepng_load_file+0x57>
    3855:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3859:	7e 07                	jle    3862 <lodepng_load_file+0x57>
    385b:	b8 53 00 00 00       	mov    $0x53,%eax
    3860:	eb 17                	jmp    3879 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    3862:	8b 45 08             	mov    0x8(%ebp),%eax
    3865:	8b 00                	mov    (%eax),%eax
    3867:	83 ec 04             	sub    $0x4,%esp
    386a:	ff 75 10             	pushl  0x10(%ebp)
    386d:	ff 75 f4             	pushl  -0xc(%ebp)
    3870:	50                   	push   %eax
    3871:	e8 54 ff ff ff       	call   37ca <lodepng_buffer_file>
    3876:	83 c4 10             	add    $0x10,%esp
}
    3879:	c9                   	leave  
    387a:	c3                   	ret    

0000387b <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    387b:	55                   	push   %ebp
    387c:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    387e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3883:	5d                   	pop    %ebp
    3884:	c3                   	ret    

00003885 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3885:	55                   	push   %ebp
    3886:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3888:	8b 45 08             	mov    0x8(%ebp),%eax
    388b:	8b 55 0c             	mov    0xc(%ebp),%edx
    388e:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3890:	8b 45 08             	mov    0x8(%ebp),%eax
    3893:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3897:	90                   	nop
    3898:	5d                   	pop    %ebp
    3899:	c3                   	ret    

0000389a <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    389a:	55                   	push   %ebp
    389b:	89 e5                	mov    %esp,%ebp
    389d:	56                   	push   %esi
    389e:	53                   	push   %ebx
    389f:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    38a2:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    38a6:	0f 85 aa 00 00 00    	jne    3956 <writeBits+0xbc>
    WRITEBIT(writer, value);
    38ac:	8b 45 08             	mov    0x8(%ebp),%eax
    38af:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38b3:	0f b6 c0             	movzbl %al,%eax
    38b6:	83 e0 07             	and    $0x7,%eax
    38b9:	85 c0                	test   %eax,%eax
    38bb:	75 39                	jne    38f6 <writeBits+0x5c>
    38bd:	8b 45 08             	mov    0x8(%ebp),%eax
    38c0:	8b 00                	mov    (%eax),%eax
    38c2:	8b 40 04             	mov    0x4(%eax),%eax
    38c5:	8d 50 01             	lea    0x1(%eax),%edx
    38c8:	8b 45 08             	mov    0x8(%ebp),%eax
    38cb:	8b 00                	mov    (%eax),%eax
    38cd:	52                   	push   %edx
    38ce:	50                   	push   %eax
    38cf:	e8 38 fd ff ff       	call   360c <ucvector_resize>
    38d4:	83 c4 08             	add    $0x8,%esp
    38d7:	85 c0                	test   %eax,%eax
    38d9:	0f 84 44 01 00 00    	je     3a23 <writeBits+0x189>
    38df:	8b 45 08             	mov    0x8(%ebp),%eax
    38e2:	8b 00                	mov    (%eax),%eax
    38e4:	8b 10                	mov    (%eax),%edx
    38e6:	8b 45 08             	mov    0x8(%ebp),%eax
    38e9:	8b 00                	mov    (%eax),%eax
    38eb:	8b 40 04             	mov    0x4(%eax),%eax
    38ee:	83 e8 01             	sub    $0x1,%eax
    38f1:	01 d0                	add    %edx,%eax
    38f3:	c6 00 00             	movb   $0x0,(%eax)
    38f6:	8b 45 08             	mov    0x8(%ebp),%eax
    38f9:	8b 00                	mov    (%eax),%eax
    38fb:	8b 10                	mov    (%eax),%edx
    38fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3900:	8b 00                	mov    (%eax),%eax
    3902:	8b 40 04             	mov    0x4(%eax),%eax
    3905:	83 e8 01             	sub    $0x1,%eax
    3908:	01 c2                	add    %eax,%edx
    390a:	8b 45 08             	mov    0x8(%ebp),%eax
    390d:	8b 00                	mov    (%eax),%eax
    390f:	8b 08                	mov    (%eax),%ecx
    3911:	8b 45 08             	mov    0x8(%ebp),%eax
    3914:	8b 00                	mov    (%eax),%eax
    3916:	8b 40 04             	mov    0x4(%eax),%eax
    3919:	83 e8 01             	sub    $0x1,%eax
    391c:	01 c8                	add    %ecx,%eax
    391e:	0f b6 00             	movzbl (%eax),%eax
    3921:	88 45 e7             	mov    %al,-0x19(%ebp)
    3924:	8b 45 08             	mov    0x8(%ebp),%eax
    3927:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    392b:	0f b6 c0             	movzbl %al,%eax
    392e:	83 e0 07             	and    $0x7,%eax
    3931:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3934:	89 de                	mov    %ebx,%esi
    3936:	89 c1                	mov    %eax,%ecx
    3938:	d3 e6                	shl    %cl,%esi
    393a:	89 f0                	mov    %esi,%eax
    393c:	0a 45 e7             	or     -0x19(%ebp),%al
    393f:	88 02                	mov    %al,(%edx)
    3941:	8b 45 08             	mov    0x8(%ebp),%eax
    3944:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3948:	8d 50 01             	lea    0x1(%eax),%edx
    394b:	8b 45 08             	mov    0x8(%ebp),%eax
    394e:	88 50 04             	mov    %dl,0x4(%eax)
    3951:	e9 d1 00 00 00       	jmp    3a27 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3956:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    395d:	e9 b3 00 00 00       	jmp    3a15 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3962:	8b 45 08             	mov    0x8(%ebp),%eax
    3965:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3969:	0f b6 c0             	movzbl %al,%eax
    396c:	83 e0 07             	and    $0x7,%eax
    396f:	85 c0                	test   %eax,%eax
    3971:	75 39                	jne    39ac <writeBits+0x112>
    3973:	8b 45 08             	mov    0x8(%ebp),%eax
    3976:	8b 00                	mov    (%eax),%eax
    3978:	8b 40 04             	mov    0x4(%eax),%eax
    397b:	8d 50 01             	lea    0x1(%eax),%edx
    397e:	8b 45 08             	mov    0x8(%ebp),%eax
    3981:	8b 00                	mov    (%eax),%eax
    3983:	52                   	push   %edx
    3984:	50                   	push   %eax
    3985:	e8 82 fc ff ff       	call   360c <ucvector_resize>
    398a:	83 c4 08             	add    $0x8,%esp
    398d:	85 c0                	test   %eax,%eax
    398f:	0f 84 91 00 00 00    	je     3a26 <writeBits+0x18c>
    3995:	8b 45 08             	mov    0x8(%ebp),%eax
    3998:	8b 00                	mov    (%eax),%eax
    399a:	8b 10                	mov    (%eax),%edx
    399c:	8b 45 08             	mov    0x8(%ebp),%eax
    399f:	8b 00                	mov    (%eax),%eax
    39a1:	8b 40 04             	mov    0x4(%eax),%eax
    39a4:	83 e8 01             	sub    $0x1,%eax
    39a7:	01 d0                	add    %edx,%eax
    39a9:	c6 00 00             	movb   $0x0,(%eax)
    39ac:	8b 45 08             	mov    0x8(%ebp),%eax
    39af:	8b 00                	mov    (%eax),%eax
    39b1:	8b 10                	mov    (%eax),%edx
    39b3:	8b 45 08             	mov    0x8(%ebp),%eax
    39b6:	8b 00                	mov    (%eax),%eax
    39b8:	8b 40 04             	mov    0x4(%eax),%eax
    39bb:	83 e8 01             	sub    $0x1,%eax
    39be:	01 c2                	add    %eax,%edx
    39c0:	8b 45 08             	mov    0x8(%ebp),%eax
    39c3:	8b 00                	mov    (%eax),%eax
    39c5:	8b 08                	mov    (%eax),%ecx
    39c7:	8b 45 08             	mov    0x8(%ebp),%eax
    39ca:	8b 00                	mov    (%eax),%eax
    39cc:	8b 40 04             	mov    0x4(%eax),%eax
    39cf:	83 e8 01             	sub    $0x1,%eax
    39d2:	01 c8                	add    %ecx,%eax
    39d4:	0f b6 00             	movzbl (%eax),%eax
    39d7:	89 c6                	mov    %eax,%esi
    39d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    39dc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    39df:	89 c1                	mov    %eax,%ecx
    39e1:	d3 eb                	shr    %cl,%ebx
    39e3:	89 d8                	mov    %ebx,%eax
    39e5:	83 e0 01             	and    $0x1,%eax
    39e8:	89 c3                	mov    %eax,%ebx
    39ea:	8b 45 08             	mov    0x8(%ebp),%eax
    39ed:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39f1:	0f b6 c0             	movzbl %al,%eax
    39f4:	83 e0 07             	and    $0x7,%eax
    39f7:	89 c1                	mov    %eax,%ecx
    39f9:	d3 e3                	shl    %cl,%ebx
    39fb:	89 d8                	mov    %ebx,%eax
    39fd:	09 f0                	or     %esi,%eax
    39ff:	88 02                	mov    %al,(%edx)
    3a01:	8b 45 08             	mov    0x8(%ebp),%eax
    3a04:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a08:	8d 50 01             	lea    0x1(%eax),%edx
    3a0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3a0e:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3a11:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a15:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a18:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a1b:	0f 85 41 ff ff ff    	jne    3962 <writeBits+0xc8>
    3a21:	eb 04                	jmp    3a27 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3a23:	90                   	nop
    3a24:	eb 01                	jmp    3a27 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3a26:	90                   	nop
    }
  }
}
    3a27:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a2a:	5b                   	pop    %ebx
    3a2b:	5e                   	pop    %esi
    3a2c:	5d                   	pop    %ebp
    3a2d:	c3                   	ret    

00003a2e <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3a2e:	55                   	push   %ebp
    3a2f:	89 e5                	mov    %esp,%ebp
    3a31:	56                   	push   %esi
    3a32:	53                   	push   %ebx
    3a33:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3a3d:	e9 bd 00 00 00       	jmp    3aff <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a42:	8b 45 08             	mov    0x8(%ebp),%eax
    3a45:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a49:	0f b6 c0             	movzbl %al,%eax
    3a4c:	83 e0 07             	and    $0x7,%eax
    3a4f:	85 c0                	test   %eax,%eax
    3a51:	75 39                	jne    3a8c <writeBitsReversed+0x5e>
    3a53:	8b 45 08             	mov    0x8(%ebp),%eax
    3a56:	8b 00                	mov    (%eax),%eax
    3a58:	8b 40 04             	mov    0x4(%eax),%eax
    3a5b:	8d 50 01             	lea    0x1(%eax),%edx
    3a5e:	8b 45 08             	mov    0x8(%ebp),%eax
    3a61:	8b 00                	mov    (%eax),%eax
    3a63:	52                   	push   %edx
    3a64:	50                   	push   %eax
    3a65:	e8 a2 fb ff ff       	call   360c <ucvector_resize>
    3a6a:	83 c4 08             	add    $0x8,%esp
    3a6d:	85 c0                	test   %eax,%eax
    3a6f:	0f 84 98 00 00 00    	je     3b0d <writeBitsReversed+0xdf>
    3a75:	8b 45 08             	mov    0x8(%ebp),%eax
    3a78:	8b 00                	mov    (%eax),%eax
    3a7a:	8b 10                	mov    (%eax),%edx
    3a7c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a7f:	8b 00                	mov    (%eax),%eax
    3a81:	8b 40 04             	mov    0x4(%eax),%eax
    3a84:	83 e8 01             	sub    $0x1,%eax
    3a87:	01 d0                	add    %edx,%eax
    3a89:	c6 00 00             	movb   $0x0,(%eax)
    3a8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a8f:	8b 00                	mov    (%eax),%eax
    3a91:	8b 10                	mov    (%eax),%edx
    3a93:	8b 45 08             	mov    0x8(%ebp),%eax
    3a96:	8b 00                	mov    (%eax),%eax
    3a98:	8b 40 04             	mov    0x4(%eax),%eax
    3a9b:	83 e8 01             	sub    $0x1,%eax
    3a9e:	01 c2                	add    %eax,%edx
    3aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa3:	8b 00                	mov    (%eax),%eax
    3aa5:	8b 08                	mov    (%eax),%ecx
    3aa7:	8b 45 08             	mov    0x8(%ebp),%eax
    3aaa:	8b 00                	mov    (%eax),%eax
    3aac:	8b 40 04             	mov    0x4(%eax),%eax
    3aaf:	83 e8 01             	sub    $0x1,%eax
    3ab2:	01 c8                	add    %ecx,%eax
    3ab4:	0f b6 00             	movzbl (%eax),%eax
    3ab7:	89 c6                	mov    %eax,%esi
    3ab9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3abc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3abf:	29 c1                	sub    %eax,%ecx
    3ac1:	89 c8                	mov    %ecx,%eax
    3ac3:	83 e8 01             	sub    $0x1,%eax
    3ac6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3ac9:	89 c1                	mov    %eax,%ecx
    3acb:	d3 eb                	shr    %cl,%ebx
    3acd:	89 d8                	mov    %ebx,%eax
    3acf:	83 e0 01             	and    $0x1,%eax
    3ad2:	89 c3                	mov    %eax,%ebx
    3ad4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ad7:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3adb:	0f b6 c0             	movzbl %al,%eax
    3ade:	83 e0 07             	and    $0x7,%eax
    3ae1:	89 c1                	mov    %eax,%ecx
    3ae3:	d3 e3                	shl    %cl,%ebx
    3ae5:	89 d8                	mov    %ebx,%eax
    3ae7:	09 f0                	or     %esi,%eax
    3ae9:	88 02                	mov    %al,(%edx)
    3aeb:	8b 45 08             	mov    0x8(%ebp),%eax
    3aee:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3af2:	8d 50 01             	lea    0x1(%eax),%edx
    3af5:	8b 45 08             	mov    0x8(%ebp),%eax
    3af8:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3afb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3aff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b02:	3b 45 10             	cmp    0x10(%ebp),%eax
    3b05:	0f 85 37 ff ff ff    	jne    3a42 <writeBitsReversed+0x14>
    3b0b:	eb 01                	jmp    3b0e <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3b0d:	90                   	nop
  }
}
    3b0e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3b11:	5b                   	pop    %ebx
    3b12:	5e                   	pop    %esi
    3b13:	5d                   	pop    %ebp
    3b14:	c3                   	ret    

00003b15 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3b15:	55                   	push   %ebp
    3b16:	89 e5                	mov    %esp,%ebp
    3b18:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3b1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b1e:	8b 55 0c             	mov    0xc(%ebp),%edx
    3b21:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3b23:	8b 45 08             	mov    0x8(%ebp),%eax
    3b26:	8b 55 10             	mov    0x10(%ebp),%edx
    3b29:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3b2c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b2f:	83 c0 08             	add    $0x8,%eax
    3b32:	50                   	push   %eax
    3b33:	6a 08                	push   $0x8
    3b35:	ff 75 10             	pushl  0x10(%ebp)
    3b38:	e8 59 f9 ff ff       	call   3496 <lodepng_mulofl>
    3b3d:	83 c4 0c             	add    $0xc,%esp
    3b40:	85 c0                	test   %eax,%eax
    3b42:	74 07                	je     3b4b <LodePNGBitReader_init+0x36>
    3b44:	b8 69 00 00 00       	mov    $0x69,%eax
    3b49:	eb 39                	jmp    3b84 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3b4b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b4e:	8b 40 08             	mov    0x8(%eax),%eax
    3b51:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3b54:	52                   	push   %edx
    3b55:	6a 40                	push   $0x40
    3b57:	50                   	push   %eax
    3b58:	e8 19 f9 ff ff       	call   3476 <lodepng_addofl>
    3b5d:	83 c4 0c             	add    $0xc,%esp
    3b60:	85 c0                	test   %eax,%eax
    3b62:	74 07                	je     3b6b <LodePNGBitReader_init+0x56>
    3b64:	b8 69 00 00 00       	mov    $0x69,%eax
    3b69:	eb 19                	jmp    3b84 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3b6b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b6e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3b75:	8b 45 08             	mov    0x8(%ebp),%eax
    3b78:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3b7f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3b84:	c9                   	leave  
    3b85:	c3                   	ret    

00003b86 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3b86:	55                   	push   %ebp
    3b87:	89 e5                	mov    %esp,%ebp
    3b89:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3b8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b8f:	8b 40 0c             	mov    0xc(%eax),%eax
    3b92:	c1 f8 03             	sar    $0x3,%eax
    3b95:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3b98:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9b:	8b 40 04             	mov    0x4(%eax),%eax
    3b9e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3ba1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ba4:	8d 50 01             	lea    0x1(%eax),%edx
    3ba7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3baa:	39 c2                	cmp    %eax,%edx
    3bac:	73 4e                	jae    3bfc <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3bae:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb1:	8b 10                	mov    (%eax),%edx
    3bb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bb6:	01 d0                	add    %edx,%eax
    3bb8:	0f b6 00             	movzbl (%eax),%eax
    3bbb:	0f b6 d0             	movzbl %al,%edx
    3bbe:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc1:	8b 00                	mov    (%eax),%eax
    3bc3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3bc6:	83 c1 01             	add    $0x1,%ecx
    3bc9:	01 c8                	add    %ecx,%eax
    3bcb:	0f b6 00             	movzbl (%eax),%eax
    3bce:	0f b6 c0             	movzbl %al,%eax
    3bd1:	c1 e0 08             	shl    $0x8,%eax
    3bd4:	09 c2                	or     %eax,%edx
    3bd6:	8b 45 08             	mov    0x8(%ebp),%eax
    3bd9:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3bdc:	8b 45 08             	mov    0x8(%ebp),%eax
    3bdf:	8b 50 10             	mov    0x10(%eax),%edx
    3be2:	8b 45 08             	mov    0x8(%ebp),%eax
    3be5:	8b 40 0c             	mov    0xc(%eax),%eax
    3be8:	83 e0 07             	and    $0x7,%eax
    3beb:	89 c1                	mov    %eax,%ecx
    3bed:	d3 ea                	shr    %cl,%edx
    3bef:	8b 45 08             	mov    0x8(%ebp),%eax
    3bf2:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3bf5:	b8 01 00 00 00       	mov    $0x1,%eax
    3bfa:	eb 64                	jmp    3c60 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3bfc:	8b 45 08             	mov    0x8(%ebp),%eax
    3bff:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c06:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c09:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c0c:	39 c2                	cmp    %eax,%edx
    3c0e:	73 1e                	jae    3c2e <ensureBits9+0xa8>
    3c10:	8b 45 08             	mov    0x8(%ebp),%eax
    3c13:	8b 50 10             	mov    0x10(%eax),%edx
    3c16:	8b 45 08             	mov    0x8(%ebp),%eax
    3c19:	8b 08                	mov    (%eax),%ecx
    3c1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c1e:	01 c8                	add    %ecx,%eax
    3c20:	0f b6 00             	movzbl (%eax),%eax
    3c23:	0f b6 c0             	movzbl %al,%eax
    3c26:	09 c2                	or     %eax,%edx
    3c28:	8b 45 08             	mov    0x8(%ebp),%eax
    3c2b:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3c2e:	8b 45 08             	mov    0x8(%ebp),%eax
    3c31:	8b 50 10             	mov    0x10(%eax),%edx
    3c34:	8b 45 08             	mov    0x8(%ebp),%eax
    3c37:	8b 40 0c             	mov    0xc(%eax),%eax
    3c3a:	83 e0 07             	and    $0x7,%eax
    3c3d:	89 c1                	mov    %eax,%ecx
    3c3f:	d3 ea                	shr    %cl,%edx
    3c41:	8b 45 08             	mov    0x8(%ebp),%eax
    3c44:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3c47:	8b 45 08             	mov    0x8(%ebp),%eax
    3c4a:	8b 50 0c             	mov    0xc(%eax),%edx
    3c4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c50:	01 c2                	add    %eax,%edx
    3c52:	8b 45 08             	mov    0x8(%ebp),%eax
    3c55:	8b 40 08             	mov    0x8(%eax),%eax
    3c58:	39 c2                	cmp    %eax,%edx
    3c5a:	0f 9e c0             	setle  %al
    3c5d:	0f b6 c0             	movzbl %al,%eax
  }
}
    3c60:	c9                   	leave  
    3c61:	c3                   	ret    

00003c62 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3c62:	55                   	push   %ebp
    3c63:	89 e5                	mov    %esp,%ebp
    3c65:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3c68:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6b:	8b 40 0c             	mov    0xc(%eax),%eax
    3c6e:	c1 f8 03             	sar    $0x3,%eax
    3c71:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3c74:	8b 45 08             	mov    0x8(%ebp),%eax
    3c77:	8b 40 04             	mov    0x4(%eax),%eax
    3c7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3c7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c80:	8d 50 02             	lea    0x2(%eax),%edx
    3c83:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c86:	39 c2                	cmp    %eax,%edx
    3c88:	73 6d                	jae    3cf7 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3c8a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c8d:	8b 10                	mov    (%eax),%edx
    3c8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c92:	01 d0                	add    %edx,%eax
    3c94:	0f b6 00             	movzbl (%eax),%eax
    3c97:	0f b6 d0             	movzbl %al,%edx
    3c9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9d:	8b 00                	mov    (%eax),%eax
    3c9f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3ca2:	83 c1 01             	add    $0x1,%ecx
    3ca5:	01 c8                	add    %ecx,%eax
    3ca7:	0f b6 00             	movzbl (%eax),%eax
    3caa:	0f b6 c0             	movzbl %al,%eax
    3cad:	c1 e0 08             	shl    $0x8,%eax
    3cb0:	89 d1                	mov    %edx,%ecx
    3cb2:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3cb4:	8b 45 08             	mov    0x8(%ebp),%eax
    3cb7:	8b 00                	mov    (%eax),%eax
    3cb9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3cbc:	83 c2 02             	add    $0x2,%edx
    3cbf:	01 d0                	add    %edx,%eax
    3cc1:	0f b6 00             	movzbl (%eax),%eax
    3cc4:	0f b6 c0             	movzbl %al,%eax
    3cc7:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3cca:	09 c1                	or     %eax,%ecx
    3ccc:	89 ca                	mov    %ecx,%edx
    3cce:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd1:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3cd4:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd7:	8b 50 10             	mov    0x10(%eax),%edx
    3cda:	8b 45 08             	mov    0x8(%ebp),%eax
    3cdd:	8b 40 0c             	mov    0xc(%eax),%eax
    3ce0:	83 e0 07             	and    $0x7,%eax
    3ce3:	89 c1                	mov    %eax,%ecx
    3ce5:	d3 ea                	shr    %cl,%edx
    3ce7:	8b 45 08             	mov    0x8(%ebp),%eax
    3cea:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3ced:	b8 01 00 00 00       	mov    $0x1,%eax
    3cf2:	e9 95 00 00 00       	jmp    3d8c <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3cf7:	8b 45 08             	mov    0x8(%ebp),%eax
    3cfa:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3d01:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d04:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d07:	39 c2                	cmp    %eax,%edx
    3d09:	73 1e                	jae    3d29 <ensureBits17+0xc7>
    3d0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3d0e:	8b 50 10             	mov    0x10(%eax),%edx
    3d11:	8b 45 08             	mov    0x8(%ebp),%eax
    3d14:	8b 08                	mov    (%eax),%ecx
    3d16:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d19:	01 c8                	add    %ecx,%eax
    3d1b:	0f b6 00             	movzbl (%eax),%eax
    3d1e:	0f b6 c0             	movzbl %al,%eax
    3d21:	09 c2                	or     %eax,%edx
    3d23:	8b 45 08             	mov    0x8(%ebp),%eax
    3d26:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3d29:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d2c:	8d 50 01             	lea    0x1(%eax),%edx
    3d2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d32:	39 c2                	cmp    %eax,%edx
    3d34:	73 24                	jae    3d5a <ensureBits17+0xf8>
    3d36:	8b 45 08             	mov    0x8(%ebp),%eax
    3d39:	8b 50 10             	mov    0x10(%eax),%edx
    3d3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3d3f:	8b 00                	mov    (%eax),%eax
    3d41:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d44:	83 c1 01             	add    $0x1,%ecx
    3d47:	01 c8                	add    %ecx,%eax
    3d49:	0f b6 00             	movzbl (%eax),%eax
    3d4c:	0f b6 c0             	movzbl %al,%eax
    3d4f:	c1 e0 08             	shl    $0x8,%eax
    3d52:	09 c2                	or     %eax,%edx
    3d54:	8b 45 08             	mov    0x8(%ebp),%eax
    3d57:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3d5a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d5d:	8b 50 10             	mov    0x10(%eax),%edx
    3d60:	8b 45 08             	mov    0x8(%ebp),%eax
    3d63:	8b 40 0c             	mov    0xc(%eax),%eax
    3d66:	83 e0 07             	and    $0x7,%eax
    3d69:	89 c1                	mov    %eax,%ecx
    3d6b:	d3 ea                	shr    %cl,%edx
    3d6d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d70:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3d73:	8b 45 08             	mov    0x8(%ebp),%eax
    3d76:	8b 50 0c             	mov    0xc(%eax),%edx
    3d79:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d7c:	01 c2                	add    %eax,%edx
    3d7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3d81:	8b 40 08             	mov    0x8(%eax),%eax
    3d84:	39 c2                	cmp    %eax,%edx
    3d86:	0f 9e c0             	setle  %al
    3d89:	0f b6 c0             	movzbl %al,%eax
  }
}
    3d8c:	c9                   	leave  
    3d8d:	c3                   	ret    

00003d8e <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3d8e:	55                   	push   %ebp
    3d8f:	89 e5                	mov    %esp,%ebp
    3d91:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3d94:	8b 45 08             	mov    0x8(%ebp),%eax
    3d97:	8b 40 0c             	mov    0xc(%eax),%eax
    3d9a:	c1 f8 03             	sar    $0x3,%eax
    3d9d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3da0:	8b 45 08             	mov    0x8(%ebp),%eax
    3da3:	8b 40 04             	mov    0x4(%eax),%eax
    3da6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3da9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dac:	8d 50 03             	lea    0x3(%eax),%edx
    3daf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3db2:	39 c2                	cmp    %eax,%edx
    3db4:	0f 83 85 00 00 00    	jae    3e3f <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3dba:	8b 45 08             	mov    0x8(%ebp),%eax
    3dbd:	8b 10                	mov    (%eax),%edx
    3dbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dc2:	01 d0                	add    %edx,%eax
    3dc4:	0f b6 00             	movzbl (%eax),%eax
    3dc7:	0f b6 d0             	movzbl %al,%edx
    3dca:	8b 45 08             	mov    0x8(%ebp),%eax
    3dcd:	8b 00                	mov    (%eax),%eax
    3dcf:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3dd2:	83 c1 01             	add    $0x1,%ecx
    3dd5:	01 c8                	add    %ecx,%eax
    3dd7:	0f b6 00             	movzbl (%eax),%eax
    3dda:	0f b6 c0             	movzbl %al,%eax
    3ddd:	c1 e0 08             	shl    $0x8,%eax
    3de0:	89 d1                	mov    %edx,%ecx
    3de2:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3de4:	8b 45 08             	mov    0x8(%ebp),%eax
    3de7:	8b 00                	mov    (%eax),%eax
    3de9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3dec:	83 c2 02             	add    $0x2,%edx
    3def:	01 d0                	add    %edx,%eax
    3df1:	0f b6 00             	movzbl (%eax),%eax
    3df4:	0f b6 c0             	movzbl %al,%eax
    3df7:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3dfa:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3dfc:	8b 45 08             	mov    0x8(%ebp),%eax
    3dff:	8b 00                	mov    (%eax),%eax
    3e01:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e04:	83 c2 03             	add    $0x3,%edx
    3e07:	01 d0                	add    %edx,%eax
    3e09:	0f b6 00             	movzbl (%eax),%eax
    3e0c:	0f b6 c0             	movzbl %al,%eax
    3e0f:	c1 e0 18             	shl    $0x18,%eax
    3e12:	09 c1                	or     %eax,%ecx
    3e14:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e16:	8b 45 08             	mov    0x8(%ebp),%eax
    3e19:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3e1c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1f:	8b 50 10             	mov    0x10(%eax),%edx
    3e22:	8b 45 08             	mov    0x8(%ebp),%eax
    3e25:	8b 40 0c             	mov    0xc(%eax),%eax
    3e28:	83 e0 07             	and    $0x7,%eax
    3e2b:	89 c1                	mov    %eax,%ecx
    3e2d:	d3 ea                	shr    %cl,%edx
    3e2f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e32:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3e35:	b8 01 00 00 00       	mov    $0x1,%eax
    3e3a:	e9 c6 00 00 00       	jmp    3f05 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3e3f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e42:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3e49:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e4f:	39 c2                	cmp    %eax,%edx
    3e51:	73 1e                	jae    3e71 <ensureBits25+0xe3>
    3e53:	8b 45 08             	mov    0x8(%ebp),%eax
    3e56:	8b 50 10             	mov    0x10(%eax),%edx
    3e59:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5c:	8b 08                	mov    (%eax),%ecx
    3e5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e61:	01 c8                	add    %ecx,%eax
    3e63:	0f b6 00             	movzbl (%eax),%eax
    3e66:	0f b6 c0             	movzbl %al,%eax
    3e69:	09 c2                	or     %eax,%edx
    3e6b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6e:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3e71:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e74:	8d 50 01             	lea    0x1(%eax),%edx
    3e77:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e7a:	39 c2                	cmp    %eax,%edx
    3e7c:	73 24                	jae    3ea2 <ensureBits25+0x114>
    3e7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3e81:	8b 50 10             	mov    0x10(%eax),%edx
    3e84:	8b 45 08             	mov    0x8(%ebp),%eax
    3e87:	8b 00                	mov    (%eax),%eax
    3e89:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e8c:	83 c1 01             	add    $0x1,%ecx
    3e8f:	01 c8                	add    %ecx,%eax
    3e91:	0f b6 00             	movzbl (%eax),%eax
    3e94:	0f b6 c0             	movzbl %al,%eax
    3e97:	c1 e0 08             	shl    $0x8,%eax
    3e9a:	09 c2                	or     %eax,%edx
    3e9c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e9f:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3ea2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ea5:	8d 50 02             	lea    0x2(%eax),%edx
    3ea8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3eab:	39 c2                	cmp    %eax,%edx
    3ead:	73 24                	jae    3ed3 <ensureBits25+0x145>
    3eaf:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb2:	8b 50 10             	mov    0x10(%eax),%edx
    3eb5:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb8:	8b 00                	mov    (%eax),%eax
    3eba:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3ebd:	83 c1 02             	add    $0x2,%ecx
    3ec0:	01 c8                	add    %ecx,%eax
    3ec2:	0f b6 00             	movzbl (%eax),%eax
    3ec5:	0f b6 c0             	movzbl %al,%eax
    3ec8:	c1 e0 10             	shl    $0x10,%eax
    3ecb:	09 c2                	or     %eax,%edx
    3ecd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed0:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3ed3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed6:	8b 50 10             	mov    0x10(%eax),%edx
    3ed9:	8b 45 08             	mov    0x8(%ebp),%eax
    3edc:	8b 40 0c             	mov    0xc(%eax),%eax
    3edf:	83 e0 07             	and    $0x7,%eax
    3ee2:	89 c1                	mov    %eax,%ecx
    3ee4:	d3 ea                	shr    %cl,%edx
    3ee6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ee9:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3eec:	8b 45 08             	mov    0x8(%ebp),%eax
    3eef:	8b 50 0c             	mov    0xc(%eax),%edx
    3ef2:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ef5:	01 c2                	add    %eax,%edx
    3ef7:	8b 45 08             	mov    0x8(%ebp),%eax
    3efa:	8b 40 08             	mov    0x8(%eax),%eax
    3efd:	39 c2                	cmp    %eax,%edx
    3eff:	0f 9e c0             	setle  %al
    3f02:	0f b6 c0             	movzbl %al,%eax
  }
}
    3f05:	c9                   	leave  
    3f06:	c3                   	ret    

00003f07 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3f07:	55                   	push   %ebp
    3f08:	89 e5                	mov    %esp,%ebp
    3f0a:	53                   	push   %ebx
    3f0b:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3f0e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f11:	8b 40 0c             	mov    0xc(%eax),%eax
    3f14:	c1 f8 03             	sar    $0x3,%eax
    3f17:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3f1a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1d:	8b 40 04             	mov    0x4(%eax),%eax
    3f20:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3f23:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f26:	8d 50 04             	lea    0x4(%eax),%edx
    3f29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f2c:	39 c2                	cmp    %eax,%edx
    3f2e:	0f 83 c3 00 00 00    	jae    3ff7 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f34:	8b 45 08             	mov    0x8(%ebp),%eax
    3f37:	8b 10                	mov    (%eax),%edx
    3f39:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f3c:	01 d0                	add    %edx,%eax
    3f3e:	0f b6 00             	movzbl (%eax),%eax
    3f41:	0f b6 d0             	movzbl %al,%edx
    3f44:	8b 45 08             	mov    0x8(%ebp),%eax
    3f47:	8b 00                	mov    (%eax),%eax
    3f49:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f4c:	83 c1 01             	add    $0x1,%ecx
    3f4f:	01 c8                	add    %ecx,%eax
    3f51:	0f b6 00             	movzbl (%eax),%eax
    3f54:	0f b6 c0             	movzbl %al,%eax
    3f57:	c1 e0 08             	shl    $0x8,%eax
    3f5a:	89 d1                	mov    %edx,%ecx
    3f5c:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3f5e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f61:	8b 00                	mov    (%eax),%eax
    3f63:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f66:	83 c2 02             	add    $0x2,%edx
    3f69:	01 d0                	add    %edx,%eax
    3f6b:	0f b6 00             	movzbl (%eax),%eax
    3f6e:	0f b6 c0             	movzbl %al,%eax
    3f71:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f74:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3f76:	8b 45 08             	mov    0x8(%ebp),%eax
    3f79:	8b 00                	mov    (%eax),%eax
    3f7b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f7e:	83 c2 03             	add    $0x3,%edx
    3f81:	01 d0                	add    %edx,%eax
    3f83:	0f b6 00             	movzbl (%eax),%eax
    3f86:	0f b6 c0             	movzbl %al,%eax
    3f89:	c1 e0 18             	shl    $0x18,%eax
    3f8c:	09 c1                	or     %eax,%ecx
    3f8e:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f90:	8b 45 08             	mov    0x8(%ebp),%eax
    3f93:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3f96:	8b 45 08             	mov    0x8(%ebp),%eax
    3f99:	8b 50 10             	mov    0x10(%eax),%edx
    3f9c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9f:	8b 40 0c             	mov    0xc(%eax),%eax
    3fa2:	83 e0 07             	and    $0x7,%eax
    3fa5:	89 c1                	mov    %eax,%ecx
    3fa7:	d3 ea                	shr    %cl,%edx
    3fa9:	8b 45 08             	mov    0x8(%ebp),%eax
    3fac:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    3faf:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb2:	8b 50 10             	mov    0x10(%eax),%edx
    3fb5:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb8:	8b 00                	mov    (%eax),%eax
    3fba:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fbd:	83 c1 04             	add    $0x4,%ecx
    3fc0:	01 c8                	add    %ecx,%eax
    3fc2:	0f b6 00             	movzbl (%eax),%eax
    3fc5:	0f b6 c0             	movzbl %al,%eax
    3fc8:	c1 e0 18             	shl    $0x18,%eax
    3fcb:	89 c3                	mov    %eax,%ebx
    3fcd:	8b 45 08             	mov    0x8(%ebp),%eax
    3fd0:	8b 40 0c             	mov    0xc(%eax),%eax
    3fd3:	83 e0 07             	and    $0x7,%eax
    3fd6:	b9 08 00 00 00       	mov    $0x8,%ecx
    3fdb:	29 c1                	sub    %eax,%ecx
    3fdd:	89 c8                	mov    %ecx,%eax
    3fdf:	89 c1                	mov    %eax,%ecx
    3fe1:	d3 e3                	shl    %cl,%ebx
    3fe3:	89 d8                	mov    %ebx,%eax
    3fe5:	09 c2                	or     %eax,%edx
    3fe7:	8b 45 08             	mov    0x8(%ebp),%eax
    3fea:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3fed:	b8 01 00 00 00       	mov    $0x1,%eax
    3ff2:	e9 f7 00 00 00       	jmp    40ee <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    3ff7:	8b 45 08             	mov    0x8(%ebp),%eax
    3ffa:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4001:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4004:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4007:	39 c2                	cmp    %eax,%edx
    4009:	73 1e                	jae    4029 <ensureBits32+0x122>
    400b:	8b 45 08             	mov    0x8(%ebp),%eax
    400e:	8b 50 10             	mov    0x10(%eax),%edx
    4011:	8b 45 08             	mov    0x8(%ebp),%eax
    4014:	8b 08                	mov    (%eax),%ecx
    4016:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4019:	01 c8                	add    %ecx,%eax
    401b:	0f b6 00             	movzbl (%eax),%eax
    401e:	0f b6 c0             	movzbl %al,%eax
    4021:	09 c2                	or     %eax,%edx
    4023:	8b 45 08             	mov    0x8(%ebp),%eax
    4026:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4029:	8b 45 f8             	mov    -0x8(%ebp),%eax
    402c:	8d 50 01             	lea    0x1(%eax),%edx
    402f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4032:	39 c2                	cmp    %eax,%edx
    4034:	73 24                	jae    405a <ensureBits32+0x153>
    4036:	8b 45 08             	mov    0x8(%ebp),%eax
    4039:	8b 50 10             	mov    0x10(%eax),%edx
    403c:	8b 45 08             	mov    0x8(%ebp),%eax
    403f:	8b 00                	mov    (%eax),%eax
    4041:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4044:	83 c1 01             	add    $0x1,%ecx
    4047:	01 c8                	add    %ecx,%eax
    4049:	0f b6 00             	movzbl (%eax),%eax
    404c:	0f b6 c0             	movzbl %al,%eax
    404f:	c1 e0 08             	shl    $0x8,%eax
    4052:	09 c2                	or     %eax,%edx
    4054:	8b 45 08             	mov    0x8(%ebp),%eax
    4057:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    405a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    405d:	8d 50 02             	lea    0x2(%eax),%edx
    4060:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4063:	39 c2                	cmp    %eax,%edx
    4065:	73 24                	jae    408b <ensureBits32+0x184>
    4067:	8b 45 08             	mov    0x8(%ebp),%eax
    406a:	8b 50 10             	mov    0x10(%eax),%edx
    406d:	8b 45 08             	mov    0x8(%ebp),%eax
    4070:	8b 00                	mov    (%eax),%eax
    4072:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4075:	83 c1 02             	add    $0x2,%ecx
    4078:	01 c8                	add    %ecx,%eax
    407a:	0f b6 00             	movzbl (%eax),%eax
    407d:	0f b6 c0             	movzbl %al,%eax
    4080:	c1 e0 10             	shl    $0x10,%eax
    4083:	09 c2                	or     %eax,%edx
    4085:	8b 45 08             	mov    0x8(%ebp),%eax
    4088:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    408b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    408e:	8d 50 03             	lea    0x3(%eax),%edx
    4091:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4094:	39 c2                	cmp    %eax,%edx
    4096:	73 24                	jae    40bc <ensureBits32+0x1b5>
    4098:	8b 45 08             	mov    0x8(%ebp),%eax
    409b:	8b 50 10             	mov    0x10(%eax),%edx
    409e:	8b 45 08             	mov    0x8(%ebp),%eax
    40a1:	8b 00                	mov    (%eax),%eax
    40a3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    40a6:	83 c1 03             	add    $0x3,%ecx
    40a9:	01 c8                	add    %ecx,%eax
    40ab:	0f b6 00             	movzbl (%eax),%eax
    40ae:	0f b6 c0             	movzbl %al,%eax
    40b1:	c1 e0 18             	shl    $0x18,%eax
    40b4:	09 c2                	or     %eax,%edx
    40b6:	8b 45 08             	mov    0x8(%ebp),%eax
    40b9:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    40bc:	8b 45 08             	mov    0x8(%ebp),%eax
    40bf:	8b 50 10             	mov    0x10(%eax),%edx
    40c2:	8b 45 08             	mov    0x8(%ebp),%eax
    40c5:	8b 40 0c             	mov    0xc(%eax),%eax
    40c8:	83 e0 07             	and    $0x7,%eax
    40cb:	89 c1                	mov    %eax,%ecx
    40cd:	d3 ea                	shr    %cl,%edx
    40cf:	8b 45 08             	mov    0x8(%ebp),%eax
    40d2:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    40d5:	8b 45 08             	mov    0x8(%ebp),%eax
    40d8:	8b 50 0c             	mov    0xc(%eax),%edx
    40db:	8b 45 0c             	mov    0xc(%ebp),%eax
    40de:	01 c2                	add    %eax,%edx
    40e0:	8b 45 08             	mov    0x8(%ebp),%eax
    40e3:	8b 40 08             	mov    0x8(%eax),%eax
    40e6:	39 c2                	cmp    %eax,%edx
    40e8:	0f 9e c0             	setle  %al
    40eb:	0f b6 c0             	movzbl %al,%eax
  }
}
    40ee:	83 c4 10             	add    $0x10,%esp
    40f1:	5b                   	pop    %ebx
    40f2:	5d                   	pop    %ebp
    40f3:	c3                   	ret    

000040f4 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    40f4:	55                   	push   %ebp
    40f5:	89 e5                	mov    %esp,%ebp
    40f7:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    40f8:	8b 45 08             	mov    0x8(%ebp),%eax
    40fb:	8b 50 10             	mov    0x10(%eax),%edx
    40fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    4101:	bb 01 00 00 00       	mov    $0x1,%ebx
    4106:	89 c1                	mov    %eax,%ecx
    4108:	d3 e3                	shl    %cl,%ebx
    410a:	89 d8                	mov    %ebx,%eax
    410c:	83 e8 01             	sub    $0x1,%eax
    410f:	21 d0                	and    %edx,%eax
}
    4111:	5b                   	pop    %ebx
    4112:	5d                   	pop    %ebp
    4113:	c3                   	ret    

00004114 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4114:	55                   	push   %ebp
    4115:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    4117:	8b 45 08             	mov    0x8(%ebp),%eax
    411a:	8b 50 10             	mov    0x10(%eax),%edx
    411d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4120:	89 c1                	mov    %eax,%ecx
    4122:	d3 ea                	shr    %cl,%edx
    4124:	8b 45 08             	mov    0x8(%ebp),%eax
    4127:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    412a:	8b 45 08             	mov    0x8(%ebp),%eax
    412d:	8b 50 0c             	mov    0xc(%eax),%edx
    4130:	8b 45 0c             	mov    0xc(%ebp),%eax
    4133:	01 c2                	add    %eax,%edx
    4135:	8b 45 08             	mov    0x8(%ebp),%eax
    4138:	89 50 0c             	mov    %edx,0xc(%eax)
}
    413b:	90                   	nop
    413c:	5d                   	pop    %ebp
    413d:	c3                   	ret    

0000413e <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    413e:	55                   	push   %ebp
    413f:	89 e5                	mov    %esp,%ebp
    4141:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4144:	ff 75 0c             	pushl  0xc(%ebp)
    4147:	ff 75 08             	pushl  0x8(%ebp)
    414a:	e8 a5 ff ff ff       	call   40f4 <peekBits>
    414f:	83 c4 08             	add    $0x8,%esp
    4152:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    4155:	ff 75 0c             	pushl  0xc(%ebp)
    4158:	ff 75 08             	pushl  0x8(%ebp)
    415b:	e8 b4 ff ff ff       	call   4114 <advanceBits>
    4160:	83 c4 08             	add    $0x8,%esp
  return result;
    4163:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    4166:	c9                   	leave  
    4167:	c3                   	ret    

00004168 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    4168:	55                   	push   %ebp
    4169:	89 e5                	mov    %esp,%ebp
    416b:	53                   	push   %ebx
    416c:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    416f:	ff 75 0c             	pushl  0xc(%ebp)
    4172:	ff 75 08             	pushl  0x8(%ebp)
    4175:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4178:	50                   	push   %eax
    4179:	e8 97 f9 ff ff       	call   3b15 <LodePNGBitReader_init>
    417e:	83 c4 0c             	add    $0xc,%esp
    4181:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    4184:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4188:	74 0a                	je     4194 <lode_png_test_bitreader+0x2c>
    418a:	b8 00 00 00 00       	mov    $0x0,%eax
    418f:	e9 c3 00 00 00       	jmp    4257 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    4194:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    419b:	e9 a6 00 00 00       	jmp    4246 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    41a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    41aa:	8b 45 14             	mov    0x14(%ebp),%eax
    41ad:	01 d0                	add    %edx,%eax
    41af:	8b 00                	mov    (%eax),%eax
    41b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    41b4:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    41b8:	7e 14                	jle    41ce <lode_png_test_bitreader+0x66>
    41ba:	ff 75 ec             	pushl  -0x14(%ebp)
    41bd:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41c0:	50                   	push   %eax
    41c1:	e8 41 fd ff ff       	call   3f07 <ensureBits32>
    41c6:	83 c4 08             	add    $0x8,%esp
    41c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    41cc:	eb 46                	jmp    4214 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    41ce:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    41d2:	7e 14                	jle    41e8 <lode_png_test_bitreader+0x80>
    41d4:	ff 75 ec             	pushl  -0x14(%ebp)
    41d7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41da:	50                   	push   %eax
    41db:	e8 ae fb ff ff       	call   3d8e <ensureBits25>
    41e0:	83 c4 08             	add    $0x8,%esp
    41e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    41e6:	eb 2c                	jmp    4214 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    41e8:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    41ec:	7e 14                	jle    4202 <lode_png_test_bitreader+0x9a>
    41ee:	ff 75 ec             	pushl  -0x14(%ebp)
    41f1:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41f4:	50                   	push   %eax
    41f5:	e8 68 fa ff ff       	call   3c62 <ensureBits17>
    41fa:	83 c4 08             	add    $0x8,%esp
    41fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4200:	eb 12                	jmp    4214 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4202:	ff 75 ec             	pushl  -0x14(%ebp)
    4205:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4208:	50                   	push   %eax
    4209:	e8 78 f9 ff ff       	call   3b86 <ensureBits9>
    420e:	83 c4 08             	add    $0x8,%esp
    4211:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4214:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4218:	75 07                	jne    4221 <lode_png_test_bitreader+0xb9>
    421a:	b8 00 00 00 00       	mov    $0x0,%eax
    421f:	eb 36                	jmp    4257 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4221:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4224:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    422b:	8b 45 18             	mov    0x18(%ebp),%eax
    422e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4231:	ff 75 ec             	pushl  -0x14(%ebp)
    4234:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4237:	50                   	push   %eax
    4238:	e8 01 ff ff ff       	call   413e <readBits>
    423d:	83 c4 08             	add    $0x8,%esp
    4240:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4242:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4246:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4249:	3b 45 10             	cmp    0x10(%ebp),%eax
    424c:	0f 8c 4e ff ff ff    	jl     41a0 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    4252:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4257:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    425a:	c9                   	leave  
    425b:	c3                   	ret    

0000425c <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    425c:	55                   	push   %ebp
    425d:	89 e5                	mov    %esp,%ebp
    425f:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    4262:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    4269:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    4270:	eb 27                	jmp    4299 <reverseBits+0x3d>
    4272:	8b 45 0c             	mov    0xc(%ebp),%eax
    4275:	2b 45 fc             	sub    -0x4(%ebp),%eax
    4278:	83 e8 01             	sub    $0x1,%eax
    427b:	8b 55 08             	mov    0x8(%ebp),%edx
    427e:	89 c1                	mov    %eax,%ecx
    4280:	d3 ea                	shr    %cl,%edx
    4282:	89 d0                	mov    %edx,%eax
    4284:	83 e0 01             	and    $0x1,%eax
    4287:	89 c2                	mov    %eax,%edx
    4289:	8b 45 fc             	mov    -0x4(%ebp),%eax
    428c:	89 c1                	mov    %eax,%ecx
    428e:	d3 e2                	shl    %cl,%edx
    4290:	89 d0                	mov    %edx,%eax
    4292:	09 45 f8             	or     %eax,-0x8(%ebp)
    4295:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4299:	8b 45 fc             	mov    -0x4(%ebp),%eax
    429c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    429f:	72 d1                	jb     4272 <reverseBits+0x16>
  return result;
    42a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    42a4:	c9                   	leave  
    42a5:	c3                   	ret    

000042a6 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    42a6:	55                   	push   %ebp
    42a7:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    42a9:	8b 45 08             	mov    0x8(%ebp),%eax
    42ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    42b2:	8b 45 08             	mov    0x8(%ebp),%eax
    42b5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    42bc:	8b 45 08             	mov    0x8(%ebp),%eax
    42bf:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    42c6:	8b 45 08             	mov    0x8(%ebp),%eax
    42c9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    42d0:	90                   	nop
    42d1:	5d                   	pop    %ebp
    42d2:	c3                   	ret    

000042d3 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    42d3:	55                   	push   %ebp
    42d4:	89 e5                	mov    %esp,%ebp
    42d6:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    42d9:	8b 45 08             	mov    0x8(%ebp),%eax
    42dc:	8b 00                	mov    (%eax),%eax
    42de:	83 ec 0c             	sub    $0xc,%esp
    42e1:	50                   	push   %eax
    42e2:	e8 ec f0 ff ff       	call   33d3 <lodepng_free>
    42e7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    42ea:	8b 45 08             	mov    0x8(%ebp),%eax
    42ed:	8b 40 04             	mov    0x4(%eax),%eax
    42f0:	83 ec 0c             	sub    $0xc,%esp
    42f3:	50                   	push   %eax
    42f4:	e8 da f0 ff ff       	call   33d3 <lodepng_free>
    42f9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    42fc:	8b 45 08             	mov    0x8(%ebp),%eax
    42ff:	8b 40 10             	mov    0x10(%eax),%eax
    4302:	83 ec 0c             	sub    $0xc,%esp
    4305:	50                   	push   %eax
    4306:	e8 c8 f0 ff ff       	call   33d3 <lodepng_free>
    430b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    430e:	8b 45 08             	mov    0x8(%ebp),%eax
    4311:	8b 40 14             	mov    0x14(%eax),%eax
    4314:	83 ec 0c             	sub    $0xc,%esp
    4317:	50                   	push   %eax
    4318:	e8 b6 f0 ff ff       	call   33d3 <lodepng_free>
    431d:	83 c4 10             	add    $0x10,%esp
}
    4320:	90                   	nop
    4321:	c9                   	leave  
    4322:	c3                   	ret    

00004323 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4323:	55                   	push   %ebp
    4324:	89 e5                	mov    %esp,%ebp
    4326:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    4329:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    432e:	c1 e0 02             	shl    $0x2,%eax
    4331:	83 ec 0c             	sub    $0xc,%esp
    4334:	50                   	push   %eax
    4335:	e8 78 f0 ff ff       	call   33b2 <lodepng_malloc>
    433a:	83 c4 10             	add    $0x10,%esp
    433d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    4340:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4344:	75 0a                	jne    4350 <HuffmanTree_makeTable+0x2d>
    4346:	b8 53 00 00 00       	mov    $0x53,%eax
    434b:	e9 61 04 00 00       	jmp    47b1 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    4350:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    4355:	c1 e0 02             	shl    $0x2,%eax
    4358:	83 ec 04             	sub    $0x4,%esp
    435b:	50                   	push   %eax
    435c:	6a 00                	push   $0x0
    435e:	ff 75 dc             	pushl  -0x24(%ebp)
    4361:	e8 bd f0 ff ff       	call   3423 <lodepng_memset>
    4366:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    4369:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4370:	eb 7d                	jmp    43ef <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    4372:	8b 45 08             	mov    0x8(%ebp),%eax
    4375:	8b 00                	mov    (%eax),%eax
    4377:	8b 55 f4             	mov    -0xc(%ebp),%edx
    437a:	c1 e2 02             	shl    $0x2,%edx
    437d:	01 d0                	add    %edx,%eax
    437f:	8b 00                	mov    (%eax),%eax
    4381:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    4384:	8b 45 08             	mov    0x8(%ebp),%eax
    4387:	8b 40 04             	mov    0x4(%eax),%eax
    438a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    438d:	c1 e2 02             	shl    $0x2,%edx
    4390:	01 d0                	add    %edx,%eax
    4392:	8b 00                	mov    (%eax),%eax
    4394:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4397:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    439b:	76 4d                	jbe    43ea <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    439d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    43a0:	83 e8 09             	sub    $0x9,%eax
    43a3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    43a6:	89 c1                	mov    %eax,%ecx
    43a8:	d3 ea                	shr    %cl,%edx
    43aa:	89 d0                	mov    %edx,%eax
    43ac:	83 ec 08             	sub    $0x8,%esp
    43af:	6a 09                	push   $0x9
    43b1:	50                   	push   %eax
    43b2:	e8 a5 fe ff ff       	call   425c <reverseBits>
    43b7:	83 c4 10             	add    $0x10,%esp
    43ba:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    43bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    43c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    43c7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    43ca:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    43cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    43d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    43d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    43da:	01 d0                	add    %edx,%eax
    43dc:	8b 10                	mov    (%eax),%edx
    43de:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    43e1:	39 c2                	cmp    %eax,%edx
    43e3:	0f 43 c2             	cmovae %edx,%eax
    43e6:	89 01                	mov    %eax,(%ecx)
    43e8:	eb 01                	jmp    43eb <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    43ea:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    43eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    43ef:	8b 45 08             	mov    0x8(%ebp),%eax
    43f2:	8b 50 0c             	mov    0xc(%eax),%edx
    43f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43f8:	39 c2                	cmp    %eax,%edx
    43fa:	0f 87 72 ff ff ff    	ja     4372 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4400:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    4405:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4408:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    440f:	eb 35                	jmp    4446 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4411:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4414:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    441b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    441e:	01 d0                	add    %edx,%eax
    4420:	8b 00                	mov    (%eax),%eax
    4422:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4425:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    4429:	76 17                	jbe    4442 <HuffmanTree_makeTable+0x11f>
    442b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    442e:	83 e8 09             	sub    $0x9,%eax
    4431:	ba 01 00 00 00       	mov    $0x1,%edx
    4436:	89 c1                	mov    %eax,%ecx
    4438:	d3 e2                	shl    %cl,%edx
    443a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    443d:	01 d0                	add    %edx,%eax
    443f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4442:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4446:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4449:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    444e:	39 c2                	cmp    %eax,%edx
    4450:	72 bf                	jb     4411 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4452:	83 ec 0c             	sub    $0xc,%esp
    4455:	ff 75 e8             	pushl  -0x18(%ebp)
    4458:	e8 55 ef ff ff       	call   33b2 <lodepng_malloc>
    445d:	83 c4 10             	add    $0x10,%esp
    4460:	89 c2                	mov    %eax,%edx
    4462:	8b 45 08             	mov    0x8(%ebp),%eax
    4465:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    4468:	8b 45 e8             	mov    -0x18(%ebp),%eax
    446b:	01 c0                	add    %eax,%eax
    446d:	83 ec 0c             	sub    $0xc,%esp
    4470:	50                   	push   %eax
    4471:	e8 3c ef ff ff       	call   33b2 <lodepng_malloc>
    4476:	83 c4 10             	add    $0x10,%esp
    4479:	89 c2                	mov    %eax,%edx
    447b:	8b 45 08             	mov    0x8(%ebp),%eax
    447e:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    4481:	8b 45 08             	mov    0x8(%ebp),%eax
    4484:	8b 40 10             	mov    0x10(%eax),%eax
    4487:	85 c0                	test   %eax,%eax
    4489:	74 0a                	je     4495 <HuffmanTree_makeTable+0x172>
    448b:	8b 45 08             	mov    0x8(%ebp),%eax
    448e:	8b 40 14             	mov    0x14(%eax),%eax
    4491:	85 c0                	test   %eax,%eax
    4493:	75 18                	jne    44ad <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4495:	83 ec 0c             	sub    $0xc,%esp
    4498:	ff 75 dc             	pushl  -0x24(%ebp)
    449b:	e8 33 ef ff ff       	call   33d3 <lodepng_free>
    44a0:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    44a3:	b8 53 00 00 00       	mov    $0x53,%eax
    44a8:	e9 04 03 00 00       	jmp    47b1 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    44ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44b4:	eb 12                	jmp    44c8 <HuffmanTree_makeTable+0x1a5>
    44b6:	8b 45 08             	mov    0x8(%ebp),%eax
    44b9:	8b 50 10             	mov    0x10(%eax),%edx
    44bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44bf:	01 d0                	add    %edx,%eax
    44c1:	c6 00 10             	movb   $0x10,(%eax)
    44c4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    44c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44cb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    44ce:	7c e6                	jl     44b6 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    44d0:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    44d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    44d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44df:	eb 5b                	jmp    453c <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    44e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    44eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    44ee:	01 d0                	add    %edx,%eax
    44f0:	8b 00                	mov    (%eax),%eax
    44f2:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    44f5:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    44f9:	76 3c                	jbe    4537 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    44fb:	8b 45 08             	mov    0x8(%ebp),%eax
    44fe:	8b 50 10             	mov    0x10(%eax),%edx
    4501:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4504:	01 d0                	add    %edx,%eax
    4506:	8b 55 c8             	mov    -0x38(%ebp),%edx
    4509:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    450b:	8b 45 08             	mov    0x8(%ebp),%eax
    450e:	8b 40 14             	mov    0x14(%eax),%eax
    4511:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4514:	01 d2                	add    %edx,%edx
    4516:	01 d0                	add    %edx,%eax
    4518:	8b 55 ec             	mov    -0x14(%ebp),%edx
    451b:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    451e:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4521:	83 e8 09             	sub    $0x9,%eax
    4524:	ba 01 00 00 00       	mov    $0x1,%edx
    4529:	89 c1                	mov    %eax,%ecx
    452b:	d3 e2                	shl    %cl,%edx
    452d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4530:	01 d0                	add    %edx,%eax
    4532:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4535:	eb 01                	jmp    4538 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    4537:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    4538:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    453c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    453f:	a1 a8 b6 01 00       	mov    0x1b6a8,%eax
    4544:	39 c2                	cmp    %eax,%edx
    4546:	72 99                	jb     44e1 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    4548:	83 ec 0c             	sub    $0xc,%esp
    454b:	ff 75 dc             	pushl  -0x24(%ebp)
    454e:	e8 80 ee ff ff       	call   33d3 <lodepng_free>
    4553:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    4556:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    455d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4564:	e9 9d 01 00 00       	jmp    4706 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    4569:	8b 45 08             	mov    0x8(%ebp),%eax
    456c:	8b 40 04             	mov    0x4(%eax),%eax
    456f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4572:	c1 e2 02             	shl    $0x2,%edx
    4575:	01 d0                	add    %edx,%eax
    4577:	8b 00                	mov    (%eax),%eax
    4579:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    457c:	8b 45 08             	mov    0x8(%ebp),%eax
    457f:	8b 00                	mov    (%eax),%eax
    4581:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4584:	c1 e2 02             	shl    $0x2,%edx
    4587:	01 d0                	add    %edx,%eax
    4589:	8b 00                	mov    (%eax),%eax
    458b:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    458e:	83 ec 08             	sub    $0x8,%esp
    4591:	ff 75 c4             	pushl  -0x3c(%ebp)
    4594:	ff 75 c0             	pushl  -0x40(%ebp)
    4597:	e8 c0 fc ff ff       	call   425c <reverseBits>
    459c:	83 c4 10             	add    $0x10,%esp
    459f:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    45a2:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    45a6:	0f 84 55 01 00 00    	je     4701 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    45ac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    45b0:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    45b4:	0f 87 81 00 00 00    	ja     463b <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    45ba:	b8 09 00 00 00       	mov    $0x9,%eax
    45bf:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    45c2:	ba 01 00 00 00       	mov    $0x1,%edx
    45c7:	89 c1                	mov    %eax,%ecx
    45c9:	d3 e2                	shl    %cl,%edx
    45cb:	89 d0                	mov    %edx,%eax
    45cd:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    45d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    45d7:	eb 55                	jmp    462e <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    45d9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    45dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    45df:	89 c1                	mov    %eax,%ecx
    45e1:	d3 e2                	shl    %cl,%edx
    45e3:	89 d0                	mov    %edx,%eax
    45e5:	0b 45 bc             	or     -0x44(%ebp),%eax
    45e8:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    45eb:	8b 45 08             	mov    0x8(%ebp),%eax
    45ee:	8b 50 10             	mov    0x10(%eax),%edx
    45f1:	8b 45 98             	mov    -0x68(%ebp),%eax
    45f4:	01 d0                	add    %edx,%eax
    45f6:	0f b6 00             	movzbl (%eax),%eax
    45f9:	3c 10                	cmp    $0x10,%al
    45fb:	74 0a                	je     4607 <HuffmanTree_makeTable+0x2e4>
    45fd:	b8 37 00 00 00       	mov    $0x37,%eax
    4602:	e9 aa 01 00 00       	jmp    47b1 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4607:	8b 45 08             	mov    0x8(%ebp),%eax
    460a:	8b 50 10             	mov    0x10(%eax),%edx
    460d:	8b 45 98             	mov    -0x68(%ebp),%eax
    4610:	01 d0                	add    %edx,%eax
    4612:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4615:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    4617:	8b 45 08             	mov    0x8(%ebp),%eax
    461a:	8b 40 14             	mov    0x14(%eax),%eax
    461d:	8b 55 98             	mov    -0x68(%ebp),%edx
    4620:	01 d2                	add    %edx,%edx
    4622:	01 d0                	add    %edx,%eax
    4624:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4627:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    462a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    462e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4631:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4634:	72 a3                	jb     45d9 <HuffmanTree_makeTable+0x2b6>
    4636:	e9 c7 00 00 00       	jmp    4702 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    463b:	a1 ac b6 01 00       	mov    0x1b6ac,%eax
    4640:	23 45 bc             	and    -0x44(%ebp),%eax
    4643:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    4646:	8b 45 08             	mov    0x8(%ebp),%eax
    4649:	8b 50 10             	mov    0x10(%eax),%edx
    464c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    464f:	01 d0                	add    %edx,%eax
    4651:	0f b6 00             	movzbl (%eax),%eax
    4654:	0f b6 c0             	movzbl %al,%eax
    4657:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    465a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    465d:	83 e8 09             	sub    $0x9,%eax
    4660:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    4663:	8b 45 08             	mov    0x8(%ebp),%eax
    4666:	8b 40 14             	mov    0x14(%eax),%eax
    4669:	8b 55 b8             	mov    -0x48(%ebp),%edx
    466c:	01 d2                	add    %edx,%edx
    466e:	01 d0                	add    %edx,%eax
    4670:	0f b7 00             	movzwl (%eax),%eax
    4673:	0f b7 c0             	movzwl %ax,%eax
    4676:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    4679:	8b 45 b0             	mov    -0x50(%ebp),%eax
    467c:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    467f:	83 c0 09             	add    $0x9,%eax
    4682:	ba 01 00 00 00       	mov    $0x1,%edx
    4687:	89 c1                	mov    %eax,%ecx
    4689:	d3 e2                	shl    %cl,%edx
    468b:	89 d0                	mov    %edx,%eax
    468d:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4690:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4693:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    4696:	73 0a                	jae    46a2 <HuffmanTree_makeTable+0x37f>
    4698:	b8 37 00 00 00       	mov    $0x37,%eax
    469d:	e9 0f 01 00 00       	jmp    47b1 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    46a2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    46a9:	eb 4c                	jmp    46f7 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    46ab:	8b 45 bc             	mov    -0x44(%ebp),%eax
    46ae:	c1 e8 09             	shr    $0x9,%eax
    46b1:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    46b4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    46b7:	83 e8 09             	sub    $0x9,%eax
    46ba:	8b 55 e0             	mov    -0x20(%ebp),%edx
    46bd:	89 c1                	mov    %eax,%ecx
    46bf:	d3 e2                	shl    %cl,%edx
    46c1:	89 d0                	mov    %edx,%eax
    46c3:	0b 45 a4             	or     -0x5c(%ebp),%eax
    46c6:	89 c2                	mov    %eax,%edx
    46c8:	8b 45 ac             	mov    -0x54(%ebp),%eax
    46cb:	01 d0                	add    %edx,%eax
    46cd:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    46d0:	8b 45 08             	mov    0x8(%ebp),%eax
    46d3:	8b 50 10             	mov    0x10(%eax),%edx
    46d6:	8b 45 a0             	mov    -0x60(%ebp),%eax
    46d9:	01 d0                	add    %edx,%eax
    46db:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    46de:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    46e0:	8b 45 08             	mov    0x8(%ebp),%eax
    46e3:	8b 40 14             	mov    0x14(%eax),%eax
    46e6:	8b 55 a0             	mov    -0x60(%ebp),%edx
    46e9:	01 d2                	add    %edx,%edx
    46eb:	01 d0                	add    %edx,%eax
    46ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46f0:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    46f3:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    46f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    46fa:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    46fd:	72 ac                	jb     46ab <HuffmanTree_makeTable+0x388>
    46ff:	eb 01                	jmp    4702 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4701:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4702:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4706:	8b 45 08             	mov    0x8(%ebp),%eax
    4709:	8b 50 0c             	mov    0xc(%eax),%edx
    470c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    470f:	39 c2                	cmp    %eax,%edx
    4711:	0f 87 52 fe ff ff    	ja     4569 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4717:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    471b:	7f 61                	jg     477e <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    471d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4724:	eb 4e                	jmp    4774 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4726:	8b 45 08             	mov    0x8(%ebp),%eax
    4729:	8b 50 10             	mov    0x10(%eax),%edx
    472c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    472f:	01 d0                	add    %edx,%eax
    4731:	0f b6 00             	movzbl (%eax),%eax
    4734:	3c 10                	cmp    $0x10,%al
    4736:	75 38                	jne    4770 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    4738:	8b 45 08             	mov    0x8(%ebp),%eax
    473b:	8b 50 10             	mov    0x10(%eax),%edx
    473e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4741:	01 d0                	add    %edx,%eax
    4743:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4746:	8b 15 a8 b6 01 00    	mov    0x1b6a8,%edx
    474c:	39 d1                	cmp    %edx,%ecx
    474e:	73 07                	jae    4757 <HuffmanTree_makeTable+0x434>
    4750:	ba 01 00 00 00       	mov    $0x1,%edx
    4755:	eb 05                	jmp    475c <HuffmanTree_makeTable+0x439>
    4757:	ba 0a 00 00 00       	mov    $0xa,%edx
    475c:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    475e:	8b 45 08             	mov    0x8(%ebp),%eax
    4761:	8b 40 14             	mov    0x14(%eax),%eax
    4764:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4767:	01 d2                	add    %edx,%edx
    4769:	01 d0                	add    %edx,%eax
    476b:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4770:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4774:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4777:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    477a:	7c aa                	jl     4726 <HuffmanTree_makeTable+0x403>
    477c:	eb 2e                	jmp    47ac <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    477e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4785:	eb 1d                	jmp    47a4 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    4787:	8b 45 08             	mov    0x8(%ebp),%eax
    478a:	8b 50 10             	mov    0x10(%eax),%edx
    478d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4790:	01 d0                	add    %edx,%eax
    4792:	0f b6 00             	movzbl (%eax),%eax
    4795:	3c 10                	cmp    $0x10,%al
    4797:	75 07                	jne    47a0 <HuffmanTree_makeTable+0x47d>
    4799:	b8 37 00 00 00       	mov    $0x37,%eax
    479e:	eb 11                	jmp    47b1 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    47a0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    47a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47a7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    47aa:	7c db                	jl     4787 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    47ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
    47b1:	c9                   	leave  
    47b2:	c3                   	ret    

000047b3 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    47b3:	55                   	push   %ebp
    47b4:	89 e5                	mov    %esp,%ebp
    47b6:	56                   	push   %esi
    47b7:	53                   	push   %ebx
    47b8:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    47bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    47c2:	8b 45 08             	mov    0x8(%ebp),%eax
    47c5:	8b 40 0c             	mov    0xc(%eax),%eax
    47c8:	c1 e0 02             	shl    $0x2,%eax
    47cb:	83 ec 0c             	sub    $0xc,%esp
    47ce:	50                   	push   %eax
    47cf:	e8 de eb ff ff       	call   33b2 <lodepng_malloc>
    47d4:	83 c4 10             	add    $0x10,%esp
    47d7:	89 c2                	mov    %eax,%edx
    47d9:	8b 45 08             	mov    0x8(%ebp),%eax
    47dc:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    47de:	8b 45 08             	mov    0x8(%ebp),%eax
    47e1:	8b 40 08             	mov    0x8(%eax),%eax
    47e4:	83 c0 01             	add    $0x1,%eax
    47e7:	c1 e0 02             	shl    $0x2,%eax
    47ea:	83 ec 0c             	sub    $0xc,%esp
    47ed:	50                   	push   %eax
    47ee:	e8 bf eb ff ff       	call   33b2 <lodepng_malloc>
    47f3:	83 c4 10             	add    $0x10,%esp
    47f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    47f9:	8b 45 08             	mov    0x8(%ebp),%eax
    47fc:	8b 40 08             	mov    0x8(%eax),%eax
    47ff:	83 c0 01             	add    $0x1,%eax
    4802:	c1 e0 02             	shl    $0x2,%eax
    4805:	83 ec 0c             	sub    $0xc,%esp
    4808:	50                   	push   %eax
    4809:	e8 a4 eb ff ff       	call   33b2 <lodepng_malloc>
    480e:	83 c4 10             	add    $0x10,%esp
    4811:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4814:	8b 45 08             	mov    0x8(%ebp),%eax
    4817:	8b 00                	mov    (%eax),%eax
    4819:	85 c0                	test   %eax,%eax
    481b:	74 0c                	je     4829 <HuffmanTree_makeFromLengths2+0x76>
    481d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4821:	74 06                	je     4829 <HuffmanTree_makeFromLengths2+0x76>
    4823:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4827:	75 07                	jne    4830 <HuffmanTree_makeFromLengths2+0x7d>
    4829:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4830:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4834:	0f 85 7d 01 00 00    	jne    49b7 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    483a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4841:	eb 2c                	jmp    486f <HuffmanTree_makeFromLengths2+0xbc>
    4843:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4846:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    484d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4850:	01 c2                	add    %eax,%edx
    4852:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4855:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    485c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    485f:	01 c8                	add    %ecx,%eax
    4861:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4867:	8b 00                	mov    (%eax),%eax
    4869:	89 02                	mov    %eax,(%edx)
    486b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    486f:	8b 45 08             	mov    0x8(%ebp),%eax
    4872:	8b 40 08             	mov    0x8(%eax),%eax
    4875:	83 c0 01             	add    $0x1,%eax
    4878:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    487b:	75 c6                	jne    4843 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    487d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4884:	eb 27                	jmp    48ad <HuffmanTree_makeFromLengths2+0xfa>
    4886:	8b 45 08             	mov    0x8(%ebp),%eax
    4889:	8b 40 04             	mov    0x4(%eax),%eax
    488c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    488f:	c1 e2 02             	shl    $0x2,%edx
    4892:	01 d0                	add    %edx,%eax
    4894:	8b 00                	mov    (%eax),%eax
    4896:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    489d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    48a0:	01 d0                	add    %edx,%eax
    48a2:	8b 10                	mov    (%eax),%edx
    48a4:	83 c2 01             	add    $0x1,%edx
    48a7:	89 10                	mov    %edx,(%eax)
    48a9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    48ad:	8b 45 08             	mov    0x8(%ebp),%eax
    48b0:	8b 40 0c             	mov    0xc(%eax),%eax
    48b3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    48b6:	75 ce                	jne    4886 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    48b8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    48bf:	eb 47                	jmp    4908 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    48c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    48c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48ce:	01 d0                	add    %edx,%eax
    48d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    48d3:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    48d9:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    48e0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    48e3:	01 ca                	add    %ecx,%edx
    48e5:	8b 0a                	mov    (%edx),%ecx
    48e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    48ea:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    48f0:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    48f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    48fa:	01 da                	add    %ebx,%edx
    48fc:	8b 12                	mov    (%edx),%edx
    48fe:	01 ca                	add    %ecx,%edx
    4900:	01 d2                	add    %edx,%edx
    4902:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4904:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4908:	8b 45 08             	mov    0x8(%ebp),%eax
    490b:	8b 40 08             	mov    0x8(%eax),%eax
    490e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4911:	73 ae                	jae    48c1 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4913:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    491a:	e9 89 00 00 00       	jmp    49a8 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    491f:	8b 45 08             	mov    0x8(%ebp),%eax
    4922:	8b 40 04             	mov    0x4(%eax),%eax
    4925:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4928:	c1 e2 02             	shl    $0x2,%edx
    492b:	01 d0                	add    %edx,%eax
    492d:	8b 00                	mov    (%eax),%eax
    492f:	85 c0                	test   %eax,%eax
    4931:	74 71                	je     49a4 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4933:	8b 45 08             	mov    0x8(%ebp),%eax
    4936:	8b 00                	mov    (%eax),%eax
    4938:	8b 55 ec             	mov    -0x14(%ebp),%edx
    493b:	c1 e2 02             	shl    $0x2,%edx
    493e:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4941:	8b 45 08             	mov    0x8(%ebp),%eax
    4944:	8b 40 04             	mov    0x4(%eax),%eax
    4947:	8b 55 ec             	mov    -0x14(%ebp),%edx
    494a:	c1 e2 02             	shl    $0x2,%edx
    494d:	01 d0                	add    %edx,%eax
    494f:	8b 00                	mov    (%eax),%eax
    4951:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4958:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    495b:	01 c2                	add    %eax,%edx
    495d:	8b 02                	mov    (%edx),%eax
    495f:	8d 48 01             	lea    0x1(%eax),%ecx
    4962:	89 0a                	mov    %ecx,(%edx)
    4964:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4966:	8b 45 08             	mov    0x8(%ebp),%eax
    4969:	8b 00                	mov    (%eax),%eax
    496b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    496e:	c1 e2 02             	shl    $0x2,%edx
    4971:	01 c2                	add    %eax,%edx
    4973:	8b 45 08             	mov    0x8(%ebp),%eax
    4976:	8b 00                	mov    (%eax),%eax
    4978:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    497b:	c1 e1 02             	shl    $0x2,%ecx
    497e:	01 c8                	add    %ecx,%eax
    4980:	8b 18                	mov    (%eax),%ebx
    4982:	8b 45 08             	mov    0x8(%ebp),%eax
    4985:	8b 40 04             	mov    0x4(%eax),%eax
    4988:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    498b:	c1 e1 02             	shl    $0x2,%ecx
    498e:	01 c8                	add    %ecx,%eax
    4990:	8b 00                	mov    (%eax),%eax
    4992:	be 01 00 00 00       	mov    $0x1,%esi
    4997:	89 c1                	mov    %eax,%ecx
    4999:	d3 e6                	shl    %cl,%esi
    499b:	89 f0                	mov    %esi,%eax
    499d:	83 e8 01             	sub    $0x1,%eax
    49a0:	21 d8                	and    %ebx,%eax
    49a2:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    49a4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    49a8:	8b 45 08             	mov    0x8(%ebp),%eax
    49ab:	8b 40 0c             	mov    0xc(%eax),%eax
    49ae:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    49b1:	0f 85 68 ff ff ff    	jne    491f <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    49b7:	83 ec 0c             	sub    $0xc,%esp
    49ba:	ff 75 e8             	pushl  -0x18(%ebp)
    49bd:	e8 11 ea ff ff       	call   33d3 <lodepng_free>
    49c2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    49c5:	83 ec 0c             	sub    $0xc,%esp
    49c8:	ff 75 e4             	pushl  -0x1c(%ebp)
    49cb:	e8 03 ea ff ff       	call   33d3 <lodepng_free>
    49d0:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    49d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    49d7:	75 11                	jne    49ea <HuffmanTree_makeFromLengths2+0x237>
    49d9:	83 ec 0c             	sub    $0xc,%esp
    49dc:	ff 75 08             	pushl  0x8(%ebp)
    49df:	e8 3f f9 ff ff       	call   4323 <HuffmanTree_makeTable>
    49e4:	83 c4 10             	add    $0x10,%esp
    49e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    49ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    49ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
    49f0:	5b                   	pop    %ebx
    49f1:	5e                   	pop    %esi
    49f2:	5d                   	pop    %ebp
    49f3:	c3                   	ret    

000049f4 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    49f4:	55                   	push   %ebp
    49f5:	89 e5                	mov    %esp,%ebp
    49f7:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    49fa:	8b 45 10             	mov    0x10(%ebp),%eax
    49fd:	c1 e0 02             	shl    $0x2,%eax
    4a00:	83 ec 0c             	sub    $0xc,%esp
    4a03:	50                   	push   %eax
    4a04:	e8 a9 e9 ff ff       	call   33b2 <lodepng_malloc>
    4a09:	83 c4 10             	add    $0x10,%esp
    4a0c:	89 c2                	mov    %eax,%edx
    4a0e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a11:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4a14:	8b 45 08             	mov    0x8(%ebp),%eax
    4a17:	8b 40 04             	mov    0x4(%eax),%eax
    4a1a:	85 c0                	test   %eax,%eax
    4a1c:	75 07                	jne    4a25 <HuffmanTree_makeFromLengths+0x31>
    4a1e:	b8 53 00 00 00       	mov    $0x53,%eax
    4a23:	eb 56                	jmp    4a7b <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4a25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4a2c:	eb 25                	jmp    4a53 <HuffmanTree_makeFromLengths+0x5f>
    4a2e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a31:	8b 40 04             	mov    0x4(%eax),%eax
    4a34:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a37:	c1 e2 02             	shl    $0x2,%edx
    4a3a:	01 c2                	add    %eax,%edx
    4a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a3f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4a46:	8b 45 0c             	mov    0xc(%ebp),%eax
    4a49:	01 c8                	add    %ecx,%eax
    4a4b:	8b 00                	mov    (%eax),%eax
    4a4d:	89 02                	mov    %eax,(%edx)
    4a4f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4a53:	8b 45 10             	mov    0x10(%ebp),%eax
    4a56:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4a59:	75 d3                	jne    4a2e <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4a5b:	8b 55 10             	mov    0x10(%ebp),%edx
    4a5e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a61:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4a64:	8b 45 08             	mov    0x8(%ebp),%eax
    4a67:	8b 55 14             	mov    0x14(%ebp),%edx
    4a6a:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4a6d:	83 ec 0c             	sub    $0xc,%esp
    4a70:	ff 75 08             	pushl  0x8(%ebp)
    4a73:	e8 3b fd ff ff       	call   47b3 <HuffmanTree_makeFromLengths2>
    4a78:	83 c4 10             	add    $0x10,%esp
}
    4a7b:	c9                   	leave  
    4a7c:	c3                   	ret    

00004a7d <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4a7d:	55                   	push   %ebp
    4a7e:	89 e5                	mov    %esp,%ebp
    4a80:	53                   	push   %ebx
    4a81:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4a84:	8b 45 08             	mov    0x8(%ebp),%eax
    4a87:	8b 50 0c             	mov    0xc(%eax),%edx
    4a8a:	8b 45 08             	mov    0x8(%ebp),%eax
    4a8d:	8b 40 08             	mov    0x8(%eax),%eax
    4a90:	39 c2                	cmp    %eax,%edx
    4a92:	0f 82 0b 01 00 00    	jb     4ba3 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4a98:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a9f:	eb 19                	jmp    4aba <bpmnode_create+0x3d>
    4aa1:	8b 45 08             	mov    0x8(%ebp),%eax
    4aa4:	8b 40 04             	mov    0x4(%eax),%eax
    4aa7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4aaa:	c1 e2 04             	shl    $0x4,%edx
    4aad:	01 d0                	add    %edx,%eax
    4aaf:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4ab6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4aba:	8b 45 08             	mov    0x8(%ebp),%eax
    4abd:	8b 00                	mov    (%eax),%eax
    4abf:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4ac2:	75 dd                	jne    4aa1 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4ac4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4acb:	eb 60                	jmp    4b2d <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4acd:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad0:	8b 40 18             	mov    0x18(%eax),%eax
    4ad3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ad6:	c1 e2 02             	shl    $0x2,%edx
    4ad9:	01 d0                	add    %edx,%eax
    4adb:	8b 00                	mov    (%eax),%eax
    4add:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4ae0:	eb 13                	jmp    4af5 <bpmnode_create+0x78>
    4ae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ae5:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4aef:	8b 40 08             	mov    0x8(%eax),%eax
    4af2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4af5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4af9:	75 e7                	jne    4ae2 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4afb:	8b 45 08             	mov    0x8(%ebp),%eax
    4afe:	8b 40 1c             	mov    0x1c(%eax),%eax
    4b01:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b04:	c1 e2 02             	shl    $0x2,%edx
    4b07:	01 d0                	add    %edx,%eax
    4b09:	8b 00                	mov    (%eax),%eax
    4b0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b0e:	eb 13                	jmp    4b23 <bpmnode_create+0xa6>
    4b10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b13:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4b1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b1d:	8b 40 08             	mov    0x8(%eax),%eax
    4b20:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4b27:	75 e7                	jne    4b10 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4b29:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b2d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b30:	8b 40 14             	mov    0x14(%eax),%eax
    4b33:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b36:	75 95                	jne    4acd <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4b38:	8b 45 08             	mov    0x8(%ebp),%eax
    4b3b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4b42:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4b49:	eb 44                	jmp    4b8f <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4b4b:	8b 45 08             	mov    0x8(%ebp),%eax
    4b4e:	8b 40 04             	mov    0x4(%eax),%eax
    4b51:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b54:	c1 e2 04             	shl    $0x4,%edx
    4b57:	01 d0                	add    %edx,%eax
    4b59:	8b 40 0c             	mov    0xc(%eax),%eax
    4b5c:	85 c0                	test   %eax,%eax
    4b5e:	75 2b                	jne    4b8b <bpmnode_create+0x10e>
    4b60:	8b 45 08             	mov    0x8(%ebp),%eax
    4b63:	8b 58 10             	mov    0x10(%eax),%ebx
    4b66:	8b 45 08             	mov    0x8(%ebp),%eax
    4b69:	8b 40 08             	mov    0x8(%eax),%eax
    4b6c:	8d 48 01             	lea    0x1(%eax),%ecx
    4b6f:	8b 55 08             	mov    0x8(%ebp),%edx
    4b72:	89 4a 08             	mov    %ecx,0x8(%edx)
    4b75:	c1 e0 02             	shl    $0x2,%eax
    4b78:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4b7b:	8b 45 08             	mov    0x8(%ebp),%eax
    4b7e:	8b 40 04             	mov    0x4(%eax),%eax
    4b81:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4b84:	c1 e1 04             	shl    $0x4,%ecx
    4b87:	01 c8                	add    %ecx,%eax
    4b89:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4b8b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b8f:	8b 45 08             	mov    0x8(%ebp),%eax
    4b92:	8b 00                	mov    (%eax),%eax
    4b94:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b97:	75 b2                	jne    4b4b <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4b99:	8b 45 08             	mov    0x8(%ebp),%eax
    4b9c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4ba3:	8b 45 08             	mov    0x8(%ebp),%eax
    4ba6:	8b 58 10             	mov    0x10(%eax),%ebx
    4ba9:	8b 45 08             	mov    0x8(%ebp),%eax
    4bac:	8b 40 0c             	mov    0xc(%eax),%eax
    4baf:	8d 48 01             	lea    0x1(%eax),%ecx
    4bb2:	8b 55 08             	mov    0x8(%ebp),%edx
    4bb5:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4bb8:	c1 e0 02             	shl    $0x2,%eax
    4bbb:	01 d8                	add    %ebx,%eax
    4bbd:	8b 00                	mov    (%eax),%eax
    4bbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4bc5:	8b 55 0c             	mov    0xc(%ebp),%edx
    4bc8:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4bca:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4bcd:	8b 55 10             	mov    0x10(%ebp),%edx
    4bd0:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4bd6:	8b 55 14             	mov    0x14(%ebp),%edx
    4bd9:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4bdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4bdf:	83 c4 10             	add    $0x10,%esp
    4be2:	5b                   	pop    %ebx
    4be3:	5d                   	pop    %ebp
    4be4:	c3                   	ret    

00004be5 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4be5:	55                   	push   %ebp
    4be6:	89 e5                	mov    %esp,%ebp
    4be8:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4beb:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bee:	c1 e0 04             	shl    $0x4,%eax
    4bf1:	83 ec 0c             	sub    $0xc,%esp
    4bf4:	50                   	push   %eax
    4bf5:	e8 b8 e7 ff ff       	call   33b2 <lodepng_malloc>
    4bfa:	83 c4 10             	add    $0x10,%esp
    4bfd:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4c00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4c07:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4c0e:	e9 41 01 00 00       	jmp    4d54 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c16:	83 e0 01             	and    $0x1,%eax
    4c19:	85 c0                	test   %eax,%eax
    4c1b:	74 05                	je     4c22 <bpmnode_sort+0x3d>
    4c1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4c20:	eb 03                	jmp    4c25 <bpmnode_sort+0x40>
    4c22:	8b 45 08             	mov    0x8(%ebp),%eax
    4c25:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4c28:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c2b:	83 e0 01             	and    $0x1,%eax
    4c2e:	85 c0                	test   %eax,%eax
    4c30:	74 05                	je     4c37 <bpmnode_sort+0x52>
    4c32:	8b 45 08             	mov    0x8(%ebp),%eax
    4c35:	eb 03                	jmp    4c3a <bpmnode_sort+0x55>
    4c37:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4c3a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4c3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4c44:	e9 f8 00 00 00       	jmp    4d41 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4c49:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c4f:	01 c2                	add    %eax,%edx
    4c51:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c54:	39 c2                	cmp    %eax,%edx
    4c56:	0f 4e c2             	cmovle %edx,%eax
    4c59:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4c5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c5f:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4c62:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c65:	01 c2                	add    %eax,%edx
    4c67:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c6a:	39 c2                	cmp    %eax,%edx
    4c6c:	0f 4e c2             	cmovle %edx,%eax
    4c6f:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4c72:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c75:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4c78:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4c7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4c7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c81:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4c84:	e9 a4 00 00 00       	jmp    4d2d <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4c89:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c8c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4c8f:	7d 62                	jge    4cf3 <bpmnode_sort+0x10e>
    4c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c94:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4c97:	7d 22                	jge    4cbb <bpmnode_sort+0xd6>
    4c99:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c9c:	c1 e0 04             	shl    $0x4,%eax
    4c9f:	89 c2                	mov    %eax,%edx
    4ca1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4ca4:	01 d0                	add    %edx,%eax
    4ca6:	8b 10                	mov    (%eax),%edx
    4ca8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4cab:	c1 e0 04             	shl    $0x4,%eax
    4cae:	89 c1                	mov    %eax,%ecx
    4cb0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4cb3:	01 c8                	add    %ecx,%eax
    4cb5:	8b 00                	mov    (%eax),%eax
    4cb7:	39 c2                	cmp    %eax,%edx
    4cb9:	7f 38                	jg     4cf3 <bpmnode_sort+0x10e>
    4cbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4cbe:	c1 e0 04             	shl    $0x4,%eax
    4cc1:	89 c2                	mov    %eax,%edx
    4cc3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4cc6:	01 d0                	add    %edx,%eax
    4cc8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4ccb:	8d 4a 01             	lea    0x1(%edx),%ecx
    4cce:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4cd1:	89 d1                	mov    %edx,%ecx
    4cd3:	c1 e1 04             	shl    $0x4,%ecx
    4cd6:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4cd9:	01 ca                	add    %ecx,%edx
    4cdb:	8b 0a                	mov    (%edx),%ecx
    4cdd:	89 08                	mov    %ecx,(%eax)
    4cdf:	8b 4a 04             	mov    0x4(%edx),%ecx
    4ce2:	89 48 04             	mov    %ecx,0x4(%eax)
    4ce5:	8b 4a 08             	mov    0x8(%edx),%ecx
    4ce8:	89 48 08             	mov    %ecx,0x8(%eax)
    4ceb:	8b 52 0c             	mov    0xc(%edx),%edx
    4cee:	89 50 0c             	mov    %edx,0xc(%eax)
    4cf1:	eb 36                	jmp    4d29 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4cf3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4cf6:	c1 e0 04             	shl    $0x4,%eax
    4cf9:	89 c2                	mov    %eax,%edx
    4cfb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4cfe:	01 d0                	add    %edx,%eax
    4d00:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4d03:	8d 4a 01             	lea    0x1(%edx),%ecx
    4d06:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4d09:	89 d1                	mov    %edx,%ecx
    4d0b:	c1 e1 04             	shl    $0x4,%ecx
    4d0e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4d11:	01 ca                	add    %ecx,%edx
    4d13:	8b 0a                	mov    (%edx),%ecx
    4d15:	89 08                	mov    %ecx,(%eax)
    4d17:	8b 4a 04             	mov    0x4(%edx),%ecx
    4d1a:	89 48 04             	mov    %ecx,0x4(%eax)
    4d1d:	8b 4a 08             	mov    0x8(%edx),%ecx
    4d20:	89 48 08             	mov    %ecx,0x8(%eax)
    4d23:	8b 52 0c             	mov    0xc(%edx),%edx
    4d26:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4d29:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4d2d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d30:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4d33:	0f 8c 50 ff ff ff    	jl     4c89 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4d39:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d3c:	01 c0                	add    %eax,%eax
    4d3e:	01 45 ec             	add    %eax,-0x14(%ebp)
    4d41:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d44:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4d47:	0f 8c fc fe ff ff    	jl     4c49 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4d4d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4d51:	d1 65 f4             	shll   -0xc(%ebp)
    4d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d57:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4d5a:	0f 8c b3 fe ff ff    	jl     4c13 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4d60:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4d63:	83 e0 01             	and    $0x1,%eax
    4d66:	85 c0                	test   %eax,%eax
    4d68:	74 18                	je     4d82 <bpmnode_sort+0x19d>
    4d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d6d:	c1 e0 04             	shl    $0x4,%eax
    4d70:	83 ec 04             	sub    $0x4,%esp
    4d73:	50                   	push   %eax
    4d74:	ff 75 dc             	pushl  -0x24(%ebp)
    4d77:	ff 75 08             	pushl  0x8(%ebp)
    4d7a:	e8 71 e6 ff ff       	call   33f0 <lodepng_memcpy>
    4d7f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4d82:	83 ec 0c             	sub    $0xc,%esp
    4d85:	ff 75 dc             	pushl  -0x24(%ebp)
    4d88:	e8 46 e6 ff ff       	call   33d3 <lodepng_free>
    4d8d:	83 c4 10             	add    $0x10,%esp
}
    4d90:	90                   	nop
    4d91:	c9                   	leave  
    4d92:	c3                   	ret    

00004d93 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4d93:	55                   	push   %ebp
    4d94:	89 e5                	mov    %esp,%ebp
    4d96:	56                   	push   %esi
    4d97:	53                   	push   %ebx
    4d98:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4d9b:	8b 45 08             	mov    0x8(%ebp),%eax
    4d9e:	8b 40 1c             	mov    0x1c(%eax),%eax
    4da1:	8b 55 14             	mov    0x14(%ebp),%edx
    4da4:	c1 e2 02             	shl    $0x2,%edx
    4da7:	01 d0                	add    %edx,%eax
    4da9:	8b 00                	mov    (%eax),%eax
    4dab:	8b 40 04             	mov    0x4(%eax),%eax
    4dae:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4db1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4db5:	75 66                	jne    4e1d <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4db7:	8b 45 10             	mov    0x10(%ebp),%eax
    4dba:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4dbd:	0f 83 a0 01 00 00    	jae    4f63 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4dc3:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc6:	8b 40 18             	mov    0x18(%eax),%eax
    4dc9:	8b 55 14             	mov    0x14(%ebp),%edx
    4dcc:	c1 e2 02             	shl    $0x2,%edx
    4dcf:	01 c2                	add    %eax,%edx
    4dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd4:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dd7:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4dda:	c1 e1 02             	shl    $0x2,%ecx
    4ddd:	01 c8                	add    %ecx,%eax
    4ddf:	8b 00                	mov    (%eax),%eax
    4de1:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4de3:	8b 45 08             	mov    0x8(%ebp),%eax
    4de6:	8b 40 1c             	mov    0x1c(%eax),%eax
    4de9:	8b 55 14             	mov    0x14(%ebp),%edx
    4dec:	c1 e2 02             	shl    $0x2,%edx
    4def:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4df2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4df5:	8d 50 01             	lea    0x1(%eax),%edx
    4df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4dfb:	c1 e0 04             	shl    $0x4,%eax
    4dfe:	89 c1                	mov    %eax,%ecx
    4e00:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e03:	01 c8                	add    %ecx,%eax
    4e05:	8b 00                	mov    (%eax),%eax
    4e07:	6a 00                	push   $0x0
    4e09:	52                   	push   %edx
    4e0a:	50                   	push   %eax
    4e0b:	ff 75 08             	pushl  0x8(%ebp)
    4e0e:	e8 6a fc ff ff       	call   4a7d <bpmnode_create>
    4e13:	83 c4 10             	add    $0x10,%esp
    4e16:	89 03                	mov    %eax,(%ebx)
    4e18:	e9 47 01 00 00       	jmp    4f64 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4e1d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e20:	8b 40 18             	mov    0x18(%eax),%eax
    4e23:	8b 55 14             	mov    0x14(%ebp),%edx
    4e26:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e2c:	c1 e2 02             	shl    $0x2,%edx
    4e2f:	01 d0                	add    %edx,%eax
    4e31:	8b 00                	mov    (%eax),%eax
    4e33:	8b 10                	mov    (%eax),%edx
    4e35:	8b 45 08             	mov    0x8(%ebp),%eax
    4e38:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e3b:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4e3e:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4e44:	c1 e1 02             	shl    $0x2,%ecx
    4e47:	01 c8                	add    %ecx,%eax
    4e49:	8b 00                	mov    (%eax),%eax
    4e4b:	8b 00                	mov    (%eax),%eax
    4e4d:	01 d0                	add    %edx,%eax
    4e4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4e52:	8b 45 08             	mov    0x8(%ebp),%eax
    4e55:	8b 40 18             	mov    0x18(%eax),%eax
    4e58:	8b 55 14             	mov    0x14(%ebp),%edx
    4e5b:	c1 e2 02             	shl    $0x2,%edx
    4e5e:	01 c2                	add    %eax,%edx
    4e60:	8b 45 08             	mov    0x8(%ebp),%eax
    4e63:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e66:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4e69:	c1 e1 02             	shl    $0x2,%ecx
    4e6c:	01 c8                	add    %ecx,%eax
    4e6e:	8b 00                	mov    (%eax),%eax
    4e70:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4e72:	8b 45 10             	mov    0x10(%ebp),%eax
    4e75:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4e78:	73 60                	jae    4eda <boundaryPM+0x147>
    4e7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e7d:	c1 e0 04             	shl    $0x4,%eax
    4e80:	89 c2                	mov    %eax,%edx
    4e82:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e85:	01 d0                	add    %edx,%eax
    4e87:	8b 00                	mov    (%eax),%eax
    4e89:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4e8c:	7d 4c                	jge    4eda <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4e8e:	8b 45 08             	mov    0x8(%ebp),%eax
    4e91:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e94:	8b 55 14             	mov    0x14(%ebp),%edx
    4e97:	c1 e2 02             	shl    $0x2,%edx
    4e9a:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e9d:	8b 45 08             	mov    0x8(%ebp),%eax
    4ea0:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ea3:	8b 55 14             	mov    0x14(%ebp),%edx
    4ea6:	c1 e2 02             	shl    $0x2,%edx
    4ea9:	01 d0                	add    %edx,%eax
    4eab:	8b 00                	mov    (%eax),%eax
    4ead:	8b 50 08             	mov    0x8(%eax),%edx
    4eb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4eb3:	8d 48 01             	lea    0x1(%eax),%ecx
    4eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4eb9:	c1 e0 04             	shl    $0x4,%eax
    4ebc:	89 c6                	mov    %eax,%esi
    4ebe:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ec1:	01 f0                	add    %esi,%eax
    4ec3:	8b 00                	mov    (%eax),%eax
    4ec5:	52                   	push   %edx
    4ec6:	51                   	push   %ecx
    4ec7:	50                   	push   %eax
    4ec8:	ff 75 08             	pushl  0x8(%ebp)
    4ecb:	e8 ad fb ff ff       	call   4a7d <bpmnode_create>
    4ed0:	83 c4 10             	add    $0x10,%esp
    4ed3:	89 03                	mov    %eax,(%ebx)
      return;
    4ed5:	e9 8a 00 00 00       	jmp    4f64 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4eda:	8b 45 08             	mov    0x8(%ebp),%eax
    4edd:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ee0:	8b 55 14             	mov    0x14(%ebp),%edx
    4ee3:	c1 e2 02             	shl    $0x2,%edx
    4ee6:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4ee9:	8b 45 08             	mov    0x8(%ebp),%eax
    4eec:	8b 40 1c             	mov    0x1c(%eax),%eax
    4eef:	8b 55 14             	mov    0x14(%ebp),%edx
    4ef2:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4ef8:	c1 e2 02             	shl    $0x2,%edx
    4efb:	01 d0                	add    %edx,%eax
    4efd:	8b 00                	mov    (%eax),%eax
    4eff:	50                   	push   %eax
    4f00:	ff 75 f4             	pushl  -0xc(%ebp)
    4f03:	ff 75 f0             	pushl  -0x10(%ebp)
    4f06:	ff 75 08             	pushl  0x8(%ebp)
    4f09:	e8 6f fb ff ff       	call   4a7d <bpmnode_create>
    4f0e:	83 c4 10             	add    $0x10,%esp
    4f11:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4f13:	8b 45 18             	mov    0x18(%ebp),%eax
    4f16:	8d 50 01             	lea    0x1(%eax),%edx
    4f19:	8b 45 10             	mov    0x10(%ebp),%eax
    4f1c:	83 e8 01             	sub    $0x1,%eax
    4f1f:	01 c0                	add    %eax,%eax
    4f21:	39 c2                	cmp    %eax,%edx
    4f23:	7d 3f                	jge    4f64 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4f25:	8b 45 14             	mov    0x14(%ebp),%eax
    4f28:	83 e8 01             	sub    $0x1,%eax
    4f2b:	83 ec 0c             	sub    $0xc,%esp
    4f2e:	ff 75 18             	pushl  0x18(%ebp)
    4f31:	50                   	push   %eax
    4f32:	ff 75 10             	pushl  0x10(%ebp)
    4f35:	ff 75 0c             	pushl  0xc(%ebp)
    4f38:	ff 75 08             	pushl  0x8(%ebp)
    4f3b:	e8 53 fe ff ff       	call   4d93 <boundaryPM>
    4f40:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4f43:	8b 45 14             	mov    0x14(%ebp),%eax
    4f46:	83 e8 01             	sub    $0x1,%eax
    4f49:	83 ec 0c             	sub    $0xc,%esp
    4f4c:	ff 75 18             	pushl  0x18(%ebp)
    4f4f:	50                   	push   %eax
    4f50:	ff 75 10             	pushl  0x10(%ebp)
    4f53:	ff 75 0c             	pushl  0xc(%ebp)
    4f56:	ff 75 08             	pushl  0x8(%ebp)
    4f59:	e8 35 fe ff ff       	call   4d93 <boundaryPM>
    4f5e:	83 c4 20             	add    $0x20,%esp
    4f61:	eb 01                	jmp    4f64 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4f63:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4f64:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4f67:	5b                   	pop    %ebx
    4f68:	5e                   	pop    %esi
    4f69:	5d                   	pop    %ebp
    4f6a:	c3                   	ret    

00004f6b <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4f6b:	55                   	push   %ebp
    4f6c:	89 e5                	mov    %esp,%ebp
    4f6e:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4f71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4f78:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4f7f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4f83:	75 0a                	jne    4f8f <lodepng_huffman_code_lengths+0x24>
    4f85:	b8 50 00 00 00       	mov    $0x50,%eax
    4f8a:	e9 4d 03 00 00       	jmp    52dc <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4f8f:	8b 45 14             	mov    0x14(%ebp),%eax
    4f92:	ba 01 00 00 00       	mov    $0x1,%edx
    4f97:	89 c1                	mov    %eax,%ecx
    4f99:	d3 e2                	shl    %cl,%edx
    4f9b:	8b 45 10             	mov    0x10(%ebp),%eax
    4f9e:	39 c2                	cmp    %eax,%edx
    4fa0:	73 0a                	jae    4fac <lodepng_huffman_code_lengths+0x41>
    4fa2:	b8 50 00 00 00       	mov    $0x50,%eax
    4fa7:	e9 30 03 00 00       	jmp    52dc <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4fac:	8b 45 10             	mov    0x10(%ebp),%eax
    4faf:	c1 e0 04             	shl    $0x4,%eax
    4fb2:	83 ec 0c             	sub    $0xc,%esp
    4fb5:	50                   	push   %eax
    4fb6:	e8 f7 e3 ff ff       	call   33b2 <lodepng_malloc>
    4fbb:	83 c4 10             	add    $0x10,%esp
    4fbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    4fc1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4fc5:	75 0a                	jne    4fd1 <lodepng_huffman_code_lengths+0x66>
    4fc7:	b8 53 00 00 00       	mov    $0x53,%eax
    4fcc:	e9 0b 03 00 00       	jmp    52dc <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    4fd1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4fd8:	eb 50                	jmp    502a <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    4fda:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4fdd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
    4fe7:	01 d0                	add    %edx,%eax
    4fe9:	8b 00                	mov    (%eax),%eax
    4feb:	85 c0                	test   %eax,%eax
    4fed:	74 37                	je     5026 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    4fef:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4ff2:	c1 e0 04             	shl    $0x4,%eax
    4ff5:	89 c2                	mov    %eax,%edx
    4ff7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ffa:	01 d0                	add    %edx,%eax
    4ffc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4fff:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    5006:	8b 55 0c             	mov    0xc(%ebp),%edx
    5009:	01 ca                	add    %ecx,%edx
    500b:	8b 12                	mov    (%edx),%edx
    500d:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    500f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5012:	c1 e0 04             	shl    $0x4,%eax
    5015:	89 c2                	mov    %eax,%edx
    5017:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    501a:	01 c2                	add    %eax,%edx
    501c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    501f:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5022:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    5026:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    502a:	8b 45 10             	mov    0x10(%ebp),%eax
    502d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5030:	75 a8                	jne    4fda <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5032:	8b 45 10             	mov    0x10(%ebp),%eax
    5035:	c1 e0 02             	shl    $0x2,%eax
    5038:	83 ec 04             	sub    $0x4,%esp
    503b:	50                   	push   %eax
    503c:	6a 00                	push   $0x0
    503e:	ff 75 08             	pushl  0x8(%ebp)
    5041:	e8 dd e3 ff ff       	call   3423 <lodepng_memset>
    5046:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    5049:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    504d:	75 18                	jne    5067 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    504f:	8b 45 08             	mov    0x8(%ebp),%eax
    5052:	83 c0 04             	add    $0x4,%eax
    5055:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    505b:	8b 10                	mov    (%eax),%edx
    505d:	8b 45 08             	mov    0x8(%ebp),%eax
    5060:	89 10                	mov    %edx,(%eax)
    5062:	e9 64 02 00 00       	jmp    52cb <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    5067:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    506b:	75 3e                	jne    50ab <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    506d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5070:	8b 40 04             	mov    0x4(%eax),%eax
    5073:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    507a:	8b 45 08             	mov    0x8(%ebp),%eax
    507d:	01 d0                	add    %edx,%eax
    507f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    5085:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5088:	8b 40 04             	mov    0x4(%eax),%eax
    508b:	85 c0                	test   %eax,%eax
    508d:	75 07                	jne    5096 <lodepng_huffman_code_lengths+0x12b>
    508f:	ba 04 00 00 00       	mov    $0x4,%edx
    5094:	eb 05                	jmp    509b <lodepng_huffman_code_lengths+0x130>
    5096:	ba 00 00 00 00       	mov    $0x0,%edx
    509b:	8b 45 08             	mov    0x8(%ebp),%eax
    509e:	01 d0                	add    %edx,%eax
    50a0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    50a6:	e9 20 02 00 00       	jmp    52cb <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    50ab:	83 ec 08             	sub    $0x8,%esp
    50ae:	ff 75 ec             	pushl  -0x14(%ebp)
    50b1:	ff 75 e4             	pushl  -0x1c(%ebp)
    50b4:	e8 2c fb ff ff       	call   4be5 <bpmnode_sort>
    50b9:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    50bc:	8b 45 14             	mov    0x14(%ebp),%eax
    50bf:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    50c2:	8b 45 14             	mov    0x14(%ebp),%eax
    50c5:	83 c0 01             	add    $0x1,%eax
    50c8:	0f af 45 14          	imul   0x14(%ebp),%eax
    50cc:	01 c0                	add    %eax,%eax
    50ce:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    50d1:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    50d8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50db:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    50de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50e1:	c1 e0 04             	shl    $0x4,%eax
    50e4:	83 ec 0c             	sub    $0xc,%esp
    50e7:	50                   	push   %eax
    50e8:	e8 c5 e2 ff ff       	call   33b2 <lodepng_malloc>
    50ed:	83 c4 10             	add    $0x10,%esp
    50f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    50f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50f6:	c1 e0 02             	shl    $0x2,%eax
    50f9:	83 ec 0c             	sub    $0xc,%esp
    50fc:	50                   	push   %eax
    50fd:	e8 b0 e2 ff ff       	call   33b2 <lodepng_malloc>
    5102:	83 c4 10             	add    $0x10,%esp
    5105:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5108:	8b 45 d8             	mov    -0x28(%ebp),%eax
    510b:	c1 e0 02             	shl    $0x2,%eax
    510e:	83 ec 0c             	sub    $0xc,%esp
    5111:	50                   	push   %eax
    5112:	e8 9b e2 ff ff       	call   33b2 <lodepng_malloc>
    5117:	83 c4 10             	add    $0x10,%esp
    511a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    511d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5120:	c1 e0 02             	shl    $0x2,%eax
    5123:	83 ec 0c             	sub    $0xc,%esp
    5126:	50                   	push   %eax
    5127:	e8 86 e2 ff ff       	call   33b2 <lodepng_malloc>
    512c:	83 c4 10             	add    $0x10,%esp
    512f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5132:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5135:	85 c0                	test   %eax,%eax
    5137:	74 15                	je     514e <lodepng_huffman_code_lengths+0x1e3>
    5139:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    513c:	85 c0                	test   %eax,%eax
    513e:	74 0e                	je     514e <lodepng_huffman_code_lengths+0x1e3>
    5140:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5143:	85 c0                	test   %eax,%eax
    5145:	74 07                	je     514e <lodepng_huffman_code_lengths+0x1e3>
    5147:	8b 45 e0             	mov    -0x20(%ebp),%eax
    514a:	85 c0                	test   %eax,%eax
    514c:	75 07                	jne    5155 <lodepng_huffman_code_lengths+0x1ea>
    514e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    5155:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5159:	0f 85 30 01 00 00    	jne    528f <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    515f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5166:	eb 1c                	jmp    5184 <lodepng_huffman_code_lengths+0x219>
    5168:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    516b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    516e:	c1 e2 02             	shl    $0x2,%edx
    5171:	01 d0                	add    %edx,%eax
    5173:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5176:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5179:	c1 e1 04             	shl    $0x4,%ecx
    517c:	01 ca                	add    %ecx,%edx
    517e:	89 10                	mov    %edx,(%eax)
    5180:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5184:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5187:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    518a:	75 dc                	jne    5168 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    518c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    518f:	8b 00                	mov    (%eax),%eax
    5191:	6a 00                	push   $0x0
    5193:	6a 01                	push   $0x1
    5195:	50                   	push   %eax
    5196:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5199:	50                   	push   %eax
    519a:	e8 de f8 ff ff       	call   4a7d <bpmnode_create>
    519f:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    51a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51a5:	83 c0 10             	add    $0x10,%eax
    51a8:	8b 00                	mov    (%eax),%eax
    51aa:	6a 00                	push   $0x0
    51ac:	6a 02                	push   $0x2
    51ae:	50                   	push   %eax
    51af:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    51b2:	50                   	push   %eax
    51b3:	e8 c5 f8 ff ff       	call   4a7d <bpmnode_create>
    51b8:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    51bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    51c2:	eb 27                	jmp    51eb <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    51c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    51c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    51ca:	c1 e2 02             	shl    $0x2,%edx
    51cd:	01 c2                	add    %eax,%edx
    51cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
    51d2:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    51d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    51da:	c1 e2 02             	shl    $0x2,%edx
    51dd:	01 d0                	add    %edx,%eax
    51df:	8b 55 c8             	mov    -0x38(%ebp),%edx
    51e2:	83 c2 10             	add    $0x10,%edx
    51e5:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    51e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51eb:	8b 45 d8             	mov    -0x28(%ebp),%eax
    51ee:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51f1:	75 d1                	jne    51c4 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    51f3:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    51fa:	eb 24                	jmp    5220 <lodepng_huffman_code_lengths+0x2b5>
    51fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    51ff:	8b 55 14             	mov    0x14(%ebp),%edx
    5202:	83 ea 01             	sub    $0x1,%edx
    5205:	83 ec 0c             	sub    $0xc,%esp
    5208:	50                   	push   %eax
    5209:	52                   	push   %edx
    520a:	ff 75 ec             	pushl  -0x14(%ebp)
    520d:	ff 75 e4             	pushl  -0x1c(%ebp)
    5210:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5213:	50                   	push   %eax
    5214:	e8 7a fb ff ff       	call   4d93 <boundaryPM>
    5219:	83 c4 20             	add    $0x20,%esp
    521c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5220:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5223:	83 e8 01             	sub    $0x1,%eax
    5226:	01 c0                	add    %eax,%eax
    5228:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    522b:	75 cf                	jne    51fc <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    522d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5230:	8b 55 14             	mov    0x14(%ebp),%edx
    5233:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5239:	c1 e2 02             	shl    $0x2,%edx
    523c:	01 d0                	add    %edx,%eax
    523e:	8b 00                	mov    (%eax),%eax
    5240:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5243:	eb 44                	jmp    5289 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    5245:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    524c:	eb 27                	jmp    5275 <lodepng_huffman_code_lengths+0x30a>
    524e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5251:	c1 e0 04             	shl    $0x4,%eax
    5254:	89 c2                	mov    %eax,%edx
    5256:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5259:	01 d0                	add    %edx,%eax
    525b:	8b 40 04             	mov    0x4(%eax),%eax
    525e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5265:	8b 45 08             	mov    0x8(%ebp),%eax
    5268:	01 d0                	add    %edx,%eax
    526a:	8b 10                	mov    (%eax),%edx
    526c:	83 c2 01             	add    $0x1,%edx
    526f:	89 10                	mov    %edx,(%eax)
    5271:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5275:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5278:	8b 40 04             	mov    0x4(%eax),%eax
    527b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    527e:	75 ce                	jne    524e <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5280:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5283:	8b 40 08             	mov    0x8(%eax),%eax
    5286:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5289:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    528d:	75 b6                	jne    5245 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    528f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5292:	83 ec 0c             	sub    $0xc,%esp
    5295:	50                   	push   %eax
    5296:	e8 38 e1 ff ff       	call   33d3 <lodepng_free>
    529b:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    529e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    52a1:	83 ec 0c             	sub    $0xc,%esp
    52a4:	50                   	push   %eax
    52a5:	e8 29 e1 ff ff       	call   33d3 <lodepng_free>
    52aa:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    52ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
    52b0:	83 ec 0c             	sub    $0xc,%esp
    52b3:	50                   	push   %eax
    52b4:	e8 1a e1 ff ff       	call   33d3 <lodepng_free>
    52b9:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    52bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    52bf:	83 ec 0c             	sub    $0xc,%esp
    52c2:	50                   	push   %eax
    52c3:	e8 0b e1 ff ff       	call   33d3 <lodepng_free>
    52c8:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    52cb:	83 ec 0c             	sub    $0xc,%esp
    52ce:	ff 75 e4             	pushl  -0x1c(%ebp)
    52d1:	e8 fd e0 ff ff       	call   33d3 <lodepng_free>
    52d6:	83 c4 10             	add    $0x10,%esp
  return error;
    52d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    52dc:	c9                   	leave  
    52dd:	c3                   	ret    

000052de <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    52de:	55                   	push   %ebp
    52df:	89 e5                	mov    %esp,%ebp
    52e1:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    52e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    52eb:	eb 04                	jmp    52f1 <HuffmanTree_makeFromFrequencies+0x13>
    52ed:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    52f1:	8b 45 14             	mov    0x14(%ebp),%eax
    52f4:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    52f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5300:	8b 45 0c             	mov    0xc(%ebp),%eax
    5303:	01 d0                	add    %edx,%eax
    5305:	8b 00                	mov    (%eax),%eax
    5307:	85 c0                	test   %eax,%eax
    5309:	75 08                	jne    5313 <HuffmanTree_makeFromFrequencies+0x35>
    530b:	8b 45 14             	mov    0x14(%ebp),%eax
    530e:	3b 45 10             	cmp    0x10(%ebp),%eax
    5311:	7f da                	jg     52ed <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5313:	8b 45 14             	mov    0x14(%ebp),%eax
    5316:	c1 e0 02             	shl    $0x2,%eax
    5319:	83 ec 0c             	sub    $0xc,%esp
    531c:	50                   	push   %eax
    531d:	e8 90 e0 ff ff       	call   33b2 <lodepng_malloc>
    5322:	83 c4 10             	add    $0x10,%esp
    5325:	89 c2                	mov    %eax,%edx
    5327:	8b 45 08             	mov    0x8(%ebp),%eax
    532a:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    532d:	8b 45 08             	mov    0x8(%ebp),%eax
    5330:	8b 40 04             	mov    0x4(%eax),%eax
    5333:	85 c0                	test   %eax,%eax
    5335:	75 07                	jne    533e <HuffmanTree_makeFromFrequencies+0x60>
    5337:	b8 53 00 00 00       	mov    $0x53,%eax
    533c:	eb 47                	jmp    5385 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    533e:	8b 45 08             	mov    0x8(%ebp),%eax
    5341:	8b 55 18             	mov    0x18(%ebp),%edx
    5344:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5347:	8b 55 14             	mov    0x14(%ebp),%edx
    534a:	8b 45 08             	mov    0x8(%ebp),%eax
    534d:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    5350:	8b 45 08             	mov    0x8(%ebp),%eax
    5353:	8b 40 04             	mov    0x4(%eax),%eax
    5356:	ff 75 18             	pushl  0x18(%ebp)
    5359:	ff 75 14             	pushl  0x14(%ebp)
    535c:	ff 75 0c             	pushl  0xc(%ebp)
    535f:	50                   	push   %eax
    5360:	e8 06 fc ff ff       	call   4f6b <lodepng_huffman_code_lengths>
    5365:	83 c4 10             	add    $0x10,%esp
    5368:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    536b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    536f:	75 11                	jne    5382 <HuffmanTree_makeFromFrequencies+0xa4>
    5371:	83 ec 0c             	sub    $0xc,%esp
    5374:	ff 75 08             	pushl  0x8(%ebp)
    5377:	e8 37 f4 ff ff       	call   47b3 <HuffmanTree_makeFromLengths2>
    537c:	83 c4 10             	add    $0x10,%esp
    537f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5382:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5385:	c9                   	leave  
    5386:	c3                   	ret    

00005387 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    5387:	55                   	push   %ebp
    5388:	89 e5                	mov    %esp,%ebp
    538a:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    538d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5394:	83 ec 0c             	sub    $0xc,%esp
    5397:	68 80 04 00 00       	push   $0x480
    539c:	e8 11 e0 ff ff       	call   33b2 <lodepng_malloc>
    53a1:	83 c4 10             	add    $0x10,%esp
    53a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    53a7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    53ab:	75 0a                	jne    53b7 <generateFixedLitLenTree+0x30>
    53ad:	b8 53 00 00 00       	mov    $0x53,%eax
    53b2:	e9 d5 00 00 00       	jmp    548c <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    53b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    53be:	eb 19                	jmp    53d9 <generateFixedLitLenTree+0x52>
    53c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53cd:	01 d0                	add    %edx,%eax
    53cf:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    53d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53d9:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    53e0:	76 de                	jbe    53c0 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    53e2:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    53e9:	eb 19                	jmp    5404 <generateFixedLitLenTree+0x7d>
    53eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53f8:	01 d0                	add    %edx,%eax
    53fa:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5400:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5404:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    540b:	76 de                	jbe    53eb <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    540d:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5414:	eb 19                	jmp    542f <generateFixedLitLenTree+0xa8>
    5416:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5419:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5420:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5423:	01 d0                	add    %edx,%eax
    5425:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    542b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    542f:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    5436:	76 de                	jbe    5416 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    5438:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    543f:	eb 19                	jmp    545a <generateFixedLitLenTree+0xd3>
    5441:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5444:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    544b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    544e:	01 d0                	add    %edx,%eax
    5450:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5456:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    545a:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    5461:	76 de                	jbe    5441 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5463:	6a 0f                	push   $0xf
    5465:	68 20 01 00 00       	push   $0x120
    546a:	ff 75 ec             	pushl  -0x14(%ebp)
    546d:	ff 75 08             	pushl  0x8(%ebp)
    5470:	e8 7f f5 ff ff       	call   49f4 <HuffmanTree_makeFromLengths>
    5475:	83 c4 10             	add    $0x10,%esp
    5478:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    547b:	83 ec 0c             	sub    $0xc,%esp
    547e:	ff 75 ec             	pushl  -0x14(%ebp)
    5481:	e8 4d df ff ff       	call   33d3 <lodepng_free>
    5486:	83 c4 10             	add    $0x10,%esp
  return error;
    5489:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    548c:	c9                   	leave  
    548d:	c3                   	ret    

0000548e <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    548e:	55                   	push   %ebp
    548f:	89 e5                	mov    %esp,%ebp
    5491:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5494:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    549b:	83 ec 0c             	sub    $0xc,%esp
    549e:	68 80 00 00 00       	push   $0x80
    54a3:	e8 0a df ff ff       	call   33b2 <lodepng_malloc>
    54a8:	83 c4 10             	add    $0x10,%esp
    54ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    54ae:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    54b2:	75 07                	jne    54bb <generateFixedDistanceTree+0x2d>
    54b4:	b8 53 00 00 00       	mov    $0x53,%eax
    54b9:	eb 4e                	jmp    5509 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    54bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    54c2:	eb 19                	jmp    54dd <generateFixedDistanceTree+0x4f>
    54c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    54c7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    54ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
    54d1:	01 d0                	add    %edx,%eax
    54d3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    54d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    54dd:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    54e1:	75 e1                	jne    54c4 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    54e3:	6a 0f                	push   $0xf
    54e5:	6a 20                	push   $0x20
    54e7:	ff 75 ec             	pushl  -0x14(%ebp)
    54ea:	ff 75 08             	pushl  0x8(%ebp)
    54ed:	e8 02 f5 ff ff       	call   49f4 <HuffmanTree_makeFromLengths>
    54f2:	83 c4 10             	add    $0x10,%esp
    54f5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    54f8:	83 ec 0c             	sub    $0xc,%esp
    54fb:	ff 75 ec             	pushl  -0x14(%ebp)
    54fe:	e8 d0 de ff ff       	call   33d3 <lodepng_free>
    5503:	83 c4 10             	add    $0x10,%esp
  return error;
    5506:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5509:	c9                   	leave  
    550a:	c3                   	ret    

0000550b <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    550b:	55                   	push   %ebp
    550c:	89 e5                	mov    %esp,%ebp
    550e:	53                   	push   %ebx
    550f:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5512:	6a 09                	push   $0x9
    5514:	ff 75 08             	pushl  0x8(%ebp)
    5517:	e8 d8 eb ff ff       	call   40f4 <peekBits>
    551c:	83 c4 08             	add    $0x8,%esp
    551f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5523:	8b 45 0c             	mov    0xc(%ebp),%eax
    5526:	8b 50 10             	mov    0x10(%eax),%edx
    5529:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    552d:	01 d0                	add    %edx,%eax
    552f:	0f b6 00             	movzbl (%eax),%eax
    5532:	0f b6 c0             	movzbl %al,%eax
    5535:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    5539:	8b 45 0c             	mov    0xc(%ebp),%eax
    553c:	8b 40 14             	mov    0x14(%eax),%eax
    553f:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5543:	01 d2                	add    %edx,%edx
    5545:	01 d0                	add    %edx,%eax
    5547:	0f b7 00             	movzwl (%eax),%eax
    554a:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    554e:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    5553:	77 16                	ja     556b <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    5555:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5559:	50                   	push   %eax
    555a:	ff 75 08             	pushl  0x8(%ebp)
    555d:	e8 b2 eb ff ff       	call   4114 <advanceBits>
    5562:	83 c4 08             	add    $0x8,%esp
    return value;
    5565:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    5569:	eb 5c                	jmp    55c7 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    556b:	6a 09                	push   $0x9
    556d:	ff 75 08             	pushl  0x8(%ebp)
    5570:	e8 9f eb ff ff       	call   4114 <advanceBits>
    5575:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    5578:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    557c:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5580:	83 e8 09             	sub    $0x9,%eax
    5583:	50                   	push   %eax
    5584:	ff 75 08             	pushl  0x8(%ebp)
    5587:	e8 68 eb ff ff       	call   40f4 <peekBits>
    558c:	83 c4 08             	add    $0x8,%esp
    558f:	01 d8                	add    %ebx,%eax
    5591:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    5594:	8b 45 0c             	mov    0xc(%ebp),%eax
    5597:	8b 50 10             	mov    0x10(%eax),%edx
    559a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    559d:	01 d0                	add    %edx,%eax
    559f:	0f b6 00             	movzbl (%eax),%eax
    55a2:	0f b6 c0             	movzbl %al,%eax
    55a5:	83 e8 09             	sub    $0x9,%eax
    55a8:	50                   	push   %eax
    55a9:	ff 75 08             	pushl  0x8(%ebp)
    55ac:	e8 63 eb ff ff       	call   4114 <advanceBits>
    55b1:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    55b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    55b7:	8b 40 14             	mov    0x14(%eax),%eax
    55ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
    55bd:	01 d2                	add    %edx,%edx
    55bf:	01 d0                	add    %edx,%eax
    55c1:	0f b7 00             	movzwl (%eax),%eax
    55c4:	0f b7 c0             	movzwl %ax,%eax
  }
}
    55c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    55ca:	c9                   	leave  
    55cb:	c3                   	ret    

000055cc <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    55cc:	55                   	push   %ebp
    55cd:	89 e5                	mov    %esp,%ebp
    55cf:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    55d2:	83 ec 0c             	sub    $0xc,%esp
    55d5:	ff 75 08             	pushl  0x8(%ebp)
    55d8:	e8 aa fd ff ff       	call   5387 <generateFixedLitLenTree>
    55dd:	83 c4 10             	add    $0x10,%esp
    55e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    55e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    55e7:	74 05                	je     55ee <getTreeInflateFixed+0x22>
    55e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    55ec:	eb 0e                	jmp    55fc <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    55ee:	83 ec 0c             	sub    $0xc,%esp
    55f1:	ff 75 0c             	pushl  0xc(%ebp)
    55f4:	e8 95 fe ff ff       	call   548e <generateFixedDistanceTree>
    55f9:	83 c4 10             	add    $0x10,%esp
}
    55fc:	c9                   	leave  
    55fd:	c3                   	ret    

000055fe <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    55fe:	55                   	push   %ebp
    55ff:	89 e5                	mov    %esp,%ebp
    5601:	53                   	push   %ebx
    5602:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5605:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    560c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5613:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    561a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5621:	6a 0e                	push   $0xe
    5623:	ff 75 10             	pushl  0x10(%ebp)
    5626:	e8 37 e6 ff ff       	call   3c62 <ensureBits17>
    562b:	83 c4 08             	add    $0x8,%esp
    562e:	85 c0                	test   %eax,%eax
    5630:	75 0a                	jne    563c <getTreeInflateDynamic+0x3e>
    5632:	b8 31 00 00 00       	mov    $0x31,%eax
    5637:	e9 ec 04 00 00       	jmp    5b28 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    563c:	6a 05                	push   $0x5
    563e:	ff 75 10             	pushl  0x10(%ebp)
    5641:	e8 f8 ea ff ff       	call   413e <readBits>
    5646:	83 c4 08             	add    $0x8,%esp
    5649:	05 01 01 00 00       	add    $0x101,%eax
    564e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    5651:	6a 05                	push   $0x5
    5653:	ff 75 10             	pushl  0x10(%ebp)
    5656:	e8 e3 ea ff ff       	call   413e <readBits>
    565b:	83 c4 08             	add    $0x8,%esp
    565e:	83 c0 01             	add    $0x1,%eax
    5661:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    5664:	6a 04                	push   $0x4
    5666:	ff 75 10             	pushl  0x10(%ebp)
    5669:	e8 d0 ea ff ff       	call   413e <readBits>
    566e:	83 c4 08             	add    $0x8,%esp
    5671:	83 c0 04             	add    $0x4,%eax
    5674:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    5677:	83 ec 0c             	sub    $0xc,%esp
    567a:	6a 4c                	push   $0x4c
    567c:	e8 31 dd ff ff       	call   33b2 <lodepng_malloc>
    5681:	83 c4 10             	add    $0x10,%esp
    5684:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    5687:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    568b:	75 0a                	jne    5697 <getTreeInflateDynamic+0x99>
    568d:	b8 53 00 00 00       	mov    $0x53,%eax
    5692:	e9 91 04 00 00       	jmp    5b28 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    5697:	83 ec 0c             	sub    $0xc,%esp
    569a:	8d 45 a8             	lea    -0x58(%ebp),%eax
    569d:	50                   	push   %eax
    569e:	e8 03 ec ff ff       	call   42a6 <HuffmanTree_init>
    56a3:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    56a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56aa:	0f 85 3c 04 00 00    	jne    5aec <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    56b0:	8b 45 10             	mov    0x10(%ebp),%eax
    56b3:	8b 48 08             	mov    0x8(%eax),%ecx
    56b6:	8b 55 d0             	mov    -0x30(%ebp),%edx
    56b9:	89 d0                	mov    %edx,%eax
    56bb:	01 c0                	add    %eax,%eax
    56bd:	01 d0                	add    %edx,%eax
    56bf:	89 c2                	mov    %eax,%edx
    56c1:	8b 45 10             	mov    0x10(%ebp),%eax
    56c4:	8b 40 0c             	mov    0xc(%eax),%eax
    56c7:	83 ec 04             	sub    $0x4,%esp
    56ca:	51                   	push   %ecx
    56cb:	52                   	push   %edx
    56cc:	50                   	push   %eax
    56cd:	e8 f7 dd ff ff       	call   34c9 <lodepng_gtofl>
    56d2:	83 c4 10             	add    $0x10,%esp
    56d5:	85 c0                	test   %eax,%eax
    56d7:	74 0c                	je     56e5 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    56d9:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    56e0:	e9 07 04 00 00       	jmp    5aec <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    56e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    56ec:	eb 3d                	jmp    572b <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    56ee:	83 ec 08             	sub    $0x8,%esp
    56f1:	6a 03                	push   $0x3
    56f3:	ff 75 10             	pushl  0x10(%ebp)
    56f6:	e8 8b e4 ff ff       	call   3b86 <ensureBits9>
    56fb:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    56fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5701:	8b 04 85 20 a0 01 00 	mov    0x1a020(,%eax,4),%eax
    5708:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    570f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5712:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5715:	83 ec 08             	sub    $0x8,%esp
    5718:	6a 03                	push   $0x3
    571a:	ff 75 10             	pushl  0x10(%ebp)
    571d:	e8 1c ea ff ff       	call   413e <readBits>
    5722:	83 c4 10             	add    $0x10,%esp
    5725:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5727:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    572b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    572e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5731:	75 bb                	jne    56ee <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5733:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5736:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5739:	eb 20                	jmp    575b <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    573b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    573e:	8b 04 85 20 a0 01 00 	mov    0x1a020(,%eax,4),%eax
    5745:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    574c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    574f:	01 d0                	add    %edx,%eax
    5751:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5757:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    575b:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    575f:	75 da                	jne    573b <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    5761:	6a 07                	push   $0x7
    5763:	6a 13                	push   $0x13
    5765:	ff 75 dc             	pushl  -0x24(%ebp)
    5768:	8d 45 a8             	lea    -0x58(%ebp),%eax
    576b:	50                   	push   %eax
    576c:	e8 83 f2 ff ff       	call   49f4 <HuffmanTree_makeFromLengths>
    5771:	83 c4 10             	add    $0x10,%esp
    5774:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5777:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    577b:	0f 85 64 03 00 00    	jne    5ae5 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5781:	83 ec 0c             	sub    $0xc,%esp
    5784:	68 80 04 00 00       	push   $0x480
    5789:	e8 24 dc ff ff       	call   33b2 <lodepng_malloc>
    578e:	83 c4 10             	add    $0x10,%esp
    5791:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5794:	83 ec 0c             	sub    $0xc,%esp
    5797:	68 80 00 00 00       	push   $0x80
    579c:	e8 11 dc ff ff       	call   33b2 <lodepng_malloc>
    57a1:	83 c4 10             	add    $0x10,%esp
    57a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    57a7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    57ab:	74 06                	je     57b3 <getTreeInflateDynamic+0x1b5>
    57ad:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    57b1:	75 0c                	jne    57bf <getTreeInflateDynamic+0x1c1>
    57b3:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    57ba:	e9 2d 03 00 00       	jmp    5aec <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    57bf:	83 ec 04             	sub    $0x4,%esp
    57c2:	68 80 04 00 00       	push   $0x480
    57c7:	6a 00                	push   $0x0
    57c9:	ff 75 e8             	pushl  -0x18(%ebp)
    57cc:	e8 52 dc ff ff       	call   3423 <lodepng_memset>
    57d1:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    57d4:	83 ec 04             	sub    $0x4,%esp
    57d7:	68 80 00 00 00       	push   $0x80
    57dc:	6a 00                	push   $0x0
    57de:	ff 75 e4             	pushl  -0x1c(%ebp)
    57e1:	e8 3d dc ff ff       	call   3423 <lodepng_memset>
    57e6:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    57e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    57f0:	e9 8d 02 00 00       	jmp    5a82 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    57f5:	83 ec 08             	sub    $0x8,%esp
    57f8:	6a 16                	push   $0x16
    57fa:	ff 75 10             	pushl  0x10(%ebp)
    57fd:	e8 8c e5 ff ff       	call   3d8e <ensureBits25>
    5802:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5805:	83 ec 08             	sub    $0x8,%esp
    5808:	8d 45 a8             	lea    -0x58(%ebp),%eax
    580b:	50                   	push   %eax
    580c:	ff 75 10             	pushl  0x10(%ebp)
    580f:	e8 f7 fc ff ff       	call   550b <huffmanDecodeSymbol>
    5814:	83 c4 10             	add    $0x10,%esp
    5817:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    581a:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    581e:	77 3e                	ja     585e <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5820:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5823:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5826:	73 16                	jae    583e <getTreeInflateDynamic+0x240>
    5828:	8b 45 ec             	mov    -0x14(%ebp),%eax
    582b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5832:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5835:	01 c2                	add    %eax,%edx
    5837:	8b 45 cc             	mov    -0x34(%ebp),%eax
    583a:	89 02                	mov    %eax,(%edx)
    583c:	eb 17                	jmp    5855 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    583e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5841:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5844:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    584b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    584e:	01 c2                	add    %eax,%edx
    5850:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5853:	89 02                	mov    %eax,(%edx)
        ++i;
    5855:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5859:	e9 0b 02 00 00       	jmp    5a69 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    585e:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    5862:	0f 85 da 00 00 00    	jne    5942 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5868:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    586f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5873:	75 0c                	jne    5881 <getTreeInflateDynamic+0x283>
    5875:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    587c:	e9 12 02 00 00       	jmp    5a93 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    5881:	83 ec 08             	sub    $0x8,%esp
    5884:	6a 02                	push   $0x2
    5886:	ff 75 10             	pushl  0x10(%ebp)
    5889:	e8 b0 e8 ff ff       	call   413e <readBits>
    588e:	83 c4 10             	add    $0x10,%esp
    5891:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5894:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5897:	83 c0 01             	add    $0x1,%eax
    589a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    589d:	76 1b                	jbe    58ba <getTreeInflateDynamic+0x2bc>
    589f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58a2:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    58a7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
    58b1:	01 d0                	add    %edx,%eax
    58b3:	8b 00                	mov    (%eax),%eax
    58b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    58b8:	eb 1c                	jmp    58d6 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    58ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58bd:	2b 45 d8             	sub    -0x28(%ebp),%eax
    58c0:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    58c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    58cf:	01 d0                	add    %edx,%eax
    58d1:	8b 00                	mov    (%eax),%eax
    58d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58dd:	eb 56                	jmp    5935 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    58df:	8b 55 d8             	mov    -0x28(%ebp),%edx
    58e2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    58e5:	01 d0                	add    %edx,%eax
    58e7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58ea:	77 0c                	ja     58f8 <getTreeInflateDynamic+0x2fa>
    58ec:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    58f3:	e9 71 01 00 00       	jmp    5a69 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    58f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58fb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    58fe:	73 16                	jae    5916 <getTreeInflateDynamic+0x318>
    5900:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5903:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    590a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    590d:	01 c2                	add    %eax,%edx
    590f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5912:	89 02                	mov    %eax,(%edx)
    5914:	eb 17                	jmp    592d <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5916:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5919:	2b 45 d8             	sub    -0x28(%ebp),%eax
    591c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5923:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5926:	01 c2                	add    %eax,%edx
    5928:	8b 45 e0             	mov    -0x20(%ebp),%eax
    592b:	89 02                	mov    %eax,(%edx)
          ++i;
    592d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5931:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5935:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5938:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    593b:	72 a2                	jb     58df <getTreeInflateDynamic+0x2e1>
    593d:	e9 27 01 00 00       	jmp    5a69 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5942:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5946:	0f 85 88 00 00 00    	jne    59d4 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    594c:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5953:	83 ec 08             	sub    $0x8,%esp
    5956:	6a 03                	push   $0x3
    5958:	ff 75 10             	pushl  0x10(%ebp)
    595b:	e8 de e7 ff ff       	call   413e <readBits>
    5960:	83 c4 10             	add    $0x10,%esp
    5963:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5966:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    596d:	eb 58                	jmp    59c7 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    596f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5972:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5975:	01 d0                	add    %edx,%eax
    5977:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    597a:	77 0c                	ja     5988 <getTreeInflateDynamic+0x38a>
    597c:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5983:	e9 e1 00 00 00       	jmp    5a69 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5988:	8b 45 ec             	mov    -0x14(%ebp),%eax
    598b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    598e:	73 17                	jae    59a7 <getTreeInflateDynamic+0x3a9>
    5990:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5993:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    599a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    599d:	01 d0                	add    %edx,%eax
    599f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    59a5:	eb 18                	jmp    59bf <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    59a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59aa:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59b7:	01 d0                	add    %edx,%eax
    59b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    59bf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59c3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    59c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    59ca:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    59cd:	72 a0                	jb     596f <getTreeInflateDynamic+0x371>
    59cf:	e9 95 00 00 00       	jmp    5a69 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    59d4:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    59d8:	0f 85 82 00 00 00    	jne    5a60 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    59de:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    59e5:	83 ec 08             	sub    $0x8,%esp
    59e8:	6a 07                	push   $0x7
    59ea:	ff 75 10             	pushl  0x10(%ebp)
    59ed:	e8 4c e7 ff ff       	call   413e <readBits>
    59f2:	83 c4 10             	add    $0x10,%esp
    59f5:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    59ff:	eb 55                	jmp    5a56 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5a01:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a04:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a07:	01 d0                	add    %edx,%eax
    5a09:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a0c:	77 09                	ja     5a17 <getTreeInflateDynamic+0x419>
    5a0e:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5a15:	eb 52                	jmp    5a69 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5a17:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a1a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5a1d:	73 17                	jae    5a36 <getTreeInflateDynamic+0x438>
    5a1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a22:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a29:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a2c:	01 d0                	add    %edx,%eax
    5a2e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5a34:	eb 18                	jmp    5a4e <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5a36:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a39:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5a3c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5a46:	01 d0                	add    %edx,%eax
    5a48:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5a4e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5a52:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5a59:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5a5c:	72 a3                	jb     5a01 <getTreeInflateDynamic+0x403>
    5a5e:	eb 09                	jmp    5a69 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5a60:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5a67:	eb 2a                	jmp    5a93 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5a69:	8b 45 10             	mov    0x10(%ebp),%eax
    5a6c:	8b 50 0c             	mov    0xc(%eax),%edx
    5a6f:	8b 45 10             	mov    0x10(%ebp),%eax
    5a72:	8b 40 08             	mov    0x8(%eax),%eax
    5a75:	39 c2                	cmp    %eax,%edx
    5a77:	7e 09                	jle    5a82 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5a79:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5a80:	eb 11                	jmp    5a93 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5a82:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a85:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a88:	01 d0                	add    %edx,%eax
    5a8a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a8d:	0f 87 62 fd ff ff    	ja     57f5 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a97:	75 4f                	jne    5ae8 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5a99:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a9c:	05 00 04 00 00       	add    $0x400,%eax
    5aa1:	8b 00                	mov    (%eax),%eax
    5aa3:	85 c0                	test   %eax,%eax
    5aa5:	75 09                	jne    5ab0 <getTreeInflateDynamic+0x4b2>
    5aa7:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5aae:	eb 3c                	jmp    5aec <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5ab0:	6a 0f                	push   $0xf
    5ab2:	68 20 01 00 00       	push   $0x120
    5ab7:	ff 75 e8             	pushl  -0x18(%ebp)
    5aba:	ff 75 08             	pushl  0x8(%ebp)
    5abd:	e8 32 ef ff ff       	call   49f4 <HuffmanTree_makeFromLengths>
    5ac2:	83 c4 10             	add    $0x10,%esp
    5ac5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5ac8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5acc:	75 1d                	jne    5aeb <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5ace:	6a 0f                	push   $0xf
    5ad0:	6a 20                	push   $0x20
    5ad2:	ff 75 e4             	pushl  -0x1c(%ebp)
    5ad5:	ff 75 0c             	pushl  0xc(%ebp)
    5ad8:	e8 17 ef ff ff       	call   49f4 <HuffmanTree_makeFromLengths>
    5add:	83 c4 10             	add    $0x10,%esp
    5ae0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5ae3:	eb 07                	jmp    5aec <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5ae5:	90                   	nop
    5ae6:	eb 04                	jmp    5aec <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5ae8:	90                   	nop
    5ae9:	eb 01                	jmp    5aec <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5aeb:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5aec:	83 ec 0c             	sub    $0xc,%esp
    5aef:	ff 75 dc             	pushl  -0x24(%ebp)
    5af2:	e8 dc d8 ff ff       	call   33d3 <lodepng_free>
    5af7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5afa:	83 ec 0c             	sub    $0xc,%esp
    5afd:	ff 75 e8             	pushl  -0x18(%ebp)
    5b00:	e8 ce d8 ff ff       	call   33d3 <lodepng_free>
    5b05:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5b08:	83 ec 0c             	sub    $0xc,%esp
    5b0b:	ff 75 e4             	pushl  -0x1c(%ebp)
    5b0e:	e8 c0 d8 ff ff       	call   33d3 <lodepng_free>
    5b13:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5b16:	83 ec 0c             	sub    $0xc,%esp
    5b19:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5b1c:	50                   	push   %eax
    5b1d:	e8 b1 e7 ff ff       	call   42d3 <HuffmanTree_cleanup>
    5b22:	83 c4 10             	add    $0x10,%esp

  return error;
    5b25:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5b28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5b2b:	c9                   	leave  
    5b2c:	c3                   	ret    

00005b2d <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5b2d:	55                   	push   %ebp
    5b2e:	89 e5                	mov    %esp,%ebp
    5b30:	53                   	push   %ebx
    5b31:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5b34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5b3b:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b3e:	50                   	push   %eax
    5b3f:	e8 62 e7 ff ff       	call   42a6 <HuffmanTree_init>
    5b44:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5b47:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b4a:	50                   	push   %eax
    5b4b:	e8 56 e7 ff ff       	call   42a6 <HuffmanTree_init>
    5b50:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5b53:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5b57:	75 1b                	jne    5b74 <inflateHuffmanBlock+0x47>
    5b59:	83 ec 08             	sub    $0x8,%esp
    5b5c:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b5f:	50                   	push   %eax
    5b60:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b63:	50                   	push   %eax
    5b64:	e8 63 fa ff ff       	call   55cc <getTreeInflateFixed>
    5b69:	83 c4 10             	add    $0x10,%esp
    5b6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5b6f:	e9 9a 02 00 00       	jmp    5e0e <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5b74:	83 ec 04             	sub    $0x4,%esp
    5b77:	ff 75 0c             	pushl  0xc(%ebp)
    5b7a:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b7d:	50                   	push   %eax
    5b7e:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b81:	50                   	push   %eax
    5b82:	e8 77 fa ff ff       	call   55fe <getTreeInflateDynamic>
    5b87:	83 c4 10             	add    $0x10,%esp
    5b8a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5b8d:	e9 7c 02 00 00       	jmp    5e0e <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5b92:	83 ec 08             	sub    $0x8,%esp
    5b95:	6a 14                	push   $0x14
    5b97:	ff 75 0c             	pushl  0xc(%ebp)
    5b9a:	e8 ef e1 ff ff       	call   3d8e <ensureBits25>
    5b9f:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5ba2:	83 ec 08             	sub    $0x8,%esp
    5ba5:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ba8:	50                   	push   %eax
    5ba9:	ff 75 0c             	pushl  0xc(%ebp)
    5bac:	e8 5a f9 ff ff       	call   550b <huffmanDecodeSymbol>
    5bb1:	83 c4 10             	add    $0x10,%esp
    5bb4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5bb7:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5bbe:	77 42                	ja     5c02 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5bc0:	8b 45 08             	mov    0x8(%ebp),%eax
    5bc3:	8b 40 04             	mov    0x4(%eax),%eax
    5bc6:	83 c0 01             	add    $0x1,%eax
    5bc9:	83 ec 08             	sub    $0x8,%esp
    5bcc:	50                   	push   %eax
    5bcd:	ff 75 08             	pushl  0x8(%ebp)
    5bd0:	e8 37 da ff ff       	call   360c <ucvector_resize>
    5bd5:	83 c4 10             	add    $0x10,%esp
    5bd8:	85 c0                	test   %eax,%eax
    5bda:	75 0c                	jne    5be8 <inflateHuffmanBlock+0xbb>
    5bdc:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5be3:	e9 33 02 00 00       	jmp    5e1b <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5be8:	8b 45 08             	mov    0x8(%ebp),%eax
    5beb:	8b 10                	mov    (%eax),%edx
    5bed:	8b 45 08             	mov    0x8(%ebp),%eax
    5bf0:	8b 40 04             	mov    0x4(%eax),%eax
    5bf3:	83 e8 01             	sub    $0x1,%eax
    5bf6:	01 d0                	add    %edx,%eax
    5bf8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5bfb:	88 10                	mov    %dl,(%eax)
    5bfd:	e9 d9 01 00 00       	jmp    5ddb <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5c02:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5c09:	0f 86 ba 01 00 00    	jbe    5dc9 <inflateHuffmanBlock+0x29c>
    5c0f:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5c16:	0f 87 ad 01 00 00    	ja     5dc9 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5c1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c1f:	2d 01 01 00 00       	sub    $0x101,%eax
    5c24:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    5c2b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5c2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c31:	2d 01 01 00 00       	sub    $0x101,%eax
    5c36:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    5c3d:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5c40:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5c44:	74 1c                	je     5c62 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5c46:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5c49:	83 ec 08             	sub    $0x8,%esp
    5c4c:	50                   	push   %eax
    5c4d:	ff 75 0c             	pushl  0xc(%ebp)
    5c50:	e8 e9 e4 ff ff       	call   413e <readBits>
    5c55:	83 c4 10             	add    $0x10,%esp
    5c58:	89 c2                	mov    %eax,%edx
    5c5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c5d:	01 d0                	add    %edx,%eax
    5c5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5c62:	83 ec 08             	sub    $0x8,%esp
    5c65:	6a 1c                	push   $0x1c
    5c67:	ff 75 0c             	pushl  0xc(%ebp)
    5c6a:	e8 98 e2 ff ff       	call   3f07 <ensureBits32>
    5c6f:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5c72:	83 ec 08             	sub    $0x8,%esp
    5c75:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5c78:	50                   	push   %eax
    5c79:	ff 75 0c             	pushl  0xc(%ebp)
    5c7c:	e8 8a f8 ff ff       	call   550b <huffmanDecodeSymbol>
    5c81:	83 c4 10             	add    $0x10,%esp
    5c84:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5c87:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5c8b:	76 1e                	jbe    5cab <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5c8d:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5c91:	77 0c                	ja     5c9f <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5c93:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5c9a:	e9 7c 01 00 00       	jmp    5e1b <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5c9f:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5ca6:	e9 70 01 00 00       	jmp    5e1b <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5cab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5cae:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    5cb5:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5cb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5cbb:	8b 04 85 a0 9f 01 00 	mov    0x19fa0(,%eax,4),%eax
    5cc2:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5cc5:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5cc9:	74 15                	je     5ce0 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5ccb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5cce:	83 ec 08             	sub    $0x8,%esp
    5cd1:	50                   	push   %eax
    5cd2:	ff 75 0c             	pushl  0xc(%ebp)
    5cd5:	e8 64 e4 ff ff       	call   413e <readBits>
    5cda:	83 c4 10             	add    $0x10,%esp
    5cdd:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    5ce3:	8b 40 04             	mov    0x4(%eax),%eax
    5ce6:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5ce9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cec:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5cef:	76 0c                	jbe    5cfd <inflateHuffmanBlock+0x1d0>
    5cf1:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5cf8:	e9 1e 01 00 00       	jmp    5e1b <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d00:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5d03:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5d06:	8b 45 08             	mov    0x8(%ebp),%eax
    5d09:	8b 50 04             	mov    0x4(%eax),%edx
    5d0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d0f:	01 d0                	add    %edx,%eax
    5d11:	83 ec 08             	sub    $0x8,%esp
    5d14:	50                   	push   %eax
    5d15:	ff 75 08             	pushl  0x8(%ebp)
    5d18:	e8 ef d8 ff ff       	call   360c <ucvector_resize>
    5d1d:	83 c4 10             	add    $0x10,%esp
    5d20:	85 c0                	test   %eax,%eax
    5d22:	75 0c                	jne    5d30 <inflateHuffmanBlock+0x203>
    5d24:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5d2b:	e9 eb 00 00 00       	jmp    5e1b <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5d30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d33:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5d36:	73 6b                	jae    5da3 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5d38:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d3b:	8b 55 08             	mov    0x8(%ebp),%edx
    5d3e:	8b 0a                	mov    (%edx),%ecx
    5d40:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5d43:	01 d1                	add    %edx,%ecx
    5d45:	8b 55 08             	mov    0x8(%ebp),%edx
    5d48:	8b 1a                	mov    (%edx),%ebx
    5d4a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5d4d:	01 da                	add    %ebx,%edx
    5d4f:	83 ec 04             	sub    $0x4,%esp
    5d52:	50                   	push   %eax
    5d53:	51                   	push   %ecx
    5d54:	52                   	push   %edx
    5d55:	e8 96 d6 ff ff       	call   33f0 <lodepng_memcpy>
    5d5a:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5d5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5d60:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d63:	01 d0                	add    %edx,%eax
    5d65:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5d68:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d6b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5d6e:	eb 29                	jmp    5d99 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5d70:	8b 45 08             	mov    0x8(%ebp),%eax
    5d73:	8b 08                	mov    (%eax),%ecx
    5d75:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d78:	8d 50 01             	lea    0x1(%eax),%edx
    5d7b:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5d7e:	01 c1                	add    %eax,%ecx
    5d80:	8b 45 08             	mov    0x8(%ebp),%eax
    5d83:	8b 18                	mov    (%eax),%ebx
    5d85:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d88:	8d 50 01             	lea    0x1(%eax),%edx
    5d8b:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5d8e:	01 d8                	add    %ebx,%eax
    5d90:	0f b6 00             	movzbl (%eax),%eax
    5d93:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5d95:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5d99:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d9c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5d9f:	7c cf                	jl     5d70 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5da1:	eb 38                	jmp    5ddb <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5da3:	8b 45 08             	mov    0x8(%ebp),%eax
    5da6:	8b 10                	mov    (%eax),%edx
    5da8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5dab:	01 c2                	add    %eax,%edx
    5dad:	8b 45 08             	mov    0x8(%ebp),%eax
    5db0:	8b 08                	mov    (%eax),%ecx
    5db2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5db5:	01 c8                	add    %ecx,%eax
    5db7:	83 ec 04             	sub    $0x4,%esp
    5dba:	ff 75 e4             	pushl  -0x1c(%ebp)
    5dbd:	52                   	push   %edx
    5dbe:	50                   	push   %eax
    5dbf:	e8 2c d6 ff ff       	call   33f0 <lodepng_memcpy>
    5dc4:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5dc7:	eb 12                	jmp    5ddb <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5dc9:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5dd0:	74 48                	je     5e1a <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5dd2:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5dd9:	eb 40                	jmp    5e1b <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5ddb:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dde:	8b 50 0c             	mov    0xc(%eax),%edx
    5de1:	8b 45 0c             	mov    0xc(%ebp),%eax
    5de4:	8b 40 08             	mov    0x8(%eax),%eax
    5de7:	39 c2                	cmp    %eax,%edx
    5de9:	7e 09                	jle    5df4 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5deb:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5df2:	eb 27                	jmp    5e1b <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5df4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5df8:	74 14                	je     5e0e <inflateHuffmanBlock+0x2e1>
    5dfa:	8b 45 08             	mov    0x8(%ebp),%eax
    5dfd:	8b 40 04             	mov    0x4(%eax),%eax
    5e00:	3b 45 14             	cmp    0x14(%ebp),%eax
    5e03:	7e 09                	jle    5e0e <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5e05:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5e0c:	eb 0d                	jmp    5e1b <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5e0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5e12:	0f 84 7a fd ff ff    	je     5b92 <inflateHuffmanBlock+0x65>
    5e18:	eb 01                	jmp    5e1b <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5e1a:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5e1b:	83 ec 0c             	sub    $0xc,%esp
    5e1e:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5e21:	50                   	push   %eax
    5e22:	e8 ac e4 ff ff       	call   42d3 <HuffmanTree_cleanup>
    5e27:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5e2a:	83 ec 0c             	sub    $0xc,%esp
    5e2d:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5e30:	50                   	push   %eax
    5e31:	e8 9d e4 ff ff       	call   42d3 <HuffmanTree_cleanup>
    5e36:	83 c4 10             	add    $0x10,%esp

  return error;
    5e39:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5e3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5e3f:	c9                   	leave  
    5e40:	c3                   	ret    

00005e41 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5e41:	55                   	push   %ebp
    5e42:	89 e5                	mov    %esp,%ebp
    5e44:	53                   	push   %ebx
    5e45:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5e48:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e4b:	8b 40 04             	mov    0x4(%eax),%eax
    5e4e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5e51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5e58:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e5b:	8b 40 0c             	mov    0xc(%eax),%eax
    5e5e:	83 c0 07             	add    $0x7,%eax
    5e61:	c1 e8 03             	shr    $0x3,%eax
    5e64:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5e67:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e6a:	83 c0 04             	add    $0x4,%eax
    5e6d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5e70:	7c 0a                	jl     5e7c <inflateNoCompression+0x3b>
    5e72:	b8 34 00 00 00       	mov    $0x34,%eax
    5e77:	e9 01 01 00 00       	jmp    5f7d <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5e7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e7f:	8b 10                	mov    (%eax),%edx
    5e81:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e84:	01 d0                	add    %edx,%eax
    5e86:	0f b6 00             	movzbl (%eax),%eax
    5e89:	0f b6 d0             	movzbl %al,%edx
    5e8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e8f:	8b 00                	mov    (%eax),%eax
    5e91:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e94:	83 c1 01             	add    $0x1,%ecx
    5e97:	01 c8                	add    %ecx,%eax
    5e99:	0f b6 00             	movzbl (%eax),%eax
    5e9c:	0f b6 c0             	movzbl %al,%eax
    5e9f:	c1 e0 08             	shl    $0x8,%eax
    5ea2:	01 d0                	add    %edx,%eax
    5ea4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5ea7:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5eab:	8b 45 0c             	mov    0xc(%ebp),%eax
    5eae:	8b 10                	mov    (%eax),%edx
    5eb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5eb3:	01 d0                	add    %edx,%eax
    5eb5:	0f b6 00             	movzbl (%eax),%eax
    5eb8:	0f b6 d0             	movzbl %al,%edx
    5ebb:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ebe:	8b 00                	mov    (%eax),%eax
    5ec0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5ec3:	83 c1 01             	add    $0x1,%ecx
    5ec6:	01 c8                	add    %ecx,%eax
    5ec8:	0f b6 00             	movzbl (%eax),%eax
    5ecb:	0f b6 c0             	movzbl %al,%eax
    5ece:	c1 e0 08             	shl    $0x8,%eax
    5ed1:	01 d0                	add    %edx,%eax
    5ed3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5ed6:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5eda:	8b 45 10             	mov    0x10(%ebp),%eax
    5edd:	8b 40 04             	mov    0x4(%eax),%eax
    5ee0:	85 c0                	test   %eax,%eax
    5ee2:	75 19                	jne    5efd <inflateNoCompression+0xbc>
    5ee4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5ee7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5eea:	01 d0                	add    %edx,%eax
    5eec:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5ef1:	74 0a                	je     5efd <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5ef3:	b8 15 00 00 00       	mov    $0x15,%eax
    5ef8:	e9 80 00 00 00       	jmp    5f7d <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5efd:	8b 45 08             	mov    0x8(%ebp),%eax
    5f00:	8b 40 04             	mov    0x4(%eax),%eax
    5f03:	89 c2                	mov    %eax,%edx
    5f05:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f08:	01 d0                	add    %edx,%eax
    5f0a:	50                   	push   %eax
    5f0b:	ff 75 08             	pushl  0x8(%ebp)
    5f0e:	e8 f9 d6 ff ff       	call   360c <ucvector_resize>
    5f13:	83 c4 08             	add    $0x8,%esp
    5f16:	85 c0                	test   %eax,%eax
    5f18:	75 07                	jne    5f21 <inflateNoCompression+0xe0>
    5f1a:	b8 53 00 00 00       	mov    $0x53,%eax
    5f1f:	eb 5c                	jmp    5f7d <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5f21:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f24:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f27:	01 c2                	add    %eax,%edx
    5f29:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5f2c:	39 c2                	cmp    %eax,%edx
    5f2e:	76 07                	jbe    5f37 <inflateNoCompression+0xf6>
    5f30:	b8 17 00 00 00       	mov    $0x17,%eax
    5f35:	eb 46                	jmp    5f7d <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5f37:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f3a:	8b 55 0c             	mov    0xc(%ebp),%edx
    5f3d:	8b 0a                	mov    (%edx),%ecx
    5f3f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f42:	01 d1                	add    %edx,%ecx
    5f44:	8b 55 08             	mov    0x8(%ebp),%edx
    5f47:	8b 1a                	mov    (%edx),%ebx
    5f49:	8b 55 08             	mov    0x8(%ebp),%edx
    5f4c:	8b 52 04             	mov    0x4(%edx),%edx
    5f4f:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5f52:	01 da                	add    %ebx,%edx
    5f54:	50                   	push   %eax
    5f55:	51                   	push   %ecx
    5f56:	52                   	push   %edx
    5f57:	e8 94 d4 ff ff       	call   33f0 <lodepng_memcpy>
    5f5c:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5f5f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f62:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f65:	01 d0                	add    %edx,%eax
    5f67:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5f6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f6d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5f74:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f77:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5f7d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5f80:	c9                   	leave  
    5f81:	c3                   	ret    

00005f82 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5f82:	55                   	push   %ebp
    5f83:	89 e5                	mov    %esp,%ebp
    5f85:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5f88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5f8f:	ff 75 10             	pushl  0x10(%ebp)
    5f92:	ff 75 0c             	pushl  0xc(%ebp)
    5f95:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f98:	50                   	push   %eax
    5f99:	e8 77 db ff ff       	call   3b15 <LodePNGBitReader_init>
    5f9e:	83 c4 0c             	add    $0xc,%esp
    5fa1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5fa4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fa8:	0f 84 b9 00 00 00    	je     6067 <lodepng_inflatev+0xe5>
    5fae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fb1:	e9 c1 00 00 00       	jmp    6077 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    5fb6:	6a 03                	push   $0x3
    5fb8:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fbb:	50                   	push   %eax
    5fbc:	e8 c5 db ff ff       	call   3b86 <ensureBits9>
    5fc1:	83 c4 08             	add    $0x8,%esp
    5fc4:	85 c0                	test   %eax,%eax
    5fc6:	75 0a                	jne    5fd2 <lodepng_inflatev+0x50>
    5fc8:	b8 34 00 00 00       	mov    $0x34,%eax
    5fcd:	e9 a5 00 00 00       	jmp    6077 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    5fd2:	6a 01                	push   $0x1
    5fd4:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fd7:	50                   	push   %eax
    5fd8:	e8 61 e1 ff ff       	call   413e <readBits>
    5fdd:	83 c4 08             	add    $0x8,%esp
    5fe0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    5fe3:	6a 02                	push   $0x2
    5fe5:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fe8:	50                   	push   %eax
    5fe9:	e8 50 e1 ff ff       	call   413e <readBits>
    5fee:	83 c4 08             	add    $0x8,%esp
    5ff1:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    5ff4:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    5ff8:	75 07                	jne    6001 <lodepng_inflatev+0x7f>
    5ffa:	b8 14 00 00 00       	mov    $0x14,%eax
    5fff:	eb 76                	jmp    6077 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    6001:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6005:	75 17                	jne    601e <lodepng_inflatev+0x9c>
    6007:	ff 75 14             	pushl  0x14(%ebp)
    600a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    600d:	50                   	push   %eax
    600e:	ff 75 08             	pushl  0x8(%ebp)
    6011:	e8 2b fe ff ff       	call   5e41 <inflateNoCompression>
    6016:	83 c4 0c             	add    $0xc,%esp
    6019:	89 45 f0             	mov    %eax,-0x10(%ebp)
    601c:	eb 1c                	jmp    603a <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    601e:	8b 45 14             	mov    0x14(%ebp),%eax
    6021:	8b 40 08             	mov    0x8(%eax),%eax
    6024:	50                   	push   %eax
    6025:	ff 75 ec             	pushl  -0x14(%ebp)
    6028:	8d 45 d8             	lea    -0x28(%ebp),%eax
    602b:	50                   	push   %eax
    602c:	ff 75 08             	pushl  0x8(%ebp)
    602f:	e8 f9 fa ff ff       	call   5b2d <inflateHuffmanBlock>
    6034:	83 c4 10             	add    $0x10,%esp
    6037:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    603a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    603e:	75 21                	jne    6061 <lodepng_inflatev+0xdf>
    6040:	8b 45 14             	mov    0x14(%ebp),%eax
    6043:	8b 40 08             	mov    0x8(%eax),%eax
    6046:	85 c0                	test   %eax,%eax
    6048:	74 17                	je     6061 <lodepng_inflatev+0xdf>
    604a:	8b 45 08             	mov    0x8(%ebp),%eax
    604d:	8b 50 04             	mov    0x4(%eax),%edx
    6050:	8b 45 14             	mov    0x14(%ebp),%eax
    6053:	8b 40 08             	mov    0x8(%eax),%eax
    6056:	39 c2                	cmp    %eax,%edx
    6058:	7e 07                	jle    6061 <lodepng_inflatev+0xdf>
    605a:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    6061:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6065:	75 0c                	jne    6073 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    6067:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    606b:	0f 84 45 ff ff ff    	je     5fb6 <lodepng_inflatev+0x34>
    6071:	eb 01                	jmp    6074 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    6073:	90                   	nop
  }

  return error;
    6074:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6077:	c9                   	leave  
    6078:	c3                   	ret    

00006079 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    6079:	55                   	push   %ebp
    607a:	89 e5                	mov    %esp,%ebp
    607c:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    607f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6082:	8b 08                	mov    (%eax),%ecx
    6084:	8b 45 08             	mov    0x8(%ebp),%eax
    6087:	8b 10                	mov    (%eax),%edx
    6089:	8d 45 e8             	lea    -0x18(%ebp),%eax
    608c:	51                   	push   %ecx
    608d:	52                   	push   %edx
    608e:	50                   	push   %eax
    608f:	e8 df d5 ff ff       	call   3673 <ucvector_init>
    6094:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    6097:	ff 75 18             	pushl  0x18(%ebp)
    609a:	ff 75 14             	pushl  0x14(%ebp)
    609d:	ff 75 10             	pushl  0x10(%ebp)
    60a0:	8d 45 e8             	lea    -0x18(%ebp),%eax
    60a3:	50                   	push   %eax
    60a4:	e8 d9 fe ff ff       	call   5f82 <lodepng_inflatev>
    60a9:	83 c4 10             	add    $0x10,%esp
    60ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    60af:	8b 55 e8             	mov    -0x18(%ebp),%edx
    60b2:	8b 45 08             	mov    0x8(%ebp),%eax
    60b5:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    60b7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    60ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    60bd:	89 10                	mov    %edx,(%eax)
  return error;
    60bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    60c2:	c9                   	leave  
    60c3:	c3                   	ret    

000060c4 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    60c4:	55                   	push   %ebp
    60c5:	89 e5                	mov    %esp,%ebp
    60c7:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    60ca:	8b 45 14             	mov    0x14(%ebp),%eax
    60cd:	8b 40 10             	mov    0x10(%eax),%eax
    60d0:	85 c0                	test   %eax,%eax
    60d2:	74 64                	je     6138 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    60d4:	8b 45 14             	mov    0x14(%ebp),%eax
    60d7:	8b 40 10             	mov    0x10(%eax),%eax
    60da:	8b 55 08             	mov    0x8(%ebp),%edx
    60dd:	8d 4a 04             	lea    0x4(%edx),%ecx
    60e0:	8b 55 08             	mov    0x8(%ebp),%edx
    60e3:	83 ec 0c             	sub    $0xc,%esp
    60e6:	ff 75 14             	pushl  0x14(%ebp)
    60e9:	ff 75 10             	pushl  0x10(%ebp)
    60ec:	ff 75 0c             	pushl  0xc(%ebp)
    60ef:	51                   	push   %ecx
    60f0:	52                   	push   %edx
    60f1:	ff d0                	call   *%eax
    60f3:	83 c4 20             	add    $0x20,%esp
    60f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    60f9:	8b 45 08             	mov    0x8(%ebp),%eax
    60fc:	8b 50 04             	mov    0x4(%eax),%edx
    60ff:	8b 45 08             	mov    0x8(%ebp),%eax
    6102:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6105:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6109:	74 28                	je     6133 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    610b:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6112:	8b 45 14             	mov    0x14(%ebp),%eax
    6115:	8b 40 08             	mov    0x8(%eax),%eax
    6118:	85 c0                	test   %eax,%eax
    611a:	74 17                	je     6133 <inflatev+0x6f>
    611c:	8b 45 08             	mov    0x8(%ebp),%eax
    611f:	8b 50 04             	mov    0x4(%eax),%edx
    6122:	8b 45 14             	mov    0x14(%ebp),%eax
    6125:	8b 40 08             	mov    0x8(%eax),%eax
    6128:	39 c2                	cmp    %eax,%edx
    612a:	7e 07                	jle    6133 <inflatev+0x6f>
    612c:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6133:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6136:	eb 14                	jmp    614c <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    6138:	ff 75 14             	pushl  0x14(%ebp)
    613b:	ff 75 10             	pushl  0x10(%ebp)
    613e:	ff 75 0c             	pushl  0xc(%ebp)
    6141:	ff 75 08             	pushl  0x8(%ebp)
    6144:	e8 39 fe ff ff       	call   5f82 <lodepng_inflatev>
    6149:	83 c4 10             	add    $0x10,%esp
  }
}
    614c:	c9                   	leave  
    614d:	c3                   	ret    

0000614e <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    614e:	55                   	push   %ebp
    614f:	89 e5                	mov    %esp,%ebp
    6151:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    6154:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    615b:	8b 45 0c             	mov    0xc(%ebp),%eax
    615e:	83 e8 01             	sub    $0x1,%eax
    6161:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    6164:	eb 39                	jmp    619f <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    6166:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6169:	8b 45 f8             	mov    -0x8(%ebp),%eax
    616c:	01 d0                	add    %edx,%eax
    616e:	d1 f8                	sar    %eax
    6170:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    6173:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6176:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    617d:	8b 45 08             	mov    0x8(%ebp),%eax
    6180:	01 d0                	add    %edx,%eax
    6182:	8b 10                	mov    (%eax),%edx
    6184:	8b 45 10             	mov    0x10(%ebp),%eax
    6187:	39 c2                	cmp    %eax,%edx
    6189:	72 0b                	jb     6196 <searchCodeIndex+0x48>
    618b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    618e:	83 e8 01             	sub    $0x1,%eax
    6191:	89 45 f8             	mov    %eax,-0x8(%ebp)
    6194:	eb 09                	jmp    619f <searchCodeIndex+0x51>
    else left = mid + 1;
    6196:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6199:	83 c0 01             	add    $0x1,%eax
    619c:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    619f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61a2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    61a5:	7e bf                	jle    6166 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    61a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61aa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    61ad:	7d 18                	jge    61c7 <searchCodeIndex+0x79>
    61af:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61b2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    61b9:	8b 45 08             	mov    0x8(%ebp),%eax
    61bc:	01 d0                	add    %edx,%eax
    61be:	8b 10                	mov    (%eax),%edx
    61c0:	8b 45 10             	mov    0x10(%ebp),%eax
    61c3:	39 c2                	cmp    %eax,%edx
    61c5:	76 04                	jbe    61cb <searchCodeIndex+0x7d>
    61c7:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    61cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    61ce:	c9                   	leave  
    61cf:	c3                   	ret    

000061d0 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    61d0:	55                   	push   %ebp
    61d1:	89 e5                	mov    %esp,%ebp
    61d3:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    61d6:	ff 75 0c             	pushl  0xc(%ebp)
    61d9:	6a 1d                	push   $0x1d
    61db:	68 20 9e 01 00       	push   $0x19e20
    61e0:	e8 69 ff ff ff       	call   614e <searchCodeIndex>
    61e5:	83 c4 0c             	add    $0xc,%esp
    61e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    61eb:	8b 55 0c             	mov    0xc(%ebp),%edx
    61ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61f1:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    61f8:	29 c2                	sub    %eax,%edx
    61fa:	89 d0                	mov    %edx,%eax
    61fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    61ff:	ff 75 10             	pushl  0x10(%ebp)
    6202:	6a 1e                	push   $0x1e
    6204:	68 20 9f 01 00       	push   $0x19f20
    6209:	e8 40 ff ff ff       	call   614e <searchCodeIndex>
    620e:	83 c4 0c             	add    $0xc,%esp
    6211:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6214:	8b 55 10             	mov    0x10(%ebp),%edx
    6217:	8b 45 f4             	mov    -0xc(%ebp),%eax
    621a:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    6221:	29 c2                	sub    %eax,%edx
    6223:	89 d0                	mov    %edx,%eax
    6225:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    6228:	8b 45 08             	mov    0x8(%ebp),%eax
    622b:	8b 40 04             	mov    0x4(%eax),%eax
    622e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6231:	8b 45 08             	mov    0x8(%ebp),%eax
    6234:	8b 40 04             	mov    0x4(%eax),%eax
    6237:	83 c0 04             	add    $0x4,%eax
    623a:	50                   	push   %eax
    623b:	ff 75 08             	pushl  0x8(%ebp)
    623e:	e8 f0 d2 ff ff       	call   3533 <uivector_resize>
    6243:	83 c4 08             	add    $0x8,%esp
    6246:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    6249:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    624d:	74 57                	je     62a6 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    624f:	8b 45 08             	mov    0x8(%ebp),%eax
    6252:	8b 00                	mov    (%eax),%eax
    6254:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6257:	c1 e2 02             	shl    $0x2,%edx
    625a:	01 d0                	add    %edx,%eax
    625c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    625f:	81 c2 01 01 00 00    	add    $0x101,%edx
    6265:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    6267:	8b 45 08             	mov    0x8(%ebp),%eax
    626a:	8b 00                	mov    (%eax),%eax
    626c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    626f:	83 c2 01             	add    $0x1,%edx
    6272:	c1 e2 02             	shl    $0x2,%edx
    6275:	01 c2                	add    %eax,%edx
    6277:	8b 45 f8             	mov    -0x8(%ebp),%eax
    627a:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    627c:	8b 45 08             	mov    0x8(%ebp),%eax
    627f:	8b 00                	mov    (%eax),%eax
    6281:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6284:	83 c2 02             	add    $0x2,%edx
    6287:	c1 e2 02             	shl    $0x2,%edx
    628a:	01 c2                	add    %eax,%edx
    628c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    628f:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    6291:	8b 45 08             	mov    0x8(%ebp),%eax
    6294:	8b 00                	mov    (%eax),%eax
    6296:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6299:	83 c2 03             	add    $0x3,%edx
    629c:	c1 e2 02             	shl    $0x2,%edx
    629f:	01 c2                	add    %eax,%edx
    62a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    62a4:	89 02                	mov    %eax,(%edx)
  }
}
    62a6:	90                   	nop
    62a7:	c9                   	leave  
    62a8:	c3                   	ret    

000062a9 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    62a9:	55                   	push   %ebp
    62aa:	89 e5                	mov    %esp,%ebp
    62ac:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    62af:	b8 00 00 01 00       	mov    $0x10000,%eax
    62b4:	c1 e0 02             	shl    $0x2,%eax
    62b7:	83 ec 0c             	sub    $0xc,%esp
    62ba:	50                   	push   %eax
    62bb:	e8 f2 d0 ff ff       	call   33b2 <lodepng_malloc>
    62c0:	83 c4 10             	add    $0x10,%esp
    62c3:	89 c2                	mov    %eax,%edx
    62c5:	8b 45 08             	mov    0x8(%ebp),%eax
    62c8:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    62ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    62cd:	c1 e0 02             	shl    $0x2,%eax
    62d0:	83 ec 0c             	sub    $0xc,%esp
    62d3:	50                   	push   %eax
    62d4:	e8 d9 d0 ff ff       	call   33b2 <lodepng_malloc>
    62d9:	83 c4 10             	add    $0x10,%esp
    62dc:	89 c2                	mov    %eax,%edx
    62de:	8b 45 08             	mov    0x8(%ebp),%eax
    62e1:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    62e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    62e7:	01 c0                	add    %eax,%eax
    62e9:	83 ec 0c             	sub    $0xc,%esp
    62ec:	50                   	push   %eax
    62ed:	e8 c0 d0 ff ff       	call   33b2 <lodepng_malloc>
    62f2:	83 c4 10             	add    $0x10,%esp
    62f5:	89 c2                	mov    %eax,%edx
    62f7:	8b 45 08             	mov    0x8(%ebp),%eax
    62fa:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    62fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    6300:	01 c0                	add    %eax,%eax
    6302:	83 ec 0c             	sub    $0xc,%esp
    6305:	50                   	push   %eax
    6306:	e8 a7 d0 ff ff       	call   33b2 <lodepng_malloc>
    630b:	83 c4 10             	add    $0x10,%esp
    630e:	89 c2                	mov    %eax,%edx
    6310:	8b 45 08             	mov    0x8(%ebp),%eax
    6313:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6316:	b8 02 01 00 00       	mov    $0x102,%eax
    631b:	83 c0 01             	add    $0x1,%eax
    631e:	c1 e0 02             	shl    $0x2,%eax
    6321:	83 ec 0c             	sub    $0xc,%esp
    6324:	50                   	push   %eax
    6325:	e8 88 d0 ff ff       	call   33b2 <lodepng_malloc>
    632a:	83 c4 10             	add    $0x10,%esp
    632d:	89 c2                	mov    %eax,%edx
    632f:	8b 45 08             	mov    0x8(%ebp),%eax
    6332:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6335:	8b 45 0c             	mov    0xc(%ebp),%eax
    6338:	01 c0                	add    %eax,%eax
    633a:	83 ec 0c             	sub    $0xc,%esp
    633d:	50                   	push   %eax
    633e:	e8 6f d0 ff ff       	call   33b2 <lodepng_malloc>
    6343:	83 c4 10             	add    $0x10,%esp
    6346:	89 c2                	mov    %eax,%edx
    6348:	8b 45 08             	mov    0x8(%ebp),%eax
    634b:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    634e:	8b 45 08             	mov    0x8(%ebp),%eax
    6351:	8b 00                	mov    (%eax),%eax
    6353:	85 c0                	test   %eax,%eax
    6355:	74 32                	je     6389 <hash_init+0xe0>
    6357:	8b 45 08             	mov    0x8(%ebp),%eax
    635a:	8b 40 04             	mov    0x4(%eax),%eax
    635d:	85 c0                	test   %eax,%eax
    635f:	74 28                	je     6389 <hash_init+0xe0>
    6361:	8b 45 08             	mov    0x8(%ebp),%eax
    6364:	8b 40 08             	mov    0x8(%eax),%eax
    6367:	85 c0                	test   %eax,%eax
    6369:	74 1e                	je     6389 <hash_init+0xe0>
    636b:	8b 45 08             	mov    0x8(%ebp),%eax
    636e:	8b 40 0c             	mov    0xc(%eax),%eax
    6371:	85 c0                	test   %eax,%eax
    6373:	74 14                	je     6389 <hash_init+0xe0>
    6375:	8b 45 08             	mov    0x8(%ebp),%eax
    6378:	8b 40 10             	mov    0x10(%eax),%eax
    637b:	85 c0                	test   %eax,%eax
    637d:	74 0a                	je     6389 <hash_init+0xe0>
    637f:	8b 45 08             	mov    0x8(%ebp),%eax
    6382:	8b 40 14             	mov    0x14(%eax),%eax
    6385:	85 c0                	test   %eax,%eax
    6387:	75 0a                	jne    6393 <hash_init+0xea>
    return 83; /*alloc fail*/
    6389:	b8 53 00 00 00       	mov    $0x53,%eax
    638e:	e9 d3 00 00 00       	jmp    6466 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    6393:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    639a:	eb 17                	jmp    63b3 <hash_init+0x10a>
    639c:	8b 45 08             	mov    0x8(%ebp),%eax
    639f:	8b 00                	mov    (%eax),%eax
    63a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63a4:	c1 e2 02             	shl    $0x2,%edx
    63a7:	01 d0                	add    %edx,%eax
    63a9:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    63af:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63b3:	b8 00 00 01 00       	mov    $0x10000,%eax
    63b8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    63bb:	75 df                	jne    639c <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    63bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63c4:	eb 18                	jmp    63de <hash_init+0x135>
    63c6:	8b 45 08             	mov    0x8(%ebp),%eax
    63c9:	8b 40 08             	mov    0x8(%eax),%eax
    63cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63cf:	c1 e2 02             	shl    $0x2,%edx
    63d2:	01 d0                	add    %edx,%eax
    63d4:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    63da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63e1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63e4:	75 e0                	jne    63c6 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    63e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63ed:	eb 17                	jmp    6406 <hash_init+0x15d>
    63ef:	8b 45 08             	mov    0x8(%ebp),%eax
    63f2:	8b 40 04             	mov    0x4(%eax),%eax
    63f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63f8:	01 d2                	add    %edx,%edx
    63fa:	01 d0                	add    %edx,%eax
    63fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63ff:	66 89 10             	mov    %dx,(%eax)
    6402:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6406:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6409:	3b 45 0c             	cmp    0xc(%ebp),%eax
    640c:	75 e1                	jne    63ef <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    640e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6415:	eb 18                	jmp    642f <hash_init+0x186>
    6417:	8b 45 08             	mov    0x8(%ebp),%eax
    641a:	8b 40 0c             	mov    0xc(%eax),%eax
    641d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6420:	c1 e2 02             	shl    $0x2,%edx
    6423:	01 d0                	add    %edx,%eax
    6425:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    642b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    642f:	b8 02 01 00 00       	mov    $0x102,%eax
    6434:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6437:	76 de                	jbe    6417 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    6439:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6440:	eb 17                	jmp    6459 <hash_init+0x1b0>
    6442:	8b 45 08             	mov    0x8(%ebp),%eax
    6445:	8b 40 10             	mov    0x10(%eax),%eax
    6448:	8b 55 f4             	mov    -0xc(%ebp),%edx
    644b:	01 d2                	add    %edx,%edx
    644d:	01 d0                	add    %edx,%eax
    644f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6452:	66 89 10             	mov    %dx,(%eax)
    6455:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6459:	8b 45 f4             	mov    -0xc(%ebp),%eax
    645c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    645f:	75 e1                	jne    6442 <hash_init+0x199>

  return 0;
    6461:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6466:	c9                   	leave  
    6467:	c3                   	ret    

00006468 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    6468:	55                   	push   %ebp
    6469:	89 e5                	mov    %esp,%ebp
    646b:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    646e:	8b 45 08             	mov    0x8(%ebp),%eax
    6471:	8b 00                	mov    (%eax),%eax
    6473:	83 ec 0c             	sub    $0xc,%esp
    6476:	50                   	push   %eax
    6477:	e8 57 cf ff ff       	call   33d3 <lodepng_free>
    647c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    647f:	8b 45 08             	mov    0x8(%ebp),%eax
    6482:	8b 40 08             	mov    0x8(%eax),%eax
    6485:	83 ec 0c             	sub    $0xc,%esp
    6488:	50                   	push   %eax
    6489:	e8 45 cf ff ff       	call   33d3 <lodepng_free>
    648e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    6491:	8b 45 08             	mov    0x8(%ebp),%eax
    6494:	8b 40 04             	mov    0x4(%eax),%eax
    6497:	83 ec 0c             	sub    $0xc,%esp
    649a:	50                   	push   %eax
    649b:	e8 33 cf ff ff       	call   33d3 <lodepng_free>
    64a0:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    64a3:	8b 45 08             	mov    0x8(%ebp),%eax
    64a6:	8b 40 14             	mov    0x14(%eax),%eax
    64a9:	83 ec 0c             	sub    $0xc,%esp
    64ac:	50                   	push   %eax
    64ad:	e8 21 cf ff ff       	call   33d3 <lodepng_free>
    64b2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    64b5:	8b 45 08             	mov    0x8(%ebp),%eax
    64b8:	8b 40 0c             	mov    0xc(%eax),%eax
    64bb:	83 ec 0c             	sub    $0xc,%esp
    64be:	50                   	push   %eax
    64bf:	e8 0f cf ff ff       	call   33d3 <lodepng_free>
    64c4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    64c7:	8b 45 08             	mov    0x8(%ebp),%eax
    64ca:	8b 40 10             	mov    0x10(%eax),%eax
    64cd:	83 ec 0c             	sub    $0xc,%esp
    64d0:	50                   	push   %eax
    64d1:	e8 fd ce ff ff       	call   33d3 <lodepng_free>
    64d6:	83 c4 10             	add    $0x10,%esp
}
    64d9:	90                   	nop
    64da:	c9                   	leave  
    64db:	c3                   	ret    

000064dc <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    64dc:	55                   	push   %ebp
    64dd:	89 e5                	mov    %esp,%ebp
    64df:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    64e2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    64e9:	8b 45 10             	mov    0x10(%ebp),%eax
    64ec:	83 c0 02             	add    $0x2,%eax
    64ef:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64f2:	7d 41                	jge    6535 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    64f4:	8b 55 10             	mov    0x10(%ebp),%edx
    64f7:	8b 45 08             	mov    0x8(%ebp),%eax
    64fa:	01 d0                	add    %edx,%eax
    64fc:	0f b6 00             	movzbl (%eax),%eax
    64ff:	0f b6 c0             	movzbl %al,%eax
    6502:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6505:	8b 45 10             	mov    0x10(%ebp),%eax
    6508:	8d 50 01             	lea    0x1(%eax),%edx
    650b:	8b 45 08             	mov    0x8(%ebp),%eax
    650e:	01 d0                	add    %edx,%eax
    6510:	0f b6 00             	movzbl (%eax),%eax
    6513:	0f b6 c0             	movzbl %al,%eax
    6516:	c1 e0 04             	shl    $0x4,%eax
    6519:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    651c:	8b 45 10             	mov    0x10(%ebp),%eax
    651f:	8d 50 02             	lea    0x2(%eax),%edx
    6522:	8b 45 08             	mov    0x8(%ebp),%eax
    6525:	01 d0                	add    %edx,%eax
    6527:	0f b6 00             	movzbl (%eax),%eax
    652a:	0f b6 c0             	movzbl %al,%eax
    652d:	c1 e0 08             	shl    $0x8,%eax
    6530:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6533:	eb 51                	jmp    6586 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    6535:	8b 45 10             	mov    0x10(%ebp),%eax
    6538:	3b 45 0c             	cmp    0xc(%ebp),%eax
    653b:	7c 07                	jl     6544 <getHash+0x68>
    653d:	b8 00 00 00 00       	mov    $0x0,%eax
    6542:	eb 4a                	jmp    658e <getHash+0xb2>
    amount = size - pos;
    6544:	8b 45 0c             	mov    0xc(%ebp),%eax
    6547:	2b 45 10             	sub    0x10(%ebp),%eax
    654a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    654d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6554:	eb 28                	jmp    657e <getHash+0xa2>
    6556:	8b 55 10             	mov    0x10(%ebp),%edx
    6559:	8b 45 f8             	mov    -0x8(%ebp),%eax
    655c:	01 d0                	add    %edx,%eax
    655e:	89 c2                	mov    %eax,%edx
    6560:	8b 45 08             	mov    0x8(%ebp),%eax
    6563:	01 d0                	add    %edx,%eax
    6565:	0f b6 00             	movzbl (%eax),%eax
    6568:	0f b6 d0             	movzbl %al,%edx
    656b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    656e:	c1 e0 03             	shl    $0x3,%eax
    6571:	89 c1                	mov    %eax,%ecx
    6573:	d3 e2                	shl    %cl,%edx
    6575:	89 d0                	mov    %edx,%eax
    6577:	31 45 fc             	xor    %eax,-0x4(%ebp)
    657a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    657e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6581:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    6584:	75 d0                	jne    6556 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    6586:	b8 ff ff 00 00       	mov    $0xffff,%eax
    658b:	23 45 fc             	and    -0x4(%ebp),%eax
}
    658e:	c9                   	leave  
    658f:	c3                   	ret    

00006590 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    6590:	55                   	push   %ebp
    6591:	89 e5                	mov    %esp,%ebp
    6593:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    6596:	8b 55 10             	mov    0x10(%ebp),%edx
    6599:	8b 45 08             	mov    0x8(%ebp),%eax
    659c:	01 d0                	add    %edx,%eax
    659e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    65a1:	b8 02 01 00 00       	mov    $0x102,%eax
    65a6:	89 c2                	mov    %eax,%edx
    65a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65ab:	01 d0                	add    %edx,%eax
    65ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    65b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    65b3:	8b 45 08             	mov    0x8(%ebp),%eax
    65b6:	01 d0                	add    %edx,%eax
    65b8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    65bb:	73 0b                	jae    65c8 <countZeros+0x38>
    65bd:	8b 55 0c             	mov    0xc(%ebp),%edx
    65c0:	8b 45 08             	mov    0x8(%ebp),%eax
    65c3:	01 d0                	add    %edx,%eax
    65c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    65c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65cb:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    65ce:	eb 04                	jmp    65d4 <countZeros+0x44>
    65d0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    65d4:	8b 45 08             	mov    0x8(%ebp),%eax
    65d7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    65da:	74 0a                	je     65e6 <countZeros+0x56>
    65dc:	8b 45 08             	mov    0x8(%ebp),%eax
    65df:	0f b6 00             	movzbl (%eax),%eax
    65e2:	84 c0                	test   %al,%al
    65e4:	74 ea                	je     65d0 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    65e6:	8b 55 08             	mov    0x8(%ebp),%edx
    65e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65ec:	29 c2                	sub    %eax,%edx
    65ee:	89 d0                	mov    %edx,%eax
}
    65f0:	c9                   	leave  
    65f1:	c3                   	ret    

000065f2 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    65f2:	55                   	push   %ebp
    65f3:	89 e5                	mov    %esp,%ebp
    65f5:	83 ec 04             	sub    $0x4,%esp
    65f8:	8b 45 14             	mov    0x14(%ebp),%eax
    65fb:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    65ff:	8b 45 08             	mov    0x8(%ebp),%eax
    6602:	8b 40 08             	mov    0x8(%eax),%eax
    6605:	8b 55 0c             	mov    0xc(%ebp),%edx
    6608:	c1 e2 02             	shl    $0x2,%edx
    660b:	01 c2                	add    %eax,%edx
    660d:	8b 45 10             	mov    0x10(%ebp),%eax
    6610:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6612:	8b 45 08             	mov    0x8(%ebp),%eax
    6615:	8b 00                	mov    (%eax),%eax
    6617:	8b 55 10             	mov    0x10(%ebp),%edx
    661a:	c1 e2 02             	shl    $0x2,%edx
    661d:	01 d0                	add    %edx,%eax
    661f:	8b 00                	mov    (%eax),%eax
    6621:	83 f8 ff             	cmp    $0xffffffff,%eax
    6624:	74 1f                	je     6645 <updateHashChain+0x53>
    6626:	8b 45 08             	mov    0x8(%ebp),%eax
    6629:	8b 40 04             	mov    0x4(%eax),%eax
    662c:	8b 55 0c             	mov    0xc(%ebp),%edx
    662f:	01 d2                	add    %edx,%edx
    6631:	01 c2                	add    %eax,%edx
    6633:	8b 45 08             	mov    0x8(%ebp),%eax
    6636:	8b 00                	mov    (%eax),%eax
    6638:	8b 4d 10             	mov    0x10(%ebp),%ecx
    663b:	c1 e1 02             	shl    $0x2,%ecx
    663e:	01 c8                	add    %ecx,%eax
    6640:	8b 00                	mov    (%eax),%eax
    6642:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    6645:	8b 45 08             	mov    0x8(%ebp),%eax
    6648:	8b 00                	mov    (%eax),%eax
    664a:	8b 55 10             	mov    0x10(%ebp),%edx
    664d:	c1 e2 02             	shl    $0x2,%edx
    6650:	01 c2                	add    %eax,%edx
    6652:	8b 45 0c             	mov    0xc(%ebp),%eax
    6655:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    6657:	8b 45 08             	mov    0x8(%ebp),%eax
    665a:	8b 40 14             	mov    0x14(%eax),%eax
    665d:	8b 55 0c             	mov    0xc(%ebp),%edx
    6660:	01 d2                	add    %edx,%edx
    6662:	01 c2                	add    %eax,%edx
    6664:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    6668:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    666b:	8b 45 08             	mov    0x8(%ebp),%eax
    666e:	8b 40 0c             	mov    0xc(%eax),%eax
    6671:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6675:	c1 e2 02             	shl    $0x2,%edx
    6678:	01 d0                	add    %edx,%eax
    667a:	8b 00                	mov    (%eax),%eax
    667c:	83 f8 ff             	cmp    $0xffffffff,%eax
    667f:	74 21                	je     66a2 <updateHashChain+0xb0>
    6681:	8b 45 08             	mov    0x8(%ebp),%eax
    6684:	8b 40 10             	mov    0x10(%eax),%eax
    6687:	8b 55 0c             	mov    0xc(%ebp),%edx
    668a:	01 d2                	add    %edx,%edx
    668c:	01 c2                	add    %eax,%edx
    668e:	8b 45 08             	mov    0x8(%ebp),%eax
    6691:	8b 40 0c             	mov    0xc(%eax),%eax
    6694:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    6698:	c1 e1 02             	shl    $0x2,%ecx
    669b:	01 c8                	add    %ecx,%eax
    669d:	8b 00                	mov    (%eax),%eax
    669f:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    66a2:	8b 45 08             	mov    0x8(%ebp),%eax
    66a5:	8b 40 0c             	mov    0xc(%eax),%eax
    66a8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    66ac:	c1 e2 02             	shl    $0x2,%edx
    66af:	01 c2                	add    %eax,%edx
    66b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    66b4:	89 02                	mov    %eax,(%edx)
}
    66b6:	90                   	nop
    66b7:	c9                   	leave  
    66b8:	c3                   	ret    

000066b9 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    66b9:	55                   	push   %ebp
    66ba:	89 e5                	mov    %esp,%ebp
    66bc:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    66bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    66c6:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    66cd:	77 08                	ja     66d7 <encodeLZ77+0x1e>
    66cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66d2:	c1 e8 03             	shr    $0x3,%eax
    66d5:	eb 03                	jmp    66da <encodeLZ77+0x21>
    66d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66da:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    66dd:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    66e4:	76 07                	jbe    66ed <encodeLZ77+0x34>
    66e6:	b8 02 01 00 00       	mov    $0x102,%eax
    66eb:	eb 05                	jmp    66f2 <encodeLZ77+0x39>
    66ed:	b8 40 00 00 00       	mov    $0x40,%eax
    66f2:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    66f5:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    66fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6703:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    670a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6711:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6718:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    671c:	74 09                	je     6727 <encodeLZ77+0x6e>
    671e:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6725:	76 0a                	jbe    6731 <encodeLZ77+0x78>
    6727:	b8 3c 00 00 00       	mov    $0x3c,%eax
    672c:	e9 e3 04 00 00       	jmp    6c14 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6731:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6734:	83 e8 01             	sub    $0x1,%eax
    6737:	23 45 1c             	and    0x1c(%ebp),%eax
    673a:	85 c0                	test   %eax,%eax
    673c:	74 0a                	je     6748 <encodeLZ77+0x8f>
    673e:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6743:	e9 cc 04 00 00       	jmp    6c14 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6748:	b8 02 01 00 00       	mov    $0x102,%eax
    674d:	39 45 24             	cmp    %eax,0x24(%ebp)
    6750:	76 08                	jbe    675a <encodeLZ77+0xa1>
    6752:	b8 02 01 00 00       	mov    $0x102,%eax
    6757:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    675a:	8b 45 14             	mov    0x14(%ebp),%eax
    675d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    6760:	e9 a0 04 00 00       	jmp    6c05 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    6765:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6768:	8d 50 ff             	lea    -0x1(%eax),%edx
    676b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    676e:	21 d0                	and    %edx,%eax
    6770:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    6773:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    677a:	ff 75 fc             	pushl  -0x4(%ebp)
    677d:	ff 75 18             	pushl  0x18(%ebp)
    6780:	ff 75 10             	pushl  0x10(%ebp)
    6783:	e8 54 fd ff ff       	call   64dc <getHash>
    6788:	83 c4 0c             	add    $0xc,%esp
    678b:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    678e:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6792:	74 4e                	je     67e2 <encodeLZ77+0x129>
    6794:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6798:	75 48                	jne    67e2 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    679a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    679e:	75 16                	jne    67b6 <encodeLZ77+0xfd>
    67a0:	ff 75 fc             	pushl  -0x4(%ebp)
    67a3:	ff 75 18             	pushl  0x18(%ebp)
    67a6:	ff 75 10             	pushl  0x10(%ebp)
    67a9:	e8 e2 fd ff ff       	call   6590 <countZeros>
    67ae:	83 c4 0c             	add    $0xc,%esp
    67b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    67b4:	eb 35                	jmp    67eb <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    67b6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    67b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    67bc:	01 c2                	add    %eax,%edx
    67be:	8b 45 18             	mov    0x18(%ebp),%eax
    67c1:	39 c2                	cmp    %eax,%edx
    67c3:	77 17                	ja     67dc <encodeLZ77+0x123>
    67c5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    67c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    67cb:	01 d0                	add    %edx,%eax
    67cd:	8d 50 ff             	lea    -0x1(%eax),%edx
    67d0:	8b 45 10             	mov    0x10(%ebp),%eax
    67d3:	01 d0                	add    %edx,%eax
    67d5:	0f b6 00             	movzbl (%eax),%eax
    67d8:	84 c0                	test   %al,%al
    67da:	74 0f                	je     67eb <encodeLZ77+0x132>
    67dc:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    67e0:	eb 09                	jmp    67eb <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    67e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    67e9:	eb 01                	jmp    67ec <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    67eb:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    67ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
    67ef:	0f b7 c0             	movzwl %ax,%eax
    67f2:	50                   	push   %eax
    67f3:	ff 75 b0             	pushl  -0x50(%ebp)
    67f6:	ff 75 b4             	pushl  -0x4c(%ebp)
    67f9:	ff 75 0c             	pushl  0xc(%ebp)
    67fc:	e8 f1 fd ff ff       	call   65f2 <updateHashChain>
    6801:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6804:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    680b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6812:	8b 45 0c             	mov    0xc(%ebp),%eax
    6815:	8b 40 04             	mov    0x4(%eax),%eax
    6818:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    681b:	01 d2                	add    %edx,%edx
    681d:	01 d0                	add    %edx,%eax
    681f:	0f b7 00             	movzwl (%eax),%eax
    6822:	0f b7 c0             	movzwl %ax,%eax
    6825:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6828:	ba 02 01 00 00       	mov    $0x102,%edx
    682d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6830:	01 c2                	add    %eax,%edx
    6832:	8b 45 18             	mov    0x18(%ebp),%eax
    6835:	39 c2                	cmp    %eax,%edx
    6837:	0f 4e c2             	cmovle %edx,%eax
    683a:	89 c2                	mov    %eax,%edx
    683c:	8b 45 10             	mov    0x10(%ebp),%eax
    683f:	01 d0                	add    %edx,%eax
    6841:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6844:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    684b:	8b 45 c8             	mov    -0x38(%ebp),%eax
    684e:	8d 50 01             	lea    0x1(%eax),%edx
    6851:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6854:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6857:	0f 83 67 01 00 00    	jae    69c4 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    685d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6860:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    6863:	77 08                	ja     686d <encodeLZ77+0x1b4>
    6865:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6868:	2b 45 cc             	sub    -0x34(%ebp),%eax
    686b:	eb 0d                	jmp    687a <encodeLZ77+0x1c1>
    686d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6870:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6873:	89 c2                	mov    %eax,%edx
    6875:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6878:	01 d0                	add    %edx,%eax
    687a:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    687d:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6880:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6883:	0f 82 3e 01 00 00    	jb     69c7 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6889:	8b 45 a8             	mov    -0x58(%ebp),%eax
    688c:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    688f:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6893:	0f 84 a3 00 00 00    	je     693c <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6899:	8b 55 fc             	mov    -0x4(%ebp),%edx
    689c:	8b 45 10             	mov    0x10(%ebp),%eax
    689f:	01 d0                	add    %edx,%eax
    68a1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    68a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    68a7:	2b 45 a8             	sub    -0x58(%ebp),%eax
    68aa:	89 c2                	mov    %eax,%edx
    68ac:	8b 45 10             	mov    0x10(%ebp),%eax
    68af:	01 d0                	add    %edx,%eax
    68b1:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    68b4:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    68b8:	76 3a                	jbe    68f4 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    68ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    68bd:	8b 40 14             	mov    0x14(%eax),%eax
    68c0:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68c3:	01 d2                	add    %edx,%edx
    68c5:	01 d0                	add    %edx,%eax
    68c7:	0f b7 00             	movzwl (%eax),%eax
    68ca:	0f b7 c0             	movzwl %ax,%eax
    68cd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    68d0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    68d3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68d6:	76 06                	jbe    68de <encodeLZ77+0x225>
    68d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    68db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    68de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    68e1:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    68e4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    68e7:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    68ea:	eb 08                	jmp    68f4 <encodeLZ77+0x23b>
          ++backptr;
    68ec:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    68f0:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    68f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    68f7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    68fa:	74 10                	je     690c <encodeLZ77+0x253>
    68fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
    68ff:	0f b6 10             	movzbl (%eax),%edx
    6902:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6905:	0f b6 00             	movzbl (%eax),%eax
    6908:	38 c2                	cmp    %al,%dl
    690a:	74 e0                	je     68ec <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    690c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    690f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6912:	8b 55 10             	mov    0x10(%ebp),%edx
    6915:	01 ca                	add    %ecx,%edx
    6917:	29 d0                	sub    %edx,%eax
    6919:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    691c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    691f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6922:	76 18                	jbe    693c <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6924:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6927:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    692a:	8b 45 a8             	mov    -0x58(%ebp),%eax
    692d:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6930:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6933:	3b 45 24             	cmp    0x24(%ebp),%eax
    6936:	0f 83 8e 00 00 00    	jae    69ca <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    693c:	8b 45 0c             	mov    0xc(%ebp),%eax
    693f:	8b 40 04             	mov    0x4(%eax),%eax
    6942:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6945:	01 d2                	add    %edx,%edx
    6947:	01 d0                	add    %edx,%eax
    6949:	0f b7 00             	movzwl (%eax),%eax
    694c:	0f b7 c0             	movzwl %ax,%eax
    694f:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6952:	74 79                	je     69cd <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6954:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6958:	76 38                	jbe    6992 <encodeLZ77+0x2d9>
    695a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    695d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6960:	76 30                	jbe    6992 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6962:	8b 45 0c             	mov    0xc(%ebp),%eax
    6965:	8b 40 10             	mov    0x10(%eax),%eax
    6968:	8b 55 cc             	mov    -0x34(%ebp),%edx
    696b:	01 d2                	add    %edx,%edx
    696d:	01 d0                	add    %edx,%eax
    696f:	0f b7 00             	movzwl (%eax),%eax
    6972:	0f b7 c0             	movzwl %ax,%eax
    6975:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6978:	8b 45 0c             	mov    0xc(%ebp),%eax
    697b:	8b 40 14             	mov    0x14(%eax),%eax
    697e:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6981:	01 d2                	add    %edx,%edx
    6983:	01 d0                	add    %edx,%eax
    6985:	0f b7 00             	movzwl (%eax),%eax
    6988:	0f b7 c0             	movzwl %ax,%eax
    698b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    698e:	74 2f                	je     69bf <encodeLZ77+0x306>
    6990:	eb 3f                	jmp    69d1 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6992:	8b 45 0c             	mov    0xc(%ebp),%eax
    6995:	8b 40 04             	mov    0x4(%eax),%eax
    6998:	8b 55 cc             	mov    -0x34(%ebp),%edx
    699b:	01 d2                	add    %edx,%edx
    699d:	01 d0                	add    %edx,%eax
    699f:	0f b7 00             	movzwl (%eax),%eax
    69a2:	0f b7 c0             	movzwl %ax,%eax
    69a5:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    69a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    69ab:	8b 40 08             	mov    0x8(%eax),%eax
    69ae:	8b 55 cc             	mov    -0x34(%ebp),%edx
    69b1:	c1 e2 02             	shl    $0x2,%edx
    69b4:	01 d0                	add    %edx,%eax
    69b6:	8b 10                	mov    (%eax),%edx
    69b8:	8b 45 b0             	mov    -0x50(%ebp),%eax
    69bb:	39 c2                	cmp    %eax,%edx
    69bd:	75 11                	jne    69d0 <encodeLZ77+0x317>
      }
    }
    69bf:	e9 87 fe ff ff       	jmp    684b <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    69c4:	90                   	nop
    69c5:	eb 0a                	jmp    69d1 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    69c7:	90                   	nop
    69c8:	eb 07                	jmp    69d1 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    69ca:	90                   	nop
    69cb:	eb 04                	jmp    69d1 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    69cd:	90                   	nop
    69ce:	eb 01                	jmp    69d1 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    69d0:	90                   	nop
      }
    }

    if(lazymatching) {
    69d1:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    69d5:	0f 84 c8 00 00 00    	je     6aa3 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    69db:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    69df:	75 30                	jne    6a11 <encodeLZ77+0x358>
    69e1:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    69e5:	76 2a                	jbe    6a11 <encodeLZ77+0x358>
    69e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    69ea:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    69ed:	77 22                	ja     6a11 <encodeLZ77+0x358>
    69ef:	b8 02 01 00 00       	mov    $0x102,%eax
    69f4:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    69f7:	73 18                	jae    6a11 <encodeLZ77+0x358>
        lazy = 1;
    69f9:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6a00:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a03:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6a06:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a09:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6a0c:	e9 f0 01 00 00       	jmp    6c01 <encodeLZ77+0x548>
      }
      if(lazy) {
    6a11:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6a15:	0f 84 88 00 00 00    	je     6aa3 <encodeLZ77+0x3ea>
        lazy = 0;
    6a1b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6a22:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6a26:	75 0c                	jne    6a34 <encodeLZ77+0x37b>
    6a28:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6a2f:	e9 dd 01 00 00       	jmp    6c11 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6a34:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6a37:	83 c0 01             	add    $0x1,%eax
    6a3a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6a3d:	73 2d                	jae    6a6c <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6a3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6a42:	8d 50 ff             	lea    -0x1(%eax),%edx
    6a45:	8b 45 10             	mov    0x10(%ebp),%eax
    6a48:	01 d0                	add    %edx,%eax
    6a4a:	0f b6 00             	movzbl (%eax),%eax
    6a4d:	0f b6 c0             	movzbl %al,%eax
    6a50:	50                   	push   %eax
    6a51:	ff 75 08             	pushl  0x8(%ebp)
    6a54:	e8 6f cb ff ff       	call   35c8 <uivector_push_back>
    6a59:	83 c4 08             	add    $0x8,%esp
    6a5c:	85 c0                	test   %eax,%eax
    6a5e:	75 43                	jne    6aa3 <encodeLZ77+0x3ea>
    6a60:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a67:	e9 a5 01 00 00       	jmp    6c11 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6a6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6a6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6a72:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6a75:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6a78:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a7b:	8b 00                	mov    (%eax),%eax
    6a7d:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6a80:	c1 e2 02             	shl    $0x2,%edx
    6a83:	01 d0                	add    %edx,%eax
    6a85:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6a8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a8e:	8b 40 0c             	mov    0xc(%eax),%eax
    6a91:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a94:	c1 e2 02             	shl    $0x2,%edx
    6a97:	01 d0                	add    %edx,%eax
    6a99:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6a9f:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6aa3:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6aa7:	76 14                	jbe    6abd <encodeLZ77+0x404>
    6aa9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6aac:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6aaf:	76 0c                	jbe    6abd <encodeLZ77+0x404>
    6ab1:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6ab8:	e9 54 01 00 00       	jmp    6c11 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6abd:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6ac1:	77 2e                	ja     6af1 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6ac3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ac6:	8b 45 10             	mov    0x10(%ebp),%eax
    6ac9:	01 d0                	add    %edx,%eax
    6acb:	0f b6 00             	movzbl (%eax),%eax
    6ace:	0f b6 c0             	movzbl %al,%eax
    6ad1:	50                   	push   %eax
    6ad2:	ff 75 08             	pushl  0x8(%ebp)
    6ad5:	e8 ee ca ff ff       	call   35c8 <uivector_push_back>
    6ada:	83 c4 08             	add    $0x8,%esp
    6add:	85 c0                	test   %eax,%eax
    6adf:	0f 85 1c 01 00 00    	jne    6c01 <encodeLZ77+0x548>
    6ae5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6aec:	e9 20 01 00 00       	jmp    6c11 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6af1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6af4:	3b 45 20             	cmp    0x20(%ebp),%eax
    6af7:	72 0f                	jb     6b08 <encodeLZ77+0x44f>
    6af9:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6afd:	75 37                	jne    6b36 <encodeLZ77+0x47d>
    6aff:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6b06:	76 2e                	jbe    6b36 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6b08:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b0b:	8b 45 10             	mov    0x10(%ebp),%eax
    6b0e:	01 d0                	add    %edx,%eax
    6b10:	0f b6 00             	movzbl (%eax),%eax
    6b13:	0f b6 c0             	movzbl %al,%eax
    6b16:	50                   	push   %eax
    6b17:	ff 75 08             	pushl  0x8(%ebp)
    6b1a:	e8 a9 ca ff ff       	call   35c8 <uivector_push_back>
    6b1f:	83 c4 08             	add    $0x8,%esp
    6b22:	85 c0                	test   %eax,%eax
    6b24:	0f 85 d7 00 00 00    	jne    6c01 <encodeLZ77+0x548>
    6b2a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6b31:	e9 db 00 00 00       	jmp    6c11 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6b36:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6b39:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6b3c:	52                   	push   %edx
    6b3d:	50                   	push   %eax
    6b3e:	ff 75 08             	pushl  0x8(%ebp)
    6b41:	e8 8a f6 ff ff       	call   61d0 <addLengthDistance>
    6b46:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6b49:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6b50:	e9 a0 00 00 00       	jmp    6bf5 <encodeLZ77+0x53c>
        ++pos;
    6b55:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6b59:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6b5c:	8d 50 ff             	lea    -0x1(%eax),%edx
    6b5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b62:	21 d0                	and    %edx,%eax
    6b64:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6b67:	ff 75 fc             	pushl  -0x4(%ebp)
    6b6a:	ff 75 18             	pushl  0x18(%ebp)
    6b6d:	ff 75 10             	pushl  0x10(%ebp)
    6b70:	e8 67 f9 ff ff       	call   64dc <getHash>
    6b75:	83 c4 0c             	add    $0xc,%esp
    6b78:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6b7b:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6b7f:	74 4e                	je     6bcf <encodeLZ77+0x516>
    6b81:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6b85:	75 48                	jne    6bcf <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b87:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6b8b:	75 16                	jne    6ba3 <encodeLZ77+0x4ea>
    6b8d:	ff 75 fc             	pushl  -0x4(%ebp)
    6b90:	ff 75 18             	pushl  0x18(%ebp)
    6b93:	ff 75 10             	pushl  0x10(%ebp)
    6b96:	e8 f5 f9 ff ff       	call   6590 <countZeros>
    6b9b:	83 c4 0c             	add    $0xc,%esp
    6b9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6ba1:	eb 35                	jmp    6bd8 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6ba3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ba6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ba9:	01 c2                	add    %eax,%edx
    6bab:	8b 45 18             	mov    0x18(%ebp),%eax
    6bae:	39 c2                	cmp    %eax,%edx
    6bb0:	77 17                	ja     6bc9 <encodeLZ77+0x510>
    6bb2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6bb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bb8:	01 d0                	add    %edx,%eax
    6bba:	8d 50 ff             	lea    -0x1(%eax),%edx
    6bbd:	8b 45 10             	mov    0x10(%ebp),%eax
    6bc0:	01 d0                	add    %edx,%eax
    6bc2:	0f b6 00             	movzbl (%eax),%eax
    6bc5:	84 c0                	test   %al,%al
    6bc7:	74 0f                	je     6bd8 <encodeLZ77+0x51f>
    6bc9:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6bcd:	eb 09                	jmp    6bd8 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6bcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6bd6:	eb 01                	jmp    6bd9 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6bd8:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6bd9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bdc:	0f b7 c0             	movzwl %ax,%eax
    6bdf:	50                   	push   %eax
    6be0:	ff 75 b0             	pushl  -0x50(%ebp)
    6be3:	ff 75 b4             	pushl  -0x4c(%ebp)
    6be6:	ff 75 0c             	pushl  0xc(%ebp)
    6be9:	e8 04 fa ff ff       	call   65f2 <updateHashChain>
    6bee:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6bf1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6bf5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6bf8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6bfb:	0f 82 54 ff ff ff    	jb     6b55 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6c01:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6c05:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c08:	3b 45 18             	cmp    0x18(%ebp),%eax
    6c0b:	0f 8c 54 fb ff ff    	jl     6765 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6c11:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6c14:	c9                   	leave  
    6c15:	c3                   	ret    

00006c16 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6c16:	55                   	push   %ebp
    6c17:	89 e5                	mov    %esp,%ebp
    6c19:	53                   	push   %ebx
    6c1a:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6c1d:	8b 45 10             	mov    0x10(%ebp),%eax
    6c20:	05 fe ff 00 00       	add    $0xfffe,%eax
    6c25:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6c2a:	f7 e2                	mul    %edx
    6c2c:	89 d0                	mov    %edx,%eax
    6c2e:	c1 e8 0f             	shr    $0xf,%eax
    6c31:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6c34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6c3b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6c42:	e9 1b 01 00 00       	jmp    6d62 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6c47:	8b 45 08             	mov    0x8(%ebp),%eax
    6c4a:	8b 40 04             	mov    0x4(%eax),%eax
    6c4d:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6c50:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6c53:	83 e8 01             	sub    $0x1,%eax
    6c56:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6c59:	0f 94 c0             	sete   %al
    6c5c:	0f b6 c0             	movzbl %al,%eax
    6c5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6c62:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6c69:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6c70:	8b 45 10             	mov    0x10(%ebp),%eax
    6c73:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6c76:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6c7b:	77 09                	ja     6c86 <deflateNoCompression+0x70>
    6c7d:	8b 45 10             	mov    0x10(%ebp),%eax
    6c80:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6c83:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6c86:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6c8b:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6c8e:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6c91:	8b 45 08             	mov    0x8(%ebp),%eax
    6c94:	8b 40 04             	mov    0x4(%eax),%eax
    6c97:	89 c2                	mov    %eax,%edx
    6c99:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c9c:	01 d0                	add    %edx,%eax
    6c9e:	83 c0 05             	add    $0x5,%eax
    6ca1:	50                   	push   %eax
    6ca2:	ff 75 08             	pushl  0x8(%ebp)
    6ca5:	e8 62 c9 ff ff       	call   360c <ucvector_resize>
    6caa:	83 c4 08             	add    $0x8,%esp
    6cad:	85 c0                	test   %eax,%eax
    6caf:	75 0a                	jne    6cbb <deflateNoCompression+0xa5>
    6cb1:	b8 53 00 00 00       	mov    $0x53,%eax
    6cb6:	e9 b8 00 00 00       	jmp    6d73 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6cbb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6cbe:	89 c2                	mov    %eax,%edx
    6cc0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6cc3:	83 e0 01             	and    $0x1,%eax
    6cc6:	01 c0                	add    %eax,%eax
    6cc8:	01 c2                	add    %eax,%edx
    6cca:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6ccd:	83 e0 02             	and    $0x2,%eax
    6cd0:	01 c0                	add    %eax,%eax
    6cd2:	01 d0                	add    %edx,%eax
    6cd4:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6cd7:	8b 45 08             	mov    0x8(%ebp),%eax
    6cda:	8b 10                	mov    (%eax),%edx
    6cdc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6cdf:	01 c2                	add    %eax,%edx
    6ce1:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6ce5:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6ce7:	8b 45 08             	mov    0x8(%ebp),%eax
    6cea:	8b 00                	mov    (%eax),%eax
    6cec:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6cef:	83 c2 01             	add    $0x1,%edx
    6cf2:	01 d0                	add    %edx,%eax
    6cf4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6cf7:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6cf9:	8b 45 08             	mov    0x8(%ebp),%eax
    6cfc:	8b 00                	mov    (%eax),%eax
    6cfe:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d01:	83 c2 02             	add    $0x2,%edx
    6d04:	01 d0                	add    %edx,%eax
    6d06:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6d09:	c1 ea 08             	shr    $0x8,%edx
    6d0c:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6d0e:	8b 45 08             	mov    0x8(%ebp),%eax
    6d11:	8b 00                	mov    (%eax),%eax
    6d13:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d16:	83 c2 03             	add    $0x3,%edx
    6d19:	01 d0                	add    %edx,%eax
    6d1b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6d1e:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6d20:	8b 45 08             	mov    0x8(%ebp),%eax
    6d23:	8b 00                	mov    (%eax),%eax
    6d25:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d28:	83 c2 04             	add    $0x4,%edx
    6d2b:	01 d0                	add    %edx,%eax
    6d2d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6d30:	c1 ea 08             	shr    $0x8,%edx
    6d33:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6d35:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d38:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6d3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6d3e:	01 d1                	add    %edx,%ecx
    6d40:	8b 55 08             	mov    0x8(%ebp),%edx
    6d43:	8b 12                	mov    (%edx),%edx
    6d45:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6d48:	83 c3 05             	add    $0x5,%ebx
    6d4b:	01 da                	add    %ebx,%edx
    6d4d:	50                   	push   %eax
    6d4e:	51                   	push   %ecx
    6d4f:	52                   	push   %edx
    6d50:	e8 9b c6 ff ff       	call   33f0 <lodepng_memcpy>
    6d55:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d5b:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6d5e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6d62:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d65:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6d68:	0f 85 d9 fe ff ff    	jne    6c47 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6d6e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6d73:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6d76:	c9                   	leave  
    6d77:	c3                   	ret    

00006d78 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6d78:	55                   	push   %ebp
    6d79:	89 e5                	mov    %esp,%ebp
    6d7b:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6d7e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6d85:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6d8c:	e9 10 01 00 00       	jmp    6ea1 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6d91:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d94:	8b 00                	mov    (%eax),%eax
    6d96:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d99:	c1 e2 02             	shl    $0x2,%edx
    6d9c:	01 d0                	add    %edx,%eax
    6d9e:	8b 00                	mov    (%eax),%eax
    6da0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6da3:	8b 45 10             	mov    0x10(%ebp),%eax
    6da6:	8b 40 04             	mov    0x4(%eax),%eax
    6da9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6dac:	c1 e2 02             	shl    $0x2,%edx
    6daf:	01 d0                	add    %edx,%eax
    6db1:	8b 00                	mov    (%eax),%eax
    6db3:	89 c1                	mov    %eax,%ecx
    6db5:	8b 45 10             	mov    0x10(%ebp),%eax
    6db8:	8b 00                	mov    (%eax),%eax
    6dba:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6dbd:	c1 e2 02             	shl    $0x2,%edx
    6dc0:	01 d0                	add    %edx,%eax
    6dc2:	8b 00                	mov    (%eax),%eax
    6dc4:	51                   	push   %ecx
    6dc5:	50                   	push   %eax
    6dc6:	ff 75 08             	pushl  0x8(%ebp)
    6dc9:	e8 60 cc ff ff       	call   3a2e <writeBitsReversed>
    6dce:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6dd1:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6dd8:	0f 86 bf 00 00 00    	jbe    6e9d <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6dde:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6de1:	2d 01 01 00 00       	sub    $0x101,%eax
    6de6:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6de9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6dec:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    6df3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6df6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6df9:	8b 00                	mov    (%eax),%eax
    6dfb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6dff:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e02:	c1 e2 02             	shl    $0x2,%edx
    6e05:	01 d0                	add    %edx,%eax
    6e07:	8b 00                	mov    (%eax),%eax
    6e09:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6e0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e0f:	8b 00                	mov    (%eax),%eax
    6e11:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e15:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e18:	c1 e2 02             	shl    $0x2,%edx
    6e1b:	01 d0                	add    %edx,%eax
    6e1d:	8b 00                	mov    (%eax),%eax
    6e1f:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6e22:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e25:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6e28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6e2b:	8b 04 85 a0 9f 01 00 	mov    0x19fa0(,%eax,4),%eax
    6e32:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6e35:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e38:	8b 00                	mov    (%eax),%eax
    6e3a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e3e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e41:	c1 e2 02             	shl    $0x2,%edx
    6e44:	01 d0                	add    %edx,%eax
    6e46:	8b 00                	mov    (%eax),%eax
    6e48:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6e4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e4e:	50                   	push   %eax
    6e4f:	ff 75 ec             	pushl  -0x14(%ebp)
    6e52:	ff 75 08             	pushl  0x8(%ebp)
    6e55:	e8 40 ca ff ff       	call   389a <writeBits>
    6e5a:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6e5d:	8b 45 14             	mov    0x14(%ebp),%eax
    6e60:	8b 40 04             	mov    0x4(%eax),%eax
    6e63:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6e66:	c1 e2 02             	shl    $0x2,%edx
    6e69:	01 d0                	add    %edx,%eax
    6e6b:	8b 00                	mov    (%eax),%eax
    6e6d:	89 c1                	mov    %eax,%ecx
    6e6f:	8b 45 14             	mov    0x14(%ebp),%eax
    6e72:	8b 00                	mov    (%eax),%eax
    6e74:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6e77:	c1 e2 02             	shl    $0x2,%edx
    6e7a:	01 d0                	add    %edx,%eax
    6e7c:	8b 00                	mov    (%eax),%eax
    6e7e:	51                   	push   %ecx
    6e7f:	50                   	push   %eax
    6e80:	ff 75 08             	pushl  0x8(%ebp)
    6e83:	e8 a6 cb ff ff       	call   3a2e <writeBitsReversed>
    6e88:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6e8b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6e8e:	50                   	push   %eax
    6e8f:	ff 75 dc             	pushl  -0x24(%ebp)
    6e92:	ff 75 08             	pushl  0x8(%ebp)
    6e95:	e8 00 ca ff ff       	call   389a <writeBits>
    6e9a:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6e9d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6ea1:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ea4:	8b 40 04             	mov    0x4(%eax),%eax
    6ea7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6eaa:	0f 85 e1 fe ff ff    	jne    6d91 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6eb0:	90                   	nop
    6eb1:	c9                   	leave  
    6eb2:	c3                   	ret    

00006eb3 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6eb3:	55                   	push   %ebp
    6eb4:	89 e5                	mov    %esp,%ebp
    6eb6:	53                   	push   %ebx
    6eb7:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6ebd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6ec4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6ecb:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6ed2:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6ed9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6ee0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6ee7:	8b 45 18             	mov    0x18(%ebp),%eax
    6eea:	2b 45 14             	sub    0x14(%ebp),%eax
    6eed:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6ef0:	8b 45 20             	mov    0x20(%ebp),%eax
    6ef3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6ef6:	8d 45 90             	lea    -0x70(%ebp),%eax
    6ef9:	50                   	push   %eax
    6efa:	e8 a4 c6 ff ff       	call   35a3 <uivector_init>
    6eff:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6f02:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6f08:	50                   	push   %eax
    6f09:	e8 98 d3 ff ff       	call   42a6 <HuffmanTree_init>
    6f0e:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6f11:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6f17:	50                   	push   %eax
    6f18:	e8 89 d3 ff ff       	call   42a6 <HuffmanTree_init>
    6f1d:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6f20:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6f26:	50                   	push   %eax
    6f27:	e8 7a d3 ff ff       	call   42a6 <HuffmanTree_init>
    6f2c:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6f2f:	83 ec 0c             	sub    $0xc,%esp
    6f32:	68 78 04 00 00       	push   $0x478
    6f37:	e8 76 c4 ff ff       	call   33b2 <lodepng_malloc>
    6f3c:	83 c4 10             	add    $0x10,%esp
    6f3f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6f42:	83 ec 0c             	sub    $0xc,%esp
    6f45:	6a 78                	push   $0x78
    6f47:	e8 66 c4 ff ff       	call   33b2 <lodepng_malloc>
    6f4c:	83 c4 10             	add    $0x10,%esp
    6f4f:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6f52:	83 ec 0c             	sub    $0xc,%esp
    6f55:	6a 4c                	push   $0x4c
    6f57:	e8 56 c4 ff ff       	call   33b2 <lodepng_malloc>
    6f5c:	83 c4 10             	add    $0x10,%esp
    6f5f:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6f62:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6f66:	74 0c                	je     6f74 <deflateDynamic+0xc1>
    6f68:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6f6c:	74 06                	je     6f74 <deflateDynamic+0xc1>
    6f6e:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6f72:	75 07                	jne    6f7b <deflateDynamic+0xc8>
    6f74:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6f7b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f7f:	0f 85 f6 07 00 00    	jne    777b <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6f85:	83 ec 04             	sub    $0x4,%esp
    6f88:	68 78 04 00 00       	push   $0x478
    6f8d:	6a 00                	push   $0x0
    6f8f:	ff 75 d4             	pushl  -0x2c(%ebp)
    6f92:	e8 8c c4 ff ff       	call   3423 <lodepng_memset>
    6f97:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6f9a:	83 ec 04             	sub    $0x4,%esp
    6f9d:	6a 78                	push   $0x78
    6f9f:	6a 00                	push   $0x0
    6fa1:	ff 75 d0             	pushl  -0x30(%ebp)
    6fa4:	e8 7a c4 ff ff       	call   3423 <lodepng_memset>
    6fa9:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6fac:	83 ec 04             	sub    $0x4,%esp
    6faf:	6a 4c                	push   $0x4c
    6fb1:	6a 00                	push   $0x0
    6fb3:	ff 75 cc             	pushl  -0x34(%ebp)
    6fb6:	e8 68 c4 ff ff       	call   3423 <lodepng_memset>
    6fbb:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    6fbe:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fc1:	8b 40 04             	mov    0x4(%eax),%eax
    6fc4:	85 c0                	test   %eax,%eax
    6fc6:	74 45                	je     700d <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    6fc8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fcb:	8b 58 14             	mov    0x14(%eax),%ebx
    6fce:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fd1:	8b 48 10             	mov    0x10(%eax),%ecx
    6fd4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fd7:	8b 50 0c             	mov    0xc(%eax),%edx
    6fda:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fdd:	8b 40 08             	mov    0x8(%eax),%eax
    6fe0:	83 ec 0c             	sub    $0xc,%esp
    6fe3:	53                   	push   %ebx
    6fe4:	51                   	push   %ecx
    6fe5:	52                   	push   %edx
    6fe6:	50                   	push   %eax
    6fe7:	ff 75 18             	pushl  0x18(%ebp)
    6fea:	ff 75 14             	pushl  0x14(%ebp)
    6fed:	ff 75 10             	pushl  0x10(%ebp)
    6ff0:	ff 75 0c             	pushl  0xc(%ebp)
    6ff3:	8d 45 90             	lea    -0x70(%ebp),%eax
    6ff6:	50                   	push   %eax
    6ff7:	e8 bd f6 ff ff       	call   66b9 <encodeLZ77>
    6ffc:	83 c4 30             	add    $0x30,%esp
    6fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    7002:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7006:	74 59                	je     7061 <deflateDynamic+0x1ae>
    7008:	e9 6e 07 00 00       	jmp    777b <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    700d:	83 ec 08             	sub    $0x8,%esp
    7010:	ff 75 c8             	pushl  -0x38(%ebp)
    7013:	8d 45 90             	lea    -0x70(%ebp),%eax
    7016:	50                   	push   %eax
    7017:	e8 17 c5 ff ff       	call   3533 <uivector_resize>
    701c:	83 c4 10             	add    $0x10,%esp
    701f:	85 c0                	test   %eax,%eax
    7021:	75 0c                	jne    702f <deflateDynamic+0x17c>
    7023:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    702a:	e9 4c 07 00 00       	jmp    777b <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    702f:	8b 45 14             	mov    0x14(%ebp),%eax
    7032:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7035:	eb 22                	jmp    7059 <deflateDynamic+0x1a6>
    7037:	8b 55 90             	mov    -0x70(%ebp),%edx
    703a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    703d:	2b 45 14             	sub    0x14(%ebp),%eax
    7040:	c1 e0 02             	shl    $0x2,%eax
    7043:	01 c2                	add    %eax,%edx
    7045:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7048:	8b 45 10             	mov    0x10(%ebp),%eax
    704b:	01 c8                	add    %ecx,%eax
    704d:	0f b6 00             	movzbl (%eax),%eax
    7050:	0f b6 c0             	movzbl %al,%eax
    7053:	89 02                	mov    %eax,(%edx)
    7055:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7059:	8b 45 e8             	mov    -0x18(%ebp),%eax
    705c:	3b 45 18             	cmp    0x18(%ebp),%eax
    705f:	7c d6                	jl     7037 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7061:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7068:	eb 60                	jmp    70ca <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    706a:	8b 45 90             	mov    -0x70(%ebp),%eax
    706d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7070:	c1 e2 02             	shl    $0x2,%edx
    7073:	01 d0                	add    %edx,%eax
    7075:	8b 00                	mov    (%eax),%eax
    7077:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    707a:	8b 45 c0             	mov    -0x40(%ebp),%eax
    707d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7084:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7087:	01 d0                	add    %edx,%eax
    7089:	8b 10                	mov    (%eax),%edx
    708b:	83 c2 01             	add    $0x1,%edx
    708e:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    7090:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    7097:	76 2d                	jbe    70c6 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    7099:	8b 45 90             	mov    -0x70(%ebp),%eax
    709c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    709f:	83 c2 02             	add    $0x2,%edx
    70a2:	c1 e2 02             	shl    $0x2,%edx
    70a5:	01 d0                	add    %edx,%eax
    70a7:	8b 00                	mov    (%eax),%eax
    70a9:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    70ac:	8b 45 bc             	mov    -0x44(%ebp),%eax
    70af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    70b6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    70b9:	01 d0                	add    %edx,%eax
    70bb:	8b 10                	mov    (%eax),%edx
    70bd:	83 c2 01             	add    $0x1,%edx
    70c0:	89 10                	mov    %edx,(%eax)
        i += 3;
    70c2:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    70c6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    70ca:	8b 45 94             	mov    -0x6c(%ebp),%eax
    70cd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    70d0:	75 98                	jne    706a <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    70d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    70d5:	05 00 04 00 00       	add    $0x400,%eax
    70da:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    70e0:	83 ec 0c             	sub    $0xc,%esp
    70e3:	6a 0f                	push   $0xf
    70e5:	68 1e 01 00 00       	push   $0x11e
    70ea:	68 01 01 00 00       	push   $0x101
    70ef:	ff 75 d4             	pushl  -0x2c(%ebp)
    70f2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    70f8:	50                   	push   %eax
    70f9:	e8 e0 e1 ff ff       	call   52de <HuffmanTree_makeFromFrequencies>
    70fe:	83 c4 20             	add    $0x20,%esp
    7101:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7104:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7108:	0f 85 66 06 00 00    	jne    7774 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    710e:	83 ec 0c             	sub    $0xc,%esp
    7111:	6a 0f                	push   $0xf
    7113:	6a 1e                	push   $0x1e
    7115:	6a 02                	push   $0x2
    7117:	ff 75 d0             	pushl  -0x30(%ebp)
    711a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7120:	50                   	push   %eax
    7121:	e8 b8 e1 ff ff       	call   52de <HuffmanTree_makeFromFrequencies>
    7126:	83 c4 20             	add    $0x20,%esp
    7129:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    712c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7130:	0f 85 41 06 00 00    	jne    7777 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    7136:	8b 45 84             	mov    -0x7c(%ebp),%eax
    7139:	ba 1e 01 00 00       	mov    $0x11e,%edx
    713e:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7143:	0f 47 c2             	cmova  %edx,%eax
    7146:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    7149:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    714f:	ba 1e 00 00 00       	mov    $0x1e,%edx
    7154:	83 f8 1e             	cmp    $0x1e,%eax
    7157:	0f 47 c2             	cmova  %edx,%eax
    715a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    715d:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7160:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7163:	01 d0                	add    %edx,%eax
    7165:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    7168:	8b 45 b0             	mov    -0x50(%ebp),%eax
    716b:	c1 e0 02             	shl    $0x2,%eax
    716e:	83 ec 0c             	sub    $0xc,%esp
    7171:	50                   	push   %eax
    7172:	e8 3b c2 ff ff       	call   33b2 <lodepng_malloc>
    7177:	83 c4 10             	add    $0x10,%esp
    717a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    717d:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7180:	c1 e0 02             	shl    $0x2,%eax
    7183:	83 ec 0c             	sub    $0xc,%esp
    7186:	50                   	push   %eax
    7187:	e8 26 c2 ff ff       	call   33b2 <lodepng_malloc>
    718c:	83 c4 10             	add    $0x10,%esp
    718f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    7192:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7196:	74 06                	je     719e <deflateDynamic+0x2eb>
    7198:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    719c:	75 0c                	jne    71aa <deflateDynamic+0x2f7>
    719e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    71a5:	e9 d1 05 00 00       	jmp    777b <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    71aa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    71b1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    71b8:	eb 25                	jmp    71df <deflateDynamic+0x32c>
    71ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71c7:	01 c2                	add    %eax,%edx
    71c9:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    71cf:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    71d2:	c1 e1 02             	shl    $0x2,%ecx
    71d5:	01 c8                	add    %ecx,%eax
    71d7:	8b 00                	mov    (%eax),%eax
    71d9:	89 02                	mov    %eax,(%edx)
    71db:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    71df:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71e2:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    71e5:	75 d3                	jne    71ba <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    71e7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    71ee:	eb 2a                	jmp    721a <deflateDynamic+0x367>
    71f0:	8b 55 b8             	mov    -0x48(%ebp),%edx
    71f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71f6:	01 d0                	add    %edx,%eax
    71f8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7202:	01 c2                	add    %eax,%edx
    7204:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    720a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    720d:	c1 e1 02             	shl    $0x2,%ecx
    7210:	01 c8                	add    %ecx,%eax
    7212:	8b 00                	mov    (%eax),%eax
    7214:	89 02                	mov    %eax,(%edx)
    7216:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    721a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    721d:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7220:	75 ce                	jne    71f0 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7222:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7229:	e9 3b 02 00 00       	jmp    7469 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    722e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    7235:	eb 04                	jmp    723b <deflateDynamic+0x388>
    7237:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    723b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    723e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7241:	01 d0                	add    %edx,%eax
    7243:	8d 50 01             	lea    0x1(%eax),%edx
    7246:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7249:	39 c2                	cmp    %eax,%edx
    724b:	73 2e                	jae    727b <deflateDynamic+0x3c8>
    724d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7250:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7253:	01 d0                	add    %edx,%eax
    7255:	83 c0 01             	add    $0x1,%eax
    7258:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    725f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7262:	01 d0                	add    %edx,%eax
    7264:	8b 10                	mov    (%eax),%edx
    7266:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7269:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7270:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7273:	01 c8                	add    %ecx,%eax
    7275:	8b 00                	mov    (%eax),%eax
    7277:	39 c2                	cmp    %eax,%edx
    7279:	74 bc                	je     7237 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    727b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    727e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7285:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7288:	01 d0                	add    %edx,%eax
    728a:	8b 00                	mov    (%eax),%eax
    728c:	85 c0                	test   %eax,%eax
    728e:	0f 85 a9 00 00 00    	jne    733d <deflateDynamic+0x48a>
    7294:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    7298:	0f 86 9f 00 00 00    	jbe    733d <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    729e:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    72a2:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    72a6:	77 3a                	ja     72e2 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    72a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72ab:	8d 50 01             	lea    0x1(%eax),%edx
    72ae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72bb:	01 d0                	add    %edx,%eax
    72bd:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    72c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72c6:	8d 50 01             	lea    0x1(%eax),%edx
    72c9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72cc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72d6:	01 d0                	add    %edx,%eax
    72d8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    72db:	83 ea 03             	sub    $0x3,%edx
    72de:	89 10                	mov    %edx,(%eax)
    72e0:	eb 48                	jmp    732a <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    72e2:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    72e9:	76 07                	jbe    72f2 <deflateDynamic+0x43f>
    72eb:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    72f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72f5:	8d 50 01             	lea    0x1(%eax),%edx
    72f8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7302:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7305:	01 d0                	add    %edx,%eax
    7307:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    730d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7310:	8d 50 01             	lea    0x1(%eax),%edx
    7313:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7316:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    731d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7320:	01 d0                	add    %edx,%eax
    7322:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7325:	83 ea 0b             	sub    $0xb,%edx
    7328:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    732a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    732d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7330:	01 d0                	add    %edx,%eax
    7332:	83 e8 01             	sub    $0x1,%eax
    7335:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7338:	e9 28 01 00 00       	jmp    7465 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    733d:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    7341:	0f 86 f6 00 00 00    	jbe    743d <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    7347:	8b 45 dc             	mov    -0x24(%ebp),%eax
    734a:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    734f:	f7 e2                	mul    %edx
    7351:	89 d0                	mov    %edx,%eax
    7353:	c1 e8 02             	shr    $0x2,%eax
    7356:	89 45 ac             	mov    %eax,-0x54(%ebp)
    7359:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    735c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7361:	89 c8                	mov    %ecx,%eax
    7363:	f7 e2                	mul    %edx
    7365:	c1 ea 02             	shr    $0x2,%edx
    7368:	89 d0                	mov    %edx,%eax
    736a:	01 c0                	add    %eax,%eax
    736c:	01 d0                	add    %edx,%eax
    736e:	01 c0                	add    %eax,%eax
    7370:	29 c1                	sub    %eax,%ecx
    7372:	89 c8                	mov    %ecx,%eax
    7374:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7377:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    737a:	8d 50 01             	lea    0x1(%eax),%edx
    737d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7380:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7387:	8b 45 ec             	mov    -0x14(%ebp),%eax
    738a:	01 c2                	add    %eax,%edx
    738c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    738f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7396:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7399:	01 c8                	add    %ecx,%eax
    739b:	8b 00                	mov    (%eax),%eax
    739d:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    739f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    73a6:	eb 3a                	jmp    73e2 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    73a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73ab:	8d 50 01             	lea    0x1(%eax),%edx
    73ae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73bb:	01 d0                	add    %edx,%eax
    73bd:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    73c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73c6:	8d 50 01             	lea    0x1(%eax),%edx
    73c9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73cc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73d6:	01 d0                	add    %edx,%eax
    73d8:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    73de:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    73e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    73e5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    73e8:	72 be                	jb     73a8 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    73ea:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    73ee:	76 3a                	jbe    742a <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    73f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73f3:	8d 50 01             	lea    0x1(%eax),%edx
    73f6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7400:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7403:	01 d0                	add    %edx,%eax
    7405:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    740b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    740e:	8d 50 01             	lea    0x1(%eax),%edx
    7411:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7414:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    741b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    741e:	01 d0                	add    %edx,%eax
    7420:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7423:	83 ea 03             	sub    $0x3,%edx
    7426:	89 10                	mov    %edx,(%eax)
    7428:	eb 06                	jmp    7430 <deflateDynamic+0x57d>
        }
        else j -= rest;
    742a:	8b 45 a8             	mov    -0x58(%ebp),%eax
    742d:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7430:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7433:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7436:	01 d0                	add    %edx,%eax
    7438:	89 45 e8             	mov    %eax,-0x18(%ebp)
    743b:	eb 28                	jmp    7465 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    743d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7440:	8d 50 01             	lea    0x1(%eax),%edx
    7443:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7446:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    744d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7450:	01 c2                	add    %eax,%edx
    7452:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7455:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    745c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    745f:	01 c8                	add    %ecx,%eax
    7461:	8b 00                	mov    (%eax),%eax
    7463:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7465:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7469:	8b 45 e8             	mov    -0x18(%ebp),%eax
    746c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    746f:	0f 85 b9 fd ff ff    	jne    722e <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7475:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    747c:	eb 42                	jmp    74c0 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    747e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7481:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7488:	8b 45 ec             	mov    -0x14(%ebp),%eax
    748b:	01 d0                	add    %edx,%eax
    748d:	8b 00                	mov    (%eax),%eax
    748f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7496:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7499:	01 d0                	add    %edx,%eax
    749b:	8b 10                	mov    (%eax),%edx
    749d:	83 c2 01             	add    $0x1,%edx
    74a0:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    74a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    74af:	01 d0                	add    %edx,%eax
    74b1:	8b 00                	mov    (%eax),%eax
    74b3:	83 f8 0f             	cmp    $0xf,%eax
    74b6:	76 04                	jbe    74bc <deflateDynamic+0x609>
    74b8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    74bc:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    74c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74c3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    74c6:	75 b6                	jne    747e <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    74c8:	83 ec 0c             	sub    $0xc,%esp
    74cb:	6a 07                	push   $0x7
    74cd:	6a 13                	push   $0x13
    74cf:	6a 13                	push   $0x13
    74d1:	ff 75 cc             	pushl  -0x34(%ebp)
    74d4:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    74da:	50                   	push   %eax
    74db:	e8 fe dd ff ff       	call   52de <HuffmanTree_makeFromFrequencies>
    74e0:	83 c4 20             	add    $0x20,%esp
    74e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    74e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    74ea:	0f 85 8a 02 00 00    	jne    777a <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    74f0:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    74f7:	eb 04                	jmp    74fd <deflateDynamic+0x64a>
      numcodes_cl--;
    74f9:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    74fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7500:	83 f8 04             	cmp    $0x4,%eax
    7503:	76 1e                	jbe    7523 <deflateDynamic+0x670>
    7505:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    750b:	8b 55 e0             	mov    -0x20(%ebp),%edx
    750e:	83 ea 01             	sub    $0x1,%edx
    7511:	8b 14 95 20 a0 01 00 	mov    0x1a020(,%edx,4),%edx
    7518:	c1 e2 02             	shl    $0x2,%edx
    751b:	01 d0                	add    %edx,%eax
    751d:	8b 00                	mov    (%eax),%eax
    751f:	85 c0                	test   %eax,%eax
    7521:	74 d6                	je     74f9 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7523:	83 ec 04             	sub    $0x4,%esp
    7526:	6a 01                	push   $0x1
    7528:	ff 75 c4             	pushl  -0x3c(%ebp)
    752b:	ff 75 08             	pushl  0x8(%ebp)
    752e:	e8 67 c3 ff ff       	call   389a <writeBits>
    7533:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    7536:	83 ec 04             	sub    $0x4,%esp
    7539:	6a 01                	push   $0x1
    753b:	6a 00                	push   $0x0
    753d:	ff 75 08             	pushl  0x8(%ebp)
    7540:	e8 55 c3 ff ff       	call   389a <writeBits>
    7545:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    7548:	83 ec 04             	sub    $0x4,%esp
    754b:	6a 01                	push   $0x1
    754d:	6a 01                	push   $0x1
    754f:	ff 75 08             	pushl  0x8(%ebp)
    7552:	e8 43 c3 ff ff       	call   389a <writeBits>
    7557:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    755a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    755d:	2d 01 01 00 00       	sub    $0x101,%eax
    7562:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    7565:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7568:	83 e8 01             	sub    $0x1,%eax
    756b:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    756e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7571:	83 e8 04             	sub    $0x4,%eax
    7574:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    7577:	83 ec 04             	sub    $0x4,%esp
    757a:	6a 05                	push   $0x5
    757c:	ff 75 a4             	pushl  -0x5c(%ebp)
    757f:	ff 75 08             	pushl  0x8(%ebp)
    7582:	e8 13 c3 ff ff       	call   389a <writeBits>
    7587:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    758a:	83 ec 04             	sub    $0x4,%esp
    758d:	6a 05                	push   $0x5
    758f:	ff 75 a0             	pushl  -0x60(%ebp)
    7592:	ff 75 08             	pushl  0x8(%ebp)
    7595:	e8 00 c3 ff ff       	call   389a <writeBits>
    759a:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    759d:	83 ec 04             	sub    $0x4,%esp
    75a0:	6a 04                	push   $0x4
    75a2:	ff 75 9c             	pushl  -0x64(%ebp)
    75a5:	ff 75 08             	pushl  0x8(%ebp)
    75a8:	e8 ed c2 ff ff       	call   389a <writeBits>
    75ad:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    75b0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    75b7:	eb 2c                	jmp    75e5 <deflateDynamic+0x732>
    75b9:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    75bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75c2:	8b 04 85 20 a0 01 00 	mov    0x1a020(,%eax,4),%eax
    75c9:	c1 e0 02             	shl    $0x2,%eax
    75cc:	01 d0                	add    %edx,%eax
    75ce:	8b 00                	mov    (%eax),%eax
    75d0:	83 ec 04             	sub    $0x4,%esp
    75d3:	6a 03                	push   $0x3
    75d5:	50                   	push   %eax
    75d6:	ff 75 08             	pushl  0x8(%ebp)
    75d9:	e8 bc c2 ff ff       	call   389a <writeBits>
    75de:	83 c4 10             	add    $0x10,%esp
    75e1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75e8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    75eb:	75 cc                	jne    75b9 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    75ed:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    75f4:	e9 0a 01 00 00       	jmp    7703 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    75f9:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    75ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7602:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7609:	8b 55 ec             	mov    -0x14(%ebp),%edx
    760c:	01 ca                	add    %ecx,%edx
    760e:	8b 12                	mov    (%edx),%edx
    7610:	c1 e2 02             	shl    $0x2,%edx
    7613:	01 d0                	add    %edx,%eax
    7615:	8b 00                	mov    (%eax),%eax
    7617:	89 c3                	mov    %eax,%ebx
    7619:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    761f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7622:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7629:	8b 55 ec             	mov    -0x14(%ebp),%edx
    762c:	01 ca                	add    %ecx,%edx
    762e:	8b 12                	mov    (%edx),%edx
    7630:	c1 e2 02             	shl    $0x2,%edx
    7633:	01 d0                	add    %edx,%eax
    7635:	8b 00                	mov    (%eax),%eax
    7637:	83 ec 04             	sub    $0x4,%esp
    763a:	53                   	push   %ebx
    763b:	50                   	push   %eax
    763c:	ff 75 08             	pushl  0x8(%ebp)
    763f:	e8 ea c3 ff ff       	call   3a2e <writeBitsReversed>
    7644:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    7647:	8b 45 e8             	mov    -0x18(%ebp),%eax
    764a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7651:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7654:	01 d0                	add    %edx,%eax
    7656:	8b 00                	mov    (%eax),%eax
    7658:	83 f8 10             	cmp    $0x10,%eax
    765b:	75 28                	jne    7685 <deflateDynamic+0x7d2>
    765d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7661:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7664:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    766b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    766e:	01 d0                	add    %edx,%eax
    7670:	8b 00                	mov    (%eax),%eax
    7672:	83 ec 04             	sub    $0x4,%esp
    7675:	6a 02                	push   $0x2
    7677:	50                   	push   %eax
    7678:	ff 75 08             	pushl  0x8(%ebp)
    767b:	e8 1a c2 ff ff       	call   389a <writeBits>
    7680:	83 c4 10             	add    $0x10,%esp
    7683:	eb 7a                	jmp    76ff <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    7685:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7688:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    768f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7692:	01 d0                	add    %edx,%eax
    7694:	8b 00                	mov    (%eax),%eax
    7696:	83 f8 11             	cmp    $0x11,%eax
    7699:	75 28                	jne    76c3 <deflateDynamic+0x810>
    769b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    769f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76ac:	01 d0                	add    %edx,%eax
    76ae:	8b 00                	mov    (%eax),%eax
    76b0:	83 ec 04             	sub    $0x4,%esp
    76b3:	6a 03                	push   $0x3
    76b5:	50                   	push   %eax
    76b6:	ff 75 08             	pushl  0x8(%ebp)
    76b9:	e8 dc c1 ff ff       	call   389a <writeBits>
    76be:	83 c4 10             	add    $0x10,%esp
    76c1:	eb 3c                	jmp    76ff <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    76c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76c6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76d0:	01 d0                	add    %edx,%eax
    76d2:	8b 00                	mov    (%eax),%eax
    76d4:	83 f8 12             	cmp    $0x12,%eax
    76d7:	75 26                	jne    76ff <deflateDynamic+0x84c>
    76d9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76ea:	01 d0                	add    %edx,%eax
    76ec:	8b 00                	mov    (%eax),%eax
    76ee:	83 ec 04             	sub    $0x4,%esp
    76f1:	6a 07                	push   $0x7
    76f3:	50                   	push   %eax
    76f4:	ff 75 08             	pushl  0x8(%ebp)
    76f7:	e8 9e c1 ff ff       	call   389a <writeBits>
    76fc:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    76ff:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7703:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7706:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7709:	0f 85 ea fe ff ff    	jne    75f9 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    770f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7715:	50                   	push   %eax
    7716:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    771c:	50                   	push   %eax
    771d:	8d 45 90             	lea    -0x70(%ebp),%eax
    7720:	50                   	push   %eax
    7721:	ff 75 08             	pushl  0x8(%ebp)
    7724:	e8 4f f6 ff ff       	call   6d78 <writeLZ77data>
    7729:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    772c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7732:	05 00 04 00 00       	add    $0x400,%eax
    7737:	8b 00                	mov    (%eax),%eax
    7739:	85 c0                	test   %eax,%eax
    773b:	75 09                	jne    7746 <deflateDynamic+0x893>
    773d:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7744:	eb 35                	jmp    777b <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7746:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    774c:	05 00 04 00 00       	add    $0x400,%eax
    7751:	8b 00                	mov    (%eax),%eax
    7753:	89 c2                	mov    %eax,%edx
    7755:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    775b:	05 00 04 00 00       	add    $0x400,%eax
    7760:	8b 00                	mov    (%eax),%eax
    7762:	83 ec 04             	sub    $0x4,%esp
    7765:	52                   	push   %edx
    7766:	50                   	push   %eax
    7767:	ff 75 08             	pushl  0x8(%ebp)
    776a:	e8 bf c2 ff ff       	call   3a2e <writeBitsReversed>
    776f:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    7772:	eb 07                	jmp    777b <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    7774:	90                   	nop
    7775:	eb 04                	jmp    777b <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    7777:	90                   	nop
    7778:	eb 01                	jmp    777b <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    777a:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    777b:	83 ec 0c             	sub    $0xc,%esp
    777e:	8d 45 90             	lea    -0x70(%ebp),%eax
    7781:	50                   	push   %eax
    7782:	e8 73 bd ff ff       	call   34fa <uivector_cleanup>
    7787:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    778a:	83 ec 0c             	sub    $0xc,%esp
    778d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7793:	50                   	push   %eax
    7794:	e8 3a cb ff ff       	call   42d3 <HuffmanTree_cleanup>
    7799:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    779c:	83 ec 0c             	sub    $0xc,%esp
    779f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    77a5:	50                   	push   %eax
    77a6:	e8 28 cb ff ff       	call   42d3 <HuffmanTree_cleanup>
    77ab:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    77ae:	83 ec 0c             	sub    $0xc,%esp
    77b1:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    77b7:	50                   	push   %eax
    77b8:	e8 16 cb ff ff       	call   42d3 <HuffmanTree_cleanup>
    77bd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    77c0:	83 ec 0c             	sub    $0xc,%esp
    77c3:	ff 75 d4             	pushl  -0x2c(%ebp)
    77c6:	e8 08 bc ff ff       	call   33d3 <lodepng_free>
    77cb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    77ce:	83 ec 0c             	sub    $0xc,%esp
    77d1:	ff 75 d0             	pushl  -0x30(%ebp)
    77d4:	e8 fa bb ff ff       	call   33d3 <lodepng_free>
    77d9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    77dc:	83 ec 0c             	sub    $0xc,%esp
    77df:	ff 75 cc             	pushl  -0x34(%ebp)
    77e2:	e8 ec bb ff ff       	call   33d3 <lodepng_free>
    77e7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    77ea:	83 ec 0c             	sub    $0xc,%esp
    77ed:	ff 75 f0             	pushl  -0x10(%ebp)
    77f0:	e8 de bb ff ff       	call   33d3 <lodepng_free>
    77f5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    77f8:	83 ec 0c             	sub    $0xc,%esp
    77fb:	ff 75 ec             	pushl  -0x14(%ebp)
    77fe:	e8 d0 bb ff ff       	call   33d3 <lodepng_free>
    7803:	83 c4 10             	add    $0x10,%esp

  return error;
    7806:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7809:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    780c:	c9                   	leave  
    780d:	c3                   	ret    

0000780e <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    780e:	55                   	push   %ebp
    780f:	89 e5                	mov    %esp,%ebp
    7811:	53                   	push   %ebx
    7812:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7815:	8b 45 20             	mov    0x20(%ebp),%eax
    7818:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    781b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7822:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7825:	50                   	push   %eax
    7826:	e8 7b ca ff ff       	call   42a6 <HuffmanTree_init>
    782b:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    782e:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7831:	50                   	push   %eax
    7832:	e8 6f ca ff ff       	call   42a6 <HuffmanTree_init>
    7837:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    783a:	83 ec 0c             	sub    $0xc,%esp
    783d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7840:	50                   	push   %eax
    7841:	e8 41 db ff ff       	call   5387 <generateFixedLitLenTree>
    7846:	83 c4 10             	add    $0x10,%esp
    7849:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    784c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7850:	75 12                	jne    7864 <deflateFixed+0x56>
    7852:	83 ec 0c             	sub    $0xc,%esp
    7855:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7858:	50                   	push   %eax
    7859:	e8 30 dc ff ff       	call   548e <generateFixedDistanceTree>
    785e:	83 c4 10             	add    $0x10,%esp
    7861:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7864:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7868:	0f 85 3a 01 00 00    	jne    79a8 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    786e:	83 ec 04             	sub    $0x4,%esp
    7871:	6a 01                	push   $0x1
    7873:	ff 75 ec             	pushl  -0x14(%ebp)
    7876:	ff 75 08             	pushl  0x8(%ebp)
    7879:	e8 1c c0 ff ff       	call   389a <writeBits>
    787e:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    7881:	83 ec 04             	sub    $0x4,%esp
    7884:	6a 01                	push   $0x1
    7886:	6a 01                	push   $0x1
    7888:	ff 75 08             	pushl  0x8(%ebp)
    788b:	e8 0a c0 ff ff       	call   389a <writeBits>
    7890:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7893:	83 ec 04             	sub    $0x4,%esp
    7896:	6a 01                	push   $0x1
    7898:	6a 00                	push   $0x0
    789a:	ff 75 08             	pushl  0x8(%ebp)
    789d:	e8 f8 bf ff ff       	call   389a <writeBits>
    78a2:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    78a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78a8:	8b 40 04             	mov    0x4(%eax),%eax
    78ab:	85 c0                	test   %eax,%eax
    78ad:	74 77                	je     7926 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    78af:	83 ec 0c             	sub    $0xc,%esp
    78b2:	8d 45 b0             	lea    -0x50(%ebp),%eax
    78b5:	50                   	push   %eax
    78b6:	e8 e8 bc ff ff       	call   35a3 <uivector_init>
    78bb:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    78be:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78c1:	8b 58 14             	mov    0x14(%eax),%ebx
    78c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78c7:	8b 48 10             	mov    0x10(%eax),%ecx
    78ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78cd:	8b 50 0c             	mov    0xc(%eax),%edx
    78d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78d3:	8b 40 08             	mov    0x8(%eax),%eax
    78d6:	83 ec 0c             	sub    $0xc,%esp
    78d9:	53                   	push   %ebx
    78da:	51                   	push   %ecx
    78db:	52                   	push   %edx
    78dc:	50                   	push   %eax
    78dd:	ff 75 18             	pushl  0x18(%ebp)
    78e0:	ff 75 14             	pushl  0x14(%ebp)
    78e3:	ff 75 10             	pushl  0x10(%ebp)
    78e6:	ff 75 0c             	pushl  0xc(%ebp)
    78e9:	8d 45 b0             	lea    -0x50(%ebp),%eax
    78ec:	50                   	push   %eax
    78ed:	e8 c7 ed ff ff       	call   66b9 <encodeLZ77>
    78f2:	83 c4 30             	add    $0x30,%esp
    78f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    78f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    78fc:	75 17                	jne    7915 <deflateFixed+0x107>
    78fe:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7901:	50                   	push   %eax
    7902:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7905:	50                   	push   %eax
    7906:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7909:	50                   	push   %eax
    790a:	ff 75 08             	pushl  0x8(%ebp)
    790d:	e8 66 f4 ff ff       	call   6d78 <writeLZ77data>
    7912:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7915:	83 ec 0c             	sub    $0xc,%esp
    7918:	8d 45 b0             	lea    -0x50(%ebp),%eax
    791b:	50                   	push   %eax
    791c:	e8 d9 bb ff ff       	call   34fa <uivector_cleanup>
    7921:	83 c4 10             	add    $0x10,%esp
    7924:	eb 56                	jmp    797c <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7926:	8b 45 14             	mov    0x14(%ebp),%eax
    7929:	89 45 f0             	mov    %eax,-0x10(%ebp)
    792c:	eb 46                	jmp    7974 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    792e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7931:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7934:	8b 55 10             	mov    0x10(%ebp),%edx
    7937:	01 ca                	add    %ecx,%edx
    7939:	0f b6 12             	movzbl (%edx),%edx
    793c:	0f b6 d2             	movzbl %dl,%edx
    793f:	c1 e2 02             	shl    $0x2,%edx
    7942:	01 d0                	add    %edx,%eax
    7944:	8b 00                	mov    (%eax),%eax
    7946:	89 c3                	mov    %eax,%ebx
    7948:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    794b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    794e:	8b 55 10             	mov    0x10(%ebp),%edx
    7951:	01 ca                	add    %ecx,%edx
    7953:	0f b6 12             	movzbl (%edx),%edx
    7956:	0f b6 d2             	movzbl %dl,%edx
    7959:	c1 e2 02             	shl    $0x2,%edx
    795c:	01 d0                	add    %edx,%eax
    795e:	8b 00                	mov    (%eax),%eax
    7960:	83 ec 04             	sub    $0x4,%esp
    7963:	53                   	push   %ebx
    7964:	50                   	push   %eax
    7965:	ff 75 08             	pushl  0x8(%ebp)
    7968:	e8 c1 c0 ff ff       	call   3a2e <writeBitsReversed>
    796d:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7970:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7974:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7977:	3b 45 18             	cmp    0x18(%ebp),%eax
    797a:	7c b2                	jl     792e <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    797c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7980:	75 26                	jne    79a8 <deflateFixed+0x19a>
    7982:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7985:	05 00 04 00 00       	add    $0x400,%eax
    798a:	8b 00                	mov    (%eax),%eax
    798c:	89 c2                	mov    %eax,%edx
    798e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7991:	05 00 04 00 00       	add    $0x400,%eax
    7996:	8b 00                	mov    (%eax),%eax
    7998:	83 ec 04             	sub    $0x4,%esp
    799b:	52                   	push   %edx
    799c:	50                   	push   %eax
    799d:	ff 75 08             	pushl  0x8(%ebp)
    79a0:	e8 89 c0 ff ff       	call   3a2e <writeBitsReversed>
    79a5:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    79a8:	83 ec 0c             	sub    $0xc,%esp
    79ab:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    79ae:	50                   	push   %eax
    79af:	e8 1f c9 ff ff       	call   42d3 <HuffmanTree_cleanup>
    79b4:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    79b7:	83 ec 0c             	sub    $0xc,%esp
    79ba:	8d 45 bc             	lea    -0x44(%ebp),%eax
    79bd:	50                   	push   %eax
    79be:	e8 10 c9 ff ff       	call   42d3 <HuffmanTree_cleanup>
    79c3:	83 c4 10             	add    $0x10,%esp

  return error;
    79c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    79c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    79cc:	c9                   	leave  
    79cd:	c3                   	ret    

000079ce <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    79ce:	55                   	push   %ebp
    79cf:	89 e5                	mov    %esp,%ebp
    79d1:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    79d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    79db:	ff 75 08             	pushl  0x8(%ebp)
    79de:	8d 45 bc             	lea    -0x44(%ebp),%eax
    79e1:	50                   	push   %eax
    79e2:	e8 9e be ff ff       	call   3885 <LodePNGBitWriter_init>
    79e7:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    79ea:	8b 45 14             	mov    0x14(%ebp),%eax
    79ed:	8b 00                	mov    (%eax),%eax
    79ef:	83 f8 02             	cmp    $0x2,%eax
    79f2:	76 0a                	jbe    79fe <lodepng_deflatev+0x30>
    79f4:	b8 3d 00 00 00       	mov    $0x3d,%eax
    79f9:	e9 68 01 00 00       	jmp    7b66 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    79fe:	8b 45 14             	mov    0x14(%ebp),%eax
    7a01:	8b 00                	mov    (%eax),%eax
    7a03:	85 c0                	test   %eax,%eax
    7a05:	75 16                	jne    7a1d <lodepng_deflatev+0x4f>
    7a07:	ff 75 10             	pushl  0x10(%ebp)
    7a0a:	ff 75 0c             	pushl  0xc(%ebp)
    7a0d:	ff 75 08             	pushl  0x8(%ebp)
    7a10:	e8 01 f2 ff ff       	call   6c16 <deflateNoCompression>
    7a15:	83 c4 0c             	add    $0xc,%esp
    7a18:	e9 49 01 00 00       	jmp    7b66 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7a1d:	8b 45 14             	mov    0x14(%ebp),%eax
    7a20:	8b 00                	mov    (%eax),%eax
    7a22:	83 f8 01             	cmp    $0x1,%eax
    7a25:	75 08                	jne    7a2f <lodepng_deflatev+0x61>
    7a27:	8b 45 10             	mov    0x10(%ebp),%eax
    7a2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7a2d:	eb 2c                	jmp    7a5b <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7a2f:	8b 45 10             	mov    0x10(%ebp),%eax
    7a32:	c1 e8 03             	shr    $0x3,%eax
    7a35:	83 c0 08             	add    $0x8,%eax
    7a38:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7a3b:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7a42:	7f 07                	jg     7a4b <lodepng_deflatev+0x7d>
    7a44:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7a4b:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7a52:	7e 07                	jle    7a5b <lodepng_deflatev+0x8d>
    7a54:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7a5b:	8b 55 10             	mov    0x10(%ebp),%edx
    7a5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a61:	01 d0                	add    %edx,%eax
    7a63:	83 e8 01             	sub    $0x1,%eax
    7a66:	99                   	cltd   
    7a67:	f7 7d ec             	idivl  -0x14(%ebp)
    7a6a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7a6d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7a71:	75 07                	jne    7a7a <lodepng_deflatev+0xac>
    7a73:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7a7a:	8b 45 14             	mov    0x14(%ebp),%eax
    7a7d:	8b 40 08             	mov    0x8(%eax),%eax
    7a80:	83 ec 08             	sub    $0x8,%esp
    7a83:	50                   	push   %eax
    7a84:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a87:	50                   	push   %eax
    7a88:	e8 1c e8 ff ff       	call   62a9 <hash_init>
    7a8d:	83 c4 10             	add    $0x10,%esp
    7a90:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7a93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a97:	0f 85 b7 00 00 00    	jne    7b54 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7a9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7aa4:	e9 99 00 00 00       	jmp    7b42 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7aa9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7aac:	83 e8 01             	sub    $0x1,%eax
    7aaf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7ab2:	0f 94 c0             	sete   %al
    7ab5:	0f b6 c0             	movzbl %al,%eax
    7ab8:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7abb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7abe:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7ac2:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7ac5:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7ac8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7acb:	01 d0                	add    %edx,%eax
    7acd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7ad0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ad3:	3b 45 10             	cmp    0x10(%ebp),%eax
    7ad6:	7e 06                	jle    7ade <lodepng_deflatev+0x110>
    7ad8:	8b 45 10             	mov    0x10(%ebp),%eax
    7adb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7ade:	8b 45 14             	mov    0x14(%ebp),%eax
    7ae1:	8b 00                	mov    (%eax),%eax
    7ae3:	83 f8 01             	cmp    $0x1,%eax
    7ae6:	75 27                	jne    7b0f <lodepng_deflatev+0x141>
    7ae8:	83 ec 04             	sub    $0x4,%esp
    7aeb:	ff 75 e0             	pushl  -0x20(%ebp)
    7aee:	ff 75 14             	pushl  0x14(%ebp)
    7af1:	ff 75 e4             	pushl  -0x1c(%ebp)
    7af4:	ff 75 dc             	pushl  -0x24(%ebp)
    7af7:	ff 75 0c             	pushl  0xc(%ebp)
    7afa:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7afd:	50                   	push   %eax
    7afe:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b01:	50                   	push   %eax
    7b02:	e8 07 fd ff ff       	call   780e <deflateFixed>
    7b07:	83 c4 20             	add    $0x20,%esp
    7b0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7b0d:	eb 2f                	jmp    7b3e <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7b0f:	8b 45 14             	mov    0x14(%ebp),%eax
    7b12:	8b 00                	mov    (%eax),%eax
    7b14:	83 f8 02             	cmp    $0x2,%eax
    7b17:	75 25                	jne    7b3e <lodepng_deflatev+0x170>
    7b19:	83 ec 04             	sub    $0x4,%esp
    7b1c:	ff 75 e0             	pushl  -0x20(%ebp)
    7b1f:	ff 75 14             	pushl  0x14(%ebp)
    7b22:	ff 75 e4             	pushl  -0x1c(%ebp)
    7b25:	ff 75 dc             	pushl  -0x24(%ebp)
    7b28:	ff 75 0c             	pushl  0xc(%ebp)
    7b2b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b2e:	50                   	push   %eax
    7b2f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b32:	50                   	push   %eax
    7b33:	e8 7b f3 ff ff       	call   6eb3 <deflateDynamic>
    7b38:	83 c4 20             	add    $0x20,%esp
    7b3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7b3e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7b42:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7b45:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7b48:	74 0a                	je     7b54 <lodepng_deflatev+0x186>
    7b4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b4e:	0f 84 55 ff ff ff    	je     7aa9 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7b54:	83 ec 0c             	sub    $0xc,%esp
    7b57:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b5a:	50                   	push   %eax
    7b5b:	e8 08 e9 ff ff       	call   6468 <hash_cleanup>
    7b60:	83 c4 10             	add    $0x10,%esp

  return error;
    7b63:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7b66:	c9                   	leave  
    7b67:	c3                   	ret    

00007b68 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7b68:	55                   	push   %ebp
    7b69:	89 e5                	mov    %esp,%ebp
    7b6b:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7b6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b71:	8b 08                	mov    (%eax),%ecx
    7b73:	8b 45 08             	mov    0x8(%ebp),%eax
    7b76:	8b 10                	mov    (%eax),%edx
    7b78:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7b7b:	51                   	push   %ecx
    7b7c:	52                   	push   %edx
    7b7d:	50                   	push   %eax
    7b7e:	e8 f0 ba ff ff       	call   3673 <ucvector_init>
    7b83:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7b86:	ff 75 18             	pushl  0x18(%ebp)
    7b89:	ff 75 14             	pushl  0x14(%ebp)
    7b8c:	ff 75 10             	pushl  0x10(%ebp)
    7b8f:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7b92:	50                   	push   %eax
    7b93:	e8 36 fe ff ff       	call   79ce <lodepng_deflatev>
    7b98:	83 c4 10             	add    $0x10,%esp
    7b9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7b9e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ba1:	8b 45 08             	mov    0x8(%ebp),%eax
    7ba4:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7ba6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7ba9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bac:	89 10                	mov    %edx,(%eax)
  return error;
    7bae:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7bb1:	c9                   	leave  
    7bb2:	c3                   	ret    

00007bb3 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7bb3:	55                   	push   %ebp
    7bb4:	89 e5                	mov    %esp,%ebp
    7bb6:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7bb9:	8b 45 18             	mov    0x18(%ebp),%eax
    7bbc:	8b 40 1c             	mov    0x1c(%eax),%eax
    7bbf:	85 c0                	test   %eax,%eax
    7bc1:	74 34                	je     7bf7 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7bc3:	8b 45 18             	mov    0x18(%ebp),%eax
    7bc6:	8b 40 1c             	mov    0x1c(%eax),%eax
    7bc9:	83 ec 0c             	sub    $0xc,%esp
    7bcc:	ff 75 18             	pushl  0x18(%ebp)
    7bcf:	ff 75 14             	pushl  0x14(%ebp)
    7bd2:	ff 75 10             	pushl  0x10(%ebp)
    7bd5:	ff 75 0c             	pushl  0xc(%ebp)
    7bd8:	ff 75 08             	pushl  0x8(%ebp)
    7bdb:	ff d0                	call   *%eax
    7bdd:	83 c4 20             	add    $0x20,%esp
    7be0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7be3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7be7:	74 07                	je     7bf0 <deflate+0x3d>
    7be9:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7bee:	eb 21                	jmp    7c11 <deflate+0x5e>
    7bf0:	b8 00 00 00 00       	mov    $0x0,%eax
    7bf5:	eb 1a                	jmp    7c11 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7bf7:	83 ec 0c             	sub    $0xc,%esp
    7bfa:	ff 75 18             	pushl  0x18(%ebp)
    7bfd:	ff 75 14             	pushl  0x14(%ebp)
    7c00:	ff 75 10             	pushl  0x10(%ebp)
    7c03:	ff 75 0c             	pushl  0xc(%ebp)
    7c06:	ff 75 08             	pushl  0x8(%ebp)
    7c09:	e8 5a ff ff ff       	call   7b68 <lodepng_deflate>
    7c0e:	83 c4 20             	add    $0x20,%esp
  }
}
    7c11:	c9                   	leave  
    7c12:	c3                   	ret    

00007c13 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7c13:	55                   	push   %ebp
    7c14:	89 e5                	mov    %esp,%ebp
    7c16:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7c19:	8b 45 08             	mov    0x8(%ebp),%eax
    7c1c:	0f b7 c0             	movzwl %ax,%eax
    7c1f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7c22:	8b 45 08             	mov    0x8(%ebp),%eax
    7c25:	c1 e8 10             	shr    $0x10,%eax
    7c28:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7c2b:	e9 82 00 00 00       	jmp    7cb2 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7c30:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7c35:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7c3c:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c46:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7c49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7c50:	eb 1c                	jmp    7c6e <update_adler32+0x5b>
      s1 += (*data++);
    7c52:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c55:	8d 50 01             	lea    0x1(%eax),%edx
    7c58:	89 55 0c             	mov    %edx,0xc(%ebp)
    7c5b:	0f b6 00             	movzbl (%eax),%eax
    7c5e:	0f b6 c0             	movzbl %al,%eax
    7c61:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7c64:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7c67:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7c6a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7c6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7c71:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7c74:	75 dc                	jne    7c52 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7c76:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7c79:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c7e:	89 c8                	mov    %ecx,%eax
    7c80:	f7 e2                	mul    %edx
    7c82:	89 d0                	mov    %edx,%eax
    7c84:	c1 e8 0f             	shr    $0xf,%eax
    7c87:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c8d:	29 c1                	sub    %eax,%ecx
    7c8f:	89 c8                	mov    %ecx,%eax
    7c91:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7c94:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7c97:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c9c:	89 c8                	mov    %ecx,%eax
    7c9e:	f7 e2                	mul    %edx
    7ca0:	89 d0                	mov    %edx,%eax
    7ca2:	c1 e8 0f             	shr    $0xf,%eax
    7ca5:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7cab:	29 c1                	sub    %eax,%ecx
    7cad:	89 c8                	mov    %ecx,%eax
    7caf:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7cb2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7cb6:	0f 85 74 ff ff ff    	jne    7c30 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7cbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7cbf:	c1 e0 10             	shl    $0x10,%eax
    7cc2:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7cc5:	c9                   	leave  
    7cc6:	c3                   	ret    

00007cc7 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7cc7:	55                   	push   %ebp
    7cc8:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7cca:	ff 75 0c             	pushl  0xc(%ebp)
    7ccd:	ff 75 08             	pushl  0x8(%ebp)
    7cd0:	6a 01                	push   $0x1
    7cd2:	e8 3c ff ff ff       	call   7c13 <update_adler32>
    7cd7:	83 c4 0c             	add    $0xc,%esp
}
    7cda:	c9                   	leave  
    7cdb:	c3                   	ret    

00007cdc <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7cdc:	55                   	push   %ebp
    7cdd:	89 e5                	mov    %esp,%ebp
    7cdf:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7ce2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7ce9:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7ced:	7f 0a                	jg     7cf9 <lodepng_zlib_decompressv+0x1d>
    7cef:	b8 35 00 00 00       	mov    $0x35,%eax
    7cf4:	e9 27 01 00 00       	jmp    7e20 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cfc:	0f b6 00             	movzbl (%eax),%eax
    7cff:	0f b6 c0             	movzbl %al,%eax
    7d02:	c1 e0 08             	shl    $0x8,%eax
    7d05:	89 c2                	mov    %eax,%edx
    7d07:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d0a:	83 c0 01             	add    $0x1,%eax
    7d0d:	0f b6 00             	movzbl (%eax),%eax
    7d10:	0f b6 c0             	movzbl %al,%eax
    7d13:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7d16:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7d1b:	89 c8                	mov    %ecx,%eax
    7d1d:	f7 ea                	imul   %edx
    7d1f:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7d22:	c1 f8 04             	sar    $0x4,%eax
    7d25:	89 c2                	mov    %eax,%edx
    7d27:	89 c8                	mov    %ecx,%eax
    7d29:	c1 f8 1f             	sar    $0x1f,%eax
    7d2c:	29 c2                	sub    %eax,%edx
    7d2e:	89 d0                	mov    %edx,%eax
    7d30:	89 c2                	mov    %eax,%edx
    7d32:	c1 e2 05             	shl    $0x5,%edx
    7d35:	29 c2                	sub    %eax,%edx
    7d37:	89 c8                	mov    %ecx,%eax
    7d39:	29 d0                	sub    %edx,%eax
    7d3b:	85 c0                	test   %eax,%eax
    7d3d:	74 0a                	je     7d49 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7d3f:	b8 18 00 00 00       	mov    $0x18,%eax
    7d44:	e9 d7 00 00 00       	jmp    7e20 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7d49:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d4c:	0f b6 00             	movzbl (%eax),%eax
    7d4f:	0f b6 c0             	movzbl %al,%eax
    7d52:	83 e0 0f             	and    $0xf,%eax
    7d55:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7d58:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d5b:	0f b6 00             	movzbl (%eax),%eax
    7d5e:	c0 e8 04             	shr    $0x4,%al
    7d61:	0f b6 c0             	movzbl %al,%eax
    7d64:	83 e0 0f             	and    $0xf,%eax
    7d67:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d6d:	83 c0 01             	add    $0x1,%eax
    7d70:	0f b6 00             	movzbl (%eax),%eax
    7d73:	c0 e8 05             	shr    $0x5,%al
    7d76:	0f b6 c0             	movzbl %al,%eax
    7d79:	83 e0 01             	and    $0x1,%eax
    7d7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7d7f:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7d83:	75 06                	jne    7d8b <lodepng_zlib_decompressv+0xaf>
    7d85:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7d89:	76 0a                	jbe    7d95 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7d8b:	b8 19 00 00 00       	mov    $0x19,%eax
    7d90:	e9 8b 00 00 00       	jmp    7e20 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7d95:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7d99:	74 07                	je     7da2 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7d9b:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7da0:	eb 7e                	jmp    7e20 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7da2:	8b 45 10             	mov    0x10(%ebp),%eax
    7da5:	8d 50 fe             	lea    -0x2(%eax),%edx
    7da8:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dab:	83 c0 02             	add    $0x2,%eax
    7dae:	ff 75 14             	pushl  0x14(%ebp)
    7db1:	52                   	push   %edx
    7db2:	50                   	push   %eax
    7db3:	ff 75 08             	pushl  0x8(%ebp)
    7db6:	e8 09 e3 ff ff       	call   60c4 <inflatev>
    7dbb:	83 c4 10             	add    $0x10,%esp
    7dbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7dc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7dc5:	74 05                	je     7dcc <lodepng_zlib_decompressv+0xf0>
    7dc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7dca:	eb 54                	jmp    7e20 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7dcc:	8b 45 14             	mov    0x14(%ebp),%eax
    7dcf:	8b 00                	mov    (%eax),%eax
    7dd1:	85 c0                	test   %eax,%eax
    7dd3:	75 46                	jne    7e1b <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7dd5:	8b 45 10             	mov    0x10(%ebp),%eax
    7dd8:	8d 50 fc             	lea    -0x4(%eax),%edx
    7ddb:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dde:	01 d0                	add    %edx,%eax
    7de0:	83 ec 0c             	sub    $0xc,%esp
    7de3:	50                   	push   %eax
    7de4:	e8 47 b9 ff ff       	call   3730 <lodepng_read32bitInt>
    7de9:	83 c4 10             	add    $0x10,%esp
    7dec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7def:	8b 45 08             	mov    0x8(%ebp),%eax
    7df2:	8b 40 04             	mov    0x4(%eax),%eax
    7df5:	89 c2                	mov    %eax,%edx
    7df7:	8b 45 08             	mov    0x8(%ebp),%eax
    7dfa:	8b 00                	mov    (%eax),%eax
    7dfc:	83 ec 08             	sub    $0x8,%esp
    7dff:	52                   	push   %edx
    7e00:	50                   	push   %eax
    7e01:	e8 c1 fe ff ff       	call   7cc7 <adler32>
    7e06:	83 c4 10             	add    $0x10,%esp
    7e09:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7e0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7e0f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7e12:	74 07                	je     7e1b <lodepng_zlib_decompressv+0x13f>
    7e14:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7e19:	eb 05                	jmp    7e20 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7e1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7e20:	c9                   	leave  
    7e21:	c3                   	ret    

00007e22 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7e22:	55                   	push   %ebp
    7e23:	89 e5                	mov    %esp,%ebp
    7e25:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7e28:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e2b:	8b 08                	mov    (%eax),%ecx
    7e2d:	8b 45 08             	mov    0x8(%ebp),%eax
    7e30:	8b 10                	mov    (%eax),%edx
    7e32:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e35:	51                   	push   %ecx
    7e36:	52                   	push   %edx
    7e37:	50                   	push   %eax
    7e38:	e8 36 b8 ff ff       	call   3673 <ucvector_init>
    7e3d:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7e40:	ff 75 18             	pushl  0x18(%ebp)
    7e43:	ff 75 14             	pushl  0x14(%ebp)
    7e46:	ff 75 10             	pushl  0x10(%ebp)
    7e49:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e4c:	50                   	push   %eax
    7e4d:	e8 8a fe ff ff       	call   7cdc <lodepng_zlib_decompressv>
    7e52:	83 c4 10             	add    $0x10,%esp
    7e55:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7e58:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7e5b:	8b 45 08             	mov    0x8(%ebp),%eax
    7e5e:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7e60:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7e63:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e66:	89 10                	mov    %edx,(%eax)
  return error;
    7e68:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7e6b:	c9                   	leave  
    7e6c:	c3                   	ret    

00007e6d <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7e6d:	55                   	push   %ebp
    7e6e:	89 e5                	mov    %esp,%ebp
    7e70:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7e73:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e76:	8b 40 0c             	mov    0xc(%eax),%eax
    7e79:	85 c0                	test   %eax,%eax
    7e7b:	74 57                	je     7ed4 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7e7d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e80:	8b 40 0c             	mov    0xc(%eax),%eax
    7e83:	83 ec 0c             	sub    $0xc,%esp
    7e86:	ff 75 1c             	pushl  0x1c(%ebp)
    7e89:	ff 75 18             	pushl  0x18(%ebp)
    7e8c:	ff 75 14             	pushl  0x14(%ebp)
    7e8f:	ff 75 0c             	pushl  0xc(%ebp)
    7e92:	ff 75 08             	pushl  0x8(%ebp)
    7e95:	ff d0                	call   *%eax
    7e97:	83 c4 20             	add    $0x20,%esp
    7e9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7e9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ea1:	0f 84 98 00 00 00    	je     7f3f <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7ea7:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7eae:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7eb1:	8b 40 08             	mov    0x8(%eax),%eax
    7eb4:	85 c0                	test   %eax,%eax
    7eb6:	0f 84 83 00 00 00    	je     7f3f <zlib_decompress+0xd2>
    7ebc:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ebf:	8b 10                	mov    (%eax),%edx
    7ec1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ec4:	8b 40 08             	mov    0x8(%eax),%eax
    7ec7:	39 c2                	cmp    %eax,%edx
    7ec9:	7e 74                	jle    7f3f <zlib_decompress+0xd2>
    7ecb:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7ed2:	eb 6b                	jmp    7f3f <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7ed4:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ed7:	8b 08                	mov    (%eax),%ecx
    7ed9:	8b 45 08             	mov    0x8(%ebp),%eax
    7edc:	8b 10                	mov    (%eax),%edx
    7ede:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7ee1:	83 ec 04             	sub    $0x4,%esp
    7ee4:	51                   	push   %ecx
    7ee5:	52                   	push   %edx
    7ee6:	50                   	push   %eax
    7ee7:	e8 87 b7 ff ff       	call   3673 <ucvector_init>
    7eec:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7eef:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7ef3:	74 22                	je     7f17 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7ef5:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ef8:	8b 10                	mov    (%eax),%edx
    7efa:	8b 45 10             	mov    0x10(%ebp),%eax
    7efd:	01 d0                	add    %edx,%eax
    7eff:	83 ec 08             	sub    $0x8,%esp
    7f02:	50                   	push   %eax
    7f03:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f06:	50                   	push   %eax
    7f07:	e8 00 b7 ff ff       	call   360c <ucvector_resize>
    7f0c:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7f0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f12:	8b 00                	mov    (%eax),%eax
    7f14:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7f17:	ff 75 1c             	pushl  0x1c(%ebp)
    7f1a:	ff 75 18             	pushl  0x18(%ebp)
    7f1d:	ff 75 14             	pushl  0x14(%ebp)
    7f20:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f23:	50                   	push   %eax
    7f24:	e8 b3 fd ff ff       	call   7cdc <lodepng_zlib_decompressv>
    7f29:	83 c4 10             	add    $0x10,%esp
    7f2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7f2f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7f32:	8b 45 08             	mov    0x8(%ebp),%eax
    7f35:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7f37:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7f3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f3d:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7f3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7f42:	c9                   	leave  
    7f43:	c3                   	ret    

00007f44 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7f44:	55                   	push   %ebp
    7f45:	89 e5                	mov    %esp,%ebp
    7f47:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7f4a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7f51:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7f58:	83 ec 0c             	sub    $0xc,%esp
    7f5b:	ff 75 18             	pushl  0x18(%ebp)
    7f5e:	ff 75 14             	pushl  0x14(%ebp)
    7f61:	ff 75 10             	pushl  0x10(%ebp)
    7f64:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7f67:	50                   	push   %eax
    7f68:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7f6b:	50                   	push   %eax
    7f6c:	e8 42 fc ff ff       	call   7bb3 <deflate>
    7f71:	83 c4 20             	add    $0x20,%esp
    7f74:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7f77:	8b 45 08             	mov    0x8(%ebp),%eax
    7f7a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7f80:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f83:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7f89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f8d:	75 33                	jne    7fc2 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7f8f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f92:	8d 50 06             	lea    0x6(%eax),%edx
    7f95:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f98:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7f9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f9d:	8b 00                	mov    (%eax),%eax
    7f9f:	83 ec 0c             	sub    $0xc,%esp
    7fa2:	50                   	push   %eax
    7fa3:	e8 0a b4 ff ff       	call   33b2 <lodepng_malloc>
    7fa8:	83 c4 10             	add    $0x10,%esp
    7fab:	89 c2                	mov    %eax,%edx
    7fad:	8b 45 08             	mov    0x8(%ebp),%eax
    7fb0:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    7fb2:	8b 45 08             	mov    0x8(%ebp),%eax
    7fb5:	8b 00                	mov    (%eax),%eax
    7fb7:	85 c0                	test   %eax,%eax
    7fb9:	75 07                	jne    7fc2 <lodepng_zlib_compress+0x7e>
    7fbb:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    7fc2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7fc6:	0f 85 e2 00 00 00    	jne    80ae <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    7fcc:	8b 45 14             	mov    0x14(%ebp),%eax
    7fcf:	83 ec 08             	sub    $0x8,%esp
    7fd2:	50                   	push   %eax
    7fd3:	ff 75 10             	pushl  0x10(%ebp)
    7fd6:	e8 ec fc ff ff       	call   7cc7 <adler32>
    7fdb:	83 c4 10             	add    $0x10,%esp
    7fde:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    7fe1:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    7fe8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    7fef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    7ff6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7ff9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8000:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8003:	01 d0                	add    %edx,%eax
    8005:	8d 14 00             	lea    (%eax,%eax,1),%edx
    8008:	8b 45 e0             	mov    -0x20(%ebp),%eax
    800b:	01 d0                	add    %edx,%eax
    800d:	c1 e0 05             	shl    $0x5,%eax
    8010:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8013:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    8016:	ba 85 10 42 08       	mov    $0x8421085,%edx
    801b:	89 c8                	mov    %ecx,%eax
    801d:	f7 e2                	mul    %edx
    801f:	89 c8                	mov    %ecx,%eax
    8021:	29 d0                	sub    %edx,%eax
    8023:	d1 e8                	shr    %eax
    8025:	01 d0                	add    %edx,%eax
    8027:	c1 e8 04             	shr    $0x4,%eax
    802a:	89 c2                	mov    %eax,%edx
    802c:	c1 e2 05             	shl    $0x5,%edx
    802f:	29 c2                	sub    %eax,%edx
    8031:	89 c8                	mov    %ecx,%eax
    8033:	29 d0                	sub    %edx,%eax
    8035:	ba 1f 00 00 00       	mov    $0x1f,%edx
    803a:	29 c2                	sub    %eax,%edx
    803c:	89 d0                	mov    %edx,%eax
    803e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    8041:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8044:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    8047:	8b 45 08             	mov    0x8(%ebp),%eax
    804a:	8b 00                	mov    (%eax),%eax
    804c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    804f:	c1 ea 08             	shr    $0x8,%edx
    8052:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    8054:	8b 45 08             	mov    0x8(%ebp),%eax
    8057:	8b 00                	mov    (%eax),%eax
    8059:	83 c0 01             	add    $0x1,%eax
    805c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    805f:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    8061:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8068:	eb 1e                	jmp    8088 <lodepng_zlib_compress+0x144>
    806a:	8b 45 08             	mov    0x8(%ebp),%eax
    806d:	8b 00                	mov    (%eax),%eax
    806f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8072:	83 c2 02             	add    $0x2,%edx
    8075:	01 c2                	add    %eax,%edx
    8077:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    807a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    807d:	01 c8                	add    %ecx,%eax
    807f:	0f b6 00             	movzbl (%eax),%eax
    8082:	88 02                	mov    %al,(%edx)
    8084:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8088:	8b 45 d0             	mov    -0x30(%ebp),%eax
    808b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    808e:	75 da                	jne    806a <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    8090:	8b 45 08             	mov    0x8(%ebp),%eax
    8093:	8b 10                	mov    (%eax),%edx
    8095:	8b 45 0c             	mov    0xc(%ebp),%eax
    8098:	8b 00                	mov    (%eax),%eax
    809a:	83 e8 04             	sub    $0x4,%eax
    809d:	01 d0                	add    %edx,%eax
    809f:	83 ec 08             	sub    $0x8,%esp
    80a2:	ff 75 ec             	pushl  -0x14(%ebp)
    80a5:	50                   	push   %eax
    80a6:	e8 c8 b6 ff ff       	call   3773 <lodepng_set32bitInt>
    80ab:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    80ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    80b1:	83 ec 0c             	sub    $0xc,%esp
    80b4:	50                   	push   %eax
    80b5:	e8 19 b3 ff ff       	call   33d3 <lodepng_free>
    80ba:	83 c4 10             	add    $0x10,%esp
  return error;
    80bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    80c0:	c9                   	leave  
    80c1:	c3                   	ret    

000080c2 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    80c2:	55                   	push   %ebp
    80c3:	89 e5                	mov    %esp,%ebp
    80c5:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    80c8:	8b 45 18             	mov    0x18(%ebp),%eax
    80cb:	8b 40 18             	mov    0x18(%eax),%eax
    80ce:	85 c0                	test   %eax,%eax
    80d0:	74 34                	je     8106 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    80d2:	8b 45 18             	mov    0x18(%ebp),%eax
    80d5:	8b 40 18             	mov    0x18(%eax),%eax
    80d8:	83 ec 0c             	sub    $0xc,%esp
    80db:	ff 75 18             	pushl  0x18(%ebp)
    80de:	ff 75 14             	pushl  0x14(%ebp)
    80e1:	ff 75 10             	pushl  0x10(%ebp)
    80e4:	ff 75 0c             	pushl  0xc(%ebp)
    80e7:	ff 75 08             	pushl  0x8(%ebp)
    80ea:	ff d0                	call   *%eax
    80ec:	83 c4 20             	add    $0x20,%esp
    80ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    80f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    80f6:	74 07                	je     80ff <zlib_compress+0x3d>
    80f8:	b8 6f 00 00 00       	mov    $0x6f,%eax
    80fd:	eb 21                	jmp    8120 <zlib_compress+0x5e>
    80ff:	b8 00 00 00 00       	mov    $0x0,%eax
    8104:	eb 1a                	jmp    8120 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8106:	83 ec 0c             	sub    $0xc,%esp
    8109:	ff 75 18             	pushl  0x18(%ebp)
    810c:	ff 75 14             	pushl  0x14(%ebp)
    810f:	ff 75 10             	pushl  0x10(%ebp)
    8112:	ff 75 0c             	pushl  0xc(%ebp)
    8115:	ff 75 08             	pushl  0x8(%ebp)
    8118:	e8 27 fe ff ff       	call   7f44 <lodepng_zlib_compress>
    811d:	83 c4 20             	add    $0x20,%esp
  }
}
    8120:	c9                   	leave  
    8121:	c3                   	ret    

00008122 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8122:	55                   	push   %ebp
    8123:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8125:	8b 45 08             	mov    0x8(%ebp),%eax
    8128:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    812e:	8b 45 08             	mov    0x8(%ebp),%eax
    8131:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    8138:	8b 45 08             	mov    0x8(%ebp),%eax
    813b:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8142:	8b 45 08             	mov    0x8(%ebp),%eax
    8145:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    814c:	8b 45 08             	mov    0x8(%ebp),%eax
    814f:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    8156:	8b 45 08             	mov    0x8(%ebp),%eax
    8159:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    8160:	8b 45 08             	mov    0x8(%ebp),%eax
    8163:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    816a:	8b 45 08             	mov    0x8(%ebp),%eax
    816d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    8174:	8b 45 08             	mov    0x8(%ebp),%eax
    8177:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    817e:	90                   	nop
    817f:	5d                   	pop    %ebp
    8180:	c3                   	ret    

00008181 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    8181:	55                   	push   %ebp
    8182:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    8184:	8b 45 08             	mov    0x8(%ebp),%eax
    8187:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    818d:	8b 45 08             	mov    0x8(%ebp),%eax
    8190:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    8197:	8b 45 08             	mov    0x8(%ebp),%eax
    819a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    81a1:	8b 45 08             	mov    0x8(%ebp),%eax
    81a4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    81ab:	8b 45 08             	mov    0x8(%ebp),%eax
    81ae:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    81b5:	8b 45 08             	mov    0x8(%ebp),%eax
    81b8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    81bf:	90                   	nop
    81c0:	5d                   	pop    %ebp
    81c1:	c3                   	ret    

000081c2 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    81c2:	55                   	push   %ebp
    81c3:	89 e5                	mov    %esp,%ebp
    81c5:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    81c8:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    81cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    81d6:	eb 2a                	jmp    8202 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    81d8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    81db:	8b 45 08             	mov    0x8(%ebp),%eax
    81de:	01 d0                	add    %edx,%eax
    81e0:	0f b6 00             	movzbl (%eax),%eax
    81e3:	0f b6 c0             	movzbl %al,%eax
    81e6:	33 45 fc             	xor    -0x4(%ebp),%eax
    81e9:	0f b6 c0             	movzbl %al,%eax
    81ec:	8b 04 85 00 e2 01 00 	mov    0x1e200(,%eax,4),%eax
    81f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    81f6:	c1 ea 08             	shr    $0x8,%edx
    81f9:	31 d0                	xor    %edx,%eax
    81fb:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    81fe:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8202:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8205:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8208:	7c ce                	jl     81d8 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    820a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    820d:	f7 d0                	not    %eax
}
    820f:	c9                   	leave  
    8210:	c3                   	ret    

00008211 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8211:	55                   	push   %ebp
    8212:	89 e5                	mov    %esp,%ebp
    8214:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    8217:	8b 45 08             	mov    0x8(%ebp),%eax
    821a:	8b 00                	mov    (%eax),%eax
    821c:	c1 f8 03             	sar    $0x3,%eax
    821f:	89 c2                	mov    %eax,%edx
    8221:	8b 45 0c             	mov    0xc(%ebp),%eax
    8224:	01 d0                	add    %edx,%eax
    8226:	0f b6 00             	movzbl (%eax),%eax
    8229:	0f b6 d0             	movzbl %al,%edx
    822c:	8b 45 08             	mov    0x8(%ebp),%eax
    822f:	8b 00                	mov    (%eax),%eax
    8231:	f7 d0                	not    %eax
    8233:	83 e0 07             	and    $0x7,%eax
    8236:	89 c1                	mov    %eax,%ecx
    8238:	d3 fa                	sar    %cl,%edx
    823a:	89 d0                	mov    %edx,%eax
    823c:	83 e0 01             	and    $0x1,%eax
    823f:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8242:	8b 45 08             	mov    0x8(%ebp),%eax
    8245:	8b 00                	mov    (%eax),%eax
    8247:	8d 50 01             	lea    0x1(%eax),%edx
    824a:	8b 45 08             	mov    0x8(%ebp),%eax
    824d:	89 10                	mov    %edx,(%eax)
  return result;
    824f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    8253:	c9                   	leave  
    8254:	c3                   	ret    

00008255 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    8255:	55                   	push   %ebp
    8256:	89 e5                	mov    %esp,%ebp
    8258:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    825b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8262:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8269:	eb 1b                	jmp    8286 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    826b:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    826e:	ff 75 0c             	pushl  0xc(%ebp)
    8271:	ff 75 08             	pushl  0x8(%ebp)
    8274:	e8 98 ff ff ff       	call   8211 <readBitFromReversedStream>
    8279:	83 c4 08             	add    $0x8,%esp
    827c:	0f b6 c0             	movzbl %al,%eax
    827f:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8282:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8286:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8289:	3b 45 10             	cmp    0x10(%ebp),%eax
    828c:	7c dd                	jl     826b <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    828e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8291:	c9                   	leave  
    8292:	c3                   	ret    

00008293 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    8293:	55                   	push   %ebp
    8294:	89 e5                	mov    %esp,%ebp
    8296:	56                   	push   %esi
    8297:	53                   	push   %ebx
    8298:	83 ec 04             	sub    $0x4,%esp
    829b:	8b 45 10             	mov    0x10(%ebp),%eax
    829e:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    82a1:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    82a5:	75 3e                	jne    82e5 <setBitOfReversedStream+0x52>
    82a7:	8b 45 08             	mov    0x8(%ebp),%eax
    82aa:	8b 00                	mov    (%eax),%eax
    82ac:	c1 f8 03             	sar    $0x3,%eax
    82af:	89 c2                	mov    %eax,%edx
    82b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    82b4:	01 c2                	add    %eax,%edx
    82b6:	8b 45 08             	mov    0x8(%ebp),%eax
    82b9:	8b 00                	mov    (%eax),%eax
    82bb:	c1 f8 03             	sar    $0x3,%eax
    82be:	89 c1                	mov    %eax,%ecx
    82c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    82c3:	01 c8                	add    %ecx,%eax
    82c5:	0f b6 18             	movzbl (%eax),%ebx
    82c8:	8b 45 08             	mov    0x8(%ebp),%eax
    82cb:	8b 00                	mov    (%eax),%eax
    82cd:	f7 d0                	not    %eax
    82cf:	83 e0 07             	and    $0x7,%eax
    82d2:	be 01 00 00 00       	mov    $0x1,%esi
    82d7:	89 c1                	mov    %eax,%ecx
    82d9:	d3 e6                	shl    %cl,%esi
    82db:	89 f0                	mov    %esi,%eax
    82dd:	f7 d0                	not    %eax
    82df:	21 d8                	and    %ebx,%eax
    82e1:	88 02                	mov    %al,(%edx)
    82e3:	eb 3a                	jmp    831f <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    82e5:	8b 45 08             	mov    0x8(%ebp),%eax
    82e8:	8b 00                	mov    (%eax),%eax
    82ea:	c1 f8 03             	sar    $0x3,%eax
    82ed:	89 c2                	mov    %eax,%edx
    82ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    82f2:	01 c2                	add    %eax,%edx
    82f4:	8b 45 08             	mov    0x8(%ebp),%eax
    82f7:	8b 00                	mov    (%eax),%eax
    82f9:	c1 f8 03             	sar    $0x3,%eax
    82fc:	89 c1                	mov    %eax,%ecx
    82fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    8301:	01 c8                	add    %ecx,%eax
    8303:	0f b6 18             	movzbl (%eax),%ebx
    8306:	8b 45 08             	mov    0x8(%ebp),%eax
    8309:	8b 00                	mov    (%eax),%eax
    830b:	f7 d0                	not    %eax
    830d:	83 e0 07             	and    $0x7,%eax
    8310:	be 01 00 00 00       	mov    $0x1,%esi
    8315:	89 c1                	mov    %eax,%ecx
    8317:	d3 e6                	shl    %cl,%esi
    8319:	89 f0                	mov    %esi,%eax
    831b:	09 d8                	or     %ebx,%eax
    831d:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    831f:	8b 45 08             	mov    0x8(%ebp),%eax
    8322:	8b 00                	mov    (%eax),%eax
    8324:	8d 50 01             	lea    0x1(%eax),%edx
    8327:	8b 45 08             	mov    0x8(%ebp),%eax
    832a:	89 10                	mov    %edx,(%eax)
}
    832c:	90                   	nop
    832d:	83 c4 04             	add    $0x4,%esp
    8330:	5b                   	pop    %ebx
    8331:	5e                   	pop    %esi
    8332:	5d                   	pop    %ebp
    8333:	c3                   	ret    

00008334 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8334:	55                   	push   %ebp
    8335:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    8337:	ff 75 08             	pushl  0x8(%ebp)
    833a:	e8 f1 b3 ff ff       	call   3730 <lodepng_read32bitInt>
    833f:	83 c4 04             	add    $0x4,%esp
}
    8342:	c9                   	leave  
    8343:	c3                   	ret    

00008344 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8344:	55                   	push   %ebp
    8345:	89 e5                	mov    %esp,%ebp
    8347:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    834a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8351:	eb 1c                	jmp    836f <lodepng_chunk_type+0x2b>
    8353:	8b 55 08             	mov    0x8(%ebp),%edx
    8356:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8359:	01 d0                	add    %edx,%eax
    835b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    835e:	8d 4a 04             	lea    0x4(%edx),%ecx
    8361:	8b 55 0c             	mov    0xc(%ebp),%edx
    8364:	01 ca                	add    %ecx,%edx
    8366:	0f b6 12             	movzbl (%edx),%edx
    8369:	88 10                	mov    %dl,(%eax)
    836b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    836f:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    8373:	75 de                	jne    8353 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    8375:	8b 45 08             	mov    0x8(%ebp),%eax
    8378:	83 c0 04             	add    $0x4,%eax
    837b:	c6 00 00             	movb   $0x0,(%eax)
}
    837e:	90                   	nop
    837f:	c9                   	leave  
    8380:	c3                   	ret    

00008381 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    8381:	55                   	push   %ebp
    8382:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    8384:	ff 75 0c             	pushl  0xc(%ebp)
    8387:	e8 c2 b0 ff ff       	call   344e <lodepng_strlen>
    838c:	83 c4 04             	add    $0x4,%esp
    838f:	83 f8 04             	cmp    $0x4,%eax
    8392:	74 07                	je     839b <lodepng_chunk_type_equals+0x1a>
    8394:	b8 00 00 00 00       	mov    $0x0,%eax
    8399:	eb 79                	jmp    8414 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    839b:	8b 45 08             	mov    0x8(%ebp),%eax
    839e:	83 c0 04             	add    $0x4,%eax
    83a1:	0f b6 00             	movzbl (%eax),%eax
    83a4:	0f b6 d0             	movzbl %al,%edx
    83a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    83aa:	0f b6 00             	movzbl (%eax),%eax
    83ad:	0f be c0             	movsbl %al,%eax
    83b0:	39 c2                	cmp    %eax,%edx
    83b2:	75 5b                	jne    840f <lodepng_chunk_type_equals+0x8e>
    83b4:	8b 45 08             	mov    0x8(%ebp),%eax
    83b7:	83 c0 05             	add    $0x5,%eax
    83ba:	0f b6 00             	movzbl (%eax),%eax
    83bd:	0f b6 d0             	movzbl %al,%edx
    83c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    83c3:	83 c0 01             	add    $0x1,%eax
    83c6:	0f b6 00             	movzbl (%eax),%eax
    83c9:	0f be c0             	movsbl %al,%eax
    83cc:	39 c2                	cmp    %eax,%edx
    83ce:	75 3f                	jne    840f <lodepng_chunk_type_equals+0x8e>
    83d0:	8b 45 08             	mov    0x8(%ebp),%eax
    83d3:	83 c0 06             	add    $0x6,%eax
    83d6:	0f b6 00             	movzbl (%eax),%eax
    83d9:	0f b6 d0             	movzbl %al,%edx
    83dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    83df:	83 c0 02             	add    $0x2,%eax
    83e2:	0f b6 00             	movzbl (%eax),%eax
    83e5:	0f be c0             	movsbl %al,%eax
    83e8:	39 c2                	cmp    %eax,%edx
    83ea:	75 23                	jne    840f <lodepng_chunk_type_equals+0x8e>
    83ec:	8b 45 08             	mov    0x8(%ebp),%eax
    83ef:	83 c0 07             	add    $0x7,%eax
    83f2:	0f b6 00             	movzbl (%eax),%eax
    83f5:	0f b6 d0             	movzbl %al,%edx
    83f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    83fb:	83 c0 03             	add    $0x3,%eax
    83fe:	0f b6 00             	movzbl (%eax),%eax
    8401:	0f be c0             	movsbl %al,%eax
    8404:	39 c2                	cmp    %eax,%edx
    8406:	75 07                	jne    840f <lodepng_chunk_type_equals+0x8e>
    8408:	b8 01 00 00 00       	mov    $0x1,%eax
    840d:	eb 05                	jmp    8414 <lodepng_chunk_type_equals+0x93>
    840f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8414:	c9                   	leave  
    8415:	c3                   	ret    

00008416 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8416:	55                   	push   %ebp
    8417:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    8419:	8b 45 08             	mov    0x8(%ebp),%eax
    841c:	83 c0 04             	add    $0x4,%eax
    841f:	0f b6 00             	movzbl (%eax),%eax
    8422:	0f b6 c0             	movzbl %al,%eax
    8425:	83 e0 20             	and    $0x20,%eax
    8428:	85 c0                	test   %eax,%eax
    842a:	0f 95 c0             	setne  %al
}
    842d:	5d                   	pop    %ebp
    842e:	c3                   	ret    

0000842f <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    842f:	55                   	push   %ebp
    8430:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8432:	8b 45 08             	mov    0x8(%ebp),%eax
    8435:	83 c0 06             	add    $0x6,%eax
    8438:	0f b6 00             	movzbl (%eax),%eax
    843b:	0f b6 c0             	movzbl %al,%eax
    843e:	83 e0 20             	and    $0x20,%eax
    8441:	85 c0                	test   %eax,%eax
    8443:	0f 95 c0             	setne  %al
}
    8446:	5d                   	pop    %ebp
    8447:	c3                   	ret    

00008448 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    8448:	55                   	push   %ebp
    8449:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    844b:	8b 45 08             	mov    0x8(%ebp),%eax
    844e:	83 c0 07             	add    $0x7,%eax
    8451:	0f b6 00             	movzbl (%eax),%eax
    8454:	0f b6 c0             	movzbl %al,%eax
    8457:	83 e0 20             	and    $0x20,%eax
    845a:	85 c0                	test   %eax,%eax
    845c:	0f 95 c0             	setne  %al
}
    845f:	5d                   	pop    %ebp
    8460:	c3                   	ret    

00008461 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    8461:	55                   	push   %ebp
    8462:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8464:	8b 45 08             	mov    0x8(%ebp),%eax
    8467:	83 c0 08             	add    $0x8,%eax
}
    846a:	5d                   	pop    %ebp
    846b:	c3                   	ret    

0000846c <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    846c:	55                   	push   %ebp
    846d:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    846f:	8b 45 08             	mov    0x8(%ebp),%eax
    8472:	83 c0 08             	add    $0x8,%eax
}
    8475:	5d                   	pop    %ebp
    8476:	c3                   	ret    

00008477 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    8477:	55                   	push   %ebp
    8478:	89 e5                	mov    %esp,%ebp
    847a:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    847d:	ff 75 08             	pushl  0x8(%ebp)
    8480:	e8 af fe ff ff       	call   8334 <lodepng_chunk_length>
    8485:	83 c4 04             	add    $0x4,%esp
    8488:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    848b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    848e:	8d 50 08             	lea    0x8(%eax),%edx
    8491:	8b 45 08             	mov    0x8(%ebp),%eax
    8494:	01 d0                	add    %edx,%eax
    8496:	50                   	push   %eax
    8497:	e8 94 b2 ff ff       	call   3730 <lodepng_read32bitInt>
    849c:	83 c4 04             	add    $0x4,%esp
    849f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    84a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    84a5:	83 c0 04             	add    $0x4,%eax
    84a8:	89 c2                	mov    %eax,%edx
    84aa:	8b 45 08             	mov    0x8(%ebp),%eax
    84ad:	83 c0 04             	add    $0x4,%eax
    84b0:	52                   	push   %edx
    84b1:	50                   	push   %eax
    84b2:	e8 0b fd ff ff       	call   81c2 <lodepng_crc32>
    84b7:	83 c4 08             	add    $0x8,%esp
    84ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    84bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    84c0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    84c3:	74 07                	je     84cc <lodepng_chunk_check_crc+0x55>
    84c5:	b8 01 00 00 00       	mov    $0x1,%eax
    84ca:	eb 05                	jmp    84d1 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    84cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    84d1:	c9                   	leave  
    84d2:	c3                   	ret    

000084d3 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    84d3:	55                   	push   %ebp
    84d4:	89 e5                	mov    %esp,%ebp
    84d6:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    84d9:	ff 75 08             	pushl  0x8(%ebp)
    84dc:	e8 53 fe ff ff       	call   8334 <lodepng_chunk_length>
    84e1:	83 c4 04             	add    $0x4,%esp
    84e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    84e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    84ea:	83 c0 04             	add    $0x4,%eax
    84ed:	89 c2                	mov    %eax,%edx
    84ef:	8b 45 08             	mov    0x8(%ebp),%eax
    84f2:	83 c0 04             	add    $0x4,%eax
    84f5:	52                   	push   %edx
    84f6:	50                   	push   %eax
    84f7:	e8 c6 fc ff ff       	call   81c2 <lodepng_crc32>
    84fc:	83 c4 08             	add    $0x8,%esp
    84ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8502:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8505:	8d 50 08             	lea    0x8(%eax),%edx
    8508:	8b 45 08             	mov    0x8(%ebp),%eax
    850b:	01 d0                	add    %edx,%eax
    850d:	ff 75 f8             	pushl  -0x8(%ebp)
    8510:	50                   	push   %eax
    8511:	e8 5d b2 ff ff       	call   3773 <lodepng_set32bitInt>
    8516:	83 c4 08             	add    $0x8,%esp
}
    8519:	90                   	nop
    851a:	c9                   	leave  
    851b:	c3                   	ret    

0000851c <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    851c:	55                   	push   %ebp
    851d:	89 e5                	mov    %esp,%ebp
    851f:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8522:	8b 45 08             	mov    0x8(%ebp),%eax
    8525:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8528:	73 0f                	jae    8539 <lodepng_chunk_next+0x1d>
    852a:	8b 55 0c             	mov    0xc(%ebp),%edx
    852d:	8b 45 08             	mov    0x8(%ebp),%eax
    8530:	29 c2                	sub    %eax,%edx
    8532:	89 d0                	mov    %edx,%eax
    8534:	83 f8 0b             	cmp    $0xb,%eax
    8537:	7f 08                	jg     8541 <lodepng_chunk_next+0x25>
    8539:	8b 45 0c             	mov    0xc(%ebp),%eax
    853c:	e9 af 00 00 00       	jmp    85f0 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8541:	8b 45 08             	mov    0x8(%ebp),%eax
    8544:	0f b6 00             	movzbl (%eax),%eax
    8547:	3c 89                	cmp    $0x89,%al
    8549:	75 63                	jne    85ae <lodepng_chunk_next+0x92>
    854b:	8b 45 08             	mov    0x8(%ebp),%eax
    854e:	83 c0 01             	add    $0x1,%eax
    8551:	0f b6 00             	movzbl (%eax),%eax
    8554:	3c 50                	cmp    $0x50,%al
    8556:	75 56                	jne    85ae <lodepng_chunk_next+0x92>
    8558:	8b 45 08             	mov    0x8(%ebp),%eax
    855b:	83 c0 02             	add    $0x2,%eax
    855e:	0f b6 00             	movzbl (%eax),%eax
    8561:	3c 4e                	cmp    $0x4e,%al
    8563:	75 49                	jne    85ae <lodepng_chunk_next+0x92>
    8565:	8b 45 08             	mov    0x8(%ebp),%eax
    8568:	83 c0 03             	add    $0x3,%eax
    856b:	0f b6 00             	movzbl (%eax),%eax
    856e:	3c 47                	cmp    $0x47,%al
    8570:	75 3c                	jne    85ae <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8572:	8b 45 08             	mov    0x8(%ebp),%eax
    8575:	83 c0 04             	add    $0x4,%eax
    8578:	0f b6 00             	movzbl (%eax),%eax
    857b:	3c 0d                	cmp    $0xd,%al
    857d:	75 2f                	jne    85ae <lodepng_chunk_next+0x92>
    857f:	8b 45 08             	mov    0x8(%ebp),%eax
    8582:	83 c0 05             	add    $0x5,%eax
    8585:	0f b6 00             	movzbl (%eax),%eax
    8588:	3c 0a                	cmp    $0xa,%al
    858a:	75 22                	jne    85ae <lodepng_chunk_next+0x92>
    858c:	8b 45 08             	mov    0x8(%ebp),%eax
    858f:	83 c0 06             	add    $0x6,%eax
    8592:	0f b6 00             	movzbl (%eax),%eax
    8595:	3c 1a                	cmp    $0x1a,%al
    8597:	75 15                	jne    85ae <lodepng_chunk_next+0x92>
    8599:	8b 45 08             	mov    0x8(%ebp),%eax
    859c:	83 c0 07             	add    $0x7,%eax
    859f:	0f b6 00             	movzbl (%eax),%eax
    85a2:	3c 0a                	cmp    $0xa,%al
    85a4:	75 08                	jne    85ae <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    85a6:	8b 45 08             	mov    0x8(%ebp),%eax
    85a9:	83 c0 08             	add    $0x8,%eax
    85ac:	eb 42                	jmp    85f0 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    85ae:	ff 75 08             	pushl  0x8(%ebp)
    85b1:	e8 7e fd ff ff       	call   8334 <lodepng_chunk_length>
    85b6:	83 c4 04             	add    $0x4,%esp
    85b9:	89 c2                	mov    %eax,%edx
    85bb:	8d 45 f8             	lea    -0x8(%ebp),%eax
    85be:	50                   	push   %eax
    85bf:	6a 0c                	push   $0xc
    85c1:	52                   	push   %edx
    85c2:	e8 af ae ff ff       	call   3476 <lodepng_addofl>
    85c7:	83 c4 0c             	add    $0xc,%esp
    85ca:	85 c0                	test   %eax,%eax
    85cc:	74 05                	je     85d3 <lodepng_chunk_next+0xb7>
    85ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    85d1:	eb 1d                	jmp    85f0 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    85d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    85d6:	89 c2                	mov    %eax,%edx
    85d8:	8b 45 08             	mov    0x8(%ebp),%eax
    85db:	01 d0                	add    %edx,%eax
    85dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    85e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    85e3:	3b 45 08             	cmp    0x8(%ebp),%eax
    85e6:	73 05                	jae    85ed <lodepng_chunk_next+0xd1>
    85e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    85eb:	eb 03                	jmp    85f0 <lodepng_chunk_next+0xd4>
    return result;
    85ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    85f0:	c9                   	leave  
    85f1:	c3                   	ret    

000085f2 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    85f2:	55                   	push   %ebp
    85f3:	89 e5                	mov    %esp,%ebp
    85f5:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    85f8:	8b 45 08             	mov    0x8(%ebp),%eax
    85fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    85fe:	73 0f                	jae    860f <lodepng_chunk_next_const+0x1d>
    8600:	8b 55 0c             	mov    0xc(%ebp),%edx
    8603:	8b 45 08             	mov    0x8(%ebp),%eax
    8606:	29 c2                	sub    %eax,%edx
    8608:	89 d0                	mov    %edx,%eax
    860a:	83 f8 0b             	cmp    $0xb,%eax
    860d:	7f 08                	jg     8617 <lodepng_chunk_next_const+0x25>
    860f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8612:	e9 af 00 00 00       	jmp    86c6 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8617:	8b 45 08             	mov    0x8(%ebp),%eax
    861a:	0f b6 00             	movzbl (%eax),%eax
    861d:	3c 89                	cmp    $0x89,%al
    861f:	75 63                	jne    8684 <lodepng_chunk_next_const+0x92>
    8621:	8b 45 08             	mov    0x8(%ebp),%eax
    8624:	83 c0 01             	add    $0x1,%eax
    8627:	0f b6 00             	movzbl (%eax),%eax
    862a:	3c 50                	cmp    $0x50,%al
    862c:	75 56                	jne    8684 <lodepng_chunk_next_const+0x92>
    862e:	8b 45 08             	mov    0x8(%ebp),%eax
    8631:	83 c0 02             	add    $0x2,%eax
    8634:	0f b6 00             	movzbl (%eax),%eax
    8637:	3c 4e                	cmp    $0x4e,%al
    8639:	75 49                	jne    8684 <lodepng_chunk_next_const+0x92>
    863b:	8b 45 08             	mov    0x8(%ebp),%eax
    863e:	83 c0 03             	add    $0x3,%eax
    8641:	0f b6 00             	movzbl (%eax),%eax
    8644:	3c 47                	cmp    $0x47,%al
    8646:	75 3c                	jne    8684 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8648:	8b 45 08             	mov    0x8(%ebp),%eax
    864b:	83 c0 04             	add    $0x4,%eax
    864e:	0f b6 00             	movzbl (%eax),%eax
    8651:	3c 0d                	cmp    $0xd,%al
    8653:	75 2f                	jne    8684 <lodepng_chunk_next_const+0x92>
    8655:	8b 45 08             	mov    0x8(%ebp),%eax
    8658:	83 c0 05             	add    $0x5,%eax
    865b:	0f b6 00             	movzbl (%eax),%eax
    865e:	3c 0a                	cmp    $0xa,%al
    8660:	75 22                	jne    8684 <lodepng_chunk_next_const+0x92>
    8662:	8b 45 08             	mov    0x8(%ebp),%eax
    8665:	83 c0 06             	add    $0x6,%eax
    8668:	0f b6 00             	movzbl (%eax),%eax
    866b:	3c 1a                	cmp    $0x1a,%al
    866d:	75 15                	jne    8684 <lodepng_chunk_next_const+0x92>
    866f:	8b 45 08             	mov    0x8(%ebp),%eax
    8672:	83 c0 07             	add    $0x7,%eax
    8675:	0f b6 00             	movzbl (%eax),%eax
    8678:	3c 0a                	cmp    $0xa,%al
    867a:	75 08                	jne    8684 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    867c:	8b 45 08             	mov    0x8(%ebp),%eax
    867f:	83 c0 08             	add    $0x8,%eax
    8682:	eb 42                	jmp    86c6 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8684:	ff 75 08             	pushl  0x8(%ebp)
    8687:	e8 a8 fc ff ff       	call   8334 <lodepng_chunk_length>
    868c:	83 c4 04             	add    $0x4,%esp
    868f:	89 c2                	mov    %eax,%edx
    8691:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8694:	50                   	push   %eax
    8695:	6a 0c                	push   $0xc
    8697:	52                   	push   %edx
    8698:	e8 d9 ad ff ff       	call   3476 <lodepng_addofl>
    869d:	83 c4 0c             	add    $0xc,%esp
    86a0:	85 c0                	test   %eax,%eax
    86a2:	74 05                	je     86a9 <lodepng_chunk_next_const+0xb7>
    86a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    86a7:	eb 1d                	jmp    86c6 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    86a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    86ac:	89 c2                	mov    %eax,%edx
    86ae:	8b 45 08             	mov    0x8(%ebp),%eax
    86b1:	01 d0                	add    %edx,%eax
    86b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    86b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    86b9:	3b 45 08             	cmp    0x8(%ebp),%eax
    86bc:	73 05                	jae    86c3 <lodepng_chunk_next_const+0xd1>
    86be:	8b 45 0c             	mov    0xc(%ebp),%eax
    86c1:	eb 03                	jmp    86c6 <lodepng_chunk_next_const+0xd4>
    return result;
    86c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    86c6:	c9                   	leave  
    86c7:	c3                   	ret    

000086c8 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    86c8:	55                   	push   %ebp
    86c9:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    86cb:	8b 45 08             	mov    0x8(%ebp),%eax
    86ce:	3b 45 0c             	cmp    0xc(%ebp),%eax
    86d1:	73 0f                	jae    86e2 <lodepng_chunk_find+0x1a>
    86d3:	8b 55 0c             	mov    0xc(%ebp),%edx
    86d6:	8b 45 08             	mov    0x8(%ebp),%eax
    86d9:	29 c2                	sub    %eax,%edx
    86db:	89 d0                	mov    %edx,%eax
    86dd:	83 f8 0b             	cmp    $0xb,%eax
    86e0:	7f 07                	jg     86e9 <lodepng_chunk_find+0x21>
    86e2:	b8 00 00 00 00       	mov    $0x0,%eax
    86e7:	eb 2a                	jmp    8713 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    86e9:	ff 75 10             	pushl  0x10(%ebp)
    86ec:	ff 75 08             	pushl  0x8(%ebp)
    86ef:	e8 8d fc ff ff       	call   8381 <lodepng_chunk_type_equals>
    86f4:	83 c4 08             	add    $0x8,%esp
    86f7:	84 c0                	test   %al,%al
    86f9:	74 05                	je     8700 <lodepng_chunk_find+0x38>
    86fb:	8b 45 08             	mov    0x8(%ebp),%eax
    86fe:	eb 13                	jmp    8713 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8700:	ff 75 0c             	pushl  0xc(%ebp)
    8703:	ff 75 08             	pushl  0x8(%ebp)
    8706:	e8 11 fe ff ff       	call   851c <lodepng_chunk_next>
    870b:	83 c4 08             	add    $0x8,%esp
    870e:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8711:	eb b8                	jmp    86cb <lodepng_chunk_find+0x3>
}
    8713:	c9                   	leave  
    8714:	c3                   	ret    

00008715 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8715:	55                   	push   %ebp
    8716:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8718:	8b 45 08             	mov    0x8(%ebp),%eax
    871b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    871e:	73 0f                	jae    872f <lodepng_chunk_find_const+0x1a>
    8720:	8b 55 0c             	mov    0xc(%ebp),%edx
    8723:	8b 45 08             	mov    0x8(%ebp),%eax
    8726:	29 c2                	sub    %eax,%edx
    8728:	89 d0                	mov    %edx,%eax
    872a:	83 f8 0b             	cmp    $0xb,%eax
    872d:	7f 07                	jg     8736 <lodepng_chunk_find_const+0x21>
    872f:	b8 00 00 00 00       	mov    $0x0,%eax
    8734:	eb 2a                	jmp    8760 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8736:	ff 75 10             	pushl  0x10(%ebp)
    8739:	ff 75 08             	pushl  0x8(%ebp)
    873c:	e8 40 fc ff ff       	call   8381 <lodepng_chunk_type_equals>
    8741:	83 c4 08             	add    $0x8,%esp
    8744:	84 c0                	test   %al,%al
    8746:	74 05                	je     874d <lodepng_chunk_find_const+0x38>
    8748:	8b 45 08             	mov    0x8(%ebp),%eax
    874b:	eb 13                	jmp    8760 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    874d:	ff 75 0c             	pushl  0xc(%ebp)
    8750:	ff 75 08             	pushl  0x8(%ebp)
    8753:	e8 9a fe ff ff       	call   85f2 <lodepng_chunk_next_const>
    8758:	83 c4 08             	add    $0x8,%esp
    875b:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    875e:	eb b8                	jmp    8718 <lodepng_chunk_find_const+0x3>
}
    8760:	c9                   	leave  
    8761:	c3                   	ret    

00008762 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    8762:	55                   	push   %ebp
    8763:	89 e5                	mov    %esp,%ebp
    8765:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    8768:	ff 75 10             	pushl  0x10(%ebp)
    876b:	e8 c4 fb ff ff       	call   8334 <lodepng_chunk_length>
    8770:	83 c4 04             	add    $0x4,%esp
    8773:	89 c2                	mov    %eax,%edx
    8775:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8778:	50                   	push   %eax
    8779:	6a 0c                	push   $0xc
    877b:	52                   	push   %edx
    877c:	e8 f5 ac ff ff       	call   3476 <lodepng_addofl>
    8781:	83 c4 0c             	add    $0xc,%esp
    8784:	85 c0                	test   %eax,%eax
    8786:	74 0a                	je     8792 <lodepng_chunk_append+0x30>
    8788:	b8 4d 00 00 00       	mov    $0x4d,%eax
    878d:	e9 96 00 00 00       	jmp    8828 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    8792:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8795:	8b 45 0c             	mov    0xc(%ebp),%eax
    8798:	8b 00                	mov    (%eax),%eax
    879a:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    879d:	51                   	push   %ecx
    879e:	52                   	push   %edx
    879f:	50                   	push   %eax
    87a0:	e8 d1 ac ff ff       	call   3476 <lodepng_addofl>
    87a5:	83 c4 0c             	add    $0xc,%esp
    87a8:	85 c0                	test   %eax,%eax
    87aa:	74 07                	je     87b3 <lodepng_chunk_append+0x51>
    87ac:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87b1:	eb 75                	jmp    8828 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    87b3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    87b6:	8b 45 08             	mov    0x8(%ebp),%eax
    87b9:	8b 00                	mov    (%eax),%eax
    87bb:	52                   	push   %edx
    87bc:	50                   	push   %eax
    87bd:	e8 07 ac ff ff       	call   33c9 <lodepng_realloc>
    87c2:	83 c4 08             	add    $0x8,%esp
    87c5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    87c8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    87cc:	75 07                	jne    87d5 <lodepng_chunk_append+0x73>
    87ce:	b8 53 00 00 00       	mov    $0x53,%eax
    87d3:	eb 53                	jmp    8828 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    87d5:	8b 45 08             	mov    0x8(%ebp),%eax
    87d8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    87db:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    87dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    87e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    87e3:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    87e5:	8b 45 08             	mov    0x8(%ebp),%eax
    87e8:	8b 00                	mov    (%eax),%eax
    87ea:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    87ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    87f0:	29 d1                	sub    %edx,%ecx
    87f2:	89 ca                	mov    %ecx,%edx
    87f4:	01 d0                	add    %edx,%eax
    87f6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    87f9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8800:	eb 19                	jmp    881b <lodepng_chunk_append+0xb9>
    8802:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8805:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8808:	01 c2                	add    %eax,%edx
    880a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    880d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8810:	01 c8                	add    %ecx,%eax
    8812:	0f b6 00             	movzbl (%eax),%eax
    8815:	88 02                	mov    %al,(%edx)
    8817:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    881b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    881e:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8821:	75 df                	jne    8802 <lodepng_chunk_append+0xa0>

  return 0;
    8823:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8828:	c9                   	leave  
    8829:	c3                   	ret    

0000882a <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    882a:	55                   	push   %ebp
    882b:	89 e5                	mov    %esp,%ebp
    882d:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8830:	8b 45 0c             	mov    0xc(%ebp),%eax
    8833:	8b 40 04             	mov    0x4(%eax),%eax
    8836:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8839:	8b 55 10             	mov    0x10(%ebp),%edx
    883c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    883f:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8842:	51                   	push   %ecx
    8843:	52                   	push   %edx
    8844:	50                   	push   %eax
    8845:	e8 2c ac ff ff       	call   3476 <lodepng_addofl>
    884a:	83 c4 0c             	add    $0xc,%esp
    884d:	85 c0                	test   %eax,%eax
    884f:	74 07                	je     8858 <lodepng_chunk_init+0x2e>
    8851:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8856:	eb 78                	jmp    88d0 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8858:	8b 45 fc             	mov    -0x4(%ebp),%eax
    885b:	8d 55 fc             	lea    -0x4(%ebp),%edx
    885e:	52                   	push   %edx
    885f:	6a 0c                	push   $0xc
    8861:	50                   	push   %eax
    8862:	e8 0f ac ff ff       	call   3476 <lodepng_addofl>
    8867:	83 c4 0c             	add    $0xc,%esp
    886a:	85 c0                	test   %eax,%eax
    886c:	74 07                	je     8875 <lodepng_chunk_init+0x4b>
    886e:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8873:	eb 5b                	jmp    88d0 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8875:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8878:	50                   	push   %eax
    8879:	ff 75 0c             	pushl  0xc(%ebp)
    887c:	e8 8b ad ff ff       	call   360c <ucvector_resize>
    8881:	83 c4 08             	add    $0x8,%esp
    8884:	85 c0                	test   %eax,%eax
    8886:	75 07                	jne    888f <lodepng_chunk_init+0x65>
    8888:	b8 53 00 00 00       	mov    $0x53,%eax
    888d:	eb 41                	jmp    88d0 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    888f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8892:	8b 00                	mov    (%eax),%eax
    8894:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8897:	2b 55 10             	sub    0x10(%ebp),%edx
    889a:	83 ea 0c             	sub    $0xc,%edx
    889d:	01 c2                	add    %eax,%edx
    889f:	8b 45 08             	mov    0x8(%ebp),%eax
    88a2:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    88a4:	8b 45 08             	mov    0x8(%ebp),%eax
    88a7:	8b 00                	mov    (%eax),%eax
    88a9:	ff 75 10             	pushl  0x10(%ebp)
    88ac:	50                   	push   %eax
    88ad:	e8 c1 ae ff ff       	call   3773 <lodepng_set32bitInt>
    88b2:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    88b5:	8b 45 08             	mov    0x8(%ebp),%eax
    88b8:	8b 00                	mov    (%eax),%eax
    88ba:	83 c0 04             	add    $0x4,%eax
    88bd:	6a 04                	push   $0x4
    88bf:	ff 75 14             	pushl  0x14(%ebp)
    88c2:	50                   	push   %eax
    88c3:	e8 28 ab ff ff       	call   33f0 <lodepng_memcpy>
    88c8:	83 c4 0c             	add    $0xc,%esp

  return 0;
    88cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    88d0:	c9                   	leave  
    88d1:	c3                   	ret    

000088d2 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    88d2:	55                   	push   %ebp
    88d3:	89 e5                	mov    %esp,%ebp
    88d5:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    88d8:	ff 75 10             	pushl  0x10(%ebp)
    88db:	ff 75 0c             	pushl  0xc(%ebp)
    88de:	ff 75 08             	pushl  0x8(%ebp)
    88e1:	8d 45 f8             	lea    -0x8(%ebp),%eax
    88e4:	50                   	push   %eax
    88e5:	e8 40 ff ff ff       	call   882a <lodepng_chunk_init>
    88ea:	83 c4 10             	add    $0x10,%esp
    88ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
    88f0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    88f4:	74 05                	je     88fb <lodepng_chunk_createv+0x29>
    88f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88f9:	eb 27                	jmp    8922 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    88fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    88fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8901:	83 c2 08             	add    $0x8,%edx
    8904:	50                   	push   %eax
    8905:	ff 75 14             	pushl  0x14(%ebp)
    8908:	52                   	push   %edx
    8909:	e8 e2 aa ff ff       	call   33f0 <lodepng_memcpy>
    890e:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8911:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8914:	50                   	push   %eax
    8915:	e8 b9 fb ff ff       	call   84d3 <lodepng_chunk_generate_crc>
    891a:	83 c4 04             	add    $0x4,%esp

  return 0;
    891d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8922:	c9                   	leave  
    8923:	c3                   	ret    

00008924 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8924:	55                   	push   %ebp
    8925:	89 e5                	mov    %esp,%ebp
    8927:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    892a:	8b 45 0c             	mov    0xc(%ebp),%eax
    892d:	8b 08                	mov    (%eax),%ecx
    892f:	8b 45 08             	mov    0x8(%ebp),%eax
    8932:	8b 10                	mov    (%eax),%edx
    8934:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8937:	51                   	push   %ecx
    8938:	52                   	push   %edx
    8939:	50                   	push   %eax
    893a:	e8 34 ad ff ff       	call   3673 <ucvector_init>
    893f:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8942:	ff 75 18             	pushl  0x18(%ebp)
    8945:	ff 75 14             	pushl  0x14(%ebp)
    8948:	ff 75 10             	pushl  0x10(%ebp)
    894b:	8d 45 f0             	lea    -0x10(%ebp),%eax
    894e:	50                   	push   %eax
    894f:	e8 7e ff ff ff       	call   88d2 <lodepng_chunk_createv>
    8954:	83 c4 10             	add    $0x10,%esp
    8957:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    895a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    895d:	8b 45 08             	mov    0x8(%ebp),%eax
    8960:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8962:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8965:	8b 45 0c             	mov    0xc(%ebp),%eax
    8968:	89 10                	mov    %edx,(%eax)
  return error;
    896a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    896d:	c9                   	leave  
    896e:	c3                   	ret    

0000896f <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    896f:	55                   	push   %ebp
    8970:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8972:	8b 45 08             	mov    0x8(%ebp),%eax
    8975:	83 f8 03             	cmp    $0x3,%eax
    8978:	74 6d                	je     89e7 <checkColorValidity+0x78>
    897a:	83 f8 03             	cmp    $0x3,%eax
    897d:	77 0e                	ja     898d <checkColorValidity+0x1e>
    897f:	85 c0                	test   %eax,%eax
    8981:	74 28                	je     89ab <checkColorValidity+0x3c>
    8983:	83 f8 02             	cmp    $0x2,%eax
    8986:	74 4c                	je     89d4 <checkColorValidity+0x65>
    8988:	e9 a6 00 00 00       	jmp    8a33 <checkColorValidity+0xc4>
    898d:	83 f8 06             	cmp    $0x6,%eax
    8990:	0f 84 83 00 00 00    	je     8a19 <checkColorValidity+0xaa>
    8996:	3d ff 00 00 00       	cmp    $0xff,%eax
    899b:	0f 84 8b 00 00 00    	je     8a2c <checkColorValidity+0xbd>
    89a1:	83 f8 04             	cmp    $0x4,%eax
    89a4:	74 60                	je     8a06 <checkColorValidity+0x97>
    89a6:	e9 88 00 00 00       	jmp    8a33 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    89ab:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    89af:	0f 84 85 00 00 00    	je     8a3a <checkColorValidity+0xcb>
    89b5:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    89b9:	74 7f                	je     8a3a <checkColorValidity+0xcb>
    89bb:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    89bf:	74 79                	je     8a3a <checkColorValidity+0xcb>
    89c1:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    89c5:	74 73                	je     8a3a <checkColorValidity+0xcb>
    89c7:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    89cb:	74 6d                	je     8a3a <checkColorValidity+0xcb>
    89cd:	b8 25 00 00 00       	mov    $0x25,%eax
    89d2:	eb 78                	jmp    8a4c <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89d4:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    89d8:	74 63                	je     8a3d <checkColorValidity+0xce>
    89da:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    89de:	74 5d                	je     8a3d <checkColorValidity+0xce>
    89e0:	b8 25 00 00 00       	mov    $0x25,%eax
    89e5:	eb 65                	jmp    8a4c <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    89e7:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    89eb:	74 53                	je     8a40 <checkColorValidity+0xd1>
    89ed:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    89f1:	74 4d                	je     8a40 <checkColorValidity+0xd1>
    89f3:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    89f7:	74 47                	je     8a40 <checkColorValidity+0xd1>
    89f9:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    89fd:	74 41                	je     8a40 <checkColorValidity+0xd1>
    89ff:	b8 25 00 00 00       	mov    $0x25,%eax
    8a04:	eb 46                	jmp    8a4c <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a06:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a0a:	74 37                	je     8a43 <checkColorValidity+0xd4>
    8a0c:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a10:	74 31                	je     8a43 <checkColorValidity+0xd4>
    8a12:	b8 25 00 00 00       	mov    $0x25,%eax
    8a17:	eb 33                	jmp    8a4c <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a19:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a1d:	74 27                	je     8a46 <checkColorValidity+0xd7>
    8a1f:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a23:	74 21                	je     8a46 <checkColorValidity+0xd7>
    8a25:	b8 25 00 00 00       	mov    $0x25,%eax
    8a2a:	eb 20                	jmp    8a4c <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8a2c:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8a31:	eb 19                	jmp    8a4c <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8a33:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8a38:	eb 12                	jmp    8a4c <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8a3a:	90                   	nop
    8a3b:	eb 0a                	jmp    8a47 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a3d:	90                   	nop
    8a3e:	eb 07                	jmp    8a47 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8a40:	90                   	nop
    8a41:	eb 04                	jmp    8a47 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a43:	90                   	nop
    8a44:	eb 01                	jmp    8a47 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a46:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8a47:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8a4c:	5d                   	pop    %ebp
    8a4d:	c3                   	ret    

00008a4e <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8a4e:	55                   	push   %ebp
    8a4f:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8a51:	8b 45 08             	mov    0x8(%ebp),%eax
    8a54:	83 f8 03             	cmp    $0x3,%eax
    8a57:	74 31                	je     8a8a <getNumColorChannels+0x3c>
    8a59:	83 f8 03             	cmp    $0x3,%eax
    8a5c:	77 0b                	ja     8a69 <getNumColorChannels+0x1b>
    8a5e:	85 c0                	test   %eax,%eax
    8a60:	74 1a                	je     8a7c <getNumColorChannels+0x2e>
    8a62:	83 f8 02             	cmp    $0x2,%eax
    8a65:	74 1c                	je     8a83 <getNumColorChannels+0x35>
    8a67:	eb 3d                	jmp    8aa6 <getNumColorChannels+0x58>
    8a69:	83 f8 06             	cmp    $0x6,%eax
    8a6c:	74 2a                	je     8a98 <getNumColorChannels+0x4a>
    8a6e:	3d ff 00 00 00       	cmp    $0xff,%eax
    8a73:	74 2a                	je     8a9f <getNumColorChannels+0x51>
    8a75:	83 f8 04             	cmp    $0x4,%eax
    8a78:	74 17                	je     8a91 <getNumColorChannels+0x43>
    8a7a:	eb 2a                	jmp    8aa6 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8a7c:	b8 01 00 00 00       	mov    $0x1,%eax
    8a81:	eb 28                	jmp    8aab <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8a83:	b8 03 00 00 00       	mov    $0x3,%eax
    8a88:	eb 21                	jmp    8aab <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8a8a:	b8 01 00 00 00       	mov    $0x1,%eax
    8a8f:	eb 1a                	jmp    8aab <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8a91:	b8 02 00 00 00       	mov    $0x2,%eax
    8a96:	eb 13                	jmp    8aab <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8a98:	b8 04 00 00 00       	mov    $0x4,%eax
    8a9d:	eb 0c                	jmp    8aab <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8a9f:	b8 00 00 00 00       	mov    $0x0,%eax
    8aa4:	eb 05                	jmp    8aab <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8aa6:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8aab:	5d                   	pop    %ebp
    8aac:	c3                   	ret    

00008aad <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8aad:	55                   	push   %ebp
    8aae:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8ab0:	ff 75 08             	pushl  0x8(%ebp)
    8ab3:	e8 96 ff ff ff       	call   8a4e <getNumColorChannels>
    8ab8:	83 c4 04             	add    $0x4,%esp
    8abb:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8abf:	c9                   	leave  
    8ac0:	c3                   	ret    

00008ac1 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8ac1:	55                   	push   %ebp
    8ac2:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8ac4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ac7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8ace:	8b 45 08             	mov    0x8(%ebp),%eax
    8ad1:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8ad8:	8b 45 08             	mov    0x8(%ebp),%eax
    8adb:	8b 50 1c             	mov    0x1c(%eax),%edx
    8ade:	8b 45 08             	mov    0x8(%ebp),%eax
    8ae1:	89 50 18             	mov    %edx,0x18(%eax)
    8ae4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ae7:	8b 50 18             	mov    0x18(%eax),%edx
    8aea:	8b 45 08             	mov    0x8(%ebp),%eax
    8aed:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8af0:	8b 45 08             	mov    0x8(%ebp),%eax
    8af3:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8af9:	8b 45 08             	mov    0x8(%ebp),%eax
    8afc:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8b03:	8b 45 08             	mov    0x8(%ebp),%eax
    8b06:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8b0d:	8b 45 08             	mov    0x8(%ebp),%eax
    8b10:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8b17:	90                   	nop
    8b18:	5d                   	pop    %ebp
    8b19:	c3                   	ret    

00008b1a <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8b1a:	55                   	push   %ebp
    8b1b:	89 e5                	mov    %esp,%ebp
    8b1d:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8b20:	8b 45 08             	mov    0x8(%ebp),%eax
    8b23:	8b 40 08             	mov    0x8(%eax),%eax
    8b26:	85 c0                	test   %eax,%eax
    8b28:	75 18                	jne    8b42 <lodepng_color_mode_alloc_palette+0x28>
    8b2a:	83 ec 0c             	sub    $0xc,%esp
    8b2d:	68 00 04 00 00       	push   $0x400
    8b32:	e8 7b a8 ff ff       	call   33b2 <lodepng_malloc>
    8b37:	83 c4 10             	add    $0x10,%esp
    8b3a:	89 c2                	mov    %eax,%edx
    8b3c:	8b 45 08             	mov    0x8(%ebp),%eax
    8b3f:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8b42:	8b 45 08             	mov    0x8(%ebp),%eax
    8b45:	8b 40 08             	mov    0x8(%eax),%eax
    8b48:	85 c0                	test   %eax,%eax
    8b4a:	74 65                	je     8bb1 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8b4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8b53:	eb 51                	jmp    8ba6 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8b55:	8b 45 08             	mov    0x8(%ebp),%eax
    8b58:	8b 40 08             	mov    0x8(%eax),%eax
    8b5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b5e:	c1 e2 02             	shl    $0x2,%edx
    8b61:	01 d0                	add    %edx,%eax
    8b63:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8b66:	8b 45 08             	mov    0x8(%ebp),%eax
    8b69:	8b 40 08             	mov    0x8(%eax),%eax
    8b6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b6f:	c1 e2 02             	shl    $0x2,%edx
    8b72:	83 c2 01             	add    $0x1,%edx
    8b75:	01 d0                	add    %edx,%eax
    8b77:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8b7a:	8b 45 08             	mov    0x8(%ebp),%eax
    8b7d:	8b 40 08             	mov    0x8(%eax),%eax
    8b80:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b83:	c1 e2 02             	shl    $0x2,%edx
    8b86:	83 c2 02             	add    $0x2,%edx
    8b89:	01 d0                	add    %edx,%eax
    8b8b:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8b8e:	8b 45 08             	mov    0x8(%ebp),%eax
    8b91:	8b 40 08             	mov    0x8(%eax),%eax
    8b94:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b97:	c1 e2 02             	shl    $0x2,%edx
    8b9a:	83 c2 03             	add    $0x3,%edx
    8b9d:	01 d0                	add    %edx,%eax
    8b9f:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8ba2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8ba6:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8bad:	75 a6                	jne    8b55 <lodepng_color_mode_alloc_palette+0x3b>
    8baf:	eb 01                	jmp    8bb2 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8bb1:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8bb2:	c9                   	leave  
    8bb3:	c3                   	ret    

00008bb4 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8bb4:	55                   	push   %ebp
    8bb5:	89 e5                	mov    %esp,%ebp
    8bb7:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8bba:	83 ec 0c             	sub    $0xc,%esp
    8bbd:	ff 75 08             	pushl  0x8(%ebp)
    8bc0:	e8 f3 01 00 00       	call   8db8 <lodepng_palette_clear>
    8bc5:	83 c4 10             	add    $0x10,%esp
}
    8bc8:	90                   	nop
    8bc9:	c9                   	leave  
    8bca:	c3                   	ret    

00008bcb <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8bcb:	55                   	push   %ebp
    8bcc:	89 e5                	mov    %esp,%ebp
    8bce:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8bd1:	83 ec 0c             	sub    $0xc,%esp
    8bd4:	ff 75 08             	pushl  0x8(%ebp)
    8bd7:	e8 d8 ff ff ff       	call   8bb4 <lodepng_color_mode_cleanup>
    8bdc:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8bdf:	83 ec 04             	sub    $0x4,%esp
    8be2:	6a 20                	push   $0x20
    8be4:	ff 75 0c             	pushl  0xc(%ebp)
    8be7:	ff 75 08             	pushl  0x8(%ebp)
    8bea:	e8 01 a8 ff ff       	call   33f0 <lodepng_memcpy>
    8bef:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8bf2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bf5:	8b 40 08             	mov    0x8(%eax),%eax
    8bf8:	85 c0                	test   %eax,%eax
    8bfa:	74 5a                	je     8c56 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8bfc:	83 ec 0c             	sub    $0xc,%esp
    8bff:	68 00 04 00 00       	push   $0x400
    8c04:	e8 a9 a7 ff ff       	call   33b2 <lodepng_malloc>
    8c09:	83 c4 10             	add    $0x10,%esp
    8c0c:	89 c2                	mov    %eax,%edx
    8c0e:	8b 45 08             	mov    0x8(%ebp),%eax
    8c11:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8c14:	8b 45 08             	mov    0x8(%ebp),%eax
    8c17:	8b 40 08             	mov    0x8(%eax),%eax
    8c1a:	85 c0                	test   %eax,%eax
    8c1c:	75 11                	jne    8c2f <lodepng_color_mode_copy+0x64>
    8c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c21:	8b 40 0c             	mov    0xc(%eax),%eax
    8c24:	85 c0                	test   %eax,%eax
    8c26:	74 07                	je     8c2f <lodepng_color_mode_copy+0x64>
    8c28:	b8 53 00 00 00       	mov    $0x53,%eax
    8c2d:	eb 2c                	jmp    8c5b <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8c2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c32:	8b 40 0c             	mov    0xc(%eax),%eax
    8c35:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8c3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c3f:	8b 50 08             	mov    0x8(%eax),%edx
    8c42:	8b 45 08             	mov    0x8(%ebp),%eax
    8c45:	8b 40 08             	mov    0x8(%eax),%eax
    8c48:	83 ec 04             	sub    $0x4,%esp
    8c4b:	51                   	push   %ecx
    8c4c:	52                   	push   %edx
    8c4d:	50                   	push   %eax
    8c4e:	e8 9d a7 ff ff       	call   33f0 <lodepng_memcpy>
    8c53:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8c56:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8c5b:	c9                   	leave  
    8c5c:	c3                   	ret    

00008c5d <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8c5d:	55                   	push   %ebp
    8c5e:	89 e5                	mov    %esp,%ebp
    8c60:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8c63:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8c66:	50                   	push   %eax
    8c67:	e8 55 fe ff ff       	call   8ac1 <lodepng_color_mode_init>
    8c6c:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8c6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c72:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8c75:	8b 45 10             	mov    0x10(%ebp),%eax
    8c78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8c7b:	8b 45 08             	mov    0x8(%ebp),%eax
    8c7e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8c81:	89 10                	mov    %edx,(%eax)
    8c83:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8c86:	89 50 04             	mov    %edx,0x4(%eax)
    8c89:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8c8c:	89 50 08             	mov    %edx,0x8(%eax)
    8c8f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8c92:	89 50 0c             	mov    %edx,0xc(%eax)
    8c95:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8c98:	89 50 10             	mov    %edx,0x10(%eax)
    8c9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c9e:	89 50 14             	mov    %edx,0x14(%eax)
    8ca1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8ca4:	89 50 18             	mov    %edx,0x18(%eax)
    8ca7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8caa:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8cad:	8b 45 08             	mov    0x8(%ebp),%eax
    8cb0:	c9                   	leave  
    8cb1:	c2 04 00             	ret    $0x4

00008cb4 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8cb4:	55                   	push   %ebp
    8cb5:	89 e5                	mov    %esp,%ebp
    8cb7:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8cba:	8b 45 08             	mov    0x8(%ebp),%eax
    8cbd:	8b 10                	mov    (%eax),%edx
    8cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cc2:	8b 00                	mov    (%eax),%eax
    8cc4:	39 c2                	cmp    %eax,%edx
    8cc6:	74 0a                	je     8cd2 <lodepng_color_mode_equal+0x1e>
    8cc8:	b8 00 00 00 00       	mov    $0x0,%eax
    8ccd:	e9 e4 00 00 00       	jmp    8db6 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8cd2:	8b 45 08             	mov    0x8(%ebp),%eax
    8cd5:	8b 50 04             	mov    0x4(%eax),%edx
    8cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cdb:	8b 40 04             	mov    0x4(%eax),%eax
    8cde:	39 c2                	cmp    %eax,%edx
    8ce0:	74 0a                	je     8cec <lodepng_color_mode_equal+0x38>
    8ce2:	b8 00 00 00 00       	mov    $0x0,%eax
    8ce7:	e9 ca 00 00 00       	jmp    8db6 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8cec:	8b 45 08             	mov    0x8(%ebp),%eax
    8cef:	8b 50 10             	mov    0x10(%eax),%edx
    8cf2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cf5:	8b 40 10             	mov    0x10(%eax),%eax
    8cf8:	39 c2                	cmp    %eax,%edx
    8cfa:	74 0a                	je     8d06 <lodepng_color_mode_equal+0x52>
    8cfc:	b8 00 00 00 00       	mov    $0x0,%eax
    8d01:	e9 b0 00 00 00       	jmp    8db6 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8d06:	8b 45 08             	mov    0x8(%ebp),%eax
    8d09:	8b 40 10             	mov    0x10(%eax),%eax
    8d0c:	85 c0                	test   %eax,%eax
    8d0e:	74 48                	je     8d58 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8d10:	8b 45 08             	mov    0x8(%ebp),%eax
    8d13:	8b 50 14             	mov    0x14(%eax),%edx
    8d16:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d19:	8b 40 14             	mov    0x14(%eax),%eax
    8d1c:	39 c2                	cmp    %eax,%edx
    8d1e:	74 0a                	je     8d2a <lodepng_color_mode_equal+0x76>
    8d20:	b8 00 00 00 00       	mov    $0x0,%eax
    8d25:	e9 8c 00 00 00       	jmp    8db6 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8d2a:	8b 45 08             	mov    0x8(%ebp),%eax
    8d2d:	8b 50 18             	mov    0x18(%eax),%edx
    8d30:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d33:	8b 40 18             	mov    0x18(%eax),%eax
    8d36:	39 c2                	cmp    %eax,%edx
    8d38:	74 07                	je     8d41 <lodepng_color_mode_equal+0x8d>
    8d3a:	b8 00 00 00 00       	mov    $0x0,%eax
    8d3f:	eb 75                	jmp    8db6 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8d41:	8b 45 08             	mov    0x8(%ebp),%eax
    8d44:	8b 50 1c             	mov    0x1c(%eax),%edx
    8d47:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d4a:	8b 40 1c             	mov    0x1c(%eax),%eax
    8d4d:	39 c2                	cmp    %eax,%edx
    8d4f:	74 07                	je     8d58 <lodepng_color_mode_equal+0xa4>
    8d51:	b8 00 00 00 00       	mov    $0x0,%eax
    8d56:	eb 5e                	jmp    8db6 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8d58:	8b 45 08             	mov    0x8(%ebp),%eax
    8d5b:	8b 50 0c             	mov    0xc(%eax),%edx
    8d5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d61:	8b 40 0c             	mov    0xc(%eax),%eax
    8d64:	39 c2                	cmp    %eax,%edx
    8d66:	74 07                	je     8d6f <lodepng_color_mode_equal+0xbb>
    8d68:	b8 00 00 00 00       	mov    $0x0,%eax
    8d6d:	eb 47                	jmp    8db6 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8d6f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8d76:	eb 2b                	jmp    8da3 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8d78:	8b 45 08             	mov    0x8(%ebp),%eax
    8d7b:	8b 50 08             	mov    0x8(%eax),%edx
    8d7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d81:	01 d0                	add    %edx,%eax
    8d83:	0f b6 10             	movzbl (%eax),%edx
    8d86:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d89:	8b 48 08             	mov    0x8(%eax),%ecx
    8d8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d8f:	01 c8                	add    %ecx,%eax
    8d91:	0f b6 00             	movzbl (%eax),%eax
    8d94:	38 c2                	cmp    %al,%dl
    8d96:	74 07                	je     8d9f <lodepng_color_mode_equal+0xeb>
    8d98:	b8 00 00 00 00       	mov    $0x0,%eax
    8d9d:	eb 17                	jmp    8db6 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8d9f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8da3:	8b 45 08             	mov    0x8(%ebp),%eax
    8da6:	8b 40 0c             	mov    0xc(%eax),%eax
    8da9:	c1 e0 02             	shl    $0x2,%eax
    8dac:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8daf:	75 c7                	jne    8d78 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8db1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8db6:	c9                   	leave  
    8db7:	c3                   	ret    

00008db8 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8db8:	55                   	push   %ebp
    8db9:	89 e5                	mov    %esp,%ebp
    8dbb:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8dbe:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc1:	8b 40 08             	mov    0x8(%eax),%eax
    8dc4:	85 c0                	test   %eax,%eax
    8dc6:	74 12                	je     8dda <lodepng_palette_clear+0x22>
    8dc8:	8b 45 08             	mov    0x8(%ebp),%eax
    8dcb:	8b 40 08             	mov    0x8(%eax),%eax
    8dce:	83 ec 0c             	sub    $0xc,%esp
    8dd1:	50                   	push   %eax
    8dd2:	e8 fc a5 ff ff       	call   33d3 <lodepng_free>
    8dd7:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8dda:	8b 45 08             	mov    0x8(%ebp),%eax
    8ddd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8de4:	8b 45 08             	mov    0x8(%ebp),%eax
    8de7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8dee:	90                   	nop
    8def:	c9                   	leave  
    8df0:	c3                   	ret    

00008df1 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8df1:	55                   	push   %ebp
    8df2:	89 e5                	mov    %esp,%ebp
    8df4:	53                   	push   %ebx
    8df5:	83 ec 14             	sub    $0x14,%esp
    8df8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8dfb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8dfe:	8b 55 14             	mov    0x14(%ebp),%edx
    8e01:	8b 45 18             	mov    0x18(%ebp),%eax
    8e04:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8e07:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8e0a:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8e0d:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8e10:	8b 45 08             	mov    0x8(%ebp),%eax
    8e13:	8b 40 08             	mov    0x8(%eax),%eax
    8e16:	85 c0                	test   %eax,%eax
    8e18:	75 22                	jne    8e3c <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8e1a:	83 ec 0c             	sub    $0xc,%esp
    8e1d:	ff 75 08             	pushl  0x8(%ebp)
    8e20:	e8 f5 fc ff ff       	call   8b1a <lodepng_color_mode_alloc_palette>
    8e25:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8e28:	8b 45 08             	mov    0x8(%ebp),%eax
    8e2b:	8b 40 08             	mov    0x8(%eax),%eax
    8e2e:	85 c0                	test   %eax,%eax
    8e30:	75 0a                	jne    8e3c <lodepng_palette_add+0x4b>
    8e32:	b8 53 00 00 00       	mov    $0x53,%eax
    8e37:	e9 8d 00 00 00       	jmp    8ec9 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8e3c:	8b 45 08             	mov    0x8(%ebp),%eax
    8e3f:	8b 40 0c             	mov    0xc(%eax),%eax
    8e42:	3d ff 00 00 00       	cmp    $0xff,%eax
    8e47:	7e 07                	jle    8e50 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8e49:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8e4e:	eb 79                	jmp    8ec9 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8e50:	8b 45 08             	mov    0x8(%ebp),%eax
    8e53:	8b 50 08             	mov    0x8(%eax),%edx
    8e56:	8b 45 08             	mov    0x8(%ebp),%eax
    8e59:	8b 40 0c             	mov    0xc(%eax),%eax
    8e5c:	c1 e0 02             	shl    $0x2,%eax
    8e5f:	01 c2                	add    %eax,%edx
    8e61:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8e65:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8e67:	8b 45 08             	mov    0x8(%ebp),%eax
    8e6a:	8b 50 08             	mov    0x8(%eax),%edx
    8e6d:	8b 45 08             	mov    0x8(%ebp),%eax
    8e70:	8b 40 0c             	mov    0xc(%eax),%eax
    8e73:	c1 e0 02             	shl    $0x2,%eax
    8e76:	83 c0 01             	add    $0x1,%eax
    8e79:	01 c2                	add    %eax,%edx
    8e7b:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8e7f:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8e81:	8b 45 08             	mov    0x8(%ebp),%eax
    8e84:	8b 50 08             	mov    0x8(%eax),%edx
    8e87:	8b 45 08             	mov    0x8(%ebp),%eax
    8e8a:	8b 40 0c             	mov    0xc(%eax),%eax
    8e8d:	c1 e0 02             	shl    $0x2,%eax
    8e90:	83 c0 02             	add    $0x2,%eax
    8e93:	01 c2                	add    %eax,%edx
    8e95:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8e99:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8e9b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e9e:	8b 50 08             	mov    0x8(%eax),%edx
    8ea1:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea4:	8b 40 0c             	mov    0xc(%eax),%eax
    8ea7:	c1 e0 02             	shl    $0x2,%eax
    8eaa:	83 c0 03             	add    $0x3,%eax
    8ead:	01 c2                	add    %eax,%edx
    8eaf:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8eb3:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8eb5:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb8:	8b 40 0c             	mov    0xc(%eax),%eax
    8ebb:	8d 50 01             	lea    0x1(%eax),%edx
    8ebe:	8b 45 08             	mov    0x8(%ebp),%eax
    8ec1:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8ec4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8ec9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8ecc:	c9                   	leave  
    8ecd:	c3                   	ret    

00008ece <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8ece:	55                   	push   %ebp
    8ecf:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8ed1:	8b 45 08             	mov    0x8(%ebp),%eax
    8ed4:	8b 50 04             	mov    0x4(%eax),%edx
    8ed7:	8b 45 08             	mov    0x8(%ebp),%eax
    8eda:	8b 00                	mov    (%eax),%eax
    8edc:	52                   	push   %edx
    8edd:	50                   	push   %eax
    8ede:	e8 ca fb ff ff       	call   8aad <lodepng_get_bpp_lct>
    8ee3:	83 c4 08             	add    $0x8,%esp
}
    8ee6:	c9                   	leave  
    8ee7:	c3                   	ret    

00008ee8 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8ee8:	55                   	push   %ebp
    8ee9:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8eeb:	8b 45 08             	mov    0x8(%ebp),%eax
    8eee:	8b 00                	mov    (%eax),%eax
    8ef0:	50                   	push   %eax
    8ef1:	e8 58 fb ff ff       	call   8a4e <getNumColorChannels>
    8ef6:	83 c4 04             	add    $0x4,%esp
}
    8ef9:	c9                   	leave  
    8efa:	c3                   	ret    

00008efb <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8efb:	55                   	push   %ebp
    8efc:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8efe:	8b 45 08             	mov    0x8(%ebp),%eax
    8f01:	8b 00                	mov    (%eax),%eax
    8f03:	85 c0                	test   %eax,%eax
    8f05:	74 0a                	je     8f11 <lodepng_is_greyscale_type+0x16>
    8f07:	8b 45 08             	mov    0x8(%ebp),%eax
    8f0a:	8b 00                	mov    (%eax),%eax
    8f0c:	83 f8 04             	cmp    $0x4,%eax
    8f0f:	75 07                	jne    8f18 <lodepng_is_greyscale_type+0x1d>
    8f11:	b8 01 00 00 00       	mov    $0x1,%eax
    8f16:	eb 05                	jmp    8f1d <lodepng_is_greyscale_type+0x22>
    8f18:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f1d:	5d                   	pop    %ebp
    8f1e:	c3                   	ret    

00008f1f <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8f1f:	55                   	push   %ebp
    8f20:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8f22:	8b 45 08             	mov    0x8(%ebp),%eax
    8f25:	8b 00                	mov    (%eax),%eax
    8f27:	83 e0 04             	and    $0x4,%eax
    8f2a:	85 c0                	test   %eax,%eax
    8f2c:	0f 95 c0             	setne  %al
    8f2f:	0f b6 c0             	movzbl %al,%eax
}
    8f32:	5d                   	pop    %ebp
    8f33:	c3                   	ret    

00008f34 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8f34:	55                   	push   %ebp
    8f35:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8f37:	8b 45 08             	mov    0x8(%ebp),%eax
    8f3a:	8b 00                	mov    (%eax),%eax
    8f3c:	83 f8 03             	cmp    $0x3,%eax
    8f3f:	0f 94 c0             	sete   %al
    8f42:	0f b6 c0             	movzbl %al,%eax
}
    8f45:	5d                   	pop    %ebp
    8f46:	c3                   	ret    

00008f47 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8f47:	55                   	push   %ebp
    8f48:	89 e5                	mov    %esp,%ebp
    8f4a:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8f4d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8f54:	eb 23                	jmp    8f79 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8f56:	8b 45 08             	mov    0x8(%ebp),%eax
    8f59:	8b 40 08             	mov    0x8(%eax),%eax
    8f5c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f5f:	c1 e2 02             	shl    $0x2,%edx
    8f62:	83 c2 03             	add    $0x3,%edx
    8f65:	01 d0                	add    %edx,%eax
    8f67:	0f b6 00             	movzbl (%eax),%eax
    8f6a:	3c ff                	cmp    $0xff,%al
    8f6c:	74 07                	je     8f75 <lodepng_has_palette_alpha+0x2e>
    8f6e:	b8 01 00 00 00       	mov    $0x1,%eax
    8f73:	eb 14                	jmp    8f89 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8f75:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8f79:	8b 45 08             	mov    0x8(%ebp),%eax
    8f7c:	8b 40 0c             	mov    0xc(%eax),%eax
    8f7f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8f82:	75 d2                	jne    8f56 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8f84:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f89:	c9                   	leave  
    8f8a:	c3                   	ret    

00008f8b <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8f8b:	55                   	push   %ebp
    8f8c:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8f8e:	8b 45 08             	mov    0x8(%ebp),%eax
    8f91:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8f94:	85 c0                	test   %eax,%eax
    8f96:	75 1e                	jne    8fb6 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8f98:	ff 75 08             	pushl  0x8(%ebp)
    8f9b:	e8 7f ff ff ff       	call   8f1f <lodepng_is_alpha_type>
    8fa0:	83 c4 04             	add    $0x4,%esp
    8fa3:	85 c0                	test   %eax,%eax
    8fa5:	75 0f                	jne    8fb6 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8fa7:	ff 75 08             	pushl  0x8(%ebp)
    8faa:	e8 98 ff ff ff       	call   8f47 <lodepng_has_palette_alpha>
    8faf:	83 c4 04             	add    $0x4,%esp
    8fb2:	85 c0                	test   %eax,%eax
    8fb4:	74 07                	je     8fbd <lodepng_can_have_alpha+0x32>
    8fb6:	b8 01 00 00 00       	mov    $0x1,%eax
    8fbb:	eb 05                	jmp    8fc2 <lodepng_can_have_alpha+0x37>
    8fbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8fc2:	c9                   	leave  
    8fc3:	c3                   	ret    

00008fc4 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    8fc4:	55                   	push   %ebp
    8fc5:	89 e5                	mov    %esp,%ebp
    8fc7:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    8fca:	ff 75 14             	pushl  0x14(%ebp)
    8fcd:	ff 75 10             	pushl  0x10(%ebp)
    8fd0:	e8 d8 fa ff ff       	call   8aad <lodepng_get_bpp_lct>
    8fd5:	83 c4 08             	add    $0x8,%esp
    8fd8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    8fdb:	8b 55 08             	mov    0x8(%ebp),%edx
    8fde:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fe1:	0f af c2             	imul   %edx,%eax
    8fe4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    8fe7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8fea:	c1 e8 03             	shr    $0x3,%eax
    8fed:	89 c2                	mov    %eax,%edx
    8fef:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8ff2:	0f af c2             	imul   %edx,%eax
    8ff5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8ff8:	89 d1                	mov    %edx,%ecx
    8ffa:	83 e1 07             	and    $0x7,%ecx
    8ffd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9000:	0f af d1             	imul   %ecx,%edx
    9003:	83 c2 07             	add    $0x7,%edx
    9006:	c1 ea 03             	shr    $0x3,%edx
    9009:	01 d0                	add    %edx,%eax
}
    900b:	c9                   	leave  
    900c:	c3                   	ret    

0000900d <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    900d:	55                   	push   %ebp
    900e:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    9010:	8b 45 10             	mov    0x10(%ebp),%eax
    9013:	8b 50 04             	mov    0x4(%eax),%edx
    9016:	8b 45 10             	mov    0x10(%ebp),%eax
    9019:	8b 00                	mov    (%eax),%eax
    901b:	52                   	push   %edx
    901c:	50                   	push   %eax
    901d:	ff 75 0c             	pushl  0xc(%ebp)
    9020:	ff 75 08             	pushl  0x8(%ebp)
    9023:	e8 9c ff ff ff       	call   8fc4 <lodepng_get_raw_size_lct>
    9028:	83 c4 10             	add    $0x10,%esp
}
    902b:	c9                   	leave  
    902c:	c3                   	ret    

0000902d <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    902d:	55                   	push   %ebp
    902e:	89 e5                	mov    %esp,%ebp
    9030:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9033:	8b 45 08             	mov    0x8(%ebp),%eax
    9036:	c1 e8 03             	shr    $0x3,%eax
    9039:	0f af 45 10          	imul   0x10(%ebp),%eax
    903d:	8b 55 08             	mov    0x8(%ebp),%edx
    9040:	83 e2 07             	and    $0x7,%edx
    9043:	0f af 55 10          	imul   0x10(%ebp),%edx
    9047:	83 c2 07             	add    $0x7,%edx
    904a:	c1 ea 03             	shr    $0x3,%edx
    904d:	01 d0                	add    %edx,%eax
    904f:	83 c0 01             	add    $0x1,%eax
    9052:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    9055:	8b 45 0c             	mov    0xc(%ebp),%eax
    9058:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    905c:	c9                   	leave  
    905d:	c3                   	ret    

0000905e <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    905e:	55                   	push   %ebp
    905f:	89 e5                	mov    %esp,%ebp
    9061:	53                   	push   %ebx
    9062:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    9065:	ff 75 10             	pushl  0x10(%ebp)
    9068:	e8 61 fe ff ff       	call   8ece <lodepng_get_bpp>
    906d:	83 c4 04             	add    $0x4,%esp
    9070:	89 c3                	mov    %eax,%ebx
    9072:	ff 75 14             	pushl  0x14(%ebp)
    9075:	e8 54 fe ff ff       	call   8ece <lodepng_get_bpp>
    907a:	83 c4 04             	add    $0x4,%esp
    907d:	39 c3                	cmp    %eax,%ebx
    907f:	76 0d                	jbe    908e <lodepng_pixel_overflow+0x30>
    9081:	ff 75 10             	pushl  0x10(%ebp)
    9084:	e8 45 fe ff ff       	call   8ece <lodepng_get_bpp>
    9089:	83 c4 04             	add    $0x4,%esp
    908c:	eb 0b                	jmp    9099 <lodepng_pixel_overflow+0x3b>
    908e:	ff 75 14             	pushl  0x14(%ebp)
    9091:	e8 38 fe ff ff       	call   8ece <lodepng_get_bpp>
    9096:	83 c4 04             	add    $0x4,%esp
    9099:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    909c:	8b 55 0c             	mov    0xc(%ebp),%edx
    909f:	8b 45 08             	mov    0x8(%ebp),%eax
    90a2:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    90a5:	51                   	push   %ecx
    90a6:	52                   	push   %edx
    90a7:	50                   	push   %eax
    90a8:	e8 e9 a3 ff ff       	call   3496 <lodepng_mulofl>
    90ad:	83 c4 0c             	add    $0xc,%esp
    90b0:	85 c0                	test   %eax,%eax
    90b2:	74 0a                	je     90be <lodepng_pixel_overflow+0x60>
    90b4:	b8 01 00 00 00       	mov    $0x1,%eax
    90b9:	e9 b6 00 00 00       	jmp    9174 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    90be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    90c1:	8d 55 f0             	lea    -0x10(%ebp),%edx
    90c4:	52                   	push   %edx
    90c5:	6a 08                	push   $0x8
    90c7:	50                   	push   %eax
    90c8:	e8 c9 a3 ff ff       	call   3496 <lodepng_mulofl>
    90cd:	83 c4 0c             	add    $0xc,%esp
    90d0:	85 c0                	test   %eax,%eax
    90d2:	74 0a                	je     90de <lodepng_pixel_overflow+0x80>
    90d4:	b8 01 00 00 00       	mov    $0x1,%eax
    90d9:	e9 96 00 00 00       	jmp    9174 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    90de:	8b 45 08             	mov    0x8(%ebp),%eax
    90e1:	c1 e8 03             	shr    $0x3,%eax
    90e4:	89 c2                	mov    %eax,%edx
    90e6:	8d 45 ec             	lea    -0x14(%ebp),%eax
    90e9:	50                   	push   %eax
    90ea:	ff 75 f8             	pushl  -0x8(%ebp)
    90ed:	52                   	push   %edx
    90ee:	e8 a3 a3 ff ff       	call   3496 <lodepng_mulofl>
    90f3:	83 c4 0c             	add    $0xc,%esp
    90f6:	85 c0                	test   %eax,%eax
    90f8:	74 07                	je     9101 <lodepng_pixel_overflow+0xa3>
    90fa:	b8 01 00 00 00       	mov    $0x1,%eax
    90ff:	eb 73                	jmp    9174 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9101:	8b 45 08             	mov    0x8(%ebp),%eax
    9104:	83 e0 07             	and    $0x7,%eax
    9107:	89 c2                	mov    %eax,%edx
    9109:	8b 45 f8             	mov    -0x8(%ebp),%eax
    910c:	0f af c2             	imul   %edx,%eax
    910f:	83 c0 07             	add    $0x7,%eax
    9112:	c1 e8 03             	shr    $0x3,%eax
    9115:	89 c1                	mov    %eax,%ecx
    9117:	8b 45 ec             	mov    -0x14(%ebp),%eax
    911a:	8d 55 ec             	lea    -0x14(%ebp),%edx
    911d:	52                   	push   %edx
    911e:	51                   	push   %ecx
    911f:	50                   	push   %eax
    9120:	e8 51 a3 ff ff       	call   3476 <lodepng_addofl>
    9125:	83 c4 0c             	add    $0xc,%esp
    9128:	85 c0                	test   %eax,%eax
    912a:	74 07                	je     9133 <lodepng_pixel_overflow+0xd5>
    912c:	b8 01 00 00 00       	mov    $0x1,%eax
    9131:	eb 41                	jmp    9174 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9133:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9136:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9139:	52                   	push   %edx
    913a:	6a 05                	push   $0x5
    913c:	50                   	push   %eax
    913d:	e8 34 a3 ff ff       	call   3476 <lodepng_addofl>
    9142:	83 c4 0c             	add    $0xc,%esp
    9145:	85 c0                	test   %eax,%eax
    9147:	74 07                	je     9150 <lodepng_pixel_overflow+0xf2>
    9149:	b8 01 00 00 00       	mov    $0x1,%eax
    914e:	eb 24                	jmp    9174 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    9150:	8b 55 0c             	mov    0xc(%ebp),%edx
    9153:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9156:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    9159:	51                   	push   %ecx
    915a:	52                   	push   %edx
    915b:	50                   	push   %eax
    915c:	e8 35 a3 ff ff       	call   3496 <lodepng_mulofl>
    9161:	83 c4 0c             	add    $0xc,%esp
    9164:	85 c0                	test   %eax,%eax
    9166:	74 07                	je     916f <lodepng_pixel_overflow+0x111>
    9168:	b8 01 00 00 00       	mov    $0x1,%eax
    916d:	eb 05                	jmp    9174 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    916f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9174:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9177:	c9                   	leave  
    9178:	c3                   	ret    

00009179 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    9179:	55                   	push   %ebp
    917a:	89 e5                	mov    %esp,%ebp
    917c:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    917f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9186:	eb 15                	jmp    919d <LodePNGUnknownChunks_init+0x24>
    9188:	8b 45 08             	mov    0x8(%ebp),%eax
    918b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    918e:	83 c2 30             	add    $0x30,%edx
    9191:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    9198:	00 
    9199:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    919d:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    91a1:	75 e5                	jne    9188 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    91a3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    91aa:	eb 15                	jmp    91c1 <LodePNGUnknownChunks_init+0x48>
    91ac:	8b 45 08             	mov    0x8(%ebp),%eax
    91af:	8b 55 fc             	mov    -0x4(%ebp),%edx
    91b2:	83 c2 34             	add    $0x34,%edx
    91b5:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    91bc:	00 
    91bd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    91c1:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    91c5:	75 e5                	jne    91ac <LodePNGUnknownChunks_init+0x33>
}
    91c7:	90                   	nop
    91c8:	c9                   	leave  
    91c9:	c3                   	ret    

000091ca <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    91ca:	55                   	push   %ebp
    91cb:	89 e5                	mov    %esp,%ebp
    91cd:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    91d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    91d7:	eb 1d                	jmp    91f6 <LodePNGUnknownChunks_cleanup+0x2c>
    91d9:	8b 45 08             	mov    0x8(%ebp),%eax
    91dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91df:	83 c2 30             	add    $0x30,%edx
    91e2:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    91e6:	83 ec 0c             	sub    $0xc,%esp
    91e9:	50                   	push   %eax
    91ea:	e8 e4 a1 ff ff       	call   33d3 <lodepng_free>
    91ef:	83 c4 10             	add    $0x10,%esp
    91f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    91f6:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    91fa:	75 dd                	jne    91d9 <LodePNGUnknownChunks_cleanup+0xf>
}
    91fc:	90                   	nop
    91fd:	c9                   	leave  
    91fe:	c3                   	ret    

000091ff <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    91ff:	55                   	push   %ebp
    9200:	89 e5                	mov    %esp,%ebp
    9202:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9205:	83 ec 0c             	sub    $0xc,%esp
    9208:	ff 75 08             	pushl  0x8(%ebp)
    920b:	e8 ba ff ff ff       	call   91ca <LodePNGUnknownChunks_cleanup>
    9210:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9213:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    921a:	e9 b7 00 00 00       	jmp    92d6 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    921f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9222:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9225:	83 c2 34             	add    $0x34,%edx
    9228:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    922c:	8b 45 08             	mov    0x8(%ebp),%eax
    922f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9232:	83 c1 34             	add    $0x34,%ecx
    9235:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    9239:	8b 45 0c             	mov    0xc(%ebp),%eax
    923c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    923f:	83 c2 34             	add    $0x34,%edx
    9242:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9246:	83 ec 0c             	sub    $0xc,%esp
    9249:	50                   	push   %eax
    924a:	e8 63 a1 ff ff       	call   33b2 <lodepng_malloc>
    924f:	83 c4 10             	add    $0x10,%esp
    9252:	89 c1                	mov    %eax,%ecx
    9254:	8b 45 08             	mov    0x8(%ebp),%eax
    9257:	8b 55 f4             	mov    -0xc(%ebp),%edx
    925a:	83 c2 30             	add    $0x30,%edx
    925d:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    9261:	8b 45 08             	mov    0x8(%ebp),%eax
    9264:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9267:	83 c2 30             	add    $0x30,%edx
    926a:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    926e:	85 c0                	test   %eax,%eax
    9270:	75 18                	jne    928a <LodePNGUnknownChunks_copy+0x8b>
    9272:	8b 45 08             	mov    0x8(%ebp),%eax
    9275:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9278:	83 c2 34             	add    $0x34,%edx
    927b:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    927f:	85 c0                	test   %eax,%eax
    9281:	74 07                	je     928a <LodePNGUnknownChunks_copy+0x8b>
    9283:	b8 53 00 00 00       	mov    $0x53,%eax
    9288:	eb 5b                	jmp    92e5 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    928a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9291:	eb 2d                	jmp    92c0 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    9293:	8b 45 08             	mov    0x8(%ebp),%eax
    9296:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9299:	83 c2 30             	add    $0x30,%edx
    929c:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    92a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92a3:	01 c2                	add    %eax,%edx
    92a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    92a8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    92ab:	83 c1 30             	add    $0x30,%ecx
    92ae:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    92b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92b5:	01 c8                	add    %ecx,%eax
    92b7:	0f b6 00             	movzbl (%eax),%eax
    92ba:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    92bc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    92c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    92c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92c6:	83 c2 34             	add    $0x34,%edx
    92c9:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    92cd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    92d0:	7f c1                	jg     9293 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    92d2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92d6:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    92da:	0f 85 3f ff ff ff    	jne    921f <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    92e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    92e5:	c9                   	leave  
    92e6:	c3                   	ret    

000092e7 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    92e7:	55                   	push   %ebp
    92e8:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    92ea:	8b 45 08             	mov    0x8(%ebp),%eax
    92ed:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    92f4:	8b 45 08             	mov    0x8(%ebp),%eax
    92f7:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    92fe:	8b 45 08             	mov    0x8(%ebp),%eax
    9301:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9308:	90                   	nop
    9309:	5d                   	pop    %ebp
    930a:	c3                   	ret    

0000930b <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    930b:	55                   	push   %ebp
    930c:	89 e5                	mov    %esp,%ebp
    930e:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9311:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9318:	eb 38                	jmp    9352 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    931a:	8b 45 08             	mov    0x8(%ebp),%eax
    931d:	8b 40 40             	mov    0x40(%eax),%eax
    9320:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9323:	c1 e2 02             	shl    $0x2,%edx
    9326:	01 d0                	add    %edx,%eax
    9328:	83 ec 0c             	sub    $0xc,%esp
    932b:	50                   	push   %eax
    932c:	e8 75 a3 ff ff       	call   36a6 <string_cleanup>
    9331:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9334:	8b 45 08             	mov    0x8(%ebp),%eax
    9337:	8b 40 44             	mov    0x44(%eax),%eax
    933a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    933d:	c1 e2 02             	shl    $0x2,%edx
    9340:	01 d0                	add    %edx,%eax
    9342:	83 ec 0c             	sub    $0xc,%esp
    9345:	50                   	push   %eax
    9346:	e8 5b a3 ff ff       	call   36a6 <string_cleanup>
    934b:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    934e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9352:	8b 45 08             	mov    0x8(%ebp),%eax
    9355:	8b 40 3c             	mov    0x3c(%eax),%eax
    9358:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    935b:	75 bd                	jne    931a <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    935d:	8b 45 08             	mov    0x8(%ebp),%eax
    9360:	8b 40 40             	mov    0x40(%eax),%eax
    9363:	83 ec 0c             	sub    $0xc,%esp
    9366:	50                   	push   %eax
    9367:	e8 67 a0 ff ff       	call   33d3 <lodepng_free>
    936c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    936f:	8b 45 08             	mov    0x8(%ebp),%eax
    9372:	8b 40 44             	mov    0x44(%eax),%eax
    9375:	83 ec 0c             	sub    $0xc,%esp
    9378:	50                   	push   %eax
    9379:	e8 55 a0 ff ff       	call   33d3 <lodepng_free>
    937e:	83 c4 10             	add    $0x10,%esp
}
    9381:	90                   	nop
    9382:	c9                   	leave  
    9383:	c3                   	ret    

00009384 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9384:	55                   	push   %ebp
    9385:	89 e5                	mov    %esp,%ebp
    9387:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    938a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    9391:	8b 45 08             	mov    0x8(%ebp),%eax
    9394:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    939b:	8b 45 08             	mov    0x8(%ebp),%eax
    939e:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    93a5:	8b 45 08             	mov    0x8(%ebp),%eax
    93a8:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    93af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    93b6:	eb 42                	jmp    93fa <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    93b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    93bb:	8b 40 44             	mov    0x44(%eax),%eax
    93be:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93c1:	c1 e2 02             	shl    $0x2,%edx
    93c4:	01 d0                	add    %edx,%eax
    93c6:	8b 10                	mov    (%eax),%edx
    93c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    93cb:	8b 40 40             	mov    0x40(%eax),%eax
    93ce:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    93d1:	c1 e1 02             	shl    $0x2,%ecx
    93d4:	01 c8                	add    %ecx,%eax
    93d6:	8b 00                	mov    (%eax),%eax
    93d8:	83 ec 04             	sub    $0x4,%esp
    93db:	52                   	push   %edx
    93dc:	50                   	push   %eax
    93dd:	ff 75 08             	pushl  0x8(%ebp)
    93e0:	e8 4d 01 00 00       	call   9532 <lodepng_add_text>
    93e5:	83 c4 10             	add    $0x10,%esp
    93e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    93eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93ef:	74 05                	je     93f6 <LodePNGText_copy+0x72>
    93f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    93f4:	eb 14                	jmp    940a <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    93f6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    93fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    93fd:	8b 40 3c             	mov    0x3c(%eax),%eax
    9400:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9403:	75 b3                	jne    93b8 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9405:	b8 00 00 00 00       	mov    $0x0,%eax
}
    940a:	c9                   	leave  
    940b:	c3                   	ret    

0000940c <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    940c:	55                   	push   %ebp
    940d:	89 e5                	mov    %esp,%ebp
    940f:	53                   	push   %ebx
    9410:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9413:	8b 45 08             	mov    0x8(%ebp),%eax
    9416:	8b 40 3c             	mov    0x3c(%eax),%eax
    9419:	83 c0 01             	add    $0x1,%eax
    941c:	c1 e0 02             	shl    $0x2,%eax
    941f:	89 c2                	mov    %eax,%edx
    9421:	8b 45 08             	mov    0x8(%ebp),%eax
    9424:	8b 40 40             	mov    0x40(%eax),%eax
    9427:	52                   	push   %edx
    9428:	50                   	push   %eax
    9429:	e8 9b 9f ff ff       	call   33c9 <lodepng_realloc>
    942e:	83 c4 08             	add    $0x8,%esp
    9431:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9434:	8b 45 08             	mov    0x8(%ebp),%eax
    9437:	8b 40 3c             	mov    0x3c(%eax),%eax
    943a:	83 c0 01             	add    $0x1,%eax
    943d:	c1 e0 02             	shl    $0x2,%eax
    9440:	89 c2                	mov    %eax,%edx
    9442:	8b 45 08             	mov    0x8(%ebp),%eax
    9445:	8b 40 44             	mov    0x44(%eax),%eax
    9448:	52                   	push   %edx
    9449:	50                   	push   %eax
    944a:	e8 7a 9f ff ff       	call   33c9 <lodepng_realloc>
    944f:	83 c4 08             	add    $0x8,%esp
    9452:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    9455:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9459:	74 09                	je     9464 <lodepng_add_text_sized+0x58>
    945b:	8b 45 08             	mov    0x8(%ebp),%eax
    945e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9461:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    9464:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9468:	74 09                	je     9473 <lodepng_add_text_sized+0x67>
    946a:	8b 45 08             	mov    0x8(%ebp),%eax
    946d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9470:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    9473:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9477:	74 06                	je     947f <lodepng_add_text_sized+0x73>
    9479:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    947d:	75 0a                	jne    9489 <lodepng_add_text_sized+0x7d>
    947f:	b8 53 00 00 00       	mov    $0x53,%eax
    9484:	e9 a4 00 00 00       	jmp    952d <lodepng_add_text_sized+0x121>

  ++info->text_num;
    9489:	8b 45 08             	mov    0x8(%ebp),%eax
    948c:	8b 40 3c             	mov    0x3c(%eax),%eax
    948f:	8d 50 01             	lea    0x1(%eax),%edx
    9492:	8b 45 08             	mov    0x8(%ebp),%eax
    9495:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    9498:	8b 45 08             	mov    0x8(%ebp),%eax
    949b:	8b 50 40             	mov    0x40(%eax),%edx
    949e:	8b 45 08             	mov    0x8(%ebp),%eax
    94a1:	8b 40 3c             	mov    0x3c(%eax),%eax
    94a4:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    94a9:	c1 e0 02             	shl    $0x2,%eax
    94ac:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    94af:	83 ec 0c             	sub    $0xc,%esp
    94b2:	ff 75 0c             	pushl  0xc(%ebp)
    94b5:	e8 54 a2 ff ff       	call   370e <alloc_string>
    94ba:	83 c4 10             	add    $0x10,%esp
    94bd:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    94bf:	8b 45 08             	mov    0x8(%ebp),%eax
    94c2:	8b 50 44             	mov    0x44(%eax),%edx
    94c5:	8b 45 08             	mov    0x8(%ebp),%eax
    94c8:	8b 40 3c             	mov    0x3c(%eax),%eax
    94cb:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    94d0:	c1 e0 02             	shl    $0x2,%eax
    94d3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    94d6:	83 ec 08             	sub    $0x8,%esp
    94d9:	ff 75 14             	pushl  0x14(%ebp)
    94dc:	ff 75 10             	pushl  0x10(%ebp)
    94df:	e8 e5 a1 ff ff       	call   36c9 <alloc_string_sized>
    94e4:	83 c4 10             	add    $0x10,%esp
    94e7:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    94e9:	8b 45 08             	mov    0x8(%ebp),%eax
    94ec:	8b 50 40             	mov    0x40(%eax),%edx
    94ef:	8b 45 08             	mov    0x8(%ebp),%eax
    94f2:	8b 40 3c             	mov    0x3c(%eax),%eax
    94f5:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    94fa:	c1 e0 02             	shl    $0x2,%eax
    94fd:	01 d0                	add    %edx,%eax
    94ff:	8b 00                	mov    (%eax),%eax
    9501:	85 c0                	test   %eax,%eax
    9503:	74 1c                	je     9521 <lodepng_add_text_sized+0x115>
    9505:	8b 45 08             	mov    0x8(%ebp),%eax
    9508:	8b 50 44             	mov    0x44(%eax),%edx
    950b:	8b 45 08             	mov    0x8(%ebp),%eax
    950e:	8b 40 3c             	mov    0x3c(%eax),%eax
    9511:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9516:	c1 e0 02             	shl    $0x2,%eax
    9519:	01 d0                	add    %edx,%eax
    951b:	8b 00                	mov    (%eax),%eax
    951d:	85 c0                	test   %eax,%eax
    951f:	75 07                	jne    9528 <lodepng_add_text_sized+0x11c>
    9521:	b8 53 00 00 00       	mov    $0x53,%eax
    9526:	eb 05                	jmp    952d <lodepng_add_text_sized+0x121>

  return 0;
    9528:	b8 00 00 00 00       	mov    $0x0,%eax
}
    952d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9530:	c9                   	leave  
    9531:	c3                   	ret    

00009532 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9532:	55                   	push   %ebp
    9533:	89 e5                	mov    %esp,%ebp
    9535:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    9538:	ff 75 10             	pushl  0x10(%ebp)
    953b:	e8 0e 9f ff ff       	call   344e <lodepng_strlen>
    9540:	83 c4 04             	add    $0x4,%esp
    9543:	50                   	push   %eax
    9544:	ff 75 10             	pushl  0x10(%ebp)
    9547:	ff 75 0c             	pushl  0xc(%ebp)
    954a:	ff 75 08             	pushl  0x8(%ebp)
    954d:	e8 ba fe ff ff       	call   940c <lodepng_add_text_sized>
    9552:	83 c4 10             	add    $0x10,%esp
}
    9555:	c9                   	leave  
    9556:	c3                   	ret    

00009557 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    9557:	55                   	push   %ebp
    9558:	89 e5                	mov    %esp,%ebp
    955a:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    955d:	83 ec 0c             	sub    $0xc,%esp
    9560:	ff 75 08             	pushl  0x8(%ebp)
    9563:	e8 a3 fd ff ff       	call   930b <LodePNGText_cleanup>
    9568:	83 c4 10             	add    $0x10,%esp
}
    956b:	90                   	nop
    956c:	c9                   	leave  
    956d:	c3                   	ret    

0000956e <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    956e:	55                   	push   %ebp
    956f:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    9571:	8b 45 08             	mov    0x8(%ebp),%eax
    9574:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    957b:	8b 45 08             	mov    0x8(%ebp),%eax
    957e:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    9585:	8b 45 08             	mov    0x8(%ebp),%eax
    9588:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    958f:	8b 45 08             	mov    0x8(%ebp),%eax
    9592:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    9599:	8b 45 08             	mov    0x8(%ebp),%eax
    959c:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    95a3:	90                   	nop
    95a4:	5d                   	pop    %ebp
    95a5:	c3                   	ret    

000095a6 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    95a6:	55                   	push   %ebp
    95a7:	89 e5                	mov    %esp,%ebp
    95a9:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    95ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    95b3:	eb 6c                	jmp    9621 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    95b5:	8b 45 08             	mov    0x8(%ebp),%eax
    95b8:	8b 40 4c             	mov    0x4c(%eax),%eax
    95bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95be:	c1 e2 02             	shl    $0x2,%edx
    95c1:	01 d0                	add    %edx,%eax
    95c3:	83 ec 0c             	sub    $0xc,%esp
    95c6:	50                   	push   %eax
    95c7:	e8 da a0 ff ff       	call   36a6 <string_cleanup>
    95cc:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    95cf:	8b 45 08             	mov    0x8(%ebp),%eax
    95d2:	8b 40 50             	mov    0x50(%eax),%eax
    95d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95d8:	c1 e2 02             	shl    $0x2,%edx
    95db:	01 d0                	add    %edx,%eax
    95dd:	83 ec 0c             	sub    $0xc,%esp
    95e0:	50                   	push   %eax
    95e1:	e8 c0 a0 ff ff       	call   36a6 <string_cleanup>
    95e6:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    95e9:	8b 45 08             	mov    0x8(%ebp),%eax
    95ec:	8b 40 54             	mov    0x54(%eax),%eax
    95ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95f2:	c1 e2 02             	shl    $0x2,%edx
    95f5:	01 d0                	add    %edx,%eax
    95f7:	83 ec 0c             	sub    $0xc,%esp
    95fa:	50                   	push   %eax
    95fb:	e8 a6 a0 ff ff       	call   36a6 <string_cleanup>
    9600:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9603:	8b 45 08             	mov    0x8(%ebp),%eax
    9606:	8b 40 58             	mov    0x58(%eax),%eax
    9609:	8b 55 f4             	mov    -0xc(%ebp),%edx
    960c:	c1 e2 02             	shl    $0x2,%edx
    960f:	01 d0                	add    %edx,%eax
    9611:	83 ec 0c             	sub    $0xc,%esp
    9614:	50                   	push   %eax
    9615:	e8 8c a0 ff ff       	call   36a6 <string_cleanup>
    961a:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    961d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9621:	8b 45 08             	mov    0x8(%ebp),%eax
    9624:	8b 40 48             	mov    0x48(%eax),%eax
    9627:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    962a:	75 89                	jne    95b5 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    962c:	8b 45 08             	mov    0x8(%ebp),%eax
    962f:	8b 40 4c             	mov    0x4c(%eax),%eax
    9632:	83 ec 0c             	sub    $0xc,%esp
    9635:	50                   	push   %eax
    9636:	e8 98 9d ff ff       	call   33d3 <lodepng_free>
    963b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    963e:	8b 45 08             	mov    0x8(%ebp),%eax
    9641:	8b 40 50             	mov    0x50(%eax),%eax
    9644:	83 ec 0c             	sub    $0xc,%esp
    9647:	50                   	push   %eax
    9648:	e8 86 9d ff ff       	call   33d3 <lodepng_free>
    964d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    9650:	8b 45 08             	mov    0x8(%ebp),%eax
    9653:	8b 40 54             	mov    0x54(%eax),%eax
    9656:	83 ec 0c             	sub    $0xc,%esp
    9659:	50                   	push   %eax
    965a:	e8 74 9d ff ff       	call   33d3 <lodepng_free>
    965f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    9662:	8b 45 08             	mov    0x8(%ebp),%eax
    9665:	8b 40 58             	mov    0x58(%eax),%eax
    9668:	83 ec 0c             	sub    $0xc,%esp
    966b:	50                   	push   %eax
    966c:	e8 62 9d ff ff       	call   33d3 <lodepng_free>
    9671:	83 c4 10             	add    $0x10,%esp
}
    9674:	90                   	nop
    9675:	c9                   	leave  
    9676:	c3                   	ret    

00009677 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9677:	55                   	push   %ebp
    9678:	89 e5                	mov    %esp,%ebp
    967a:	56                   	push   %esi
    967b:	53                   	push   %ebx
    967c:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    967f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    9686:	8b 45 08             	mov    0x8(%ebp),%eax
    9689:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    9690:	8b 45 08             	mov    0x8(%ebp),%eax
    9693:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    969a:	8b 45 08             	mov    0x8(%ebp),%eax
    969d:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    96a4:	8b 45 08             	mov    0x8(%ebp),%eax
    96a7:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    96ae:	8b 45 08             	mov    0x8(%ebp),%eax
    96b1:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    96b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    96bf:	eb 64                	jmp    9725 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    96c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    96c4:	8b 40 58             	mov    0x58(%eax),%eax
    96c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96ca:	c1 e2 02             	shl    $0x2,%edx
    96cd:	01 d0                	add    %edx,%eax
    96cf:	8b 18                	mov    (%eax),%ebx
    96d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    96d4:	8b 40 54             	mov    0x54(%eax),%eax
    96d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96da:	c1 e2 02             	shl    $0x2,%edx
    96dd:	01 d0                	add    %edx,%eax
    96df:	8b 08                	mov    (%eax),%ecx
    96e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    96e4:	8b 40 50             	mov    0x50(%eax),%eax
    96e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96ea:	c1 e2 02             	shl    $0x2,%edx
    96ed:	01 d0                	add    %edx,%eax
    96ef:	8b 10                	mov    (%eax),%edx
    96f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    96f4:	8b 40 4c             	mov    0x4c(%eax),%eax
    96f7:	8b 75 f4             	mov    -0xc(%ebp),%esi
    96fa:	c1 e6 02             	shl    $0x2,%esi
    96fd:	01 f0                	add    %esi,%eax
    96ff:	8b 00                	mov    (%eax),%eax
    9701:	83 ec 0c             	sub    $0xc,%esp
    9704:	53                   	push   %ebx
    9705:	51                   	push   %ecx
    9706:	52                   	push   %edx
    9707:	50                   	push   %eax
    9708:	ff 75 08             	pushl  0x8(%ebp)
    970b:	e8 e4 01 00 00       	call   98f4 <lodepng_add_itext>
    9710:	83 c4 20             	add    $0x20,%esp
    9713:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9716:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    971a:	74 05                	je     9721 <LodePNGIText_copy+0xaa>
    971c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    971f:	eb 14                	jmp    9735 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9721:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9725:	8b 45 0c             	mov    0xc(%ebp),%eax
    9728:	8b 40 48             	mov    0x48(%eax),%eax
    972b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    972e:	75 91                	jne    96c1 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9730:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9735:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9738:	5b                   	pop    %ebx
    9739:	5e                   	pop    %esi
    973a:	5d                   	pop    %ebp
    973b:	c3                   	ret    

0000973c <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    973c:	55                   	push   %ebp
    973d:	89 e5                	mov    %esp,%ebp
    973f:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9742:	83 ec 0c             	sub    $0xc,%esp
    9745:	ff 75 08             	pushl  0x8(%ebp)
    9748:	e8 59 fe ff ff       	call   95a6 <LodePNGIText_cleanup>
    974d:	83 c4 10             	add    $0x10,%esp
}
    9750:	90                   	nop
    9751:	c9                   	leave  
    9752:	c3                   	ret    

00009753 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    9753:	55                   	push   %ebp
    9754:	89 e5                	mov    %esp,%ebp
    9756:	53                   	push   %ebx
    9757:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    975a:	8b 45 08             	mov    0x8(%ebp),%eax
    975d:	8b 40 48             	mov    0x48(%eax),%eax
    9760:	83 c0 01             	add    $0x1,%eax
    9763:	c1 e0 02             	shl    $0x2,%eax
    9766:	89 c2                	mov    %eax,%edx
    9768:	8b 45 08             	mov    0x8(%ebp),%eax
    976b:	8b 40 4c             	mov    0x4c(%eax),%eax
    976e:	52                   	push   %edx
    976f:	50                   	push   %eax
    9770:	e8 54 9c ff ff       	call   33c9 <lodepng_realloc>
    9775:	83 c4 08             	add    $0x8,%esp
    9778:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    977b:	8b 45 08             	mov    0x8(%ebp),%eax
    977e:	8b 40 48             	mov    0x48(%eax),%eax
    9781:	83 c0 01             	add    $0x1,%eax
    9784:	c1 e0 02             	shl    $0x2,%eax
    9787:	89 c2                	mov    %eax,%edx
    9789:	8b 45 08             	mov    0x8(%ebp),%eax
    978c:	8b 40 50             	mov    0x50(%eax),%eax
    978f:	52                   	push   %edx
    9790:	50                   	push   %eax
    9791:	e8 33 9c ff ff       	call   33c9 <lodepng_realloc>
    9796:	83 c4 08             	add    $0x8,%esp
    9799:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    979c:	8b 45 08             	mov    0x8(%ebp),%eax
    979f:	8b 40 48             	mov    0x48(%eax),%eax
    97a2:	83 c0 01             	add    $0x1,%eax
    97a5:	c1 e0 02             	shl    $0x2,%eax
    97a8:	89 c2                	mov    %eax,%edx
    97aa:	8b 45 08             	mov    0x8(%ebp),%eax
    97ad:	8b 40 54             	mov    0x54(%eax),%eax
    97b0:	52                   	push   %edx
    97b1:	50                   	push   %eax
    97b2:	e8 12 9c ff ff       	call   33c9 <lodepng_realloc>
    97b7:	83 c4 08             	add    $0x8,%esp
    97ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    97bd:	8b 45 08             	mov    0x8(%ebp),%eax
    97c0:	8b 40 48             	mov    0x48(%eax),%eax
    97c3:	83 c0 01             	add    $0x1,%eax
    97c6:	c1 e0 02             	shl    $0x2,%eax
    97c9:	89 c2                	mov    %eax,%edx
    97cb:	8b 45 08             	mov    0x8(%ebp),%eax
    97ce:	8b 40 58             	mov    0x58(%eax),%eax
    97d1:	52                   	push   %edx
    97d2:	50                   	push   %eax
    97d3:	e8 f1 9b ff ff       	call   33c9 <lodepng_realloc>
    97d8:	83 c4 08             	add    $0x8,%esp
    97db:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    97de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    97e2:	74 09                	je     97ed <lodepng_add_itext_sized+0x9a>
    97e4:	8b 45 08             	mov    0x8(%ebp),%eax
    97e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    97ea:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    97ed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    97f1:	74 09                	je     97fc <lodepng_add_itext_sized+0xa9>
    97f3:	8b 45 08             	mov    0x8(%ebp),%eax
    97f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    97f9:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    97fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9800:	74 09                	je     980b <lodepng_add_itext_sized+0xb8>
    9802:	8b 45 08             	mov    0x8(%ebp),%eax
    9805:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9808:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    980b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    980f:	74 09                	je     981a <lodepng_add_itext_sized+0xc7>
    9811:	8b 45 08             	mov    0x8(%ebp),%eax
    9814:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9817:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    981a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    981e:	74 12                	je     9832 <lodepng_add_itext_sized+0xdf>
    9820:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9824:	74 0c                	je     9832 <lodepng_add_itext_sized+0xdf>
    9826:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    982a:	74 06                	je     9832 <lodepng_add_itext_sized+0xdf>
    982c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9830:	75 0a                	jne    983c <lodepng_add_itext_sized+0xe9>
    9832:	b8 53 00 00 00       	mov    $0x53,%eax
    9837:	e9 b3 00 00 00       	jmp    98ef <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    983c:	8b 45 08             	mov    0x8(%ebp),%eax
    983f:	8b 40 48             	mov    0x48(%eax),%eax
    9842:	8d 50 01             	lea    0x1(%eax),%edx
    9845:	8b 45 08             	mov    0x8(%ebp),%eax
    9848:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    984b:	8b 45 08             	mov    0x8(%ebp),%eax
    984e:	8b 50 4c             	mov    0x4c(%eax),%edx
    9851:	8b 45 08             	mov    0x8(%ebp),%eax
    9854:	8b 40 48             	mov    0x48(%eax),%eax
    9857:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    985c:	c1 e0 02             	shl    $0x2,%eax
    985f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9862:	83 ec 0c             	sub    $0xc,%esp
    9865:	ff 75 0c             	pushl  0xc(%ebp)
    9868:	e8 a1 9e ff ff       	call   370e <alloc_string>
    986d:	83 c4 10             	add    $0x10,%esp
    9870:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9872:	8b 45 08             	mov    0x8(%ebp),%eax
    9875:	8b 50 50             	mov    0x50(%eax),%edx
    9878:	8b 45 08             	mov    0x8(%ebp),%eax
    987b:	8b 40 48             	mov    0x48(%eax),%eax
    987e:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9883:	c1 e0 02             	shl    $0x2,%eax
    9886:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9889:	83 ec 0c             	sub    $0xc,%esp
    988c:	ff 75 10             	pushl  0x10(%ebp)
    988f:	e8 7a 9e ff ff       	call   370e <alloc_string>
    9894:	83 c4 10             	add    $0x10,%esp
    9897:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9899:	8b 45 08             	mov    0x8(%ebp),%eax
    989c:	8b 50 54             	mov    0x54(%eax),%edx
    989f:	8b 45 08             	mov    0x8(%ebp),%eax
    98a2:	8b 40 48             	mov    0x48(%eax),%eax
    98a5:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    98aa:	c1 e0 02             	shl    $0x2,%eax
    98ad:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    98b0:	83 ec 0c             	sub    $0xc,%esp
    98b3:	ff 75 14             	pushl  0x14(%ebp)
    98b6:	e8 53 9e ff ff       	call   370e <alloc_string>
    98bb:	83 c4 10             	add    $0x10,%esp
    98be:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    98c0:	8b 45 08             	mov    0x8(%ebp),%eax
    98c3:	8b 50 58             	mov    0x58(%eax),%edx
    98c6:	8b 45 08             	mov    0x8(%ebp),%eax
    98c9:	8b 40 48             	mov    0x48(%eax),%eax
    98cc:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    98d1:	c1 e0 02             	shl    $0x2,%eax
    98d4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    98d7:	83 ec 08             	sub    $0x8,%esp
    98da:	ff 75 1c             	pushl  0x1c(%ebp)
    98dd:	ff 75 18             	pushl  0x18(%ebp)
    98e0:	e8 e4 9d ff ff       	call   36c9 <alloc_string_sized>
    98e5:	83 c4 10             	add    $0x10,%esp
    98e8:	89 03                	mov    %eax,(%ebx)

  return 0;
    98ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
    98ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    98f2:	c9                   	leave  
    98f3:	c3                   	ret    

000098f4 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    98f4:	55                   	push   %ebp
    98f5:	89 e5                	mov    %esp,%ebp
    98f7:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    98fa:	ff 75 18             	pushl  0x18(%ebp)
    98fd:	e8 4c 9b ff ff       	call   344e <lodepng_strlen>
    9902:	83 c4 04             	add    $0x4,%esp
    9905:	83 ec 08             	sub    $0x8,%esp
    9908:	50                   	push   %eax
    9909:	ff 75 18             	pushl  0x18(%ebp)
    990c:	ff 75 14             	pushl  0x14(%ebp)
    990f:	ff 75 10             	pushl  0x10(%ebp)
    9912:	ff 75 0c             	pushl  0xc(%ebp)
    9915:	ff 75 08             	pushl  0x8(%ebp)
    9918:	e8 36 fe ff ff       	call   9753 <lodepng_add_itext_sized>
    991d:	83 c4 20             	add    $0x20,%esp
}
    9920:	c9                   	leave  
    9921:	c3                   	ret    

00009922 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9922:	55                   	push   %ebp
    9923:	89 e5                	mov    %esp,%ebp
    9925:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9928:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    992c:	75 0a                	jne    9938 <lodepng_assign_icc+0x16>
    992e:	b8 64 00 00 00       	mov    $0x64,%eax
    9933:	e9 81 00 00 00       	jmp    99b9 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9938:	83 ec 0c             	sub    $0xc,%esp
    993b:	ff 75 0c             	pushl  0xc(%ebp)
    993e:	e8 cb 9d ff ff       	call   370e <alloc_string>
    9943:	83 c4 10             	add    $0x10,%esp
    9946:	89 c2                	mov    %eax,%edx
    9948:	8b 45 08             	mov    0x8(%ebp),%eax
    994b:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    9951:	8b 45 14             	mov    0x14(%ebp),%eax
    9954:	83 ec 0c             	sub    $0xc,%esp
    9957:	50                   	push   %eax
    9958:	e8 55 9a ff ff       	call   33b2 <lodepng_malloc>
    995d:	83 c4 10             	add    $0x10,%esp
    9960:	89 c2                	mov    %eax,%edx
    9962:	8b 45 08             	mov    0x8(%ebp),%eax
    9965:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    996b:	8b 45 08             	mov    0x8(%ebp),%eax
    996e:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9974:	85 c0                	test   %eax,%eax
    9976:	74 0d                	je     9985 <lodepng_assign_icc+0x63>
    9978:	8b 45 08             	mov    0x8(%ebp),%eax
    997b:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9981:	85 c0                	test   %eax,%eax
    9983:	75 07                	jne    998c <lodepng_assign_icc+0x6a>
    9985:	b8 53 00 00 00       	mov    $0x53,%eax
    998a:	eb 2d                	jmp    99b9 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    998c:	8b 55 14             	mov    0x14(%ebp),%edx
    998f:	8b 45 08             	mov    0x8(%ebp),%eax
    9992:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9998:	83 ec 04             	sub    $0x4,%esp
    999b:	52                   	push   %edx
    999c:	ff 75 10             	pushl  0x10(%ebp)
    999f:	50                   	push   %eax
    99a0:	e8 4b 9a ff ff       	call   33f0 <lodepng_memcpy>
    99a5:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    99a8:	8b 45 08             	mov    0x8(%ebp),%eax
    99ab:	8b 55 14             	mov    0x14(%ebp),%edx
    99ae:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    99b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    99b9:	c9                   	leave  
    99ba:	c3                   	ret    

000099bb <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    99bb:	55                   	push   %ebp
    99bc:	89 e5                	mov    %esp,%ebp
    99be:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    99c1:	8b 45 08             	mov    0x8(%ebp),%eax
    99c4:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    99ca:	85 c0                	test   %eax,%eax
    99cc:	74 0e                	je     99dc <lodepng_set_icc+0x21>
    99ce:	83 ec 0c             	sub    $0xc,%esp
    99d1:	ff 75 08             	pushl  0x8(%ebp)
    99d4:	e8 26 00 00 00       	call   99ff <lodepng_clear_icc>
    99d9:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    99dc:	8b 45 08             	mov    0x8(%ebp),%eax
    99df:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    99e6:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    99e9:	ff 75 14             	pushl  0x14(%ebp)
    99ec:	ff 75 10             	pushl  0x10(%ebp)
    99ef:	ff 75 0c             	pushl  0xc(%ebp)
    99f2:	ff 75 08             	pushl  0x8(%ebp)
    99f5:	e8 28 ff ff ff       	call   9922 <lodepng_assign_icc>
    99fa:	83 c4 10             	add    $0x10,%esp
}
    99fd:	c9                   	leave  
    99fe:	c3                   	ret    

000099ff <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    99ff:	55                   	push   %ebp
    9a00:	89 e5                	mov    %esp,%ebp
    9a02:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9a05:	8b 45 08             	mov    0x8(%ebp),%eax
    9a08:	05 c0 00 00 00       	add    $0xc0,%eax
    9a0d:	83 ec 0c             	sub    $0xc,%esp
    9a10:	50                   	push   %eax
    9a11:	e8 90 9c ff ff       	call   36a6 <string_cleanup>
    9a16:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9a19:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1c:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9a22:	83 ec 0c             	sub    $0xc,%esp
    9a25:	50                   	push   %eax
    9a26:	e8 a8 99 ff ff       	call   33d3 <lodepng_free>
    9a2b:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9a2e:	8b 45 08             	mov    0x8(%ebp),%eax
    9a31:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9a38:	00 00 00 
  info->iccp_profile_size = 0;
    9a3b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3e:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9a45:	00 00 00 
  info->iccp_defined = 0;
    9a48:	8b 45 08             	mov    0x8(%ebp),%eax
    9a4b:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9a52:	00 00 00 
}
    9a55:	90                   	nop
    9a56:	c9                   	leave  
    9a57:	c3                   	ret    

00009a58 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9a58:	55                   	push   %ebp
    9a59:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a5e:	83 c0 0c             	add    $0xc,%eax
    9a61:	50                   	push   %eax
    9a62:	e8 5a f0 ff ff       	call   8ac1 <lodepng_color_mode_init>
    9a67:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9a6a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9a74:	8b 45 08             	mov    0x8(%ebp),%eax
    9a77:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9a7d:	8b 45 08             	mov    0x8(%ebp),%eax
    9a80:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9a87:	8b 45 08             	mov    0x8(%ebp),%eax
    9a8a:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9a91:	8b 45 08             	mov    0x8(%ebp),%eax
    9a94:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9a9b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a9e:	8b 50 38             	mov    0x38(%eax),%edx
    9aa1:	8b 45 08             	mov    0x8(%ebp),%eax
    9aa4:	89 50 34             	mov    %edx,0x34(%eax)
    9aa7:	8b 45 08             	mov    0x8(%ebp),%eax
    9aaa:	8b 50 34             	mov    0x34(%eax),%edx
    9aad:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab0:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9ab3:	ff 75 08             	pushl  0x8(%ebp)
    9ab6:	e8 2c f8 ff ff       	call   92e7 <LodePNGText_init>
    9abb:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9abe:	ff 75 08             	pushl  0x8(%ebp)
    9ac1:	e8 a8 fa ff ff       	call   956e <LodePNGIText_init>
    9ac6:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9ac9:	8b 45 08             	mov    0x8(%ebp),%eax
    9acc:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9ad3:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad6:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9add:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae0:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9ae7:	00 00 00 
  info->chrm_defined = 0;
    9aea:	8b 45 08             	mov    0x8(%ebp),%eax
    9aed:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9af4:	00 00 00 
  info->srgb_defined = 0;
    9af7:	8b 45 08             	mov    0x8(%ebp),%eax
    9afa:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9b01:	00 00 00 
  info->iccp_defined = 0;
    9b04:	8b 45 08             	mov    0x8(%ebp),%eax
    9b07:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9b0e:	00 00 00 
  info->iccp_name = NULL;
    9b11:	8b 45 08             	mov    0x8(%ebp),%eax
    9b14:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9b1b:	00 00 00 
  info->iccp_profile = NULL;
    9b1e:	8b 45 08             	mov    0x8(%ebp),%eax
    9b21:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9b28:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9b2b:	ff 75 08             	pushl  0x8(%ebp)
    9b2e:	e8 46 f6 ff ff       	call   9179 <LodePNGUnknownChunks_init>
    9b33:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9b36:	90                   	nop
    9b37:	c9                   	leave  
    9b38:	c3                   	ret    

00009b39 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9b39:	55                   	push   %ebp
    9b3a:	89 e5                	mov    %esp,%ebp
    9b3c:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9b3f:	8b 45 08             	mov    0x8(%ebp),%eax
    9b42:	83 c0 0c             	add    $0xc,%eax
    9b45:	83 ec 0c             	sub    $0xc,%esp
    9b48:	50                   	push   %eax
    9b49:	e8 66 f0 ff ff       	call   8bb4 <lodepng_color_mode_cleanup>
    9b4e:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9b51:	83 ec 0c             	sub    $0xc,%esp
    9b54:	ff 75 08             	pushl  0x8(%ebp)
    9b57:	e8 af f7 ff ff       	call   930b <LodePNGText_cleanup>
    9b5c:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9b5f:	83 ec 0c             	sub    $0xc,%esp
    9b62:	ff 75 08             	pushl  0x8(%ebp)
    9b65:	e8 3c fa ff ff       	call   95a6 <LodePNGIText_cleanup>
    9b6a:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9b6d:	83 ec 0c             	sub    $0xc,%esp
    9b70:	ff 75 08             	pushl  0x8(%ebp)
    9b73:	e8 87 fe ff ff       	call   99ff <lodepng_clear_icc>
    9b78:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9b7b:	83 ec 0c             	sub    $0xc,%esp
    9b7e:	ff 75 08             	pushl  0x8(%ebp)
    9b81:	e8 44 f6 ff ff       	call   91ca <LodePNGUnknownChunks_cleanup>
    9b86:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9b89:	90                   	nop
    9b8a:	c9                   	leave  
    9b8b:	c3                   	ret    

00009b8c <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9b8c:	55                   	push   %ebp
    9b8d:	89 e5                	mov    %esp,%ebp
    9b8f:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9b92:	83 ec 0c             	sub    $0xc,%esp
    9b95:	ff 75 08             	pushl  0x8(%ebp)
    9b98:	e8 9c ff ff ff       	call   9b39 <lodepng_info_cleanup>
    9b9d:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9ba0:	83 ec 04             	sub    $0x4,%esp
    9ba3:	68 e4 00 00 00       	push   $0xe4
    9ba8:	ff 75 0c             	pushl  0xc(%ebp)
    9bab:	ff 75 08             	pushl  0x8(%ebp)
    9bae:	e8 3d 98 ff ff       	call   33f0 <lodepng_memcpy>
    9bb3:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9bb6:	8b 45 08             	mov    0x8(%ebp),%eax
    9bb9:	83 c0 0c             	add    $0xc,%eax
    9bbc:	83 ec 0c             	sub    $0xc,%esp
    9bbf:	50                   	push   %eax
    9bc0:	e8 fc ee ff ff       	call   8ac1 <lodepng_color_mode_init>
    9bc5:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bcb:	8d 50 0c             	lea    0xc(%eax),%edx
    9bce:	8b 45 08             	mov    0x8(%ebp),%eax
    9bd1:	83 c0 0c             	add    $0xc,%eax
    9bd4:	83 ec 08             	sub    $0x8,%esp
    9bd7:	52                   	push   %edx
    9bd8:	50                   	push   %eax
    9bd9:	e8 ed ef ff ff       	call   8bcb <lodepng_color_mode_copy>
    9bde:	83 c4 10             	add    $0x10,%esp
    9be1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9be4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9be8:	74 08                	je     9bf2 <lodepng_info_copy+0x66>
    9bea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9bed:	e9 b7 00 00 00       	jmp    9ca9 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9bf2:	83 ec 08             	sub    $0x8,%esp
    9bf5:	ff 75 0c             	pushl  0xc(%ebp)
    9bf8:	ff 75 08             	pushl  0x8(%ebp)
    9bfb:	e8 84 f7 ff ff       	call   9384 <LodePNGText_copy>
    9c00:	83 c4 10             	add    $0x10,%esp
    9c03:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9c06:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9c0a:	74 08                	je     9c14 <lodepng_info_copy+0x88>
    9c0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9c0f:	e9 95 00 00 00       	jmp    9ca9 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9c14:	83 ec 08             	sub    $0x8,%esp
    9c17:	ff 75 0c             	pushl  0xc(%ebp)
    9c1a:	ff 75 08             	pushl  0x8(%ebp)
    9c1d:	e8 55 fa ff ff       	call   9677 <LodePNGIText_copy>
    9c22:	83 c4 10             	add    $0x10,%esp
    9c25:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9c28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9c2c:	74 05                	je     9c33 <lodepng_info_copy+0xa7>
    9c2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9c31:	eb 76                	jmp    9ca9 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9c33:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c36:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9c3c:	85 c0                	test   %eax,%eax
    9c3e:	74 37                	je     9c77 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9c40:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c43:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9c49:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c4c:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9c52:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c55:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9c5b:	51                   	push   %ecx
    9c5c:	52                   	push   %edx
    9c5d:	50                   	push   %eax
    9c5e:	ff 75 08             	pushl  0x8(%ebp)
    9c61:	e8 bc fc ff ff       	call   9922 <lodepng_assign_icc>
    9c66:	83 c4 10             	add    $0x10,%esp
    9c69:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9c6c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9c70:	74 05                	je     9c77 <lodepng_info_copy+0xeb>
    9c72:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9c75:	eb 32                	jmp    9ca9 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9c77:	83 ec 0c             	sub    $0xc,%esp
    9c7a:	ff 75 08             	pushl  0x8(%ebp)
    9c7d:	e8 f7 f4 ff ff       	call   9179 <LodePNGUnknownChunks_init>
    9c82:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9c85:	83 ec 08             	sub    $0x8,%esp
    9c88:	ff 75 0c             	pushl  0xc(%ebp)
    9c8b:	ff 75 08             	pushl  0x8(%ebp)
    9c8e:	e8 6c f5 ff ff       	call   91ff <LodePNGUnknownChunks_copy>
    9c93:	83 c4 10             	add    $0x10,%esp
    9c96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9c99:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9c9d:	74 05                	je     9ca4 <lodepng_info_copy+0x118>
    9c9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9ca2:	eb 05                	jmp    9ca9 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9ca4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9ca9:	c9                   	leave  
    9caa:	c3                   	ret    

00009cab <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9cab:	55                   	push   %ebp
    9cac:	89 e5                	mov    %esp,%ebp
    9cae:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9cb1:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9cb5:	74 14                	je     9ccb <addColorBits+0x20>
    9cb7:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9cbb:	75 07                	jne    9cc4 <addColorBits+0x19>
    9cbd:	b8 03 00 00 00       	mov    $0x3,%eax
    9cc2:	eb 0c                	jmp    9cd0 <addColorBits+0x25>
    9cc4:	b8 01 00 00 00       	mov    $0x1,%eax
    9cc9:	eb 05                	jmp    9cd0 <addColorBits+0x25>
    9ccb:	b8 07 00 00 00       	mov    $0x7,%eax
    9cd0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cd6:	23 45 fc             	and    -0x4(%ebp),%eax
    9cd9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9cdc:	8b 45 10             	mov    0x10(%ebp),%eax
    9cdf:	ba 01 00 00 00       	mov    $0x1,%edx
    9ce4:	89 c1                	mov    %eax,%ecx
    9ce6:	d3 e2                	shl    %cl,%edx
    9ce8:	89 d0                	mov    %edx,%eax
    9cea:	83 e8 01             	sub    $0x1,%eax
    9ced:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9cf0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9cf3:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9cf6:	0f af 45 10          	imul   0x10(%ebp),%eax
    9cfa:	89 c1                	mov    %eax,%ecx
    9cfc:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9cff:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9d03:	75 18                	jne    9d1d <addColorBits+0x72>
    9d05:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d08:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d0c:	c1 e8 03             	shr    $0x3,%eax
    9d0f:	89 c2                	mov    %eax,%edx
    9d11:	8b 45 08             	mov    0x8(%ebp),%eax
    9d14:	01 d0                	add    %edx,%eax
    9d16:	8b 55 14             	mov    0x14(%ebp),%edx
    9d19:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9d1b:	eb 1e                	jmp    9d3b <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9d1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d20:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d24:	c1 e8 03             	shr    $0x3,%eax
    9d27:	8b 55 08             	mov    0x8(%ebp),%edx
    9d2a:	01 c2                	add    %eax,%edx
    9d2c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9d2f:	01 c8                	add    %ecx,%eax
    9d31:	0f b6 08             	movzbl (%eax),%ecx
    9d34:	8b 45 14             	mov    0x14(%ebp),%eax
    9d37:	09 c8                	or     %ecx,%eax
    9d39:	88 02                	mov    %al,(%edx)
}
    9d3b:	90                   	nop
    9d3c:	c9                   	leave  
    9d3d:	c3                   	ret    

00009d3e <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9d3e:	55                   	push   %ebp
    9d3f:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9d41:	8b 45 08             	mov    0x8(%ebp),%eax
    9d44:	6a 40                	push   $0x40
    9d46:	6a 00                	push   $0x0
    9d48:	50                   	push   %eax
    9d49:	e8 d5 96 ff ff       	call   3423 <lodepng_memset>
    9d4e:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9d51:	8b 45 08             	mov    0x8(%ebp),%eax
    9d54:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9d5b:	90                   	nop
    9d5c:	c9                   	leave  
    9d5d:	c3                   	ret    

00009d5e <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9d5e:	55                   	push   %ebp
    9d5f:	89 e5                	mov    %esp,%ebp
    9d61:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9d64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9d6b:	eb 3b                	jmp    9da8 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9d6d:	8b 45 08             	mov    0x8(%ebp),%eax
    9d70:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d73:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d76:	85 c0                	test   %eax,%eax
    9d78:	74 2a                	je     9da4 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9d7a:	8b 45 08             	mov    0x8(%ebp),%eax
    9d7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d80:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d83:	83 ec 0c             	sub    $0xc,%esp
    9d86:	50                   	push   %eax
    9d87:	e8 d2 ff ff ff       	call   9d5e <color_tree_cleanup>
    9d8c:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9d8f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d92:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d95:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d98:	83 ec 0c             	sub    $0xc,%esp
    9d9b:	50                   	push   %eax
    9d9c:	e8 32 96 ff ff       	call   33d3 <lodepng_free>
    9da1:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9da4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9da8:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9dac:	75 bf                	jne    9d6d <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9dae:	90                   	nop
    9daf:	c9                   	leave  
    9db0:	c3                   	ret    

00009db1 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9db1:	55                   	push   %ebp
    9db2:	89 e5                	mov    %esp,%ebp
    9db4:	53                   	push   %ebx
    9db5:	83 ec 20             	sub    $0x20,%esp
    9db8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9dbb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9dbe:	8b 55 14             	mov    0x14(%ebp),%edx
    9dc1:	8b 45 18             	mov    0x18(%ebp),%eax
    9dc4:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9dc7:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9dca:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9dcd:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9dd0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9dd7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9dde:	eb 76                	jmp    9e56 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9de0:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9de4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9de7:	89 c1                	mov    %eax,%ecx
    9de9:	d3 fa                	sar    %cl,%edx
    9deb:	89 d0                	mov    %edx,%eax
    9ded:	83 e0 01             	and    $0x1,%eax
    9df0:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9df3:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9df7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9dfa:	89 c1                	mov    %eax,%ecx
    9dfc:	d3 fa                	sar    %cl,%edx
    9dfe:	89 d0                	mov    %edx,%eax
    9e00:	83 e0 01             	and    $0x1,%eax
    9e03:	01 d8                	add    %ebx,%eax
    9e05:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e08:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e0f:	89 c1                	mov    %eax,%ecx
    9e11:	d3 fa                	sar    %cl,%edx
    9e13:	89 d0                	mov    %edx,%eax
    9e15:	83 e0 01             	and    $0x1,%eax
    9e18:	01 d8                	add    %ebx,%eax
    9e1a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e1d:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9e21:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e24:	89 c1                	mov    %eax,%ecx
    9e26:	d3 fa                	sar    %cl,%edx
    9e28:	89 d0                	mov    %edx,%eax
    9e2a:	83 e0 01             	and    $0x1,%eax
    9e2d:	01 d8                	add    %ebx,%eax
    9e2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9e32:	8b 45 08             	mov    0x8(%ebp),%eax
    9e35:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e38:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e3b:	85 c0                	test   %eax,%eax
    9e3d:	75 07                	jne    9e46 <color_tree_get+0x95>
    9e3f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9e44:	eb 2a                	jmp    9e70 <color_tree_get+0xbf>
    else tree = tree->children[i];
    9e46:	8b 45 08             	mov    0x8(%ebp),%eax
    9e49:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e4c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e4f:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9e52:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9e56:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9e5a:	7e 84                	jle    9de0 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9e5c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9e60:	74 08                	je     9e6a <color_tree_get+0xb9>
    9e62:	8b 45 08             	mov    0x8(%ebp),%eax
    9e65:	8b 40 40             	mov    0x40(%eax),%eax
    9e68:	eb 05                	jmp    9e6f <color_tree_get+0xbe>
    9e6a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9e6f:	90                   	nop
}
    9e70:	83 c4 20             	add    $0x20,%esp
    9e73:	5b                   	pop    %ebx
    9e74:	5d                   	pop    %ebp
    9e75:	c3                   	ret    

00009e76 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9e76:	55                   	push   %ebp
    9e77:	89 e5                	mov    %esp,%ebp
    9e79:	53                   	push   %ebx
    9e7a:	83 ec 10             	sub    $0x10,%esp
    9e7d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e80:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e83:	8b 55 14             	mov    0x14(%ebp),%edx
    9e86:	8b 45 18             	mov    0x18(%ebp),%eax
    9e89:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9e8c:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9e8f:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9e92:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9e95:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9e99:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9e9d:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9ea1:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9ea5:	53                   	push   %ebx
    9ea6:	51                   	push   %ecx
    9ea7:	52                   	push   %edx
    9ea8:	50                   	push   %eax
    9ea9:	ff 75 08             	pushl  0x8(%ebp)
    9eac:	e8 00 ff ff ff       	call   9db1 <color_tree_get>
    9eb1:	83 c4 14             	add    $0x14,%esp
    9eb4:	f7 d0                	not    %eax
    9eb6:	c1 e8 1f             	shr    $0x1f,%eax
    9eb9:	0f b6 c0             	movzbl %al,%eax
}
    9ebc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9ebf:	c9                   	leave  
    9ec0:	c3                   	ret    

00009ec1 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9ec1:	55                   	push   %ebp
    9ec2:	89 e5                	mov    %esp,%ebp
    9ec4:	53                   	push   %ebx
    9ec5:	83 ec 24             	sub    $0x24,%esp
    9ec8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9ecb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9ece:	8b 55 14             	mov    0x14(%ebp),%edx
    9ed1:	8b 45 18             	mov    0x18(%ebp),%eax
    9ed4:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9ed7:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9eda:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9edd:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9ee0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9ee7:	e9 b0 00 00 00       	jmp    9f9c <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9eec:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9ef0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9ef3:	89 c1                	mov    %eax,%ecx
    9ef5:	d3 fa                	sar    %cl,%edx
    9ef7:	89 d0                	mov    %edx,%eax
    9ef9:	83 e0 01             	and    $0x1,%eax
    9efc:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9eff:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f06:	89 c1                	mov    %eax,%ecx
    9f08:	d3 fa                	sar    %cl,%edx
    9f0a:	89 d0                	mov    %edx,%eax
    9f0c:	83 e0 01             	and    $0x1,%eax
    9f0f:	01 d8                	add    %ebx,%eax
    9f11:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f14:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9f18:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f1b:	89 c1                	mov    %eax,%ecx
    9f1d:	d3 fa                	sar    %cl,%edx
    9f1f:	89 d0                	mov    %edx,%eax
    9f21:	83 e0 01             	and    $0x1,%eax
    9f24:	01 d8                	add    %ebx,%eax
    9f26:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f29:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9f2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f30:	89 c1                	mov    %eax,%ecx
    9f32:	d3 fa                	sar    %cl,%edx
    9f34:	89 d0                	mov    %edx,%eax
    9f36:	83 e0 01             	and    $0x1,%eax
    9f39:	01 d8                	add    %ebx,%eax
    9f3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9f3e:	8b 45 08             	mov    0x8(%ebp),%eax
    9f41:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f44:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f47:	85 c0                	test   %eax,%eax
    9f49:	75 41                	jne    9f8c <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9f4b:	83 ec 0c             	sub    $0xc,%esp
    9f4e:	6a 44                	push   $0x44
    9f50:	e8 5d 94 ff ff       	call   33b2 <lodepng_malloc>
    9f55:	83 c4 10             	add    $0x10,%esp
    9f58:	89 c1                	mov    %eax,%ecx
    9f5a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f5d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f60:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9f63:	8b 45 08             	mov    0x8(%ebp),%eax
    9f66:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f69:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f6c:	85 c0                	test   %eax,%eax
    9f6e:	75 07                	jne    9f77 <color_tree_add+0xb6>
    9f70:	b8 53 00 00 00       	mov    $0x53,%eax
    9f75:	eb 3d                	jmp    9fb4 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9f77:	8b 45 08             	mov    0x8(%ebp),%eax
    9f7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f7d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f80:	83 ec 0c             	sub    $0xc,%esp
    9f83:	50                   	push   %eax
    9f84:	e8 b5 fd ff ff       	call   9d3e <color_tree_init>
    9f89:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9f8c:	8b 45 08             	mov    0x8(%ebp),%eax
    9f8f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f92:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f95:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9f98:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f9c:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9fa0:	0f 8e 46 ff ff ff    	jle    9eec <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9fa6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9fa9:	8b 45 08             	mov    0x8(%ebp),%eax
    9fac:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    9faf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9fb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9fb7:	c9                   	leave  
    9fb8:	c3                   	ret    

00009fb9 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9fb9:	55                   	push   %ebp
    9fba:	89 e5                	mov    %esp,%ebp
    9fbc:	53                   	push   %ebx
    9fbd:	83 ec 20             	sub    $0x20,%esp
    9fc0:	8b 5d 18             	mov    0x18(%ebp),%ebx
    9fc3:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    9fc6:	8b 55 20             	mov    0x20(%ebp),%edx
    9fc9:	8b 45 24             	mov    0x24(%ebp),%eax
    9fcc:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9fcf:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9fd2:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9fd5:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    9fd8:	8b 45 10             	mov    0x10(%ebp),%eax
    9fdb:	8b 00                	mov    (%eax),%eax
    9fdd:	85 c0                	test   %eax,%eax
    9fdf:	0f 85 ad 00 00 00    	jne    a092 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    9fe5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9fe9:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    9fec:	8b 45 10             	mov    0x10(%ebp),%eax
    9fef:	8b 40 04             	mov    0x4(%eax),%eax
    9ff2:	83 f8 08             	cmp    $0x8,%eax
    9ff5:	75 13                	jne    a00a <rgba8ToPixel+0x51>
    9ff7:	8b 55 0c             	mov    0xc(%ebp),%edx
    9ffa:	8b 45 08             	mov    0x8(%ebp),%eax
    9ffd:	01 c2                	add    %eax,%edx
    9fff:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a003:	88 02                	mov    %al,(%edx)
    a005:	e9 b4 03 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a00a:	8b 45 10             	mov    0x10(%ebp),%eax
    a00d:	8b 40 04             	mov    0x4(%eax),%eax
    a010:	83 f8 10             	cmp    $0x10,%eax
    a013:	75 2a                	jne    a03f <rgba8ToPixel+0x86>
    a015:	8b 45 0c             	mov    0xc(%ebp),%eax
    a018:	01 c0                	add    %eax,%eax
    a01a:	89 c2                	mov    %eax,%edx
    a01c:	8b 45 08             	mov    0x8(%ebp),%eax
    a01f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a022:	8b 45 0c             	mov    0xc(%ebp),%eax
    a025:	01 c0                	add    %eax,%eax
    a027:	8d 50 01             	lea    0x1(%eax),%edx
    a02a:	8b 45 08             	mov    0x8(%ebp),%eax
    a02d:	01 d0                	add    %edx,%eax
    a02f:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a033:	88 10                	mov    %dl,(%eax)
    a035:	0f b6 00             	movzbl (%eax),%eax
    a038:	88 01                	mov    %al,(%ecx)
    a03a:	e9 7f 03 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a03f:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a043:	8b 45 10             	mov    0x10(%ebp),%eax
    a046:	8b 40 04             	mov    0x4(%eax),%eax
    a049:	b9 08 00 00 00       	mov    $0x8,%ecx
    a04e:	29 c1                	sub    %eax,%ecx
    a050:	89 c8                	mov    %ecx,%eax
    a052:	89 c1                	mov    %eax,%ecx
    a054:	d3 ea                	shr    %cl,%edx
    a056:	89 d0                	mov    %edx,%eax
    a058:	89 c2                	mov    %eax,%edx
    a05a:	8b 45 10             	mov    0x10(%ebp),%eax
    a05d:	8b 40 04             	mov    0x4(%eax),%eax
    a060:	bb 01 00 00 00       	mov    $0x1,%ebx
    a065:	89 c1                	mov    %eax,%ecx
    a067:	d3 e3                	shl    %cl,%ebx
    a069:	89 d8                	mov    %ebx,%eax
    a06b:	83 e8 01             	sub    $0x1,%eax
    a06e:	21 d0                	and    %edx,%eax
    a070:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a073:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a077:	8b 45 10             	mov    0x10(%ebp),%eax
    a07a:	8b 40 04             	mov    0x4(%eax),%eax
    a07d:	52                   	push   %edx
    a07e:	50                   	push   %eax
    a07f:	ff 75 0c             	pushl  0xc(%ebp)
    a082:	ff 75 08             	pushl  0x8(%ebp)
    a085:	e8 21 fc ff ff       	call   9cab <addColorBits>
    a08a:	83 c4 10             	add    $0x10,%esp
    a08d:	e9 2c 03 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a092:	8b 45 10             	mov    0x10(%ebp),%eax
    a095:	8b 00                	mov    (%eax),%eax
    a097:	83 f8 02             	cmp    $0x2,%eax
    a09a:	0f 85 ee 00 00 00    	jne    a18e <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a0a0:	8b 45 10             	mov    0x10(%ebp),%eax
    a0a3:	8b 40 04             	mov    0x4(%eax),%eax
    a0a6:	83 f8 08             	cmp    $0x8,%eax
    a0a9:	75 49                	jne    a0f4 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a0ab:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0ae:	89 d0                	mov    %edx,%eax
    a0b0:	01 c0                	add    %eax,%eax
    a0b2:	01 d0                	add    %edx,%eax
    a0b4:	89 c2                	mov    %eax,%edx
    a0b6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0b9:	01 c2                	add    %eax,%edx
    a0bb:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a0bf:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a0c1:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0c4:	89 d0                	mov    %edx,%eax
    a0c6:	01 c0                	add    %eax,%eax
    a0c8:	01 d0                	add    %edx,%eax
    a0ca:	8d 50 01             	lea    0x1(%eax),%edx
    a0cd:	8b 45 08             	mov    0x8(%ebp),%eax
    a0d0:	01 c2                	add    %eax,%edx
    a0d2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a0d6:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a0d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0db:	89 d0                	mov    %edx,%eax
    a0dd:	01 c0                	add    %eax,%eax
    a0df:	01 d0                	add    %edx,%eax
    a0e1:	8d 50 02             	lea    0x2(%eax),%edx
    a0e4:	8b 45 08             	mov    0x8(%ebp),%eax
    a0e7:	01 c2                	add    %eax,%edx
    a0e9:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a0ed:	88 02                	mov    %al,(%edx)
    a0ef:	e9 ca 02 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a0f4:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0f7:	89 d0                	mov    %edx,%eax
    a0f9:	01 c0                	add    %eax,%eax
    a0fb:	01 d0                	add    %edx,%eax
    a0fd:	01 c0                	add    %eax,%eax
    a0ff:	89 c2                	mov    %eax,%edx
    a101:	8b 45 08             	mov    0x8(%ebp),%eax
    a104:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a107:	8b 55 0c             	mov    0xc(%ebp),%edx
    a10a:	89 d0                	mov    %edx,%eax
    a10c:	01 c0                	add    %eax,%eax
    a10e:	01 d0                	add    %edx,%eax
    a110:	01 c0                	add    %eax,%eax
    a112:	8d 50 01             	lea    0x1(%eax),%edx
    a115:	8b 45 08             	mov    0x8(%ebp),%eax
    a118:	01 d0                	add    %edx,%eax
    a11a:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a11e:	88 10                	mov    %dl,(%eax)
    a120:	0f b6 00             	movzbl (%eax),%eax
    a123:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a125:	8b 55 0c             	mov    0xc(%ebp),%edx
    a128:	89 d0                	mov    %edx,%eax
    a12a:	01 c0                	add    %eax,%eax
    a12c:	01 d0                	add    %edx,%eax
    a12e:	01 c0                	add    %eax,%eax
    a130:	8d 50 02             	lea    0x2(%eax),%edx
    a133:	8b 45 08             	mov    0x8(%ebp),%eax
    a136:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a139:	8b 55 0c             	mov    0xc(%ebp),%edx
    a13c:	89 d0                	mov    %edx,%eax
    a13e:	01 c0                	add    %eax,%eax
    a140:	01 d0                	add    %edx,%eax
    a142:	01 c0                	add    %eax,%eax
    a144:	8d 50 03             	lea    0x3(%eax),%edx
    a147:	8b 45 08             	mov    0x8(%ebp),%eax
    a14a:	01 d0                	add    %edx,%eax
    a14c:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a150:	88 10                	mov    %dl,(%eax)
    a152:	0f b6 00             	movzbl (%eax),%eax
    a155:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a157:	8b 55 0c             	mov    0xc(%ebp),%edx
    a15a:	89 d0                	mov    %edx,%eax
    a15c:	01 c0                	add    %eax,%eax
    a15e:	01 d0                	add    %edx,%eax
    a160:	01 c0                	add    %eax,%eax
    a162:	8d 50 04             	lea    0x4(%eax),%edx
    a165:	8b 45 08             	mov    0x8(%ebp),%eax
    a168:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a16b:	8b 55 0c             	mov    0xc(%ebp),%edx
    a16e:	89 d0                	mov    %edx,%eax
    a170:	01 c0                	add    %eax,%eax
    a172:	01 d0                	add    %edx,%eax
    a174:	01 c0                	add    %eax,%eax
    a176:	8d 50 05             	lea    0x5(%eax),%edx
    a179:	8b 45 08             	mov    0x8(%ebp),%eax
    a17c:	01 d0                	add    %edx,%eax
    a17e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a182:	88 10                	mov    %dl,(%eax)
    a184:	0f b6 00             	movzbl (%eax),%eax
    a187:	88 01                	mov    %al,(%ecx)
    a189:	e9 30 02 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a18e:	8b 45 10             	mov    0x10(%ebp),%eax
    a191:	8b 00                	mov    (%eax),%eax
    a193:	83 f8 03             	cmp    $0x3,%eax
    a196:	75 6d                	jne    a205 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a198:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a19c:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a1a0:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a1a4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a1a8:	53                   	push   %ebx
    a1a9:	51                   	push   %ecx
    a1aa:	52                   	push   %edx
    a1ab:	50                   	push   %eax
    a1ac:	ff 75 14             	pushl  0x14(%ebp)
    a1af:	e8 fd fb ff ff       	call   9db1 <color_tree_get>
    a1b4:	83 c4 14             	add    $0x14,%esp
    a1b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a1ba:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a1be:	79 0a                	jns    a1ca <rgba8ToPixel+0x211>
    a1c0:	b8 52 00 00 00       	mov    $0x52,%eax
    a1c5:	e9 f9 01 00 00       	jmp    a3c3 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a1ca:	8b 45 10             	mov    0x10(%ebp),%eax
    a1cd:	8b 40 04             	mov    0x4(%eax),%eax
    a1d0:	83 f8 08             	cmp    $0x8,%eax
    a1d3:	75 12                	jne    a1e7 <rgba8ToPixel+0x22e>
    a1d5:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1d8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1db:	01 d0                	add    %edx,%eax
    a1dd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a1e0:	88 10                	mov    %dl,(%eax)
    a1e2:	e9 d7 01 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a1e7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a1ea:	8b 45 10             	mov    0x10(%ebp),%eax
    a1ed:	8b 40 04             	mov    0x4(%eax),%eax
    a1f0:	52                   	push   %edx
    a1f1:	50                   	push   %eax
    a1f2:	ff 75 0c             	pushl  0xc(%ebp)
    a1f5:	ff 75 08             	pushl  0x8(%ebp)
    a1f8:	e8 ae fa ff ff       	call   9cab <addColorBits>
    a1fd:	83 c4 10             	add    $0x10,%esp
    a200:	e9 b9 01 00 00       	jmp    a3be <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a205:	8b 45 10             	mov    0x10(%ebp),%eax
    a208:	8b 00                	mov    (%eax),%eax
    a20a:	83 f8 04             	cmp    $0x4,%eax
    a20d:	0f 85 9f 00 00 00    	jne    a2b2 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a213:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a217:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a21a:	8b 45 10             	mov    0x10(%ebp),%eax
    a21d:	8b 40 04             	mov    0x4(%eax),%eax
    a220:	83 f8 08             	cmp    $0x8,%eax
    a223:	75 2a                	jne    a24f <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a225:	8b 45 0c             	mov    0xc(%ebp),%eax
    a228:	01 c0                	add    %eax,%eax
    a22a:	89 c2                	mov    %eax,%edx
    a22c:	8b 45 08             	mov    0x8(%ebp),%eax
    a22f:	01 c2                	add    %eax,%edx
    a231:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a235:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a237:	8b 45 0c             	mov    0xc(%ebp),%eax
    a23a:	01 c0                	add    %eax,%eax
    a23c:	8d 50 01             	lea    0x1(%eax),%edx
    a23f:	8b 45 08             	mov    0x8(%ebp),%eax
    a242:	01 c2                	add    %eax,%edx
    a244:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a248:	88 02                	mov    %al,(%edx)
    a24a:	e9 6f 01 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a24f:	8b 45 10             	mov    0x10(%ebp),%eax
    a252:	8b 40 04             	mov    0x4(%eax),%eax
    a255:	83 f8 10             	cmp    $0x10,%eax
    a258:	0f 85 60 01 00 00    	jne    a3be <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a25e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a261:	c1 e0 02             	shl    $0x2,%eax
    a264:	89 c2                	mov    %eax,%edx
    a266:	8b 45 08             	mov    0x8(%ebp),%eax
    a269:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a26c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a26f:	c1 e0 02             	shl    $0x2,%eax
    a272:	8d 50 01             	lea    0x1(%eax),%edx
    a275:	8b 45 08             	mov    0x8(%ebp),%eax
    a278:	01 d0                	add    %edx,%eax
    a27a:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a27e:	88 10                	mov    %dl,(%eax)
    a280:	0f b6 00             	movzbl (%eax),%eax
    a283:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a285:	8b 45 0c             	mov    0xc(%ebp),%eax
    a288:	c1 e0 02             	shl    $0x2,%eax
    a28b:	8d 50 02             	lea    0x2(%eax),%edx
    a28e:	8b 45 08             	mov    0x8(%ebp),%eax
    a291:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a294:	8b 45 0c             	mov    0xc(%ebp),%eax
    a297:	c1 e0 02             	shl    $0x2,%eax
    a29a:	8d 50 03             	lea    0x3(%eax),%edx
    a29d:	8b 45 08             	mov    0x8(%ebp),%eax
    a2a0:	01 d0                	add    %edx,%eax
    a2a2:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a2a6:	88 10                	mov    %dl,(%eax)
    a2a8:	0f b6 00             	movzbl (%eax),%eax
    a2ab:	88 01                	mov    %al,(%ecx)
    a2ad:	e9 0c 01 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a2b2:	8b 45 10             	mov    0x10(%ebp),%eax
    a2b5:	8b 00                	mov    (%eax),%eax
    a2b7:	83 f8 06             	cmp    $0x6,%eax
    a2ba:	0f 85 fe 00 00 00    	jne    a3be <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a2c0:	8b 45 10             	mov    0x10(%ebp),%eax
    a2c3:	8b 40 04             	mov    0x4(%eax),%eax
    a2c6:	83 f8 08             	cmp    $0x8,%eax
    a2c9:	75 54                	jne    a31f <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a2cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2ce:	c1 e0 02             	shl    $0x2,%eax
    a2d1:	89 c2                	mov    %eax,%edx
    a2d3:	8b 45 08             	mov    0x8(%ebp),%eax
    a2d6:	01 c2                	add    %eax,%edx
    a2d8:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a2dc:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a2de:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e1:	c1 e0 02             	shl    $0x2,%eax
    a2e4:	8d 50 01             	lea    0x1(%eax),%edx
    a2e7:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ea:	01 c2                	add    %eax,%edx
    a2ec:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a2f0:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a2f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2f5:	c1 e0 02             	shl    $0x2,%eax
    a2f8:	8d 50 02             	lea    0x2(%eax),%edx
    a2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    a2fe:	01 c2                	add    %eax,%edx
    a300:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a304:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a306:	8b 45 0c             	mov    0xc(%ebp),%eax
    a309:	c1 e0 02             	shl    $0x2,%eax
    a30c:	8d 50 03             	lea    0x3(%eax),%edx
    a30f:	8b 45 08             	mov    0x8(%ebp),%eax
    a312:	01 c2                	add    %eax,%edx
    a314:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a318:	88 02                	mov    %al,(%edx)
    a31a:	e9 9f 00 00 00       	jmp    a3be <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a31f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a322:	c1 e0 03             	shl    $0x3,%eax
    a325:	89 c2                	mov    %eax,%edx
    a327:	8b 45 08             	mov    0x8(%ebp),%eax
    a32a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a32d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a330:	c1 e0 03             	shl    $0x3,%eax
    a333:	8d 50 01             	lea    0x1(%eax),%edx
    a336:	8b 45 08             	mov    0x8(%ebp),%eax
    a339:	01 d0                	add    %edx,%eax
    a33b:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a33f:	88 10                	mov    %dl,(%eax)
    a341:	0f b6 00             	movzbl (%eax),%eax
    a344:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a346:	8b 45 0c             	mov    0xc(%ebp),%eax
    a349:	c1 e0 03             	shl    $0x3,%eax
    a34c:	8d 50 02             	lea    0x2(%eax),%edx
    a34f:	8b 45 08             	mov    0x8(%ebp),%eax
    a352:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a355:	8b 45 0c             	mov    0xc(%ebp),%eax
    a358:	c1 e0 03             	shl    $0x3,%eax
    a35b:	8d 50 03             	lea    0x3(%eax),%edx
    a35e:	8b 45 08             	mov    0x8(%ebp),%eax
    a361:	01 d0                	add    %edx,%eax
    a363:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a367:	88 10                	mov    %dl,(%eax)
    a369:	0f b6 00             	movzbl (%eax),%eax
    a36c:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a36e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a371:	c1 e0 03             	shl    $0x3,%eax
    a374:	8d 50 04             	lea    0x4(%eax),%edx
    a377:	8b 45 08             	mov    0x8(%ebp),%eax
    a37a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a37d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a380:	c1 e0 03             	shl    $0x3,%eax
    a383:	8d 50 05             	lea    0x5(%eax),%edx
    a386:	8b 45 08             	mov    0x8(%ebp),%eax
    a389:	01 d0                	add    %edx,%eax
    a38b:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a38f:	88 10                	mov    %dl,(%eax)
    a391:	0f b6 00             	movzbl (%eax),%eax
    a394:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a396:	8b 45 0c             	mov    0xc(%ebp),%eax
    a399:	c1 e0 03             	shl    $0x3,%eax
    a39c:	8d 50 06             	lea    0x6(%eax),%edx
    a39f:	8b 45 08             	mov    0x8(%ebp),%eax
    a3a2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3a8:	c1 e0 03             	shl    $0x3,%eax
    a3ab:	8d 50 07             	lea    0x7(%eax),%edx
    a3ae:	8b 45 08             	mov    0x8(%ebp),%eax
    a3b1:	01 d0                	add    %edx,%eax
    a3b3:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a3b7:	88 10                	mov    %dl,(%eax)
    a3b9:	0f b6 00             	movzbl (%eax),%eax
    a3bc:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a3be:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a3c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a3c6:	c9                   	leave  
    a3c7:	c3                   	ret    

0000a3c8 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a3c8:	55                   	push   %ebp
    a3c9:	89 e5                	mov    %esp,%ebp
    a3cb:	53                   	push   %ebx
    a3cc:	83 ec 20             	sub    $0x20,%esp
    a3cf:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a3d2:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a3d5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a3d8:	8b 45 20             	mov    0x20(%ebp),%eax
    a3db:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a3df:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a3e3:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a3e7:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a3eb:	8b 45 10             	mov    0x10(%ebp),%eax
    a3ee:	8b 00                	mov    (%eax),%eax
    a3f0:	85 c0                	test   %eax,%eax
    a3f2:	75 36                	jne    a42a <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a3f4:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a3f8:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a3fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3ff:	01 c0                	add    %eax,%eax
    a401:	89 c2                	mov    %eax,%edx
    a403:	8b 45 08             	mov    0x8(%ebp),%eax
    a406:	01 d0                	add    %edx,%eax
    a408:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a40c:	66 c1 ea 08          	shr    $0x8,%dx
    a410:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a412:	8b 45 0c             	mov    0xc(%ebp),%eax
    a415:	01 c0                	add    %eax,%eax
    a417:	8d 50 01             	lea    0x1(%eax),%edx
    a41a:	8b 45 08             	mov    0x8(%ebp),%eax
    a41d:	01 d0                	add    %edx,%eax
    a41f:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a423:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a425:	e9 df 01 00 00       	jmp    a609 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a42a:	8b 45 10             	mov    0x10(%ebp),%eax
    a42d:	8b 00                	mov    (%eax),%eax
    a42f:	83 f8 02             	cmp    $0x2,%eax
    a432:	0f 85 a6 00 00 00    	jne    a4de <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a438:	8b 55 0c             	mov    0xc(%ebp),%edx
    a43b:	89 d0                	mov    %edx,%eax
    a43d:	01 c0                	add    %eax,%eax
    a43f:	01 d0                	add    %edx,%eax
    a441:	01 c0                	add    %eax,%eax
    a443:	89 c2                	mov    %eax,%edx
    a445:	8b 45 08             	mov    0x8(%ebp),%eax
    a448:	01 d0                	add    %edx,%eax
    a44a:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a44e:	66 c1 ea 08          	shr    $0x8,%dx
    a452:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a454:	8b 55 0c             	mov    0xc(%ebp),%edx
    a457:	89 d0                	mov    %edx,%eax
    a459:	01 c0                	add    %eax,%eax
    a45b:	01 d0                	add    %edx,%eax
    a45d:	01 c0                	add    %eax,%eax
    a45f:	8d 50 01             	lea    0x1(%eax),%edx
    a462:	8b 45 08             	mov    0x8(%ebp),%eax
    a465:	01 d0                	add    %edx,%eax
    a467:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a46b:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a46d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a470:	89 d0                	mov    %edx,%eax
    a472:	01 c0                	add    %eax,%eax
    a474:	01 d0                	add    %edx,%eax
    a476:	01 c0                	add    %eax,%eax
    a478:	8d 50 02             	lea    0x2(%eax),%edx
    a47b:	8b 45 08             	mov    0x8(%ebp),%eax
    a47e:	01 d0                	add    %edx,%eax
    a480:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a484:	66 c1 ea 08          	shr    $0x8,%dx
    a488:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a48a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a48d:	89 d0                	mov    %edx,%eax
    a48f:	01 c0                	add    %eax,%eax
    a491:	01 d0                	add    %edx,%eax
    a493:	01 c0                	add    %eax,%eax
    a495:	8d 50 03             	lea    0x3(%eax),%edx
    a498:	8b 45 08             	mov    0x8(%ebp),%eax
    a49b:	01 d0                	add    %edx,%eax
    a49d:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a4a1:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a4a3:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4a6:	89 d0                	mov    %edx,%eax
    a4a8:	01 c0                	add    %eax,%eax
    a4aa:	01 d0                	add    %edx,%eax
    a4ac:	01 c0                	add    %eax,%eax
    a4ae:	8d 50 04             	lea    0x4(%eax),%edx
    a4b1:	8b 45 08             	mov    0x8(%ebp),%eax
    a4b4:	01 d0                	add    %edx,%eax
    a4b6:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a4ba:	66 c1 ea 08          	shr    $0x8,%dx
    a4be:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a4c0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4c3:	89 d0                	mov    %edx,%eax
    a4c5:	01 c0                	add    %eax,%eax
    a4c7:	01 d0                	add    %edx,%eax
    a4c9:	01 c0                	add    %eax,%eax
    a4cb:	8d 50 05             	lea    0x5(%eax),%edx
    a4ce:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d1:	01 d0                	add    %edx,%eax
    a4d3:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a4d7:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a4d9:	e9 2b 01 00 00       	jmp    a609 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a4de:	8b 45 10             	mov    0x10(%ebp),%eax
    a4e1:	8b 00                	mov    (%eax),%eax
    a4e3:	83 f8 04             	cmp    $0x4,%eax
    a4e6:	75 64                	jne    a54c <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a4e8:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a4ec:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a4f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4f3:	c1 e0 02             	shl    $0x2,%eax
    a4f6:	89 c2                	mov    %eax,%edx
    a4f8:	8b 45 08             	mov    0x8(%ebp),%eax
    a4fb:	01 d0                	add    %edx,%eax
    a4fd:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a501:	66 c1 ea 08          	shr    $0x8,%dx
    a505:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a507:	8b 45 0c             	mov    0xc(%ebp),%eax
    a50a:	c1 e0 02             	shl    $0x2,%eax
    a50d:	8d 50 01             	lea    0x1(%eax),%edx
    a510:	8b 45 08             	mov    0x8(%ebp),%eax
    a513:	01 d0                	add    %edx,%eax
    a515:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a519:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a51b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a51e:	c1 e0 02             	shl    $0x2,%eax
    a521:	8d 50 02             	lea    0x2(%eax),%edx
    a524:	8b 45 08             	mov    0x8(%ebp),%eax
    a527:	01 d0                	add    %edx,%eax
    a529:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a52d:	66 c1 ea 08          	shr    $0x8,%dx
    a531:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a533:	8b 45 0c             	mov    0xc(%ebp),%eax
    a536:	c1 e0 02             	shl    $0x2,%eax
    a539:	8d 50 03             	lea    0x3(%eax),%edx
    a53c:	8b 45 08             	mov    0x8(%ebp),%eax
    a53f:	01 d0                	add    %edx,%eax
    a541:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a545:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a547:	e9 bd 00 00 00       	jmp    a609 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a54c:	8b 45 10             	mov    0x10(%ebp),%eax
    a54f:	8b 00                	mov    (%eax),%eax
    a551:	83 f8 06             	cmp    $0x6,%eax
    a554:	0f 85 af 00 00 00    	jne    a609 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a55a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a55d:	c1 e0 03             	shl    $0x3,%eax
    a560:	89 c2                	mov    %eax,%edx
    a562:	8b 45 08             	mov    0x8(%ebp),%eax
    a565:	01 d0                	add    %edx,%eax
    a567:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a56b:	66 c1 ea 08          	shr    $0x8,%dx
    a56f:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a571:	8b 45 0c             	mov    0xc(%ebp),%eax
    a574:	c1 e0 03             	shl    $0x3,%eax
    a577:	8d 50 01             	lea    0x1(%eax),%edx
    a57a:	8b 45 08             	mov    0x8(%ebp),%eax
    a57d:	01 d0                	add    %edx,%eax
    a57f:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a583:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a585:	8b 45 0c             	mov    0xc(%ebp),%eax
    a588:	c1 e0 03             	shl    $0x3,%eax
    a58b:	8d 50 02             	lea    0x2(%eax),%edx
    a58e:	8b 45 08             	mov    0x8(%ebp),%eax
    a591:	01 d0                	add    %edx,%eax
    a593:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a597:	66 c1 ea 08          	shr    $0x8,%dx
    a59b:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a59d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5a0:	c1 e0 03             	shl    $0x3,%eax
    a5a3:	8d 50 03             	lea    0x3(%eax),%edx
    a5a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a5a9:	01 d0                	add    %edx,%eax
    a5ab:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a5af:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a5b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5b4:	c1 e0 03             	shl    $0x3,%eax
    a5b7:	8d 50 04             	lea    0x4(%eax),%edx
    a5ba:	8b 45 08             	mov    0x8(%ebp),%eax
    a5bd:	01 d0                	add    %edx,%eax
    a5bf:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a5c3:	66 c1 ea 08          	shr    $0x8,%dx
    a5c7:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a5c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5cc:	c1 e0 03             	shl    $0x3,%eax
    a5cf:	8d 50 05             	lea    0x5(%eax),%edx
    a5d2:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d5:	01 d0                	add    %edx,%eax
    a5d7:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a5db:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a5dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5e0:	c1 e0 03             	shl    $0x3,%eax
    a5e3:	8d 50 06             	lea    0x6(%eax),%edx
    a5e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e9:	01 d0                	add    %edx,%eax
    a5eb:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a5ef:	66 c1 ea 08          	shr    $0x8,%dx
    a5f3:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a5f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5f8:	c1 e0 03             	shl    $0x3,%eax
    a5fb:	8d 50 07             	lea    0x7(%eax),%edx
    a5fe:	8b 45 08             	mov    0x8(%ebp),%eax
    a601:	01 d0                	add    %edx,%eax
    a603:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a607:	88 10                	mov    %dl,(%eax)
  }
}
    a609:	90                   	nop
    a60a:	83 c4 20             	add    $0x20,%esp
    a60d:	5b                   	pop    %ebx
    a60e:	5d                   	pop    %ebp
    a60f:	c3                   	ret    

0000a610 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a610:	55                   	push   %ebp
    a611:	89 e5                	mov    %esp,%ebp
    a613:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a616:	8b 45 20             	mov    0x20(%ebp),%eax
    a619:	8b 00                	mov    (%eax),%eax
    a61b:	85 c0                	test   %eax,%eax
    a61d:	0f 85 8c 01 00 00    	jne    a7af <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a623:	8b 45 20             	mov    0x20(%ebp),%eax
    a626:	8b 40 04             	mov    0x4(%eax),%eax
    a629:	83 f8 08             	cmp    $0x8,%eax
    a62c:	75 59                	jne    a687 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a62e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a631:	8b 45 18             	mov    0x18(%ebp),%eax
    a634:	01 d0                	add    %edx,%eax
    a636:	0f b6 10             	movzbl (%eax),%edx
    a639:	8b 45 10             	mov    0x10(%ebp),%eax
    a63c:	88 10                	mov    %dl,(%eax)
    a63e:	8b 45 10             	mov    0x10(%ebp),%eax
    a641:	0f b6 10             	movzbl (%eax),%edx
    a644:	8b 45 0c             	mov    0xc(%ebp),%eax
    a647:	88 10                	mov    %dl,(%eax)
    a649:	8b 45 0c             	mov    0xc(%ebp),%eax
    a64c:	0f b6 10             	movzbl (%eax),%edx
    a64f:	8b 45 08             	mov    0x8(%ebp),%eax
    a652:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a654:	8b 45 20             	mov    0x20(%ebp),%eax
    a657:	8b 40 10             	mov    0x10(%eax),%eax
    a65a:	85 c0                	test   %eax,%eax
    a65c:	74 1e                	je     a67c <getPixelColorRGBA8+0x6c>
    a65e:	8b 45 08             	mov    0x8(%ebp),%eax
    a661:	0f b6 00             	movzbl (%eax),%eax
    a664:	0f b6 d0             	movzbl %al,%edx
    a667:	8b 45 20             	mov    0x20(%ebp),%eax
    a66a:	8b 40 14             	mov    0x14(%eax),%eax
    a66d:	39 c2                	cmp    %eax,%edx
    a66f:	75 0b                	jne    a67c <getPixelColorRGBA8+0x6c>
    a671:	8b 45 14             	mov    0x14(%ebp),%eax
    a674:	c6 00 00             	movb   $0x0,(%eax)
    a677:	e9 5e 05 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a67c:	8b 45 14             	mov    0x14(%ebp),%eax
    a67f:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a682:	e9 53 05 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a687:	8b 45 20             	mov    0x20(%ebp),%eax
    a68a:	8b 40 04             	mov    0x4(%eax),%eax
    a68d:	83 f8 10             	cmp    $0x10,%eax
    a690:	0f 85 80 00 00 00    	jne    a716 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a696:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a699:	01 c0                	add    %eax,%eax
    a69b:	89 c2                	mov    %eax,%edx
    a69d:	8b 45 18             	mov    0x18(%ebp),%eax
    a6a0:	01 d0                	add    %edx,%eax
    a6a2:	0f b6 10             	movzbl (%eax),%edx
    a6a5:	8b 45 10             	mov    0x10(%ebp),%eax
    a6a8:	88 10                	mov    %dl,(%eax)
    a6aa:	8b 45 10             	mov    0x10(%ebp),%eax
    a6ad:	0f b6 10             	movzbl (%eax),%edx
    a6b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6b3:	88 10                	mov    %dl,(%eax)
    a6b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6b8:	0f b6 10             	movzbl (%eax),%edx
    a6bb:	8b 45 08             	mov    0x8(%ebp),%eax
    a6be:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a6c0:	8b 45 20             	mov    0x20(%ebp),%eax
    a6c3:	8b 40 10             	mov    0x10(%eax),%eax
    a6c6:	85 c0                	test   %eax,%eax
    a6c8:	74 41                	je     a70b <getPixelColorRGBA8+0xfb>
    a6ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6cd:	01 c0                	add    %eax,%eax
    a6cf:	89 c2                	mov    %eax,%edx
    a6d1:	8b 45 18             	mov    0x18(%ebp),%eax
    a6d4:	01 d0                	add    %edx,%eax
    a6d6:	0f b6 00             	movzbl (%eax),%eax
    a6d9:	0f b6 c0             	movzbl %al,%eax
    a6dc:	c1 e0 08             	shl    $0x8,%eax
    a6df:	89 c2                	mov    %eax,%edx
    a6e1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6e4:	01 c0                	add    %eax,%eax
    a6e6:	8d 48 01             	lea    0x1(%eax),%ecx
    a6e9:	8b 45 18             	mov    0x18(%ebp),%eax
    a6ec:	01 c8                	add    %ecx,%eax
    a6ee:	0f b6 00             	movzbl (%eax),%eax
    a6f1:	0f b6 c0             	movzbl %al,%eax
    a6f4:	01 c2                	add    %eax,%edx
    a6f6:	8b 45 20             	mov    0x20(%ebp),%eax
    a6f9:	8b 40 14             	mov    0x14(%eax),%eax
    a6fc:	39 c2                	cmp    %eax,%edx
    a6fe:	75 0b                	jne    a70b <getPixelColorRGBA8+0xfb>
    a700:	8b 45 14             	mov    0x14(%ebp),%eax
    a703:	c6 00 00             	movb   $0x0,(%eax)
    a706:	e9 cf 04 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a70b:	8b 45 14             	mov    0x14(%ebp),%eax
    a70e:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a711:	e9 c4 04 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a716:	8b 45 20             	mov    0x20(%ebp),%eax
    a719:	8b 40 04             	mov    0x4(%eax),%eax
    a71c:	ba 01 00 00 00       	mov    $0x1,%edx
    a721:	89 c1                	mov    %eax,%ecx
    a723:	d3 e2                	shl    %cl,%edx
    a725:	89 d0                	mov    %edx,%eax
    a727:	83 e8 01             	sub    $0x1,%eax
    a72a:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a72d:	8b 45 20             	mov    0x20(%ebp),%eax
    a730:	8b 50 04             	mov    0x4(%eax),%edx
    a733:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a736:	0f af c2             	imul   %edx,%eax
    a739:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a73c:	8b 45 20             	mov    0x20(%ebp),%eax
    a73f:	8b 40 04             	mov    0x4(%eax),%eax
    a742:	50                   	push   %eax
    a743:	ff 75 18             	pushl  0x18(%ebp)
    a746:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a749:	50                   	push   %eax
    a74a:	e8 06 db ff ff       	call   8255 <readBitsFromReversedStream>
    a74f:	83 c4 0c             	add    $0xc,%esp
    a752:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a755:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a758:	89 d0                	mov    %edx,%eax
    a75a:	c1 e0 08             	shl    $0x8,%eax
    a75d:	29 d0                	sub    %edx,%eax
    a75f:	ba 00 00 00 00       	mov    $0x0,%edx
    a764:	f7 75 f8             	divl   -0x8(%ebp)
    a767:	89 c2                	mov    %eax,%edx
    a769:	8b 45 10             	mov    0x10(%ebp),%eax
    a76c:	88 10                	mov    %dl,(%eax)
    a76e:	8b 45 10             	mov    0x10(%ebp),%eax
    a771:	0f b6 10             	movzbl (%eax),%edx
    a774:	8b 45 0c             	mov    0xc(%ebp),%eax
    a777:	88 10                	mov    %dl,(%eax)
    a779:	8b 45 0c             	mov    0xc(%ebp),%eax
    a77c:	0f b6 10             	movzbl (%eax),%edx
    a77f:	8b 45 08             	mov    0x8(%ebp),%eax
    a782:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a784:	8b 45 20             	mov    0x20(%ebp),%eax
    a787:	8b 40 10             	mov    0x10(%eax),%eax
    a78a:	85 c0                	test   %eax,%eax
    a78c:	74 16                	je     a7a4 <getPixelColorRGBA8+0x194>
    a78e:	8b 45 20             	mov    0x20(%ebp),%eax
    a791:	8b 40 14             	mov    0x14(%eax),%eax
    a794:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a797:	75 0b                	jne    a7a4 <getPixelColorRGBA8+0x194>
    a799:	8b 45 14             	mov    0x14(%ebp),%eax
    a79c:	c6 00 00             	movb   $0x0,(%eax)
    a79f:	e9 36 04 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7a4:	8b 45 14             	mov    0x14(%ebp),%eax
    a7a7:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7aa:	e9 2b 04 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a7af:	8b 45 20             	mov    0x20(%ebp),%eax
    a7b2:	8b 00                	mov    (%eax),%eax
    a7b4:	83 f8 02             	cmp    $0x2,%eax
    a7b7:	0f 85 f5 01 00 00    	jne    a9b2 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a7bd:	8b 45 20             	mov    0x20(%ebp),%eax
    a7c0:	8b 40 04             	mov    0x4(%eax),%eax
    a7c3:	83 f8 08             	cmp    $0x8,%eax
    a7c6:	0f 85 a3 00 00 00    	jne    a86f <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a7cc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7cf:	89 d0                	mov    %edx,%eax
    a7d1:	01 c0                	add    %eax,%eax
    a7d3:	01 d0                	add    %edx,%eax
    a7d5:	89 c2                	mov    %eax,%edx
    a7d7:	8b 45 18             	mov    0x18(%ebp),%eax
    a7da:	01 d0                	add    %edx,%eax
    a7dc:	0f b6 10             	movzbl (%eax),%edx
    a7df:	8b 45 08             	mov    0x8(%ebp),%eax
    a7e2:	88 10                	mov    %dl,(%eax)
    a7e4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7e7:	89 d0                	mov    %edx,%eax
    a7e9:	01 c0                	add    %eax,%eax
    a7eb:	01 d0                	add    %edx,%eax
    a7ed:	8d 50 01             	lea    0x1(%eax),%edx
    a7f0:	8b 45 18             	mov    0x18(%ebp),%eax
    a7f3:	01 d0                	add    %edx,%eax
    a7f5:	0f b6 10             	movzbl (%eax),%edx
    a7f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7fb:	88 10                	mov    %dl,(%eax)
    a7fd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a800:	89 d0                	mov    %edx,%eax
    a802:	01 c0                	add    %eax,%eax
    a804:	01 d0                	add    %edx,%eax
    a806:	8d 50 02             	lea    0x2(%eax),%edx
    a809:	8b 45 18             	mov    0x18(%ebp),%eax
    a80c:	01 d0                	add    %edx,%eax
    a80e:	0f b6 10             	movzbl (%eax),%edx
    a811:	8b 45 10             	mov    0x10(%ebp),%eax
    a814:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a816:	8b 45 20             	mov    0x20(%ebp),%eax
    a819:	8b 40 10             	mov    0x10(%eax),%eax
    a81c:	85 c0                	test   %eax,%eax
    a81e:	74 44                	je     a864 <getPixelColorRGBA8+0x254>
    a820:	8b 45 08             	mov    0x8(%ebp),%eax
    a823:	0f b6 00             	movzbl (%eax),%eax
    a826:	0f b6 d0             	movzbl %al,%edx
    a829:	8b 45 20             	mov    0x20(%ebp),%eax
    a82c:	8b 40 14             	mov    0x14(%eax),%eax
    a82f:	39 c2                	cmp    %eax,%edx
    a831:	75 31                	jne    a864 <getPixelColorRGBA8+0x254>
    a833:	8b 45 0c             	mov    0xc(%ebp),%eax
    a836:	0f b6 00             	movzbl (%eax),%eax
    a839:	0f b6 d0             	movzbl %al,%edx
    a83c:	8b 45 20             	mov    0x20(%ebp),%eax
    a83f:	8b 40 18             	mov    0x18(%eax),%eax
    a842:	39 c2                	cmp    %eax,%edx
    a844:	75 1e                	jne    a864 <getPixelColorRGBA8+0x254>
    a846:	8b 45 10             	mov    0x10(%ebp),%eax
    a849:	0f b6 00             	movzbl (%eax),%eax
    a84c:	0f b6 d0             	movzbl %al,%edx
    a84f:	8b 45 20             	mov    0x20(%ebp),%eax
    a852:	8b 40 1c             	mov    0x1c(%eax),%eax
    a855:	39 c2                	cmp    %eax,%edx
    a857:	75 0b                	jne    a864 <getPixelColorRGBA8+0x254>
    a859:	8b 45 14             	mov    0x14(%ebp),%eax
    a85c:	c6 00 00             	movb   $0x0,(%eax)
    a85f:	e9 76 03 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a864:	8b 45 14             	mov    0x14(%ebp),%eax
    a867:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a86a:	e9 6b 03 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a86f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a872:	89 d0                	mov    %edx,%eax
    a874:	01 c0                	add    %eax,%eax
    a876:	01 d0                	add    %edx,%eax
    a878:	01 c0                	add    %eax,%eax
    a87a:	89 c2                	mov    %eax,%edx
    a87c:	8b 45 18             	mov    0x18(%ebp),%eax
    a87f:	01 d0                	add    %edx,%eax
    a881:	0f b6 10             	movzbl (%eax),%edx
    a884:	8b 45 08             	mov    0x8(%ebp),%eax
    a887:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a889:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a88c:	89 d0                	mov    %edx,%eax
    a88e:	01 c0                	add    %eax,%eax
    a890:	01 d0                	add    %edx,%eax
    a892:	01 c0                	add    %eax,%eax
    a894:	8d 50 02             	lea    0x2(%eax),%edx
    a897:	8b 45 18             	mov    0x18(%ebp),%eax
    a89a:	01 d0                	add    %edx,%eax
    a89c:	0f b6 10             	movzbl (%eax),%edx
    a89f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8a2:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a8a4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8a7:	89 d0                	mov    %edx,%eax
    a8a9:	01 c0                	add    %eax,%eax
    a8ab:	01 d0                	add    %edx,%eax
    a8ad:	01 c0                	add    %eax,%eax
    a8af:	8d 50 04             	lea    0x4(%eax),%edx
    a8b2:	8b 45 18             	mov    0x18(%ebp),%eax
    a8b5:	01 d0                	add    %edx,%eax
    a8b7:	0f b6 10             	movzbl (%eax),%edx
    a8ba:	8b 45 10             	mov    0x10(%ebp),%eax
    a8bd:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a8bf:	8b 45 20             	mov    0x20(%ebp),%eax
    a8c2:	8b 40 10             	mov    0x10(%eax),%eax
    a8c5:	85 c0                	test   %eax,%eax
    a8c7:	0f 84 da 00 00 00    	je     a9a7 <getPixelColorRGBA8+0x397>
    a8cd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8d0:	89 d0                	mov    %edx,%eax
    a8d2:	01 c0                	add    %eax,%eax
    a8d4:	01 d0                	add    %edx,%eax
    a8d6:	01 c0                	add    %eax,%eax
    a8d8:	89 c2                	mov    %eax,%edx
    a8da:	8b 45 18             	mov    0x18(%ebp),%eax
    a8dd:	01 d0                	add    %edx,%eax
    a8df:	0f b6 00             	movzbl (%eax),%eax
    a8e2:	0f b6 c0             	movzbl %al,%eax
    a8e5:	c1 e0 08             	shl    $0x8,%eax
    a8e8:	89 c1                	mov    %eax,%ecx
    a8ea:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8ed:	89 d0                	mov    %edx,%eax
    a8ef:	01 c0                	add    %eax,%eax
    a8f1:	01 d0                	add    %edx,%eax
    a8f3:	01 c0                	add    %eax,%eax
    a8f5:	8d 50 01             	lea    0x1(%eax),%edx
    a8f8:	8b 45 18             	mov    0x18(%ebp),%eax
    a8fb:	01 d0                	add    %edx,%eax
    a8fd:	0f b6 00             	movzbl (%eax),%eax
    a900:	0f b6 c0             	movzbl %al,%eax
    a903:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a906:	8b 45 20             	mov    0x20(%ebp),%eax
    a909:	8b 40 14             	mov    0x14(%eax),%eax
    a90c:	39 c2                	cmp    %eax,%edx
    a90e:	0f 85 93 00 00 00    	jne    a9a7 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a914:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a917:	89 d0                	mov    %edx,%eax
    a919:	01 c0                	add    %eax,%eax
    a91b:	01 d0                	add    %edx,%eax
    a91d:	01 c0                	add    %eax,%eax
    a91f:	8d 50 02             	lea    0x2(%eax),%edx
    a922:	8b 45 18             	mov    0x18(%ebp),%eax
    a925:	01 d0                	add    %edx,%eax
    a927:	0f b6 00             	movzbl (%eax),%eax
    a92a:	0f b6 c0             	movzbl %al,%eax
    a92d:	c1 e0 08             	shl    $0x8,%eax
    a930:	89 c1                	mov    %eax,%ecx
    a932:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a935:	89 d0                	mov    %edx,%eax
    a937:	01 c0                	add    %eax,%eax
    a939:	01 d0                	add    %edx,%eax
    a93b:	01 c0                	add    %eax,%eax
    a93d:	8d 50 03             	lea    0x3(%eax),%edx
    a940:	8b 45 18             	mov    0x18(%ebp),%eax
    a943:	01 d0                	add    %edx,%eax
    a945:	0f b6 00             	movzbl (%eax),%eax
    a948:	0f b6 c0             	movzbl %al,%eax
    a94b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a94e:	8b 45 20             	mov    0x20(%ebp),%eax
    a951:	8b 40 18             	mov    0x18(%eax),%eax
    a954:	39 c2                	cmp    %eax,%edx
    a956:	75 4f                	jne    a9a7 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a958:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a95b:	89 d0                	mov    %edx,%eax
    a95d:	01 c0                	add    %eax,%eax
    a95f:	01 d0                	add    %edx,%eax
    a961:	01 c0                	add    %eax,%eax
    a963:	8d 50 04             	lea    0x4(%eax),%edx
    a966:	8b 45 18             	mov    0x18(%ebp),%eax
    a969:	01 d0                	add    %edx,%eax
    a96b:	0f b6 00             	movzbl (%eax),%eax
    a96e:	0f b6 c0             	movzbl %al,%eax
    a971:	c1 e0 08             	shl    $0x8,%eax
    a974:	89 c1                	mov    %eax,%ecx
    a976:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a979:	89 d0                	mov    %edx,%eax
    a97b:	01 c0                	add    %eax,%eax
    a97d:	01 d0                	add    %edx,%eax
    a97f:	01 c0                	add    %eax,%eax
    a981:	8d 50 05             	lea    0x5(%eax),%edx
    a984:	8b 45 18             	mov    0x18(%ebp),%eax
    a987:	01 d0                	add    %edx,%eax
    a989:	0f b6 00             	movzbl (%eax),%eax
    a98c:	0f b6 c0             	movzbl %al,%eax
    a98f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a992:	8b 45 20             	mov    0x20(%ebp),%eax
    a995:	8b 40 1c             	mov    0x1c(%eax),%eax
    a998:	39 c2                	cmp    %eax,%edx
    a99a:	75 0b                	jne    a9a7 <getPixelColorRGBA8+0x397>
    a99c:	8b 45 14             	mov    0x14(%ebp),%eax
    a99f:	c6 00 00             	movb   $0x0,(%eax)
    a9a2:	e9 33 02 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a9a7:	8b 45 14             	mov    0x14(%ebp),%eax
    a9aa:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9ad:	e9 28 02 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a9b2:	8b 45 20             	mov    0x20(%ebp),%eax
    a9b5:	8b 00                	mov    (%eax),%eax
    a9b7:	83 f8 03             	cmp    $0x3,%eax
    a9ba:	0f 85 ac 00 00 00    	jne    aa6c <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    a9c0:	8b 45 20             	mov    0x20(%ebp),%eax
    a9c3:	8b 40 04             	mov    0x4(%eax),%eax
    a9c6:	83 f8 08             	cmp    $0x8,%eax
    a9c9:	75 13                	jne    a9de <getPixelColorRGBA8+0x3ce>
    a9cb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a9ce:	8b 45 18             	mov    0x18(%ebp),%eax
    a9d1:	01 d0                	add    %edx,%eax
    a9d3:	0f b6 00             	movzbl (%eax),%eax
    a9d6:	0f b6 c0             	movzbl %al,%eax
    a9d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a9dc:	eb 28                	jmp    aa06 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    a9de:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e1:	8b 50 04             	mov    0x4(%eax),%edx
    a9e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9e7:	0f af c2             	imul   %edx,%eax
    a9ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a9ed:	8b 45 20             	mov    0x20(%ebp),%eax
    a9f0:	8b 40 04             	mov    0x4(%eax),%eax
    a9f3:	50                   	push   %eax
    a9f4:	ff 75 18             	pushl  0x18(%ebp)
    a9f7:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a9fa:	50                   	push   %eax
    a9fb:	e8 55 d8 ff ff       	call   8255 <readBitsFromReversedStream>
    aa00:	83 c4 0c             	add    $0xc,%esp
    aa03:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    aa06:	8b 45 20             	mov    0x20(%ebp),%eax
    aa09:	8b 40 08             	mov    0x8(%eax),%eax
    aa0c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa0f:	c1 e2 02             	shl    $0x2,%edx
    aa12:	01 d0                	add    %edx,%eax
    aa14:	0f b6 10             	movzbl (%eax),%edx
    aa17:	8b 45 08             	mov    0x8(%ebp),%eax
    aa1a:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    aa1c:	8b 45 20             	mov    0x20(%ebp),%eax
    aa1f:	8b 40 08             	mov    0x8(%eax),%eax
    aa22:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa25:	c1 e2 02             	shl    $0x2,%edx
    aa28:	83 c2 01             	add    $0x1,%edx
    aa2b:	01 d0                	add    %edx,%eax
    aa2d:	0f b6 10             	movzbl (%eax),%edx
    aa30:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa33:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    aa35:	8b 45 20             	mov    0x20(%ebp),%eax
    aa38:	8b 40 08             	mov    0x8(%eax),%eax
    aa3b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa3e:	c1 e2 02             	shl    $0x2,%edx
    aa41:	83 c2 02             	add    $0x2,%edx
    aa44:	01 d0                	add    %edx,%eax
    aa46:	0f b6 10             	movzbl (%eax),%edx
    aa49:	8b 45 10             	mov    0x10(%ebp),%eax
    aa4c:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    aa4e:	8b 45 20             	mov    0x20(%ebp),%eax
    aa51:	8b 40 08             	mov    0x8(%eax),%eax
    aa54:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa57:	c1 e2 02             	shl    $0x2,%edx
    aa5a:	83 c2 03             	add    $0x3,%edx
    aa5d:	01 d0                	add    %edx,%eax
    aa5f:	0f b6 10             	movzbl (%eax),%edx
    aa62:	8b 45 14             	mov    0x14(%ebp),%eax
    aa65:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa67:	e9 6e 01 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    aa6c:	8b 45 20             	mov    0x20(%ebp),%eax
    aa6f:	8b 00                	mov    (%eax),%eax
    aa71:	83 f8 04             	cmp    $0x4,%eax
    aa74:	0f 85 95 00 00 00    	jne    ab0f <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    aa7a:	8b 45 20             	mov    0x20(%ebp),%eax
    aa7d:	8b 40 04             	mov    0x4(%eax),%eax
    aa80:	83 f8 08             	cmp    $0x8,%eax
    aa83:	75 44                	jne    aac9 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    aa85:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa88:	01 c0                	add    %eax,%eax
    aa8a:	89 c2                	mov    %eax,%edx
    aa8c:	8b 45 18             	mov    0x18(%ebp),%eax
    aa8f:	01 d0                	add    %edx,%eax
    aa91:	0f b6 10             	movzbl (%eax),%edx
    aa94:	8b 45 10             	mov    0x10(%ebp),%eax
    aa97:	88 10                	mov    %dl,(%eax)
    aa99:	8b 45 10             	mov    0x10(%ebp),%eax
    aa9c:	0f b6 10             	movzbl (%eax),%edx
    aa9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaa2:	88 10                	mov    %dl,(%eax)
    aaa4:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaa7:	0f b6 10             	movzbl (%eax),%edx
    aaaa:	8b 45 08             	mov    0x8(%ebp),%eax
    aaad:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    aaaf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aab2:	01 c0                	add    %eax,%eax
    aab4:	8d 50 01             	lea    0x1(%eax),%edx
    aab7:	8b 45 18             	mov    0x18(%ebp),%eax
    aaba:	01 d0                	add    %edx,%eax
    aabc:	0f b6 10             	movzbl (%eax),%edx
    aabf:	8b 45 14             	mov    0x14(%ebp),%eax
    aac2:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aac4:	e9 11 01 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    aac9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aacc:	c1 e0 02             	shl    $0x2,%eax
    aacf:	89 c2                	mov    %eax,%edx
    aad1:	8b 45 18             	mov    0x18(%ebp),%eax
    aad4:	01 d0                	add    %edx,%eax
    aad6:	0f b6 10             	movzbl (%eax),%edx
    aad9:	8b 45 10             	mov    0x10(%ebp),%eax
    aadc:	88 10                	mov    %dl,(%eax)
    aade:	8b 45 10             	mov    0x10(%ebp),%eax
    aae1:	0f b6 10             	movzbl (%eax),%edx
    aae4:	8b 45 0c             	mov    0xc(%ebp),%eax
    aae7:	88 10                	mov    %dl,(%eax)
    aae9:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaec:	0f b6 10             	movzbl (%eax),%edx
    aaef:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf2:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    aaf4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaf7:	c1 e0 02             	shl    $0x2,%eax
    aafa:	8d 50 02             	lea    0x2(%eax),%edx
    aafd:	8b 45 18             	mov    0x18(%ebp),%eax
    ab00:	01 d0                	add    %edx,%eax
    ab02:	0f b6 10             	movzbl (%eax),%edx
    ab05:	8b 45 14             	mov    0x14(%ebp),%eax
    ab08:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab0a:	e9 cb 00 00 00       	jmp    abda <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    ab0f:	8b 45 20             	mov    0x20(%ebp),%eax
    ab12:	8b 00                	mov    (%eax),%eax
    ab14:	83 f8 06             	cmp    $0x6,%eax
    ab17:	0f 85 bd 00 00 00    	jne    abda <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    ab1d:	8b 45 20             	mov    0x20(%ebp),%eax
    ab20:	8b 40 04             	mov    0x4(%eax),%eax
    ab23:	83 f8 08             	cmp    $0x8,%eax
    ab26:	75 59                	jne    ab81 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    ab28:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab2b:	c1 e0 02             	shl    $0x2,%eax
    ab2e:	89 c2                	mov    %eax,%edx
    ab30:	8b 45 18             	mov    0x18(%ebp),%eax
    ab33:	01 d0                	add    %edx,%eax
    ab35:	0f b6 10             	movzbl (%eax),%edx
    ab38:	8b 45 08             	mov    0x8(%ebp),%eax
    ab3b:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    ab3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab40:	c1 e0 02             	shl    $0x2,%eax
    ab43:	8d 50 01             	lea    0x1(%eax),%edx
    ab46:	8b 45 18             	mov    0x18(%ebp),%eax
    ab49:	01 d0                	add    %edx,%eax
    ab4b:	0f b6 10             	movzbl (%eax),%edx
    ab4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab51:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    ab53:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab56:	c1 e0 02             	shl    $0x2,%eax
    ab59:	8d 50 02             	lea    0x2(%eax),%edx
    ab5c:	8b 45 18             	mov    0x18(%ebp),%eax
    ab5f:	01 d0                	add    %edx,%eax
    ab61:	0f b6 10             	movzbl (%eax),%edx
    ab64:	8b 45 10             	mov    0x10(%ebp),%eax
    ab67:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    ab69:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab6c:	c1 e0 02             	shl    $0x2,%eax
    ab6f:	8d 50 03             	lea    0x3(%eax),%edx
    ab72:	8b 45 18             	mov    0x18(%ebp),%eax
    ab75:	01 d0                	add    %edx,%eax
    ab77:	0f b6 10             	movzbl (%eax),%edx
    ab7a:	8b 45 14             	mov    0x14(%ebp),%eax
    ab7d:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab7f:	eb 59                	jmp    abda <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    ab81:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab84:	c1 e0 03             	shl    $0x3,%eax
    ab87:	89 c2                	mov    %eax,%edx
    ab89:	8b 45 18             	mov    0x18(%ebp),%eax
    ab8c:	01 d0                	add    %edx,%eax
    ab8e:	0f b6 10             	movzbl (%eax),%edx
    ab91:	8b 45 08             	mov    0x8(%ebp),%eax
    ab94:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    ab96:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab99:	c1 e0 03             	shl    $0x3,%eax
    ab9c:	8d 50 02             	lea    0x2(%eax),%edx
    ab9f:	8b 45 18             	mov    0x18(%ebp),%eax
    aba2:	01 d0                	add    %edx,%eax
    aba4:	0f b6 10             	movzbl (%eax),%edx
    aba7:	8b 45 0c             	mov    0xc(%ebp),%eax
    abaa:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    abac:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abaf:	c1 e0 03             	shl    $0x3,%eax
    abb2:	8d 50 04             	lea    0x4(%eax),%edx
    abb5:	8b 45 18             	mov    0x18(%ebp),%eax
    abb8:	01 d0                	add    %edx,%eax
    abba:	0f b6 10             	movzbl (%eax),%edx
    abbd:	8b 45 10             	mov    0x10(%ebp),%eax
    abc0:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    abc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abc5:	c1 e0 03             	shl    $0x3,%eax
    abc8:	8d 50 06             	lea    0x6(%eax),%edx
    abcb:	8b 45 18             	mov    0x18(%ebp),%eax
    abce:	01 d0                	add    %edx,%eax
    abd0:	0f b6 10             	movzbl (%eax),%edx
    abd3:	8b 45 14             	mov    0x14(%ebp),%eax
    abd6:	88 10                	mov    %dl,(%eax)
    }
  }
}
    abd8:	eb 00                	jmp    abda <getPixelColorRGBA8+0x5ca>
    abda:	90                   	nop
    abdb:	c9                   	leave  
    abdc:	c3                   	ret    

0000abdd <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    abdd:	55                   	push   %ebp
    abde:	89 e5                	mov    %esp,%ebp
    abe0:	53                   	push   %ebx
    abe1:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    abe4:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    abeb:	8b 45 14             	mov    0x14(%ebp),%eax
    abee:	8b 00                	mov    (%eax),%eax
    abf0:	85 c0                	test   %eax,%eax
    abf2:	0f 85 14 02 00 00    	jne    ae0c <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    abf8:	8b 45 14             	mov    0x14(%ebp),%eax
    abfb:	8b 40 04             	mov    0x4(%eax),%eax
    abfe:	83 f8 08             	cmp    $0x8,%eax
    ac01:	0f 85 a0 00 00 00    	jne    aca7 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac07:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac0e:	eb 39                	jmp    ac49 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ac10:	8b 45 08             	mov    0x8(%ebp),%eax
    ac13:	83 c0 01             	add    $0x1,%eax
    ac16:	8b 55 08             	mov    0x8(%ebp),%edx
    ac19:	83 c2 02             	add    $0x2,%edx
    ac1c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ac1f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac22:	01 d9                	add    %ebx,%ecx
    ac24:	0f b6 09             	movzbl (%ecx),%ecx
    ac27:	88 0a                	mov    %cl,(%edx)
    ac29:	0f b6 12             	movzbl (%edx),%edx
    ac2c:	88 10                	mov    %dl,(%eax)
    ac2e:	0f b6 10             	movzbl (%eax),%edx
    ac31:	8b 45 08             	mov    0x8(%ebp),%eax
    ac34:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    ac36:	8b 45 08             	mov    0x8(%ebp),%eax
    ac39:	83 c0 03             	add    $0x3,%eax
    ac3c:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac3f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac43:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac46:	01 45 08             	add    %eax,0x8(%ebp)
    ac49:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac4c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ac4f:	75 bf                	jne    ac10 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ac51:	8b 45 14             	mov    0x14(%ebp),%eax
    ac54:	8b 40 10             	mov    0x10(%eax),%eax
    ac57:	85 c0                	test   %eax,%eax
    ac59:	0f 84 48 06 00 00    	je     b2a7 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ac5f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac62:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ac66:	f7 d8                	neg    %eax
    ac68:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac6b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac72:	eb 26                	jmp    ac9a <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    ac74:	8b 45 08             	mov    0x8(%ebp),%eax
    ac77:	0f b6 00             	movzbl (%eax),%eax
    ac7a:	0f b6 d0             	movzbl %al,%edx
    ac7d:	8b 45 14             	mov    0x14(%ebp),%eax
    ac80:	8b 40 14             	mov    0x14(%eax),%eax
    ac83:	39 c2                	cmp    %eax,%edx
    ac85:	75 09                	jne    ac90 <getPixelColorsRGBA8+0xb3>
    ac87:	8b 45 08             	mov    0x8(%ebp),%eax
    ac8a:	83 c0 03             	add    $0x3,%eax
    ac8d:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac90:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac94:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac97:	01 45 08             	add    %eax,0x8(%ebp)
    ac9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac9d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aca0:	75 d2                	jne    ac74 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    aca2:	e9 00 06 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    aca7:	8b 45 14             	mov    0x14(%ebp),%eax
    acaa:	8b 40 04             	mov    0x4(%eax),%eax
    acad:	83 f8 10             	cmp    $0x10,%eax
    acb0:	0f 85 a5 00 00 00    	jne    ad5b <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acb6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    acbd:	e9 88 00 00 00       	jmp    ad4a <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    acc2:	8b 45 08             	mov    0x8(%ebp),%eax
    acc5:	83 c0 01             	add    $0x1,%eax
    acc8:	8b 55 08             	mov    0x8(%ebp),%edx
    accb:	83 c2 02             	add    $0x2,%edx
    acce:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    acd1:	01 c9                	add    %ecx,%ecx
    acd3:	89 cb                	mov    %ecx,%ebx
    acd5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    acd8:	01 d9                	add    %ebx,%ecx
    acda:	0f b6 09             	movzbl (%ecx),%ecx
    acdd:	88 0a                	mov    %cl,(%edx)
    acdf:	0f b6 12             	movzbl (%edx),%edx
    ace2:	88 10                	mov    %dl,(%eax)
    ace4:	0f b6 10             	movzbl (%eax),%edx
    ace7:	8b 45 08             	mov    0x8(%ebp),%eax
    acea:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    acec:	8b 45 08             	mov    0x8(%ebp),%eax
    acef:	8d 50 03             	lea    0x3(%eax),%edx
    acf2:	8b 45 14             	mov    0x14(%ebp),%eax
    acf5:	8b 40 10             	mov    0x10(%eax),%eax
    acf8:	85 c0                	test   %eax,%eax
    acfa:	74 3d                	je     ad39 <getPixelColorsRGBA8+0x15c>
    acfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    acff:	01 c0                	add    %eax,%eax
    ad01:	89 c1                	mov    %eax,%ecx
    ad03:	8b 45 10             	mov    0x10(%ebp),%eax
    ad06:	01 c8                	add    %ecx,%eax
    ad08:	0f b6 00             	movzbl (%eax),%eax
    ad0b:	0f b6 c0             	movzbl %al,%eax
    ad0e:	c1 e0 08             	shl    $0x8,%eax
    ad11:	89 c1                	mov    %eax,%ecx
    ad13:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad16:	01 c0                	add    %eax,%eax
    ad18:	8d 58 01             	lea    0x1(%eax),%ebx
    ad1b:	8b 45 10             	mov    0x10(%ebp),%eax
    ad1e:	01 d8                	add    %ebx,%eax
    ad20:	0f b6 00             	movzbl (%eax),%eax
    ad23:	0f b6 c0             	movzbl %al,%eax
    ad26:	01 c1                	add    %eax,%ecx
    ad28:	8b 45 14             	mov    0x14(%ebp),%eax
    ad2b:	8b 40 14             	mov    0x14(%eax),%eax
    ad2e:	39 c1                	cmp    %eax,%ecx
    ad30:	75 07                	jne    ad39 <getPixelColorsRGBA8+0x15c>
    ad32:	b8 00 00 00 00       	mov    $0x0,%eax
    ad37:	eb 05                	jmp    ad3e <getPixelColorsRGBA8+0x161>
    ad39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad3e:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad40:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad44:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad47:	01 45 08             	add    %eax,0x8(%ebp)
    ad4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad4d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad50:	0f 85 6c ff ff ff    	jne    acc2 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad56:	e9 4c 05 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    ad5b:	8b 45 14             	mov    0x14(%ebp),%eax
    ad5e:	8b 40 04             	mov    0x4(%eax),%eax
    ad61:	ba 01 00 00 00       	mov    $0x1,%edx
    ad66:	89 c1                	mov    %eax,%ecx
    ad68:	d3 e2                	shl    %cl,%edx
    ad6a:	89 d0                	mov    %edx,%eax
    ad6c:	83 e8 01             	sub    $0x1,%eax
    ad6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ad72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad79:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad80:	eb 79                	jmp    adfb <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ad82:	8b 45 14             	mov    0x14(%ebp),%eax
    ad85:	8b 40 04             	mov    0x4(%eax),%eax
    ad88:	50                   	push   %eax
    ad89:	ff 75 10             	pushl  0x10(%ebp)
    ad8c:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ad8f:	50                   	push   %eax
    ad90:	e8 c0 d4 ff ff       	call   8255 <readBitsFromReversedStream>
    ad95:	83 c4 0c             	add    $0xc,%esp
    ad98:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ad9b:	8b 45 08             	mov    0x8(%ebp),%eax
    ad9e:	8d 48 01             	lea    0x1(%eax),%ecx
    ada1:	8b 45 08             	mov    0x8(%ebp),%eax
    ada4:	8d 58 02             	lea    0x2(%eax),%ebx
    ada7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    adaa:	89 d0                	mov    %edx,%eax
    adac:	c1 e0 08             	shl    $0x8,%eax
    adaf:	29 d0                	sub    %edx,%eax
    adb1:	ba 00 00 00 00       	mov    $0x0,%edx
    adb6:	f7 75 f0             	divl   -0x10(%ebp)
    adb9:	88 03                	mov    %al,(%ebx)
    adbb:	0f b6 03             	movzbl (%ebx),%eax
    adbe:	88 01                	mov    %al,(%ecx)
    adc0:	0f b6 11             	movzbl (%ecx),%edx
    adc3:	8b 45 08             	mov    0x8(%ebp),%eax
    adc6:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    adc8:	8b 45 08             	mov    0x8(%ebp),%eax
    adcb:	8d 50 03             	lea    0x3(%eax),%edx
    adce:	8b 45 14             	mov    0x14(%ebp),%eax
    add1:	8b 40 10             	mov    0x10(%eax),%eax
    add4:	85 c0                	test   %eax,%eax
    add6:	74 12                	je     adea <getPixelColorsRGBA8+0x20d>
    add8:	8b 45 14             	mov    0x14(%ebp),%eax
    addb:	8b 40 14             	mov    0x14(%eax),%eax
    adde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ade1:	75 07                	jne    adea <getPixelColorsRGBA8+0x20d>
    ade3:	b8 00 00 00 00       	mov    $0x0,%eax
    ade8:	eb 05                	jmp    adef <getPixelColorsRGBA8+0x212>
    adea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    adef:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adf1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    adf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    adf8:	01 45 08             	add    %eax,0x8(%ebp)
    adfb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    adfe:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae01:	0f 85 7b ff ff ff    	jne    ad82 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae07:	e9 9b 04 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ae0c:	8b 45 14             	mov    0x14(%ebp),%eax
    ae0f:	8b 00                	mov    (%eax),%eax
    ae11:	83 f8 02             	cmp    $0x2,%eax
    ae14:	0f 85 41 02 00 00    	jne    b05b <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ae1a:	8b 45 14             	mov    0x14(%ebp),%eax
    ae1d:	8b 40 04             	mov    0x4(%eax),%eax
    ae20:	83 f8 08             	cmp    $0x8,%eax
    ae23:	0f 85 c4 00 00 00    	jne    aeed <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae29:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae30:	eb 31                	jmp    ae63 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    ae32:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae35:	89 d0                	mov    %edx,%eax
    ae37:	01 c0                	add    %eax,%eax
    ae39:	01 d0                	add    %edx,%eax
    ae3b:	89 c2                	mov    %eax,%edx
    ae3d:	8b 45 10             	mov    0x10(%ebp),%eax
    ae40:	01 d0                	add    %edx,%eax
    ae42:	6a 03                	push   $0x3
    ae44:	50                   	push   %eax
    ae45:	ff 75 08             	pushl  0x8(%ebp)
    ae48:	e8 a3 85 ff ff       	call   33f0 <lodepng_memcpy>
    ae4d:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    ae50:	8b 45 08             	mov    0x8(%ebp),%eax
    ae53:	83 c0 03             	add    $0x3,%eax
    ae56:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae59:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae60:	01 45 08             	add    %eax,0x8(%ebp)
    ae63:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae66:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae69:	75 c7                	jne    ae32 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ae6b:	8b 45 14             	mov    0x14(%ebp),%eax
    ae6e:	8b 40 10             	mov    0x10(%eax),%eax
    ae71:	85 c0                	test   %eax,%eax
    ae73:	0f 84 2e 04 00 00    	je     b2a7 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ae79:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae7c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ae80:	f7 d8                	neg    %eax
    ae82:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae85:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae8c:	eb 52                	jmp    aee0 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    ae8e:	8b 45 08             	mov    0x8(%ebp),%eax
    ae91:	0f b6 00             	movzbl (%eax),%eax
    ae94:	0f b6 d0             	movzbl %al,%edx
    ae97:	8b 45 14             	mov    0x14(%ebp),%eax
    ae9a:	8b 40 14             	mov    0x14(%eax),%eax
    ae9d:	39 c2                	cmp    %eax,%edx
    ae9f:	75 35                	jne    aed6 <getPixelColorsRGBA8+0x2f9>
    aea1:	8b 45 08             	mov    0x8(%ebp),%eax
    aea4:	83 c0 01             	add    $0x1,%eax
    aea7:	0f b6 00             	movzbl (%eax),%eax
    aeaa:	0f b6 d0             	movzbl %al,%edx
    aead:	8b 45 14             	mov    0x14(%ebp),%eax
    aeb0:	8b 40 18             	mov    0x18(%eax),%eax
    aeb3:	39 c2                	cmp    %eax,%edx
    aeb5:	75 1f                	jne    aed6 <getPixelColorsRGBA8+0x2f9>
    aeb7:	8b 45 08             	mov    0x8(%ebp),%eax
    aeba:	83 c0 02             	add    $0x2,%eax
    aebd:	0f b6 00             	movzbl (%eax),%eax
    aec0:	0f b6 d0             	movzbl %al,%edx
    aec3:	8b 45 14             	mov    0x14(%ebp),%eax
    aec6:	8b 40 1c             	mov    0x1c(%eax),%eax
    aec9:	39 c2                	cmp    %eax,%edx
    aecb:	75 09                	jne    aed6 <getPixelColorsRGBA8+0x2f9>
    aecd:	8b 45 08             	mov    0x8(%ebp),%eax
    aed0:	83 c0 03             	add    $0x3,%eax
    aed3:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aed6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aeda:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aedd:	01 45 08             	add    %eax,0x8(%ebp)
    aee0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aee3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aee6:	75 a6                	jne    ae8e <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    aee8:	e9 ba 03 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aeed:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    aef4:	e9 51 01 00 00       	jmp    b04a <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    aef9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aefc:	89 d0                	mov    %edx,%eax
    aefe:	01 c0                	add    %eax,%eax
    af00:	01 d0                	add    %edx,%eax
    af02:	01 c0                	add    %eax,%eax
    af04:	89 c2                	mov    %eax,%edx
    af06:	8b 45 10             	mov    0x10(%ebp),%eax
    af09:	01 d0                	add    %edx,%eax
    af0b:	0f b6 10             	movzbl (%eax),%edx
    af0e:	8b 45 08             	mov    0x8(%ebp),%eax
    af11:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    af13:	8b 45 08             	mov    0x8(%ebp),%eax
    af16:	8d 48 01             	lea    0x1(%eax),%ecx
    af19:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af1c:	89 d0                	mov    %edx,%eax
    af1e:	01 c0                	add    %eax,%eax
    af20:	01 d0                	add    %edx,%eax
    af22:	01 c0                	add    %eax,%eax
    af24:	8d 50 02             	lea    0x2(%eax),%edx
    af27:	8b 45 10             	mov    0x10(%ebp),%eax
    af2a:	01 d0                	add    %edx,%eax
    af2c:	0f b6 00             	movzbl (%eax),%eax
    af2f:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    af31:	8b 45 08             	mov    0x8(%ebp),%eax
    af34:	8d 48 02             	lea    0x2(%eax),%ecx
    af37:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af3a:	89 d0                	mov    %edx,%eax
    af3c:	01 c0                	add    %eax,%eax
    af3e:	01 d0                	add    %edx,%eax
    af40:	01 c0                	add    %eax,%eax
    af42:	8d 50 04             	lea    0x4(%eax),%edx
    af45:	8b 45 10             	mov    0x10(%ebp),%eax
    af48:	01 d0                	add    %edx,%eax
    af4a:	0f b6 00             	movzbl (%eax),%eax
    af4d:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    af4f:	8b 45 08             	mov    0x8(%ebp),%eax
    af52:	8d 48 03             	lea    0x3(%eax),%ecx
    af55:	8b 45 14             	mov    0x14(%ebp),%eax
    af58:	8b 40 10             	mov    0x10(%eax),%eax
    af5b:	85 c0                	test   %eax,%eax
    af5d:	0f 84 d6 00 00 00    	je     b039 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    af63:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af66:	89 d0                	mov    %edx,%eax
    af68:	01 c0                	add    %eax,%eax
    af6a:	01 d0                	add    %edx,%eax
    af6c:	01 c0                	add    %eax,%eax
    af6e:	89 c2                	mov    %eax,%edx
    af70:	8b 45 10             	mov    0x10(%ebp),%eax
    af73:	01 d0                	add    %edx,%eax
    af75:	0f b6 00             	movzbl (%eax),%eax
    af78:	0f b6 c0             	movzbl %al,%eax
    af7b:	c1 e0 08             	shl    $0x8,%eax
    af7e:	89 c3                	mov    %eax,%ebx
    af80:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af83:	89 d0                	mov    %edx,%eax
    af85:	01 c0                	add    %eax,%eax
    af87:	01 d0                	add    %edx,%eax
    af89:	01 c0                	add    %eax,%eax
    af8b:	8d 50 01             	lea    0x1(%eax),%edx
    af8e:	8b 45 10             	mov    0x10(%ebp),%eax
    af91:	01 d0                	add    %edx,%eax
    af93:	0f b6 00             	movzbl (%eax),%eax
    af96:	0f b6 c0             	movzbl %al,%eax
    af99:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af9c:	8b 45 14             	mov    0x14(%ebp),%eax
    af9f:	8b 40 14             	mov    0x14(%eax),%eax
    afa2:	39 c2                	cmp    %eax,%edx
    afa4:	0f 85 8f 00 00 00    	jne    b039 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    afaa:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afad:	89 d0                	mov    %edx,%eax
    afaf:	01 c0                	add    %eax,%eax
    afb1:	01 d0                	add    %edx,%eax
    afb3:	01 c0                	add    %eax,%eax
    afb5:	8d 50 02             	lea    0x2(%eax),%edx
    afb8:	8b 45 10             	mov    0x10(%ebp),%eax
    afbb:	01 d0                	add    %edx,%eax
    afbd:	0f b6 00             	movzbl (%eax),%eax
    afc0:	0f b6 c0             	movzbl %al,%eax
    afc3:	c1 e0 08             	shl    $0x8,%eax
    afc6:	89 c3                	mov    %eax,%ebx
    afc8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afcb:	89 d0                	mov    %edx,%eax
    afcd:	01 c0                	add    %eax,%eax
    afcf:	01 d0                	add    %edx,%eax
    afd1:	01 c0                	add    %eax,%eax
    afd3:	8d 50 03             	lea    0x3(%eax),%edx
    afd6:	8b 45 10             	mov    0x10(%ebp),%eax
    afd9:	01 d0                	add    %edx,%eax
    afdb:	0f b6 00             	movzbl (%eax),%eax
    afde:	0f b6 c0             	movzbl %al,%eax
    afe1:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    afe4:	8b 45 14             	mov    0x14(%ebp),%eax
    afe7:	8b 40 18             	mov    0x18(%eax),%eax
    afea:	39 c2                	cmp    %eax,%edx
    afec:	75 4b                	jne    b039 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    afee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aff1:	89 d0                	mov    %edx,%eax
    aff3:	01 c0                	add    %eax,%eax
    aff5:	01 d0                	add    %edx,%eax
    aff7:	01 c0                	add    %eax,%eax
    aff9:	8d 50 04             	lea    0x4(%eax),%edx
    affc:	8b 45 10             	mov    0x10(%ebp),%eax
    afff:	01 d0                	add    %edx,%eax
    b001:	0f b6 00             	movzbl (%eax),%eax
    b004:	0f b6 c0             	movzbl %al,%eax
    b007:	c1 e0 08             	shl    $0x8,%eax
    b00a:	89 c3                	mov    %eax,%ebx
    b00c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b00f:	89 d0                	mov    %edx,%eax
    b011:	01 c0                	add    %eax,%eax
    b013:	01 d0                	add    %edx,%eax
    b015:	01 c0                	add    %eax,%eax
    b017:	8d 50 05             	lea    0x5(%eax),%edx
    b01a:	8b 45 10             	mov    0x10(%ebp),%eax
    b01d:	01 d0                	add    %edx,%eax
    b01f:	0f b6 00             	movzbl (%eax),%eax
    b022:	0f b6 c0             	movzbl %al,%eax
    b025:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b028:	8b 45 14             	mov    0x14(%ebp),%eax
    b02b:	8b 40 1c             	mov    0x1c(%eax),%eax
    b02e:	39 c2                	cmp    %eax,%edx
    b030:	75 07                	jne    b039 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b032:	b8 00 00 00 00       	mov    $0x0,%eax
    b037:	eb 05                	jmp    b03e <getPixelColorsRGBA8+0x461>
    b039:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b03e:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b040:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b044:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b047:	01 45 08             	add    %eax,0x8(%ebp)
    b04a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b04d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b050:	0f 85 a3 fe ff ff    	jne    aef9 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b056:	e9 4c 02 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b05b:	8b 45 14             	mov    0x14(%ebp),%eax
    b05e:	8b 00                	mov    (%eax),%eax
    b060:	83 f8 03             	cmp    $0x3,%eax
    b063:	0f 85 b4 00 00 00    	jne    b11d <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b069:	8b 45 14             	mov    0x14(%ebp),%eax
    b06c:	8b 40 04             	mov    0x4(%eax),%eax
    b06f:	83 f8 08             	cmp    $0x8,%eax
    b072:	75 4d                	jne    b0c1 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b074:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b07b:	eb 37                	jmp    b0b4 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b07d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b080:	8b 45 10             	mov    0x10(%ebp),%eax
    b083:	01 d0                	add    %edx,%eax
    b085:	0f b6 00             	movzbl (%eax),%eax
    b088:	0f b6 c0             	movzbl %al,%eax
    b08b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b08e:	8b 45 14             	mov    0x14(%ebp),%eax
    b091:	8b 40 08             	mov    0x8(%eax),%eax
    b094:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b097:	c1 e2 02             	shl    $0x2,%edx
    b09a:	01 d0                	add    %edx,%eax
    b09c:	6a 04                	push   $0x4
    b09e:	50                   	push   %eax
    b09f:	ff 75 08             	pushl  0x8(%ebp)
    b0a2:	e8 49 83 ff ff       	call   33f0 <lodepng_memcpy>
    b0a7:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0aa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b0b1:	01 45 08             	add    %eax,0x8(%ebp)
    b0b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0b7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b0ba:	75 c1                	jne    b07d <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b0bc:	e9 e6 01 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b0c1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0c8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0cf:	eb 3f                	jmp    b110 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b0d1:	8b 45 14             	mov    0x14(%ebp),%eax
    b0d4:	8b 40 04             	mov    0x4(%eax),%eax
    b0d7:	50                   	push   %eax
    b0d8:	ff 75 10             	pushl  0x10(%ebp)
    b0db:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b0de:	50                   	push   %eax
    b0df:	e8 71 d1 ff ff       	call   8255 <readBitsFromReversedStream>
    b0e4:	83 c4 0c             	add    $0xc,%esp
    b0e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b0ea:	8b 45 14             	mov    0x14(%ebp),%eax
    b0ed:	8b 40 08             	mov    0x8(%eax),%eax
    b0f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b0f3:	c1 e2 02             	shl    $0x2,%edx
    b0f6:	01 d0                	add    %edx,%eax
    b0f8:	6a 04                	push   $0x4
    b0fa:	50                   	push   %eax
    b0fb:	ff 75 08             	pushl  0x8(%ebp)
    b0fe:	e8 ed 82 ff ff       	call   33f0 <lodepng_memcpy>
    b103:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b106:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b10a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b10d:	01 45 08             	add    %eax,0x8(%ebp)
    b110:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b113:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b116:	75 b9                	jne    b0d1 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b118:	e9 8a 01 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b11d:	8b 45 14             	mov    0x14(%ebp),%eax
    b120:	8b 00                	mov    (%eax),%eax
    b122:	83 f8 04             	cmp    $0x4,%eax
    b125:	0f 85 d1 00 00 00    	jne    b1fc <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b12b:	8b 45 14             	mov    0x14(%ebp),%eax
    b12e:	8b 40 04             	mov    0x4(%eax),%eax
    b131:	83 f8 08             	cmp    $0x8,%eax
    b134:	75 62                	jne    b198 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b136:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b13d:	eb 4c                	jmp    b18b <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b13f:	8b 45 08             	mov    0x8(%ebp),%eax
    b142:	83 c0 01             	add    $0x1,%eax
    b145:	8b 55 08             	mov    0x8(%ebp),%edx
    b148:	83 c2 02             	add    $0x2,%edx
    b14b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b14e:	01 c9                	add    %ecx,%ecx
    b150:	89 cb                	mov    %ecx,%ebx
    b152:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b155:	01 d9                	add    %ebx,%ecx
    b157:	0f b6 09             	movzbl (%ecx),%ecx
    b15a:	88 0a                	mov    %cl,(%edx)
    b15c:	0f b6 12             	movzbl (%edx),%edx
    b15f:	88 10                	mov    %dl,(%eax)
    b161:	0f b6 10             	movzbl (%eax),%edx
    b164:	8b 45 08             	mov    0x8(%ebp),%eax
    b167:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b169:	8b 45 08             	mov    0x8(%ebp),%eax
    b16c:	8d 50 03             	lea    0x3(%eax),%edx
    b16f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b172:	01 c0                	add    %eax,%eax
    b174:	8d 48 01             	lea    0x1(%eax),%ecx
    b177:	8b 45 10             	mov    0x10(%ebp),%eax
    b17a:	01 c8                	add    %ecx,%eax
    b17c:	0f b6 00             	movzbl (%eax),%eax
    b17f:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b181:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b185:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b188:	01 45 08             	add    %eax,0x8(%ebp)
    b18b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b18e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b191:	75 ac                	jne    b13f <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b193:	e9 0f 01 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b198:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b19f:	eb 4e                	jmp    b1ef <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b1a1:	8b 45 08             	mov    0x8(%ebp),%eax
    b1a4:	83 c0 01             	add    $0x1,%eax
    b1a7:	8b 55 08             	mov    0x8(%ebp),%edx
    b1aa:	83 c2 02             	add    $0x2,%edx
    b1ad:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b1b0:	c1 e1 02             	shl    $0x2,%ecx
    b1b3:	89 cb                	mov    %ecx,%ebx
    b1b5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b1b8:	01 d9                	add    %ebx,%ecx
    b1ba:	0f b6 09             	movzbl (%ecx),%ecx
    b1bd:	88 0a                	mov    %cl,(%edx)
    b1bf:	0f b6 12             	movzbl (%edx),%edx
    b1c2:	88 10                	mov    %dl,(%eax)
    b1c4:	0f b6 10             	movzbl (%eax),%edx
    b1c7:	8b 45 08             	mov    0x8(%ebp),%eax
    b1ca:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b1cc:	8b 45 08             	mov    0x8(%ebp),%eax
    b1cf:	8d 50 03             	lea    0x3(%eax),%edx
    b1d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1d5:	c1 e0 02             	shl    $0x2,%eax
    b1d8:	8d 48 02             	lea    0x2(%eax),%ecx
    b1db:	8b 45 10             	mov    0x10(%ebp),%eax
    b1de:	01 c8                	add    %ecx,%eax
    b1e0:	0f b6 00             	movzbl (%eax),%eax
    b1e3:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1e5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b1e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b1ec:	01 45 08             	add    %eax,0x8(%ebp)
    b1ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1f2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b1f5:	75 aa                	jne    b1a1 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b1f7:	e9 ab 00 00 00       	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b1fc:	8b 45 14             	mov    0x14(%ebp),%eax
    b1ff:	8b 00                	mov    (%eax),%eax
    b201:	83 f8 06             	cmp    $0x6,%eax
    b204:	0f 85 9d 00 00 00    	jne    b2a7 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b20a:	8b 45 14             	mov    0x14(%ebp),%eax
    b20d:	8b 40 04             	mov    0x4(%eax),%eax
    b210:	83 f8 08             	cmp    $0x8,%eax
    b213:	75 17                	jne    b22c <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b215:	8b 45 0c             	mov    0xc(%ebp),%eax
    b218:	c1 e0 02             	shl    $0x2,%eax
    b21b:	50                   	push   %eax
    b21c:	ff 75 10             	pushl  0x10(%ebp)
    b21f:	ff 75 08             	pushl  0x8(%ebp)
    b222:	e8 c9 81 ff ff       	call   33f0 <lodepng_memcpy>
    b227:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b22a:	eb 7b                	jmp    b2a7 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b22c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b233:	eb 6a                	jmp    b29f <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b235:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b238:	c1 e0 03             	shl    $0x3,%eax
    b23b:	89 c2                	mov    %eax,%edx
    b23d:	8b 45 10             	mov    0x10(%ebp),%eax
    b240:	01 d0                	add    %edx,%eax
    b242:	0f b6 10             	movzbl (%eax),%edx
    b245:	8b 45 08             	mov    0x8(%ebp),%eax
    b248:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b24a:	8b 45 08             	mov    0x8(%ebp),%eax
    b24d:	8d 50 01             	lea    0x1(%eax),%edx
    b250:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b253:	c1 e0 03             	shl    $0x3,%eax
    b256:	8d 48 02             	lea    0x2(%eax),%ecx
    b259:	8b 45 10             	mov    0x10(%ebp),%eax
    b25c:	01 c8                	add    %ecx,%eax
    b25e:	0f b6 00             	movzbl (%eax),%eax
    b261:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b263:	8b 45 08             	mov    0x8(%ebp),%eax
    b266:	8d 50 02             	lea    0x2(%eax),%edx
    b269:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b26c:	c1 e0 03             	shl    $0x3,%eax
    b26f:	8d 48 04             	lea    0x4(%eax),%ecx
    b272:	8b 45 10             	mov    0x10(%ebp),%eax
    b275:	01 c8                	add    %ecx,%eax
    b277:	0f b6 00             	movzbl (%eax),%eax
    b27a:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b27c:	8b 45 08             	mov    0x8(%ebp),%eax
    b27f:	8d 50 03             	lea    0x3(%eax),%edx
    b282:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b285:	c1 e0 03             	shl    $0x3,%eax
    b288:	8d 48 06             	lea    0x6(%eax),%ecx
    b28b:	8b 45 10             	mov    0x10(%ebp),%eax
    b28e:	01 c8                	add    %ecx,%eax
    b290:	0f b6 00             	movzbl (%eax),%eax
    b293:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b295:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b299:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b29c:	01 45 08             	add    %eax,0x8(%ebp)
    b29f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2a2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2a5:	75 8e                	jne    b235 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b2a7:	90                   	nop
    b2a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b2ab:	c9                   	leave  
    b2ac:	c3                   	ret    

0000b2ad <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b2ad:	55                   	push   %ebp
    b2ae:	89 e5                	mov    %esp,%ebp
    b2b0:	53                   	push   %ebx
    b2b1:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b2b4:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b2bb:	8b 45 14             	mov    0x14(%ebp),%eax
    b2be:	8b 00                	mov    (%eax),%eax
    b2c0:	85 c0                	test   %eax,%eax
    b2c2:	0f 85 2a 01 00 00    	jne    b3f2 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b2c8:	8b 45 14             	mov    0x14(%ebp),%eax
    b2cb:	8b 40 04             	mov    0x4(%eax),%eax
    b2ce:	83 f8 08             	cmp    $0x8,%eax
    b2d1:	75 46                	jne    b319 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2d3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2da:	eb 30                	jmp    b30c <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b2dc:	8b 45 08             	mov    0x8(%ebp),%eax
    b2df:	83 c0 01             	add    $0x1,%eax
    b2e2:	8b 55 08             	mov    0x8(%ebp),%edx
    b2e5:	83 c2 02             	add    $0x2,%edx
    b2e8:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b2eb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b2ee:	01 d9                	add    %ebx,%ecx
    b2f0:	0f b6 09             	movzbl (%ecx),%ecx
    b2f3:	88 0a                	mov    %cl,(%edx)
    b2f5:	0f b6 12             	movzbl (%edx),%edx
    b2f8:	88 10                	mov    %dl,(%eax)
    b2fa:	0f b6 10             	movzbl (%eax),%edx
    b2fd:	8b 45 08             	mov    0x8(%ebp),%eax
    b300:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b302:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b306:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b309:	01 45 08             	add    %eax,0x8(%ebp)
    b30c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b30f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b312:	75 c8                	jne    b2dc <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b314:	e9 a8 03 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b319:	8b 45 14             	mov    0x14(%ebp),%eax
    b31c:	8b 40 04             	mov    0x4(%eax),%eax
    b31f:	83 f8 10             	cmp    $0x10,%eax
    b322:	75 4a                	jne    b36e <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b324:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b32b:	eb 34                	jmp    b361 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b32d:	8b 45 08             	mov    0x8(%ebp),%eax
    b330:	83 c0 01             	add    $0x1,%eax
    b333:	8b 55 08             	mov    0x8(%ebp),%edx
    b336:	83 c2 02             	add    $0x2,%edx
    b339:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b33c:	01 c9                	add    %ecx,%ecx
    b33e:	89 cb                	mov    %ecx,%ebx
    b340:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b343:	01 d9                	add    %ebx,%ecx
    b345:	0f b6 09             	movzbl (%ecx),%ecx
    b348:	88 0a                	mov    %cl,(%edx)
    b34a:	0f b6 12             	movzbl (%edx),%edx
    b34d:	88 10                	mov    %dl,(%eax)
    b34f:	0f b6 10             	movzbl (%eax),%edx
    b352:	8b 45 08             	mov    0x8(%ebp),%eax
    b355:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b357:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b35b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b35e:	01 45 08             	add    %eax,0x8(%ebp)
    b361:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b364:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b367:	75 c4                	jne    b32d <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b369:	e9 53 03 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b36e:	8b 45 14             	mov    0x14(%ebp),%eax
    b371:	8b 40 04             	mov    0x4(%eax),%eax
    b374:	ba 01 00 00 00       	mov    $0x1,%edx
    b379:	89 c1                	mov    %eax,%ecx
    b37b:	d3 e2                	shl    %cl,%edx
    b37d:	89 d0                	mov    %edx,%eax
    b37f:	83 e8 01             	sub    $0x1,%eax
    b382:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b385:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b38c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b393:	eb 50                	jmp    b3e5 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b395:	8b 45 14             	mov    0x14(%ebp),%eax
    b398:	8b 40 04             	mov    0x4(%eax),%eax
    b39b:	50                   	push   %eax
    b39c:	ff 75 10             	pushl  0x10(%ebp)
    b39f:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b3a2:	50                   	push   %eax
    b3a3:	e8 ad ce ff ff       	call   8255 <readBitsFromReversedStream>
    b3a8:	83 c4 0c             	add    $0xc,%esp
    b3ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b3ae:	8b 45 08             	mov    0x8(%ebp),%eax
    b3b1:	8d 48 01             	lea    0x1(%eax),%ecx
    b3b4:	8b 45 08             	mov    0x8(%ebp),%eax
    b3b7:	8d 58 02             	lea    0x2(%eax),%ebx
    b3ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b3bd:	89 d0                	mov    %edx,%eax
    b3bf:	c1 e0 08             	shl    $0x8,%eax
    b3c2:	29 d0                	sub    %edx,%eax
    b3c4:	ba 00 00 00 00       	mov    $0x0,%edx
    b3c9:	f7 75 f0             	divl   -0x10(%ebp)
    b3cc:	88 03                	mov    %al,(%ebx)
    b3ce:	0f b6 03             	movzbl (%ebx),%eax
    b3d1:	88 01                	mov    %al,(%ecx)
    b3d3:	0f b6 11             	movzbl (%ecx),%edx
    b3d6:	8b 45 08             	mov    0x8(%ebp),%eax
    b3d9:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3db:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3e2:	01 45 08             	add    %eax,0x8(%ebp)
    b3e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3e8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3eb:	75 a8                	jne    b395 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b3ed:	e9 cf 02 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b3f2:	8b 45 14             	mov    0x14(%ebp),%eax
    b3f5:	8b 00                	mov    (%eax),%eax
    b3f7:	83 f8 02             	cmp    $0x2,%eax
    b3fa:	0f 85 9e 00 00 00    	jne    b49e <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b400:	8b 45 14             	mov    0x14(%ebp),%eax
    b403:	8b 40 04             	mov    0x4(%eax),%eax
    b406:	83 f8 08             	cmp    $0x8,%eax
    b409:	75 1d                	jne    b428 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b40b:	8b 55 0c             	mov    0xc(%ebp),%edx
    b40e:	89 d0                	mov    %edx,%eax
    b410:	01 c0                	add    %eax,%eax
    b412:	01 d0                	add    %edx,%eax
    b414:	50                   	push   %eax
    b415:	ff 75 10             	pushl  0x10(%ebp)
    b418:	ff 75 08             	pushl  0x8(%ebp)
    b41b:	e8 d0 7f ff ff       	call   33f0 <lodepng_memcpy>
    b420:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b423:	e9 99 02 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b428:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b42f:	eb 60                	jmp    b491 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b431:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b434:	89 d0                	mov    %edx,%eax
    b436:	01 c0                	add    %eax,%eax
    b438:	01 d0                	add    %edx,%eax
    b43a:	01 c0                	add    %eax,%eax
    b43c:	89 c2                	mov    %eax,%edx
    b43e:	8b 45 10             	mov    0x10(%ebp),%eax
    b441:	01 d0                	add    %edx,%eax
    b443:	0f b6 10             	movzbl (%eax),%edx
    b446:	8b 45 08             	mov    0x8(%ebp),%eax
    b449:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b44b:	8b 45 08             	mov    0x8(%ebp),%eax
    b44e:	8d 48 01             	lea    0x1(%eax),%ecx
    b451:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b454:	89 d0                	mov    %edx,%eax
    b456:	01 c0                	add    %eax,%eax
    b458:	01 d0                	add    %edx,%eax
    b45a:	01 c0                	add    %eax,%eax
    b45c:	8d 50 02             	lea    0x2(%eax),%edx
    b45f:	8b 45 10             	mov    0x10(%ebp),%eax
    b462:	01 d0                	add    %edx,%eax
    b464:	0f b6 00             	movzbl (%eax),%eax
    b467:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b469:	8b 45 08             	mov    0x8(%ebp),%eax
    b46c:	8d 48 02             	lea    0x2(%eax),%ecx
    b46f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b472:	89 d0                	mov    %edx,%eax
    b474:	01 c0                	add    %eax,%eax
    b476:	01 d0                	add    %edx,%eax
    b478:	01 c0                	add    %eax,%eax
    b47a:	8d 50 04             	lea    0x4(%eax),%edx
    b47d:	8b 45 10             	mov    0x10(%ebp),%eax
    b480:	01 d0                	add    %edx,%eax
    b482:	0f b6 00             	movzbl (%eax),%eax
    b485:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b487:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b48b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b48e:	01 45 08             	add    %eax,0x8(%ebp)
    b491:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b494:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b497:	75 98                	jne    b431 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b499:	e9 23 02 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b49e:	8b 45 14             	mov    0x14(%ebp),%eax
    b4a1:	8b 00                	mov    (%eax),%eax
    b4a3:	83 f8 03             	cmp    $0x3,%eax
    b4a6:	0f 85 b4 00 00 00    	jne    b560 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b4ac:	8b 45 14             	mov    0x14(%ebp),%eax
    b4af:	8b 40 04             	mov    0x4(%eax),%eax
    b4b2:	83 f8 08             	cmp    $0x8,%eax
    b4b5:	75 4d                	jne    b504 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4be:	eb 37                	jmp    b4f7 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b4c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4c3:	8b 45 10             	mov    0x10(%ebp),%eax
    b4c6:	01 d0                	add    %edx,%eax
    b4c8:	0f b6 00             	movzbl (%eax),%eax
    b4cb:	0f b6 c0             	movzbl %al,%eax
    b4ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b4d1:	8b 45 14             	mov    0x14(%ebp),%eax
    b4d4:	8b 40 08             	mov    0x8(%eax),%eax
    b4d7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b4da:	c1 e2 02             	shl    $0x2,%edx
    b4dd:	01 d0                	add    %edx,%eax
    b4df:	6a 03                	push   $0x3
    b4e1:	50                   	push   %eax
    b4e2:	ff 75 08             	pushl  0x8(%ebp)
    b4e5:	e8 06 7f ff ff       	call   33f0 <lodepng_memcpy>
    b4ea:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4ed:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4f4:	01 45 08             	add    %eax,0x8(%ebp)
    b4f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4fa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4fd:	75 c1                	jne    b4c0 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4ff:	e9 bd 01 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b504:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b50b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b512:	eb 3f                	jmp    b553 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b514:	8b 45 14             	mov    0x14(%ebp),%eax
    b517:	8b 40 04             	mov    0x4(%eax),%eax
    b51a:	50                   	push   %eax
    b51b:	ff 75 10             	pushl  0x10(%ebp)
    b51e:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b521:	50                   	push   %eax
    b522:	e8 2e cd ff ff       	call   8255 <readBitsFromReversedStream>
    b527:	83 c4 0c             	add    $0xc,%esp
    b52a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b52d:	8b 45 14             	mov    0x14(%ebp),%eax
    b530:	8b 40 08             	mov    0x8(%eax),%eax
    b533:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b536:	c1 e2 02             	shl    $0x2,%edx
    b539:	01 d0                	add    %edx,%eax
    b53b:	6a 03                	push   $0x3
    b53d:	50                   	push   %eax
    b53e:	ff 75 08             	pushl  0x8(%ebp)
    b541:	e8 aa 7e ff ff       	call   33f0 <lodepng_memcpy>
    b546:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b549:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b54d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b550:	01 45 08             	add    %eax,0x8(%ebp)
    b553:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b556:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b559:	75 b9                	jne    b514 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b55b:	e9 61 01 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b560:	8b 45 14             	mov    0x14(%ebp),%eax
    b563:	8b 00                	mov    (%eax),%eax
    b565:	83 f8 04             	cmp    $0x4,%eax
    b568:	0f 85 a0 00 00 00    	jne    b60e <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b56e:	8b 45 14             	mov    0x14(%ebp),%eax
    b571:	8b 40 04             	mov    0x4(%eax),%eax
    b574:	83 f8 08             	cmp    $0x8,%eax
    b577:	75 4a                	jne    b5c3 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b579:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b580:	eb 34                	jmp    b5b6 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b582:	8b 45 08             	mov    0x8(%ebp),%eax
    b585:	83 c0 01             	add    $0x1,%eax
    b588:	8b 55 08             	mov    0x8(%ebp),%edx
    b58b:	83 c2 02             	add    $0x2,%edx
    b58e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b591:	01 c9                	add    %ecx,%ecx
    b593:	89 cb                	mov    %ecx,%ebx
    b595:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b598:	01 d9                	add    %ebx,%ecx
    b59a:	0f b6 09             	movzbl (%ecx),%ecx
    b59d:	88 0a                	mov    %cl,(%edx)
    b59f:	0f b6 12             	movzbl (%edx),%edx
    b5a2:	88 10                	mov    %dl,(%eax)
    b5a4:	0f b6 10             	movzbl (%eax),%edx
    b5a7:	8b 45 08             	mov    0x8(%ebp),%eax
    b5aa:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5ac:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5b3:	01 45 08             	add    %eax,0x8(%ebp)
    b5b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5b9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5bc:	75 c4                	jne    b582 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5be:	e9 fe 00 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5ca:	eb 35                	jmp    b601 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b5cc:	8b 45 08             	mov    0x8(%ebp),%eax
    b5cf:	83 c0 01             	add    $0x1,%eax
    b5d2:	8b 55 08             	mov    0x8(%ebp),%edx
    b5d5:	83 c2 02             	add    $0x2,%edx
    b5d8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b5db:	c1 e1 02             	shl    $0x2,%ecx
    b5de:	89 cb                	mov    %ecx,%ebx
    b5e0:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b5e3:	01 d9                	add    %ebx,%ecx
    b5e5:	0f b6 09             	movzbl (%ecx),%ecx
    b5e8:	88 0a                	mov    %cl,(%edx)
    b5ea:	0f b6 12             	movzbl (%edx),%edx
    b5ed:	88 10                	mov    %dl,(%eax)
    b5ef:	0f b6 10             	movzbl (%eax),%edx
    b5f2:	8b 45 08             	mov    0x8(%ebp),%eax
    b5f5:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5f7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5fe:	01 45 08             	add    %eax,0x8(%ebp)
    b601:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b604:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b607:	75 c3                	jne    b5cc <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b609:	e9 b3 00 00 00       	jmp    b6c1 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b60e:	8b 45 14             	mov    0x14(%ebp),%eax
    b611:	8b 00                	mov    (%eax),%eax
    b613:	83 f8 06             	cmp    $0x6,%eax
    b616:	0f 85 a5 00 00 00    	jne    b6c1 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b61c:	8b 45 14             	mov    0x14(%ebp),%eax
    b61f:	8b 40 04             	mov    0x4(%eax),%eax
    b622:	83 f8 08             	cmp    $0x8,%eax
    b625:	75 38                	jne    b65f <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b627:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b62e:	eb 25                	jmp    b655 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b630:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b633:	c1 e0 02             	shl    $0x2,%eax
    b636:	89 c2                	mov    %eax,%edx
    b638:	8b 45 10             	mov    0x10(%ebp),%eax
    b63b:	01 d0                	add    %edx,%eax
    b63d:	6a 03                	push   $0x3
    b63f:	50                   	push   %eax
    b640:	ff 75 08             	pushl  0x8(%ebp)
    b643:	e8 a8 7d ff ff       	call   33f0 <lodepng_memcpy>
    b648:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b64b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b64f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b652:	01 45 08             	add    %eax,0x8(%ebp)
    b655:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b658:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b65b:	75 d3                	jne    b630 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b65d:	eb 62                	jmp    b6c1 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b65f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b666:	eb 51                	jmp    b6b9 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b668:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b66b:	c1 e0 03             	shl    $0x3,%eax
    b66e:	89 c2                	mov    %eax,%edx
    b670:	8b 45 10             	mov    0x10(%ebp),%eax
    b673:	01 d0                	add    %edx,%eax
    b675:	0f b6 10             	movzbl (%eax),%edx
    b678:	8b 45 08             	mov    0x8(%ebp),%eax
    b67b:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b67d:	8b 45 08             	mov    0x8(%ebp),%eax
    b680:	8d 50 01             	lea    0x1(%eax),%edx
    b683:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b686:	c1 e0 03             	shl    $0x3,%eax
    b689:	8d 48 02             	lea    0x2(%eax),%ecx
    b68c:	8b 45 10             	mov    0x10(%ebp),%eax
    b68f:	01 c8                	add    %ecx,%eax
    b691:	0f b6 00             	movzbl (%eax),%eax
    b694:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b696:	8b 45 08             	mov    0x8(%ebp),%eax
    b699:	8d 50 02             	lea    0x2(%eax),%edx
    b69c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b69f:	c1 e0 03             	shl    $0x3,%eax
    b6a2:	8d 48 04             	lea    0x4(%eax),%ecx
    b6a5:	8b 45 10             	mov    0x10(%ebp),%eax
    b6a8:	01 c8                	add    %ecx,%eax
    b6aa:	0f b6 00             	movzbl (%eax),%eax
    b6ad:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6af:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6b6:	01 45 08             	add    %eax,0x8(%ebp)
    b6b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6bc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6bf:	75 a7                	jne    b668 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b6c1:	90                   	nop
    b6c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b6c5:	c9                   	leave  
    b6c6:	c3                   	ret    

0000b6c7 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b6c7:	55                   	push   %ebp
    b6c8:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b6ca:	8b 45 20             	mov    0x20(%ebp),%eax
    b6cd:	8b 00                	mov    (%eax),%eax
    b6cf:	85 c0                	test   %eax,%eax
    b6d1:	0f 85 a4 00 00 00    	jne    b77b <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b6d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6da:	01 c0                	add    %eax,%eax
    b6dc:	89 c2                	mov    %eax,%edx
    b6de:	8b 45 18             	mov    0x18(%ebp),%eax
    b6e1:	01 d0                	add    %edx,%eax
    b6e3:	0f b6 00             	movzbl (%eax),%eax
    b6e6:	0f b6 c0             	movzbl %al,%eax
    b6e9:	c1 e0 08             	shl    $0x8,%eax
    b6ec:	89 c2                	mov    %eax,%edx
    b6ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6f1:	01 c0                	add    %eax,%eax
    b6f3:	8d 48 01             	lea    0x1(%eax),%ecx
    b6f6:	8b 45 18             	mov    0x18(%ebp),%eax
    b6f9:	01 c8                	add    %ecx,%eax
    b6fb:	0f b6 00             	movzbl (%eax),%eax
    b6fe:	0f b6 c0             	movzbl %al,%eax
    b701:	01 c2                	add    %eax,%edx
    b703:	8b 45 10             	mov    0x10(%ebp),%eax
    b706:	66 89 10             	mov    %dx,(%eax)
    b709:	8b 45 10             	mov    0x10(%ebp),%eax
    b70c:	0f b7 10             	movzwl (%eax),%edx
    b70f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b712:	66 89 10             	mov    %dx,(%eax)
    b715:	8b 45 0c             	mov    0xc(%ebp),%eax
    b718:	0f b7 10             	movzwl (%eax),%edx
    b71b:	8b 45 08             	mov    0x8(%ebp),%eax
    b71e:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b721:	8b 45 20             	mov    0x20(%ebp),%eax
    b724:	8b 40 10             	mov    0x10(%eax),%eax
    b727:	85 c0                	test   %eax,%eax
    b729:	74 43                	je     b76e <getPixelColorRGBA16+0xa7>
    b72b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b72e:	01 c0                	add    %eax,%eax
    b730:	89 c2                	mov    %eax,%edx
    b732:	8b 45 18             	mov    0x18(%ebp),%eax
    b735:	01 d0                	add    %edx,%eax
    b737:	0f b6 00             	movzbl (%eax),%eax
    b73a:	0f b6 c0             	movzbl %al,%eax
    b73d:	c1 e0 08             	shl    $0x8,%eax
    b740:	89 c2                	mov    %eax,%edx
    b742:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b745:	01 c0                	add    %eax,%eax
    b747:	8d 48 01             	lea    0x1(%eax),%ecx
    b74a:	8b 45 18             	mov    0x18(%ebp),%eax
    b74d:	01 c8                	add    %ecx,%eax
    b74f:	0f b6 00             	movzbl (%eax),%eax
    b752:	0f b6 c0             	movzbl %al,%eax
    b755:	01 c2                	add    %eax,%edx
    b757:	8b 45 20             	mov    0x20(%ebp),%eax
    b75a:	8b 40 14             	mov    0x14(%eax),%eax
    b75d:	39 c2                	cmp    %eax,%edx
    b75f:	75 0d                	jne    b76e <getPixelColorRGBA16+0xa7>
    b761:	8b 45 14             	mov    0x14(%ebp),%eax
    b764:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b769:	e9 48 03 00 00       	jmp    bab6 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b76e:	8b 45 14             	mov    0x14(%ebp),%eax
    b771:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b776:	e9 3b 03 00 00       	jmp    bab6 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b77b:	8b 45 20             	mov    0x20(%ebp),%eax
    b77e:	8b 00                	mov    (%eax),%eax
    b780:	83 f8 02             	cmp    $0x2,%eax
    b783:	0f 85 b6 01 00 00    	jne    b93f <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b789:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b78c:	89 d0                	mov    %edx,%eax
    b78e:	01 c0                	add    %eax,%eax
    b790:	01 d0                	add    %edx,%eax
    b792:	01 c0                	add    %eax,%eax
    b794:	89 c2                	mov    %eax,%edx
    b796:	8b 45 18             	mov    0x18(%ebp),%eax
    b799:	01 d0                	add    %edx,%eax
    b79b:	0f b6 00             	movzbl (%eax),%eax
    b79e:	0f b6 c0             	movzbl %al,%eax
    b7a1:	c1 e0 08             	shl    $0x8,%eax
    b7a4:	89 c1                	mov    %eax,%ecx
    b7a6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7a9:	89 d0                	mov    %edx,%eax
    b7ab:	01 c0                	add    %eax,%eax
    b7ad:	01 d0                	add    %edx,%eax
    b7af:	01 c0                	add    %eax,%eax
    b7b1:	8d 50 01             	lea    0x1(%eax),%edx
    b7b4:	8b 45 18             	mov    0x18(%ebp),%eax
    b7b7:	01 d0                	add    %edx,%eax
    b7b9:	0f b6 00             	movzbl (%eax),%eax
    b7bc:	0f b6 c0             	movzbl %al,%eax
    b7bf:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7c2:	8b 45 08             	mov    0x8(%ebp),%eax
    b7c5:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b7c8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7cb:	89 d0                	mov    %edx,%eax
    b7cd:	01 c0                	add    %eax,%eax
    b7cf:	01 d0                	add    %edx,%eax
    b7d1:	01 c0                	add    %eax,%eax
    b7d3:	8d 50 02             	lea    0x2(%eax),%edx
    b7d6:	8b 45 18             	mov    0x18(%ebp),%eax
    b7d9:	01 d0                	add    %edx,%eax
    b7db:	0f b6 00             	movzbl (%eax),%eax
    b7de:	0f b6 c0             	movzbl %al,%eax
    b7e1:	c1 e0 08             	shl    $0x8,%eax
    b7e4:	89 c1                	mov    %eax,%ecx
    b7e6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7e9:	89 d0                	mov    %edx,%eax
    b7eb:	01 c0                	add    %eax,%eax
    b7ed:	01 d0                	add    %edx,%eax
    b7ef:	01 c0                	add    %eax,%eax
    b7f1:	8d 50 03             	lea    0x3(%eax),%edx
    b7f4:	8b 45 18             	mov    0x18(%ebp),%eax
    b7f7:	01 d0                	add    %edx,%eax
    b7f9:	0f b6 00             	movzbl (%eax),%eax
    b7fc:	0f b6 c0             	movzbl %al,%eax
    b7ff:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b802:	8b 45 0c             	mov    0xc(%ebp),%eax
    b805:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b808:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b80b:	89 d0                	mov    %edx,%eax
    b80d:	01 c0                	add    %eax,%eax
    b80f:	01 d0                	add    %edx,%eax
    b811:	01 c0                	add    %eax,%eax
    b813:	8d 50 04             	lea    0x4(%eax),%edx
    b816:	8b 45 18             	mov    0x18(%ebp),%eax
    b819:	01 d0                	add    %edx,%eax
    b81b:	0f b6 00             	movzbl (%eax),%eax
    b81e:	0f b6 c0             	movzbl %al,%eax
    b821:	c1 e0 08             	shl    $0x8,%eax
    b824:	89 c1                	mov    %eax,%ecx
    b826:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b829:	89 d0                	mov    %edx,%eax
    b82b:	01 c0                	add    %eax,%eax
    b82d:	01 d0                	add    %edx,%eax
    b82f:	01 c0                	add    %eax,%eax
    b831:	8d 50 05             	lea    0x5(%eax),%edx
    b834:	8b 45 18             	mov    0x18(%ebp),%eax
    b837:	01 d0                	add    %edx,%eax
    b839:	0f b6 00             	movzbl (%eax),%eax
    b83c:	0f b6 c0             	movzbl %al,%eax
    b83f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b842:	8b 45 10             	mov    0x10(%ebp),%eax
    b845:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b848:	8b 45 20             	mov    0x20(%ebp),%eax
    b84b:	8b 40 10             	mov    0x10(%eax),%eax
    b84e:	85 c0                	test   %eax,%eax
    b850:	0f 84 dc 00 00 00    	je     b932 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b856:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b859:	89 d0                	mov    %edx,%eax
    b85b:	01 c0                	add    %eax,%eax
    b85d:	01 d0                	add    %edx,%eax
    b85f:	01 c0                	add    %eax,%eax
    b861:	89 c2                	mov    %eax,%edx
    b863:	8b 45 18             	mov    0x18(%ebp),%eax
    b866:	01 d0                	add    %edx,%eax
    b868:	0f b6 00             	movzbl (%eax),%eax
    b86b:	0f b6 c0             	movzbl %al,%eax
    b86e:	c1 e0 08             	shl    $0x8,%eax
    b871:	89 c1                	mov    %eax,%ecx
    b873:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b876:	89 d0                	mov    %edx,%eax
    b878:	01 c0                	add    %eax,%eax
    b87a:	01 d0                	add    %edx,%eax
    b87c:	01 c0                	add    %eax,%eax
    b87e:	8d 50 01             	lea    0x1(%eax),%edx
    b881:	8b 45 18             	mov    0x18(%ebp),%eax
    b884:	01 d0                	add    %edx,%eax
    b886:	0f b6 00             	movzbl (%eax),%eax
    b889:	0f b6 c0             	movzbl %al,%eax
    b88c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b88f:	8b 45 20             	mov    0x20(%ebp),%eax
    b892:	8b 40 14             	mov    0x14(%eax),%eax
    b895:	39 c2                	cmp    %eax,%edx
    b897:	0f 85 95 00 00 00    	jne    b932 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b89d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8a0:	89 d0                	mov    %edx,%eax
    b8a2:	01 c0                	add    %eax,%eax
    b8a4:	01 d0                	add    %edx,%eax
    b8a6:	01 c0                	add    %eax,%eax
    b8a8:	8d 50 02             	lea    0x2(%eax),%edx
    b8ab:	8b 45 18             	mov    0x18(%ebp),%eax
    b8ae:	01 d0                	add    %edx,%eax
    b8b0:	0f b6 00             	movzbl (%eax),%eax
    b8b3:	0f b6 c0             	movzbl %al,%eax
    b8b6:	c1 e0 08             	shl    $0x8,%eax
    b8b9:	89 c1                	mov    %eax,%ecx
    b8bb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8be:	89 d0                	mov    %edx,%eax
    b8c0:	01 c0                	add    %eax,%eax
    b8c2:	01 d0                	add    %edx,%eax
    b8c4:	01 c0                	add    %eax,%eax
    b8c6:	8d 50 03             	lea    0x3(%eax),%edx
    b8c9:	8b 45 18             	mov    0x18(%ebp),%eax
    b8cc:	01 d0                	add    %edx,%eax
    b8ce:	0f b6 00             	movzbl (%eax),%eax
    b8d1:	0f b6 c0             	movzbl %al,%eax
    b8d4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b8d7:	8b 45 20             	mov    0x20(%ebp),%eax
    b8da:	8b 40 18             	mov    0x18(%eax),%eax
    b8dd:	39 c2                	cmp    %eax,%edx
    b8df:	75 51                	jne    b932 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b8e1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8e4:	89 d0                	mov    %edx,%eax
    b8e6:	01 c0                	add    %eax,%eax
    b8e8:	01 d0                	add    %edx,%eax
    b8ea:	01 c0                	add    %eax,%eax
    b8ec:	8d 50 04             	lea    0x4(%eax),%edx
    b8ef:	8b 45 18             	mov    0x18(%ebp),%eax
    b8f2:	01 d0                	add    %edx,%eax
    b8f4:	0f b6 00             	movzbl (%eax),%eax
    b8f7:	0f b6 c0             	movzbl %al,%eax
    b8fa:	c1 e0 08             	shl    $0x8,%eax
    b8fd:	89 c1                	mov    %eax,%ecx
    b8ff:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b902:	89 d0                	mov    %edx,%eax
    b904:	01 c0                	add    %eax,%eax
    b906:	01 d0                	add    %edx,%eax
    b908:	01 c0                	add    %eax,%eax
    b90a:	8d 50 05             	lea    0x5(%eax),%edx
    b90d:	8b 45 18             	mov    0x18(%ebp),%eax
    b910:	01 d0                	add    %edx,%eax
    b912:	0f b6 00             	movzbl (%eax),%eax
    b915:	0f b6 c0             	movzbl %al,%eax
    b918:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b91b:	8b 45 20             	mov    0x20(%ebp),%eax
    b91e:	8b 40 1c             	mov    0x1c(%eax),%eax
    b921:	39 c2                	cmp    %eax,%edx
    b923:	75 0d                	jne    b932 <getPixelColorRGBA16+0x26b>
    b925:	8b 45 14             	mov    0x14(%ebp),%eax
    b928:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b92d:	e9 84 01 00 00       	jmp    bab6 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b932:	8b 45 14             	mov    0x14(%ebp),%eax
    b935:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b93a:	e9 77 01 00 00       	jmp    bab6 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b93f:	8b 45 20             	mov    0x20(%ebp),%eax
    b942:	8b 00                	mov    (%eax),%eax
    b944:	83 f8 04             	cmp    $0x4,%eax
    b947:	0f 85 86 00 00 00    	jne    b9d3 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b94d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b950:	c1 e0 02             	shl    $0x2,%eax
    b953:	89 c2                	mov    %eax,%edx
    b955:	8b 45 18             	mov    0x18(%ebp),%eax
    b958:	01 d0                	add    %edx,%eax
    b95a:	0f b6 00             	movzbl (%eax),%eax
    b95d:	0f b6 c0             	movzbl %al,%eax
    b960:	c1 e0 08             	shl    $0x8,%eax
    b963:	89 c2                	mov    %eax,%edx
    b965:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b968:	c1 e0 02             	shl    $0x2,%eax
    b96b:	8d 48 01             	lea    0x1(%eax),%ecx
    b96e:	8b 45 18             	mov    0x18(%ebp),%eax
    b971:	01 c8                	add    %ecx,%eax
    b973:	0f b6 00             	movzbl (%eax),%eax
    b976:	0f b6 c0             	movzbl %al,%eax
    b979:	01 c2                	add    %eax,%edx
    b97b:	8b 45 10             	mov    0x10(%ebp),%eax
    b97e:	66 89 10             	mov    %dx,(%eax)
    b981:	8b 45 10             	mov    0x10(%ebp),%eax
    b984:	0f b7 10             	movzwl (%eax),%edx
    b987:	8b 45 0c             	mov    0xc(%ebp),%eax
    b98a:	66 89 10             	mov    %dx,(%eax)
    b98d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b990:	0f b7 10             	movzwl (%eax),%edx
    b993:	8b 45 08             	mov    0x8(%ebp),%eax
    b996:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b999:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b99c:	c1 e0 02             	shl    $0x2,%eax
    b99f:	8d 50 02             	lea    0x2(%eax),%edx
    b9a2:	8b 45 18             	mov    0x18(%ebp),%eax
    b9a5:	01 d0                	add    %edx,%eax
    b9a7:	0f b6 00             	movzbl (%eax),%eax
    b9aa:	0f b6 c0             	movzbl %al,%eax
    b9ad:	c1 e0 08             	shl    $0x8,%eax
    b9b0:	89 c2                	mov    %eax,%edx
    b9b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9b5:	c1 e0 02             	shl    $0x2,%eax
    b9b8:	8d 48 03             	lea    0x3(%eax),%ecx
    b9bb:	8b 45 18             	mov    0x18(%ebp),%eax
    b9be:	01 c8                	add    %ecx,%eax
    b9c0:	0f b6 00             	movzbl (%eax),%eax
    b9c3:	0f b6 c0             	movzbl %al,%eax
    b9c6:	01 c2                	add    %eax,%edx
    b9c8:	8b 45 14             	mov    0x14(%ebp),%eax
    b9cb:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b9ce:	e9 e3 00 00 00       	jmp    bab6 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    b9d3:	8b 45 20             	mov    0x20(%ebp),%eax
    b9d6:	8b 00                	mov    (%eax),%eax
    b9d8:	83 f8 06             	cmp    $0x6,%eax
    b9db:	0f 85 d5 00 00 00    	jne    bab6 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    b9e1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9e4:	c1 e0 03             	shl    $0x3,%eax
    b9e7:	89 c2                	mov    %eax,%edx
    b9e9:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ec:	01 d0                	add    %edx,%eax
    b9ee:	0f b6 00             	movzbl (%eax),%eax
    b9f1:	0f b6 c0             	movzbl %al,%eax
    b9f4:	c1 e0 08             	shl    $0x8,%eax
    b9f7:	89 c2                	mov    %eax,%edx
    b9f9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9fc:	c1 e0 03             	shl    $0x3,%eax
    b9ff:	8d 48 01             	lea    0x1(%eax),%ecx
    ba02:	8b 45 18             	mov    0x18(%ebp),%eax
    ba05:	01 c8                	add    %ecx,%eax
    ba07:	0f b6 00             	movzbl (%eax),%eax
    ba0a:	0f b6 c0             	movzbl %al,%eax
    ba0d:	01 c2                	add    %eax,%edx
    ba0f:	8b 45 08             	mov    0x8(%ebp),%eax
    ba12:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    ba15:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba18:	c1 e0 03             	shl    $0x3,%eax
    ba1b:	8d 50 02             	lea    0x2(%eax),%edx
    ba1e:	8b 45 18             	mov    0x18(%ebp),%eax
    ba21:	01 d0                	add    %edx,%eax
    ba23:	0f b6 00             	movzbl (%eax),%eax
    ba26:	0f b6 c0             	movzbl %al,%eax
    ba29:	c1 e0 08             	shl    $0x8,%eax
    ba2c:	89 c2                	mov    %eax,%edx
    ba2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba31:	c1 e0 03             	shl    $0x3,%eax
    ba34:	8d 48 03             	lea    0x3(%eax),%ecx
    ba37:	8b 45 18             	mov    0x18(%ebp),%eax
    ba3a:	01 c8                	add    %ecx,%eax
    ba3c:	0f b6 00             	movzbl (%eax),%eax
    ba3f:	0f b6 c0             	movzbl %al,%eax
    ba42:	01 c2                	add    %eax,%edx
    ba44:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba47:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    ba4a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba4d:	c1 e0 03             	shl    $0x3,%eax
    ba50:	8d 50 04             	lea    0x4(%eax),%edx
    ba53:	8b 45 18             	mov    0x18(%ebp),%eax
    ba56:	01 d0                	add    %edx,%eax
    ba58:	0f b6 00             	movzbl (%eax),%eax
    ba5b:	0f b6 c0             	movzbl %al,%eax
    ba5e:	c1 e0 08             	shl    $0x8,%eax
    ba61:	89 c2                	mov    %eax,%edx
    ba63:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba66:	c1 e0 03             	shl    $0x3,%eax
    ba69:	8d 48 05             	lea    0x5(%eax),%ecx
    ba6c:	8b 45 18             	mov    0x18(%ebp),%eax
    ba6f:	01 c8                	add    %ecx,%eax
    ba71:	0f b6 00             	movzbl (%eax),%eax
    ba74:	0f b6 c0             	movzbl %al,%eax
    ba77:	01 c2                	add    %eax,%edx
    ba79:	8b 45 10             	mov    0x10(%ebp),%eax
    ba7c:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    ba7f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba82:	c1 e0 03             	shl    $0x3,%eax
    ba85:	8d 50 06             	lea    0x6(%eax),%edx
    ba88:	8b 45 18             	mov    0x18(%ebp),%eax
    ba8b:	01 d0                	add    %edx,%eax
    ba8d:	0f b6 00             	movzbl (%eax),%eax
    ba90:	0f b6 c0             	movzbl %al,%eax
    ba93:	c1 e0 08             	shl    $0x8,%eax
    ba96:	89 c2                	mov    %eax,%edx
    ba98:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba9b:	c1 e0 03             	shl    $0x3,%eax
    ba9e:	8d 48 07             	lea    0x7(%eax),%ecx
    baa1:	8b 45 18             	mov    0x18(%ebp),%eax
    baa4:	01 c8                	add    %ecx,%eax
    baa6:	0f b6 00             	movzbl (%eax),%eax
    baa9:	0f b6 c0             	movzbl %al,%eax
    baac:	01 c2                	add    %eax,%edx
    baae:	8b 45 14             	mov    0x14(%ebp),%eax
    bab1:	66 89 10             	mov    %dx,(%eax)
  }
}
    bab4:	eb 00                	jmp    bab6 <getPixelColorRGBA16+0x3ef>
    bab6:	90                   	nop
    bab7:	5d                   	pop    %ebp
    bab8:	c3                   	ret    

0000bab9 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bab9:	55                   	push   %ebp
    baba:	89 e5                	mov    %esp,%ebp
    babc:	56                   	push   %esi
    babd:	53                   	push   %ebx
    babe:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bac1:	8b 55 18             	mov    0x18(%ebp),%edx
    bac4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bac7:	0f af c2             	imul   %edx,%eax
    baca:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    bacd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bad4:	8b 45 14             	mov    0x14(%ebp),%eax
    bad7:	8b 00                	mov    (%eax),%eax
    bad9:	83 f8 03             	cmp    $0x3,%eax
    badc:	75 14                	jne    baf2 <lodepng_convert+0x39>
    bade:	8b 45 14             	mov    0x14(%ebp),%eax
    bae1:	8b 40 08             	mov    0x8(%eax),%eax
    bae4:	85 c0                	test   %eax,%eax
    bae6:	75 0a                	jne    baf2 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    bae8:	b8 6b 00 00 00       	mov    $0x6b,%eax
    baed:	e9 19 03 00 00       	jmp    be0b <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    baf2:	ff 75 14             	pushl  0x14(%ebp)
    baf5:	ff 75 10             	pushl  0x10(%ebp)
    baf8:	e8 b7 d1 ff ff       	call   8cb4 <lodepng_color_mode_equal>
    bafd:	83 c4 08             	add    $0x8,%esp
    bb00:	85 c0                	test   %eax,%eax
    bb02:	74 2f                	je     bb33 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bb04:	ff 75 14             	pushl  0x14(%ebp)
    bb07:	ff 75 1c             	pushl  0x1c(%ebp)
    bb0a:	ff 75 18             	pushl  0x18(%ebp)
    bb0d:	e8 fb d4 ff ff       	call   900d <lodepng_get_raw_size>
    bb12:	83 c4 0c             	add    $0xc,%esp
    bb15:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    bb18:	ff 75 dc             	pushl  -0x24(%ebp)
    bb1b:	ff 75 0c             	pushl  0xc(%ebp)
    bb1e:	ff 75 08             	pushl  0x8(%ebp)
    bb21:	e8 ca 78 ff ff       	call   33f0 <lodepng_memcpy>
    bb26:	83 c4 0c             	add    $0xc,%esp
    return 0;
    bb29:	b8 00 00 00 00       	mov    $0x0,%eax
    bb2e:	e9 d8 02 00 00       	jmp    be0b <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bb33:	8b 45 10             	mov    0x10(%ebp),%eax
    bb36:	8b 00                	mov    (%eax),%eax
    bb38:	83 f8 03             	cmp    $0x3,%eax
    bb3b:	0f 85 16 01 00 00    	jne    bc57 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bb41:	8b 45 10             	mov    0x10(%ebp),%eax
    bb44:	8b 40 0c             	mov    0xc(%eax),%eax
    bb47:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    bb4a:	8b 45 10             	mov    0x10(%ebp),%eax
    bb4d:	8b 40 08             	mov    0x8(%eax),%eax
    bb50:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bb53:	8b 45 10             	mov    0x10(%ebp),%eax
    bb56:	8b 40 04             	mov    0x4(%eax),%eax
    bb59:	ba 01 00 00 00       	mov    $0x1,%edx
    bb5e:	89 c1                	mov    %eax,%ecx
    bb60:	d3 e2                	shl    %cl,%edx
    bb62:	89 d0                	mov    %edx,%eax
    bb64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bb67:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bb6b:	75 5b                	jne    bbc8 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bb6d:	8b 45 14             	mov    0x14(%ebp),%eax
    bb70:	8b 40 0c             	mov    0xc(%eax),%eax
    bb73:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bb76:	8b 45 14             	mov    0x14(%ebp),%eax
    bb79:	8b 40 08             	mov    0x8(%eax),%eax
    bb7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bb7f:	8b 45 14             	mov    0x14(%ebp),%eax
    bb82:	8b 00                	mov    (%eax),%eax
    bb84:	83 f8 03             	cmp    $0x3,%eax
    bb87:	75 3f                	jne    bbc8 <lodepng_convert+0x10f>
    bb89:	8b 45 14             	mov    0x14(%ebp),%eax
    bb8c:	8b 50 04             	mov    0x4(%eax),%edx
    bb8f:	8b 45 10             	mov    0x10(%ebp),%eax
    bb92:	8b 40 04             	mov    0x4(%eax),%eax
    bb95:	39 c2                	cmp    %eax,%edx
    bb97:	75 2f                	jne    bbc8 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bb99:	ff 75 14             	pushl  0x14(%ebp)
    bb9c:	ff 75 1c             	pushl  0x1c(%ebp)
    bb9f:	ff 75 18             	pushl  0x18(%ebp)
    bba2:	e8 66 d4 ff ff       	call   900d <lodepng_get_raw_size>
    bba7:	83 c4 0c             	add    $0xc,%esp
    bbaa:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bbad:	ff 75 d8             	pushl  -0x28(%ebp)
    bbb0:	ff 75 0c             	pushl  0xc(%ebp)
    bbb3:	ff 75 08             	pushl  0x8(%ebp)
    bbb6:	e8 35 78 ff ff       	call   33f0 <lodepng_memcpy>
    bbbb:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bbbe:	b8 00 00 00 00       	mov    $0x0,%eax
    bbc3:	e9 43 02 00 00       	jmp    be0b <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bbc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bbcb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bbce:	7d 06                	jge    bbd6 <lodepng_convert+0x11d>
    bbd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bbd3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bbd6:	8d 45 90             	lea    -0x70(%ebp),%eax
    bbd9:	50                   	push   %eax
    bbda:	e8 5f e1 ff ff       	call   9d3e <color_tree_init>
    bbdf:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bbe2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bbe9:	eb 61                	jmp    bc4c <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bbeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbee:	c1 e0 02             	shl    $0x2,%eax
    bbf1:	89 c2                	mov    %eax,%edx
    bbf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bbf6:	01 d0                	add    %edx,%eax
    bbf8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bbfb:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bbfe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc01:	83 c0 03             	add    $0x3,%eax
    bc04:	0f b6 00             	movzbl (%eax),%eax
    bc07:	0f b6 d8             	movzbl %al,%ebx
    bc0a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc0d:	83 c0 02             	add    $0x2,%eax
    bc10:	0f b6 00             	movzbl (%eax),%eax
    bc13:	0f b6 c8             	movzbl %al,%ecx
    bc16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc19:	83 c0 01             	add    $0x1,%eax
    bc1c:	0f b6 00             	movzbl (%eax),%eax
    bc1f:	0f b6 d0             	movzbl %al,%edx
    bc22:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc25:	0f b6 00             	movzbl (%eax),%eax
    bc28:	0f b6 c0             	movzbl %al,%eax
    bc2b:	83 ec 08             	sub    $0x8,%esp
    bc2e:	56                   	push   %esi
    bc2f:	53                   	push   %ebx
    bc30:	51                   	push   %ecx
    bc31:	52                   	push   %edx
    bc32:	50                   	push   %eax
    bc33:	8d 45 90             	lea    -0x70(%ebp),%eax
    bc36:	50                   	push   %eax
    bc37:	e8 85 e2 ff ff       	call   9ec1 <color_tree_add>
    bc3c:	83 c4 20             	add    $0x20,%esp
    bc3f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bc42:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bc46:	75 0e                	jne    bc56 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bc48:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc4f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bc52:	75 97                	jne    bbeb <lodepng_convert+0x132>
    bc54:	eb 01                	jmp    bc57 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bc56:	90                   	nop
    }
  }

  if(!error) {
    bc57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bc5b:	0f 85 8e 01 00 00    	jne    bdef <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bc61:	8b 45 14             	mov    0x14(%ebp),%eax
    bc64:	8b 40 04             	mov    0x4(%eax),%eax
    bc67:	83 f8 10             	cmp    $0x10,%eax
    bc6a:	0f 85 99 00 00 00    	jne    bd09 <lodepng_convert+0x250>
    bc70:	8b 45 10             	mov    0x10(%ebp),%eax
    bc73:	8b 40 04             	mov    0x4(%eax),%eax
    bc76:	83 f8 10             	cmp    $0x10,%eax
    bc79:	0f 85 8a 00 00 00    	jne    bd09 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bc7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bc86:	eb 74                	jmp    bcfc <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bc88:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bc8e:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bc94:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bc9a:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bca0:	83 ec 04             	sub    $0x4,%esp
    bca3:	ff 75 14             	pushl  0x14(%ebp)
    bca6:	ff 75 f4             	pushl  -0xc(%ebp)
    bca9:	ff 75 0c             	pushl  0xc(%ebp)
    bcac:	8d 45 88             	lea    -0x78(%ebp),%eax
    bcaf:	50                   	push   %eax
    bcb0:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bcb3:	50                   	push   %eax
    bcb4:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bcb7:	50                   	push   %eax
    bcb8:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bcbb:	50                   	push   %eax
    bcbc:	e8 06 fa ff ff       	call   b6c7 <getPixelColorRGBA16>
    bcc1:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bcc4:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bcc8:	0f b7 d8             	movzwl %ax,%ebx
    bccb:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bccf:	0f b7 c8             	movzwl %ax,%ecx
    bcd2:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bcd6:	0f b7 d0             	movzwl %ax,%edx
    bcd9:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bcdd:	0f b7 c0             	movzwl %ax,%eax
    bce0:	83 ec 04             	sub    $0x4,%esp
    bce3:	53                   	push   %ebx
    bce4:	51                   	push   %ecx
    bce5:	52                   	push   %edx
    bce6:	50                   	push   %eax
    bce7:	ff 75 10             	pushl  0x10(%ebp)
    bcea:	ff 75 f4             	pushl  -0xc(%ebp)
    bced:	ff 75 08             	pushl  0x8(%ebp)
    bcf0:	e8 d3 e6 ff ff       	call   a3c8 <rgba16ToPixel>
    bcf5:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bcf8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bcfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bcff:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd02:	75 84                	jne    bc88 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bd04:	e9 e6 00 00 00       	jmp    bdef <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bd09:	8b 45 10             	mov    0x10(%ebp),%eax
    bd0c:	8b 40 04             	mov    0x4(%eax),%eax
    bd0f:	83 f8 08             	cmp    $0x8,%eax
    bd12:	75 23                	jne    bd37 <lodepng_convert+0x27e>
    bd14:	8b 45 10             	mov    0x10(%ebp),%eax
    bd17:	8b 00                	mov    (%eax),%eax
    bd19:	83 f8 06             	cmp    $0x6,%eax
    bd1c:	75 19                	jne    bd37 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bd1e:	ff 75 14             	pushl  0x14(%ebp)
    bd21:	ff 75 0c             	pushl  0xc(%ebp)
    bd24:	ff 75 e0             	pushl  -0x20(%ebp)
    bd27:	ff 75 08             	pushl  0x8(%ebp)
    bd2a:	e8 ae ee ff ff       	call   abdd <getPixelColorsRGBA8>
    bd2f:	83 c4 10             	add    $0x10,%esp
    bd32:	e9 b8 00 00 00       	jmp    bdef <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bd37:	8b 45 10             	mov    0x10(%ebp),%eax
    bd3a:	8b 40 04             	mov    0x4(%eax),%eax
    bd3d:	83 f8 08             	cmp    $0x8,%eax
    bd40:	75 23                	jne    bd65 <lodepng_convert+0x2ac>
    bd42:	8b 45 10             	mov    0x10(%ebp),%eax
    bd45:	8b 00                	mov    (%eax),%eax
    bd47:	83 f8 02             	cmp    $0x2,%eax
    bd4a:	75 19                	jne    bd65 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bd4c:	ff 75 14             	pushl  0x14(%ebp)
    bd4f:	ff 75 0c             	pushl  0xc(%ebp)
    bd52:	ff 75 e0             	pushl  -0x20(%ebp)
    bd55:	ff 75 08             	pushl  0x8(%ebp)
    bd58:	e8 50 f5 ff ff       	call   b2ad <getPixelColorsRGB8>
    bd5d:	83 c4 10             	add    $0x10,%esp
    bd60:	e9 8a 00 00 00       	jmp    bdef <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bd65:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bd69:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bd6d:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bd71:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bd75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bd7c:	eb 66                	jmp    bde4 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bd7e:	83 ec 04             	sub    $0x4,%esp
    bd81:	ff 75 14             	pushl  0x14(%ebp)
    bd84:	ff 75 f4             	pushl  -0xc(%ebp)
    bd87:	ff 75 0c             	pushl  0xc(%ebp)
    bd8a:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bd8d:	50                   	push   %eax
    bd8e:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bd91:	50                   	push   %eax
    bd92:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bd95:	50                   	push   %eax
    bd96:	8d 45 87             	lea    -0x79(%ebp),%eax
    bd99:	50                   	push   %eax
    bd9a:	e8 71 e8 ff ff       	call   a610 <getPixelColorRGBA8>
    bd9f:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bda2:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bda6:	0f b6 d8             	movzbl %al,%ebx
    bda9:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bdad:	0f b6 c8             	movzbl %al,%ecx
    bdb0:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bdb4:	0f b6 d0             	movzbl %al,%edx
    bdb7:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bdbb:	0f b6 c0             	movzbl %al,%eax
    bdbe:	53                   	push   %ebx
    bdbf:	51                   	push   %ecx
    bdc0:	52                   	push   %edx
    bdc1:	50                   	push   %eax
    bdc2:	8d 45 90             	lea    -0x70(%ebp),%eax
    bdc5:	50                   	push   %eax
    bdc6:	ff 75 10             	pushl  0x10(%ebp)
    bdc9:	ff 75 f4             	pushl  -0xc(%ebp)
    bdcc:	ff 75 08             	pushl  0x8(%ebp)
    bdcf:	e8 e5 e1 ff ff       	call   9fb9 <rgba8ToPixel>
    bdd4:	83 c4 20             	add    $0x20,%esp
    bdd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    bdda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bdde:	75 0e                	jne    bdee <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    bde0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bde4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bde7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bdea:	75 92                	jne    bd7e <lodepng_convert+0x2c5>
    bdec:	eb 01                	jmp    bdef <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    bdee:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bdef:	8b 45 10             	mov    0x10(%ebp),%eax
    bdf2:	8b 00                	mov    (%eax),%eax
    bdf4:	83 f8 03             	cmp    $0x3,%eax
    bdf7:	75 0f                	jne    be08 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    bdf9:	83 ec 0c             	sub    $0xc,%esp
    bdfc:	8d 45 90             	lea    -0x70(%ebp),%eax
    bdff:	50                   	push   %eax
    be00:	e8 59 df ff ff       	call   9d5e <color_tree_cleanup>
    be05:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    be08:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    be0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    be0e:	5b                   	pop    %ebx
    be0f:	5e                   	pop    %esi
    be10:	5d                   	pop    %ebp
    be11:	c3                   	ret    

0000be12 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    be12:	55                   	push   %ebp
    be13:	89 e5                	mov    %esp,%ebp
    be15:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    be18:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    be1f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    be26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    be2d:	8b 45 24             	mov    0x24(%ebp),%eax
    be30:	8b 40 04             	mov    0x4(%eax),%eax
    be33:	ba 01 00 00 00       	mov    $0x1,%edx
    be38:	89 c1                	mov    %eax,%ecx
    be3a:	d3 e2                	shl    %cl,%edx
    be3c:	89 d0                	mov    %edx,%eax
    be3e:	8d 48 ff             	lea    -0x1(%eax),%ecx
    be41:	b8 ff ff 00 00       	mov    $0xffff,%eax
    be46:	ba 00 00 00 00       	mov    $0x0,%edx
    be4b:	f7 f1                	div    %ecx
    be4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    be50:	8b 45 20             	mov    0x20(%ebp),%eax
    be53:	8b 40 04             	mov    0x4(%eax),%eax
    be56:	ba 10 00 00 00       	mov    $0x10,%edx
    be5b:	29 c2                	sub    %eax,%edx
    be5d:	89 d0                	mov    %edx,%eax
    be5f:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    be62:	8b 45 24             	mov    0x24(%ebp),%eax
    be65:	8b 00                	mov    (%eax),%eax
    be67:	85 c0                	test   %eax,%eax
    be69:	74 0a                	je     be75 <lodepng_convert_rgb+0x63>
    be6b:	8b 45 24             	mov    0x24(%ebp),%eax
    be6e:	8b 00                	mov    (%eax),%eax
    be70:	83 f8 04             	cmp    $0x4,%eax
    be73:	75 1b                	jne    be90 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    be75:	8b 45 14             	mov    0x14(%ebp),%eax
    be78:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be82:	89 45 f8             	mov    %eax,-0x8(%ebp)
    be85:	8b 45 f8             	mov    -0x8(%ebp),%eax
    be88:	89 45 fc             	mov    %eax,-0x4(%ebp)
    be8b:	e9 c2 00 00 00       	jmp    bf52 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    be90:	8b 45 24             	mov    0x24(%ebp),%eax
    be93:	8b 00                	mov    (%eax),%eax
    be95:	83 f8 02             	cmp    $0x2,%eax
    be98:	74 0a                	je     bea4 <lodepng_convert_rgb+0x92>
    be9a:	8b 45 24             	mov    0x24(%ebp),%eax
    be9d:	8b 00                	mov    (%eax),%eax
    be9f:	83 f8 06             	cmp    $0x6,%eax
    bea2:	75 23                	jne    bec7 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    bea4:	8b 45 14             	mov    0x14(%ebp),%eax
    bea7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    beab:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    beae:	8b 45 18             	mov    0x18(%ebp),%eax
    beb1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    beb5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    beb8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bebb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bebf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bec2:	e9 8b 00 00 00       	jmp    bf52 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    bec7:	8b 45 24             	mov    0x24(%ebp),%eax
    beca:	8b 00                	mov    (%eax),%eax
    becc:	83 f8 03             	cmp    $0x3,%eax
    becf:	75 77                	jne    bf48 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    bed1:	8b 45 24             	mov    0x24(%ebp),%eax
    bed4:	8b 40 0c             	mov    0xc(%eax),%eax
    bed7:	3b 45 14             	cmp    0x14(%ebp),%eax
    beda:	77 0a                	ja     bee6 <lodepng_convert_rgb+0xd4>
    bedc:	b8 52 00 00 00       	mov    $0x52,%eax
    bee1:	e9 cb 01 00 00       	jmp    c0b1 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    bee6:	8b 45 24             	mov    0x24(%ebp),%eax
    bee9:	8b 40 08             	mov    0x8(%eax),%eax
    beec:	8b 55 14             	mov    0x14(%ebp),%edx
    beef:	c1 e2 02             	shl    $0x2,%edx
    bef2:	01 d0                	add    %edx,%eax
    bef4:	0f b6 00             	movzbl (%eax),%eax
    bef7:	0f b6 d0             	movzbl %al,%edx
    befa:	89 d0                	mov    %edx,%eax
    befc:	c1 e0 08             	shl    $0x8,%eax
    beff:	01 d0                	add    %edx,%eax
    bf01:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    bf04:	8b 45 24             	mov    0x24(%ebp),%eax
    bf07:	8b 40 08             	mov    0x8(%eax),%eax
    bf0a:	8b 55 14             	mov    0x14(%ebp),%edx
    bf0d:	c1 e2 02             	shl    $0x2,%edx
    bf10:	83 c2 01             	add    $0x1,%edx
    bf13:	01 d0                	add    %edx,%eax
    bf15:	0f b6 00             	movzbl (%eax),%eax
    bf18:	0f b6 d0             	movzbl %al,%edx
    bf1b:	89 d0                	mov    %edx,%eax
    bf1d:	c1 e0 08             	shl    $0x8,%eax
    bf20:	01 d0                	add    %edx,%eax
    bf22:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    bf25:	8b 45 24             	mov    0x24(%ebp),%eax
    bf28:	8b 40 08             	mov    0x8(%eax),%eax
    bf2b:	8b 55 14             	mov    0x14(%ebp),%edx
    bf2e:	c1 e2 02             	shl    $0x2,%edx
    bf31:	83 c2 02             	add    $0x2,%edx
    bf34:	01 d0                	add    %edx,%eax
    bf36:	0f b6 00             	movzbl (%eax),%eax
    bf39:	0f b6 d0             	movzbl %al,%edx
    bf3c:	89 d0                	mov    %edx,%eax
    bf3e:	c1 e0 08             	shl    $0x8,%eax
    bf41:	01 d0                	add    %edx,%eax
    bf43:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bf46:	eb 0a                	jmp    bf52 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    bf48:	b8 1f 00 00 00       	mov    $0x1f,%eax
    bf4d:	e9 5f 01 00 00       	jmp    c0b1 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    bf52:	8b 45 20             	mov    0x20(%ebp),%eax
    bf55:	8b 00                	mov    (%eax),%eax
    bf57:	85 c0                	test   %eax,%eax
    bf59:	74 0a                	je     bf65 <lodepng_convert_rgb+0x153>
    bf5b:	8b 45 20             	mov    0x20(%ebp),%eax
    bf5e:	8b 00                	mov    (%eax),%eax
    bf60:	83 f8 04             	cmp    $0x4,%eax
    bf63:	75 14                	jne    bf79 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    bf65:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf68:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bf6b:	89 c1                	mov    %eax,%ecx
    bf6d:	d3 ea                	shr    %cl,%edx
    bf6f:	8b 45 08             	mov    0x8(%ebp),%eax
    bf72:	89 10                	mov    %edx,(%eax)
    bf74:	e9 33 01 00 00       	jmp    c0ac <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    bf79:	8b 45 20             	mov    0x20(%ebp),%eax
    bf7c:	8b 00                	mov    (%eax),%eax
    bf7e:	83 f8 02             	cmp    $0x2,%eax
    bf81:	74 0a                	je     bf8d <lodepng_convert_rgb+0x17b>
    bf83:	8b 45 20             	mov    0x20(%ebp),%eax
    bf86:	8b 00                	mov    (%eax),%eax
    bf88:	83 f8 06             	cmp    $0x6,%eax
    bf8b:	75 32                	jne    bfbf <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    bf8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf90:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bf93:	89 c1                	mov    %eax,%ecx
    bf95:	d3 ea                	shr    %cl,%edx
    bf97:	8b 45 08             	mov    0x8(%ebp),%eax
    bf9a:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bf9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf9f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bfa2:	89 c1                	mov    %eax,%ecx
    bfa4:	d3 ea                	shr    %cl,%edx
    bfa6:	8b 45 0c             	mov    0xc(%ebp),%eax
    bfa9:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bfab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bfb1:	89 c1                	mov    %eax,%ecx
    bfb3:	d3 ea                	shr    %cl,%edx
    bfb5:	8b 45 10             	mov    0x10(%ebp),%eax
    bfb8:	89 10                	mov    %edx,(%eax)
    bfba:	e9 ed 00 00 00       	jmp    c0ac <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    bfbf:	8b 45 20             	mov    0x20(%ebp),%eax
    bfc2:	8b 00                	mov    (%eax),%eax
    bfc4:	83 f8 03             	cmp    $0x3,%eax
    bfc7:	0f 85 d8 00 00 00    	jne    c0a5 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    bfcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bfd0:	c1 e8 08             	shr    $0x8,%eax
    bfd3:	89 c2                	mov    %eax,%edx
    bfd5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bfd8:	0f b6 c0             	movzbl %al,%eax
    bfdb:	39 c2                	cmp    %eax,%edx
    bfdd:	75 24                	jne    c003 <lodepng_convert_rgb+0x1f1>
    bfdf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bfe2:	c1 e8 08             	shr    $0x8,%eax
    bfe5:	89 c2                	mov    %eax,%edx
    bfe7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bfea:	0f b6 c0             	movzbl %al,%eax
    bfed:	39 c2                	cmp    %eax,%edx
    bfef:	75 12                	jne    c003 <lodepng_convert_rgb+0x1f1>
    bff1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bff4:	c1 e8 08             	shr    $0x8,%eax
    bff7:	89 c2                	mov    %eax,%edx
    bff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bffc:	0f b6 c0             	movzbl %al,%eax
    bfff:	39 c2                	cmp    %eax,%edx
    c001:	74 0a                	je     c00d <lodepng_convert_rgb+0x1fb>
    c003:	b8 52 00 00 00       	mov    $0x52,%eax
    c008:	e9 a4 00 00 00       	jmp    c0b1 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c00d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c014:	eb 79                	jmp    c08f <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c016:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c019:	c1 e0 02             	shl    $0x2,%eax
    c01c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c01f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c022:	c1 e8 08             	shr    $0x8,%eax
    c025:	89 c1                	mov    %eax,%ecx
    c027:	8b 45 20             	mov    0x20(%ebp),%eax
    c02a:	8b 50 08             	mov    0x8(%eax),%edx
    c02d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c030:	01 d0                	add    %edx,%eax
    c032:	0f b6 00             	movzbl (%eax),%eax
    c035:	0f b6 c0             	movzbl %al,%eax
    c038:	39 c1                	cmp    %eax,%ecx
    c03a:	75 4f                	jne    c08b <lodepng_convert_rgb+0x279>
    c03c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c03f:	c1 e8 08             	shr    $0x8,%eax
    c042:	89 c1                	mov    %eax,%ecx
    c044:	8b 45 20             	mov    0x20(%ebp),%eax
    c047:	8b 40 08             	mov    0x8(%eax),%eax
    c04a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c04d:	83 c2 01             	add    $0x1,%edx
    c050:	01 d0                	add    %edx,%eax
    c052:	0f b6 00             	movzbl (%eax),%eax
    c055:	0f b6 c0             	movzbl %al,%eax
    c058:	39 c1                	cmp    %eax,%ecx
    c05a:	75 2f                	jne    c08b <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c05c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c05f:	c1 e8 08             	shr    $0x8,%eax
    c062:	89 c1                	mov    %eax,%ecx
    c064:	8b 45 20             	mov    0x20(%ebp),%eax
    c067:	8b 40 08             	mov    0x8(%eax),%eax
    c06a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c06d:	83 c2 02             	add    $0x2,%edx
    c070:	01 d0                	add    %edx,%eax
    c072:	0f b6 00             	movzbl (%eax),%eax
    c075:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c078:	39 c1                	cmp    %eax,%ecx
    c07a:	75 0f                	jne    c08b <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c07c:	8b 45 08             	mov    0x8(%ebp),%eax
    c07f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c082:	89 10                	mov    %edx,(%eax)
        return 0;
    c084:	b8 00 00 00 00       	mov    $0x0,%eax
    c089:	eb 26                	jmp    c0b1 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c08b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c08f:	8b 45 20             	mov    0x20(%ebp),%eax
    c092:	8b 40 0c             	mov    0xc(%eax),%eax
    c095:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c098:	0f 87 78 ff ff ff    	ja     c016 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c09e:	b8 52 00 00 00       	mov    $0x52,%eax
    c0a3:	eb 0c                	jmp    c0b1 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c0a5:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c0aa:	eb 05                	jmp    c0b1 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c0ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c0b1:	c9                   	leave  
    c0b2:	c3                   	ret    

0000c0b3 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c0b3:	55                   	push   %ebp
    c0b4:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c0b6:	8b 45 08             	mov    0x8(%ebp),%eax
    c0b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c0bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c0c2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c0c9:	8b 45 08             	mov    0x8(%ebp),%eax
    c0cc:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c0d2:	8b 45 08             	mov    0x8(%ebp),%eax
    c0d5:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c0d9:	8b 45 08             	mov    0x8(%ebp),%eax
    c0dc:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c0e0:	8b 45 08             	mov    0x8(%ebp),%eax
    c0e3:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c0e7:	8b 45 08             	mov    0x8(%ebp),%eax
    c0ea:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c0ee:	8b 45 08             	mov    0x8(%ebp),%eax
    c0f1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c0f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c0fb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c102:	8b 45 08             	mov    0x8(%ebp),%eax
    c105:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c10c:	00 00 00 
  stats->numpixels = 0;
    c10f:	8b 45 08             	mov    0x8(%ebp),%eax
    c112:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c119:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c11c:	8b 45 08             	mov    0x8(%ebp),%eax
    c11f:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c126:	00 00 00 
  stats->allow_greyscale = 1;
    c129:	8b 45 08             	mov    0x8(%ebp),%eax
    c12c:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c133:	00 00 00 
}
    c136:	90                   	nop
    c137:	5d                   	pop    %ebp
    c138:	c3                   	ret    

0000c139 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c139:	55                   	push   %ebp
    c13a:	89 e5                	mov    %esp,%ebp
    c13c:	53                   	push   %ebx
    c13d:	83 ec 04             	sub    $0x4,%esp
    c140:	8b 45 08             	mov    0x8(%ebp),%eax
    c143:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c146:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c14a:	74 06                	je     c152 <getValueRequiredBits+0x19>
    c14c:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c150:	75 07                	jne    c159 <getValueRequiredBits+0x20>
    c152:	b8 01 00 00 00       	mov    $0x1,%eax
    c157:	eb 6b                	jmp    c1c4 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c159:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c15d:	0f b6 d9             	movzbl %cl,%ebx
    c160:	89 da                	mov    %ebx,%edx
    c162:	89 d0                	mov    %edx,%eax
    c164:	c1 e0 04             	shl    $0x4,%eax
    c167:	89 c2                	mov    %eax,%edx
    c169:	89 d0                	mov    %edx,%eax
    c16b:	c1 e0 04             	shl    $0x4,%eax
    c16e:	29 d0                	sub    %edx,%eax
    c170:	01 d8                	add    %ebx,%eax
    c172:	66 c1 e8 08          	shr    $0x8,%ax
    c176:	c0 e8 04             	shr    $0x4,%al
    c179:	89 c2                	mov    %eax,%edx
    c17b:	c1 e2 04             	shl    $0x4,%edx
    c17e:	01 c2                	add    %eax,%edx
    c180:	89 c8                	mov    %ecx,%eax
    c182:	29 d0                	sub    %edx,%eax
    c184:	84 c0                	test   %al,%al
    c186:	75 37                	jne    c1bf <getValueRequiredBits+0x86>
    c188:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c18c:	0f b6 d1             	movzbl %cl,%edx
    c18f:	89 d0                	mov    %edx,%eax
    c191:	01 c0                	add    %eax,%eax
    c193:	01 d0                	add    %edx,%eax
    c195:	c1 e0 06             	shl    $0x6,%eax
    c198:	01 d0                	add    %edx,%eax
    c19a:	66 c1 e8 08          	shr    $0x8,%ax
    c19e:	c0 e8 06             	shr    $0x6,%al
    c1a1:	ba 55 00 00 00       	mov    $0x55,%edx
    c1a6:	0f af c2             	imul   %edx,%eax
    c1a9:	29 c1                	sub    %eax,%ecx
    c1ab:	89 c8                	mov    %ecx,%eax
    c1ad:	84 c0                	test   %al,%al
    c1af:	75 07                	jne    c1b8 <getValueRequiredBits+0x7f>
    c1b1:	b8 02 00 00 00       	mov    $0x2,%eax
    c1b6:	eb 0c                	jmp    c1c4 <getValueRequiredBits+0x8b>
    c1b8:	b8 04 00 00 00       	mov    $0x4,%eax
    c1bd:	eb 05                	jmp    c1c4 <getValueRequiredBits+0x8b>
  return 8;
    c1bf:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c1c4:	83 c4 04             	add    $0x4,%esp
    c1c7:	5b                   	pop    %ebx
    c1c8:	5d                   	pop    %ebp
    c1c9:	c3                   	ret    

0000c1ca <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c1ca:	55                   	push   %ebp
    c1cb:	89 e5                	mov    %esp,%ebp
    c1cd:	56                   	push   %esi
    c1ce:	53                   	push   %ebx
    c1cf:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c1d5:	8b 55 10             	mov    0x10(%ebp),%edx
    c1d8:	8b 45 14             	mov    0x14(%ebp),%eax
    c1db:	0f af c2             	imul   %edx,%eax
    c1de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c1e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c1e8:	ff 75 18             	pushl  0x18(%ebp)
    c1eb:	e8 0b cd ff ff       	call   8efb <lodepng_is_greyscale_type>
    c1f0:	83 c4 04             	add    $0x4,%esp
    c1f3:	85 c0                	test   %eax,%eax
    c1f5:	0f 95 c0             	setne  %al
    c1f8:	0f b6 c0             	movzbl %al,%eax
    c1fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c1fe:	ff 75 18             	pushl  0x18(%ebp)
    c201:	e8 85 cd ff ff       	call   8f8b <lodepng_can_have_alpha>
    c206:	83 c4 04             	add    $0x4,%esp
    c209:	85 c0                	test   %eax,%eax
    c20b:	0f 94 c0             	sete   %al
    c20e:	0f b6 c0             	movzbl %al,%eax
    c211:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c214:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c21b:	ff 75 18             	pushl  0x18(%ebp)
    c21e:	e8 ab cc ff ff       	call   8ece <lodepng_get_bpp>
    c223:	83 c4 04             	add    $0x4,%esp
    c226:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c229:	8b 45 08             	mov    0x8(%ebp),%eax
    c22c:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c232:	83 f8 01             	cmp    $0x1,%eax
    c235:	75 0d                	jne    c244 <lodepng_compute_color_stats+0x7a>
    c237:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c23b:	75 07                	jne    c244 <lodepng_compute_color_stats+0x7a>
    c23d:	b8 01 00 00 00       	mov    $0x1,%eax
    c242:	eb 05                	jmp    c249 <lodepng_compute_color_stats+0x7f>
    c244:	b8 00 00 00 00       	mov    $0x0,%eax
    c249:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c24c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c253:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c25a:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c25e:	77 26                	ja     c286 <lodepng_compute_color_stats+0xbc>
    c260:	8b 45 08             	mov    0x8(%ebp),%eax
    c263:	8b 50 14             	mov    0x14(%eax),%edx
    c266:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c269:	bb 01 00 00 00       	mov    $0x1,%ebx
    c26e:	89 c1                	mov    %eax,%ecx
    c270:	d3 e3                	shl    %cl,%ebx
    c272:	89 d8                	mov    %ebx,%eax
    c274:	01 d0                	add    %edx,%eax
    c276:	ba 01 01 00 00       	mov    $0x101,%edx
    c27b:	3d 01 01 00 00       	cmp    $0x101,%eax
    c280:	0f 47 c2             	cmova  %edx,%eax
    c283:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c286:	8b 45 08             	mov    0x8(%ebp),%eax
    c289:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c28f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c292:	01 c2                	add    %eax,%edx
    c294:	8b 45 08             	mov    0x8(%ebp),%eax
    c297:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c29d:	8b 45 08             	mov    0x8(%ebp),%eax
    c2a0:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c2a6:	85 c0                	test   %eax,%eax
    c2a8:	75 07                	jne    c2b1 <lodepng_compute_color_stats+0xe7>
    c2aa:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c2b1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c2b7:	50                   	push   %eax
    c2b8:	e8 81 da ff ff       	call   9d3e <color_tree_init>
    c2bd:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c2c0:	8b 45 08             	mov    0x8(%ebp),%eax
    c2c3:	8b 40 10             	mov    0x10(%eax),%eax
    c2c6:	85 c0                	test   %eax,%eax
    c2c8:	74 07                	je     c2d1 <lodepng_compute_color_stats+0x107>
    c2ca:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c2d1:	8b 45 08             	mov    0x8(%ebp),%eax
    c2d4:	8b 00                	mov    (%eax),%eax
    c2d6:	85 c0                	test   %eax,%eax
    c2d8:	74 07                	je     c2e1 <lodepng_compute_color_stats+0x117>
    c2da:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c2e1:	8b 45 08             	mov    0x8(%ebp),%eax
    c2e4:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c2ea:	83 f8 10             	cmp    $0x10,%eax
    c2ed:	75 07                	jne    c2f6 <lodepng_compute_color_stats+0x12c>
    c2ef:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c2f6:	8b 45 08             	mov    0x8(%ebp),%eax
    c2f9:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c2ff:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c302:	72 07                	jb     c30b <lodepng_compute_color_stats+0x141>
    c304:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c30b:	8b 45 08             	mov    0x8(%ebp),%eax
    c30e:	8b 40 14             	mov    0x14(%eax),%eax
    c311:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c314:	72 07                	jb     c31d <lodepng_compute_color_stats+0x153>
    c316:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c31d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c321:	0f 85 82 00 00 00    	jne    c3a9 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c327:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c32e:	eb 6c                	jmp    c39c <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c330:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c333:	c1 e0 02             	shl    $0x2,%eax
    c336:	8d 50 10             	lea    0x10(%eax),%edx
    c339:	8b 45 08             	mov    0x8(%ebp),%eax
    c33c:	01 d0                	add    %edx,%eax
    c33e:	83 c0 08             	add    $0x8,%eax
    c341:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c344:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c347:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c34a:	83 c0 03             	add    $0x3,%eax
    c34d:	0f b6 00             	movzbl (%eax),%eax
    c350:	0f b6 d8             	movzbl %al,%ebx
    c353:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c356:	83 c0 02             	add    $0x2,%eax
    c359:	0f b6 00             	movzbl (%eax),%eax
    c35c:	0f b6 c8             	movzbl %al,%ecx
    c35f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c362:	83 c0 01             	add    $0x1,%eax
    c365:	0f b6 00             	movzbl (%eax),%eax
    c368:	0f b6 d0             	movzbl %al,%edx
    c36b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c36e:	0f b6 00             	movzbl (%eax),%eax
    c371:	0f b6 c0             	movzbl %al,%eax
    c374:	83 ec 08             	sub    $0x8,%esp
    c377:	56                   	push   %esi
    c378:	53                   	push   %ebx
    c379:	51                   	push   %ecx
    c37a:	52                   	push   %edx
    c37b:	50                   	push   %eax
    c37c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c382:	50                   	push   %eax
    c383:	e8 39 db ff ff       	call   9ec1 <color_tree_add>
    c388:	83 c4 20             	add    $0x20,%esp
    c38b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c38e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c392:	0f 85 22 09 00 00    	jne    ccba <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c398:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c39c:	8b 45 08             	mov    0x8(%ebp),%eax
    c39f:	8b 50 14             	mov    0x14(%eax),%edx
    c3a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3a5:	39 c2                	cmp    %eax,%edx
    c3a7:	77 87                	ja     c330 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c3a9:	8b 45 18             	mov    0x18(%ebp),%eax
    c3ac:	8b 40 04             	mov    0x4(%eax),%eax
    c3af:	83 f8 10             	cmp    $0x10,%eax
    c3b2:	0f 85 1e 01 00 00    	jne    c4d6 <lodepng_compute_color_stats+0x30c>
    c3b8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c3bc:	0f 85 14 01 00 00    	jne    c4d6 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c3c2:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c3c9:	00 00 
    c3cb:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c3d2:	00 00 
    c3d4:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c3db:	00 00 
    c3dd:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c3e4:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c3e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c3ed:	e9 d8 00 00 00       	jmp    c4ca <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c3f2:	83 ec 04             	sub    $0x4,%esp
    c3f5:	ff 75 18             	pushl  0x18(%ebp)
    c3f8:	ff 75 f4             	pushl  -0xc(%ebp)
    c3fb:	ff 75 0c             	pushl  0xc(%ebp)
    c3fe:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c404:	50                   	push   %eax
    c405:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c40b:	50                   	push   %eax
    c40c:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c412:	50                   	push   %eax
    c413:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c419:	50                   	push   %eax
    c41a:	e8 a8 f2 ff ff       	call   b6c7 <getPixelColorRGBA16>
    c41f:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c422:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c429:	66 c1 e8 08          	shr    $0x8,%ax
    c42d:	89 c2                	mov    %eax,%edx
    c42f:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c436:	31 d0                	xor    %edx,%eax
    c438:	0f b7 c0             	movzwl %ax,%eax
    c43b:	0f b6 c0             	movzbl %al,%eax
    c43e:	85 c0                	test   %eax,%eax
    c440:	75 60                	jne    c4a2 <lodepng_compute_color_stats+0x2d8>
    c442:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c449:	66 c1 e8 08          	shr    $0x8,%ax
    c44d:	89 c2                	mov    %eax,%edx
    c44f:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c456:	31 d0                	xor    %edx,%eax
    c458:	0f b7 c0             	movzwl %ax,%eax
    c45b:	0f b6 c0             	movzbl %al,%eax
    c45e:	85 c0                	test   %eax,%eax
    c460:	75 40                	jne    c4a2 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c462:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c469:	66 c1 e8 08          	shr    $0x8,%ax
    c46d:	89 c2                	mov    %eax,%edx
    c46f:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c476:	31 d0                	xor    %edx,%eax
    c478:	0f b7 c0             	movzwl %ax,%eax
    c47b:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c47e:	85 c0                	test   %eax,%eax
    c480:	75 20                	jne    c4a2 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c482:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c489:	66 c1 e8 08          	shr    $0x8,%ax
    c48d:	89 c2                	mov    %eax,%edx
    c48f:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c496:	31 d0                	xor    %edx,%eax
    c498:	0f b7 c0             	movzwl %ax,%eax
    c49b:	0f b6 c0             	movzbl %al,%eax
    c49e:	85 c0                	test   %eax,%eax
    c4a0:	74 24                	je     c4c6 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c4a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c4a5:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c4ac:	00 00 00 
        sixteen = 1;
    c4af:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c4b6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c4bd:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c4c4:	eb 10                	jmp    c4d6 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c4c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c4ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c4cd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c4d0:	0f 85 1c ff ff ff    	jne    c3f2 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c4d6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c4da:	0f 84 bd 02 00 00    	je     c79d <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c4e0:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c4e7:	00 00 
    c4e9:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c4f0:	00 00 
    c4f2:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c4f9:	00 00 
    c4fb:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c502:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c504:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c50b:	e9 b1 01 00 00       	jmp    c6c1 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c510:	83 ec 04             	sub    $0x4,%esp
    c513:	ff 75 18             	pushl  0x18(%ebp)
    c516:	ff 75 f4             	pushl  -0xc(%ebp)
    c519:	ff 75 0c             	pushl  0xc(%ebp)
    c51c:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c522:	50                   	push   %eax
    c523:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c529:	50                   	push   %eax
    c52a:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c530:	50                   	push   %eax
    c531:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c537:	50                   	push   %eax
    c538:	e8 8a f1 ff ff       	call   b6c7 <getPixelColorRGBA16>
    c53d:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c540:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c544:	75 36                	jne    c57c <lodepng_compute_color_stats+0x3b2>
    c546:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c54d:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c554:	66 39 c2             	cmp    %ax,%dx
    c557:	75 13                	jne    c56c <lodepng_compute_color_stats+0x3a2>
    c559:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c560:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c567:	66 39 c2             	cmp    %ax,%dx
    c56a:	74 10                	je     c57c <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c56c:	8b 45 08             	mov    0x8(%ebp),%eax
    c56f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c575:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c57c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c580:	0f 85 1f 01 00 00    	jne    c6a5 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c586:	8b 45 08             	mov    0x8(%ebp),%eax
    c589:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c58d:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c594:	66 39 c2             	cmp    %ax,%dx
    c597:	75 2d                	jne    c5c6 <lodepng_compute_color_stats+0x3fc>
    c599:	8b 45 08             	mov    0x8(%ebp),%eax
    c59c:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c5a0:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c5a7:	66 39 c2             	cmp    %ax,%dx
    c5aa:	75 1a                	jne    c5c6 <lodepng_compute_color_stats+0x3fc>
    c5ac:	8b 45 08             	mov    0x8(%ebp),%eax
    c5af:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c5b3:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c5ba:	66 39 c2             	cmp    %ax,%dx
    c5bd:	75 07                	jne    c5c6 <lodepng_compute_color_stats+0x3fc>
    c5bf:	b8 01 00 00 00       	mov    $0x1,%eax
    c5c4:	eb 05                	jmp    c5cb <lodepng_compute_color_stats+0x401>
    c5c6:	b8 00 00 00 00       	mov    $0x0,%eax
    c5cb:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c5ce:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5d5:	66 83 f8 ff          	cmp    $0xffff,%ax
    c5d9:	74 3c                	je     c617 <lodepng_compute_color_stats+0x44d>
    c5db:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5e2:	66 85 c0             	test   %ax,%ax
    c5e5:	75 10                	jne    c5f7 <lodepng_compute_color_stats+0x42d>
    c5e7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ea:	8b 40 04             	mov    0x4(%eax),%eax
    c5ed:	85 c0                	test   %eax,%eax
    c5ef:	74 26                	je     c617 <lodepng_compute_color_stats+0x44d>
    c5f1:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c5f5:	75 20                	jne    c617 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c5f7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5fa:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c601:	8b 45 08             	mov    0x8(%ebp),%eax
    c604:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c60b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c612:	e9 8e 00 00 00       	jmp    c6a5 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c617:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c61e:	66 85 c0             	test   %ax,%ax
    c621:	75 4a                	jne    c66d <lodepng_compute_color_stats+0x4a3>
    c623:	8b 45 08             	mov    0x8(%ebp),%eax
    c626:	8b 40 10             	mov    0x10(%eax),%eax
    c629:	85 c0                	test   %eax,%eax
    c62b:	75 40                	jne    c66d <lodepng_compute_color_stats+0x4a3>
    c62d:	8b 45 08             	mov    0x8(%ebp),%eax
    c630:	8b 40 04             	mov    0x4(%eax),%eax
    c633:	85 c0                	test   %eax,%eax
    c635:	75 36                	jne    c66d <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c637:	8b 45 08             	mov    0x8(%ebp),%eax
    c63a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c641:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c648:	8b 45 08             	mov    0x8(%ebp),%eax
    c64b:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c64f:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c656:	8b 45 08             	mov    0x8(%ebp),%eax
    c659:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c65d:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c664:	8b 45 08             	mov    0x8(%ebp),%eax
    c667:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c66b:	eb 38                	jmp    c6a5 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c66d:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c674:	66 83 f8 ff          	cmp    $0xffff,%ax
    c678:	75 2b                	jne    c6a5 <lodepng_compute_color_stats+0x4db>
    c67a:	8b 45 08             	mov    0x8(%ebp),%eax
    c67d:	8b 40 04             	mov    0x4(%eax),%eax
    c680:	85 c0                	test   %eax,%eax
    c682:	74 21                	je     c6a5 <lodepng_compute_color_stats+0x4db>
    c684:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c688:	74 1b                	je     c6a5 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c68a:	8b 45 08             	mov    0x8(%ebp),%eax
    c68d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c694:	8b 45 08             	mov    0x8(%ebp),%eax
    c697:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c69e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c6a5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c6a9:	74 12                	je     c6bd <lodepng_compute_color_stats+0x4f3>
    c6ab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c6af:	74 0c                	je     c6bd <lodepng_compute_color_stats+0x4f3>
    c6b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c6b5:	74 06                	je     c6bd <lodepng_compute_color_stats+0x4f3>
    c6b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c6bb:	75 12                	jne    c6cf <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c6bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6c4:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c6c7:	0f 85 43 fe ff ff    	jne    c510 <lodepng_compute_color_stats+0x346>
    c6cd:	eb 01                	jmp    c6d0 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c6cf:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c6d0:	8b 45 08             	mov    0x8(%ebp),%eax
    c6d3:	8b 40 04             	mov    0x4(%eax),%eax
    c6d6:	85 c0                	test   %eax,%eax
    c6d8:	0f 84 e0 05 00 00    	je     ccbe <lodepng_compute_color_stats+0xaf4>
    c6de:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e1:	8b 40 10             	mov    0x10(%eax),%eax
    c6e4:	85 c0                	test   %eax,%eax
    c6e6:	0f 85 d2 05 00 00    	jne    ccbe <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c6ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c6f3:	e9 94 00 00 00       	jmp    c78c <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c6f8:	83 ec 04             	sub    $0x4,%esp
    c6fb:	ff 75 18             	pushl  0x18(%ebp)
    c6fe:	ff 75 f4             	pushl  -0xc(%ebp)
    c701:	ff 75 0c             	pushl  0xc(%ebp)
    c704:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c70a:	50                   	push   %eax
    c70b:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c711:	50                   	push   %eax
    c712:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c718:	50                   	push   %eax
    c719:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c71f:	50                   	push   %eax
    c720:	e8 a2 ef ff ff       	call   b6c7 <getPixelColorRGBA16>
    c725:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c728:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c72f:	66 85 c0             	test   %ax,%ax
    c732:	74 54                	je     c788 <lodepng_compute_color_stats+0x5be>
    c734:	8b 45 08             	mov    0x8(%ebp),%eax
    c737:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c73b:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c742:	66 39 c2             	cmp    %ax,%dx
    c745:	75 41                	jne    c788 <lodepng_compute_color_stats+0x5be>
    c747:	8b 45 08             	mov    0x8(%ebp),%eax
    c74a:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c74e:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c755:	66 39 c2             	cmp    %ax,%dx
    c758:	75 2e                	jne    c788 <lodepng_compute_color_stats+0x5be>
    c75a:	8b 45 08             	mov    0x8(%ebp),%eax
    c75d:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c761:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c768:	66 39 c2             	cmp    %ax,%dx
    c76b:	75 1b                	jne    c788 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c76d:	8b 45 08             	mov    0x8(%ebp),%eax
    c770:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c777:	8b 45 08             	mov    0x8(%ebp),%eax
    c77a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c781:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c788:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c78c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c78f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c792:	0f 85 60 ff ff ff    	jne    c6f8 <lodepng_compute_color_stats+0x52e>
    c798:	e9 21 05 00 00       	jmp    ccbe <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c79d:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c7a4:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c7ab:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c7b2:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c7b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c7c0:	e9 ab 03 00 00       	jmp    cb70 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c7c5:	83 ec 04             	sub    $0x4,%esp
    c7c8:	ff 75 18             	pushl  0x18(%ebp)
    c7cb:	ff 75 f4             	pushl  -0xc(%ebp)
    c7ce:	ff 75 0c             	pushl  0xc(%ebp)
    c7d1:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c7d7:	50                   	push   %eax
    c7d8:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c7de:	50                   	push   %eax
    c7df:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c7e5:	50                   	push   %eax
    c7e6:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c7ec:	50                   	push   %eax
    c7ed:	e8 1e de ff ff       	call   a610 <getPixelColorRGBA8>
    c7f2:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c7f5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c7f9:	75 41                	jne    c83c <lodepng_compute_color_stats+0x672>
    c7fb:	8b 45 08             	mov    0x8(%ebp),%eax
    c7fe:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c804:	83 f8 07             	cmp    $0x7,%eax
    c807:	77 33                	ja     c83c <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c809:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c810:	0f b6 c0             	movzbl %al,%eax
    c813:	83 ec 0c             	sub    $0xc,%esp
    c816:	50                   	push   %eax
    c817:	e8 1d f9 ff ff       	call   c139 <getValueRequiredBits>
    c81c:	83 c4 10             	add    $0x10,%esp
    c81f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c822:	8b 45 08             	mov    0x8(%ebp),%eax
    c825:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c82b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c82e:	73 0c                	jae    c83c <lodepng_compute_color_stats+0x672>
    c830:	8b 45 08             	mov    0x8(%ebp),%eax
    c833:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c836:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c83c:	8b 45 08             	mov    0x8(%ebp),%eax
    c83f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c845:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c848:	0f 93 c0             	setae  %al
    c84b:	0f b6 c0             	movzbl %al,%eax
    c84e:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c851:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c855:	75 4f                	jne    c8a6 <lodepng_compute_color_stats+0x6dc>
    c857:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c85e:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c865:	38 c2                	cmp    %al,%dl
    c867:	75 12                	jne    c87b <lodepng_compute_color_stats+0x6b1>
    c869:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c870:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c877:	38 c2                	cmp    %al,%dl
    c879:	74 2b                	je     c8a6 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c87b:	8b 45 08             	mov    0x8(%ebp),%eax
    c87e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c884:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c88b:	8b 45 08             	mov    0x8(%ebp),%eax
    c88e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c894:	83 f8 07             	cmp    $0x7,%eax
    c897:	77 0d                	ja     c8a6 <lodepng_compute_color_stats+0x6dc>
    c899:	8b 45 08             	mov    0x8(%ebp),%eax
    c89c:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c8a3:	00 00 00 
      }

      if(!alpha_done) {
    c8a6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c8aa:	0f 85 65 01 00 00    	jne    ca15 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c8b0:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c8b7:	0f b6 d0             	movzbl %al,%edx
    c8ba:	8b 45 08             	mov    0x8(%ebp),%eax
    c8bd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c8c1:	66 39 c2             	cmp    %ax,%dx
    c8c4:	75 33                	jne    c8f9 <lodepng_compute_color_stats+0x72f>
    c8c6:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c8cd:	0f b6 d0             	movzbl %al,%edx
    c8d0:	8b 45 08             	mov    0x8(%ebp),%eax
    c8d3:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c8d7:	66 39 c2             	cmp    %ax,%dx
    c8da:	75 1d                	jne    c8f9 <lodepng_compute_color_stats+0x72f>
    c8dc:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c8e3:	0f b6 d0             	movzbl %al,%edx
    c8e6:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c8ed:	66 39 c2             	cmp    %ax,%dx
    c8f0:	75 07                	jne    c8f9 <lodepng_compute_color_stats+0x72f>
    c8f2:	b8 01 00 00 00       	mov    $0x1,%eax
    c8f7:	eb 05                	jmp    c8fe <lodepng_compute_color_stats+0x734>
    c8f9:	b8 00 00 00 00       	mov    $0x0,%eax
    c8fe:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c901:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c908:	3c ff                	cmp    $0xff,%al
    c90a:	74 5a                	je     c966 <lodepng_compute_color_stats+0x79c>
    c90c:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c913:	84 c0                	test   %al,%al
    c915:	75 10                	jne    c927 <lodepng_compute_color_stats+0x75d>
    c917:	8b 45 08             	mov    0x8(%ebp),%eax
    c91a:	8b 40 04             	mov    0x4(%eax),%eax
    c91d:	85 c0                	test   %eax,%eax
    c91f:	74 45                	je     c966 <lodepng_compute_color_stats+0x79c>
    c921:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c925:	75 3f                	jne    c966 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c927:	8b 45 08             	mov    0x8(%ebp),%eax
    c92a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c931:	8b 45 08             	mov    0x8(%ebp),%eax
    c934:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c93b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c942:	8b 45 08             	mov    0x8(%ebp),%eax
    c945:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c94b:	83 f8 07             	cmp    $0x7,%eax
    c94e:	0f 87 c1 00 00 00    	ja     ca15 <lodepng_compute_color_stats+0x84b>
    c954:	8b 45 08             	mov    0x8(%ebp),%eax
    c957:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c95e:	00 00 00 
    c961:	e9 af 00 00 00       	jmp    ca15 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c966:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c96d:	84 c0                	test   %al,%al
    c96f:	75 53                	jne    c9c4 <lodepng_compute_color_stats+0x7fa>
    c971:	8b 45 08             	mov    0x8(%ebp),%eax
    c974:	8b 40 10             	mov    0x10(%eax),%eax
    c977:	85 c0                	test   %eax,%eax
    c979:	75 49                	jne    c9c4 <lodepng_compute_color_stats+0x7fa>
    c97b:	8b 45 08             	mov    0x8(%ebp),%eax
    c97e:	8b 40 04             	mov    0x4(%eax),%eax
    c981:	85 c0                	test   %eax,%eax
    c983:	75 3f                	jne    c9c4 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c985:	8b 45 08             	mov    0x8(%ebp),%eax
    c988:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c98f:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c996:	0f b6 d0             	movzbl %al,%edx
    c999:	8b 45 08             	mov    0x8(%ebp),%eax
    c99c:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c9a0:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9a7:	0f b6 d0             	movzbl %al,%edx
    c9aa:	8b 45 08             	mov    0x8(%ebp),%eax
    c9ad:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c9b1:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9b8:	0f b6 d0             	movzbl %al,%edx
    c9bb:	8b 45 08             	mov    0x8(%ebp),%eax
    c9be:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c9c2:	eb 51                	jmp    ca15 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    c9c4:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9cb:	3c ff                	cmp    $0xff,%al
    c9cd:	75 46                	jne    ca15 <lodepng_compute_color_stats+0x84b>
    c9cf:	8b 45 08             	mov    0x8(%ebp),%eax
    c9d2:	8b 40 04             	mov    0x4(%eax),%eax
    c9d5:	85 c0                	test   %eax,%eax
    c9d7:	74 3c                	je     ca15 <lodepng_compute_color_stats+0x84b>
    c9d9:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c9dd:	74 36                	je     ca15 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c9df:	8b 45 08             	mov    0x8(%ebp),%eax
    c9e2:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c9e9:	8b 45 08             	mov    0x8(%ebp),%eax
    c9ec:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c9f3:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c9fa:	8b 45 08             	mov    0x8(%ebp),%eax
    c9fd:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca03:	83 f8 07             	cmp    $0x7,%eax
    ca06:	77 0d                	ja     ca15 <lodepng_compute_color_stats+0x84b>
    ca08:	8b 45 08             	mov    0x8(%ebp),%eax
    ca0b:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    ca12:	00 00 00 
        }
      }

      if(!numcolors_done) {
    ca15:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ca19:	0f 85 35 01 00 00    	jne    cb54 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    ca1f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca26:	0f b6 d8             	movzbl %al,%ebx
    ca29:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca30:	0f b6 c8             	movzbl %al,%ecx
    ca33:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca3a:	0f b6 d0             	movzbl %al,%edx
    ca3d:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca44:	0f b6 c0             	movzbl %al,%eax
    ca47:	83 ec 0c             	sub    $0xc,%esp
    ca4a:	53                   	push   %ebx
    ca4b:	51                   	push   %ecx
    ca4c:	52                   	push   %edx
    ca4d:	50                   	push   %eax
    ca4e:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ca54:	50                   	push   %eax
    ca55:	e8 1c d4 ff ff       	call   9e76 <color_tree_has>
    ca5a:	83 c4 20             	add    $0x20,%esp
    ca5d:	85 c0                	test   %eax,%eax
    ca5f:	0f 85 ef 00 00 00    	jne    cb54 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    ca65:	8b 45 08             	mov    0x8(%ebp),%eax
    ca68:	8b 70 14             	mov    0x14(%eax),%esi
    ca6b:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca72:	0f b6 d8             	movzbl %al,%ebx
    ca75:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca7c:	0f b6 c8             	movzbl %al,%ecx
    ca7f:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca86:	0f b6 d0             	movzbl %al,%edx
    ca89:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca90:	0f b6 c0             	movzbl %al,%eax
    ca93:	83 ec 08             	sub    $0x8,%esp
    ca96:	56                   	push   %esi
    ca97:	53                   	push   %ebx
    ca98:	51                   	push   %ecx
    ca99:	52                   	push   %edx
    ca9a:	50                   	push   %eax
    ca9b:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    caa1:	50                   	push   %eax
    caa2:	e8 1a d4 ff ff       	call   9ec1 <color_tree_add>
    caa7:	83 c4 20             	add    $0x20,%esp
    caaa:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    caad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cab1:	0f 85 06 02 00 00    	jne    ccbd <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    cab7:	8b 45 08             	mov    0x8(%ebp),%eax
    caba:	8b 40 14             	mov    0x14(%eax),%eax
    cabd:	3d ff 00 00 00       	cmp    $0xff,%eax
    cac2:	77 6f                	ja     cb33 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    cac4:	8b 45 08             	mov    0x8(%ebp),%eax
    cac7:	83 c0 18             	add    $0x18,%eax
    caca:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cacd:	8b 45 08             	mov    0x8(%ebp),%eax
    cad0:	8b 40 14             	mov    0x14(%eax),%eax
    cad3:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cad6:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cad9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cae0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cae3:	01 c2                	add    %eax,%edx
    cae5:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    caec:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    caee:	8b 45 b8             	mov    -0x48(%ebp),%eax
    caf1:	c1 e0 02             	shl    $0x2,%eax
    caf4:	8d 50 01             	lea    0x1(%eax),%edx
    caf7:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cafa:	01 c2                	add    %eax,%edx
    cafc:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb03:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    cb05:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb08:	c1 e0 02             	shl    $0x2,%eax
    cb0b:	8d 50 02             	lea    0x2(%eax),%edx
    cb0e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb11:	01 c2                	add    %eax,%edx
    cb13:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb1a:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    cb1c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb1f:	c1 e0 02             	shl    $0x2,%eax
    cb22:	8d 50 03             	lea    0x3(%eax),%edx
    cb25:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb28:	01 c2                	add    %eax,%edx
    cb2a:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb31:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    cb33:	8b 45 08             	mov    0x8(%ebp),%eax
    cb36:	8b 40 14             	mov    0x14(%eax),%eax
    cb39:	8d 50 01             	lea    0x1(%eax),%edx
    cb3c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb3f:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cb42:	8b 45 08             	mov    0x8(%ebp),%eax
    cb45:	8b 40 14             	mov    0x14(%eax),%eax
    cb48:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cb4b:	0f 93 c0             	setae  %al
    cb4e:	0f b6 c0             	movzbl %al,%eax
    cb51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cb54:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cb58:	74 12                	je     cb6c <lodepng_compute_color_stats+0x9a2>
    cb5a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cb5e:	74 0c                	je     cb6c <lodepng_compute_color_stats+0x9a2>
    cb60:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cb64:	74 06                	je     cb6c <lodepng_compute_color_stats+0x9a2>
    cb66:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cb6a:	75 12                	jne    cb7e <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cb6c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cb70:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb73:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cb76:	0f 85 49 fc ff ff    	jne    c7c5 <lodepng_compute_color_stats+0x5fb>
    cb7c:	eb 01                	jmp    cb7f <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cb7e:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cb7f:	8b 45 08             	mov    0x8(%ebp),%eax
    cb82:	8b 40 04             	mov    0x4(%eax),%eax
    cb85:	85 c0                	test   %eax,%eax
    cb87:	0f 84 dd 00 00 00    	je     cc6a <lodepng_compute_color_stats+0xaa0>
    cb8d:	8b 45 08             	mov    0x8(%ebp),%eax
    cb90:	8b 40 10             	mov    0x10(%eax),%eax
    cb93:	85 c0                	test   %eax,%eax
    cb95:	0f 85 cf 00 00 00    	jne    cc6a <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cb9b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cba2:	e9 b7 00 00 00       	jmp    cc5e <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cba7:	83 ec 04             	sub    $0x4,%esp
    cbaa:	ff 75 18             	pushl  0x18(%ebp)
    cbad:	ff 75 f4             	pushl  -0xc(%ebp)
    cbb0:	ff 75 0c             	pushl  0xc(%ebp)
    cbb3:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cbb9:	50                   	push   %eax
    cbba:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cbc0:	50                   	push   %eax
    cbc1:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cbc7:	50                   	push   %eax
    cbc8:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cbce:	50                   	push   %eax
    cbcf:	e8 3c da ff ff       	call   a610 <getPixelColorRGBA8>
    cbd4:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cbd7:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cbde:	84 c0                	test   %al,%al
    cbe0:	74 78                	je     cc5a <lodepng_compute_color_stats+0xa90>
    cbe2:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cbe9:	0f b6 d0             	movzbl %al,%edx
    cbec:	8b 45 08             	mov    0x8(%ebp),%eax
    cbef:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cbf3:	66 39 c2             	cmp    %ax,%dx
    cbf6:	75 62                	jne    cc5a <lodepng_compute_color_stats+0xa90>
    cbf8:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cbff:	0f b6 d0             	movzbl %al,%edx
    cc02:	8b 45 08             	mov    0x8(%ebp),%eax
    cc05:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cc09:	66 39 c2             	cmp    %ax,%dx
    cc0c:	75 4c                	jne    cc5a <lodepng_compute_color_stats+0xa90>
    cc0e:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cc15:	0f b6 d0             	movzbl %al,%edx
    cc18:	8b 45 08             	mov    0x8(%ebp),%eax
    cc1b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc1f:	66 39 c2             	cmp    %ax,%dx
    cc22:	75 36                	jne    cc5a <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cc24:	8b 45 08             	mov    0x8(%ebp),%eax
    cc27:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc2e:	8b 45 08             	mov    0x8(%ebp),%eax
    cc31:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc38:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cc3f:	8b 45 08             	mov    0x8(%ebp),%eax
    cc42:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cc48:	83 f8 07             	cmp    $0x7,%eax
    cc4b:	77 0d                	ja     cc5a <lodepng_compute_color_stats+0xa90>
    cc4d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc50:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cc57:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cc5a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cc5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc61:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cc64:	0f 85 3d ff ff ff    	jne    cba7 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cc6a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc6d:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cc71:	8b 45 08             	mov    0x8(%ebp),%eax
    cc74:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc78:	c1 e0 08             	shl    $0x8,%eax
    cc7b:	01 c2                	add    %eax,%edx
    cc7d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc80:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cc84:	8b 45 08             	mov    0x8(%ebp),%eax
    cc87:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cc8b:	8b 45 08             	mov    0x8(%ebp),%eax
    cc8e:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cc92:	c1 e0 08             	shl    $0x8,%eax
    cc95:	01 c2                	add    %eax,%edx
    cc97:	8b 45 08             	mov    0x8(%ebp),%eax
    cc9a:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cc9e:	8b 45 08             	mov    0x8(%ebp),%eax
    cca1:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cca5:	8b 45 08             	mov    0x8(%ebp),%eax
    cca8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    ccac:	c1 e0 08             	shl    $0x8,%eax
    ccaf:	01 c2                	add    %eax,%edx
    ccb1:	8b 45 08             	mov    0x8(%ebp),%eax
    ccb4:	66 89 50 0c          	mov    %dx,0xc(%eax)
    ccb8:	eb 04                	jmp    ccbe <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    ccba:	90                   	nop
    ccbb:	eb 01                	jmp    ccbe <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    ccbd:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    ccbe:	83 ec 0c             	sub    $0xc,%esp
    ccc1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ccc7:	50                   	push   %eax
    ccc8:	e8 91 d0 ff ff       	call   9d5e <color_tree_cleanup>
    cccd:	83 c4 10             	add    $0x10,%esp
  return error;
    ccd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    ccd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ccd6:	5b                   	pop    %ebx
    ccd7:	5e                   	pop    %esi
    ccd8:	5d                   	pop    %ebp
    ccd9:	c3                   	ret    

0000ccda <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    ccda:	55                   	push   %ebp
    ccdb:	89 e5                	mov    %esp,%ebp
    ccdd:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cce0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cce7:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccea:	50                   	push   %eax
    cceb:	e8 d1 bd ff ff       	call   8ac1 <lodepng_color_mode_init>
    ccf0:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    ccf3:	8b 45 0c             	mov    0xc(%ebp),%eax
    ccf6:	c1 e8 08             	shr    $0x8,%eax
    ccf9:	88 45 ec             	mov    %al,-0x14(%ebp)
    ccfc:	8b 45 0c             	mov    0xc(%ebp),%eax
    ccff:	88 45 ed             	mov    %al,-0x13(%ebp)
    cd02:	8b 45 10             	mov    0x10(%ebp),%eax
    cd05:	c1 e8 08             	shr    $0x8,%eax
    cd08:	88 45 ee             	mov    %al,-0x12(%ebp)
    cd0b:	8b 45 10             	mov    0x10(%ebp),%eax
    cd0e:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cd11:	8b 45 14             	mov    0x14(%ebp),%eax
    cd14:	c1 e8 08             	shr    $0x8,%eax
    cd17:	88 45 f0             	mov    %al,-0x10(%ebp)
    cd1a:	8b 45 14             	mov    0x14(%ebp),%eax
    cd1d:	88 45 f1             	mov    %al,-0xf(%ebp)
    cd20:	8b 45 18             	mov    0x18(%ebp),%eax
    cd23:	c1 e8 08             	shr    $0x8,%eax
    cd26:	88 45 f2             	mov    %al,-0xe(%ebp)
    cd29:	8b 45 18             	mov    0x18(%ebp),%eax
    cd2c:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cd2f:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cd36:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cd3d:	83 ec 0c             	sub    $0xc,%esp
    cd40:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cd43:	50                   	push   %eax
    cd44:	6a 01                	push   $0x1
    cd46:	6a 01                	push   $0x1
    cd48:	8d 45 ec             	lea    -0x14(%ebp),%eax
    cd4b:	50                   	push   %eax
    cd4c:	ff 75 08             	pushl  0x8(%ebp)
    cd4f:	e8 76 f4 ff ff       	call   c1ca <lodepng_compute_color_stats>
    cd54:	83 c4 20             	add    $0x20,%esp
    cd57:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cd5a:	83 ec 0c             	sub    $0xc,%esp
    cd5d:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cd60:	50                   	push   %eax
    cd61:	e8 4e be ff ff       	call   8bb4 <lodepng_color_mode_cleanup>
    cd66:	83 c4 10             	add    $0x10,%esp
  return error;
    cd69:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cd6c:	c9                   	leave  
    cd6d:	c3                   	ret    

0000cd6e <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    cd6e:	55                   	push   %ebp
    cd6f:	89 e5                	mov    %esp,%ebp
    cd71:	56                   	push   %esi
    cd72:	53                   	push   %ebx
    cd73:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cd76:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cd7d:	8b 45 10             	mov    0x10(%ebp),%eax
    cd80:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    cd86:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    cd89:	8b 45 10             	mov    0x10(%ebp),%eax
    cd8c:	8b 40 10             	mov    0x10(%eax),%eax
    cd8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cd92:	8b 45 10             	mov    0x10(%ebp),%eax
    cd95:	8b 40 04             	mov    0x4(%eax),%eax
    cd98:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cd9b:	8b 45 10             	mov    0x10(%ebp),%eax
    cd9e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cda4:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cda7:	8b 45 08             	mov    0x8(%ebp),%eax
    cdaa:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cdb1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cdb5:	74 21                	je     cdd8 <auto_choose_color+0x6a>
    cdb7:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cdbb:	7f 1b                	jg     cdd8 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cdbd:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    cdc4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cdcb:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cdcf:	77 07                	ja     cdd8 <auto_choose_color+0x6a>
    cdd1:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    cdd8:	8b 45 10             	mov    0x10(%ebp),%eax
    cddb:	8b 00                	mov    (%eax),%eax
    cddd:	85 c0                	test   %eax,%eax
    cddf:	0f 94 c0             	sete   %al
    cde2:	0f b6 c0             	movzbl %al,%eax
    cde5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cde8:	8b 45 10             	mov    0x10(%ebp),%eax
    cdeb:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cdf1:	85 c0                	test   %eax,%eax
    cdf3:	75 07                	jne    cdfc <auto_choose_color+0x8e>
    cdf5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    cdfc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ce00:	75 0d                	jne    ce0f <auto_choose_color+0xa1>
    ce02:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    ce06:	77 07                	ja     ce0f <auto_choose_color+0xa1>
    ce08:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    ce0f:	8b 45 10             	mov    0x10(%ebp),%eax
    ce12:	8b 40 14             	mov    0x14(%eax),%eax
    ce15:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    ce18:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    ce1c:	7e 21                	jle    ce3f <auto_choose_color+0xd1>
    ce1e:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    ce22:	7e 14                	jle    ce38 <auto_choose_color+0xca>
    ce24:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    ce28:	7f 07                	jg     ce31 <auto_choose_color+0xc3>
    ce2a:	b8 04 00 00 00       	mov    $0x4,%eax
    ce2f:	eb 13                	jmp    ce44 <auto_choose_color+0xd6>
    ce31:	b8 08 00 00 00       	mov    $0x8,%eax
    ce36:	eb 0c                	jmp    ce44 <auto_choose_color+0xd6>
    ce38:	b8 02 00 00 00       	mov    $0x2,%eax
    ce3d:	eb 05                	jmp    ce44 <auto_choose_color+0xd6>
    ce3f:	b8 01 00 00 00       	mov    $0x1,%eax
    ce44:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    ce47:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    ce4e:	7f 13                	jg     ce63 <auto_choose_color+0xf5>
    ce50:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    ce54:	77 0d                	ja     ce63 <auto_choose_color+0xf5>
    ce56:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    ce5a:	74 07                	je     ce63 <auto_choose_color+0xf5>
    ce5c:	b8 01 00 00 00       	mov    $0x1,%eax
    ce61:	eb 05                	jmp    ce68 <auto_choose_color+0xfa>
    ce63:	b8 00 00 00 00       	mov    $0x0,%eax
    ce68:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    ce6b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ce6e:	01 c0                	add    %eax,%eax
    ce70:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ce73:	7e 07                	jle    ce7c <auto_choose_color+0x10e>
    ce75:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    ce7c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ce80:	74 15                	je     ce97 <auto_choose_color+0x129>
    ce82:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ce86:	75 0f                	jne    ce97 <auto_choose_color+0x129>
    ce88:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ce8b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    ce8e:	77 07                	ja     ce97 <auto_choose_color+0x129>
    ce90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    ce97:	8b 45 10             	mov    0x10(%ebp),%eax
    ce9a:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    cea0:	85 c0                	test   %eax,%eax
    cea2:	75 07                	jne    ceab <auto_choose_color+0x13d>
    cea4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    ceab:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ceaf:	0f 84 0a 01 00 00    	je     cfbf <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    ceb5:	8b 45 10             	mov    0x10(%ebp),%eax
    ceb8:	83 c0 18             	add    $0x18,%eax
    cebb:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    cebe:	83 ec 0c             	sub    $0xc,%esp
    cec1:	ff 75 08             	pushl  0x8(%ebp)
    cec4:	e8 ef be ff ff       	call   8db8 <lodepng_palette_clear>
    cec9:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    cecc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ced3:	eb 6e                	jmp    cf43 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    ced5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ced8:	c1 e0 02             	shl    $0x2,%eax
    cedb:	8d 50 03             	lea    0x3(%eax),%edx
    cede:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cee1:	01 d0                	add    %edx,%eax
    cee3:	0f b6 00             	movzbl (%eax),%eax
    cee6:	0f b6 d8             	movzbl %al,%ebx
    cee9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ceec:	c1 e0 02             	shl    $0x2,%eax
    ceef:	8d 50 02             	lea    0x2(%eax),%edx
    cef2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cef5:	01 d0                	add    %edx,%eax
    cef7:	0f b6 00             	movzbl (%eax),%eax
    cefa:	0f b6 c8             	movzbl %al,%ecx
    cefd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf00:	c1 e0 02             	shl    $0x2,%eax
    cf03:	8d 50 01             	lea    0x1(%eax),%edx
    cf06:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf09:	01 d0                	add    %edx,%eax
    cf0b:	0f b6 00             	movzbl (%eax),%eax
    cf0e:	0f b6 d0             	movzbl %al,%edx
    cf11:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf14:	c1 e0 02             	shl    $0x2,%eax
    cf17:	89 c6                	mov    %eax,%esi
    cf19:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf1c:	01 f0                	add    %esi,%eax
    cf1e:	0f b6 00             	movzbl (%eax),%eax
    cf21:	0f b6 c0             	movzbl %al,%eax
    cf24:	83 ec 0c             	sub    $0xc,%esp
    cf27:	53                   	push   %ebx
    cf28:	51                   	push   %ecx
    cf29:	52                   	push   %edx
    cf2a:	50                   	push   %eax
    cf2b:	ff 75 08             	pushl  0x8(%ebp)
    cf2e:	e8 be be ff ff       	call   8df1 <lodepng_palette_add>
    cf33:	83 c4 20             	add    $0x20,%esp
    cf36:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    cf39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cf3d:	75 13                	jne    cf52 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    cf3f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    cf43:	8b 45 10             	mov    0x10(%ebp),%eax
    cf46:	8b 50 14             	mov    0x14(%eax),%edx
    cf49:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf4c:	39 c2                	cmp    %eax,%edx
    cf4e:	75 85                	jne    ced5 <auto_choose_color+0x167>
    cf50:	eb 01                	jmp    cf53 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    cf52:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    cf53:	8b 45 08             	mov    0x8(%ebp),%eax
    cf56:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    cf5c:	8b 45 08             	mov    0x8(%ebp),%eax
    cf5f:	8b 55 d0             	mov    -0x30(%ebp),%edx
    cf62:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    cf65:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf68:	8b 00                	mov    (%eax),%eax
    cf6a:	83 f8 03             	cmp    $0x3,%eax
    cf6d:	0f 85 ec 00 00 00    	jne    d05f <auto_choose_color+0x2f1>
    cf73:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf76:	8b 50 0c             	mov    0xc(%eax),%edx
    cf79:	8b 45 08             	mov    0x8(%ebp),%eax
    cf7c:	8b 40 0c             	mov    0xc(%eax),%eax
    cf7f:	39 c2                	cmp    %eax,%edx
    cf81:	0f 8c d8 00 00 00    	jl     d05f <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    cf87:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf8a:	8b 50 04             	mov    0x4(%eax),%edx
    cf8d:	8b 45 08             	mov    0x8(%ebp),%eax
    cf90:	8b 40 04             	mov    0x4(%eax),%eax
    cf93:	39 c2                	cmp    %eax,%edx
    cf95:	0f 85 c4 00 00 00    	jne    d05f <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    cf9b:	83 ec 0c             	sub    $0xc,%esp
    cf9e:	ff 75 08             	pushl  0x8(%ebp)
    cfa1:	e8 0e bc ff ff       	call   8bb4 <lodepng_color_mode_cleanup>
    cfa6:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    cfa9:	83 ec 08             	sub    $0x8,%esp
    cfac:	ff 75 0c             	pushl  0xc(%ebp)
    cfaf:	ff 75 08             	pushl  0x8(%ebp)
    cfb2:	e8 14 bc ff ff       	call   8bcb <lodepng_color_mode_copy>
    cfb7:	83 c4 10             	add    $0x10,%esp
    cfba:	e9 a0 00 00 00       	jmp    d05f <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    cfbf:	8b 45 08             	mov    0x8(%ebp),%eax
    cfc2:	8b 55 dc             	mov    -0x24(%ebp),%edx
    cfc5:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    cfc8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cfcc:	74 14                	je     cfe2 <auto_choose_color+0x274>
    cfce:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cfd2:	74 07                	je     cfdb <auto_choose_color+0x26d>
    cfd4:	b8 04 00 00 00       	mov    $0x4,%eax
    cfd9:	eb 19                	jmp    cff4 <auto_choose_color+0x286>
    cfdb:	b8 06 00 00 00       	mov    $0x6,%eax
    cfe0:	eb 12                	jmp    cff4 <auto_choose_color+0x286>
    cfe2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cfe6:	74 07                	je     cfef <auto_choose_color+0x281>
    cfe8:	b8 00 00 00 00       	mov    $0x0,%eax
    cfed:	eb 05                	jmp    cff4 <auto_choose_color+0x286>
    cfef:	b8 02 00 00 00       	mov    $0x2,%eax
    cff4:	8b 55 08             	mov    0x8(%ebp),%edx
    cff7:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    cff9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cffd:	74 60                	je     d05f <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    cfff:	8b 45 08             	mov    0x8(%ebp),%eax
    d002:	8b 40 04             	mov    0x4(%eax),%eax
    d005:	ba 01 00 00 00       	mov    $0x1,%edx
    d00a:	89 c1                	mov    %eax,%ecx
    d00c:	d3 e2                	shl    %cl,%edx
    d00e:	89 d0                	mov    %edx,%eax
    d010:	83 e8 01             	sub    $0x1,%eax
    d013:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d016:	8b 45 10             	mov    0x10(%ebp),%eax
    d019:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d01d:	0f b7 c0             	movzwl %ax,%eax
    d020:	23 45 c8             	and    -0x38(%ebp),%eax
    d023:	89 c2                	mov    %eax,%edx
    d025:	8b 45 08             	mov    0x8(%ebp),%eax
    d028:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d02b:	8b 45 10             	mov    0x10(%ebp),%eax
    d02e:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d032:	0f b7 c0             	movzwl %ax,%eax
    d035:	23 45 c8             	and    -0x38(%ebp),%eax
    d038:	89 c2                	mov    %eax,%edx
    d03a:	8b 45 08             	mov    0x8(%ebp),%eax
    d03d:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d040:	8b 45 10             	mov    0x10(%ebp),%eax
    d043:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d047:	0f b7 c0             	movzwl %ax,%eax
    d04a:	23 45 c8             	and    -0x38(%ebp),%eax
    d04d:	89 c2                	mov    %eax,%edx
    d04f:	8b 45 08             	mov    0x8(%ebp),%eax
    d052:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d055:	8b 45 08             	mov    0x8(%ebp),%eax
    d058:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d05f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d062:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d065:	5b                   	pop    %ebx
    d066:	5e                   	pop    %esi
    d067:	5d                   	pop    %ebp
    d068:	c3                   	ret    

0000d069 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d069:	55                   	push   %ebp
    d06a:	89 e5                	mov    %esp,%ebp
    d06c:	83 ec 1c             	sub    $0x1c,%esp
    d06f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d072:	8b 55 0c             	mov    0xc(%ebp),%edx
    d075:	8b 45 10             	mov    0x10(%ebp),%eax
    d078:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d07c:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d080:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d084:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d088:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d08c:	29 c2                	sub    %eax,%edx
    d08e:	89 d0                	mov    %edx,%eax
    d090:	99                   	cltd   
    d091:	31 d0                	xor    %edx,%eax
    d093:	29 d0                	sub    %edx,%eax
    d095:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d099:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d09d:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0a1:	29 c2                	sub    %eax,%edx
    d0a3:	89 d0                	mov    %edx,%eax
    d0a5:	99                   	cltd   
    d0a6:	31 d0                	xor    %edx,%eax
    d0a8:	29 d0                	sub    %edx,%eax
    d0aa:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d0ae:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d0b2:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d0b6:	01 c2                	add    %eax,%edx
    d0b8:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0bc:	29 c2                	sub    %eax,%edx
    d0be:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0c2:	29 c2                	sub    %eax,%edx
    d0c4:	89 d0                	mov    %edx,%eax
    d0c6:	99                   	cltd   
    d0c7:	31 d0                	xor    %edx,%eax
    d0c9:	29 d0                	sub    %edx,%eax
    d0cb:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d0cf:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d0d3:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d0d7:	7d 10                	jge    d0e9 <paethPredictor+0x80>
    d0d9:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d0dd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d0e1:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d0e5:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d0e9:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d0ed:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d0f1:	7d 06                	jge    d0f9 <paethPredictor+0x90>
    d0f3:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d0f7:	eb 04                	jmp    d0fd <paethPredictor+0x94>
    d0f9:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d0fd:	c9                   	leave  
    d0fe:	c3                   	ret    

0000d0ff <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d0ff:	55                   	push   %ebp
    d100:	89 e5                	mov    %esp,%ebp
    d102:	56                   	push   %esi
    d103:	53                   	push   %ebx
    d104:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d107:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d10e:	e9 e2 00 00 00       	jmp    d1f5 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d113:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d116:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d11d:	8b 45 08             	mov    0x8(%ebp),%eax
    d120:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d123:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d126:	8b 14 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%edx
    d12d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d130:	01 c2                	add    %eax,%edx
    d132:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d135:	8b 04 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%eax
    d13c:	29 c2                	sub    %eax,%edx
    d13e:	89 d0                	mov    %edx,%eax
    d140:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d143:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d146:	8b 34 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%esi
    d14d:	89 d8                	mov    %ebx,%eax
    d14f:	ba 00 00 00 00       	mov    $0x0,%edx
    d154:	f7 f6                	div    %esi
    d156:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d158:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d15b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d162:	8b 45 0c             	mov    0xc(%ebp),%eax
    d165:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d168:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d16b:	8b 14 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%edx
    d172:	8b 45 20             	mov    0x20(%ebp),%eax
    d175:	01 c2                	add    %eax,%edx
    d177:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d17a:	8b 04 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%eax
    d181:	29 c2                	sub    %eax,%edx
    d183:	89 d0                	mov    %edx,%eax
    d185:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d188:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d18b:	8b 34 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%esi
    d192:	89 d8                	mov    %ebx,%eax
    d194:	ba 00 00 00 00       	mov    $0x0,%edx
    d199:	f7 f6                	div    %esi
    d19b:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d19d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1a0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1a7:	8b 45 08             	mov    0x8(%ebp),%eax
    d1aa:	01 d0                	add    %edx,%eax
    d1ac:	8b 00                	mov    (%eax),%eax
    d1ae:	85 c0                	test   %eax,%eax
    d1b0:	75 15                	jne    d1c7 <Adam7_getpassvalues+0xc8>
    d1b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1bf:	01 d0                	add    %edx,%eax
    d1c1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d1c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1d4:	01 d0                	add    %edx,%eax
    d1d6:	8b 00                	mov    (%eax),%eax
    d1d8:	85 c0                	test   %eax,%eax
    d1da:	75 15                	jne    d1f1 <Adam7_getpassvalues+0xf2>
    d1dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    d1e9:	01 d0                	add    %edx,%eax
    d1eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d1f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d1f5:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d1f9:	0f 85 14 ff ff ff    	jne    d113 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d1ff:	8b 45 18             	mov    0x18(%ebp),%eax
    d202:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d208:	8b 45 18             	mov    0x18(%ebp),%eax
    d20b:	8b 10                	mov    (%eax),%edx
    d20d:	8b 45 14             	mov    0x14(%ebp),%eax
    d210:	89 10                	mov    %edx,(%eax)
    d212:	8b 45 14             	mov    0x14(%ebp),%eax
    d215:	8b 10                	mov    (%eax),%edx
    d217:	8b 45 10             	mov    0x10(%ebp),%eax
    d21a:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d21c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d223:	e9 40 01 00 00       	jmp    d368 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d228:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d22b:	83 c0 01             	add    $0x1,%eax
    d22e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d235:	8b 45 10             	mov    0x10(%ebp),%eax
    d238:	01 c2                	add    %eax,%edx
    d23a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d23d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d244:	8b 45 10             	mov    0x10(%ebp),%eax
    d247:	01 c8                	add    %ecx,%eax
    d249:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d24b:	89 c6                	mov    %eax,%esi
    d24d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d250:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d257:	8b 45 08             	mov    0x8(%ebp),%eax
    d25a:	01 c8                	add    %ecx,%eax
    d25c:	8b 00                	mov    (%eax),%eax
    d25e:	85 c0                	test   %eax,%eax
    d260:	74 49                	je     d2ab <Adam7_getpassvalues+0x1ac>
    d262:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d265:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d26c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d26f:	01 c8                	add    %ecx,%eax
    d271:	8b 00                	mov    (%eax),%eax
    d273:	85 c0                	test   %eax,%eax
    d275:	74 34                	je     d2ab <Adam7_getpassvalues+0x1ac>
    d277:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d27a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d281:	8b 45 0c             	mov    0xc(%ebp),%eax
    d284:	01 c8                	add    %ecx,%eax
    d286:	8b 08                	mov    (%eax),%ecx
    d288:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d28b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d292:	8b 45 08             	mov    0x8(%ebp),%eax
    d295:	01 d8                	add    %ebx,%eax
    d297:	8b 00                	mov    (%eax),%eax
    d299:	0f af 45 24          	imul   0x24(%ebp),%eax
    d29d:	83 c0 07             	add    $0x7,%eax
    d2a0:	c1 e8 03             	shr    $0x3,%eax
    d2a3:	83 c0 01             	add    $0x1,%eax
    d2a6:	0f af c1             	imul   %ecx,%eax
    d2a9:	eb 05                	jmp    d2b0 <Adam7_getpassvalues+0x1b1>
    d2ab:	b8 00 00 00 00       	mov    $0x0,%eax
    d2b0:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d2b2:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d2b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2b7:	83 c0 01             	add    $0x1,%eax
    d2ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2c1:	8b 45 14             	mov    0x14(%ebp),%eax
    d2c4:	01 c2                	add    %eax,%edx
    d2c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2c9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2d0:	8b 45 14             	mov    0x14(%ebp),%eax
    d2d3:	01 c8                	add    %ecx,%eax
    d2d5:	8b 00                	mov    (%eax),%eax
    d2d7:	89 c6                	mov    %eax,%esi
    d2d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2dc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2e6:	01 c8                	add    %ecx,%eax
    d2e8:	8b 08                	mov    (%eax),%ecx
    d2ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2ed:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d2f4:	8b 45 08             	mov    0x8(%ebp),%eax
    d2f7:	01 d8                	add    %ebx,%eax
    d2f9:	8b 00                	mov    (%eax),%eax
    d2fb:	0f af 45 24          	imul   0x24(%ebp),%eax
    d2ff:	83 c0 07             	add    $0x7,%eax
    d302:	c1 e8 03             	shr    $0x3,%eax
    d305:	0f af c1             	imul   %ecx,%eax
    d308:	01 f0                	add    %esi,%eax
    d30a:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d30c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d30f:	83 c0 01             	add    $0x1,%eax
    d312:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d319:	8b 45 18             	mov    0x18(%ebp),%eax
    d31c:	01 c2                	add    %eax,%edx
    d31e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d321:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d328:	8b 45 18             	mov    0x18(%ebp),%eax
    d32b:	01 c8                	add    %ecx,%eax
    d32d:	8b 00                	mov    (%eax),%eax
    d32f:	89 c6                	mov    %eax,%esi
    d331:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d334:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d33b:	8b 45 0c             	mov    0xc(%ebp),%eax
    d33e:	01 c8                	add    %ecx,%eax
    d340:	8b 08                	mov    (%eax),%ecx
    d342:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d345:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d34c:	8b 45 08             	mov    0x8(%ebp),%eax
    d34f:	01 d8                	add    %ebx,%eax
    d351:	8b 00                	mov    (%eax),%eax
    d353:	0f af c1             	imul   %ecx,%eax
    d356:	0f af 45 24          	imul   0x24(%ebp),%eax
    d35a:	83 c0 07             	add    $0x7,%eax
    d35d:	c1 e8 03             	shr    $0x3,%eax
    d360:	01 f0                	add    %esi,%eax
    d362:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d364:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d368:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d36c:	0f 85 b6 fe ff ff    	jne    d228 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d372:	90                   	nop
    d373:	83 c4 10             	add    $0x10,%esp
    d376:	5b                   	pop    %ebx
    d377:	5e                   	pop    %esi
    d378:	5d                   	pop    %ebp
    d379:	c3                   	ret    

0000d37a <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d37a:	55                   	push   %ebp
    d37b:	89 e5                	mov    %esp,%ebp
    d37d:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d380:	8b 45 10             	mov    0x10(%ebp),%eax
    d383:	05 98 00 00 00       	add    $0x98,%eax
    d388:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d38b:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d38f:	74 06                	je     d397 <lodepng_inspect+0x1d>
    d391:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d395:	75 17                	jne    d3ae <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d397:	8b 45 10             	mov    0x10(%ebp),%eax
    d39a:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d3a1:	00 00 00 
    d3a4:	b8 30 00 00 00       	mov    $0x30,%eax
    d3a9:	e9 ce 02 00 00       	jmp    d67c <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d3ae:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d3b2:	7f 17                	jg     d3cb <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d3b4:	8b 45 10             	mov    0x10(%ebp),%eax
    d3b7:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d3be:	00 00 00 
    d3c1:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d3c6:	e9 b1 02 00 00       	jmp    d67c <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d3cb:	83 ec 0c             	sub    $0xc,%esp
    d3ce:	ff 75 f4             	pushl  -0xc(%ebp)
    d3d1:	e8 63 c7 ff ff       	call   9b39 <lodepng_info_cleanup>
    d3d6:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d3d9:	83 ec 0c             	sub    $0xc,%esp
    d3dc:	ff 75 f4             	pushl  -0xc(%ebp)
    d3df:	e8 74 c6 ff ff       	call   9a58 <lodepng_info_init>
    d3e4:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d3e7:	8b 45 14             	mov    0x14(%ebp),%eax
    d3ea:	0f b6 00             	movzbl (%eax),%eax
    d3ed:	3c 89                	cmp    $0x89,%al
    d3ef:	75 5b                	jne    d44c <lodepng_inspect+0xd2>
    d3f1:	8b 45 14             	mov    0x14(%ebp),%eax
    d3f4:	83 c0 01             	add    $0x1,%eax
    d3f7:	0f b6 00             	movzbl (%eax),%eax
    d3fa:	3c 50                	cmp    $0x50,%al
    d3fc:	75 4e                	jne    d44c <lodepng_inspect+0xd2>
    d3fe:	8b 45 14             	mov    0x14(%ebp),%eax
    d401:	83 c0 02             	add    $0x2,%eax
    d404:	0f b6 00             	movzbl (%eax),%eax
    d407:	3c 4e                	cmp    $0x4e,%al
    d409:	75 41                	jne    d44c <lodepng_inspect+0xd2>
    d40b:	8b 45 14             	mov    0x14(%ebp),%eax
    d40e:	83 c0 03             	add    $0x3,%eax
    d411:	0f b6 00             	movzbl (%eax),%eax
    d414:	3c 47                	cmp    $0x47,%al
    d416:	75 34                	jne    d44c <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d418:	8b 45 14             	mov    0x14(%ebp),%eax
    d41b:	83 c0 04             	add    $0x4,%eax
    d41e:	0f b6 00             	movzbl (%eax),%eax
    d421:	3c 0d                	cmp    $0xd,%al
    d423:	75 27                	jne    d44c <lodepng_inspect+0xd2>
    d425:	8b 45 14             	mov    0x14(%ebp),%eax
    d428:	83 c0 05             	add    $0x5,%eax
    d42b:	0f b6 00             	movzbl (%eax),%eax
    d42e:	3c 0a                	cmp    $0xa,%al
    d430:	75 1a                	jne    d44c <lodepng_inspect+0xd2>
    d432:	8b 45 14             	mov    0x14(%ebp),%eax
    d435:	83 c0 06             	add    $0x6,%eax
    d438:	0f b6 00             	movzbl (%eax),%eax
    d43b:	3c 1a                	cmp    $0x1a,%al
    d43d:	75 0d                	jne    d44c <lodepng_inspect+0xd2>
    d43f:	8b 45 14             	mov    0x14(%ebp),%eax
    d442:	83 c0 07             	add    $0x7,%eax
    d445:	0f b6 00             	movzbl (%eax),%eax
    d448:	3c 0a                	cmp    $0xa,%al
    d44a:	74 17                	je     d463 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d44c:	8b 45 10             	mov    0x10(%ebp),%eax
    d44f:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d456:	00 00 00 
    d459:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d45e:	e9 19 02 00 00       	jmp    d67c <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d463:	8b 45 14             	mov    0x14(%ebp),%eax
    d466:	83 c0 08             	add    $0x8,%eax
    d469:	83 ec 0c             	sub    $0xc,%esp
    d46c:	50                   	push   %eax
    d46d:	e8 c2 ae ff ff       	call   8334 <lodepng_chunk_length>
    d472:	83 c4 10             	add    $0x10,%esp
    d475:	83 f8 0d             	cmp    $0xd,%eax
    d478:	74 17                	je     d491 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d47a:	8b 45 10             	mov    0x10(%ebp),%eax
    d47d:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d484:	00 00 00 
    d487:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d48c:	e9 eb 01 00 00       	jmp    d67c <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d491:	8b 45 14             	mov    0x14(%ebp),%eax
    d494:	83 c0 08             	add    $0x8,%eax
    d497:	83 ec 08             	sub    $0x8,%esp
    d49a:	68 2c a1 01 00       	push   $0x1a12c
    d49f:	50                   	push   %eax
    d4a0:	e8 dc ae ff ff       	call   8381 <lodepng_chunk_type_equals>
    d4a5:	83 c4 10             	add    $0x10,%esp
    d4a8:	84 c0                	test   %al,%al
    d4aa:	75 17                	jne    d4c3 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d4ac:	8b 45 10             	mov    0x10(%ebp),%eax
    d4af:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d4b6:	00 00 00 
    d4b9:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d4be:	e9 b9 01 00 00       	jmp    d67c <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d4c3:	8b 45 14             	mov    0x14(%ebp),%eax
    d4c6:	83 c0 10             	add    $0x10,%eax
    d4c9:	83 ec 0c             	sub    $0xc,%esp
    d4cc:	50                   	push   %eax
    d4cd:	e8 5e 62 ff ff       	call   3730 <lodepng_read32bitInt>
    d4d2:	83 c4 10             	add    $0x10,%esp
    d4d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d4d8:	8b 45 14             	mov    0x14(%ebp),%eax
    d4db:	83 c0 14             	add    $0x14,%eax
    d4de:	83 ec 0c             	sub    $0xc,%esp
    d4e1:	50                   	push   %eax
    d4e2:	e8 49 62 ff ff       	call   3730 <lodepng_read32bitInt>
    d4e7:	83 c4 10             	add    $0x10,%esp
    d4ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d4ed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d4f1:	74 08                	je     d4fb <lodepng_inspect+0x181>
    d4f3:	8b 45 08             	mov    0x8(%ebp),%eax
    d4f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d4f9:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d4fb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d4ff:	74 08                	je     d509 <lodepng_inspect+0x18f>
    d501:	8b 45 0c             	mov    0xc(%ebp),%eax
    d504:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d507:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d509:	8b 45 14             	mov    0x14(%ebp),%eax
    d50c:	83 c0 18             	add    $0x18,%eax
    d50f:	0f b6 00             	movzbl (%eax),%eax
    d512:	0f b6 d0             	movzbl %al,%edx
    d515:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d518:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d51b:	8b 45 14             	mov    0x14(%ebp),%eax
    d51e:	83 c0 19             	add    $0x19,%eax
    d521:	0f b6 00             	movzbl (%eax),%eax
    d524:	0f b6 d0             	movzbl %al,%edx
    d527:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d52a:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d52d:	8b 45 14             	mov    0x14(%ebp),%eax
    d530:	83 c0 1a             	add    $0x1a,%eax
    d533:	0f b6 00             	movzbl (%eax),%eax
    d536:	0f b6 d0             	movzbl %al,%edx
    d539:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d53c:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d53e:	8b 45 14             	mov    0x14(%ebp),%eax
    d541:	83 c0 1b             	add    $0x1b,%eax
    d544:	0f b6 00             	movzbl (%eax),%eax
    d547:	0f b6 d0             	movzbl %al,%edx
    d54a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d54d:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d550:	8b 45 14             	mov    0x14(%ebp),%eax
    d553:	83 c0 1c             	add    $0x1c,%eax
    d556:	0f b6 00             	movzbl (%eax),%eax
    d559:	0f b6 d0             	movzbl %al,%edx
    d55c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d55f:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d562:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d566:	74 06                	je     d56e <lodepng_inspect+0x1f4>
    d568:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d56c:	75 17                	jne    d585 <lodepng_inspect+0x20b>
    d56e:	8b 45 10             	mov    0x10(%ebp),%eax
    d571:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d578:	00 00 00 
    d57b:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d580:	e9 f7 00 00 00       	jmp    d67c <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d585:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d588:	8b 50 10             	mov    0x10(%eax),%edx
    d58b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d58e:	8b 40 0c             	mov    0xc(%eax),%eax
    d591:	83 ec 08             	sub    $0x8,%esp
    d594:	52                   	push   %edx
    d595:	50                   	push   %eax
    d596:	e8 d4 b3 ff ff       	call   896f <checkColorValidity>
    d59b:	83 c4 10             	add    $0x10,%esp
    d59e:	89 c2                	mov    %eax,%edx
    d5a0:	8b 45 10             	mov    0x10(%ebp),%eax
    d5a3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d5a9:	8b 45 10             	mov    0x10(%ebp),%eax
    d5ac:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d5b2:	85 c0                	test   %eax,%eax
    d5b4:	74 0e                	je     d5c4 <lodepng_inspect+0x24a>
    d5b6:	8b 45 10             	mov    0x10(%ebp),%eax
    d5b9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d5bf:	e9 b8 00 00 00       	jmp    d67c <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d5c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5c7:	8b 00                	mov    (%eax),%eax
    d5c9:	85 c0                	test   %eax,%eax
    d5cb:	74 17                	je     d5e4 <lodepng_inspect+0x26a>
    d5cd:	8b 45 10             	mov    0x10(%ebp),%eax
    d5d0:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d5d7:	00 00 00 
    d5da:	b8 20 00 00 00       	mov    $0x20,%eax
    d5df:	e9 98 00 00 00       	jmp    d67c <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d5e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5e7:	8b 40 04             	mov    0x4(%eax),%eax
    d5ea:	85 c0                	test   %eax,%eax
    d5ec:	74 14                	je     d602 <lodepng_inspect+0x288>
    d5ee:	8b 45 10             	mov    0x10(%ebp),%eax
    d5f1:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d5f8:	00 00 00 
    d5fb:	b8 21 00 00 00       	mov    $0x21,%eax
    d600:	eb 7a                	jmp    d67c <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d602:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d605:	8b 40 08             	mov    0x8(%eax),%eax
    d608:	83 f8 01             	cmp    $0x1,%eax
    d60b:	76 14                	jbe    d621 <lodepng_inspect+0x2a7>
    d60d:	8b 45 10             	mov    0x10(%ebp),%eax
    d610:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d617:	00 00 00 
    d61a:	b8 22 00 00 00       	mov    $0x22,%eax
    d61f:	eb 5b                	jmp    d67c <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d621:	8b 45 10             	mov    0x10(%ebp),%eax
    d624:	8b 40 18             	mov    0x18(%eax),%eax
    d627:	85 c0                	test   %eax,%eax
    d629:	75 48                	jne    d673 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d62b:	8b 45 14             	mov    0x14(%ebp),%eax
    d62e:	83 c0 1d             	add    $0x1d,%eax
    d631:	83 ec 0c             	sub    $0xc,%esp
    d634:	50                   	push   %eax
    d635:	e8 f6 60 ff ff       	call   3730 <lodepng_read32bitInt>
    d63a:	83 c4 10             	add    $0x10,%esp
    d63d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d640:	8b 45 14             	mov    0x14(%ebp),%eax
    d643:	83 c0 0c             	add    $0xc,%eax
    d646:	83 ec 08             	sub    $0x8,%esp
    d649:	6a 11                	push   $0x11
    d64b:	50                   	push   %eax
    d64c:	e8 71 ab ff ff       	call   81c2 <lodepng_crc32>
    d651:	83 c4 10             	add    $0x10,%esp
    d654:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d657:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d65a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d65d:	74 14                	je     d673 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d65f:	8b 45 10             	mov    0x10(%ebp),%eax
    d662:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d669:	00 00 00 
    d66c:	b8 39 00 00 00       	mov    $0x39,%eax
    d671:	eb 09                	jmp    d67c <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d673:	8b 45 10             	mov    0x10(%ebp),%eax
    d676:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d67c:	c9                   	leave  
    d67d:	c3                   	ret    

0000d67e <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d67e:	55                   	push   %ebp
    d67f:	89 e5                	mov    %esp,%ebp
    d681:	56                   	push   %esi
    d682:	53                   	push   %ebx
    d683:	83 ec 44             	sub    $0x44,%esp
    d686:	8b 45 18             	mov    0x18(%ebp),%eax
    d689:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d68c:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d690:	83 f8 04             	cmp    $0x4,%eax
    d693:	0f 87 81 07 00 00    	ja     de1a <unfilterScanline+0x79c>
    d699:	8b 04 85 34 a1 01 00 	mov    0x1a134(,%eax,4),%eax
    d6a0:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d6a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6a9:	eb 19                	jmp    d6c4 <unfilterScanline+0x46>
    d6ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6ae:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b1:	01 c2                	add    %eax,%edx
    d6b3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6b9:	01 c8                	add    %ecx,%eax
    d6bb:	0f b6 00             	movzbl (%eax),%eax
    d6be:	88 02                	mov    %al,(%edx)
    d6c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6c7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6ca:	75 df                	jne    d6ab <unfilterScanline+0x2d>
      break;
    d6cc:	e9 50 07 00 00       	jmp    de21 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d6d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6d8:	eb 19                	jmp    d6f3 <unfilterScanline+0x75>
    d6da:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6dd:	8b 45 08             	mov    0x8(%ebp),%eax
    d6e0:	01 c2                	add    %eax,%edx
    d6e2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6e8:	01 c8                	add    %ecx,%eax
    d6ea:	0f b6 00             	movzbl (%eax),%eax
    d6ed:	88 02                	mov    %al,(%edx)
    d6ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6f6:	3b 45 14             	cmp    0x14(%ebp),%eax
    d6f9:	75 df                	jne    d6da <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d6fb:	8b 45 14             	mov    0x14(%ebp),%eax
    d6fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d701:	eb 2b                	jmp    d72e <unfilterScanline+0xb0>
    d703:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d706:	8b 45 08             	mov    0x8(%ebp),%eax
    d709:	01 c2                	add    %eax,%edx
    d70b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d70e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d711:	01 c8                	add    %ecx,%eax
    d713:	0f b6 08             	movzbl (%eax),%ecx
    d716:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d719:	2b 45 14             	sub    0x14(%ebp),%eax
    d71c:	89 c3                	mov    %eax,%ebx
    d71e:	8b 45 08             	mov    0x8(%ebp),%eax
    d721:	01 d8                	add    %ebx,%eax
    d723:	0f b6 00             	movzbl (%eax),%eax
    d726:	01 c8                	add    %ecx,%eax
    d728:	88 02                	mov    %al,(%edx)
    d72a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d72e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d731:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d734:	7c cd                	jl     d703 <unfilterScanline+0x85>
      break;
    d736:	e9 e6 06 00 00       	jmp    de21 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d73b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d73f:	74 3c                	je     d77d <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d741:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d748:	eb 26                	jmp    d770 <unfilterScanline+0xf2>
    d74a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d74d:	8b 45 08             	mov    0x8(%ebp),%eax
    d750:	01 d0                	add    %edx,%eax
    d752:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d755:	8b 55 0c             	mov    0xc(%ebp),%edx
    d758:	01 ca                	add    %ecx,%edx
    d75a:	0f b6 0a             	movzbl (%edx),%ecx
    d75d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d760:	8b 55 10             	mov    0x10(%ebp),%edx
    d763:	01 da                	add    %ebx,%edx
    d765:	0f b6 12             	movzbl (%edx),%edx
    d768:	01 ca                	add    %ecx,%edx
    d76a:	88 10                	mov    %dl,(%eax)
    d76c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d770:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d773:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d776:	75 d2                	jne    d74a <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d778:	e9 a4 06 00 00       	jmp    de21 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d77d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d784:	eb 19                	jmp    d79f <unfilterScanline+0x121>
    d786:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d789:	8b 45 08             	mov    0x8(%ebp),%eax
    d78c:	01 c2                	add    %eax,%edx
    d78e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d791:	8b 45 0c             	mov    0xc(%ebp),%eax
    d794:	01 c8                	add    %ecx,%eax
    d796:	0f b6 00             	movzbl (%eax),%eax
    d799:	88 02                	mov    %al,(%edx)
    d79b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d79f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7a2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7a5:	75 df                	jne    d786 <unfilterScanline+0x108>
      }
      break;
    d7a7:	e9 75 06 00 00       	jmp    de21 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d7ac:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d7b0:	0f 84 8e 00 00 00    	je     d844 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d7b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7bd:	eb 28                	jmp    d7e7 <unfilterScanline+0x169>
    d7bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d7c5:	01 d0                	add    %edx,%eax
    d7c7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    d7cd:	01 ca                	add    %ecx,%edx
    d7cf:	0f b6 12             	movzbl (%edx),%edx
    d7d2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d7d5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d7d8:	01 d9                	add    %ebx,%ecx
    d7da:	0f b6 09             	movzbl (%ecx),%ecx
    d7dd:	d0 e9                	shr    %cl
    d7df:	01 ca                	add    %ecx,%edx
    d7e1:	88 10                	mov    %dl,(%eax)
    d7e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7ea:	3b 45 14             	cmp    0x14(%ebp),%eax
    d7ed:	75 d0                	jne    d7bf <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d7ef:	8b 45 14             	mov    0x14(%ebp),%eax
    d7f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d7f5:	eb 40                	jmp    d837 <unfilterScanline+0x1b9>
    d7f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7fa:	8b 45 08             	mov    0x8(%ebp),%eax
    d7fd:	01 c2                	add    %eax,%edx
    d7ff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d802:	8b 45 0c             	mov    0xc(%ebp),%eax
    d805:	01 c8                	add    %ecx,%eax
    d807:	0f b6 08             	movzbl (%eax),%ecx
    d80a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d80d:	2b 45 14             	sub    0x14(%ebp),%eax
    d810:	89 c3                	mov    %eax,%ebx
    d812:	8b 45 08             	mov    0x8(%ebp),%eax
    d815:	01 d8                	add    %ebx,%eax
    d817:	0f b6 00             	movzbl (%eax),%eax
    d81a:	0f b6 d8             	movzbl %al,%ebx
    d81d:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d820:	8b 45 10             	mov    0x10(%ebp),%eax
    d823:	01 f0                	add    %esi,%eax
    d825:	0f b6 00             	movzbl (%eax),%eax
    d828:	0f b6 c0             	movzbl %al,%eax
    d82b:	01 d8                	add    %ebx,%eax
    d82d:	d1 f8                	sar    %eax
    d82f:	01 c8                	add    %ecx,%eax
    d831:	88 02                	mov    %al,(%edx)
    d833:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d837:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d83a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d83d:	7c b8                	jl     d7f7 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d83f:	e9 dd 05 00 00       	jmp    de21 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d844:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d84b:	eb 19                	jmp    d866 <unfilterScanline+0x1e8>
    d84d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d850:	8b 45 08             	mov    0x8(%ebp),%eax
    d853:	01 c2                	add    %eax,%edx
    d855:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d858:	8b 45 0c             	mov    0xc(%ebp),%eax
    d85b:	01 c8                	add    %ecx,%eax
    d85d:	0f b6 00             	movzbl (%eax),%eax
    d860:	88 02                	mov    %al,(%edx)
    d862:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d866:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d869:	3b 45 14             	cmp    0x14(%ebp),%eax
    d86c:	75 df                	jne    d84d <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d86e:	8b 45 14             	mov    0x14(%ebp),%eax
    d871:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d874:	eb 2d                	jmp    d8a3 <unfilterScanline+0x225>
    d876:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d879:	8b 45 08             	mov    0x8(%ebp),%eax
    d87c:	01 c2                	add    %eax,%edx
    d87e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d881:	8b 45 0c             	mov    0xc(%ebp),%eax
    d884:	01 c8                	add    %ecx,%eax
    d886:	0f b6 08             	movzbl (%eax),%ecx
    d889:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d88c:	2b 45 14             	sub    0x14(%ebp),%eax
    d88f:	89 c3                	mov    %eax,%ebx
    d891:	8b 45 08             	mov    0x8(%ebp),%eax
    d894:	01 d8                	add    %ebx,%eax
    d896:	0f b6 00             	movzbl (%eax),%eax
    d899:	d0 e8                	shr    %al
    d89b:	01 c8                	add    %ecx,%eax
    d89d:	88 02                	mov    %al,(%edx)
    d89f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8a6:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d8a9:	7c cb                	jl     d876 <unfilterScanline+0x1f8>
      }
      break;
    d8ab:	e9 71 05 00 00       	jmp    de21 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d8b0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d8b4:	0f 84 f9 04 00 00    	je     ddb3 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d8ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d8c1:	eb 26                	jmp    d8e9 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d8c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8c6:	8b 45 08             	mov    0x8(%ebp),%eax
    d8c9:	01 d0                	add    %edx,%eax
    d8cb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d8ce:	8b 55 0c             	mov    0xc(%ebp),%edx
    d8d1:	01 ca                	add    %ecx,%edx
    d8d3:	0f b6 0a             	movzbl (%edx),%ecx
    d8d6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d8d9:	8b 55 10             	mov    0x10(%ebp),%edx
    d8dc:	01 da                	add    %ebx,%edx
    d8de:	0f b6 12             	movzbl (%edx),%edx
    d8e1:	01 ca                	add    %ecx,%edx
    d8e3:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d8e5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8ec:	3b 45 14             	cmp    0x14(%ebp),%eax
    d8ef:	75 d2                	jne    d8c3 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d8f1:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d8f5:	0f 8e db 01 00 00    	jle    dad6 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d8fb:	e9 c2 01 00 00       	jmp    dac2 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d900:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d903:	2b 45 14             	sub    0x14(%ebp),%eax
    d906:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d909:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d90c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d90f:	01 d0                	add    %edx,%eax
    d911:	0f b6 00             	movzbl (%eax),%eax
    d914:	88 45 ef             	mov    %al,-0x11(%ebp)
    d917:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d91a:	8d 50 01             	lea    0x1(%eax),%edx
    d91d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d920:	01 d0                	add    %edx,%eax
    d922:	0f b6 00             	movzbl (%eax),%eax
    d925:	88 45 ee             	mov    %al,-0x12(%ebp)
    d928:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d92b:	8d 50 02             	lea    0x2(%eax),%edx
    d92e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d931:	01 d0                	add    %edx,%eax
    d933:	0f b6 00             	movzbl (%eax),%eax
    d936:	88 45 ed             	mov    %al,-0x13(%ebp)
    d939:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d93c:	8d 50 03             	lea    0x3(%eax),%edx
    d93f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d942:	01 d0                	add    %edx,%eax
    d944:	0f b6 00             	movzbl (%eax),%eax
    d947:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d94a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d94d:	8b 45 08             	mov    0x8(%ebp),%eax
    d950:	01 d0                	add    %edx,%eax
    d952:	0f b6 00             	movzbl (%eax),%eax
    d955:	88 45 eb             	mov    %al,-0x15(%ebp)
    d958:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d95b:	8d 50 01             	lea    0x1(%eax),%edx
    d95e:	8b 45 08             	mov    0x8(%ebp),%eax
    d961:	01 d0                	add    %edx,%eax
    d963:	0f b6 00             	movzbl (%eax),%eax
    d966:	88 45 ea             	mov    %al,-0x16(%ebp)
    d969:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d96c:	8d 50 02             	lea    0x2(%eax),%edx
    d96f:	8b 45 08             	mov    0x8(%ebp),%eax
    d972:	01 d0                	add    %edx,%eax
    d974:	0f b6 00             	movzbl (%eax),%eax
    d977:	88 45 e9             	mov    %al,-0x17(%ebp)
    d97a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d97d:	8d 50 03             	lea    0x3(%eax),%edx
    d980:	8b 45 08             	mov    0x8(%ebp),%eax
    d983:	01 d0                	add    %edx,%eax
    d985:	0f b6 00             	movzbl (%eax),%eax
    d988:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d98b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d98e:	8b 45 10             	mov    0x10(%ebp),%eax
    d991:	01 d0                	add    %edx,%eax
    d993:	0f b6 00             	movzbl (%eax),%eax
    d996:	88 45 e7             	mov    %al,-0x19(%ebp)
    d999:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d99c:	8d 50 01             	lea    0x1(%eax),%edx
    d99f:	8b 45 10             	mov    0x10(%ebp),%eax
    d9a2:	01 d0                	add    %edx,%eax
    d9a4:	0f b6 00             	movzbl (%eax),%eax
    d9a7:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d9aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9ad:	8d 50 02             	lea    0x2(%eax),%edx
    d9b0:	8b 45 10             	mov    0x10(%ebp),%eax
    d9b3:	01 d0                	add    %edx,%eax
    d9b5:	0f b6 00             	movzbl (%eax),%eax
    d9b8:	88 45 e5             	mov    %al,-0x1b(%ebp)
    d9bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9be:	8d 50 03             	lea    0x3(%eax),%edx
    d9c1:	8b 45 10             	mov    0x10(%ebp),%eax
    d9c4:	01 d0                	add    %edx,%eax
    d9c6:	0f b6 00             	movzbl (%eax),%eax
    d9c9:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    d9cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d9cf:	8b 45 10             	mov    0x10(%ebp),%eax
    d9d2:	01 d0                	add    %edx,%eax
    d9d4:	0f b6 00             	movzbl (%eax),%eax
    d9d7:	88 45 e3             	mov    %al,-0x1d(%ebp)
    d9da:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9dd:	8d 50 01             	lea    0x1(%eax),%edx
    d9e0:	8b 45 10             	mov    0x10(%ebp),%eax
    d9e3:	01 d0                	add    %edx,%eax
    d9e5:	0f b6 00             	movzbl (%eax),%eax
    d9e8:	88 45 e2             	mov    %al,-0x1e(%ebp)
    d9eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9ee:	8d 50 02             	lea    0x2(%eax),%edx
    d9f1:	8b 45 10             	mov    0x10(%ebp),%eax
    d9f4:	01 d0                	add    %edx,%eax
    d9f6:	0f b6 00             	movzbl (%eax),%eax
    d9f9:	88 45 e1             	mov    %al,-0x1f(%ebp)
    d9fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9ff:	8d 50 03             	lea    0x3(%eax),%edx
    da02:	8b 45 10             	mov    0x10(%ebp),%eax
    da05:	01 d0                	add    %edx,%eax
    da07:	0f b6 00             	movzbl (%eax),%eax
    da0a:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    da0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da10:	8b 45 08             	mov    0x8(%ebp),%eax
    da13:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da16:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    da1a:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    da1e:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    da22:	51                   	push   %ecx
    da23:	52                   	push   %edx
    da24:	50                   	push   %eax
    da25:	e8 3f f6 ff ff       	call   d069 <paethPredictor>
    da2a:	83 c4 0c             	add    $0xc,%esp
    da2d:	89 c2                	mov    %eax,%edx
    da2f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    da33:	01 d0                	add    %edx,%eax
    da35:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    da37:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da3a:	8d 50 01             	lea    0x1(%eax),%edx
    da3d:	8b 45 08             	mov    0x8(%ebp),%eax
    da40:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da43:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    da47:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    da4b:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    da4f:	51                   	push   %ecx
    da50:	52                   	push   %edx
    da51:	50                   	push   %eax
    da52:	e8 12 f6 ff ff       	call   d069 <paethPredictor>
    da57:	83 c4 0c             	add    $0xc,%esp
    da5a:	89 c2                	mov    %eax,%edx
    da5c:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    da60:	01 d0                	add    %edx,%eax
    da62:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    da64:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da67:	8d 50 02             	lea    0x2(%eax),%edx
    da6a:	8b 45 08             	mov    0x8(%ebp),%eax
    da6d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da70:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    da74:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    da78:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    da7c:	51                   	push   %ecx
    da7d:	52                   	push   %edx
    da7e:	50                   	push   %eax
    da7f:	e8 e5 f5 ff ff       	call   d069 <paethPredictor>
    da84:	83 c4 0c             	add    $0xc,%esp
    da87:	89 c2                	mov    %eax,%edx
    da89:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    da8d:	01 d0                	add    %edx,%eax
    da8f:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    da91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da94:	8d 50 03             	lea    0x3(%eax),%edx
    da97:	8b 45 08             	mov    0x8(%ebp),%eax
    da9a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da9d:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    daa1:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    daa5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    daa9:	51                   	push   %ecx
    daaa:	52                   	push   %edx
    daab:	50                   	push   %eax
    daac:	e8 b8 f5 ff ff       	call   d069 <paethPredictor>
    dab1:	83 c4 0c             	add    $0xc,%esp
    dab4:	89 c2                	mov    %eax,%edx
    dab6:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    daba:	01 d0                	add    %edx,%eax
    dabc:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    dabe:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    dac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dac5:	83 c0 03             	add    $0x3,%eax
    dac8:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dacb:	0f 8c 2f fe ff ff    	jl     d900 <unfilterScanline+0x282>
    dad1:	e9 d3 02 00 00       	jmp    dda9 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    dad6:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    dada:	0f 8e 6a 01 00 00    	jle    dc4a <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    dae0:	e9 51 01 00 00       	jmp    dc36 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    dae5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dae8:	2b 45 14             	sub    0x14(%ebp),%eax
    daeb:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    daee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    daf1:	8b 45 0c             	mov    0xc(%ebp),%eax
    daf4:	01 d0                	add    %edx,%eax
    daf6:	0f b6 00             	movzbl (%eax),%eax
    daf9:	88 45 db             	mov    %al,-0x25(%ebp)
    dafc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daff:	8d 50 01             	lea    0x1(%eax),%edx
    db02:	8b 45 0c             	mov    0xc(%ebp),%eax
    db05:	01 d0                	add    %edx,%eax
    db07:	0f b6 00             	movzbl (%eax),%eax
    db0a:	88 45 da             	mov    %al,-0x26(%ebp)
    db0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db10:	8d 50 02             	lea    0x2(%eax),%edx
    db13:	8b 45 0c             	mov    0xc(%ebp),%eax
    db16:	01 d0                	add    %edx,%eax
    db18:	0f b6 00             	movzbl (%eax),%eax
    db1b:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    db1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    db21:	8b 45 08             	mov    0x8(%ebp),%eax
    db24:	01 d0                	add    %edx,%eax
    db26:	0f b6 00             	movzbl (%eax),%eax
    db29:	88 45 d8             	mov    %al,-0x28(%ebp)
    db2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db2f:	8d 50 01             	lea    0x1(%eax),%edx
    db32:	8b 45 08             	mov    0x8(%ebp),%eax
    db35:	01 d0                	add    %edx,%eax
    db37:	0f b6 00             	movzbl (%eax),%eax
    db3a:	88 45 d7             	mov    %al,-0x29(%ebp)
    db3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db40:	8d 50 02             	lea    0x2(%eax),%edx
    db43:	8b 45 08             	mov    0x8(%ebp),%eax
    db46:	01 d0                	add    %edx,%eax
    db48:	0f b6 00             	movzbl (%eax),%eax
    db4b:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    db4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db51:	8b 45 10             	mov    0x10(%ebp),%eax
    db54:	01 d0                	add    %edx,%eax
    db56:	0f b6 00             	movzbl (%eax),%eax
    db59:	88 45 d5             	mov    %al,-0x2b(%ebp)
    db5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db5f:	8d 50 01             	lea    0x1(%eax),%edx
    db62:	8b 45 10             	mov    0x10(%ebp),%eax
    db65:	01 d0                	add    %edx,%eax
    db67:	0f b6 00             	movzbl (%eax),%eax
    db6a:	88 45 d4             	mov    %al,-0x2c(%ebp)
    db6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db70:	8d 50 02             	lea    0x2(%eax),%edx
    db73:	8b 45 10             	mov    0x10(%ebp),%eax
    db76:	01 d0                	add    %edx,%eax
    db78:	0f b6 00             	movzbl (%eax),%eax
    db7b:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    db7e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    db81:	8b 45 10             	mov    0x10(%ebp),%eax
    db84:	01 d0                	add    %edx,%eax
    db86:	0f b6 00             	movzbl (%eax),%eax
    db89:	88 45 d2             	mov    %al,-0x2e(%ebp)
    db8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db8f:	8d 50 01             	lea    0x1(%eax),%edx
    db92:	8b 45 10             	mov    0x10(%ebp),%eax
    db95:	01 d0                	add    %edx,%eax
    db97:	0f b6 00             	movzbl (%eax),%eax
    db9a:	88 45 d1             	mov    %al,-0x2f(%ebp)
    db9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dba0:	8d 50 02             	lea    0x2(%eax),%edx
    dba3:	8b 45 10             	mov    0x10(%ebp),%eax
    dba6:	01 d0                	add    %edx,%eax
    dba8:	0f b6 00             	movzbl (%eax),%eax
    dbab:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dbae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbb1:	8b 45 08             	mov    0x8(%ebp),%eax
    dbb4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dbb7:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    dbbb:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    dbbf:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    dbc3:	51                   	push   %ecx
    dbc4:	52                   	push   %edx
    dbc5:	50                   	push   %eax
    dbc6:	e8 9e f4 ff ff       	call   d069 <paethPredictor>
    dbcb:	83 c4 0c             	add    $0xc,%esp
    dbce:	89 c2                	mov    %eax,%edx
    dbd0:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    dbd4:	01 d0                	add    %edx,%eax
    dbd6:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dbd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbdb:	8d 50 01             	lea    0x1(%eax),%edx
    dbde:	8b 45 08             	mov    0x8(%ebp),%eax
    dbe1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dbe4:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    dbe8:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    dbec:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    dbf0:	51                   	push   %ecx
    dbf1:	52                   	push   %edx
    dbf2:	50                   	push   %eax
    dbf3:	e8 71 f4 ff ff       	call   d069 <paethPredictor>
    dbf8:	83 c4 0c             	add    $0xc,%esp
    dbfb:	89 c2                	mov    %eax,%edx
    dbfd:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    dc01:	01 d0                	add    %edx,%eax
    dc03:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dc05:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc08:	8d 50 02             	lea    0x2(%eax),%edx
    dc0b:	8b 45 08             	mov    0x8(%ebp),%eax
    dc0e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc11:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    dc15:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    dc19:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    dc1d:	51                   	push   %ecx
    dc1e:	52                   	push   %edx
    dc1f:	50                   	push   %eax
    dc20:	e8 44 f4 ff ff       	call   d069 <paethPredictor>
    dc25:	83 c4 0c             	add    $0xc,%esp
    dc28:	89 c2                	mov    %eax,%edx
    dc2a:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    dc2e:	01 d0                	add    %edx,%eax
    dc30:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    dc32:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    dc36:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc39:	83 c0 02             	add    $0x2,%eax
    dc3c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dc3f:	0f 8c a0 fe ff ff    	jl     dae5 <unfilterScanline+0x467>
    dc45:	e9 5f 01 00 00       	jmp    dda9 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dc4a:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dc4e:	0f 8e 55 01 00 00    	jle    dda9 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dc54:	e9 e0 00 00 00       	jmp    dd39 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dc59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc5c:	2b 45 14             	sub    0x14(%ebp),%eax
    dc5f:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dc62:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc65:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc68:	01 d0                	add    %edx,%eax
    dc6a:	0f b6 00             	movzbl (%eax),%eax
    dc6d:	88 45 cb             	mov    %al,-0x35(%ebp)
    dc70:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc73:	8d 50 01             	lea    0x1(%eax),%edx
    dc76:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc79:	01 d0                	add    %edx,%eax
    dc7b:	0f b6 00             	movzbl (%eax),%eax
    dc7e:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dc81:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dc84:	8b 45 08             	mov    0x8(%ebp),%eax
    dc87:	01 d0                	add    %edx,%eax
    dc89:	0f b6 00             	movzbl (%eax),%eax
    dc8c:	88 45 c9             	mov    %al,-0x37(%ebp)
    dc8f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc92:	8d 50 01             	lea    0x1(%eax),%edx
    dc95:	8b 45 08             	mov    0x8(%ebp),%eax
    dc98:	01 d0                	add    %edx,%eax
    dc9a:	0f b6 00             	movzbl (%eax),%eax
    dc9d:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dca0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dca3:	8b 45 10             	mov    0x10(%ebp),%eax
    dca6:	01 d0                	add    %edx,%eax
    dca8:	0f b6 00             	movzbl (%eax),%eax
    dcab:	88 45 c7             	mov    %al,-0x39(%ebp)
    dcae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcb1:	8d 50 01             	lea    0x1(%eax),%edx
    dcb4:	8b 45 10             	mov    0x10(%ebp),%eax
    dcb7:	01 d0                	add    %edx,%eax
    dcb9:	0f b6 00             	movzbl (%eax),%eax
    dcbc:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dcbf:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dcc2:	8b 45 10             	mov    0x10(%ebp),%eax
    dcc5:	01 d0                	add    %edx,%eax
    dcc7:	0f b6 00             	movzbl (%eax),%eax
    dcca:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dccd:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dcd0:	8d 50 01             	lea    0x1(%eax),%edx
    dcd3:	8b 45 10             	mov    0x10(%ebp),%eax
    dcd6:	01 d0                	add    %edx,%eax
    dcd8:	0f b6 00             	movzbl (%eax),%eax
    dcdb:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dcde:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dce1:	8b 45 08             	mov    0x8(%ebp),%eax
    dce4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dce7:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dceb:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dcef:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dcf3:	51                   	push   %ecx
    dcf4:	52                   	push   %edx
    dcf5:	50                   	push   %eax
    dcf6:	e8 6e f3 ff ff       	call   d069 <paethPredictor>
    dcfb:	83 c4 0c             	add    $0xc,%esp
    dcfe:	89 c2                	mov    %eax,%edx
    dd00:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dd04:	01 d0                	add    %edx,%eax
    dd06:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dd08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd0b:	8d 50 01             	lea    0x1(%eax),%edx
    dd0e:	8b 45 08             	mov    0x8(%ebp),%eax
    dd11:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd14:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dd18:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dd1c:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dd20:	51                   	push   %ecx
    dd21:	52                   	push   %edx
    dd22:	50                   	push   %eax
    dd23:	e8 41 f3 ff ff       	call   d069 <paethPredictor>
    dd28:	83 c4 0c             	add    $0xc,%esp
    dd2b:	89 c2                	mov    %eax,%edx
    dd2d:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dd31:	01 d0                	add    %edx,%eax
    dd33:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dd35:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dd39:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd3c:	83 c0 01             	add    $0x1,%eax
    dd3f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd42:	0f 8c 11 ff ff ff    	jl     dc59 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dd48:	eb 5f                	jmp    dda9 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dd4a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd4d:	8b 45 08             	mov    0x8(%ebp),%eax
    dd50:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd53:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd56:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd59:	01 d0                	add    %edx,%eax
    dd5b:	0f b6 00             	movzbl (%eax),%eax
    dd5e:	88 45 b7             	mov    %al,-0x49(%ebp)
    dd61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd64:	2b 45 14             	sub    0x14(%ebp),%eax
    dd67:	89 c2                	mov    %eax,%edx
    dd69:	8b 45 10             	mov    0x10(%ebp),%eax
    dd6c:	01 d0                	add    %edx,%eax
    dd6e:	0f b6 00             	movzbl (%eax),%eax
    dd71:	0f b6 c8             	movzbl %al,%ecx
    dd74:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd77:	8b 45 10             	mov    0x10(%ebp),%eax
    dd7a:	01 d0                	add    %edx,%eax
    dd7c:	0f b6 00             	movzbl (%eax),%eax
    dd7f:	0f b6 d0             	movzbl %al,%edx
    dd82:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd85:	2b 45 14             	sub    0x14(%ebp),%eax
    dd88:	89 c6                	mov    %eax,%esi
    dd8a:	8b 45 08             	mov    0x8(%ebp),%eax
    dd8d:	01 f0                	add    %esi,%eax
    dd8f:	0f b6 00             	movzbl (%eax),%eax
    dd92:	0f b6 c0             	movzbl %al,%eax
    dd95:	51                   	push   %ecx
    dd96:	52                   	push   %edx
    dd97:	50                   	push   %eax
    dd98:	e8 cc f2 ff ff       	call   d069 <paethPredictor>
    dd9d:	83 c4 0c             	add    $0xc,%esp
    dda0:	02 45 b7             	add    -0x49(%ebp),%al
    dda3:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dda5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dda9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddac:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ddaf:	75 99                	jne    dd4a <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    ddb1:	eb 6e                	jmp    de21 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    ddb3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ddba:	eb 19                	jmp    ddd5 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    ddbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddbf:	8b 45 08             	mov    0x8(%ebp),%eax
    ddc2:	01 c2                	add    %eax,%edx
    ddc4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ddc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddca:	01 c8                	add    %ecx,%eax
    ddcc:	0f b6 00             	movzbl (%eax),%eax
    ddcf:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    ddd1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ddd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddd8:	3b 45 14             	cmp    0x14(%ebp),%eax
    dddb:	75 df                	jne    ddbc <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dddd:	8b 45 14             	mov    0x14(%ebp),%eax
    dde0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dde3:	eb 2b                	jmp    de10 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    dde5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dde8:	8b 45 08             	mov    0x8(%ebp),%eax
    ddeb:	01 c2                	add    %eax,%edx
    dded:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ddf0:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddf3:	01 c8                	add    %ecx,%eax
    ddf5:	0f b6 08             	movzbl (%eax),%ecx
    ddf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddfb:	2b 45 14             	sub    0x14(%ebp),%eax
    ddfe:	89 c3                	mov    %eax,%ebx
    de00:	8b 45 08             	mov    0x8(%ebp),%eax
    de03:	01 d8                	add    %ebx,%eax
    de05:	0f b6 00             	movzbl (%eax),%eax
    de08:	01 c8                	add    %ecx,%eax
    de0a:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    de0c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de13:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de16:	7c cd                	jl     dde5 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    de18:	eb 07                	jmp    de21 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    de1a:	b8 24 00 00 00       	mov    $0x24,%eax
    de1f:	eb 05                	jmp    de26 <unfilterScanline+0x7a8>
  }
  return 0;
    de21:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de26:	8d 65 f8             	lea    -0x8(%ebp),%esp
    de29:	5b                   	pop    %ebx
    de2a:	5e                   	pop    %esi
    de2b:	5d                   	pop    %ebp
    de2c:	c3                   	ret    

0000de2d <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de2d:	55                   	push   %ebp
    de2e:	89 e5                	mov    %esp,%ebp
    de30:	53                   	push   %ebx
    de31:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    de34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    de3b:	8b 45 18             	mov    0x18(%ebp),%eax
    de3e:	83 c0 07             	add    $0x7,%eax
    de41:	c1 e8 03             	shr    $0x3,%eax
    de44:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    de47:	ff 75 18             	pushl  0x18(%ebp)
    de4a:	6a 01                	push   $0x1
    de4c:	ff 75 10             	pushl  0x10(%ebp)
    de4f:	e8 d9 b1 ff ff       	call   902d <lodepng_get_raw_size_idat>
    de54:	83 c4 0c             	add    $0xc,%esp
    de57:	83 e8 01             	sub    $0x1,%eax
    de5a:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    de5d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    de64:	eb 6d                	jmp    ded3 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    de66:	8b 45 ec             	mov    -0x14(%ebp),%eax
    de69:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    de6d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    de70:	8b 45 ec             	mov    -0x14(%ebp),%eax
    de73:	83 c0 01             	add    $0x1,%eax
    de76:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    de7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    de7d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    de80:	8b 45 0c             	mov    0xc(%ebp),%eax
    de83:	01 d0                	add    %edx,%eax
    de85:	0f b6 00             	movzbl (%eax),%eax
    de88:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    de8b:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    de8f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    de92:	8d 4a 01             	lea    0x1(%edx),%ecx
    de95:	8b 55 0c             	mov    0xc(%ebp),%edx
    de98:	01 d1                	add    %edx,%ecx
    de9a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    de9d:	8b 55 08             	mov    0x8(%ebp),%edx
    dea0:	01 da                	add    %ebx,%edx
    dea2:	ff 75 ec             	pushl  -0x14(%ebp)
    dea5:	50                   	push   %eax
    dea6:	ff 75 f0             	pushl  -0x10(%ebp)
    dea9:	ff 75 f4             	pushl  -0xc(%ebp)
    deac:	51                   	push   %ecx
    dead:	52                   	push   %edx
    deae:	e8 cb f7 ff ff       	call   d67e <unfilterScanline>
    deb3:	83 c4 18             	add    $0x18,%esp
    deb6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    deb9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    debd:	74 05                	je     dec4 <unfilter+0x97>
    debf:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dec2:	eb 1c                	jmp    dee0 <unfilter+0xb3>

    prevline = &out[outindex];
    dec4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    dec7:	8b 45 08             	mov    0x8(%ebp),%eax
    deca:	01 d0                	add    %edx,%eax
    decc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    decf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ded3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ded6:	3b 45 14             	cmp    0x14(%ebp),%eax
    ded9:	72 8b                	jb     de66 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    dedb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dee0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    dee3:	c9                   	leave  
    dee4:	c3                   	ret    

0000dee5 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    dee5:	55                   	push   %ebp
    dee6:	89 e5                	mov    %esp,%ebp
    dee8:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    deee:	ff 75 18             	pushl  0x18(%ebp)
    def1:	ff 75 14             	pushl  0x14(%ebp)
    def4:	ff 75 10             	pushl  0x10(%ebp)
    def7:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    defd:	50                   	push   %eax
    defe:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    df04:	50                   	push   %eax
    df05:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    df0b:	50                   	push   %eax
    df0c:	8d 45 94             	lea    -0x6c(%ebp),%eax
    df0f:	50                   	push   %eax
    df10:	8d 45 b0             	lea    -0x50(%ebp),%eax
    df13:	50                   	push   %eax
    df14:	e8 e6 f1 ff ff       	call   d0ff <Adam7_getpassvalues>
    df19:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    df1c:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    df20:	0f 86 0a 01 00 00    	jbe    e030 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    df26:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    df2d:	e9 ef 00 00 00       	jmp    e021 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    df32:	8b 45 18             	mov    0x18(%ebp),%eax
    df35:	c1 e8 03             	shr    $0x3,%eax
    df38:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    df3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    df42:	e9 c6 00 00 00       	jmp    e00d <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    df47:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    df4e:	e9 a6 00 00 00       	jmp    dff9 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    df53:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df56:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    df5d:	89 c1                	mov    %eax,%ecx
    df5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df62:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df66:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    df6a:	89 c2                	mov    %eax,%edx
    df6c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    df6f:	01 c2                	add    %eax,%edx
    df71:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df74:	0f af c2             	imul   %edx,%eax
    df77:	01 c8                	add    %ecx,%eax
    df79:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    df7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df7f:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
    df86:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df89:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
    df90:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    df94:	01 d0                	add    %edx,%eax
    df96:	0f af 45 10          	imul   0x10(%ebp),%eax
    df9a:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    df9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df9f:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
    dfa6:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    dfaa:	01 c2                	add    %eax,%edx
    dfac:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfaf:	8b 04 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%eax
    dfb6:	01 c2                	add    %eax,%edx
    dfb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dfbb:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    dfbe:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    dfc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    dfc8:	eb 23                	jmp    dfed <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    dfca:	8b 55 d8             	mov    -0x28(%ebp),%edx
    dfcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dfd0:	01 c2                	add    %eax,%edx
    dfd2:	8b 45 08             	mov    0x8(%ebp),%eax
    dfd5:	01 c2                	add    %eax,%edx
    dfd7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    dfda:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dfdd:	01 c1                	add    %eax,%ecx
    dfdf:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfe2:	01 c8                	add    %ecx,%eax
    dfe4:	0f b6 00             	movzbl (%eax),%eax
    dfe7:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    dfe9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    dfed:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dff0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    dff3:	72 d5                	jb     dfca <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    dff5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    dff9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dffc:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e000:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e003:	0f 87 4a ff ff ff    	ja     df53 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e009:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e00d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e010:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e014:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e017:	0f 87 2a ff ff ff    	ja     df47 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e01d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e021:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e025:	0f 85 07 ff ff ff    	jne    df32 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e02b:	e9 22 01 00 00       	jmp    e152 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e030:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e037:	e9 0c 01 00 00       	jmp    e148 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e03c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e03f:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e043:	0f af 45 18          	imul   0x18(%ebp),%eax
    e047:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e04a:	8b 45 18             	mov    0x18(%ebp),%eax
    e04d:	0f af 45 10          	imul   0x10(%ebp),%eax
    e051:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e054:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e05b:	e9 d4 00 00 00       	jmp    e134 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e060:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e067:	e9 b4 00 00 00       	jmp    e120 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e06c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e06f:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e076:	c1 e0 03             	shl    $0x3,%eax
    e079:	89 c1                	mov    %eax,%ecx
    e07b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e07e:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e082:	89 c2                	mov    %eax,%edx
    e084:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e087:	0f af 45 18          	imul   0x18(%ebp),%eax
    e08b:	01 d0                	add    %edx,%eax
    e08d:	01 c8                	add    %ecx,%eax
    e08f:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e095:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e098:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
    e09f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0a2:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
    e0a9:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e0ad:	01 d0                	add    %edx,%eax
    e0af:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e0b3:	89 c2                	mov    %eax,%edx
    e0b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0b8:	8b 0c 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%ecx
    e0bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0c2:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
    e0c9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e0cd:	01 c8                	add    %ecx,%eax
    e0cf:	0f af 45 18          	imul   0x18(%ebp),%eax
    e0d3:	01 d0                	add    %edx,%eax
    e0d5:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e0db:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e0e2:	eb 30                	jmp    e114 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e0e4:	ff 75 0c             	pushl  0xc(%ebp)
    e0e7:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e0ed:	50                   	push   %eax
    e0ee:	e8 1e a1 ff ff       	call   8211 <readBitFromReversedStream>
    e0f3:	83 c4 08             	add    $0x8,%esp
    e0f6:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e0f9:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e0fd:	50                   	push   %eax
    e0fe:	ff 75 08             	pushl  0x8(%ebp)
    e101:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e107:	50                   	push   %eax
    e108:	e8 86 a1 ff ff       	call   8293 <setBitOfReversedStream>
    e10d:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e110:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e114:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e117:	3b 45 18             	cmp    0x18(%ebp),%eax
    e11a:	72 c8                	jb     e0e4 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e11c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e120:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e123:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e127:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e12a:	0f 87 3c ff ff ff    	ja     e06c <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e130:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e134:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e137:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e13b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e13e:	0f 87 1c ff ff ff    	ja     e060 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e144:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e148:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e14c:	0f 85 ea fe ff ff    	jne    e03c <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e152:	90                   	nop
    e153:	c9                   	leave  
    e154:	c3                   	ret    

0000e155 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e155:	55                   	push   %ebp
    e156:	89 e5                	mov    %esp,%ebp
    e158:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e15b:	8b 45 14             	mov    0x14(%ebp),%eax
    e15e:	2b 45 10             	sub    0x10(%ebp),%eax
    e161:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e164:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e16b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e172:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e179:	eb 4a                	jmp    e1c5 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e17b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e182:	eb 2a                	jmp    e1ae <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e184:	ff 75 0c             	pushl  0xc(%ebp)
    e187:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e18a:	50                   	push   %eax
    e18b:	e8 81 a0 ff ff       	call   8211 <readBitFromReversedStream>
    e190:	83 c4 08             	add    $0x8,%esp
    e193:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e196:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e19a:	50                   	push   %eax
    e19b:	ff 75 08             	pushl  0x8(%ebp)
    e19e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e1a1:	50                   	push   %eax
    e1a2:	e8 ec a0 ff ff       	call   8293 <setBitOfReversedStream>
    e1a7:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e1aa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e1ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e1b1:	3b 45 10             	cmp    0x10(%ebp),%eax
    e1b4:	7c ce                	jl     e184 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e1b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e1b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1bc:	01 d0                	add    %edx,%eax
    e1be:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e1c1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e1c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1c8:	3b 45 18             	cmp    0x18(%ebp),%eax
    e1cb:	72 ae                	jb     e17b <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e1cd:	90                   	nop
    e1ce:	c9                   	leave  
    e1cf:	c3                   	ret    

0000e1d0 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e1d0:	55                   	push   %ebp
    e1d1:	89 e5                	mov    %esp,%ebp
    e1d3:	57                   	push   %edi
    e1d4:	56                   	push   %esi
    e1d5:	53                   	push   %ebx
    e1d6:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e1dc:	8b 45 18             	mov    0x18(%ebp),%eax
    e1df:	83 c0 0c             	add    $0xc,%eax
    e1e2:	50                   	push   %eax
    e1e3:	e8 e6 ac ff ff       	call   8ece <lodepng_get_bpp>
    e1e8:	83 c4 04             	add    $0x4,%esp
    e1eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e1ee:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e1f2:	75 0a                	jne    e1fe <postProcessScanlines+0x2e>
    e1f4:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e1f9:	e9 c3 01 00 00       	jmp    e3c1 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e1fe:	8b 45 18             	mov    0x18(%ebp),%eax
    e201:	8b 40 08             	mov    0x8(%eax),%eax
    e204:	85 c0                	test   %eax,%eax
    e206:	0f 85 a8 00 00 00    	jne    e2b4 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e20c:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e210:	77 76                	ja     e288 <postProcessScanlines+0xb8>
    e212:	8b 45 10             	mov    0x10(%ebp),%eax
    e215:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e219:	89 c2                	mov    %eax,%edx
    e21b:	8b 45 10             	mov    0x10(%ebp),%eax
    e21e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e222:	83 c0 07             	add    $0x7,%eax
    e225:	c1 e8 03             	shr    $0x3,%eax
    e228:	c1 e0 03             	shl    $0x3,%eax
    e22b:	39 c2                	cmp    %eax,%edx
    e22d:	74 59                	je     e288 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e22f:	ff 75 ec             	pushl  -0x14(%ebp)
    e232:	ff 75 14             	pushl  0x14(%ebp)
    e235:	ff 75 10             	pushl  0x10(%ebp)
    e238:	ff 75 0c             	pushl  0xc(%ebp)
    e23b:	ff 75 0c             	pushl  0xc(%ebp)
    e23e:	e8 ea fb ff ff       	call   de2d <unfilter>
    e243:	83 c4 14             	add    $0x14,%esp
    e246:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e249:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e24d:	74 08                	je     e257 <postProcessScanlines+0x87>
    e24f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e252:	e9 6a 01 00 00       	jmp    e3c1 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e257:	8b 45 10             	mov    0x10(%ebp),%eax
    e25a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e25e:	83 c0 07             	add    $0x7,%eax
    e261:	c1 e8 03             	shr    $0x3,%eax
    e264:	c1 e0 03             	shl    $0x3,%eax
    e267:	89 c2                	mov    %eax,%edx
    e269:	8b 45 10             	mov    0x10(%ebp),%eax
    e26c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e270:	ff 75 14             	pushl  0x14(%ebp)
    e273:	52                   	push   %edx
    e274:	50                   	push   %eax
    e275:	ff 75 0c             	pushl  0xc(%ebp)
    e278:	ff 75 08             	pushl  0x8(%ebp)
    e27b:	e8 d5 fe ff ff       	call   e155 <removePaddingBits>
    e280:	83 c4 14             	add    $0x14,%esp
    e283:	e9 34 01 00 00       	jmp    e3bc <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e288:	ff 75 ec             	pushl  -0x14(%ebp)
    e28b:	ff 75 14             	pushl  0x14(%ebp)
    e28e:	ff 75 10             	pushl  0x10(%ebp)
    e291:	ff 75 0c             	pushl  0xc(%ebp)
    e294:	ff 75 08             	pushl  0x8(%ebp)
    e297:	e8 91 fb ff ff       	call   de2d <unfilter>
    e29c:	83 c4 14             	add    $0x14,%esp
    e29f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e2a2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e2a6:	0f 84 10 01 00 00    	je     e3bc <postProcessScanlines+0x1ec>
    e2ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e2af:	e9 0d 01 00 00       	jmp    e3c1 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e2b4:	ff 75 ec             	pushl  -0x14(%ebp)
    e2b7:	ff 75 14             	pushl  0x14(%ebp)
    e2ba:	ff 75 10             	pushl  0x10(%ebp)
    e2bd:	8d 45 88             	lea    -0x78(%ebp),%eax
    e2c0:	50                   	push   %eax
    e2c1:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e2c7:	50                   	push   %eax
    e2c8:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e2ce:	50                   	push   %eax
    e2cf:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e2d2:	50                   	push   %eax
    e2d3:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e2d6:	50                   	push   %eax
    e2d7:	e8 23 ee ff ff       	call   d0ff <Adam7_getpassvalues>
    e2dc:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e2df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e2e6:	e9 b0 00 00 00       	jmp    e39b <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e2eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2ee:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e2f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2f5:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e2f9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e2fc:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e303:	89 cb                	mov    %ecx,%ebx
    e305:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e308:	01 cb                	add    %ecx,%ebx
    e30a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e30d:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e314:	89 ce                	mov    %ecx,%esi
    e316:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e319:	01 f1                	add    %esi,%ecx
    e31b:	ff 75 ec             	pushl  -0x14(%ebp)
    e31e:	52                   	push   %edx
    e31f:	50                   	push   %eax
    e320:	53                   	push   %ebx
    e321:	51                   	push   %ecx
    e322:	e8 06 fb ff ff       	call   de2d <unfilter>
    e327:	83 c4 14             	add    $0x14,%esp
    e32a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e32d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e331:	74 08                	je     e33b <postProcessScanlines+0x16b>
    e333:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e336:	e9 86 00 00 00       	jmp    e3c1 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e33b:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e33f:	77 56                	ja     e397 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e341:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e344:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e348:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e34b:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e34f:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e353:	83 c2 07             	add    $0x7,%edx
    e356:	c1 ea 03             	shr    $0x3,%edx
    e359:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e35c:	89 d6                	mov    %edx,%esi
    e35e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e361:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e365:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e369:	89 d3                	mov    %edx,%ebx
    e36b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e36e:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e375:	89 d1                	mov    %edx,%ecx
    e377:	8b 55 0c             	mov    0xc(%ebp),%edx
    e37a:	01 d1                	add    %edx,%ecx
    e37c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e37f:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e383:	89 d7                	mov    %edx,%edi
    e385:	8b 55 0c             	mov    0xc(%ebp),%edx
    e388:	01 fa                	add    %edi,%edx
    e38a:	50                   	push   %eax
    e38b:	56                   	push   %esi
    e38c:	53                   	push   %ebx
    e38d:	51                   	push   %ecx
    e38e:	52                   	push   %edx
    e38f:	e8 c1 fd ff ff       	call   e155 <removePaddingBits>
    e394:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e397:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e39b:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e39f:	0f 85 46 ff ff ff    	jne    e2eb <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e3a5:	ff 75 ec             	pushl  -0x14(%ebp)
    e3a8:	ff 75 14             	pushl  0x14(%ebp)
    e3ab:	ff 75 10             	pushl  0x10(%ebp)
    e3ae:	ff 75 0c             	pushl  0xc(%ebp)
    e3b1:	ff 75 08             	pushl  0x8(%ebp)
    e3b4:	e8 2c fb ff ff       	call   dee5 <Adam7_deinterlace>
    e3b9:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e3bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e3c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e3c4:	5b                   	pop    %ebx
    e3c5:	5e                   	pop    %esi
    e3c6:	5f                   	pop    %edi
    e3c7:	5d                   	pop    %ebp
    e3c8:	c3                   	ret    

0000e3c9 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e3c9:	55                   	push   %ebp
    e3ca:	89 e5                	mov    %esp,%ebp
    e3cc:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e3cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e3d6:	8b 45 10             	mov    0x10(%ebp),%eax
    e3d9:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e3de:	f7 e2                	mul    %edx
    e3e0:	89 d0                	mov    %edx,%eax
    e3e2:	d1 e8                	shr    %eax
    e3e4:	89 c2                	mov    %eax,%edx
    e3e6:	8b 45 08             	mov    0x8(%ebp),%eax
    e3e9:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e3ec:	8b 45 08             	mov    0x8(%ebp),%eax
    e3ef:	8b 40 0c             	mov    0xc(%eax),%eax
    e3f2:	85 c0                	test   %eax,%eax
    e3f4:	74 0d                	je     e403 <readChunk_PLTE+0x3a>
    e3f6:	8b 45 08             	mov    0x8(%ebp),%eax
    e3f9:	8b 40 0c             	mov    0xc(%eax),%eax
    e3fc:	3d 00 01 00 00       	cmp    $0x100,%eax
    e401:	7e 0a                	jle    e40d <readChunk_PLTE+0x44>
    e403:	b8 26 00 00 00       	mov    $0x26,%eax
    e408:	e9 da 00 00 00       	jmp    e4e7 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e40d:	83 ec 0c             	sub    $0xc,%esp
    e410:	ff 75 08             	pushl  0x8(%ebp)
    e413:	e8 02 a7 ff ff       	call   8b1a <lodepng_color_mode_alloc_palette>
    e418:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e41b:	8b 45 08             	mov    0x8(%ebp),%eax
    e41e:	8b 40 08             	mov    0x8(%eax),%eax
    e421:	85 c0                	test   %eax,%eax
    e423:	75 1e                	jne    e443 <readChunk_PLTE+0x7a>
    e425:	8b 45 08             	mov    0x8(%ebp),%eax
    e428:	8b 40 0c             	mov    0xc(%eax),%eax
    e42b:	85 c0                	test   %eax,%eax
    e42d:	74 14                	je     e443 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e42f:	8b 45 08             	mov    0x8(%ebp),%eax
    e432:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e439:	b8 53 00 00 00       	mov    $0x53,%eax
    e43e:	e9 a4 00 00 00       	jmp    e4e7 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e443:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e44a:	e9 84 00 00 00       	jmp    e4d3 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e44f:	8b 45 08             	mov    0x8(%ebp),%eax
    e452:	8b 40 08             	mov    0x8(%eax),%eax
    e455:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e458:	c1 e2 02             	shl    $0x2,%edx
    e45b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e45e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e461:	8d 50 01             	lea    0x1(%eax),%edx
    e464:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e467:	8b 55 0c             	mov    0xc(%ebp),%edx
    e46a:	01 d0                	add    %edx,%eax
    e46c:	0f b6 00             	movzbl (%eax),%eax
    e46f:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e471:	8b 45 08             	mov    0x8(%ebp),%eax
    e474:	8b 40 08             	mov    0x8(%eax),%eax
    e477:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e47a:	c1 e2 02             	shl    $0x2,%edx
    e47d:	83 c2 01             	add    $0x1,%edx
    e480:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e483:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e486:	8d 50 01             	lea    0x1(%eax),%edx
    e489:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e48c:	8b 55 0c             	mov    0xc(%ebp),%edx
    e48f:	01 d0                	add    %edx,%eax
    e491:	0f b6 00             	movzbl (%eax),%eax
    e494:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e496:	8b 45 08             	mov    0x8(%ebp),%eax
    e499:	8b 40 08             	mov    0x8(%eax),%eax
    e49c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e49f:	c1 e2 02             	shl    $0x2,%edx
    e4a2:	83 c2 02             	add    $0x2,%edx
    e4a5:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e4a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4ab:	8d 50 01             	lea    0x1(%eax),%edx
    e4ae:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e4b1:	8b 55 0c             	mov    0xc(%ebp),%edx
    e4b4:	01 d0                	add    %edx,%eax
    e4b6:	0f b6 00             	movzbl (%eax),%eax
    e4b9:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e4bb:	8b 45 08             	mov    0x8(%ebp),%eax
    e4be:	8b 40 08             	mov    0x8(%eax),%eax
    e4c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e4c4:	c1 e2 02             	shl    $0x2,%edx
    e4c7:	83 c2 03             	add    $0x3,%edx
    e4ca:	01 d0                	add    %edx,%eax
    e4cc:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e4cf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e4d3:	8b 45 08             	mov    0x8(%ebp),%eax
    e4d6:	8b 40 0c             	mov    0xc(%eax),%eax
    e4d9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e4dc:	0f 85 6d ff ff ff    	jne    e44f <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e4e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e4e7:	c9                   	leave  
    e4e8:	c3                   	ret    

0000e4e9 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e4e9:	55                   	push   %ebp
    e4ea:	89 e5                	mov    %esp,%ebp
    e4ec:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e4ef:	8b 45 08             	mov    0x8(%ebp),%eax
    e4f2:	8b 00                	mov    (%eax),%eax
    e4f4:	83 f8 03             	cmp    $0x3,%eax
    e4f7:	75 4d                	jne    e546 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e4f9:	8b 45 08             	mov    0x8(%ebp),%eax
    e4fc:	8b 40 0c             	mov    0xc(%eax),%eax
    e4ff:	3b 45 10             	cmp    0x10(%ebp),%eax
    e502:	7d 0a                	jge    e50e <readChunk_tRNS+0x25>
    e504:	b8 27 00 00 00       	mov    $0x27,%eax
    e509:	e9 3c 01 00 00       	jmp    e64a <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e50e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e515:	eb 22                	jmp    e539 <readChunk_tRNS+0x50>
    e517:	8b 45 08             	mov    0x8(%ebp),%eax
    e51a:	8b 40 08             	mov    0x8(%eax),%eax
    e51d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e520:	c1 e2 02             	shl    $0x2,%edx
    e523:	83 c2 03             	add    $0x3,%edx
    e526:	01 c2                	add    %eax,%edx
    e528:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e52b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e52e:	01 c8                	add    %ecx,%eax
    e530:	0f b6 00             	movzbl (%eax),%eax
    e533:	88 02                	mov    %al,(%edx)
    e535:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e539:	8b 45 10             	mov    0x10(%ebp),%eax
    e53c:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e53f:	75 d6                	jne    e517 <readChunk_tRNS+0x2e>
    e541:	e9 ff 00 00 00       	jmp    e645 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e546:	8b 45 08             	mov    0x8(%ebp),%eax
    e549:	8b 00                	mov    (%eax),%eax
    e54b:	85 c0                	test   %eax,%eax
    e54d:	75 59                	jne    e5a8 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e54f:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e553:	74 0a                	je     e55f <readChunk_tRNS+0x76>
    e555:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e55a:	e9 eb 00 00 00       	jmp    e64a <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e55f:	8b 45 08             	mov    0x8(%ebp),%eax
    e562:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e569:	8b 45 0c             	mov    0xc(%ebp),%eax
    e56c:	0f b6 00             	movzbl (%eax),%eax
    e56f:	0f b6 c0             	movzbl %al,%eax
    e572:	c1 e0 08             	shl    $0x8,%eax
    e575:	89 c2                	mov    %eax,%edx
    e577:	8b 45 0c             	mov    0xc(%ebp),%eax
    e57a:	83 c0 01             	add    $0x1,%eax
    e57d:	0f b6 00             	movzbl (%eax),%eax
    e580:	0f b6 c0             	movzbl %al,%eax
    e583:	01 c2                	add    %eax,%edx
    e585:	8b 45 08             	mov    0x8(%ebp),%eax
    e588:	89 50 1c             	mov    %edx,0x1c(%eax)
    e58b:	8b 45 08             	mov    0x8(%ebp),%eax
    e58e:	8b 50 1c             	mov    0x1c(%eax),%edx
    e591:	8b 45 08             	mov    0x8(%ebp),%eax
    e594:	89 50 18             	mov    %edx,0x18(%eax)
    e597:	8b 45 08             	mov    0x8(%ebp),%eax
    e59a:	8b 50 18             	mov    0x18(%eax),%edx
    e59d:	8b 45 08             	mov    0x8(%ebp),%eax
    e5a0:	89 50 14             	mov    %edx,0x14(%eax)
    e5a3:	e9 9d 00 00 00       	jmp    e645 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e5a8:	8b 45 08             	mov    0x8(%ebp),%eax
    e5ab:	8b 00                	mov    (%eax),%eax
    e5ad:	83 f8 02             	cmp    $0x2,%eax
    e5b0:	0f 85 88 00 00 00    	jne    e63e <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e5b6:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e5ba:	74 0a                	je     e5c6 <readChunk_tRNS+0xdd>
    e5bc:	b8 29 00 00 00       	mov    $0x29,%eax
    e5c1:	e9 84 00 00 00       	jmp    e64a <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e5c6:	8b 45 08             	mov    0x8(%ebp),%eax
    e5c9:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e5d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5d3:	0f b6 00             	movzbl (%eax),%eax
    e5d6:	0f b6 c0             	movzbl %al,%eax
    e5d9:	c1 e0 08             	shl    $0x8,%eax
    e5dc:	89 c2                	mov    %eax,%edx
    e5de:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5e1:	83 c0 01             	add    $0x1,%eax
    e5e4:	0f b6 00             	movzbl (%eax),%eax
    e5e7:	0f b6 c0             	movzbl %al,%eax
    e5ea:	01 c2                	add    %eax,%edx
    e5ec:	8b 45 08             	mov    0x8(%ebp),%eax
    e5ef:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e5f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5f5:	83 c0 02             	add    $0x2,%eax
    e5f8:	0f b6 00             	movzbl (%eax),%eax
    e5fb:	0f b6 c0             	movzbl %al,%eax
    e5fe:	c1 e0 08             	shl    $0x8,%eax
    e601:	89 c2                	mov    %eax,%edx
    e603:	8b 45 0c             	mov    0xc(%ebp),%eax
    e606:	83 c0 03             	add    $0x3,%eax
    e609:	0f b6 00             	movzbl (%eax),%eax
    e60c:	0f b6 c0             	movzbl %al,%eax
    e60f:	01 c2                	add    %eax,%edx
    e611:	8b 45 08             	mov    0x8(%ebp),%eax
    e614:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e617:	8b 45 0c             	mov    0xc(%ebp),%eax
    e61a:	83 c0 04             	add    $0x4,%eax
    e61d:	0f b6 00             	movzbl (%eax),%eax
    e620:	0f b6 c0             	movzbl %al,%eax
    e623:	c1 e0 08             	shl    $0x8,%eax
    e626:	89 c2                	mov    %eax,%edx
    e628:	8b 45 0c             	mov    0xc(%ebp),%eax
    e62b:	83 c0 05             	add    $0x5,%eax
    e62e:	0f b6 00             	movzbl (%eax),%eax
    e631:	0f b6 c0             	movzbl %al,%eax
    e634:	01 c2                	add    %eax,%edx
    e636:	8b 45 08             	mov    0x8(%ebp),%eax
    e639:	89 50 1c             	mov    %edx,0x1c(%eax)
    e63c:	eb 07                	jmp    e645 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e63e:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e643:	eb 05                	jmp    e64a <readChunk_tRNS+0x161>

  return 0; /* OK */
    e645:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e64a:	c9                   	leave  
    e64b:	c3                   	ret    

0000e64c <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e64c:	55                   	push   %ebp
    e64d:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e64f:	8b 45 08             	mov    0x8(%ebp),%eax
    e652:	8b 40 0c             	mov    0xc(%eax),%eax
    e655:	83 f8 03             	cmp    $0x3,%eax
    e658:	75 63                	jne    e6bd <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e65a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e65e:	74 0a                	je     e66a <readChunk_bKGD+0x1e>
    e660:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e665:	e9 63 01 00 00       	jmp    e7cd <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e66a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e66d:	0f b6 00             	movzbl (%eax),%eax
    e670:	0f b6 d0             	movzbl %al,%edx
    e673:	8b 45 08             	mov    0x8(%ebp),%eax
    e676:	8b 40 18             	mov    0x18(%eax),%eax
    e679:	39 c2                	cmp    %eax,%edx
    e67b:	7c 0a                	jl     e687 <readChunk_bKGD+0x3b>
    e67d:	b8 67 00 00 00       	mov    $0x67,%eax
    e682:	e9 46 01 00 00       	jmp    e7cd <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e687:	8b 45 08             	mov    0x8(%ebp),%eax
    e68a:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e691:	8b 45 0c             	mov    0xc(%ebp),%eax
    e694:	0f b6 00             	movzbl (%eax),%eax
    e697:	0f b6 d0             	movzbl %al,%edx
    e69a:	8b 45 08             	mov    0x8(%ebp),%eax
    e69d:	89 50 38             	mov    %edx,0x38(%eax)
    e6a0:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a3:	8b 50 38             	mov    0x38(%eax),%edx
    e6a6:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a9:	89 50 34             	mov    %edx,0x34(%eax)
    e6ac:	8b 45 08             	mov    0x8(%ebp),%eax
    e6af:	8b 50 34             	mov    0x34(%eax),%edx
    e6b2:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b5:	89 50 30             	mov    %edx,0x30(%eax)
    e6b8:	e9 0b 01 00 00       	jmp    e7c8 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e6bd:	8b 45 08             	mov    0x8(%ebp),%eax
    e6c0:	8b 40 0c             	mov    0xc(%eax),%eax
    e6c3:	85 c0                	test   %eax,%eax
    e6c5:	74 0b                	je     e6d2 <readChunk_bKGD+0x86>
    e6c7:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ca:	8b 40 0c             	mov    0xc(%eax),%eax
    e6cd:	83 f8 04             	cmp    $0x4,%eax
    e6d0:	75 59                	jne    e72b <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e6d2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e6d6:	74 0a                	je     e6e2 <readChunk_bKGD+0x96>
    e6d8:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e6dd:	e9 eb 00 00 00       	jmp    e7cd <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e6e2:	8b 45 08             	mov    0x8(%ebp),%eax
    e6e5:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e6ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6ef:	0f b6 00             	movzbl (%eax),%eax
    e6f2:	0f b6 c0             	movzbl %al,%eax
    e6f5:	c1 e0 08             	shl    $0x8,%eax
    e6f8:	89 c2                	mov    %eax,%edx
    e6fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6fd:	83 c0 01             	add    $0x1,%eax
    e700:	0f b6 00             	movzbl (%eax),%eax
    e703:	0f b6 c0             	movzbl %al,%eax
    e706:	01 c2                	add    %eax,%edx
    e708:	8b 45 08             	mov    0x8(%ebp),%eax
    e70b:	89 50 38             	mov    %edx,0x38(%eax)
    e70e:	8b 45 08             	mov    0x8(%ebp),%eax
    e711:	8b 50 38             	mov    0x38(%eax),%edx
    e714:	8b 45 08             	mov    0x8(%ebp),%eax
    e717:	89 50 34             	mov    %edx,0x34(%eax)
    e71a:	8b 45 08             	mov    0x8(%ebp),%eax
    e71d:	8b 50 34             	mov    0x34(%eax),%edx
    e720:	8b 45 08             	mov    0x8(%ebp),%eax
    e723:	89 50 30             	mov    %edx,0x30(%eax)
    e726:	e9 9d 00 00 00       	jmp    e7c8 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e72b:	8b 45 08             	mov    0x8(%ebp),%eax
    e72e:	8b 40 0c             	mov    0xc(%eax),%eax
    e731:	83 f8 02             	cmp    $0x2,%eax
    e734:	74 0f                	je     e745 <readChunk_bKGD+0xf9>
    e736:	8b 45 08             	mov    0x8(%ebp),%eax
    e739:	8b 40 0c             	mov    0xc(%eax),%eax
    e73c:	83 f8 06             	cmp    $0x6,%eax
    e73f:	0f 85 83 00 00 00    	jne    e7c8 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e745:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e749:	74 07                	je     e752 <readChunk_bKGD+0x106>
    e74b:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e750:	eb 7b                	jmp    e7cd <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e752:	8b 45 08             	mov    0x8(%ebp),%eax
    e755:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e75c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e75f:	0f b6 00             	movzbl (%eax),%eax
    e762:	0f b6 c0             	movzbl %al,%eax
    e765:	c1 e0 08             	shl    $0x8,%eax
    e768:	89 c2                	mov    %eax,%edx
    e76a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e76d:	83 c0 01             	add    $0x1,%eax
    e770:	0f b6 00             	movzbl (%eax),%eax
    e773:	0f b6 c0             	movzbl %al,%eax
    e776:	01 c2                	add    %eax,%edx
    e778:	8b 45 08             	mov    0x8(%ebp),%eax
    e77b:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e77e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e781:	83 c0 02             	add    $0x2,%eax
    e784:	0f b6 00             	movzbl (%eax),%eax
    e787:	0f b6 c0             	movzbl %al,%eax
    e78a:	c1 e0 08             	shl    $0x8,%eax
    e78d:	89 c2                	mov    %eax,%edx
    e78f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e792:	83 c0 03             	add    $0x3,%eax
    e795:	0f b6 00             	movzbl (%eax),%eax
    e798:	0f b6 c0             	movzbl %al,%eax
    e79b:	01 c2                	add    %eax,%edx
    e79d:	8b 45 08             	mov    0x8(%ebp),%eax
    e7a0:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e7a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7a6:	83 c0 04             	add    $0x4,%eax
    e7a9:	0f b6 00             	movzbl (%eax),%eax
    e7ac:	0f b6 c0             	movzbl %al,%eax
    e7af:	c1 e0 08             	shl    $0x8,%eax
    e7b2:	89 c2                	mov    %eax,%edx
    e7b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7b7:	83 c0 05             	add    $0x5,%eax
    e7ba:	0f b6 00             	movzbl (%eax),%eax
    e7bd:	0f b6 c0             	movzbl %al,%eax
    e7c0:	01 c2                	add    %eax,%edx
    e7c2:	8b 45 08             	mov    0x8(%ebp),%eax
    e7c5:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e7c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e7cd:	5d                   	pop    %ebp
    e7ce:	c3                   	ret    

0000e7cf <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e7cf:	55                   	push   %ebp
    e7d0:	89 e5                	mov    %esp,%ebp
    e7d2:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e7d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e7dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e7e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e7ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e7ee:	0f 85 06 01 00 00    	jne    e8fa <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e7f4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e7fb:	eb 04                	jmp    e801 <readChunk_tEXt+0x32>
    e7fd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e801:	8b 45 10             	mov    0x10(%ebp),%eax
    e804:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e807:	73 0f                	jae    e818 <readChunk_tEXt+0x49>
    e809:	8b 55 0c             	mov    0xc(%ebp),%edx
    e80c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e80f:	01 d0                	add    %edx,%eax
    e811:	0f b6 00             	movzbl (%eax),%eax
    e814:	84 c0                	test   %al,%al
    e816:	75 e5                	jne    e7fd <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e818:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e81c:	74 06                	je     e824 <readChunk_tEXt+0x55>
    e81e:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e822:	76 0c                	jbe    e830 <readChunk_tEXt+0x61>
    e824:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e82b:	e9 ca 00 00 00       	jmp    e8fa <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e830:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e833:	83 c0 01             	add    $0x1,%eax
    e836:	83 ec 0c             	sub    $0xc,%esp
    e839:	50                   	push   %eax
    e83a:	e8 73 4b ff ff       	call   33b2 <lodepng_malloc>
    e83f:	83 c4 10             	add    $0x10,%esp
    e842:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e845:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e849:	75 0c                	jne    e857 <readChunk_tEXt+0x88>
    e84b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e852:	e9 a3 00 00 00       	jmp    e8fa <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e857:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e85a:	83 ec 04             	sub    $0x4,%esp
    e85d:	50                   	push   %eax
    e85e:	ff 75 0c             	pushl  0xc(%ebp)
    e861:	ff 75 f0             	pushl  -0x10(%ebp)
    e864:	e8 87 4b ff ff       	call   33f0 <lodepng_memcpy>
    e869:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e86c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e86f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e872:	01 d0                	add    %edx,%eax
    e874:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e877:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e87a:	83 c0 01             	add    $0x1,%eax
    e87d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e880:	8b 45 10             	mov    0x10(%ebp),%eax
    e883:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e886:	72 08                	jb     e890 <readChunk_tEXt+0xc1>
    e888:	8b 45 10             	mov    0x10(%ebp),%eax
    e88b:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e88e:	eb 05                	jmp    e895 <readChunk_tEXt+0xc6>
    e890:	b8 00 00 00 00       	mov    $0x0,%eax
    e895:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e898:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e89b:	83 c0 01             	add    $0x1,%eax
    e89e:	83 ec 0c             	sub    $0xc,%esp
    e8a1:	50                   	push   %eax
    e8a2:	e8 0b 4b ff ff       	call   33b2 <lodepng_malloc>
    e8a7:	83 c4 10             	add    $0x10,%esp
    e8aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e8ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e8b1:	75 09                	jne    e8bc <readChunk_tEXt+0xed>
    e8b3:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e8ba:	eb 3e                	jmp    e8fa <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e8bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8bf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e8c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e8c5:	01 ca                	add    %ecx,%edx
    e8c7:	83 ec 04             	sub    $0x4,%esp
    e8ca:	50                   	push   %eax
    e8cb:	52                   	push   %edx
    e8cc:	ff 75 ec             	pushl  -0x14(%ebp)
    e8cf:	e8 1c 4b ff ff       	call   33f0 <lodepng_memcpy>
    e8d4:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e8d7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e8da:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8dd:	01 d0                	add    %edx,%eax
    e8df:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e8e2:	83 ec 04             	sub    $0x4,%esp
    e8e5:	ff 75 ec             	pushl  -0x14(%ebp)
    e8e8:	ff 75 f0             	pushl  -0x10(%ebp)
    e8eb:	ff 75 08             	pushl  0x8(%ebp)
    e8ee:	e8 3f ac ff ff       	call   9532 <lodepng_add_text>
    e8f3:	83 c4 10             	add    $0x10,%esp
    e8f6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e8f9:	90                   	nop
  }

  lodepng_free(key);
    e8fa:	83 ec 0c             	sub    $0xc,%esp
    e8fd:	ff 75 f0             	pushl  -0x10(%ebp)
    e900:	e8 ce 4a ff ff       	call   33d3 <lodepng_free>
    e905:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e908:	83 ec 0c             	sub    $0xc,%esp
    e90b:	ff 75 ec             	pushl  -0x14(%ebp)
    e90e:	e8 c0 4a ff ff       	call   33d3 <lodepng_free>
    e913:	83 c4 10             	add    $0x10,%esp

  return error;
    e916:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e919:	c9                   	leave  
    e91a:	c3                   	ret    

0000e91b <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e91b:	55                   	push   %ebp
    e91c:	89 e5                	mov    %esp,%ebp
    e91e:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e921:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e928:	8b 45 0c             	mov    0xc(%ebp),%eax
    e92b:	8b 10                	mov    (%eax),%edx
    e92d:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e930:	8b 50 04             	mov    0x4(%eax),%edx
    e933:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e936:	8b 50 08             	mov    0x8(%eax),%edx
    e939:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e93c:	8b 50 0c             	mov    0xc(%eax),%edx
    e93f:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e942:	8b 50 10             	mov    0x10(%eax),%edx
    e945:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e948:	8b 40 14             	mov    0x14(%eax),%eax
    e94b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e94e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e955:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e95c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e963:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e967:	0f 85 48 01 00 00    	jne    eab5 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e96d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e974:	eb 04                	jmp    e97a <readChunk_zTXt+0x5f>
    e976:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e97a:	8b 45 14             	mov    0x14(%ebp),%eax
    e97d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e980:	73 0f                	jae    e991 <readChunk_zTXt+0x76>
    e982:	8b 55 10             	mov    0x10(%ebp),%edx
    e985:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e988:	01 d0                	add    %edx,%eax
    e98a:	0f b6 00             	movzbl (%eax),%eax
    e98d:	84 c0                	test   %al,%al
    e98f:	75 e5                	jne    e976 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e991:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e994:	8d 50 02             	lea    0x2(%eax),%edx
    e997:	8b 45 14             	mov    0x14(%ebp),%eax
    e99a:	39 c2                	cmp    %eax,%edx
    e99c:	72 0c                	jb     e9aa <readChunk_zTXt+0x8f>
    e99e:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e9a5:	e9 0b 01 00 00       	jmp    eab5 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e9aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e9ae:	74 06                	je     e9b6 <readChunk_zTXt+0x9b>
    e9b0:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    e9b4:	76 0c                	jbe    e9c2 <readChunk_zTXt+0xa7>
    e9b6:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e9bd:	e9 f3 00 00 00       	jmp    eab5 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    e9c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9c5:	83 c0 01             	add    $0x1,%eax
    e9c8:	83 ec 0c             	sub    $0xc,%esp
    e9cb:	50                   	push   %eax
    e9cc:	e8 e1 49 ff ff       	call   33b2 <lodepng_malloc>
    e9d1:	83 c4 10             	add    $0x10,%esp
    e9d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e9d7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e9db:	75 0c                	jne    e9e9 <readChunk_zTXt+0xce>
    e9dd:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e9e4:	e9 cc 00 00 00       	jmp    eab5 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    e9e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9ec:	83 ec 04             	sub    $0x4,%esp
    e9ef:	50                   	push   %eax
    e9f0:	ff 75 10             	pushl  0x10(%ebp)
    e9f3:	ff 75 ec             	pushl  -0x14(%ebp)
    e9f6:	e8 f5 49 ff ff       	call   33f0 <lodepng_memcpy>
    e9fb:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e9fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ea01:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea04:	01 d0                	add    %edx,%eax
    ea06:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ea09:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea0c:	8d 50 01             	lea    0x1(%eax),%edx
    ea0f:	8b 45 10             	mov    0x10(%ebp),%eax
    ea12:	01 d0                	add    %edx,%eax
    ea14:	0f b6 00             	movzbl (%eax),%eax
    ea17:	84 c0                	test   %al,%al
    ea19:	74 0c                	je     ea27 <readChunk_zTXt+0x10c>
    ea1b:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ea22:	e9 8e 00 00 00       	jmp    eab5 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    ea27:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea2a:	83 c0 02             	add    $0x2,%eax
    ea2d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ea30:	8b 45 14             	mov    0x14(%ebp),%eax
    ea33:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ea36:	76 09                	jbe    ea41 <readChunk_zTXt+0x126>
    ea38:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ea3f:	eb 74                	jmp    eab5 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    ea41:	8b 45 14             	mov    0x14(%ebp),%eax
    ea44:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ea47:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    ea4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea4d:	8b 40 30             	mov    0x30(%eax),%eax
    ea50:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    ea53:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea56:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ea59:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ea5c:	01 d1                	add    %edx,%ecx
    ea5e:	83 ec 08             	sub    $0x8,%esp
    ea61:	8d 55 d0             	lea    -0x30(%ebp),%edx
    ea64:	52                   	push   %edx
    ea65:	50                   	push   %eax
    ea66:	51                   	push   %ecx
    ea67:	6a 00                	push   $0x0
    ea69:	8d 45 c8             	lea    -0x38(%ebp),%eax
    ea6c:	50                   	push   %eax
    ea6d:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ea70:	50                   	push   %eax
    ea71:	e8 f7 93 ff ff       	call   7e6d <zlib_decompress>
    ea76:	83 c4 20             	add    $0x20,%esp
    ea79:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    ea7c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea80:	74 11                	je     ea93 <readChunk_zTXt+0x178>
    ea82:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ea85:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ea88:	39 c2                	cmp    %eax,%edx
    ea8a:	7d 07                	jge    ea93 <readChunk_zTXt+0x178>
    ea8c:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    ea93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea97:	75 1b                	jne    eab4 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    ea99:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ea9c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea9f:	52                   	push   %edx
    eaa0:	50                   	push   %eax
    eaa1:	ff 75 ec             	pushl  -0x14(%ebp)
    eaa4:	ff 75 08             	pushl  0x8(%ebp)
    eaa7:	e8 60 a9 ff ff       	call   940c <lodepng_add_text_sized>
    eaac:	83 c4 10             	add    $0x10,%esp
    eaaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    eab2:	eb 01                	jmp    eab5 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    eab4:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    eab5:	83 ec 0c             	sub    $0xc,%esp
    eab8:	ff 75 ec             	pushl  -0x14(%ebp)
    eabb:	e8 13 49 ff ff       	call   33d3 <lodepng_free>
    eac0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    eac3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    eac6:	83 ec 0c             	sub    $0xc,%esp
    eac9:	50                   	push   %eax
    eaca:	e8 04 49 ff ff       	call   33d3 <lodepng_free>
    eacf:	83 c4 10             	add    $0x10,%esp

  return error;
    ead2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ead5:	c9                   	leave  
    ead6:	c3                   	ret    

0000ead7 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ead7:	55                   	push   %ebp
    ead8:	89 e5                	mov    %esp,%ebp
    eada:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    eadd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    eae4:	8b 45 0c             	mov    0xc(%ebp),%eax
    eae7:	8b 10                	mov    (%eax),%edx
    eae9:	89 55 c0             	mov    %edx,-0x40(%ebp)
    eaec:	8b 50 04             	mov    0x4(%eax),%edx
    eaef:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    eaf2:	8b 50 08             	mov    0x8(%eax),%edx
    eaf5:	89 55 c8             	mov    %edx,-0x38(%ebp)
    eaf8:	8b 50 0c             	mov    0xc(%eax),%edx
    eafb:	89 55 cc             	mov    %edx,-0x34(%ebp)
    eafe:	8b 50 10             	mov    0x10(%eax),%edx
    eb01:	89 55 d0             	mov    %edx,-0x30(%ebp)
    eb04:	8b 40 14             	mov    0x14(%eax),%eax
    eb07:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    eb0a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    eb11:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    eb18:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    eb1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eb23:	0f 85 d5 02 00 00    	jne    edfe <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    eb29:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    eb2d:	7f 0c                	jg     eb3b <readChunk_iTXt+0x64>
    eb2f:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    eb36:	e9 c3 02 00 00       	jmp    edfe <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eb3b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    eb42:	eb 04                	jmp    eb48 <readChunk_iTXt+0x71>
    eb44:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eb48:	8b 45 14             	mov    0x14(%ebp),%eax
    eb4b:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    eb4e:	73 0f                	jae    eb5f <readChunk_iTXt+0x88>
    eb50:	8b 55 10             	mov    0x10(%ebp),%edx
    eb53:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb56:	01 d0                	add    %edx,%eax
    eb58:	0f b6 00             	movzbl (%eax),%eax
    eb5b:	84 c0                	test   %al,%al
    eb5d:	75 e5                	jne    eb44 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    eb5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb62:	8d 50 03             	lea    0x3(%eax),%edx
    eb65:	8b 45 14             	mov    0x14(%ebp),%eax
    eb68:	39 c2                	cmp    %eax,%edx
    eb6a:	72 0c                	jb     eb78 <readChunk_iTXt+0xa1>
    eb6c:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eb73:	e9 86 02 00 00       	jmp    edfe <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eb78:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eb7c:	74 06                	je     eb84 <readChunk_iTXt+0xad>
    eb7e:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eb82:	76 0c                	jbe    eb90 <readChunk_iTXt+0xb9>
    eb84:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eb8b:	e9 6e 02 00 00       	jmp    edfe <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eb90:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb93:	83 c0 01             	add    $0x1,%eax
    eb96:	83 ec 0c             	sub    $0xc,%esp
    eb99:	50                   	push   %eax
    eb9a:	e8 13 48 ff ff       	call   33b2 <lodepng_malloc>
    eb9f:	83 c4 10             	add    $0x10,%esp
    eba2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eba5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eba9:	75 0c                	jne    ebb7 <readChunk_iTXt+0xe0>
    ebab:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ebb2:	e9 47 02 00 00       	jmp    edfe <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    ebb7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebba:	83 ec 04             	sub    $0x4,%esp
    ebbd:	50                   	push   %eax
    ebbe:	ff 75 10             	pushl  0x10(%ebp)
    ebc1:	ff 75 e8             	pushl  -0x18(%ebp)
    ebc4:	e8 27 48 ff ff       	call   33f0 <lodepng_memcpy>
    ebc9:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ebcc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ebcf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebd2:	01 d0                	add    %edx,%eax
    ebd4:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    ebd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebda:	8d 50 01             	lea    0x1(%eax),%edx
    ebdd:	8b 45 10             	mov    0x10(%ebp),%eax
    ebe0:	01 d0                	add    %edx,%eax
    ebe2:	0f b6 00             	movzbl (%eax),%eax
    ebe5:	0f b6 c0             	movzbl %al,%eax
    ebe8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ebeb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebee:	8d 50 02             	lea    0x2(%eax),%edx
    ebf1:	8b 45 10             	mov    0x10(%ebp),%eax
    ebf4:	01 d0                	add    %edx,%eax
    ebf6:	0f b6 00             	movzbl (%eax),%eax
    ebf9:	84 c0                	test   %al,%al
    ebfb:	74 0c                	je     ec09 <readChunk_iTXt+0x132>
    ebfd:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ec04:	e9 f5 01 00 00       	jmp    edfe <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    ec09:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec0c:	83 c0 03             	add    $0x3,%eax
    ec0f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ec12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ec19:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ec1f:	eb 08                	jmp    ec29 <readChunk_iTXt+0x152>
    ec21:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec25:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ec29:	8b 45 14             	mov    0x14(%ebp),%eax
    ec2c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ec2f:	73 0f                	jae    ec40 <readChunk_iTXt+0x169>
    ec31:	8b 55 10             	mov    0x10(%ebp),%edx
    ec34:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec37:	01 d0                	add    %edx,%eax
    ec39:	0f b6 00             	movzbl (%eax),%eax
    ec3c:	84 c0                	test   %al,%al
    ec3e:	75 e1                	jne    ec21 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ec40:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec43:	83 c0 01             	add    $0x1,%eax
    ec46:	83 ec 0c             	sub    $0xc,%esp
    ec49:	50                   	push   %eax
    ec4a:	e8 63 47 ff ff       	call   33b2 <lodepng_malloc>
    ec4f:	83 c4 10             	add    $0x10,%esp
    ec52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ec55:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ec59:	75 0c                	jne    ec67 <readChunk_iTXt+0x190>
    ec5b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec62:	e9 97 01 00 00       	jmp    edfe <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ec67:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec6a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec6d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec70:	01 ca                	add    %ecx,%edx
    ec72:	83 ec 04             	sub    $0x4,%esp
    ec75:	50                   	push   %eax
    ec76:	52                   	push   %edx
    ec77:	ff 75 e4             	pushl  -0x1c(%ebp)
    ec7a:	e8 71 47 ff ff       	call   33f0 <lodepng_memcpy>
    ec7f:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ec82:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ec85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec88:	01 d0                	add    %edx,%eax
    ec8a:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ec8d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec90:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec93:	01 d0                	add    %edx,%eax
    ec95:	83 c0 01             	add    $0x1,%eax
    ec98:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ec9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eca2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eca5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eca8:	eb 08                	jmp    ecb2 <readChunk_iTXt+0x1db>
    ecaa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ecae:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ecb2:	8b 45 14             	mov    0x14(%ebp),%eax
    ecb5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ecb8:	73 0f                	jae    ecc9 <readChunk_iTXt+0x1f2>
    ecba:	8b 55 10             	mov    0x10(%ebp),%edx
    ecbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ecc0:	01 d0                	add    %edx,%eax
    ecc2:	0f b6 00             	movzbl (%eax),%eax
    ecc5:	84 c0                	test   %al,%al
    ecc7:	75 e1                	jne    ecaa <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ecc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eccc:	83 c0 01             	add    $0x1,%eax
    eccf:	83 ec 0c             	sub    $0xc,%esp
    ecd2:	50                   	push   %eax
    ecd3:	e8 da 46 ff ff       	call   33b2 <lodepng_malloc>
    ecd8:	83 c4 10             	add    $0x10,%esp
    ecdb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ecde:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ece2:	75 0c                	jne    ecf0 <readChunk_iTXt+0x219>
    ece4:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eceb:	e9 0e 01 00 00       	jmp    edfe <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ecf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecf3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ecf6:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecf9:	01 ca                	add    %ecx,%edx
    ecfb:	83 ec 04             	sub    $0x4,%esp
    ecfe:	50                   	push   %eax
    ecff:	52                   	push   %edx
    ed00:	ff 75 e0             	pushl  -0x20(%ebp)
    ed03:	e8 e8 46 ff ff       	call   33f0 <lodepng_memcpy>
    ed08:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ed0b:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ed0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed11:	01 d0                	add    %edx,%eax
    ed13:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ed16:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ed19:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ed1c:	01 d0                	add    %edx,%eax
    ed1e:	83 c0 01             	add    $0x1,%eax
    ed21:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ed24:	8b 45 14             	mov    0x14(%ebp),%eax
    ed27:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ed2a:	72 08                	jb     ed34 <readChunk_iTXt+0x25d>
    ed2c:	8b 45 14             	mov    0x14(%ebp),%eax
    ed2f:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ed32:	eb 05                	jmp    ed39 <readChunk_iTXt+0x262>
    ed34:	b8 00 00 00 00       	mov    $0x0,%eax
    ed39:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ed3c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ed40:	0f 84 90 00 00 00    	je     edd6 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ed46:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ed4d:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ed54:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed57:	8b 40 30             	mov    0x30(%eax),%eax
    ed5a:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ed5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed60:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed63:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed66:	01 d1                	add    %edx,%ecx
    ed68:	83 ec 08             	sub    $0x8,%esp
    ed6b:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ed6e:	52                   	push   %edx
    ed6f:	50                   	push   %eax
    ed70:	51                   	push   %ecx
    ed71:	6a 00                	push   $0x0
    ed73:	8d 45 b8             	lea    -0x48(%ebp),%eax
    ed76:	50                   	push   %eax
    ed77:	8d 45 bc             	lea    -0x44(%ebp),%eax
    ed7a:	50                   	push   %eax
    ed7b:	e8 ed 90 ff ff       	call   7e6d <zlib_decompress>
    ed80:	83 c4 20             	add    $0x20,%esp
    ed83:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ed86:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed8a:	74 11                	je     ed9d <readChunk_iTXt+0x2c6>
    ed8c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ed8f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ed92:	39 c2                	cmp    %eax,%edx
    ed94:	7d 07                	jge    ed9d <readChunk_iTXt+0x2c6>
    ed96:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    ed9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eda1:	75 22                	jne    edc5 <readChunk_iTXt+0x2ee>
    eda3:	8b 55 b8             	mov    -0x48(%ebp),%edx
    eda6:	8b 45 bc             	mov    -0x44(%ebp),%eax
    eda9:	83 ec 08             	sub    $0x8,%esp
    edac:	52                   	push   %edx
    edad:	50                   	push   %eax
    edae:	ff 75 e0             	pushl  -0x20(%ebp)
    edb1:	ff 75 e4             	pushl  -0x1c(%ebp)
    edb4:	ff 75 e8             	pushl  -0x18(%ebp)
    edb7:	ff 75 08             	pushl  0x8(%ebp)
    edba:	e8 94 a9 ff ff       	call   9753 <lodepng_add_itext_sized>
    edbf:	83 c4 20             	add    $0x20,%esp
    edc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    edc5:	8b 45 bc             	mov    -0x44(%ebp),%eax
    edc8:	83 ec 0c             	sub    $0xc,%esp
    edcb:	50                   	push   %eax
    edcc:	e8 02 46 ff ff       	call   33d3 <lodepng_free>
    edd1:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    edd4:	eb 27                	jmp    edfd <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    edd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edd9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eddc:	8b 55 d8             	mov    -0x28(%ebp),%edx
    eddf:	01 ca                	add    %ecx,%edx
    ede1:	83 ec 08             	sub    $0x8,%esp
    ede4:	50                   	push   %eax
    ede5:	52                   	push   %edx
    ede6:	ff 75 e0             	pushl  -0x20(%ebp)
    ede9:	ff 75 e4             	pushl  -0x1c(%ebp)
    edec:	ff 75 e8             	pushl  -0x18(%ebp)
    edef:	ff 75 08             	pushl  0x8(%ebp)
    edf2:	e8 5c a9 ff ff       	call   9753 <lodepng_add_itext_sized>
    edf7:	83 c4 20             	add    $0x20,%esp
    edfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    edfd:	90                   	nop
  }

  lodepng_free(key);
    edfe:	83 ec 0c             	sub    $0xc,%esp
    ee01:	ff 75 e8             	pushl  -0x18(%ebp)
    ee04:	e8 ca 45 ff ff       	call   33d3 <lodepng_free>
    ee09:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ee0c:	83 ec 0c             	sub    $0xc,%esp
    ee0f:	ff 75 e4             	pushl  -0x1c(%ebp)
    ee12:	e8 bc 45 ff ff       	call   33d3 <lodepng_free>
    ee17:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    ee1a:	83 ec 0c             	sub    $0xc,%esp
    ee1d:	ff 75 e0             	pushl  -0x20(%ebp)
    ee20:	e8 ae 45 ff ff       	call   33d3 <lodepng_free>
    ee25:	83 c4 10             	add    $0x10,%esp

  return error;
    ee28:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ee2b:	c9                   	leave  
    ee2c:	c3                   	ret    

0000ee2d <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee2d:	55                   	push   %ebp
    ee2e:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    ee30:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    ee34:	74 0a                	je     ee40 <readChunk_tIME+0x13>
    ee36:	b8 49 00 00 00       	mov    $0x49,%eax
    ee3b:	e9 8b 00 00 00       	jmp    eecb <readChunk_tIME+0x9e>

  info->time_defined = 1;
    ee40:	8b 45 08             	mov    0x8(%ebp),%eax
    ee43:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    ee4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee4d:	0f b6 00             	movzbl (%eax),%eax
    ee50:	0f b6 c0             	movzbl %al,%eax
    ee53:	c1 e0 08             	shl    $0x8,%eax
    ee56:	89 c2                	mov    %eax,%edx
    ee58:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee5b:	83 c0 01             	add    $0x1,%eax
    ee5e:	0f b6 00             	movzbl (%eax),%eax
    ee61:	0f b6 c0             	movzbl %al,%eax
    ee64:	01 c2                	add    %eax,%edx
    ee66:	8b 45 08             	mov    0x8(%ebp),%eax
    ee69:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    ee6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee6f:	83 c0 02             	add    $0x2,%eax
    ee72:	0f b6 00             	movzbl (%eax),%eax
    ee75:	0f b6 d0             	movzbl %al,%edx
    ee78:	8b 45 08             	mov    0x8(%ebp),%eax
    ee7b:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    ee7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee81:	83 c0 03             	add    $0x3,%eax
    ee84:	0f b6 00             	movzbl (%eax),%eax
    ee87:	0f b6 d0             	movzbl %al,%edx
    ee8a:	8b 45 08             	mov    0x8(%ebp),%eax
    ee8d:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    ee90:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee93:	83 c0 04             	add    $0x4,%eax
    ee96:	0f b6 00             	movzbl (%eax),%eax
    ee99:	0f b6 d0             	movzbl %al,%edx
    ee9c:	8b 45 08             	mov    0x8(%ebp),%eax
    ee9f:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    eea2:	8b 45 0c             	mov    0xc(%ebp),%eax
    eea5:	83 c0 05             	add    $0x5,%eax
    eea8:	0f b6 00             	movzbl (%eax),%eax
    eeab:	0f b6 d0             	movzbl %al,%edx
    eeae:	8b 45 08             	mov    0x8(%ebp),%eax
    eeb1:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    eeb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeb7:	83 c0 06             	add    $0x6,%eax
    eeba:	0f b6 00             	movzbl (%eax),%eax
    eebd:	0f b6 d0             	movzbl %al,%edx
    eec0:	8b 45 08             	mov    0x8(%ebp),%eax
    eec3:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    eec6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eecb:	5d                   	pop    %ebp
    eecc:	c3                   	ret    

0000eecd <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    eecd:	55                   	push   %ebp
    eece:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    eed0:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    eed4:	74 0a                	je     eee0 <readChunk_pHYs+0x13>
    eed6:	b8 4a 00 00 00       	mov    $0x4a,%eax
    eedb:	e9 ba 00 00 00       	jmp    ef9a <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    eee0:	8b 45 08             	mov    0x8(%ebp),%eax
    eee3:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    eeea:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeed:	0f b6 00             	movzbl (%eax),%eax
    eef0:	0f b6 c0             	movzbl %al,%eax
    eef3:	c1 e0 08             	shl    $0x8,%eax
    eef6:	89 c2                	mov    %eax,%edx
    eef8:	8b 45 0c             	mov    0xc(%ebp),%eax
    eefb:	83 c0 01             	add    $0x1,%eax
    eefe:	0f b6 00             	movzbl (%eax),%eax
    ef01:	0f b6 c0             	movzbl %al,%eax
    ef04:	01 d0                	add    %edx,%eax
    ef06:	c1 e0 08             	shl    $0x8,%eax
    ef09:	89 c2                	mov    %eax,%edx
    ef0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef0e:	83 c0 02             	add    $0x2,%eax
    ef11:	0f b6 00             	movzbl (%eax),%eax
    ef14:	0f b6 c0             	movzbl %al,%eax
    ef17:	01 d0                	add    %edx,%eax
    ef19:	c1 e0 08             	shl    $0x8,%eax
    ef1c:	89 c2                	mov    %eax,%edx
    ef1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef21:	83 c0 03             	add    $0x3,%eax
    ef24:	0f b6 00             	movzbl (%eax),%eax
    ef27:	0f b6 c0             	movzbl %al,%eax
    ef2a:	01 c2                	add    %eax,%edx
    ef2c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef2f:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    ef32:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef35:	83 c0 04             	add    $0x4,%eax
    ef38:	0f b6 00             	movzbl (%eax),%eax
    ef3b:	0f b6 c0             	movzbl %al,%eax
    ef3e:	c1 e0 08             	shl    $0x8,%eax
    ef41:	89 c2                	mov    %eax,%edx
    ef43:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef46:	83 c0 05             	add    $0x5,%eax
    ef49:	0f b6 00             	movzbl (%eax),%eax
    ef4c:	0f b6 c0             	movzbl %al,%eax
    ef4f:	01 d0                	add    %edx,%eax
    ef51:	c1 e0 08             	shl    $0x8,%eax
    ef54:	89 c2                	mov    %eax,%edx
    ef56:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef59:	83 c0 06             	add    $0x6,%eax
    ef5c:	0f b6 00             	movzbl (%eax),%eax
    ef5f:	0f b6 c0             	movzbl %al,%eax
    ef62:	01 d0                	add    %edx,%eax
    ef64:	c1 e0 08             	shl    $0x8,%eax
    ef67:	89 c2                	mov    %eax,%edx
    ef69:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef6c:	83 c0 07             	add    $0x7,%eax
    ef6f:	0f b6 00             	movzbl (%eax),%eax
    ef72:	0f b6 c0             	movzbl %al,%eax
    ef75:	01 c2                	add    %eax,%edx
    ef77:	8b 45 08             	mov    0x8(%ebp),%eax
    ef7a:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    ef80:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef83:	83 c0 08             	add    $0x8,%eax
    ef86:	0f b6 00             	movzbl (%eax),%eax
    ef89:	0f b6 d0             	movzbl %al,%edx
    ef8c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef8f:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    ef95:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef9a:	5d                   	pop    %ebp
    ef9b:	c3                   	ret    

0000ef9c <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef9c:	55                   	push   %ebp
    ef9d:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    ef9f:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    efa3:	74 07                	je     efac <readChunk_gAMA+0x10>
    efa5:	b8 60 00 00 00       	mov    $0x60,%eax
    efaa:	eb 5d                	jmp    f009 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    efac:	8b 45 08             	mov    0x8(%ebp),%eax
    efaf:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    efb6:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    efb9:	8b 45 0c             	mov    0xc(%ebp),%eax
    efbc:	0f b6 00             	movzbl (%eax),%eax
    efbf:	0f b6 c0             	movzbl %al,%eax
    efc2:	c1 e0 08             	shl    $0x8,%eax
    efc5:	89 c2                	mov    %eax,%edx
    efc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    efca:	83 c0 01             	add    $0x1,%eax
    efcd:	0f b6 00             	movzbl (%eax),%eax
    efd0:	0f b6 c0             	movzbl %al,%eax
    efd3:	01 d0                	add    %edx,%eax
    efd5:	c1 e0 08             	shl    $0x8,%eax
    efd8:	89 c2                	mov    %eax,%edx
    efda:	8b 45 0c             	mov    0xc(%ebp),%eax
    efdd:	83 c0 02             	add    $0x2,%eax
    efe0:	0f b6 00             	movzbl (%eax),%eax
    efe3:	0f b6 c0             	movzbl %al,%eax
    efe6:	01 d0                	add    %edx,%eax
    efe8:	c1 e0 08             	shl    $0x8,%eax
    efeb:	89 c2                	mov    %eax,%edx
    efed:	8b 45 0c             	mov    0xc(%ebp),%eax
    eff0:	83 c0 03             	add    $0x3,%eax
    eff3:	0f b6 00             	movzbl (%eax),%eax
    eff6:	0f b6 c0             	movzbl %al,%eax
    eff9:	01 c2                	add    %eax,%edx
    effb:	8b 45 08             	mov    0x8(%ebp),%eax
    effe:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f004:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f009:	5d                   	pop    %ebp
    f00a:	c3                   	ret    

0000f00b <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f00b:	55                   	push   %ebp
    f00c:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f00e:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f012:	74 0a                	je     f01e <readChunk_cHRM+0x13>
    f014:	b8 61 00 00 00       	mov    $0x61,%eax
    f019:	e9 7f 02 00 00       	jmp    f29d <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f01e:	8b 45 08             	mov    0x8(%ebp),%eax
    f021:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f028:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f02b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f02e:	0f b6 00             	movzbl (%eax),%eax
    f031:	0f b6 c0             	movzbl %al,%eax
    f034:	c1 e0 08             	shl    $0x8,%eax
    f037:	89 c2                	mov    %eax,%edx
    f039:	8b 45 0c             	mov    0xc(%ebp),%eax
    f03c:	83 c0 01             	add    $0x1,%eax
    f03f:	0f b6 00             	movzbl (%eax),%eax
    f042:	0f b6 c0             	movzbl %al,%eax
    f045:	01 d0                	add    %edx,%eax
    f047:	c1 e0 08             	shl    $0x8,%eax
    f04a:	89 c2                	mov    %eax,%edx
    f04c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f04f:	83 c0 02             	add    $0x2,%eax
    f052:	0f b6 00             	movzbl (%eax),%eax
    f055:	0f b6 c0             	movzbl %al,%eax
    f058:	01 d0                	add    %edx,%eax
    f05a:	c1 e0 08             	shl    $0x8,%eax
    f05d:	89 c2                	mov    %eax,%edx
    f05f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f062:	83 c0 03             	add    $0x3,%eax
    f065:	0f b6 00             	movzbl (%eax),%eax
    f068:	0f b6 c0             	movzbl %al,%eax
    f06b:	01 c2                	add    %eax,%edx
    f06d:	8b 45 08             	mov    0x8(%ebp),%eax
    f070:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f076:	8b 45 0c             	mov    0xc(%ebp),%eax
    f079:	83 c0 04             	add    $0x4,%eax
    f07c:	0f b6 00             	movzbl (%eax),%eax
    f07f:	0f b6 c0             	movzbl %al,%eax
    f082:	c1 e0 08             	shl    $0x8,%eax
    f085:	89 c2                	mov    %eax,%edx
    f087:	8b 45 0c             	mov    0xc(%ebp),%eax
    f08a:	83 c0 05             	add    $0x5,%eax
    f08d:	0f b6 00             	movzbl (%eax),%eax
    f090:	0f b6 c0             	movzbl %al,%eax
    f093:	01 d0                	add    %edx,%eax
    f095:	c1 e0 08             	shl    $0x8,%eax
    f098:	89 c2                	mov    %eax,%edx
    f09a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f09d:	83 c0 06             	add    $0x6,%eax
    f0a0:	0f b6 00             	movzbl (%eax),%eax
    f0a3:	0f b6 c0             	movzbl %al,%eax
    f0a6:	01 d0                	add    %edx,%eax
    f0a8:	c1 e0 08             	shl    $0x8,%eax
    f0ab:	89 c2                	mov    %eax,%edx
    f0ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0b0:	83 c0 07             	add    $0x7,%eax
    f0b3:	0f b6 00             	movzbl (%eax),%eax
    f0b6:	0f b6 c0             	movzbl %al,%eax
    f0b9:	01 c2                	add    %eax,%edx
    f0bb:	8b 45 08             	mov    0x8(%ebp),%eax
    f0be:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f0c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0c7:	83 c0 08             	add    $0x8,%eax
    f0ca:	0f b6 00             	movzbl (%eax),%eax
    f0cd:	0f b6 c0             	movzbl %al,%eax
    f0d0:	c1 e0 08             	shl    $0x8,%eax
    f0d3:	89 c2                	mov    %eax,%edx
    f0d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d8:	83 c0 09             	add    $0x9,%eax
    f0db:	0f b6 00             	movzbl (%eax),%eax
    f0de:	0f b6 c0             	movzbl %al,%eax
    f0e1:	01 d0                	add    %edx,%eax
    f0e3:	c1 e0 08             	shl    $0x8,%eax
    f0e6:	89 c2                	mov    %eax,%edx
    f0e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0eb:	83 c0 0a             	add    $0xa,%eax
    f0ee:	0f b6 00             	movzbl (%eax),%eax
    f0f1:	0f b6 c0             	movzbl %al,%eax
    f0f4:	01 d0                	add    %edx,%eax
    f0f6:	c1 e0 08             	shl    $0x8,%eax
    f0f9:	89 c2                	mov    %eax,%edx
    f0fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0fe:	83 c0 0b             	add    $0xb,%eax
    f101:	0f b6 00             	movzbl (%eax),%eax
    f104:	0f b6 c0             	movzbl %al,%eax
    f107:	01 c2                	add    %eax,%edx
    f109:	8b 45 08             	mov    0x8(%ebp),%eax
    f10c:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f112:	8b 45 0c             	mov    0xc(%ebp),%eax
    f115:	83 c0 0c             	add    $0xc,%eax
    f118:	0f b6 00             	movzbl (%eax),%eax
    f11b:	0f b6 c0             	movzbl %al,%eax
    f11e:	c1 e0 08             	shl    $0x8,%eax
    f121:	89 c2                	mov    %eax,%edx
    f123:	8b 45 0c             	mov    0xc(%ebp),%eax
    f126:	83 c0 0d             	add    $0xd,%eax
    f129:	0f b6 00             	movzbl (%eax),%eax
    f12c:	0f b6 c0             	movzbl %al,%eax
    f12f:	01 d0                	add    %edx,%eax
    f131:	c1 e0 08             	shl    $0x8,%eax
    f134:	89 c2                	mov    %eax,%edx
    f136:	8b 45 0c             	mov    0xc(%ebp),%eax
    f139:	83 c0 0e             	add    $0xe,%eax
    f13c:	0f b6 00             	movzbl (%eax),%eax
    f13f:	0f b6 c0             	movzbl %al,%eax
    f142:	01 d0                	add    %edx,%eax
    f144:	c1 e0 08             	shl    $0x8,%eax
    f147:	89 c2                	mov    %eax,%edx
    f149:	8b 45 0c             	mov    0xc(%ebp),%eax
    f14c:	83 c0 0f             	add    $0xf,%eax
    f14f:	0f b6 00             	movzbl (%eax),%eax
    f152:	0f b6 c0             	movzbl %al,%eax
    f155:	01 c2                	add    %eax,%edx
    f157:	8b 45 08             	mov    0x8(%ebp),%eax
    f15a:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f160:	8b 45 0c             	mov    0xc(%ebp),%eax
    f163:	83 c0 10             	add    $0x10,%eax
    f166:	0f b6 00             	movzbl (%eax),%eax
    f169:	0f b6 c0             	movzbl %al,%eax
    f16c:	c1 e0 08             	shl    $0x8,%eax
    f16f:	89 c2                	mov    %eax,%edx
    f171:	8b 45 0c             	mov    0xc(%ebp),%eax
    f174:	83 c0 11             	add    $0x11,%eax
    f177:	0f b6 00             	movzbl (%eax),%eax
    f17a:	0f b6 c0             	movzbl %al,%eax
    f17d:	01 d0                	add    %edx,%eax
    f17f:	c1 e0 08             	shl    $0x8,%eax
    f182:	89 c2                	mov    %eax,%edx
    f184:	8b 45 0c             	mov    0xc(%ebp),%eax
    f187:	83 c0 12             	add    $0x12,%eax
    f18a:	0f b6 00             	movzbl (%eax),%eax
    f18d:	0f b6 c0             	movzbl %al,%eax
    f190:	01 d0                	add    %edx,%eax
    f192:	c1 e0 08             	shl    $0x8,%eax
    f195:	89 c2                	mov    %eax,%edx
    f197:	8b 45 0c             	mov    0xc(%ebp),%eax
    f19a:	83 c0 13             	add    $0x13,%eax
    f19d:	0f b6 00             	movzbl (%eax),%eax
    f1a0:	0f b6 c0             	movzbl %al,%eax
    f1a3:	01 c2                	add    %eax,%edx
    f1a5:	8b 45 08             	mov    0x8(%ebp),%eax
    f1a8:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1b1:	83 c0 14             	add    $0x14,%eax
    f1b4:	0f b6 00             	movzbl (%eax),%eax
    f1b7:	0f b6 c0             	movzbl %al,%eax
    f1ba:	c1 e0 08             	shl    $0x8,%eax
    f1bd:	89 c2                	mov    %eax,%edx
    f1bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1c2:	83 c0 15             	add    $0x15,%eax
    f1c5:	0f b6 00             	movzbl (%eax),%eax
    f1c8:	0f b6 c0             	movzbl %al,%eax
    f1cb:	01 d0                	add    %edx,%eax
    f1cd:	c1 e0 08             	shl    $0x8,%eax
    f1d0:	89 c2                	mov    %eax,%edx
    f1d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1d5:	83 c0 16             	add    $0x16,%eax
    f1d8:	0f b6 00             	movzbl (%eax),%eax
    f1db:	0f b6 c0             	movzbl %al,%eax
    f1de:	01 d0                	add    %edx,%eax
    f1e0:	c1 e0 08             	shl    $0x8,%eax
    f1e3:	89 c2                	mov    %eax,%edx
    f1e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e8:	83 c0 17             	add    $0x17,%eax
    f1eb:	0f b6 00             	movzbl (%eax),%eax
    f1ee:	0f b6 c0             	movzbl %al,%eax
    f1f1:	01 c2                	add    %eax,%edx
    f1f3:	8b 45 08             	mov    0x8(%ebp),%eax
    f1f6:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f1fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1ff:	83 c0 18             	add    $0x18,%eax
    f202:	0f b6 00             	movzbl (%eax),%eax
    f205:	0f b6 c0             	movzbl %al,%eax
    f208:	c1 e0 08             	shl    $0x8,%eax
    f20b:	89 c2                	mov    %eax,%edx
    f20d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f210:	83 c0 19             	add    $0x19,%eax
    f213:	0f b6 00             	movzbl (%eax),%eax
    f216:	0f b6 c0             	movzbl %al,%eax
    f219:	01 d0                	add    %edx,%eax
    f21b:	c1 e0 08             	shl    $0x8,%eax
    f21e:	89 c2                	mov    %eax,%edx
    f220:	8b 45 0c             	mov    0xc(%ebp),%eax
    f223:	83 c0 1a             	add    $0x1a,%eax
    f226:	0f b6 00             	movzbl (%eax),%eax
    f229:	0f b6 c0             	movzbl %al,%eax
    f22c:	01 d0                	add    %edx,%eax
    f22e:	c1 e0 08             	shl    $0x8,%eax
    f231:	89 c2                	mov    %eax,%edx
    f233:	8b 45 0c             	mov    0xc(%ebp),%eax
    f236:	83 c0 1b             	add    $0x1b,%eax
    f239:	0f b6 00             	movzbl (%eax),%eax
    f23c:	0f b6 c0             	movzbl %al,%eax
    f23f:	01 c2                	add    %eax,%edx
    f241:	8b 45 08             	mov    0x8(%ebp),%eax
    f244:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f24a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f24d:	83 c0 1c             	add    $0x1c,%eax
    f250:	0f b6 00             	movzbl (%eax),%eax
    f253:	0f b6 c0             	movzbl %al,%eax
    f256:	c1 e0 08             	shl    $0x8,%eax
    f259:	89 c2                	mov    %eax,%edx
    f25b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f25e:	83 c0 1d             	add    $0x1d,%eax
    f261:	0f b6 00             	movzbl (%eax),%eax
    f264:	0f b6 c0             	movzbl %al,%eax
    f267:	01 d0                	add    %edx,%eax
    f269:	c1 e0 08             	shl    $0x8,%eax
    f26c:	89 c2                	mov    %eax,%edx
    f26e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f271:	83 c0 1e             	add    $0x1e,%eax
    f274:	0f b6 00             	movzbl (%eax),%eax
    f277:	0f b6 c0             	movzbl %al,%eax
    f27a:	01 d0                	add    %edx,%eax
    f27c:	c1 e0 08             	shl    $0x8,%eax
    f27f:	89 c2                	mov    %eax,%edx
    f281:	8b 45 0c             	mov    0xc(%ebp),%eax
    f284:	83 c0 1f             	add    $0x1f,%eax
    f287:	0f b6 00             	movzbl (%eax),%eax
    f28a:	0f b6 c0             	movzbl %al,%eax
    f28d:	01 c2                	add    %eax,%edx
    f28f:	8b 45 08             	mov    0x8(%ebp),%eax
    f292:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f298:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f29d:	5d                   	pop    %ebp
    f29e:	c3                   	ret    

0000f29f <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f29f:	55                   	push   %ebp
    f2a0:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f2a2:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f2a6:	74 07                	je     f2af <readChunk_sRGB+0x10>
    f2a8:	b8 62 00 00 00       	mov    $0x62,%eax
    f2ad:	eb 24                	jmp    f2d3 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f2af:	8b 45 08             	mov    0x8(%ebp),%eax
    f2b2:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f2b9:	00 00 00 
  info->srgb_intent = data[0];
    f2bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2bf:	0f b6 00             	movzbl (%eax),%eax
    f2c2:	0f b6 d0             	movzbl %al,%edx
    f2c5:	8b 45 08             	mov    0x8(%ebp),%eax
    f2c8:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f2ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f2d3:	5d                   	pop    %ebp
    f2d4:	c3                   	ret    

0000f2d5 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f2d5:	55                   	push   %ebp
    f2d6:	89 e5                	mov    %esp,%ebp
    f2d8:	53                   	push   %ebx
    f2d9:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f2dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f2e3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f2ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2ed:	8b 10                	mov    (%eax),%edx
    f2ef:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f2f2:	8b 50 04             	mov    0x4(%eax),%edx
    f2f5:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f2f8:	8b 50 08             	mov    0x8(%eax),%edx
    f2fb:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f2fe:	8b 50 0c             	mov    0xc(%eax),%edx
    f301:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f304:	8b 50 10             	mov    0x10(%eax),%edx
    f307:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f30a:	8b 40 14             	mov    0x14(%eax),%eax
    f30d:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f310:	8b 45 08             	mov    0x8(%ebp),%eax
    f313:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f31a:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f31d:	8b 45 08             	mov    0x8(%ebp),%eax
    f320:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f326:	85 c0                	test   %eax,%eax
    f328:	74 0e                	je     f338 <readChunk_iCCP+0x63>
    f32a:	83 ec 0c             	sub    $0xc,%esp
    f32d:	ff 75 08             	pushl  0x8(%ebp)
    f330:	e8 ca a6 ff ff       	call   99ff <lodepng_clear_icc>
    f335:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f338:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f33f:	eb 04                	jmp    f345 <readChunk_iCCP+0x70>
    f341:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f345:	8b 45 14             	mov    0x14(%ebp),%eax
    f348:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f34b:	73 0f                	jae    f35c <readChunk_iCCP+0x87>
    f34d:	8b 55 10             	mov    0x10(%ebp),%edx
    f350:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f353:	01 d0                	add    %edx,%eax
    f355:	0f b6 00             	movzbl (%eax),%eax
    f358:	84 c0                	test   %al,%al
    f35a:	75 e5                	jne    f341 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f35c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f35f:	8d 50 02             	lea    0x2(%eax),%edx
    f362:	8b 45 14             	mov    0x14(%ebp),%eax
    f365:	39 c2                	cmp    %eax,%edx
    f367:	72 0a                	jb     f373 <readChunk_iCCP+0x9e>
    f369:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f36e:	e9 46 01 00 00       	jmp    f4b9 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f373:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f377:	74 06                	je     f37f <readChunk_iCCP+0xaa>
    f379:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f37d:	76 0a                	jbe    f389 <readChunk_iCCP+0xb4>
    f37f:	b8 59 00 00 00       	mov    $0x59,%eax
    f384:	e9 30 01 00 00       	jmp    f4b9 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f389:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f38c:	83 c0 01             	add    $0x1,%eax
    f38f:	83 ec 0c             	sub    $0xc,%esp
    f392:	50                   	push   %eax
    f393:	e8 1a 40 ff ff       	call   33b2 <lodepng_malloc>
    f398:	83 c4 10             	add    $0x10,%esp
    f39b:	89 c2                	mov    %eax,%edx
    f39d:	8b 45 08             	mov    0x8(%ebp),%eax
    f3a0:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f3a6:	8b 45 08             	mov    0x8(%ebp),%eax
    f3a9:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f3af:	85 c0                	test   %eax,%eax
    f3b1:	75 0a                	jne    f3bd <readChunk_iCCP+0xe8>
    f3b3:	b8 53 00 00 00       	mov    $0x53,%eax
    f3b8:	e9 fc 00 00 00       	jmp    f4b9 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f3bd:	8b 45 08             	mov    0x8(%ebp),%eax
    f3c0:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f3c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3c9:	01 d0                	add    %edx,%eax
    f3cb:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f3ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f3d5:	eb 1f                	jmp    f3f6 <readChunk_iCCP+0x121>
    f3d7:	8b 45 08             	mov    0x8(%ebp),%eax
    f3da:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f3e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f3e3:	01 d0                	add    %edx,%eax
    f3e5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f3e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3eb:	01 ca                	add    %ecx,%edx
    f3ed:	0f b6 12             	movzbl (%edx),%edx
    f3f0:	88 10                	mov    %dl,(%eax)
    f3f2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f3f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f3f9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f3fc:	75 d9                	jne    f3d7 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f3fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f401:	8d 50 01             	lea    0x1(%eax),%edx
    f404:	8b 45 10             	mov    0x10(%ebp),%eax
    f407:	01 d0                	add    %edx,%eax
    f409:	0f b6 00             	movzbl (%eax),%eax
    f40c:	84 c0                	test   %al,%al
    f40e:	74 0a                	je     f41a <readChunk_iCCP+0x145>
    f410:	b8 48 00 00 00       	mov    $0x48,%eax
    f415:	e9 9f 00 00 00       	jmp    f4b9 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f41a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f41d:	83 c0 02             	add    $0x2,%eax
    f420:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f423:	8b 45 14             	mov    0x14(%ebp),%eax
    f426:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f429:	76 0a                	jbe    f435 <readChunk_iCCP+0x160>
    f42b:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f430:	e9 84 00 00 00       	jmp    f4b9 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f435:	8b 45 14             	mov    0x14(%ebp),%eax
    f438:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f43b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f43e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f441:	8b 40 34             	mov    0x34(%eax),%eax
    f444:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f447:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f44a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f44d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f450:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f453:	8b 55 08             	mov    0x8(%ebp),%edx
    f456:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f45c:	83 ec 08             	sub    $0x8,%esp
    f45f:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f462:	52                   	push   %edx
    f463:	50                   	push   %eax
    f464:	53                   	push   %ebx
    f465:	6a 00                	push   $0x0
    f467:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f46a:	50                   	push   %eax
    f46b:	51                   	push   %ecx
    f46c:	e8 fc 89 ff ff       	call   7e6d <zlib_decompress>
    f471:	83 c4 20             	add    $0x20,%esp
    f474:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f477:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f47b:	74 11                	je     f48e <readChunk_iCCP+0x1b9>
    f47d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f480:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f483:	39 c2                	cmp    %eax,%edx
    f485:	7d 07                	jge    f48e <readChunk_iCCP+0x1b9>
    f487:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f48e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f491:	89 c2                	mov    %eax,%edx
    f493:	8b 45 08             	mov    0x8(%ebp),%eax
    f496:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f49c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f4a0:	75 14                	jne    f4b6 <readChunk_iCCP+0x1e1>
    f4a2:	8b 45 08             	mov    0x8(%ebp),%eax
    f4a5:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f4ab:	85 c0                	test   %eax,%eax
    f4ad:	75 07                	jne    f4b6 <readChunk_iCCP+0x1e1>
    f4af:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f4b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f4b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f4bc:	c9                   	leave  
    f4bd:	c3                   	ret    

0000f4be <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f4be:	55                   	push   %ebp
    f4bf:	89 e5                	mov    %esp,%ebp
    f4c1:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f4c4:	8b 55 0c             	mov    0xc(%ebp),%edx
    f4c7:	8b 45 10             	mov    0x10(%ebp),%eax
    f4ca:	01 d0                	add    %edx,%eax
    f4cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f4cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f4d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f4dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4e0:	83 c0 04             	add    $0x4,%eax
    f4e3:	3b 45 14             	cmp    0x14(%ebp),%eax
    f4e6:	7e 0a                	jle    f4f2 <lodepng_inspect_chunk+0x34>
    f4e8:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f4ed:	e9 43 03 00 00       	jmp    f835 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f4f2:	ff 75 ec             	pushl  -0x14(%ebp)
    f4f5:	e8 3a 8e ff ff       	call   8334 <lodepng_chunk_length>
    f4fa:	83 c4 04             	add    $0x4,%esp
    f4fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f500:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f503:	85 c0                	test   %eax,%eax
    f505:	79 0a                	jns    f511 <lodepng_inspect_chunk+0x53>
    f507:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f50c:	e9 24 03 00 00       	jmp    f835 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f511:	ff 75 ec             	pushl  -0x14(%ebp)
    f514:	e8 53 8f ff ff       	call   846c <lodepng_chunk_data_const>
    f519:	83 c4 04             	add    $0x4,%esp
    f51c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f51f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f522:	8d 50 04             	lea    0x4(%eax),%edx
    f525:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f528:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f52b:	8b 55 14             	mov    0x14(%ebp),%edx
    f52e:	8b 45 10             	mov    0x10(%ebp),%eax
    f531:	01 d0                	add    %edx,%eax
    f533:	39 c1                	cmp    %eax,%ecx
    f535:	76 0a                	jbe    f541 <lodepng_inspect_chunk+0x83>
    f537:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f53c:	e9 f4 02 00 00       	jmp    f835 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f541:	68 48 a1 01 00       	push   $0x1a148
    f546:	ff 75 ec             	pushl  -0x14(%ebp)
    f549:	e8 33 8e ff ff       	call   8381 <lodepng_chunk_type_equals>
    f54e:	83 c4 08             	add    $0x8,%esp
    f551:	84 c0                	test   %al,%al
    f553:	74 24                	je     f579 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f555:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f558:	8b 55 08             	mov    0x8(%ebp),%edx
    f55b:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f561:	83 ec 04             	sub    $0x4,%esp
    f564:	50                   	push   %eax
    f565:	ff 75 e4             	pushl  -0x1c(%ebp)
    f568:	52                   	push   %edx
    f569:	e8 5b ee ff ff       	call   e3c9 <readChunk_PLTE>
    f56e:	83 c4 10             	add    $0x10,%esp
    f571:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f574:	e9 8a 02 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f579:	83 ec 08             	sub    $0x8,%esp
    f57c:	68 4d a1 01 00       	push   $0x1a14d
    f581:	ff 75 ec             	pushl  -0x14(%ebp)
    f584:	e8 f8 8d ff ff       	call   8381 <lodepng_chunk_type_equals>
    f589:	83 c4 10             	add    $0x10,%esp
    f58c:	84 c0                	test   %al,%al
    f58e:	74 24                	je     f5b4 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f590:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f593:	8b 55 08             	mov    0x8(%ebp),%edx
    f596:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f59c:	83 ec 04             	sub    $0x4,%esp
    f59f:	50                   	push   %eax
    f5a0:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5a3:	52                   	push   %edx
    f5a4:	e8 40 ef ff ff       	call   e4e9 <readChunk_tRNS>
    f5a9:	83 c4 10             	add    $0x10,%esp
    f5ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5af:	e9 4f 02 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f5b4:	83 ec 08             	sub    $0x8,%esp
    f5b7:	68 52 a1 01 00       	push   $0x1a152
    f5bc:	ff 75 ec             	pushl  -0x14(%ebp)
    f5bf:	e8 bd 8d ff ff       	call   8381 <lodepng_chunk_type_equals>
    f5c4:	83 c4 10             	add    $0x10,%esp
    f5c7:	84 c0                	test   %al,%al
    f5c9:	74 24                	je     f5ef <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f5cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5ce:	8b 55 08             	mov    0x8(%ebp),%edx
    f5d1:	81 c2 98 00 00 00    	add    $0x98,%edx
    f5d7:	83 ec 04             	sub    $0x4,%esp
    f5da:	50                   	push   %eax
    f5db:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5de:	52                   	push   %edx
    f5df:	e8 68 f0 ff ff       	call   e64c <readChunk_bKGD>
    f5e4:	83 c4 10             	add    $0x10,%esp
    f5e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5ea:	e9 14 02 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f5ef:	83 ec 08             	sub    $0x8,%esp
    f5f2:	68 57 a1 01 00       	push   $0x1a157
    f5f7:	ff 75 ec             	pushl  -0x14(%ebp)
    f5fa:	e8 82 8d ff ff       	call   8381 <lodepng_chunk_type_equals>
    f5ff:	83 c4 10             	add    $0x10,%esp
    f602:	84 c0                	test   %al,%al
    f604:	74 24                	je     f62a <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f606:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f609:	8b 55 08             	mov    0x8(%ebp),%edx
    f60c:	81 c2 98 00 00 00    	add    $0x98,%edx
    f612:	83 ec 04             	sub    $0x4,%esp
    f615:	50                   	push   %eax
    f616:	ff 75 e4             	pushl  -0x1c(%ebp)
    f619:	52                   	push   %edx
    f61a:	e8 b0 f1 ff ff       	call   e7cf <readChunk_tEXt>
    f61f:	83 c4 10             	add    $0x10,%esp
    f622:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f625:	e9 d9 01 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f62a:	83 ec 08             	sub    $0x8,%esp
    f62d:	68 5c a1 01 00       	push   $0x1a15c
    f632:	ff 75 ec             	pushl  -0x14(%ebp)
    f635:	e8 47 8d ff ff       	call   8381 <lodepng_chunk_type_equals>
    f63a:	83 c4 10             	add    $0x10,%esp
    f63d:	84 c0                	test   %al,%al
    f63f:	74 25                	je     f666 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f641:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f644:	8b 45 08             	mov    0x8(%ebp),%eax
    f647:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f64a:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f650:	52                   	push   %edx
    f651:	ff 75 e4             	pushl  -0x1c(%ebp)
    f654:	50                   	push   %eax
    f655:	51                   	push   %ecx
    f656:	e8 c0 f2 ff ff       	call   e91b <readChunk_zTXt>
    f65b:	83 c4 10             	add    $0x10,%esp
    f65e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f661:	e9 9d 01 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f666:	83 ec 08             	sub    $0x8,%esp
    f669:	68 61 a1 01 00       	push   $0x1a161
    f66e:	ff 75 ec             	pushl  -0x14(%ebp)
    f671:	e8 0b 8d ff ff       	call   8381 <lodepng_chunk_type_equals>
    f676:	83 c4 10             	add    $0x10,%esp
    f679:	84 c0                	test   %al,%al
    f67b:	74 25                	je     f6a2 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f67d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f680:	8b 45 08             	mov    0x8(%ebp),%eax
    f683:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f686:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f68c:	52                   	push   %edx
    f68d:	ff 75 e4             	pushl  -0x1c(%ebp)
    f690:	50                   	push   %eax
    f691:	51                   	push   %ecx
    f692:	e8 40 f4 ff ff       	call   ead7 <readChunk_iTXt>
    f697:	83 c4 10             	add    $0x10,%esp
    f69a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f69d:	e9 61 01 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f6a2:	83 ec 08             	sub    $0x8,%esp
    f6a5:	68 66 a1 01 00       	push   $0x1a166
    f6aa:	ff 75 ec             	pushl  -0x14(%ebp)
    f6ad:	e8 cf 8c ff ff       	call   8381 <lodepng_chunk_type_equals>
    f6b2:	83 c4 10             	add    $0x10,%esp
    f6b5:	84 c0                	test   %al,%al
    f6b7:	74 24                	je     f6dd <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f6b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6bc:	8b 55 08             	mov    0x8(%ebp),%edx
    f6bf:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6c5:	83 ec 04             	sub    $0x4,%esp
    f6c8:	50                   	push   %eax
    f6c9:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6cc:	52                   	push   %edx
    f6cd:	e8 5b f7 ff ff       	call   ee2d <readChunk_tIME>
    f6d2:	83 c4 10             	add    $0x10,%esp
    f6d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6d8:	e9 26 01 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f6dd:	83 ec 08             	sub    $0x8,%esp
    f6e0:	68 6b a1 01 00       	push   $0x1a16b
    f6e5:	ff 75 ec             	pushl  -0x14(%ebp)
    f6e8:	e8 94 8c ff ff       	call   8381 <lodepng_chunk_type_equals>
    f6ed:	83 c4 10             	add    $0x10,%esp
    f6f0:	84 c0                	test   %al,%al
    f6f2:	74 24                	je     f718 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f6f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6f7:	8b 55 08             	mov    0x8(%ebp),%edx
    f6fa:	81 c2 98 00 00 00    	add    $0x98,%edx
    f700:	83 ec 04             	sub    $0x4,%esp
    f703:	50                   	push   %eax
    f704:	ff 75 e4             	pushl  -0x1c(%ebp)
    f707:	52                   	push   %edx
    f708:	e8 c0 f7 ff ff       	call   eecd <readChunk_pHYs>
    f70d:	83 c4 10             	add    $0x10,%esp
    f710:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f713:	e9 eb 00 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f718:	83 ec 08             	sub    $0x8,%esp
    f71b:	68 70 a1 01 00       	push   $0x1a170
    f720:	ff 75 ec             	pushl  -0x14(%ebp)
    f723:	e8 59 8c ff ff       	call   8381 <lodepng_chunk_type_equals>
    f728:	83 c4 10             	add    $0x10,%esp
    f72b:	84 c0                	test   %al,%al
    f72d:	74 24                	je     f753 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f72f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f732:	8b 55 08             	mov    0x8(%ebp),%edx
    f735:	81 c2 98 00 00 00    	add    $0x98,%edx
    f73b:	83 ec 04             	sub    $0x4,%esp
    f73e:	50                   	push   %eax
    f73f:	ff 75 e4             	pushl  -0x1c(%ebp)
    f742:	52                   	push   %edx
    f743:	e8 54 f8 ff ff       	call   ef9c <readChunk_gAMA>
    f748:	83 c4 10             	add    $0x10,%esp
    f74b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f74e:	e9 b0 00 00 00       	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f753:	83 ec 08             	sub    $0x8,%esp
    f756:	68 75 a1 01 00       	push   $0x1a175
    f75b:	ff 75 ec             	pushl  -0x14(%ebp)
    f75e:	e8 1e 8c ff ff       	call   8381 <lodepng_chunk_type_equals>
    f763:	83 c4 10             	add    $0x10,%esp
    f766:	84 c0                	test   %al,%al
    f768:	74 21                	je     f78b <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f76a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f76d:	8b 55 08             	mov    0x8(%ebp),%edx
    f770:	81 c2 98 00 00 00    	add    $0x98,%edx
    f776:	83 ec 04             	sub    $0x4,%esp
    f779:	50                   	push   %eax
    f77a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f77d:	52                   	push   %edx
    f77e:	e8 88 f8 ff ff       	call   f00b <readChunk_cHRM>
    f783:	83 c4 10             	add    $0x10,%esp
    f786:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f789:	eb 78                	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f78b:	83 ec 08             	sub    $0x8,%esp
    f78e:	68 7a a1 01 00       	push   $0x1a17a
    f793:	ff 75 ec             	pushl  -0x14(%ebp)
    f796:	e8 e6 8b ff ff       	call   8381 <lodepng_chunk_type_equals>
    f79b:	83 c4 10             	add    $0x10,%esp
    f79e:	84 c0                	test   %al,%al
    f7a0:	74 21                	je     f7c3 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f7a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7a5:	8b 55 08             	mov    0x8(%ebp),%edx
    f7a8:	81 c2 98 00 00 00    	add    $0x98,%edx
    f7ae:	83 ec 04             	sub    $0x4,%esp
    f7b1:	50                   	push   %eax
    f7b2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7b5:	52                   	push   %edx
    f7b6:	e8 e4 fa ff ff       	call   f29f <readChunk_sRGB>
    f7bb:	83 c4 10             	add    $0x10,%esp
    f7be:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7c1:	eb 40                	jmp    f803 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f7c3:	83 ec 08             	sub    $0x8,%esp
    f7c6:	68 7f a1 01 00       	push   $0x1a17f
    f7cb:	ff 75 ec             	pushl  -0x14(%ebp)
    f7ce:	e8 ae 8b ff ff       	call   8381 <lodepng_chunk_type_equals>
    f7d3:	83 c4 10             	add    $0x10,%esp
    f7d6:	84 c0                	test   %al,%al
    f7d8:	74 22                	je     f7fc <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f7da:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f7dd:	8b 45 08             	mov    0x8(%ebp),%eax
    f7e0:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f7e3:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f7e9:	52                   	push   %edx
    f7ea:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7ed:	50                   	push   %eax
    f7ee:	51                   	push   %ecx
    f7ef:	e8 e1 fa ff ff       	call   f2d5 <readChunk_iCCP>
    f7f4:	83 c4 10             	add    $0x10,%esp
    f7f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7fa:	eb 07                	jmp    f803 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f7fc:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f803:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f807:	75 29                	jne    f832 <lodepng_inspect_chunk+0x374>
    f809:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f80d:	75 23                	jne    f832 <lodepng_inspect_chunk+0x374>
    f80f:	8b 45 08             	mov    0x8(%ebp),%eax
    f812:	8b 40 18             	mov    0x18(%eax),%eax
    f815:	85 c0                	test   %eax,%eax
    f817:	75 19                	jne    f832 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f819:	83 ec 0c             	sub    $0xc,%esp
    f81c:	ff 75 ec             	pushl  -0x14(%ebp)
    f81f:	e8 53 8c ff ff       	call   8477 <lodepng_chunk_check_crc>
    f824:	83 c4 10             	add    $0x10,%esp
    f827:	85 c0                	test   %eax,%eax
    f829:	74 07                	je     f832 <lodepng_inspect_chunk+0x374>
    f82b:	b8 39 00 00 00       	mov    $0x39,%eax
    f830:	eb 03                	jmp    f835 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f832:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f835:	c9                   	leave  
    f836:	c3                   	ret    

0000f837 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f837:	55                   	push   %ebp
    f838:	89 e5                	mov    %esp,%ebp
    f83a:	56                   	push   %esi
    f83b:	53                   	push   %ebx
    f83c:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f83f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f843:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f84a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f851:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f858:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f85f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f866:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f86d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f874:	8b 45 08             	mov    0x8(%ebp),%eax
    f877:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f87d:	8b 45 10             	mov    0x10(%ebp),%eax
    f880:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f886:	8b 45 10             	mov    0x10(%ebp),%eax
    f889:	8b 10                	mov    (%eax),%edx
    f88b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f88e:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f890:	83 ec 0c             	sub    $0xc,%esp
    f893:	ff 75 1c             	pushl  0x1c(%ebp)
    f896:	ff 75 18             	pushl  0x18(%ebp)
    f899:	ff 75 14             	pushl  0x14(%ebp)
    f89c:	ff 75 10             	pushl  0x10(%ebp)
    f89f:	ff 75 0c             	pushl  0xc(%ebp)
    f8a2:	e8 d3 da ff ff       	call   d37a <lodepng_inspect>
    f8a7:	83 c4 20             	add    $0x20,%esp
    f8aa:	89 c2                	mov    %eax,%edx
    f8ac:	8b 45 14             	mov    0x14(%ebp),%eax
    f8af:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f8b5:	8b 45 14             	mov    0x14(%ebp),%eax
    f8b8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f8be:	85 c0                	test   %eax,%eax
    f8c0:	0f 85 24 0a 00 00    	jne    102ea <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f8c6:	8b 45 14             	mov    0x14(%ebp),%eax
    f8c9:	8d 58 78             	lea    0x78(%eax),%ebx
    f8cc:	8b 45 14             	mov    0x14(%ebp),%eax
    f8cf:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f8d5:	8b 45 10             	mov    0x10(%ebp),%eax
    f8d8:	8b 10                	mov    (%eax),%edx
    f8da:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8dd:	8b 00                	mov    (%eax),%eax
    f8df:	53                   	push   %ebx
    f8e0:	51                   	push   %ecx
    f8e1:	52                   	push   %edx
    f8e2:	50                   	push   %eax
    f8e3:	e8 76 97 ff ff       	call   905e <lodepng_pixel_overflow>
    f8e8:	83 c4 10             	add    $0x10,%esp
    f8eb:	85 c0                	test   %eax,%eax
    f8ed:	74 12                	je     f901 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f8ef:	8b 45 14             	mov    0x14(%ebp),%eax
    f8f2:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f8f9:	00 00 00 
    f8fc:	e9 ea 09 00 00       	jmp    102eb <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f901:	83 ec 0c             	sub    $0xc,%esp
    f904:	ff 75 1c             	pushl  0x1c(%ebp)
    f907:	e8 a6 3a ff ff       	call   33b2 <lodepng_malloc>
    f90c:	83 c4 10             	add    $0x10,%esp
    f90f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f912:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f916:	75 12                	jne    f92a <decodeGeneric+0xf3>
    f918:	8b 45 14             	mov    0x14(%ebp),%eax
    f91b:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f922:	00 00 00 
    f925:	e9 c1 09 00 00       	jmp    102eb <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f92a:	8b 45 18             	mov    0x18(%ebp),%eax
    f92d:	83 c0 21             	add    $0x21,%eax
    f930:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f933:	e9 81 06 00 00       	jmp    ffb9 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f938:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f93b:	8b 45 18             	mov    0x18(%ebp),%eax
    f93e:	29 c2                	sub    %eax,%edx
    f940:	89 d0                	mov    %edx,%eax
    f942:	83 c0 0c             	add    $0xc,%eax
    f945:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f948:	7f 08                	jg     f952 <decodeGeneric+0x11b>
    f94a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f94d:	3b 45 18             	cmp    0x18(%ebp),%eax
    f950:	73 20                	jae    f972 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f952:	8b 45 14             	mov    0x14(%ebp),%eax
    f955:	8b 40 20             	mov    0x20(%eax),%eax
    f958:	85 c0                	test   %eax,%eax
    f95a:	0f 85 72 06 00 00    	jne    ffd2 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f960:	8b 45 14             	mov    0x14(%ebp),%eax
    f963:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f96a:	00 00 00 
    f96d:	e9 6a 06 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f972:	83 ec 0c             	sub    $0xc,%esp
    f975:	ff 75 f0             	pushl  -0x10(%ebp)
    f978:	e8 b7 89 ff ff       	call   8334 <lodepng_chunk_length>
    f97d:	83 c4 10             	add    $0x10,%esp
    f980:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f983:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f986:	85 c0                	test   %eax,%eax
    f988:	79 20                	jns    f9aa <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f98a:	8b 45 14             	mov    0x14(%ebp),%eax
    f98d:	8b 40 20             	mov    0x20(%eax),%eax
    f990:	85 c0                	test   %eax,%eax
    f992:	0f 85 3d 06 00 00    	jne    ffd5 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f998:	8b 45 14             	mov    0x14(%ebp),%eax
    f99b:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f9a2:	00 00 00 
    f9a5:	e9 32 06 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f9aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9ad:	8b 45 18             	mov    0x18(%ebp),%eax
    f9b0:	29 c2                	sub    %eax,%edx
    f9b2:	89 d0                	mov    %edx,%eax
    f9b4:	89 c2                	mov    %eax,%edx
    f9b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9b9:	01 d0                	add    %edx,%eax
    f9bb:	83 c0 0c             	add    $0xc,%eax
    f9be:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f9c1:	7f 10                	jg     f9d3 <decodeGeneric+0x19c>
    f9c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9c6:	8d 50 0c             	lea    0xc(%eax),%edx
    f9c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f9cc:	01 d0                	add    %edx,%eax
    f9ce:	3b 45 18             	cmp    0x18(%ebp),%eax
    f9d1:	73 12                	jae    f9e5 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    f9d3:	8b 45 14             	mov    0x14(%ebp),%eax
    f9d6:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    f9dd:	00 00 00 
    f9e0:	e9 f7 05 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    f9e5:	83 ec 0c             	sub    $0xc,%esp
    f9e8:	ff 75 f0             	pushl  -0x10(%ebp)
    f9eb:	e8 7c 8a ff ff       	call   846c <lodepng_chunk_data_const>
    f9f0:	83 c4 10             	add    $0x10,%esp
    f9f3:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    f9f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    f9fd:	83 ec 08             	sub    $0x8,%esp
    fa00:	68 84 a1 01 00       	push   $0x1a184
    fa05:	ff 75 f0             	pushl  -0x10(%ebp)
    fa08:	e8 74 89 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fa0d:	83 c4 10             	add    $0x10,%esp
    fa10:	84 c0                	test   %al,%al
    fa12:	74 79                	je     fa8d <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    fa14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa17:	83 ec 04             	sub    $0x4,%esp
    fa1a:	8d 55 bc             	lea    -0x44(%ebp),%edx
    fa1d:	52                   	push   %edx
    fa1e:	50                   	push   %eax
    fa1f:	ff 75 ec             	pushl  -0x14(%ebp)
    fa22:	e8 4f 3a ff ff       	call   3476 <lodepng_addofl>
    fa27:	83 c4 10             	add    $0x10,%esp
    fa2a:	85 c0                	test   %eax,%eax
    fa2c:	74 12                	je     fa40 <decodeGeneric+0x209>
    fa2e:	8b 45 14             	mov    0x14(%ebp),%eax
    fa31:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fa38:	00 00 00 
    fa3b:	e9 9c 05 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    fa40:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fa43:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fa46:	7e 13                	jle    fa5b <decodeGeneric+0x224>
    fa48:	8b 45 14             	mov    0x14(%ebp),%eax
    fa4b:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fa52:	00 00 00 
    fa55:	90                   	nop
    fa56:	e9 81 05 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    fa5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa5e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    fa61:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fa64:	01 ca                	add    %ecx,%edx
    fa66:	83 ec 04             	sub    $0x4,%esp
    fa69:	50                   	push   %eax
    fa6a:	ff 75 d0             	pushl  -0x30(%ebp)
    fa6d:	52                   	push   %edx
    fa6e:	e8 7d 39 ff ff       	call   33f0 <lodepng_memcpy>
    fa73:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fa76:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fa79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa7c:	01 d0                	add    %edx,%eax
    fa7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fa81:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fa88:	e9 db 04 00 00       	jmp    ff68 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fa8d:	83 ec 08             	sub    $0x8,%esp
    fa90:	68 89 a1 01 00       	push   $0x1a189
    fa95:	ff 75 f0             	pushl  -0x10(%ebp)
    fa98:	e8 e4 88 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fa9d:	83 c4 10             	add    $0x10,%esp
    faa0:	84 c0                	test   %al,%al
    faa2:	74 09                	je     faad <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    faa4:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    faa8:	e9 bb 04 00 00       	jmp    ff68 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    faad:	83 ec 08             	sub    $0x8,%esp
    fab0:	68 48 a1 01 00       	push   $0x1a148
    fab5:	ff 75 f0             	pushl  -0x10(%ebp)
    fab8:	e8 c4 88 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fabd:	83 c4 10             	add    $0x10,%esp
    fac0:	84 c0                	test   %al,%al
    fac2:	74 44                	je     fb08 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fac4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fac7:	8b 55 14             	mov    0x14(%ebp),%edx
    faca:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fad0:	83 ec 04             	sub    $0x4,%esp
    fad3:	50                   	push   %eax
    fad4:	ff 75 d0             	pushl  -0x30(%ebp)
    fad7:	52                   	push   %edx
    fad8:	e8 ec e8 ff ff       	call   e3c9 <readChunk_PLTE>
    fadd:	83 c4 10             	add    $0x10,%esp
    fae0:	89 c2                	mov    %eax,%edx
    fae2:	8b 45 14             	mov    0x14(%ebp),%eax
    fae5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    faeb:	8b 45 14             	mov    0x14(%ebp),%eax
    faee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    faf4:	85 c0                	test   %eax,%eax
    faf6:	0f 85 dc 04 00 00    	jne    ffd8 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fafc:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fb03:	e9 60 04 00 00       	jmp    ff68 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fb08:	83 ec 08             	sub    $0x8,%esp
    fb0b:	68 4d a1 01 00       	push   $0x1a14d
    fb10:	ff 75 f0             	pushl  -0x10(%ebp)
    fb13:	e8 69 88 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fb18:	83 c4 10             	add    $0x10,%esp
    fb1b:	84 c0                	test   %al,%al
    fb1d:	74 3d                	je     fb5c <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fb1f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb22:	8b 55 14             	mov    0x14(%ebp),%edx
    fb25:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fb2b:	83 ec 04             	sub    $0x4,%esp
    fb2e:	50                   	push   %eax
    fb2f:	ff 75 d0             	pushl  -0x30(%ebp)
    fb32:	52                   	push   %edx
    fb33:	e8 b1 e9 ff ff       	call   e4e9 <readChunk_tRNS>
    fb38:	83 c4 10             	add    $0x10,%esp
    fb3b:	89 c2                	mov    %eax,%edx
    fb3d:	8b 45 14             	mov    0x14(%ebp),%eax
    fb40:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb46:	8b 45 14             	mov    0x14(%ebp),%eax
    fb49:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb4f:	85 c0                	test   %eax,%eax
    fb51:	0f 84 11 04 00 00    	je     ff68 <decodeGeneric+0x731>
    fb57:	e9 80 04 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fb5c:	83 ec 08             	sub    $0x8,%esp
    fb5f:	68 52 a1 01 00       	push   $0x1a152
    fb64:	ff 75 f0             	pushl  -0x10(%ebp)
    fb67:	e8 15 88 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fb6c:	83 c4 10             	add    $0x10,%esp
    fb6f:	84 c0                	test   %al,%al
    fb71:	74 3d                	je     fbb0 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fb73:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb76:	8b 55 14             	mov    0x14(%ebp),%edx
    fb79:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb7f:	83 ec 04             	sub    $0x4,%esp
    fb82:	50                   	push   %eax
    fb83:	ff 75 d0             	pushl  -0x30(%ebp)
    fb86:	52                   	push   %edx
    fb87:	e8 c0 ea ff ff       	call   e64c <readChunk_bKGD>
    fb8c:	83 c4 10             	add    $0x10,%esp
    fb8f:	89 c2                	mov    %eax,%edx
    fb91:	8b 45 14             	mov    0x14(%ebp),%eax
    fb94:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb9a:	8b 45 14             	mov    0x14(%ebp),%eax
    fb9d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fba3:	85 c0                	test   %eax,%eax
    fba5:	0f 84 bd 03 00 00    	je     ff68 <decodeGeneric+0x731>
    fbab:	e9 2c 04 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fbb0:	83 ec 08             	sub    $0x8,%esp
    fbb3:	68 57 a1 01 00       	push   $0x1a157
    fbb8:	ff 75 f0             	pushl  -0x10(%ebp)
    fbbb:	e8 c1 87 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fbc0:	83 c4 10             	add    $0x10,%esp
    fbc3:	84 c0                	test   %al,%al
    fbc5:	74 4b                	je     fc12 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fbc7:	8b 45 14             	mov    0x14(%ebp),%eax
    fbca:	8b 40 28             	mov    0x28(%eax),%eax
    fbcd:	85 c0                	test   %eax,%eax
    fbcf:	0f 84 93 03 00 00    	je     ff68 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fbd5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbd8:	8b 55 14             	mov    0x14(%ebp),%edx
    fbdb:	81 c2 98 00 00 00    	add    $0x98,%edx
    fbe1:	83 ec 04             	sub    $0x4,%esp
    fbe4:	50                   	push   %eax
    fbe5:	ff 75 d0             	pushl  -0x30(%ebp)
    fbe8:	52                   	push   %edx
    fbe9:	e8 e1 eb ff ff       	call   e7cf <readChunk_tEXt>
    fbee:	83 c4 10             	add    $0x10,%esp
    fbf1:	89 c2                	mov    %eax,%edx
    fbf3:	8b 45 14             	mov    0x14(%ebp),%eax
    fbf6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fbfc:	8b 45 14             	mov    0x14(%ebp),%eax
    fbff:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc05:	85 c0                	test   %eax,%eax
    fc07:	0f 84 5b 03 00 00    	je     ff68 <decodeGeneric+0x731>
    fc0d:	e9 ca 03 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fc12:	83 ec 08             	sub    $0x8,%esp
    fc15:	68 5c a1 01 00       	push   $0x1a15c
    fc1a:	ff 75 f0             	pushl  -0x10(%ebp)
    fc1d:	e8 5f 87 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fc22:	83 c4 10             	add    $0x10,%esp
    fc25:	84 c0                	test   %al,%al
    fc27:	74 4c                	je     fc75 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fc29:	8b 45 14             	mov    0x14(%ebp),%eax
    fc2c:	8b 40 28             	mov    0x28(%eax),%eax
    fc2f:	85 c0                	test   %eax,%eax
    fc31:	0f 84 31 03 00 00    	je     ff68 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fc37:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc3a:	8b 45 14             	mov    0x14(%ebp),%eax
    fc3d:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fc40:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fc46:	52                   	push   %edx
    fc47:	ff 75 d0             	pushl  -0x30(%ebp)
    fc4a:	50                   	push   %eax
    fc4b:	51                   	push   %ecx
    fc4c:	e8 ca ec ff ff       	call   e91b <readChunk_zTXt>
    fc51:	83 c4 10             	add    $0x10,%esp
    fc54:	89 c2                	mov    %eax,%edx
    fc56:	8b 45 14             	mov    0x14(%ebp),%eax
    fc59:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc5f:	8b 45 14             	mov    0x14(%ebp),%eax
    fc62:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc68:	85 c0                	test   %eax,%eax
    fc6a:	0f 84 f8 02 00 00    	je     ff68 <decodeGeneric+0x731>
    fc70:	e9 67 03 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fc75:	83 ec 08             	sub    $0x8,%esp
    fc78:	68 61 a1 01 00       	push   $0x1a161
    fc7d:	ff 75 f0             	pushl  -0x10(%ebp)
    fc80:	e8 fc 86 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fc85:	83 c4 10             	add    $0x10,%esp
    fc88:	84 c0                	test   %al,%al
    fc8a:	74 4c                	je     fcd8 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fc8c:	8b 45 14             	mov    0x14(%ebp),%eax
    fc8f:	8b 40 28             	mov    0x28(%eax),%eax
    fc92:	85 c0                	test   %eax,%eax
    fc94:	0f 84 ce 02 00 00    	je     ff68 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fc9a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc9d:	8b 45 14             	mov    0x14(%ebp),%eax
    fca0:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fca3:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fca9:	52                   	push   %edx
    fcaa:	ff 75 d0             	pushl  -0x30(%ebp)
    fcad:	50                   	push   %eax
    fcae:	51                   	push   %ecx
    fcaf:	e8 23 ee ff ff       	call   ead7 <readChunk_iTXt>
    fcb4:	83 c4 10             	add    $0x10,%esp
    fcb7:	89 c2                	mov    %eax,%edx
    fcb9:	8b 45 14             	mov    0x14(%ebp),%eax
    fcbc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fcc2:	8b 45 14             	mov    0x14(%ebp),%eax
    fcc5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fccb:	85 c0                	test   %eax,%eax
    fccd:	0f 84 95 02 00 00    	je     ff68 <decodeGeneric+0x731>
    fcd3:	e9 04 03 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fcd8:	83 ec 08             	sub    $0x8,%esp
    fcdb:	68 66 a1 01 00       	push   $0x1a166
    fce0:	ff 75 f0             	pushl  -0x10(%ebp)
    fce3:	e8 99 86 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fce8:	83 c4 10             	add    $0x10,%esp
    fceb:	84 c0                	test   %al,%al
    fced:	74 3d                	je     fd2c <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fcef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcf2:	8b 55 14             	mov    0x14(%ebp),%edx
    fcf5:	81 c2 98 00 00 00    	add    $0x98,%edx
    fcfb:	83 ec 04             	sub    $0x4,%esp
    fcfe:	50                   	push   %eax
    fcff:	ff 75 d0             	pushl  -0x30(%ebp)
    fd02:	52                   	push   %edx
    fd03:	e8 25 f1 ff ff       	call   ee2d <readChunk_tIME>
    fd08:	83 c4 10             	add    $0x10,%esp
    fd0b:	89 c2                	mov    %eax,%edx
    fd0d:	8b 45 14             	mov    0x14(%ebp),%eax
    fd10:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd16:	8b 45 14             	mov    0x14(%ebp),%eax
    fd19:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd1f:	85 c0                	test   %eax,%eax
    fd21:	0f 84 41 02 00 00    	je     ff68 <decodeGeneric+0x731>
    fd27:	e9 b0 02 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fd2c:	83 ec 08             	sub    $0x8,%esp
    fd2f:	68 6b a1 01 00       	push   $0x1a16b
    fd34:	ff 75 f0             	pushl  -0x10(%ebp)
    fd37:	e8 45 86 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fd3c:	83 c4 10             	add    $0x10,%esp
    fd3f:	84 c0                	test   %al,%al
    fd41:	74 3d                	je     fd80 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fd43:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd46:	8b 55 14             	mov    0x14(%ebp),%edx
    fd49:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd4f:	83 ec 04             	sub    $0x4,%esp
    fd52:	50                   	push   %eax
    fd53:	ff 75 d0             	pushl  -0x30(%ebp)
    fd56:	52                   	push   %edx
    fd57:	e8 71 f1 ff ff       	call   eecd <readChunk_pHYs>
    fd5c:	83 c4 10             	add    $0x10,%esp
    fd5f:	89 c2                	mov    %eax,%edx
    fd61:	8b 45 14             	mov    0x14(%ebp),%eax
    fd64:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd6a:	8b 45 14             	mov    0x14(%ebp),%eax
    fd6d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd73:	85 c0                	test   %eax,%eax
    fd75:	0f 84 ed 01 00 00    	je     ff68 <decodeGeneric+0x731>
    fd7b:	e9 5c 02 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fd80:	83 ec 08             	sub    $0x8,%esp
    fd83:	68 70 a1 01 00       	push   $0x1a170
    fd88:	ff 75 f0             	pushl  -0x10(%ebp)
    fd8b:	e8 f1 85 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fd90:	83 c4 10             	add    $0x10,%esp
    fd93:	84 c0                	test   %al,%al
    fd95:	74 3d                	je     fdd4 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fd97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd9a:	8b 55 14             	mov    0x14(%ebp),%edx
    fd9d:	81 c2 98 00 00 00    	add    $0x98,%edx
    fda3:	83 ec 04             	sub    $0x4,%esp
    fda6:	50                   	push   %eax
    fda7:	ff 75 d0             	pushl  -0x30(%ebp)
    fdaa:	52                   	push   %edx
    fdab:	e8 ec f1 ff ff       	call   ef9c <readChunk_gAMA>
    fdb0:	83 c4 10             	add    $0x10,%esp
    fdb3:	89 c2                	mov    %eax,%edx
    fdb5:	8b 45 14             	mov    0x14(%ebp),%eax
    fdb8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdbe:	8b 45 14             	mov    0x14(%ebp),%eax
    fdc1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdc7:	85 c0                	test   %eax,%eax
    fdc9:	0f 84 99 01 00 00    	je     ff68 <decodeGeneric+0x731>
    fdcf:	e9 08 02 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fdd4:	83 ec 08             	sub    $0x8,%esp
    fdd7:	68 75 a1 01 00       	push   $0x1a175
    fddc:	ff 75 f0             	pushl  -0x10(%ebp)
    fddf:	e8 9d 85 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fde4:	83 c4 10             	add    $0x10,%esp
    fde7:	84 c0                	test   %al,%al
    fde9:	74 3d                	je     fe28 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fdeb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdee:	8b 55 14             	mov    0x14(%ebp),%edx
    fdf1:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdf7:	83 ec 04             	sub    $0x4,%esp
    fdfa:	50                   	push   %eax
    fdfb:	ff 75 d0             	pushl  -0x30(%ebp)
    fdfe:	52                   	push   %edx
    fdff:	e8 07 f2 ff ff       	call   f00b <readChunk_cHRM>
    fe04:	83 c4 10             	add    $0x10,%esp
    fe07:	89 c2                	mov    %eax,%edx
    fe09:	8b 45 14             	mov    0x14(%ebp),%eax
    fe0c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe12:	8b 45 14             	mov    0x14(%ebp),%eax
    fe15:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe1b:	85 c0                	test   %eax,%eax
    fe1d:	0f 84 45 01 00 00    	je     ff68 <decodeGeneric+0x731>
    fe23:	e9 b4 01 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fe28:	83 ec 08             	sub    $0x8,%esp
    fe2b:	68 7a a1 01 00       	push   $0x1a17a
    fe30:	ff 75 f0             	pushl  -0x10(%ebp)
    fe33:	e8 49 85 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fe38:	83 c4 10             	add    $0x10,%esp
    fe3b:	84 c0                	test   %al,%al
    fe3d:	74 3d                	je     fe7c <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fe3f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe42:	8b 55 14             	mov    0x14(%ebp),%edx
    fe45:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe4b:	83 ec 04             	sub    $0x4,%esp
    fe4e:	50                   	push   %eax
    fe4f:	ff 75 d0             	pushl  -0x30(%ebp)
    fe52:	52                   	push   %edx
    fe53:	e8 47 f4 ff ff       	call   f29f <readChunk_sRGB>
    fe58:	83 c4 10             	add    $0x10,%esp
    fe5b:	89 c2                	mov    %eax,%edx
    fe5d:	8b 45 14             	mov    0x14(%ebp),%eax
    fe60:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe66:	8b 45 14             	mov    0x14(%ebp),%eax
    fe69:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe6f:	85 c0                	test   %eax,%eax
    fe71:	0f 84 f1 00 00 00    	je     ff68 <decodeGeneric+0x731>
    fe77:	e9 60 01 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fe7c:	83 ec 08             	sub    $0x8,%esp
    fe7f:	68 7f a1 01 00       	push   $0x1a17f
    fe84:	ff 75 f0             	pushl  -0x10(%ebp)
    fe87:	e8 f5 84 ff ff       	call   8381 <lodepng_chunk_type_equals>
    fe8c:	83 c4 10             	add    $0x10,%esp
    fe8f:	84 c0                	test   %al,%al
    fe91:	74 3e                	je     fed1 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fe93:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe96:	8b 45 14             	mov    0x14(%ebp),%eax
    fe99:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fe9c:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fea2:	52                   	push   %edx
    fea3:	ff 75 d0             	pushl  -0x30(%ebp)
    fea6:	50                   	push   %eax
    fea7:	51                   	push   %ecx
    fea8:	e8 28 f4 ff ff       	call   f2d5 <readChunk_iCCP>
    fead:	83 c4 10             	add    $0x10,%esp
    feb0:	89 c2                	mov    %eax,%edx
    feb2:	8b 45 14             	mov    0x14(%ebp),%eax
    feb5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    febb:	8b 45 14             	mov    0x14(%ebp),%eax
    febe:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fec4:	85 c0                	test   %eax,%eax
    fec6:	0f 84 9c 00 00 00    	je     ff68 <decodeGeneric+0x731>
    fecc:	e9 0b 01 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    fed1:	8b 45 14             	mov    0x14(%ebp),%eax
    fed4:	8b 40 1c             	mov    0x1c(%eax),%eax
    fed7:	85 c0                	test   %eax,%eax
    fed9:	75 24                	jne    feff <decodeGeneric+0x6c8>
    fedb:	83 ec 0c             	sub    $0xc,%esp
    fede:	ff 75 f0             	pushl  -0x10(%ebp)
    fee1:	e8 30 85 ff ff       	call   8416 <lodepng_chunk_ancillary>
    fee6:	83 c4 10             	add    $0x10,%esp
    fee9:	84 c0                	test   %al,%al
    feeb:	75 12                	jne    feff <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    feed:	8b 45 14             	mov    0x14(%ebp),%eax
    fef0:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    fef7:	00 00 00 
    fefa:	e9 dd 00 00 00       	jmp    ffdc <decodeGeneric+0x7a5>
      }

      unknown = 1;
    feff:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    ff06:	8b 45 14             	mov    0x14(%ebp),%eax
    ff09:	8b 40 2c             	mov    0x2c(%eax),%eax
    ff0c:	85 c0                	test   %eax,%eax
    ff0e:	74 58                	je     ff68 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    ff10:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff13:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    ff16:	83 c0 58             	add    $0x58,%eax
    ff19:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ff20:	8b 45 14             	mov    0x14(%ebp),%eax
    ff23:	01 d0                	add    %edx,%eax
    ff25:	8d 50 10             	lea    0x10(%eax),%edx
    ff28:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff2b:	83 e8 01             	sub    $0x1,%eax
    ff2e:	83 c0 54             	add    $0x54,%eax
    ff31:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    ff38:	8b 45 14             	mov    0x14(%ebp),%eax
    ff3b:	01 c8                	add    %ecx,%eax
    ff3d:	83 c0 14             	add    $0x14,%eax
    ff40:	83 ec 04             	sub    $0x4,%esp
    ff43:	ff 75 f0             	pushl  -0x10(%ebp)
    ff46:	52                   	push   %edx
    ff47:	50                   	push   %eax
    ff48:	e8 15 88 ff ff       	call   8762 <lodepng_chunk_append>
    ff4d:	83 c4 10             	add    $0x10,%esp
    ff50:	89 c2                	mov    %eax,%edx
    ff52:	8b 45 14             	mov    0x14(%ebp),%eax
    ff55:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ff5b:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff64:	85 c0                	test   %eax,%eax
    ff66:	75 73                	jne    ffdb <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    ff68:	8b 45 14             	mov    0x14(%ebp),%eax
    ff6b:	8b 40 18             	mov    0x18(%eax),%eax
    ff6e:	85 c0                	test   %eax,%eax
    ff70:	75 27                	jne    ff99 <decodeGeneric+0x762>
    ff72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ff76:	75 21                	jne    ff99 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    ff78:	83 ec 0c             	sub    $0xc,%esp
    ff7b:	ff 75 f0             	pushl  -0x10(%ebp)
    ff7e:	e8 f4 84 ff ff       	call   8477 <lodepng_chunk_check_crc>
    ff83:	83 c4 10             	add    $0x10,%esp
    ff86:	85 c0                	test   %eax,%eax
    ff88:	74 0f                	je     ff99 <decodeGeneric+0x762>
    ff8a:	8b 45 14             	mov    0x14(%ebp),%eax
    ff8d:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    ff94:	00 00 00 
    ff97:	eb 43                	jmp    ffdc <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    ff99:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff9d:	75 1a                	jne    ffb9 <decodeGeneric+0x782>
    ff9f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ffa2:	8b 45 18             	mov    0x18(%ebp),%eax
    ffa5:	01 d0                	add    %edx,%eax
    ffa7:	83 ec 08             	sub    $0x8,%esp
    ffaa:	50                   	push   %eax
    ffab:	ff 75 f0             	pushl  -0x10(%ebp)
    ffae:	e8 3f 86 ff ff       	call   85f2 <lodepng_chunk_next_const>
    ffb3:	83 c4 10             	add    $0x10,%esp
    ffb6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    ffb9:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ffbd:	75 1d                	jne    ffdc <decodeGeneric+0x7a5>
    ffbf:	8b 45 14             	mov    0x14(%ebp),%eax
    ffc2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffc8:	85 c0                	test   %eax,%eax
    ffca:	0f 84 68 f9 ff ff    	je     f938 <decodeGeneric+0x101>
    ffd0:	eb 0a                	jmp    ffdc <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ffd2:	90                   	nop
    ffd3:	eb 07                	jmp    ffdc <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ffd5:	90                   	nop
    ffd6:	eb 04                	jmp    ffdc <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    ffd8:	90                   	nop
    ffd9:	eb 01                	jmp    ffdc <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ffdb:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
    ffdc:	8b 45 14             	mov    0x14(%ebp),%eax
    ffdf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffe5:	85 c0                	test   %eax,%eax
    ffe7:	75 28                	jne    10011 <decodeGeneric+0x7da>
    ffe9:	8b 45 14             	mov    0x14(%ebp),%eax
    ffec:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
    fff2:	83 f8 03             	cmp    $0x3,%eax
    fff5:	75 1a                	jne    10011 <decodeGeneric+0x7da>
    fff7:	8b 45 14             	mov    0x14(%ebp),%eax
    fffa:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10000:	85 c0                	test   %eax,%eax
   10002:	75 0d                	jne    10011 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   10004:	8b 45 14             	mov    0x14(%ebp),%eax
   10007:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   1000e:	00 00 00 
  }

  if(!state->error) {
   10011:	8b 45 14             	mov    0x14(%ebp),%eax
   10014:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1001a:	85 c0                	test   %eax,%eax
   1001c:	0f 85 d2 01 00 00    	jne    101f4 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10022:	8b 45 14             	mov    0x14(%ebp),%eax
   10025:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   1002b:	85 c0                	test   %eax,%eax
   1002d:	75 3a                	jne    10069 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   1002f:	8b 45 14             	mov    0x14(%ebp),%eax
   10032:	05 a4 00 00 00       	add    $0xa4,%eax
   10037:	83 ec 0c             	sub    $0xc,%esp
   1003a:	50                   	push   %eax
   1003b:	e8 8e 8e ff ff       	call   8ece <lodepng_get_bpp>
   10040:	83 c4 10             	add    $0x10,%esp
   10043:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   10046:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   10049:	8b 45 10             	mov    0x10(%ebp),%eax
   1004c:	8b 10                	mov    (%eax),%edx
   1004e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10051:	8b 00                	mov    (%eax),%eax
   10053:	83 ec 04             	sub    $0x4,%esp
   10056:	51                   	push   %ecx
   10057:	52                   	push   %edx
   10058:	50                   	push   %eax
   10059:	e8 cf 8f ff ff       	call   902d <lodepng_get_raw_size_idat>
   1005e:	83 c4 10             	add    $0x10,%esp
   10061:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10064:	e9 60 01 00 00       	jmp    101c9 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10069:	8b 45 14             	mov    0x14(%ebp),%eax
   1006c:	05 a4 00 00 00       	add    $0xa4,%eax
   10071:	83 ec 0c             	sub    $0xc,%esp
   10074:	50                   	push   %eax
   10075:	e8 54 8e ff ff       	call   8ece <lodepng_get_bpp>
   1007a:	83 c4 10             	add    $0x10,%esp
   1007d:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   10080:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   10087:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1008a:	8b 55 10             	mov    0x10(%ebp),%edx
   1008d:	8b 12                	mov    (%edx),%edx
   1008f:	83 c2 07             	add    $0x7,%edx
   10092:	89 d1                	mov    %edx,%ecx
   10094:	c1 e9 03             	shr    $0x3,%ecx
   10097:	8b 55 0c             	mov    0xc(%ebp),%edx
   1009a:	8b 12                	mov    (%edx),%edx
   1009c:	83 c2 07             	add    $0x7,%edx
   1009f:	c1 ea 03             	shr    $0x3,%edx
   100a2:	83 ec 04             	sub    $0x4,%esp
   100a5:	50                   	push   %eax
   100a6:	51                   	push   %ecx
   100a7:	52                   	push   %edx
   100a8:	e8 80 8f ff ff       	call   902d <lodepng_get_raw_size_idat>
   100ad:	83 c4 10             	add    $0x10,%esp
   100b0:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   100b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   100b6:	8b 00                	mov    (%eax),%eax
   100b8:	83 f8 04             	cmp    $0x4,%eax
   100bb:	76 2c                	jbe    100e9 <decodeGeneric+0x8b2>
   100bd:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100c0:	8b 55 10             	mov    0x10(%ebp),%edx
   100c3:	8b 12                	mov    (%edx),%edx
   100c5:	83 c2 07             	add    $0x7,%edx
   100c8:	89 d1                	mov    %edx,%ecx
   100ca:	c1 e9 03             	shr    $0x3,%ecx
   100cd:	8b 55 0c             	mov    0xc(%ebp),%edx
   100d0:	8b 12                	mov    (%edx),%edx
   100d2:	83 c2 03             	add    $0x3,%edx
   100d5:	c1 ea 03             	shr    $0x3,%edx
   100d8:	83 ec 04             	sub    $0x4,%esp
   100db:	50                   	push   %eax
   100dc:	51                   	push   %ecx
   100dd:	52                   	push   %edx
   100de:	e8 4a 8f ff ff       	call   902d <lodepng_get_raw_size_idat>
   100e3:	83 c4 10             	add    $0x10,%esp
   100e6:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   100e9:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100ec:	8b 55 10             	mov    0x10(%ebp),%edx
   100ef:	8b 12                	mov    (%edx),%edx
   100f1:	83 c2 03             	add    $0x3,%edx
   100f4:	89 d1                	mov    %edx,%ecx
   100f6:	c1 e9 03             	shr    $0x3,%ecx
   100f9:	8b 55 0c             	mov    0xc(%ebp),%edx
   100fc:	8b 12                	mov    (%edx),%edx
   100fe:	83 c2 03             	add    $0x3,%edx
   10101:	c1 ea 02             	shr    $0x2,%edx
   10104:	83 ec 04             	sub    $0x4,%esp
   10107:	50                   	push   %eax
   10108:	51                   	push   %ecx
   10109:	52                   	push   %edx
   1010a:	e8 1e 8f ff ff       	call   902d <lodepng_get_raw_size_idat>
   1010f:	83 c4 10             	add    $0x10,%esp
   10112:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10115:	8b 45 0c             	mov    0xc(%ebp),%eax
   10118:	8b 00                	mov    (%eax),%eax
   1011a:	83 f8 02             	cmp    $0x2,%eax
   1011d:	76 2c                	jbe    1014b <decodeGeneric+0x914>
   1011f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10122:	8b 55 10             	mov    0x10(%ebp),%edx
   10125:	8b 12                	mov    (%edx),%edx
   10127:	83 c2 03             	add    $0x3,%edx
   1012a:	89 d1                	mov    %edx,%ecx
   1012c:	c1 e9 02             	shr    $0x2,%ecx
   1012f:	8b 55 0c             	mov    0xc(%ebp),%edx
   10132:	8b 12                	mov    (%edx),%edx
   10134:	83 c2 01             	add    $0x1,%edx
   10137:	c1 ea 02             	shr    $0x2,%edx
   1013a:	83 ec 04             	sub    $0x4,%esp
   1013d:	50                   	push   %eax
   1013e:	51                   	push   %ecx
   1013f:	52                   	push   %edx
   10140:	e8 e8 8e ff ff       	call   902d <lodepng_get_raw_size_idat>
   10145:	83 c4 10             	add    $0x10,%esp
   10148:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   1014b:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1014e:	8b 55 10             	mov    0x10(%ebp),%edx
   10151:	8b 12                	mov    (%edx),%edx
   10153:	83 c2 01             	add    $0x1,%edx
   10156:	89 d1                	mov    %edx,%ecx
   10158:	c1 e9 02             	shr    $0x2,%ecx
   1015b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1015e:	8b 12                	mov    (%edx),%edx
   10160:	83 c2 01             	add    $0x1,%edx
   10163:	d1 ea                	shr    %edx
   10165:	83 ec 04             	sub    $0x4,%esp
   10168:	50                   	push   %eax
   10169:	51                   	push   %ecx
   1016a:	52                   	push   %edx
   1016b:	e8 bd 8e ff ff       	call   902d <lodepng_get_raw_size_idat>
   10170:	83 c4 10             	add    $0x10,%esp
   10173:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   10176:	8b 45 0c             	mov    0xc(%ebp),%eax
   10179:	8b 00                	mov    (%eax),%eax
   1017b:	83 f8 01             	cmp    $0x1,%eax
   1017e:	76 27                	jbe    101a7 <decodeGeneric+0x970>
   10180:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10183:	8b 55 10             	mov    0x10(%ebp),%edx
   10186:	8b 12                	mov    (%edx),%edx
   10188:	83 c2 01             	add    $0x1,%edx
   1018b:	89 d1                	mov    %edx,%ecx
   1018d:	d1 e9                	shr    %ecx
   1018f:	8b 55 0c             	mov    0xc(%ebp),%edx
   10192:	8b 12                	mov    (%edx),%edx
   10194:	d1 ea                	shr    %edx
   10196:	83 ec 04             	sub    $0x4,%esp
   10199:	50                   	push   %eax
   1019a:	51                   	push   %ecx
   1019b:	52                   	push   %edx
   1019c:	e8 8c 8e ff ff       	call   902d <lodepng_get_raw_size_idat>
   101a1:	83 c4 10             	add    $0x10,%esp
   101a4:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   101a7:	8b 55 c8             	mov    -0x38(%ebp),%edx
   101aa:	8b 45 10             	mov    0x10(%ebp),%eax
   101ad:	8b 00                	mov    (%eax),%eax
   101af:	d1 e8                	shr    %eax
   101b1:	89 c1                	mov    %eax,%ecx
   101b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   101b6:	8b 00                	mov    (%eax),%eax
   101b8:	83 ec 04             	sub    $0x4,%esp
   101bb:	52                   	push   %edx
   101bc:	51                   	push   %ecx
   101bd:	50                   	push   %eax
   101be:	e8 6a 8e ff ff       	call   902d <lodepng_get_raw_size_idat>
   101c3:	83 c4 10             	add    $0x10,%esp
   101c6:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   101c9:	8b 45 14             	mov    0x14(%ebp),%eax
   101cc:	83 ec 08             	sub    $0x8,%esp
   101cf:	50                   	push   %eax
   101d0:	ff 75 ec             	pushl  -0x14(%ebp)
   101d3:	ff 75 d8             	pushl  -0x28(%ebp)
   101d6:	ff 75 e8             	pushl  -0x18(%ebp)
   101d9:	8d 45 c0             	lea    -0x40(%ebp),%eax
   101dc:	50                   	push   %eax
   101dd:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   101e0:	50                   	push   %eax
   101e1:	e8 87 7c ff ff       	call   7e6d <zlib_decompress>
   101e6:	83 c4 20             	add    $0x20,%esp
   101e9:	89 c2                	mov    %eax,%edx
   101eb:	8b 45 14             	mov    0x14(%ebp),%eax
   101ee:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   101f4:	8b 45 14             	mov    0x14(%ebp),%eax
   101f7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101fd:	85 c0                	test   %eax,%eax
   101ff:	75 15                	jne    10216 <decodeGeneric+0x9df>
   10201:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10204:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10207:	74 0d                	je     10216 <decodeGeneric+0x9df>
   10209:	8b 45 14             	mov    0x14(%ebp),%eax
   1020c:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10213:	00 00 00 
  lodepng_free(idat);
   10216:	83 ec 0c             	sub    $0xc,%esp
   10219:	ff 75 d8             	pushl  -0x28(%ebp)
   1021c:	e8 b2 31 ff ff       	call   33d3 <lodepng_free>
   10221:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10224:	8b 45 14             	mov    0x14(%ebp),%eax
   10227:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1022d:	85 c0                	test   %eax,%eax
   1022f:	75 4f                	jne    10280 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10231:	8b 45 14             	mov    0x14(%ebp),%eax
   10234:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   1023a:	8b 45 10             	mov    0x10(%ebp),%eax
   1023d:	8b 10                	mov    (%eax),%edx
   1023f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10242:	8b 00                	mov    (%eax),%eax
   10244:	83 ec 04             	sub    $0x4,%esp
   10247:	51                   	push   %ecx
   10248:	52                   	push   %edx
   10249:	50                   	push   %eax
   1024a:	e8 be 8d ff ff       	call   900d <lodepng_get_raw_size>
   1024f:	83 c4 10             	add    $0x10,%esp
   10252:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10255:	83 ec 0c             	sub    $0xc,%esp
   10258:	ff 75 e4             	pushl  -0x1c(%ebp)
   1025b:	e8 52 31 ff ff       	call   33b2 <lodepng_malloc>
   10260:	83 c4 10             	add    $0x10,%esp
   10263:	89 c2                	mov    %eax,%edx
   10265:	8b 45 08             	mov    0x8(%ebp),%eax
   10268:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   1026a:	8b 45 08             	mov    0x8(%ebp),%eax
   1026d:	8b 00                	mov    (%eax),%eax
   1026f:	85 c0                	test   %eax,%eax
   10271:	75 0d                	jne    10280 <decodeGeneric+0xa49>
   10273:	8b 45 14             	mov    0x14(%ebp),%eax
   10276:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1027d:	00 00 00 
  }
  if(!state->error) {
   10280:	8b 45 14             	mov    0x14(%ebp),%eax
   10283:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10289:	85 c0                	test   %eax,%eax
   1028b:	75 4c                	jne    102d9 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   1028d:	8b 45 08             	mov    0x8(%ebp),%eax
   10290:	8b 00                	mov    (%eax),%eax
   10292:	83 ec 04             	sub    $0x4,%esp
   10295:	ff 75 e4             	pushl  -0x1c(%ebp)
   10298:	6a 00                	push   $0x0
   1029a:	50                   	push   %eax
   1029b:	e8 83 31 ff ff       	call   3423 <lodepng_memset>
   102a0:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   102a3:	8b 45 14             	mov    0x14(%ebp),%eax
   102a6:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   102ac:	8b 45 10             	mov    0x10(%ebp),%eax
   102af:	8b 18                	mov    (%eax),%ebx
   102b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   102b4:	8b 08                	mov    (%eax),%ecx
   102b6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   102b9:	8b 45 08             	mov    0x8(%ebp),%eax
   102bc:	8b 00                	mov    (%eax),%eax
   102be:	83 ec 0c             	sub    $0xc,%esp
   102c1:	56                   	push   %esi
   102c2:	53                   	push   %ebx
   102c3:	51                   	push   %ecx
   102c4:	52                   	push   %edx
   102c5:	50                   	push   %eax
   102c6:	e8 05 df ff ff       	call   e1d0 <postProcessScanlines>
   102cb:	83 c4 20             	add    $0x20,%esp
   102ce:	89 c2                	mov    %eax,%edx
   102d0:	8b 45 14             	mov    0x14(%ebp),%eax
   102d3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   102d9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   102dc:	83 ec 0c             	sub    $0xc,%esp
   102df:	50                   	push   %eax
   102e0:	e8 ee 30 ff ff       	call   33d3 <lodepng_free>
   102e5:	83 c4 10             	add    $0x10,%esp
   102e8:	eb 01                	jmp    102eb <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   102ea:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   102eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
   102ee:	5b                   	pop    %ebx
   102ef:	5e                   	pop    %esi
   102f0:	5d                   	pop    %ebp
   102f1:	c3                   	ret    

000102f2 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   102f2:	55                   	push   %ebp
   102f3:	89 e5                	mov    %esp,%ebp
   102f5:	56                   	push   %esi
   102f6:	53                   	push   %ebx
   102f7:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   102fa:	8b 45 08             	mov    0x8(%ebp),%eax
   102fd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10303:	83 ec 08             	sub    $0x8,%esp
   10306:	ff 75 1c             	pushl  0x1c(%ebp)
   10309:	ff 75 18             	pushl  0x18(%ebp)
   1030c:	ff 75 14             	pushl  0x14(%ebp)
   1030f:	ff 75 10             	pushl  0x10(%ebp)
   10312:	ff 75 0c             	pushl  0xc(%ebp)
   10315:	ff 75 08             	pushl  0x8(%ebp)
   10318:	e8 1a f5 ff ff       	call   f837 <decodeGeneric>
   1031d:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10320:	8b 45 14             	mov    0x14(%ebp),%eax
   10323:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10329:	85 c0                	test   %eax,%eax
   1032b:	74 0e                	je     1033b <lodepng_decode+0x49>
   1032d:	8b 45 14             	mov    0x14(%ebp),%eax
   10330:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10336:	e9 55 01 00 00       	jmp    10490 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   1033b:	8b 45 14             	mov    0x14(%ebp),%eax
   1033e:	8b 40 24             	mov    0x24(%eax),%eax
   10341:	85 c0                	test   %eax,%eax
   10343:	74 20                	je     10365 <lodepng_decode+0x73>
   10345:	8b 45 14             	mov    0x14(%ebp),%eax
   10348:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1034e:	8b 45 14             	mov    0x14(%ebp),%eax
   10351:	83 c0 78             	add    $0x78,%eax
   10354:	83 ec 08             	sub    $0x8,%esp
   10357:	52                   	push   %edx
   10358:	50                   	push   %eax
   10359:	e8 56 89 ff ff       	call   8cb4 <lodepng_color_mode_equal>
   1035e:	83 c4 10             	add    $0x10,%esp
   10361:	85 c0                	test   %eax,%eax
   10363:	74 54                	je     103b9 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10365:	8b 45 14             	mov    0x14(%ebp),%eax
   10368:	8b 40 24             	mov    0x24(%eax),%eax
   1036b:	85 c0                	test   %eax,%eax
   1036d:	0f 85 13 01 00 00    	jne    10486 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   10373:	8b 45 14             	mov    0x14(%ebp),%eax
   10376:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1037c:	8b 45 14             	mov    0x14(%ebp),%eax
   1037f:	83 c0 78             	add    $0x78,%eax
   10382:	83 ec 08             	sub    $0x8,%esp
   10385:	52                   	push   %edx
   10386:	50                   	push   %eax
   10387:	e8 3f 88 ff ff       	call   8bcb <lodepng_color_mode_copy>
   1038c:	83 c4 10             	add    $0x10,%esp
   1038f:	89 c2                	mov    %eax,%edx
   10391:	8b 45 14             	mov    0x14(%ebp),%eax
   10394:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   1039a:	8b 45 14             	mov    0x14(%ebp),%eax
   1039d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103a3:	85 c0                	test   %eax,%eax
   103a5:	0f 84 db 00 00 00    	je     10486 <lodepng_decode+0x194>
   103ab:	8b 45 14             	mov    0x14(%ebp),%eax
   103ae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103b4:	e9 d7 00 00 00       	jmp    10490 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   103b9:	8b 45 08             	mov    0x8(%ebp),%eax
   103bc:	8b 00                	mov    (%eax),%eax
   103be:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   103c1:	8b 45 14             	mov    0x14(%ebp),%eax
   103c4:	8b 40 78             	mov    0x78(%eax),%eax
   103c7:	83 f8 02             	cmp    $0x2,%eax
   103ca:	74 20                	je     103ec <lodepng_decode+0xfa>
   103cc:	8b 45 14             	mov    0x14(%ebp),%eax
   103cf:	8b 40 78             	mov    0x78(%eax),%eax
   103d2:	83 f8 06             	cmp    $0x6,%eax
   103d5:	74 15                	je     103ec <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   103d7:	8b 45 14             	mov    0x14(%ebp),%eax
   103da:	8b 40 7c             	mov    0x7c(%eax),%eax
   103dd:	83 f8 08             	cmp    $0x8,%eax
   103e0:	74 0a                	je     103ec <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   103e2:	b8 38 00 00 00       	mov    $0x38,%eax
   103e7:	e9 a4 00 00 00       	jmp    10490 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   103ec:	8b 45 14             	mov    0x14(%ebp),%eax
   103ef:	8d 48 78             	lea    0x78(%eax),%ecx
   103f2:	8b 45 10             	mov    0x10(%ebp),%eax
   103f5:	8b 10                	mov    (%eax),%edx
   103f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   103fa:	8b 00                	mov    (%eax),%eax
   103fc:	83 ec 04             	sub    $0x4,%esp
   103ff:	51                   	push   %ecx
   10400:	52                   	push   %edx
   10401:	50                   	push   %eax
   10402:	e8 06 8c ff ff       	call   900d <lodepng_get_raw_size>
   10407:	83 c4 10             	add    $0x10,%esp
   1040a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1040d:	83 ec 0c             	sub    $0xc,%esp
   10410:	ff 75 f0             	pushl  -0x10(%ebp)
   10413:	e8 9a 2f ff ff       	call   33b2 <lodepng_malloc>
   10418:	83 c4 10             	add    $0x10,%esp
   1041b:	89 c2                	mov    %eax,%edx
   1041d:	8b 45 08             	mov    0x8(%ebp),%eax
   10420:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10422:	8b 45 08             	mov    0x8(%ebp),%eax
   10425:	8b 00                	mov    (%eax),%eax
   10427:	85 c0                	test   %eax,%eax
   10429:	75 0f                	jne    1043a <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   1042b:	8b 45 14             	mov    0x14(%ebp),%eax
   1042e:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10435:	00 00 00 
   10438:	eb 3c                	jmp    10476 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1043a:	8b 45 10             	mov    0x10(%ebp),%eax
   1043d:	8b 08                	mov    (%eax),%ecx
   1043f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10442:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10444:	8b 45 14             	mov    0x14(%ebp),%eax
   10447:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1044d:	8b 45 14             	mov    0x14(%ebp),%eax
   10450:	8d 58 78             	lea    0x78(%eax),%ebx
   10453:	8b 45 08             	mov    0x8(%ebp),%eax
   10456:	8b 00                	mov    (%eax),%eax
   10458:	83 ec 08             	sub    $0x8,%esp
   1045b:	51                   	push   %ecx
   1045c:	52                   	push   %edx
   1045d:	56                   	push   %esi
   1045e:	53                   	push   %ebx
   1045f:	ff 75 f4             	pushl  -0xc(%ebp)
   10462:	50                   	push   %eax
   10463:	e8 51 b6 ff ff       	call   bab9 <lodepng_convert>
   10468:	83 c4 20             	add    $0x20,%esp
   1046b:	89 c2                	mov    %eax,%edx
   1046d:	8b 45 14             	mov    0x14(%ebp),%eax
   10470:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   10476:	83 ec 0c             	sub    $0xc,%esp
   10479:	ff 75 f4             	pushl  -0xc(%ebp)
   1047c:	e8 52 2f ff ff       	call   33d3 <lodepng_free>
   10481:	83 c4 10             	add    $0x10,%esp
   10484:	eb 01                	jmp    10487 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10486:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   10487:	8b 45 14             	mov    0x14(%ebp),%eax
   1048a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   10490:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10493:	5b                   	pop    %ebx
   10494:	5e                   	pop    %esi
   10495:	5d                   	pop    %ebp
   10496:	c3                   	ret    

00010497 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   10497:	55                   	push   %ebp
   10498:	89 e5                	mov    %esp,%ebp
   1049a:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   104a0:	83 ec 0c             	sub    $0xc,%esp
   104a3:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   104a9:	50                   	push   %eax
   104aa:	e8 d9 01 00 00       	call   10688 <lodepng_state_init>
   104af:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   104b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   104b5:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   104bb:	8b 45 20             	mov    0x20(%ebp),%eax
   104be:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   104c4:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   104cb:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   104ce:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   104d5:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   104d8:	83 ec 08             	sub    $0x8,%esp
   104db:	ff 75 18             	pushl  0x18(%ebp)
   104de:	ff 75 14             	pushl  0x14(%ebp)
   104e1:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   104e7:	50                   	push   %eax
   104e8:	ff 75 10             	pushl  0x10(%ebp)
   104eb:	ff 75 0c             	pushl  0xc(%ebp)
   104ee:	ff 75 08             	pushl  0x8(%ebp)
   104f1:	e8 fc fd ff ff       	call   102f2 <lodepng_decode>
   104f6:	83 c4 20             	add    $0x20,%esp
   104f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   104fc:	83 ec 0c             	sub    $0xc,%esp
   104ff:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10505:	50                   	push   %eax
   10506:	e8 d7 01 00 00       	call   106e2 <lodepng_state_cleanup>
   1050b:	83 c4 10             	add    $0x10,%esp
  return error;
   1050e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10511:	c9                   	leave  
   10512:	c3                   	ret    

00010513 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10513:	55                   	push   %ebp
   10514:	89 e5                	mov    %esp,%ebp
   10516:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   10519:	83 ec 04             	sub    $0x4,%esp
   1051c:	6a 08                	push   $0x8
   1051e:	6a 06                	push   $0x6
   10520:	ff 75 18             	pushl  0x18(%ebp)
   10523:	ff 75 14             	pushl  0x14(%ebp)
   10526:	ff 75 10             	pushl  0x10(%ebp)
   10529:	ff 75 0c             	pushl  0xc(%ebp)
   1052c:	ff 75 08             	pushl  0x8(%ebp)
   1052f:	e8 63 ff ff ff       	call   10497 <lodepng_decode_memory>
   10534:	83 c4 20             	add    $0x20,%esp
}
   10537:	c9                   	leave  
   10538:	c3                   	ret    

00010539 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10539:	55                   	push   %ebp
   1053a:	89 e5                	mov    %esp,%ebp
   1053c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   1053f:	83 ec 04             	sub    $0x4,%esp
   10542:	6a 08                	push   $0x8
   10544:	6a 02                	push   $0x2
   10546:	ff 75 18             	pushl  0x18(%ebp)
   10549:	ff 75 14             	pushl  0x14(%ebp)
   1054c:	ff 75 10             	pushl  0x10(%ebp)
   1054f:	ff 75 0c             	pushl  0xc(%ebp)
   10552:	ff 75 08             	pushl  0x8(%ebp)
   10555:	e8 3d ff ff ff       	call   10497 <lodepng_decode_memory>
   1055a:	83 c4 20             	add    $0x20,%esp
}
   1055d:	c9                   	leave  
   1055e:	c3                   	ret    

0001055f <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   1055f:	55                   	push   %ebp
   10560:	89 e5                	mov    %esp,%ebp
   10562:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   10565:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   1056c:	8b 45 08             	mov    0x8(%ebp),%eax
   1056f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10575:	8b 45 10             	mov    0x10(%ebp),%eax
   10578:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1057e:	8b 45 10             	mov    0x10(%ebp),%eax
   10581:	8b 10                	mov    (%eax),%edx
   10583:	8b 45 0c             	mov    0xc(%ebp),%eax
   10586:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   10588:	83 ec 04             	sub    $0x4,%esp
   1058b:	ff 75 14             	pushl  0x14(%ebp)
   1058e:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10591:	50                   	push   %eax
   10592:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10595:	50                   	push   %eax
   10596:	e8 70 32 ff ff       	call   380b <lodepng_load_file>
   1059b:	83 c4 10             	add    $0x10,%esp
   1059e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   105a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   105a5:	75 25                	jne    105cc <lodepng_decode_file+0x6d>
   105a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   105aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105ad:	83 ec 04             	sub    $0x4,%esp
   105b0:	ff 75 1c             	pushl  0x1c(%ebp)
   105b3:	ff 75 18             	pushl  0x18(%ebp)
   105b6:	52                   	push   %edx
   105b7:	50                   	push   %eax
   105b8:	ff 75 10             	pushl  0x10(%ebp)
   105bb:	ff 75 0c             	pushl  0xc(%ebp)
   105be:	ff 75 08             	pushl  0x8(%ebp)
   105c1:	e8 d1 fe ff ff       	call   10497 <lodepng_decode_memory>
   105c6:	83 c4 20             	add    $0x20,%esp
   105c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   105cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105cf:	83 ec 0c             	sub    $0xc,%esp
   105d2:	50                   	push   %eax
   105d3:	e8 fb 2d ff ff       	call   33d3 <lodepng_free>
   105d8:	83 c4 10             	add    $0x10,%esp
  return error;
   105db:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   105de:	c9                   	leave  
   105df:	c3                   	ret    

000105e0 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   105e0:	55                   	push   %ebp
   105e1:	89 e5                	mov    %esp,%ebp
   105e3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   105e6:	83 ec 08             	sub    $0x8,%esp
   105e9:	6a 08                	push   $0x8
   105eb:	6a 06                	push   $0x6
   105ed:	ff 75 14             	pushl  0x14(%ebp)
   105f0:	ff 75 10             	pushl  0x10(%ebp)
   105f3:	ff 75 0c             	pushl  0xc(%ebp)
   105f6:	ff 75 08             	pushl  0x8(%ebp)
   105f9:	e8 61 ff ff ff       	call   1055f <lodepng_decode_file>
   105fe:	83 c4 20             	add    $0x20,%esp
}
   10601:	c9                   	leave  
   10602:	c3                   	ret    

00010603 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10603:	55                   	push   %ebp
   10604:	89 e5                	mov    %esp,%ebp
   10606:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   10609:	83 ec 08             	sub    $0x8,%esp
   1060c:	6a 08                	push   $0x8
   1060e:	6a 02                	push   $0x2
   10610:	ff 75 14             	pushl  0x14(%ebp)
   10613:	ff 75 10             	pushl  0x10(%ebp)
   10616:	ff 75 0c             	pushl  0xc(%ebp)
   10619:	ff 75 08             	pushl  0x8(%ebp)
   1061c:	e8 3e ff ff ff       	call   1055f <lodepng_decode_file>
   10621:	83 c4 20             	add    $0x20,%esp
}
   10624:	c9                   	leave  
   10625:	c3                   	ret    

00010626 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10626:	55                   	push   %ebp
   10627:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   10629:	8b 45 08             	mov    0x8(%ebp),%eax
   1062c:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10633:	8b 45 08             	mov    0x8(%ebp),%eax
   10636:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   1063d:	8b 45 08             	mov    0x8(%ebp),%eax
   10640:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   10647:	8b 45 08             	mov    0x8(%ebp),%eax
   1064a:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   10651:	8b 45 08             	mov    0x8(%ebp),%eax
   10654:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   1065b:	8b 45 08             	mov    0x8(%ebp),%eax
   1065e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   10665:	8b 45 08             	mov    0x8(%ebp),%eax
   10668:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   1066f:	8b 45 08             	mov    0x8(%ebp),%eax
   10672:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   10679:	8b 45 08             	mov    0x8(%ebp),%eax
   1067c:	50                   	push   %eax
   1067d:	e8 ff 7a ff ff       	call   8181 <lodepng_decompress_settings_init>
   10682:	83 c4 04             	add    $0x4,%esp
}
   10685:	90                   	nop
   10686:	c9                   	leave  
   10687:	c3                   	ret    

00010688 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   10688:	55                   	push   %ebp
   10689:	89 e5                	mov    %esp,%ebp
   1068b:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   1068e:	8b 45 08             	mov    0x8(%ebp),%eax
   10691:	50                   	push   %eax
   10692:	e8 8f ff ff ff       	call   10626 <lodepng_decoder_settings_init>
   10697:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   1069a:	8b 45 08             	mov    0x8(%ebp),%eax
   1069d:	83 c0 38             	add    $0x38,%eax
   106a0:	83 ec 0c             	sub    $0xc,%esp
   106a3:	50                   	push   %eax
   106a4:	e8 fc 30 00 00       	call   137a5 <lodepng_encoder_settings_init>
   106a9:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   106ac:	8b 45 08             	mov    0x8(%ebp),%eax
   106af:	83 c0 78             	add    $0x78,%eax
   106b2:	83 ec 0c             	sub    $0xc,%esp
   106b5:	50                   	push   %eax
   106b6:	e8 06 84 ff ff       	call   8ac1 <lodepng_color_mode_init>
   106bb:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   106be:	8b 45 08             	mov    0x8(%ebp),%eax
   106c1:	05 98 00 00 00       	add    $0x98,%eax
   106c6:	83 ec 0c             	sub    $0xc,%esp
   106c9:	50                   	push   %eax
   106ca:	e8 89 93 ff ff       	call   9a58 <lodepng_info_init>
   106cf:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   106d2:	8b 45 08             	mov    0x8(%ebp),%eax
   106d5:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   106dc:	00 00 00 
}
   106df:	90                   	nop
   106e0:	c9                   	leave  
   106e1:	c3                   	ret    

000106e2 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   106e2:	55                   	push   %ebp
   106e3:	89 e5                	mov    %esp,%ebp
   106e5:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   106e8:	8b 45 08             	mov    0x8(%ebp),%eax
   106eb:	83 c0 78             	add    $0x78,%eax
   106ee:	83 ec 0c             	sub    $0xc,%esp
   106f1:	50                   	push   %eax
   106f2:	e8 bd 84 ff ff       	call   8bb4 <lodepng_color_mode_cleanup>
   106f7:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   106fa:	8b 45 08             	mov    0x8(%ebp),%eax
   106fd:	05 98 00 00 00       	add    $0x98,%eax
   10702:	83 ec 0c             	sub    $0xc,%esp
   10705:	50                   	push   %eax
   10706:	e8 2e 94 ff ff       	call   9b39 <lodepng_info_cleanup>
   1070b:	83 c4 10             	add    $0x10,%esp
}
   1070e:	90                   	nop
   1070f:	c9                   	leave  
   10710:	c3                   	ret    

00010711 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10711:	55                   	push   %ebp
   10712:	89 e5                	mov    %esp,%ebp
   10714:	57                   	push   %edi
   10715:	56                   	push   %esi
   10716:	53                   	push   %ebx
   10717:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   1071a:	83 ec 0c             	sub    $0xc,%esp
   1071d:	ff 75 08             	pushl  0x8(%ebp)
   10720:	e8 bd ff ff ff       	call   106e2 <lodepng_state_cleanup>
   10725:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10728:	8b 55 08             	mov    0x8(%ebp),%edx
   1072b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1072e:	89 c3                	mov    %eax,%ebx
   10730:	b8 60 00 00 00       	mov    $0x60,%eax
   10735:	89 d7                	mov    %edx,%edi
   10737:	89 de                	mov    %ebx,%esi
   10739:	89 c1                	mov    %eax,%ecx
   1073b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   1073d:	8b 45 08             	mov    0x8(%ebp),%eax
   10740:	83 c0 78             	add    $0x78,%eax
   10743:	83 ec 0c             	sub    $0xc,%esp
   10746:	50                   	push   %eax
   10747:	e8 75 83 ff ff       	call   8ac1 <lodepng_color_mode_init>
   1074c:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   1074f:	8b 45 08             	mov    0x8(%ebp),%eax
   10752:	05 98 00 00 00       	add    $0x98,%eax
   10757:	83 ec 0c             	sub    $0xc,%esp
   1075a:	50                   	push   %eax
   1075b:	e8 f8 92 ff ff       	call   9a58 <lodepng_info_init>
   10760:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10763:	8b 45 0c             	mov    0xc(%ebp),%eax
   10766:	8d 50 78             	lea    0x78(%eax),%edx
   10769:	8b 45 08             	mov    0x8(%ebp),%eax
   1076c:	83 c0 78             	add    $0x78,%eax
   1076f:	83 ec 08             	sub    $0x8,%esp
   10772:	52                   	push   %edx
   10773:	50                   	push   %eax
   10774:	e8 52 84 ff ff       	call   8bcb <lodepng_color_mode_copy>
   10779:	83 c4 10             	add    $0x10,%esp
   1077c:	89 c2                	mov    %eax,%edx
   1077e:	8b 45 08             	mov    0x8(%ebp),%eax
   10781:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10787:	8b 45 08             	mov    0x8(%ebp),%eax
   1078a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10790:	85 c0                	test   %eax,%eax
   10792:	75 36                	jne    107ca <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10794:	8b 45 0c             	mov    0xc(%ebp),%eax
   10797:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   1079d:	8b 45 08             	mov    0x8(%ebp),%eax
   107a0:	05 98 00 00 00       	add    $0x98,%eax
   107a5:	83 ec 08             	sub    $0x8,%esp
   107a8:	52                   	push   %edx
   107a9:	50                   	push   %eax
   107aa:	e8 dd 93 ff ff       	call   9b8c <lodepng_info_copy>
   107af:	83 c4 10             	add    $0x10,%esp
   107b2:	89 c2                	mov    %eax,%edx
   107b4:	8b 45 08             	mov    0x8(%ebp),%eax
   107b7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   107bd:	8b 45 08             	mov    0x8(%ebp),%eax
   107c0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   107c6:	85 c0                	test   %eax,%eax
   107c8:	eb 01                	jmp    107cb <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   107ca:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   107cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
   107ce:	5b                   	pop    %ebx
   107cf:	5e                   	pop    %esi
   107d0:	5f                   	pop    %edi
   107d1:	5d                   	pop    %ebp
   107d2:	c3                   	ret    

000107d3 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   107d3:	55                   	push   %ebp
   107d4:	89 e5                	mov    %esp,%ebp
   107d6:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   107d9:	8b 45 08             	mov    0x8(%ebp),%eax
   107dc:	8b 40 04             	mov    0x4(%eax),%eax
   107df:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   107e2:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   107e6:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   107ea:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   107ee:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   107f2:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   107f6:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   107fa:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   107fe:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10802:	8b 45 08             	mov    0x8(%ebp),%eax
   10805:	8b 40 04             	mov    0x4(%eax),%eax
   10808:	83 c0 08             	add    $0x8,%eax
   1080b:	50                   	push   %eax
   1080c:	ff 75 08             	pushl  0x8(%ebp)
   1080f:	e8 f8 2d ff ff       	call   360c <ucvector_resize>
   10814:	83 c4 08             	add    $0x8,%esp
   10817:	85 c0                	test   %eax,%eax
   10819:	75 07                	jne    10822 <writeSignature+0x4f>
   1081b:	b8 53 00 00 00       	mov    $0x53,%eax
   10820:	eb 1e                	jmp    10840 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10822:	8b 45 08             	mov    0x8(%ebp),%eax
   10825:	8b 10                	mov    (%eax),%edx
   10827:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1082a:	01 c2                	add    %eax,%edx
   1082c:	6a 08                	push   $0x8
   1082e:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10831:	50                   	push   %eax
   10832:	52                   	push   %edx
   10833:	e8 b8 2b ff ff       	call   33f0 <lodepng_memcpy>
   10838:	83 c4 0c             	add    $0xc,%esp
  return 0;
   1083b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10840:	c9                   	leave  
   10841:	c3                   	ret    

00010842 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10842:	55                   	push   %ebp
   10843:	89 e5                	mov    %esp,%ebp
   10845:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10848:	68 2c a1 01 00       	push   $0x1a12c
   1084d:	6a 0d                	push   $0xd
   1084f:	ff 75 08             	pushl  0x8(%ebp)
   10852:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10855:	50                   	push   %eax
   10856:	e8 cf 7f ff ff       	call   882a <lodepng_chunk_init>
   1085b:	83 c4 10             	add    $0x10,%esp
   1085e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10861:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10865:	74 05                	je     1086c <addChunk_IHDR+0x2a>
   10867:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1086a:	eb 6d                	jmp    108d9 <addChunk_IHDR+0x97>
  data = chunk + 8;
   1086c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1086f:	83 c0 08             	add    $0x8,%eax
   10872:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10875:	ff 75 0c             	pushl  0xc(%ebp)
   10878:	ff 75 f8             	pushl  -0x8(%ebp)
   1087b:	e8 f3 2e ff ff       	call   3773 <lodepng_set32bitInt>
   10880:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10883:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10886:	83 c0 04             	add    $0x4,%eax
   10889:	ff 75 10             	pushl  0x10(%ebp)
   1088c:	50                   	push   %eax
   1088d:	e8 e1 2e ff ff       	call   3773 <lodepng_set32bitInt>
   10892:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10895:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10898:	83 c0 08             	add    $0x8,%eax
   1089b:	8b 55 18             	mov    0x18(%ebp),%edx
   1089e:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   108a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108a3:	83 c0 09             	add    $0x9,%eax
   108a6:	8b 55 14             	mov    0x14(%ebp),%edx
   108a9:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   108ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108ae:	83 c0 0a             	add    $0xa,%eax
   108b1:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   108b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108b7:	83 c0 0b             	add    $0xb,%eax
   108ba:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   108bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108c0:	83 c0 0c             	add    $0xc,%eax
   108c3:	8b 55 1c             	mov    0x1c(%ebp),%edx
   108c6:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   108c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   108cb:	50                   	push   %eax
   108cc:	e8 02 7c ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   108d1:	83 c4 04             	add    $0x4,%esp
  return 0;
   108d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   108d9:	c9                   	leave  
   108da:	c3                   	ret    

000108db <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   108db:	55                   	push   %ebp
   108dc:	89 e5                	mov    %esp,%ebp
   108de:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   108e1:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   108e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   108eb:	8b 50 0c             	mov    0xc(%eax),%edx
   108ee:	89 d0                	mov    %edx,%eax
   108f0:	01 c0                	add    %eax,%eax
   108f2:	01 d0                	add    %edx,%eax
   108f4:	68 48 a1 01 00       	push   $0x1a148
   108f9:	50                   	push   %eax
   108fa:	ff 75 08             	pushl  0x8(%ebp)
   108fd:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10900:	50                   	push   %eax
   10901:	e8 24 7f ff ff       	call   882a <lodepng_chunk_init>
   10906:	83 c4 10             	add    $0x10,%esp
   10909:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1090c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10910:	74 08                	je     1091a <addChunk_PLTE+0x3f>
   10912:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10915:	e9 95 00 00 00       	jmp    109af <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   1091a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10921:	eb 70                	jmp    10993 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10923:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10926:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10929:	8d 50 01             	lea    0x1(%eax),%edx
   1092c:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1092f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10932:	8b 45 0c             	mov    0xc(%ebp),%eax
   10935:	8b 40 08             	mov    0x8(%eax),%eax
   10938:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1093b:	c1 e1 02             	shl    $0x2,%ecx
   1093e:	01 c8                	add    %ecx,%eax
   10940:	0f b6 00             	movzbl (%eax),%eax
   10943:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10945:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10948:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1094b:	8d 50 01             	lea    0x1(%eax),%edx
   1094e:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10951:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10954:	8b 45 0c             	mov    0xc(%ebp),%eax
   10957:	8b 40 08             	mov    0x8(%eax),%eax
   1095a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1095d:	c1 e1 02             	shl    $0x2,%ecx
   10960:	83 c1 01             	add    $0x1,%ecx
   10963:	01 c8                	add    %ecx,%eax
   10965:	0f b6 00             	movzbl (%eax),%eax
   10968:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   1096a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   1096d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10970:	8d 50 01             	lea    0x1(%eax),%edx
   10973:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10976:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10979:	8b 45 0c             	mov    0xc(%ebp),%eax
   1097c:	8b 40 08             	mov    0x8(%eax),%eax
   1097f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10982:	c1 e1 02             	shl    $0x2,%ecx
   10985:	83 c1 02             	add    $0x2,%ecx
   10988:	01 c8                	add    %ecx,%eax
   1098a:	0f b6 00             	movzbl (%eax),%eax
   1098d:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   1098f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10993:	8b 45 0c             	mov    0xc(%ebp),%eax
   10996:	8b 40 0c             	mov    0xc(%eax),%eax
   10999:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   1099c:	75 85                	jne    10923 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   1099e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109a1:	50                   	push   %eax
   109a2:	e8 2c 7b ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   109a7:	83 c4 04             	add    $0x4,%esp
  return 0;
   109aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   109af:	c9                   	leave  
   109b0:	c3                   	ret    

000109b1 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   109b1:	55                   	push   %ebp
   109b2:	89 e5                	mov    %esp,%ebp
   109b4:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   109b7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   109be:	8b 45 0c             	mov    0xc(%ebp),%eax
   109c1:	8b 00                	mov    (%eax),%eax
   109c3:	83 f8 03             	cmp    $0x3,%eax
   109c6:	0f 85 ae 00 00 00    	jne    10a7a <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   109cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   109cf:	8b 40 0c             	mov    0xc(%eax),%eax
   109d2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   109d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   109d8:	8b 40 0c             	mov    0xc(%eax),%eax
   109db:	89 45 fc             	mov    %eax,-0x4(%ebp)
   109de:	eb 23                	jmp    10a03 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   109e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   109e3:	8b 40 08             	mov    0x8(%eax),%eax
   109e6:	8b 55 fc             	mov    -0x4(%ebp),%edx
   109e9:	83 ea 01             	sub    $0x1,%edx
   109ec:	c1 e2 02             	shl    $0x2,%edx
   109ef:	83 c2 03             	add    $0x3,%edx
   109f2:	01 d0                	add    %edx,%eax
   109f4:	0f b6 00             	movzbl (%eax),%eax
   109f7:	3c ff                	cmp    $0xff,%al
   109f9:	75 10                	jne    10a0b <addChunk_tRNS+0x5a>
      --amount;
   109fb:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   109ff:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10a03:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10a07:	75 d7                	jne    109e0 <addChunk_tRNS+0x2f>
   10a09:	eb 01                	jmp    10a0c <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10a0b:	90                   	nop
      --amount;
    }
    if(amount) {
   10a0c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10a10:	0f 84 63 01 00 00    	je     10b79 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10a16:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10a19:	68 4d a1 01 00       	push   $0x1a14d
   10a1e:	50                   	push   %eax
   10a1f:	ff 75 08             	pushl  0x8(%ebp)
   10a22:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a25:	50                   	push   %eax
   10a26:	e8 ff 7d ff ff       	call   882a <lodepng_chunk_init>
   10a2b:	83 c4 10             	add    $0x10,%esp
   10a2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10a31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10a35:	74 08                	je     10a3f <addChunk_tRNS+0x8e>
   10a37:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a3a:	e9 52 01 00 00       	jmp    10b91 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10a3f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10a46:	eb 25                	jmp    10a6d <addChunk_tRNS+0xbc>
   10a48:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a4b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10a4e:	83 c2 08             	add    $0x8,%edx
   10a51:	01 c2                	add    %eax,%edx
   10a53:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a56:	8b 40 08             	mov    0x8(%eax),%eax
   10a59:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10a5c:	c1 e1 02             	shl    $0x2,%ecx
   10a5f:	83 c1 03             	add    $0x3,%ecx
   10a62:	01 c8                	add    %ecx,%eax
   10a64:	0f b6 00             	movzbl (%eax),%eax
   10a67:	88 02                	mov    %al,(%edx)
   10a69:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10a6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a70:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10a73:	75 d3                	jne    10a48 <addChunk_tRNS+0x97>
   10a75:	e9 ff 00 00 00       	jmp    10b79 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10a7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a7d:	8b 00                	mov    (%eax),%eax
   10a7f:	85 c0                	test   %eax,%eax
   10a81:	75 59                	jne    10adc <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10a83:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a86:	8b 40 10             	mov    0x10(%eax),%eax
   10a89:	85 c0                	test   %eax,%eax
   10a8b:	0f 84 e8 00 00 00    	je     10b79 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10a91:	68 4d a1 01 00       	push   $0x1a14d
   10a96:	6a 02                	push   $0x2
   10a98:	ff 75 08             	pushl  0x8(%ebp)
   10a9b:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a9e:	50                   	push   %eax
   10a9f:	e8 86 7d ff ff       	call   882a <lodepng_chunk_init>
   10aa4:	83 c4 10             	add    $0x10,%esp
   10aa7:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10aaa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10aae:	74 08                	je     10ab8 <addChunk_tRNS+0x107>
   10ab0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ab3:	e9 d9 00 00 00       	jmp    10b91 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10ab8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10abb:	8d 50 08             	lea    0x8(%eax),%edx
   10abe:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ac1:	8b 40 14             	mov    0x14(%eax),%eax
   10ac4:	c1 e8 08             	shr    $0x8,%eax
   10ac7:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10ac9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10acc:	8d 50 09             	lea    0x9(%eax),%edx
   10acf:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ad2:	8b 40 14             	mov    0x14(%eax),%eax
   10ad5:	88 02                	mov    %al,(%edx)
   10ad7:	e9 9d 00 00 00       	jmp    10b79 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10adc:	8b 45 0c             	mov    0xc(%ebp),%eax
   10adf:	8b 00                	mov    (%eax),%eax
   10ae1:	83 f8 02             	cmp    $0x2,%eax
   10ae4:	0f 85 8f 00 00 00    	jne    10b79 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10aea:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aed:	8b 40 10             	mov    0x10(%eax),%eax
   10af0:	85 c0                	test   %eax,%eax
   10af2:	0f 84 81 00 00 00    	je     10b79 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10af8:	68 4d a1 01 00       	push   $0x1a14d
   10afd:	6a 06                	push   $0x6
   10aff:	ff 75 08             	pushl  0x8(%ebp)
   10b02:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10b05:	50                   	push   %eax
   10b06:	e8 1f 7d ff ff       	call   882a <lodepng_chunk_init>
   10b0b:	83 c4 10             	add    $0x10,%esp
   10b0e:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10b11:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10b15:	74 05                	je     10b1c <addChunk_tRNS+0x16b>
   10b17:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b1a:	eb 75                	jmp    10b91 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10b1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b1f:	8d 50 08             	lea    0x8(%eax),%edx
   10b22:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b25:	8b 40 14             	mov    0x14(%eax),%eax
   10b28:	c1 e8 08             	shr    $0x8,%eax
   10b2b:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10b2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b30:	8d 50 09             	lea    0x9(%eax),%edx
   10b33:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b36:	8b 40 14             	mov    0x14(%eax),%eax
   10b39:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10b3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b3e:	8d 50 0a             	lea    0xa(%eax),%edx
   10b41:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b44:	8b 40 18             	mov    0x18(%eax),%eax
   10b47:	c1 e8 08             	shr    $0x8,%eax
   10b4a:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10b4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b4f:	8d 50 0b             	lea    0xb(%eax),%edx
   10b52:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b55:	8b 40 18             	mov    0x18(%eax),%eax
   10b58:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10b5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b5d:	8d 50 0c             	lea    0xc(%eax),%edx
   10b60:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b63:	8b 40 1c             	mov    0x1c(%eax),%eax
   10b66:	c1 e8 08             	shr    $0x8,%eax
   10b69:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10b6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b6e:	8d 50 0d             	lea    0xd(%eax),%edx
   10b71:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b74:	8b 40 1c             	mov    0x1c(%eax),%eax
   10b77:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10b79:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b7c:	85 c0                	test   %eax,%eax
   10b7e:	74 0c                	je     10b8c <addChunk_tRNS+0x1db>
   10b80:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b83:	50                   	push   %eax
   10b84:	e8 4a 79 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   10b89:	83 c4 04             	add    $0x4,%esp
  return 0;
   10b8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b91:	c9                   	leave  
   10b92:	c3                   	ret    

00010b93 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10b93:	55                   	push   %ebp
   10b94:	89 e5                	mov    %esp,%ebp
   10b96:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10b99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10ba0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10ba7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10bae:	83 ec 0c             	sub    $0xc,%esp
   10bb1:	ff 75 14             	pushl  0x14(%ebp)
   10bb4:	ff 75 10             	pushl  0x10(%ebp)
   10bb7:	ff 75 0c             	pushl  0xc(%ebp)
   10bba:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10bbd:	50                   	push   %eax
   10bbe:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10bc1:	50                   	push   %eax
   10bc2:	e8 fb 74 ff ff       	call   80c2 <zlib_compress>
   10bc7:	83 c4 20             	add    $0x20,%esp
   10bca:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10bcd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10bd1:	75 1b                	jne    10bee <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bd6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10bd9:	50                   	push   %eax
   10bda:	68 84 a1 01 00       	push   $0x1a184
   10bdf:	52                   	push   %edx
   10be0:	ff 75 08             	pushl  0x8(%ebp)
   10be3:	e8 ea 7c ff ff       	call   88d2 <lodepng_chunk_createv>
   10be8:	83 c4 10             	add    $0x10,%esp
   10beb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10bee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bf1:	83 ec 0c             	sub    $0xc,%esp
   10bf4:	50                   	push   %eax
   10bf5:	e8 d9 27 ff ff       	call   33d3 <lodepng_free>
   10bfa:	83 c4 10             	add    $0x10,%esp
  return error;
   10bfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10c00:	c9                   	leave  
   10c01:	c3                   	ret    

00010c02 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10c02:	55                   	push   %ebp
   10c03:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10c05:	6a 00                	push   $0x0
   10c07:	68 89 a1 01 00       	push   $0x1a189
   10c0c:	6a 00                	push   $0x0
   10c0e:	ff 75 08             	pushl  0x8(%ebp)
   10c11:	e8 bc 7c ff ff       	call   88d2 <lodepng_chunk_createv>
   10c16:	83 c4 10             	add    $0x10,%esp
}
   10c19:	c9                   	leave  
   10c1a:	c3                   	ret    

00010c1b <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10c1b:	55                   	push   %ebp
   10c1c:	89 e5                	mov    %esp,%ebp
   10c1e:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10c21:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10c28:	ff 75 0c             	pushl  0xc(%ebp)
   10c2b:	e8 1e 28 ff ff       	call   344e <lodepng_strlen>
   10c30:	83 c4 04             	add    $0x4,%esp
   10c33:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10c36:	ff 75 10             	pushl  0x10(%ebp)
   10c39:	e8 10 28 ff ff       	call   344e <lodepng_strlen>
   10c3e:	83 c4 04             	add    $0x4,%esp
   10c41:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10c44:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10c47:	8d 50 01             	lea    0x1(%eax),%edx
   10c4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c4d:	01 d0                	add    %edx,%eax
   10c4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10c52:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10c56:	7e 06                	jle    10c5e <addChunk_tEXt+0x43>
   10c58:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10c5c:	7e 07                	jle    10c65 <addChunk_tEXt+0x4a>
   10c5e:	b8 59 00 00 00       	mov    $0x59,%eax
   10c63:	eb 74                	jmp    10cd9 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10c65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c68:	68 57 a1 01 00       	push   $0x1a157
   10c6d:	50                   	push   %eax
   10c6e:	ff 75 08             	pushl  0x8(%ebp)
   10c71:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10c74:	50                   	push   %eax
   10c75:	e8 b0 7b ff ff       	call   882a <lodepng_chunk_init>
   10c7a:	83 c4 10             	add    $0x10,%esp
   10c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10c80:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10c84:	74 05                	je     10c8b <addChunk_tEXt+0x70>
   10c86:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c89:	eb 4e                	jmp    10cd9 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c8e:	83 c0 08             	add    $0x8,%eax
   10c91:	ff 75 fc             	pushl  -0x4(%ebp)
   10c94:	ff 75 0c             	pushl  0xc(%ebp)
   10c97:	50                   	push   %eax
   10c98:	e8 53 27 ff ff       	call   33f0 <lodepng_memcpy>
   10c9d:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10ca0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ca3:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10ca6:	83 c2 08             	add    $0x8,%edx
   10ca9:	01 d0                	add    %edx,%eax
   10cab:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10cae:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cb1:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10cb4:	83 c2 09             	add    $0x9,%edx
   10cb7:	01 d0                	add    %edx,%eax
   10cb9:	ff 75 f8             	pushl  -0x8(%ebp)
   10cbc:	ff 75 10             	pushl  0x10(%ebp)
   10cbf:	50                   	push   %eax
   10cc0:	e8 2b 27 ff ff       	call   33f0 <lodepng_memcpy>
   10cc5:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10cc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ccb:	50                   	push   %eax
   10ccc:	e8 02 78 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   10cd1:	83 c4 04             	add    $0x4,%esp
  return 0;
   10cd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cd9:	c9                   	leave  
   10cda:	c3                   	ret    

00010cdb <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10cdb:	55                   	push   %ebp
   10cdc:	89 e5                	mov    %esp,%ebp
   10cde:	53                   	push   %ebx
   10cdf:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10ce2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10ce9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10cf0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10cf7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10cfe:	ff 75 10             	pushl  0x10(%ebp)
   10d01:	e8 48 27 ff ff       	call   344e <lodepng_strlen>
   10d06:	83 c4 04             	add    $0x4,%esp
   10d09:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10d0c:	ff 75 0c             	pushl  0xc(%ebp)
   10d0f:	e8 3a 27 ff ff       	call   344e <lodepng_strlen>
   10d14:	83 c4 04             	add    $0x4,%esp
   10d17:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10d1a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10d1e:	7e 06                	jle    10d26 <addChunk_zTXt+0x4b>
   10d20:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10d24:	7e 0a                	jle    10d30 <addChunk_zTXt+0x55>
   10d26:	b8 59 00 00 00       	mov    $0x59,%eax
   10d2b:	e9 c8 00 00 00       	jmp    10df8 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10d30:	83 ec 0c             	sub    $0xc,%esp
   10d33:	ff 75 14             	pushl  0x14(%ebp)
   10d36:	ff 75 f0             	pushl  -0x10(%ebp)
   10d39:	ff 75 10             	pushl  0x10(%ebp)
   10d3c:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10d3f:	50                   	push   %eax
   10d40:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10d43:	50                   	push   %eax
   10d44:	e8 79 73 ff ff       	call   80c2 <zlib_compress>
   10d49:	83 c4 20             	add    $0x20,%esp
   10d4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10d4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10d53:	75 29                	jne    10d7e <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10d55:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d58:	8d 50 02             	lea    0x2(%eax),%edx
   10d5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10d5e:	01 d0                	add    %edx,%eax
   10d60:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10d63:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d66:	68 5c a1 01 00       	push   $0x1a15c
   10d6b:	50                   	push   %eax
   10d6c:	ff 75 08             	pushl  0x8(%ebp)
   10d6f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10d72:	50                   	push   %eax
   10d73:	e8 b2 7a ff ff       	call   882a <lodepng_chunk_init>
   10d78:	83 c4 10             	add    $0x10,%esp
   10d7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10d7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10d82:	75 62                	jne    10de6 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10d84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d87:	83 c0 08             	add    $0x8,%eax
   10d8a:	83 ec 04             	sub    $0x4,%esp
   10d8d:	ff 75 ec             	pushl  -0x14(%ebp)
   10d90:	ff 75 0c             	pushl  0xc(%ebp)
   10d93:	50                   	push   %eax
   10d94:	e8 57 26 ff ff       	call   33f0 <lodepng_memcpy>
   10d99:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10d9c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d9f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10da2:	83 c2 08             	add    $0x8,%edx
   10da5:	01 d0                	add    %edx,%eax
   10da7:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10daa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dad:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10db0:	83 c2 09             	add    $0x9,%edx
   10db3:	01 d0                	add    %edx,%eax
   10db5:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10db8:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10dbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10dbe:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10dc1:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10dc4:	83 c3 0a             	add    $0xa,%ebx
   10dc7:	01 d9                	add    %ebx,%ecx
   10dc9:	83 ec 04             	sub    $0x4,%esp
   10dcc:	52                   	push   %edx
   10dcd:	50                   	push   %eax
   10dce:	51                   	push   %ecx
   10dcf:	e8 1c 26 ff ff       	call   33f0 <lodepng_memcpy>
   10dd4:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10dd7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dda:	83 ec 0c             	sub    $0xc,%esp
   10ddd:	50                   	push   %eax
   10dde:	e8 f0 76 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   10de3:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10de6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10de9:	83 ec 0c             	sub    $0xc,%esp
   10dec:	50                   	push   %eax
   10ded:	e8 e1 25 ff ff       	call   33d3 <lodepng_free>
   10df2:	83 c4 10             	add    $0x10,%esp
  return error;
   10df5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10df8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10dfb:	c9                   	leave  
   10dfc:	c3                   	ret    

00010dfd <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10dfd:	55                   	push   %ebp
   10dfe:	89 e5                	mov    %esp,%ebp
   10e00:	53                   	push   %ebx
   10e01:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10e04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10e0b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10e12:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10e19:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10e20:	ff 75 1c             	pushl  0x1c(%ebp)
   10e23:	e8 26 26 ff ff       	call   344e <lodepng_strlen>
   10e28:	83 c4 04             	add    $0x4,%esp
   10e2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10e2e:	ff 75 10             	pushl  0x10(%ebp)
   10e31:	e8 18 26 ff ff       	call   344e <lodepng_strlen>
   10e36:	83 c4 04             	add    $0x4,%esp
   10e39:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10e3c:	ff 75 14             	pushl  0x14(%ebp)
   10e3f:	e8 0a 26 ff ff       	call   344e <lodepng_strlen>
   10e44:	83 c4 04             	add    $0x4,%esp
   10e47:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10e4a:	ff 75 18             	pushl  0x18(%ebp)
   10e4d:	e8 fc 25 ff ff       	call   344e <lodepng_strlen>
   10e52:	83 c4 04             	add    $0x4,%esp
   10e55:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10e58:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10e5c:	7e 06                	jle    10e64 <addChunk_iTXt+0x67>
   10e5e:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10e62:	7e 0a                	jle    10e6e <addChunk_iTXt+0x71>
   10e64:	b8 59 00 00 00       	mov    $0x59,%eax
   10e69:	e9 9a 01 00 00       	jmp    11008 <addChunk_iTXt+0x20b>

  if(compress) {
   10e6e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e72:	74 1f                	je     10e93 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10e74:	83 ec 0c             	sub    $0xc,%esp
   10e77:	ff 75 20             	pushl  0x20(%ebp)
   10e7a:	ff 75 f0             	pushl  -0x10(%ebp)
   10e7d:	ff 75 1c             	pushl  0x1c(%ebp)
   10e80:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10e83:	50                   	push   %eax
   10e84:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10e87:	50                   	push   %eax
   10e88:	e8 35 72 ff ff       	call   80c2 <zlib_compress>
   10e8d:	83 c4 20             	add    $0x20,%esp
   10e90:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10e93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e97:	75 44                	jne    10edd <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10e99:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e9c:	8d 50 03             	lea    0x3(%eax),%edx
   10e9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ea2:	01 d0                	add    %edx,%eax
   10ea4:	8d 50 01             	lea    0x1(%eax),%edx
   10ea7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10eaa:	01 d0                	add    %edx,%eax
   10eac:	8d 50 01             	lea    0x1(%eax),%edx
   10eaf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10eb3:	74 05                	je     10eba <addChunk_iTXt+0xbd>
   10eb5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10eb8:	eb 03                	jmp    10ebd <addChunk_iTXt+0xc0>
   10eba:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ebd:	01 d0                	add    %edx,%eax
   10ebf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10ec2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10ec5:	68 61 a1 01 00       	push   $0x1a161
   10eca:	50                   	push   %eax
   10ecb:	ff 75 08             	pushl  0x8(%ebp)
   10ece:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10ed1:	50                   	push   %eax
   10ed2:	e8 53 79 ff ff       	call   882a <lodepng_chunk_init>
   10ed7:	83 c4 10             	add    $0x10,%esp
   10eda:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10edd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ee1:	0f 85 0f 01 00 00    	jne    10ff6 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10ee7:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10eee:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10ef1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ef4:	01 d0                	add    %edx,%eax
   10ef6:	83 ec 04             	sub    $0x4,%esp
   10ef9:	ff 75 ec             	pushl  -0x14(%ebp)
   10efc:	ff 75 10             	pushl  0x10(%ebp)
   10eff:	50                   	push   %eax
   10f00:	e8 eb 24 ff ff       	call   33f0 <lodepng_memcpy>
   10f05:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10f08:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f0b:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f0e:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f11:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f14:	8d 50 01             	lea    0x1(%eax),%edx
   10f17:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f1a:	01 c8                	add    %ecx,%eax
   10f1c:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10f1f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f22:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f25:	8d 50 01             	lea    0x1(%eax),%edx
   10f28:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f2b:	01 c8                	add    %ecx,%eax
   10f2d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f31:	0f 95 c2             	setne  %dl
   10f34:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10f36:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f39:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f3c:	8d 50 01             	lea    0x1(%eax),%edx
   10f3f:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f42:	01 c8                	add    %ecx,%eax
   10f44:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10f47:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f4d:	01 d0                	add    %edx,%eax
   10f4f:	83 ec 04             	sub    $0x4,%esp
   10f52:	ff 75 e8             	pushl  -0x18(%ebp)
   10f55:	ff 75 14             	pushl  0x14(%ebp)
   10f58:	50                   	push   %eax
   10f59:	e8 92 24 ff ff       	call   33f0 <lodepng_memcpy>
   10f5e:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10f61:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f64:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f67:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f6a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f6d:	8d 50 01             	lea    0x1(%eax),%edx
   10f70:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f73:	01 c8                	add    %ecx,%eax
   10f75:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10f78:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f7e:	01 d0                	add    %edx,%eax
   10f80:	83 ec 04             	sub    $0x4,%esp
   10f83:	ff 75 e4             	pushl  -0x1c(%ebp)
   10f86:	ff 75 18             	pushl  0x18(%ebp)
   10f89:	50                   	push   %eax
   10f8a:	e8 61 24 ff ff       	call   33f0 <lodepng_memcpy>
   10f8f:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10f92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10f95:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f98:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f9e:	8d 50 01             	lea    0x1(%eax),%edx
   10fa1:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10fa4:	01 c8                	add    %ecx,%eax
   10fa6:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10fa9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10fad:	74 1e                	je     10fcd <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   10faf:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10fb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10fb5:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   10fb8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10fbb:	01 d9                	add    %ebx,%ecx
   10fbd:	83 ec 04             	sub    $0x4,%esp
   10fc0:	52                   	push   %edx
   10fc1:	50                   	push   %eax
   10fc2:	51                   	push   %ecx
   10fc3:	e8 28 24 ff ff       	call   33f0 <lodepng_memcpy>
   10fc8:	83 c4 10             	add    $0x10,%esp
   10fcb:	eb 1a                	jmp    10fe7 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   10fcd:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10fd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fd3:	01 d0                	add    %edx,%eax
   10fd5:	83 ec 04             	sub    $0x4,%esp
   10fd8:	ff 75 f0             	pushl  -0x10(%ebp)
   10fdb:	ff 75 1c             	pushl  0x1c(%ebp)
   10fde:	50                   	push   %eax
   10fdf:	e8 0c 24 ff ff       	call   33f0 <lodepng_memcpy>
   10fe4:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   10fe7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10fea:	83 ec 0c             	sub    $0xc,%esp
   10fed:	50                   	push   %eax
   10fee:	e8 e0 74 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   10ff3:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10ff6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10ff9:	83 ec 0c             	sub    $0xc,%esp
   10ffc:	50                   	push   %eax
   10ffd:	e8 d1 23 ff ff       	call   33d3 <lodepng_free>
   11002:	83 c4 10             	add    $0x10,%esp
  return error;
   11005:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11008:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1100b:	c9                   	leave  
   1100c:	c3                   	ret    

0001100d <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   1100d:	55                   	push   %ebp
   1100e:	89 e5                	mov    %esp,%ebp
   11010:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11013:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   1101a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1101d:	8b 40 0c             	mov    0xc(%eax),%eax
   11020:	85 c0                	test   %eax,%eax
   11022:	74 0b                	je     1102f <addChunk_bKGD+0x22>
   11024:	8b 45 0c             	mov    0xc(%ebp),%eax
   11027:	8b 40 0c             	mov    0xc(%eax),%eax
   1102a:	83 f8 04             	cmp    $0x4,%eax
   1102d:	75 4b                	jne    1107a <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   1102f:	68 52 a1 01 00       	push   $0x1a152
   11034:	6a 02                	push   $0x2
   11036:	ff 75 08             	pushl  0x8(%ebp)
   11039:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1103c:	50                   	push   %eax
   1103d:	e8 e8 77 ff ff       	call   882a <lodepng_chunk_init>
   11042:	83 c4 10             	add    $0x10,%esp
   11045:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11048:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1104c:	74 08                	je     11056 <addChunk_bKGD+0x49>
   1104e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11051:	e9 19 01 00 00       	jmp    1116f <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11056:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11059:	8d 50 08             	lea    0x8(%eax),%edx
   1105c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1105f:	8b 40 30             	mov    0x30(%eax),%eax
   11062:	c1 e8 08             	shr    $0x8,%eax
   11065:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11067:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1106a:	8d 50 09             	lea    0x9(%eax),%edx
   1106d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11070:	8b 40 30             	mov    0x30(%eax),%eax
   11073:	88 02                	mov    %al,(%edx)
   11075:	e9 dd 00 00 00       	jmp    11157 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   1107a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1107d:	8b 40 0c             	mov    0xc(%eax),%eax
   11080:	83 f8 02             	cmp    $0x2,%eax
   11083:	74 0f                	je     11094 <addChunk_bKGD+0x87>
   11085:	8b 45 0c             	mov    0xc(%ebp),%eax
   11088:	8b 40 0c             	mov    0xc(%eax),%eax
   1108b:	83 f8 06             	cmp    $0x6,%eax
   1108e:	0f 85 86 00 00 00    	jne    1111a <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   11094:	68 52 a1 01 00       	push   $0x1a152
   11099:	6a 06                	push   $0x6
   1109b:	ff 75 08             	pushl  0x8(%ebp)
   1109e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110a1:	50                   	push   %eax
   110a2:	e8 83 77 ff ff       	call   882a <lodepng_chunk_init>
   110a7:	83 c4 10             	add    $0x10,%esp
   110aa:	89 45 f8             	mov    %eax,-0x8(%ebp)
   110ad:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   110b1:	74 08                	je     110bb <addChunk_bKGD+0xae>
   110b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   110b6:	e9 b4 00 00 00       	jmp    1116f <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   110bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110be:	8d 50 08             	lea    0x8(%eax),%edx
   110c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   110c4:	8b 40 30             	mov    0x30(%eax),%eax
   110c7:	c1 e8 08             	shr    $0x8,%eax
   110ca:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   110cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110cf:	8d 50 09             	lea    0x9(%eax),%edx
   110d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   110d5:	8b 40 30             	mov    0x30(%eax),%eax
   110d8:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   110da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110dd:	8d 50 0a             	lea    0xa(%eax),%edx
   110e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   110e3:	8b 40 34             	mov    0x34(%eax),%eax
   110e6:	c1 e8 08             	shr    $0x8,%eax
   110e9:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   110eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110ee:	8d 50 0b             	lea    0xb(%eax),%edx
   110f1:	8b 45 0c             	mov    0xc(%ebp),%eax
   110f4:	8b 40 34             	mov    0x34(%eax),%eax
   110f7:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   110f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110fc:	8d 50 0c             	lea    0xc(%eax),%edx
   110ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11102:	8b 40 38             	mov    0x38(%eax),%eax
   11105:	c1 e8 08             	shr    $0x8,%eax
   11108:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   1110a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1110d:	8d 50 0d             	lea    0xd(%eax),%edx
   11110:	8b 45 0c             	mov    0xc(%ebp),%eax
   11113:	8b 40 38             	mov    0x38(%eax),%eax
   11116:	88 02                	mov    %al,(%edx)
   11118:	eb 3d                	jmp    11157 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1111a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1111d:	8b 40 0c             	mov    0xc(%eax),%eax
   11120:	83 f8 03             	cmp    $0x3,%eax
   11123:	75 32                	jne    11157 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11125:	68 52 a1 01 00       	push   $0x1a152
   1112a:	6a 01                	push   $0x1
   1112c:	ff 75 08             	pushl  0x8(%ebp)
   1112f:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11132:	50                   	push   %eax
   11133:	e8 f2 76 ff ff       	call   882a <lodepng_chunk_init>
   11138:	83 c4 10             	add    $0x10,%esp
   1113b:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1113e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11142:	74 05                	je     11149 <addChunk_bKGD+0x13c>
   11144:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11147:	eb 26                	jmp    1116f <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   11149:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1114c:	8d 50 08             	lea    0x8(%eax),%edx
   1114f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11152:	8b 40 30             	mov    0x30(%eax),%eax
   11155:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   11157:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1115a:	85 c0                	test   %eax,%eax
   1115c:	74 0c                	je     1116a <addChunk_bKGD+0x15d>
   1115e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11161:	50                   	push   %eax
   11162:	e8 6c 73 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   11167:	83 c4 04             	add    $0x4,%esp
  return 0;
   1116a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1116f:	c9                   	leave  
   11170:	c3                   	ret    

00011171 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   11171:	55                   	push   %ebp
   11172:	89 e5                	mov    %esp,%ebp
   11174:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   11177:	68 66 a1 01 00       	push   $0x1a166
   1117c:	6a 07                	push   $0x7
   1117e:	ff 75 08             	pushl  0x8(%ebp)
   11181:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11184:	50                   	push   %eax
   11185:	e8 a0 76 ff ff       	call   882a <lodepng_chunk_init>
   1118a:	83 c4 10             	add    $0x10,%esp
   1118d:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11190:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11194:	74 05                	je     1119b <addChunk_tIME+0x2a>
   11196:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11199:	eb 74                	jmp    1120f <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   1119b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1119e:	8d 50 08             	lea    0x8(%eax),%edx
   111a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   111a4:	8b 00                	mov    (%eax),%eax
   111a6:	c1 e8 08             	shr    $0x8,%eax
   111a9:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   111ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111ae:	8d 50 09             	lea    0x9(%eax),%edx
   111b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   111b4:	8b 00                	mov    (%eax),%eax
   111b6:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   111b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111bb:	8d 50 0a             	lea    0xa(%eax),%edx
   111be:	8b 45 0c             	mov    0xc(%ebp),%eax
   111c1:	8b 40 04             	mov    0x4(%eax),%eax
   111c4:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   111c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111c9:	8d 50 0b             	lea    0xb(%eax),%edx
   111cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   111cf:	8b 40 08             	mov    0x8(%eax),%eax
   111d2:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   111d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111d7:	8d 50 0c             	lea    0xc(%eax),%edx
   111da:	8b 45 0c             	mov    0xc(%ebp),%eax
   111dd:	8b 40 0c             	mov    0xc(%eax),%eax
   111e0:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   111e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111e5:	8d 50 0d             	lea    0xd(%eax),%edx
   111e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   111eb:	8b 40 10             	mov    0x10(%eax),%eax
   111ee:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   111f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111f3:	8d 50 0e             	lea    0xe(%eax),%edx
   111f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   111f9:	8b 40 14             	mov    0x14(%eax),%eax
   111fc:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   111fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11201:	50                   	push   %eax
   11202:	e8 cc 72 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   11207:	83 c4 04             	add    $0x4,%esp
  return 0;
   1120a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1120f:	c9                   	leave  
   11210:	c3                   	ret    

00011211 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11211:	55                   	push   %ebp
   11212:	89 e5                	mov    %esp,%ebp
   11214:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   11217:	68 6b a1 01 00       	push   $0x1a16b
   1121c:	6a 09                	push   $0x9
   1121e:	ff 75 08             	pushl  0x8(%ebp)
   11221:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11224:	50                   	push   %eax
   11225:	e8 00 76 ff ff       	call   882a <lodepng_chunk_init>
   1122a:	83 c4 10             	add    $0x10,%esp
   1122d:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11230:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11234:	74 05                	je     1123b <addChunk_pHYs+0x2a>
   11236:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11239:	eb 51                	jmp    1128c <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   1123b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1123e:	8b 40 7c             	mov    0x7c(%eax),%eax
   11241:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11244:	83 c2 08             	add    $0x8,%edx
   11247:	50                   	push   %eax
   11248:	52                   	push   %edx
   11249:	e8 25 25 ff ff       	call   3773 <lodepng_set32bitInt>
   1124e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   11251:	8b 45 0c             	mov    0xc(%ebp),%eax
   11254:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1125a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1125d:	83 c2 0c             	add    $0xc,%edx
   11260:	50                   	push   %eax
   11261:	52                   	push   %edx
   11262:	e8 0c 25 ff ff       	call   3773 <lodepng_set32bitInt>
   11267:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   1126a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1126d:	8d 50 10             	lea    0x10(%eax),%edx
   11270:	8b 45 0c             	mov    0xc(%ebp),%eax
   11273:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   11279:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1127b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1127e:	50                   	push   %eax
   1127f:	e8 4f 72 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   11284:	83 c4 04             	add    $0x4,%esp
  return 0;
   11287:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1128c:	c9                   	leave  
   1128d:	c3                   	ret    

0001128e <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   1128e:	55                   	push   %ebp
   1128f:	89 e5                	mov    %esp,%ebp
   11291:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   11294:	68 70 a1 01 00       	push   $0x1a170
   11299:	6a 04                	push   $0x4
   1129b:	ff 75 08             	pushl  0x8(%ebp)
   1129e:	8d 45 f8             	lea    -0x8(%ebp),%eax
   112a1:	50                   	push   %eax
   112a2:	e8 83 75 ff ff       	call   882a <lodepng_chunk_init>
   112a7:	83 c4 10             	add    $0x10,%esp
   112aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
   112ad:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   112b1:	74 05                	je     112b8 <addChunk_gAMA+0x2a>
   112b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   112b6:	eb 2a                	jmp    112e2 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   112b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   112bb:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   112c1:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112c4:	83 c2 08             	add    $0x8,%edx
   112c7:	50                   	push   %eax
   112c8:	52                   	push   %edx
   112c9:	e8 a5 24 ff ff       	call   3773 <lodepng_set32bitInt>
   112ce:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   112d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112d4:	50                   	push   %eax
   112d5:	e8 f9 71 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   112da:	83 c4 04             	add    $0x4,%esp
  return 0;
   112dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   112e2:	c9                   	leave  
   112e3:	c3                   	ret    

000112e4 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   112e4:	55                   	push   %ebp
   112e5:	89 e5                	mov    %esp,%ebp
   112e7:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   112ea:	68 75 a1 01 00       	push   $0x1a175
   112ef:	6a 20                	push   $0x20
   112f1:	ff 75 08             	pushl  0x8(%ebp)
   112f4:	8d 45 f8             	lea    -0x8(%ebp),%eax
   112f7:	50                   	push   %eax
   112f8:	e8 2d 75 ff ff       	call   882a <lodepng_chunk_init>
   112fd:	83 c4 10             	add    $0x10,%esp
   11300:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11303:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11307:	74 08                	je     11311 <addChunk_cHRM+0x2d>
   11309:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1130c:	e9 d9 00 00 00       	jmp    113ea <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11311:	8b 45 0c             	mov    0xc(%ebp),%eax
   11314:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1131a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1131d:	83 c2 08             	add    $0x8,%edx
   11320:	50                   	push   %eax
   11321:	52                   	push   %edx
   11322:	e8 4c 24 ff ff       	call   3773 <lodepng_set32bitInt>
   11327:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1132a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1132d:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11333:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11336:	83 c2 0c             	add    $0xc,%edx
   11339:	50                   	push   %eax
   1133a:	52                   	push   %edx
   1133b:	e8 33 24 ff ff       	call   3773 <lodepng_set32bitInt>
   11340:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11343:	8b 45 0c             	mov    0xc(%ebp),%eax
   11346:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   1134c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1134f:	83 c2 10             	add    $0x10,%edx
   11352:	50                   	push   %eax
   11353:	52                   	push   %edx
   11354:	e8 1a 24 ff ff       	call   3773 <lodepng_set32bitInt>
   11359:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   1135c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1135f:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11365:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11368:	83 c2 14             	add    $0x14,%edx
   1136b:	50                   	push   %eax
   1136c:	52                   	push   %edx
   1136d:	e8 01 24 ff ff       	call   3773 <lodepng_set32bitInt>
   11372:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   11375:	8b 45 0c             	mov    0xc(%ebp),%eax
   11378:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   1137e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11381:	83 c2 18             	add    $0x18,%edx
   11384:	50                   	push   %eax
   11385:	52                   	push   %edx
   11386:	e8 e8 23 ff ff       	call   3773 <lodepng_set32bitInt>
   1138b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   1138e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11391:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   11397:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1139a:	83 c2 1c             	add    $0x1c,%edx
   1139d:	50                   	push   %eax
   1139e:	52                   	push   %edx
   1139f:	e8 cf 23 ff ff       	call   3773 <lodepng_set32bitInt>
   113a4:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   113a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   113aa:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   113b0:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113b3:	83 c2 20             	add    $0x20,%edx
   113b6:	50                   	push   %eax
   113b7:	52                   	push   %edx
   113b8:	e8 b6 23 ff ff       	call   3773 <lodepng_set32bitInt>
   113bd:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   113c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   113c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   113c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113cc:	83 c2 24             	add    $0x24,%edx
   113cf:	50                   	push   %eax
   113d0:	52                   	push   %edx
   113d1:	e8 9d 23 ff ff       	call   3773 <lodepng_set32bitInt>
   113d6:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   113d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113dc:	50                   	push   %eax
   113dd:	e8 f1 70 ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   113e2:	83 c4 04             	add    $0x4,%esp
  return 0;
   113e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   113ea:	c9                   	leave  
   113eb:	c3                   	ret    

000113ec <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   113ec:	55                   	push   %ebp
   113ed:	89 e5                	mov    %esp,%ebp
   113ef:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   113f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   113f5:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   113fb:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   113fe:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11401:	50                   	push   %eax
   11402:	68 7a a1 01 00       	push   $0x1a17a
   11407:	6a 01                	push   $0x1
   11409:	ff 75 08             	pushl  0x8(%ebp)
   1140c:	e8 c1 74 ff ff       	call   88d2 <lodepng_chunk_createv>
   11411:	83 c4 10             	add    $0x10,%esp
}
   11414:	c9                   	leave  
   11415:	c3                   	ret    

00011416 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11416:	55                   	push   %ebp
   11417:	89 e5                	mov    %esp,%ebp
   11419:	53                   	push   %ebx
   1141a:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   1141d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11424:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   1142b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11432:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   11439:	8b 45 0c             	mov    0xc(%ebp),%eax
   1143c:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11442:	50                   	push   %eax
   11443:	e8 06 20 ff ff       	call   344e <lodepng_strlen>
   11448:	83 c4 04             	add    $0x4,%esp
   1144b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1144e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11452:	7e 06                	jle    1145a <addChunk_iCCP+0x44>
   11454:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   11458:	7e 0a                	jle    11464 <addChunk_iCCP+0x4e>
   1145a:	b8 59 00 00 00       	mov    $0x59,%eax
   1145f:	e9 df 00 00 00       	jmp    11543 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11464:	8b 45 0c             	mov    0xc(%ebp),%eax
   11467:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   1146d:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   1146f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11472:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11478:	83 ec 0c             	sub    $0xc,%esp
   1147b:	ff 75 10             	pushl  0x10(%ebp)
   1147e:	52                   	push   %edx
   1147f:	50                   	push   %eax
   11480:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11483:	50                   	push   %eax
   11484:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11487:	50                   	push   %eax
   11488:	e8 35 6c ff ff       	call   80c2 <zlib_compress>
   1148d:	83 c4 20             	add    $0x20,%esp
   11490:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   11493:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11497:	75 29                	jne    114c2 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   11499:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1149c:	8d 50 02             	lea    0x2(%eax),%edx
   1149f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   114a2:	01 d0                	add    %edx,%eax
   114a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   114a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   114aa:	68 7f a1 01 00       	push   $0x1a17f
   114af:	50                   	push   %eax
   114b0:	ff 75 08             	pushl  0x8(%ebp)
   114b3:	8d 45 e8             	lea    -0x18(%ebp),%eax
   114b6:	50                   	push   %eax
   114b7:	e8 6e 73 ff ff       	call   882a <lodepng_chunk_init>
   114bc:	83 c4 10             	add    $0x10,%esp
   114bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   114c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   114c6:	75 69                	jne    11531 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   114c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   114cb:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   114d1:	8b 55 e8             	mov    -0x18(%ebp),%edx
   114d4:	83 c2 08             	add    $0x8,%edx
   114d7:	83 ec 04             	sub    $0x4,%esp
   114da:	ff 75 f0             	pushl  -0x10(%ebp)
   114dd:	50                   	push   %eax
   114de:	52                   	push   %edx
   114df:	e8 0c 1f ff ff       	call   33f0 <lodepng_memcpy>
   114e4:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   114e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   114ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
   114ed:	83 c2 08             	add    $0x8,%edx
   114f0:	01 d0                	add    %edx,%eax
   114f2:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   114f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   114f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
   114fb:	83 c2 09             	add    $0x9,%edx
   114fe:	01 d0                	add    %edx,%eax
   11500:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11503:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11506:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11509:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1150c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1150f:	83 c3 0a             	add    $0xa,%ebx
   11512:	01 d9                	add    %ebx,%ecx
   11514:	83 ec 04             	sub    $0x4,%esp
   11517:	52                   	push   %edx
   11518:	50                   	push   %eax
   11519:	51                   	push   %ecx
   1151a:	e8 d1 1e ff ff       	call   33f0 <lodepng_memcpy>
   1151f:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11522:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11525:	83 ec 0c             	sub    $0xc,%esp
   11528:	50                   	push   %eax
   11529:	e8 a5 6f ff ff       	call   84d3 <lodepng_chunk_generate_crc>
   1152e:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11531:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11534:	83 ec 0c             	sub    $0xc,%esp
   11537:	50                   	push   %eax
   11538:	e8 96 1e ff ff       	call   33d3 <lodepng_free>
   1153d:	83 c4 10             	add    $0x10,%esp
  return error;
   11540:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11543:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11546:	c9                   	leave  
   11547:	c3                   	ret    

00011548 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   11548:	55                   	push   %ebp
   11549:	89 e5                	mov    %esp,%ebp
   1154b:	56                   	push   %esi
   1154c:	53                   	push   %ebx
   1154d:	83 ec 14             	sub    $0x14,%esp
   11550:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11553:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   11556:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1155a:	83 f8 04             	cmp    $0x4,%eax
   1155d:	0f 87 41 03 00 00    	ja     118a4 <filterScanline+0x35c>
   11563:	8b 04 85 90 a1 01 00 	mov    0x1a190(,%eax,4),%eax
   1156a:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   1156c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11573:	eb 19                	jmp    1158e <filterScanline+0x46>
   11575:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11578:	8b 45 08             	mov    0x8(%ebp),%eax
   1157b:	01 c2                	add    %eax,%edx
   1157d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11580:	8b 45 0c             	mov    0xc(%ebp),%eax
   11583:	01 c8                	add    %ecx,%eax
   11585:	0f b6 00             	movzbl (%eax),%eax
   11588:	88 02                	mov    %al,(%edx)
   1158a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1158e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11591:	3b 45 14             	cmp    0x14(%ebp),%eax
   11594:	75 df                	jne    11575 <filterScanline+0x2d>
      break;
   11596:	e9 0a 03 00 00       	jmp    118a5 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1159b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115a2:	eb 19                	jmp    115bd <filterScanline+0x75>
   115a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115a7:	8b 45 08             	mov    0x8(%ebp),%eax
   115aa:	01 c2                	add    %eax,%edx
   115ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115af:	8b 45 0c             	mov    0xc(%ebp),%eax
   115b2:	01 c8                	add    %ecx,%eax
   115b4:	0f b6 00             	movzbl (%eax),%eax
   115b7:	88 02                	mov    %al,(%edx)
   115b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115c0:	3b 45 18             	cmp    0x18(%ebp),%eax
   115c3:	75 df                	jne    115a4 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   115c5:	8b 45 18             	mov    0x18(%ebp),%eax
   115c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
   115cb:	eb 2d                	jmp    115fa <filterScanline+0xb2>
   115cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115d0:	8b 45 08             	mov    0x8(%ebp),%eax
   115d3:	01 c2                	add    %eax,%edx
   115d5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115d8:	8b 45 0c             	mov    0xc(%ebp),%eax
   115db:	01 c8                	add    %ecx,%eax
   115dd:	0f b6 08             	movzbl (%eax),%ecx
   115e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115e3:	2b 45 18             	sub    0x18(%ebp),%eax
   115e6:	89 c3                	mov    %eax,%ebx
   115e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   115eb:	01 d8                	add    %ebx,%eax
   115ed:	0f b6 00             	movzbl (%eax),%eax
   115f0:	29 c1                	sub    %eax,%ecx
   115f2:	89 c8                	mov    %ecx,%eax
   115f4:	88 02                	mov    %al,(%edx)
   115f6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115fd:	3b 45 14             	cmp    0x14(%ebp),%eax
   11600:	7c cb                	jl     115cd <filterScanline+0x85>
      break;
   11602:	e9 9e 02 00 00       	jmp    118a5 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11607:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1160b:	74 3e                	je     1164b <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   1160d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11614:	eb 28                	jmp    1163e <filterScanline+0xf6>
   11616:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11619:	8b 45 08             	mov    0x8(%ebp),%eax
   1161c:	01 d0                	add    %edx,%eax
   1161e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11621:	8b 55 0c             	mov    0xc(%ebp),%edx
   11624:	01 ca                	add    %ecx,%edx
   11626:	0f b6 0a             	movzbl (%edx),%ecx
   11629:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1162c:	8b 55 10             	mov    0x10(%ebp),%edx
   1162f:	01 da                	add    %ebx,%edx
   11631:	0f b6 12             	movzbl (%edx),%edx
   11634:	29 d1                	sub    %edx,%ecx
   11636:	89 ca                	mov    %ecx,%edx
   11638:	88 10                	mov    %dl,(%eax)
   1163a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1163e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11641:	3b 45 14             	cmp    0x14(%ebp),%eax
   11644:	75 d0                	jne    11616 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   11646:	e9 5a 02 00 00       	jmp    118a5 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   1164b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11652:	eb 19                	jmp    1166d <filterScanline+0x125>
   11654:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11657:	8b 45 08             	mov    0x8(%ebp),%eax
   1165a:	01 c2                	add    %eax,%edx
   1165c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1165f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11662:	01 c8                	add    %ecx,%eax
   11664:	0f b6 00             	movzbl (%eax),%eax
   11667:	88 02                	mov    %al,(%edx)
   11669:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1166d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11670:	3b 45 14             	cmp    0x14(%ebp),%eax
   11673:	75 df                	jne    11654 <filterScanline+0x10c>
      }
      break;
   11675:	e9 2b 02 00 00       	jmp    118a5 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   1167a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1167e:	0f 84 90 00 00 00    	je     11714 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   11684:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1168b:	eb 28                	jmp    116b5 <filterScanline+0x16d>
   1168d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11690:	8b 45 08             	mov    0x8(%ebp),%eax
   11693:	01 d0                	add    %edx,%eax
   11695:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11698:	8b 55 0c             	mov    0xc(%ebp),%edx
   1169b:	01 ca                	add    %ecx,%edx
   1169d:	0f b6 12             	movzbl (%edx),%edx
   116a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   116a3:	8b 4d 10             	mov    0x10(%ebp),%ecx
   116a6:	01 d9                	add    %ebx,%ecx
   116a8:	0f b6 09             	movzbl (%ecx),%ecx
   116ab:	d0 e9                	shr    %cl
   116ad:	29 ca                	sub    %ecx,%edx
   116af:	88 10                	mov    %dl,(%eax)
   116b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116b8:	3b 45 18             	cmp    0x18(%ebp),%eax
   116bb:	75 d0                	jne    1168d <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   116bd:	8b 45 18             	mov    0x18(%ebp),%eax
   116c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116c3:	eb 42                	jmp    11707 <filterScanline+0x1bf>
   116c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116c8:	8b 45 08             	mov    0x8(%ebp),%eax
   116cb:	01 c2                	add    %eax,%edx
   116cd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116d0:	8b 45 0c             	mov    0xc(%ebp),%eax
   116d3:	01 c8                	add    %ecx,%eax
   116d5:	0f b6 08             	movzbl (%eax),%ecx
   116d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116db:	2b 45 18             	sub    0x18(%ebp),%eax
   116de:	89 c3                	mov    %eax,%ebx
   116e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   116e3:	01 d8                	add    %ebx,%eax
   116e5:	0f b6 00             	movzbl (%eax),%eax
   116e8:	0f b6 d8             	movzbl %al,%ebx
   116eb:	8b 75 f4             	mov    -0xc(%ebp),%esi
   116ee:	8b 45 10             	mov    0x10(%ebp),%eax
   116f1:	01 f0                	add    %esi,%eax
   116f3:	0f b6 00             	movzbl (%eax),%eax
   116f6:	0f b6 c0             	movzbl %al,%eax
   116f9:	01 d8                	add    %ebx,%eax
   116fb:	d1 f8                	sar    %eax
   116fd:	29 c1                	sub    %eax,%ecx
   116ff:	89 c8                	mov    %ecx,%eax
   11701:	88 02                	mov    %al,(%edx)
   11703:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11707:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1170a:	3b 45 14             	cmp    0x14(%ebp),%eax
   1170d:	7c b6                	jl     116c5 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   1170f:	e9 91 01 00 00       	jmp    118a5 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11714:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1171b:	eb 19                	jmp    11736 <filterScanline+0x1ee>
   1171d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11720:	8b 45 08             	mov    0x8(%ebp),%eax
   11723:	01 c2                	add    %eax,%edx
   11725:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11728:	8b 45 0c             	mov    0xc(%ebp),%eax
   1172b:	01 c8                	add    %ecx,%eax
   1172d:	0f b6 00             	movzbl (%eax),%eax
   11730:	88 02                	mov    %al,(%edx)
   11732:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11736:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11739:	3b 45 18             	cmp    0x18(%ebp),%eax
   1173c:	75 df                	jne    1171d <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   1173e:	8b 45 18             	mov    0x18(%ebp),%eax
   11741:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11744:	eb 2f                	jmp    11775 <filterScanline+0x22d>
   11746:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11749:	8b 45 08             	mov    0x8(%ebp),%eax
   1174c:	01 c2                	add    %eax,%edx
   1174e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11751:	8b 45 0c             	mov    0xc(%ebp),%eax
   11754:	01 c8                	add    %ecx,%eax
   11756:	0f b6 08             	movzbl (%eax),%ecx
   11759:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1175c:	2b 45 18             	sub    0x18(%ebp),%eax
   1175f:	89 c3                	mov    %eax,%ebx
   11761:	8b 45 0c             	mov    0xc(%ebp),%eax
   11764:	01 d8                	add    %ebx,%eax
   11766:	0f b6 00             	movzbl (%eax),%eax
   11769:	d0 e8                	shr    %al
   1176b:	29 c1                	sub    %eax,%ecx
   1176d:	89 c8                	mov    %ecx,%eax
   1176f:	88 02                	mov    %al,(%edx)
   11771:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11775:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11778:	3b 45 14             	cmp    0x14(%ebp),%eax
   1177b:	7c c9                	jl     11746 <filterScanline+0x1fe>
      }
      break;
   1177d:	e9 23 01 00 00       	jmp    118a5 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   11782:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11786:	0f 84 af 00 00 00    	je     1183b <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   1178c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11793:	eb 28                	jmp    117bd <filterScanline+0x275>
   11795:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11798:	8b 45 08             	mov    0x8(%ebp),%eax
   1179b:	01 d0                	add    %edx,%eax
   1179d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117a0:	8b 55 0c             	mov    0xc(%ebp),%edx
   117a3:	01 ca                	add    %ecx,%edx
   117a5:	0f b6 0a             	movzbl (%edx),%ecx
   117a8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   117ab:	8b 55 10             	mov    0x10(%ebp),%edx
   117ae:	01 da                	add    %ebx,%edx
   117b0:	0f b6 12             	movzbl (%edx),%edx
   117b3:	29 d1                	sub    %edx,%ecx
   117b5:	89 ca                	mov    %ecx,%edx
   117b7:	88 10                	mov    %dl,(%eax)
   117b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c0:	3b 45 18             	cmp    0x18(%ebp),%eax
   117c3:	75 d0                	jne    11795 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   117c5:	8b 45 18             	mov    0x18(%ebp),%eax
   117c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
   117cb:	eb 64                	jmp    11831 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   117cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117d0:	8b 45 08             	mov    0x8(%ebp),%eax
   117d3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   117d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   117dc:	01 d0                	add    %edx,%eax
   117de:	0f b6 00             	movzbl (%eax),%eax
   117e1:	88 45 e7             	mov    %al,-0x19(%ebp)
   117e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117e7:	2b 45 18             	sub    0x18(%ebp),%eax
   117ea:	89 c2                	mov    %eax,%edx
   117ec:	8b 45 10             	mov    0x10(%ebp),%eax
   117ef:	01 d0                	add    %edx,%eax
   117f1:	0f b6 00             	movzbl (%eax),%eax
   117f4:	0f b6 c8             	movzbl %al,%ecx
   117f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117fa:	8b 45 10             	mov    0x10(%ebp),%eax
   117fd:	01 d0                	add    %edx,%eax
   117ff:	0f b6 00             	movzbl (%eax),%eax
   11802:	0f b6 d0             	movzbl %al,%edx
   11805:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11808:	2b 45 18             	sub    0x18(%ebp),%eax
   1180b:	89 c6                	mov    %eax,%esi
   1180d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11810:	01 f0                	add    %esi,%eax
   11812:	0f b6 00             	movzbl (%eax),%eax
   11815:	0f b6 c0             	movzbl %al,%eax
   11818:	51                   	push   %ecx
   11819:	52                   	push   %edx
   1181a:	50                   	push   %eax
   1181b:	e8 49 b8 ff ff       	call   d069 <paethPredictor>
   11820:	83 c4 0c             	add    $0xc,%esp
   11823:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11827:	29 c1                	sub    %eax,%ecx
   11829:	89 c8                	mov    %ecx,%eax
   1182b:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   1182d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11831:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11834:	3b 45 14             	cmp    0x14(%ebp),%eax
   11837:	7c 94                	jl     117cd <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11839:	eb 6a                	jmp    118a5 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1183b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11842:	eb 19                	jmp    1185d <filterScanline+0x315>
   11844:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11847:	8b 45 08             	mov    0x8(%ebp),%eax
   1184a:	01 c2                	add    %eax,%edx
   1184c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1184f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11852:	01 c8                	add    %ecx,%eax
   11854:	0f b6 00             	movzbl (%eax),%eax
   11857:	88 02                	mov    %al,(%edx)
   11859:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1185d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11860:	3b 45 18             	cmp    0x18(%ebp),%eax
   11863:	75 df                	jne    11844 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11865:	8b 45 18             	mov    0x18(%ebp),%eax
   11868:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1186b:	eb 2d                	jmp    1189a <filterScanline+0x352>
   1186d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11870:	8b 45 08             	mov    0x8(%ebp),%eax
   11873:	01 c2                	add    %eax,%edx
   11875:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11878:	8b 45 0c             	mov    0xc(%ebp),%eax
   1187b:	01 c8                	add    %ecx,%eax
   1187d:	0f b6 08             	movzbl (%eax),%ecx
   11880:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11883:	2b 45 18             	sub    0x18(%ebp),%eax
   11886:	89 c3                	mov    %eax,%ebx
   11888:	8b 45 0c             	mov    0xc(%ebp),%eax
   1188b:	01 d8                	add    %ebx,%eax
   1188d:	0f b6 00             	movzbl (%eax),%eax
   11890:	29 c1                	sub    %eax,%ecx
   11892:	89 c8                	mov    %ecx,%eax
   11894:	88 02                	mov    %al,(%edx)
   11896:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1189a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1189d:	3b 45 14             	cmp    0x14(%ebp),%eax
   118a0:	7c cb                	jl     1186d <filterScanline+0x325>
      }
      break;
   118a2:	eb 01                	jmp    118a5 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   118a4:	90                   	nop
  }
}
   118a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
   118a8:	5b                   	pop    %ebx
   118a9:	5e                   	pop    %esi
   118aa:	5d                   	pop    %ebp
   118ab:	c3                   	ret    

000118ac <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   118ac:	55                   	push   %ebp
   118ad:	89 e5                	mov    %esp,%ebp
   118af:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   118b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   118b9:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   118c0:	7e 08                	jle    118ca <ilog2+0x1e>
   118c2:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   118c6:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   118ca:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   118d1:	7e 08                	jle    118db <ilog2+0x2f>
   118d3:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   118d7:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   118db:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   118df:	7e 08                	jle    118e9 <ilog2+0x3d>
   118e1:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   118e5:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   118e9:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   118ed:	7e 08                	jle    118f7 <ilog2+0x4b>
   118ef:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   118f3:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   118f7:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   118fb:	7e 04                	jle    11901 <ilog2+0x55>
   118fd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11901:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11904:	c9                   	leave  
   11905:	c3                   	ret    

00011906 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11906:	55                   	push   %ebp
   11907:	89 e5                	mov    %esp,%ebp
   11909:	56                   	push   %esi
   1190a:	53                   	push   %ebx
   1190b:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   1190e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11912:	75 07                	jne    1191b <ilog2i+0x15>
   11914:	b8 00 00 00 00       	mov    $0x0,%eax
   11919:	eb 30                	jmp    1194b <ilog2i+0x45>
  l = ilog2(i);
   1191b:	ff 75 08             	pushl  0x8(%ebp)
   1191e:	e8 89 ff ff ff       	call   118ac <ilog2>
   11923:	83 c4 04             	add    $0x4,%esp
   11926:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11929:	8b 45 08             	mov    0x8(%ebp),%eax
   1192c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11930:	89 c3                	mov    %eax,%ebx
   11932:	8b 55 08             	mov    0x8(%ebp),%edx
   11935:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11938:	be 01 00 00 00       	mov    $0x1,%esi
   1193d:	89 c1                	mov    %eax,%ecx
   1193f:	d3 e6                	shl    %cl,%esi
   11941:	89 f0                	mov    %esi,%eax
   11943:	29 c2                	sub    %eax,%edx
   11945:	89 d0                	mov    %edx,%eax
   11947:	01 c0                	add    %eax,%eax
   11949:	01 d8                	add    %ebx,%eax
}
   1194b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1194e:	5b                   	pop    %ebx
   1194f:	5e                   	pop    %esi
   11950:	5d                   	pop    %ebp
   11951:	c3                   	ret    

00011952 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11952:	55                   	push   %ebp
   11953:	89 e5                	mov    %esp,%ebp
   11955:	53                   	push   %ebx
   11956:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   1195c:	ff 75 18             	pushl  0x18(%ebp)
   1195f:	e8 6a 75 ff ff       	call   8ece <lodepng_get_bpp>
   11964:	83 c4 04             	add    $0x4,%esp
   11967:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   1196a:	ff 75 b8             	pushl  -0x48(%ebp)
   1196d:	6a 01                	push   $0x1
   1196f:	ff 75 10             	pushl  0x10(%ebp)
   11972:	e8 b6 76 ff ff       	call   902d <lodepng_get_raw_size_idat>
   11977:	83 c4 0c             	add    $0xc,%esp
   1197a:	83 e8 01             	sub    $0x1,%eax
   1197d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   11980:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11983:	83 c0 07             	add    $0x7,%eax
   11986:	c1 e8 03             	shr    $0x3,%eax
   11989:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   1198c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11993:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   1199a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1199d:	8b 40 2c             	mov    0x2c(%eax),%eax
   119a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   119a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   119a6:	8b 40 28             	mov    0x28(%eax),%eax
   119a9:	85 c0                	test   %eax,%eax
   119ab:	74 1c                	je     119c9 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   119ad:	8b 45 18             	mov    0x18(%ebp),%eax
   119b0:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   119b2:	83 f8 03             	cmp    $0x3,%eax
   119b5:	74 0b                	je     119c2 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   119b7:	8b 45 18             	mov    0x18(%ebp),%eax
   119ba:	8b 40 04             	mov    0x4(%eax),%eax
   119bd:	83 f8 07             	cmp    $0x7,%eax
   119c0:	77 07                	ja     119c9 <filter+0x77>
   119c2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   119c9:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   119cd:	75 0a                	jne    119d9 <filter+0x87>
   119cf:	b8 1f 00 00 00       	mov    $0x1f,%eax
   119d4:	e9 5b 07 00 00       	jmp    12134 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   119d9:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   119dd:	77 7b                	ja     11a5a <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   119df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119e2:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   119e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   119ec:	eb 5f                	jmp    11a4d <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   119ee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   119f1:	83 c0 01             	add    $0x1,%eax
   119f4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   119f8:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   119fb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   119fe:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a02:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11a05:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11a08:	8b 45 08             	mov    0x8(%ebp),%eax
   11a0b:	01 c2                	add    %eax,%edx
   11a0d:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11a11:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11a13:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11a17:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11a1a:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a1d:	01 d1                	add    %edx,%ecx
   11a1f:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11a22:	8d 5a 01             	lea    0x1(%edx),%ebx
   11a25:	8b 55 08             	mov    0x8(%ebp),%edx
   11a28:	01 da                	add    %ebx,%edx
   11a2a:	50                   	push   %eax
   11a2b:	ff 75 b0             	pushl  -0x50(%ebp)
   11a2e:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a31:	ff 75 f4             	pushl  -0xc(%ebp)
   11a34:	51                   	push   %ecx
   11a35:	52                   	push   %edx
   11a36:	e8 0d fb ff ff       	call   11548 <filterScanline>
   11a3b:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11a3e:	8b 55 98             	mov    -0x68(%ebp),%edx
   11a41:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a44:	01 d0                	add    %edx,%eax
   11a46:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11a49:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11a4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a50:	3b 45 14             	cmp    0x14(%ebp),%eax
   11a53:	75 99                	jne    119ee <filter+0x9c>
   11a55:	e9 d7 06 00 00       	jmp    12131 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11a5a:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11a5e:	0f 85 e3 01 00 00    	jne    11c47 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11a64:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11a6b:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11a6f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11a73:	eb 2d                	jmp    11aa2 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11a75:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11a79:	83 ec 0c             	sub    $0xc,%esp
   11a7c:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a7f:	e8 2e 19 ff ff       	call   33b2 <lodepng_malloc>
   11a84:	83 c4 10             	add    $0x10,%esp
   11a87:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11a8b:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a8f:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a93:	85 c0                	test   %eax,%eax
   11a95:	75 07                	jne    11a9e <filter+0x14c>
   11a97:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11a9e:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11aa2:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11aa6:	75 cd                	jne    11a75 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11aa8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11aac:	0f 85 6c 01 00 00    	jne    11c1e <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11ab2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ab9:	e9 54 01 00 00       	jmp    11c12 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11abe:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11ac2:	e9 d5 00 00 00       	jmp    11b9c <filter+0x24a>
          size_t sum = 0;
   11ac7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11ace:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11ad2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ad5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ad9:	89 c1                	mov    %eax,%ecx
   11adb:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ade:	01 c1                	add    %eax,%ecx
   11ae0:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11ae4:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11ae8:	83 ec 08             	sub    $0x8,%esp
   11aeb:	52                   	push   %edx
   11aec:	ff 75 b0             	pushl  -0x50(%ebp)
   11aef:	ff 75 b4             	pushl  -0x4c(%ebp)
   11af2:	ff 75 f4             	pushl  -0xc(%ebp)
   11af5:	51                   	push   %ecx
   11af6:	50                   	push   %eax
   11af7:	e8 4c fa ff ff       	call   11548 <filterScanline>
   11afc:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11aff:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11b03:	75 2d                	jne    11b32 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11b05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b0c:	eb 1a                	jmp    11b28 <filter+0x1d6>
   11b0e:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b12:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11b16:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b19:	01 d0                	add    %edx,%eax
   11b1b:	0f b6 00             	movzbl (%eax),%eax
   11b1e:	0f b6 c0             	movzbl %al,%eax
   11b21:	01 45 d8             	add    %eax,-0x28(%ebp)
   11b24:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b28:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b2b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b2e:	75 de                	jne    11b0e <filter+0x1bc>
   11b30:	eb 4b                	jmp    11b7d <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11b32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b39:	eb 3a                	jmp    11b75 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11b3b:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b3f:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b46:	01 d0                	add    %edx,%eax
   11b48:	0f b6 00             	movzbl (%eax),%eax
   11b4b:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11b4e:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11b52:	84 c0                	test   %al,%al
   11b54:	78 06                	js     11b5c <filter+0x20a>
   11b56:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11b5a:	eb 0d                	jmp    11b69 <filter+0x217>
   11b5c:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11b60:	ba ff 00 00 00       	mov    $0xff,%edx
   11b65:	29 c2                	sub    %eax,%edx
   11b67:	89 d0                	mov    %edx,%eax
   11b69:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11b6c:	01 d0                	add    %edx,%eax
   11b6e:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11b71:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b75:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b78:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b7b:	75 be                	jne    11b3b <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11b7d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11b81:	74 08                	je     11b8b <filter+0x239>
   11b83:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b86:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11b89:	7d 0d                	jge    11b98 <filter+0x246>
            bestType = type;
   11b8b:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b8f:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11b92:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b95:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11b98:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11b9c:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11ba0:	0f 85 21 ff ff ff    	jne    11ac7 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11ba6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ba9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11bad:	89 c2                	mov    %eax,%edx
   11baf:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bb2:	01 d0                	add    %edx,%eax
   11bb4:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11bb7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11bba:	83 c0 01             	add    $0x1,%eax
   11bbd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11bc1:	89 c2                	mov    %eax,%edx
   11bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   11bc6:	01 c2                	add    %eax,%edx
   11bc8:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11bcc:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11bce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11bd5:	eb 2f                	jmp    11c06 <filter+0x2b4>
   11bd7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11bda:	83 c0 01             	add    $0x1,%eax
   11bdd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11be1:	89 c2                	mov    %eax,%edx
   11be3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11be6:	01 d0                	add    %edx,%eax
   11be8:	8d 50 01             	lea    0x1(%eax),%edx
   11beb:	8b 45 08             	mov    0x8(%ebp),%eax
   11bee:	01 c2                	add    %eax,%edx
   11bf0:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11bf4:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11bf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bfb:	01 c8                	add    %ecx,%eax
   11bfd:	0f b6 00             	movzbl (%eax),%eax
   11c00:	88 02                	mov    %al,(%edx)
   11c02:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11c06:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c09:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11c0c:	75 c9                	jne    11bd7 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11c0e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11c12:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c15:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c18:	0f 85 a0 fe ff ff    	jne    11abe <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11c1e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11c22:	eb 18                	jmp    11c3c <filter+0x2ea>
   11c24:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11c28:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11c2c:	83 ec 0c             	sub    $0xc,%esp
   11c2f:	50                   	push   %eax
   11c30:	e8 9e 17 ff ff       	call   33d3 <lodepng_free>
   11c35:	83 c4 10             	add    $0x10,%esp
   11c38:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11c3c:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11c40:	75 e2                	jne    11c24 <filter+0x2d2>
   11c42:	e9 ea 04 00 00       	jmp    12131 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11c47:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11c4b:	0f 85 17 02 00 00    	jne    11e68 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11c51:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11c58:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11c5f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11c66:	eb 33                	jmp    11c9b <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11c68:	83 ec 0c             	sub    $0xc,%esp
   11c6b:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c6e:	e8 3f 17 ff ff       	call   33b2 <lodepng_malloc>
   11c73:	83 c4 10             	add    $0x10,%esp
   11c76:	89 c2                	mov    %eax,%edx
   11c78:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c7b:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11c82:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c85:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c8c:	85 c0                	test   %eax,%eax
   11c8e:	75 07                	jne    11c97 <filter+0x345>
   11c90:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11c97:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11c9b:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11c9f:	75 c7                	jne    11c68 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11ca1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11ca5:	0f 85 8f 01 00 00    	jne    11e3a <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11cab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11cb2:	e9 77 01 00 00       	jmp    11e2e <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11cb7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11cbe:	e9 f4 00 00 00       	jmp    11db7 <filter+0x465>
          size_t sum = 0;
   11cc3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11cca:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11ccd:	0f b6 d0             	movzbl %al,%edx
   11cd0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11cd3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11cd7:	89 c1                	mov    %eax,%ecx
   11cd9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cdc:	01 c1                	add    %eax,%ecx
   11cde:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11ce1:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11ce8:	83 ec 08             	sub    $0x8,%esp
   11ceb:	52                   	push   %edx
   11cec:	ff 75 b0             	pushl  -0x50(%ebp)
   11cef:	ff 75 b4             	pushl  -0x4c(%ebp)
   11cf2:	ff 75 f4             	pushl  -0xc(%ebp)
   11cf5:	51                   	push   %ecx
   11cf6:	50                   	push   %eax
   11cf7:	e8 4c f8 ff ff       	call   11548 <filterScanline>
   11cfc:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11cff:	83 ec 04             	sub    $0x4,%esp
   11d02:	68 00 04 00 00       	push   $0x400
   11d07:	6a 00                	push   $0x0
   11d09:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11d0f:	50                   	push   %eax
   11d10:	e8 0e 17 ff ff       	call   3423 <lodepng_memset>
   11d15:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d1f:	eb 2a                	jmp    11d4b <filter+0x3f9>
   11d21:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d24:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11d2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d2e:	01 d0                	add    %edx,%eax
   11d30:	0f b6 00             	movzbl (%eax),%eax
   11d33:	0f b6 c0             	movzbl %al,%eax
   11d36:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11d3d:	83 c2 01             	add    $0x1,%edx
   11d40:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11d47:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d4b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d4e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d51:	75 ce                	jne    11d21 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11d53:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d56:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11d5d:	8d 50 01             	lea    0x1(%eax),%edx
   11d60:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d63:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11d6a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d71:	eb 1d                	jmp    11d90 <filter+0x43e>
            sum += ilog2i(count[x]);
   11d73:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d76:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11d7d:	83 ec 0c             	sub    $0xc,%esp
   11d80:	50                   	push   %eax
   11d81:	e8 80 fb ff ff       	call   11906 <ilog2i>
   11d86:	83 c4 10             	add    $0x10,%esp
   11d89:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11d8c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d90:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11d97:	75 da                	jne    11d73 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11d99:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11d9d:	74 08                	je     11da7 <filter+0x455>
   11d9f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11da2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11da5:	7e 0c                	jle    11db3 <filter+0x461>
            bestType = type;
   11da7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11daa:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11dad:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11db0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11db3:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11db7:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11dbb:	0f 85 02 ff ff ff    	jne    11cc3 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11dc1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dc4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11dc8:	89 c2                	mov    %eax,%edx
   11dca:	8b 45 0c             	mov    0xc(%ebp),%eax
   11dcd:	01 d0                	add    %edx,%eax
   11dcf:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11dd2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dd5:	83 c0 01             	add    $0x1,%eax
   11dd8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ddc:	89 c2                	mov    %eax,%edx
   11dde:	8b 45 08             	mov    0x8(%ebp),%eax
   11de1:	01 d0                	add    %edx,%eax
   11de3:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11de6:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11de8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11def:	eb 31                	jmp    11e22 <filter+0x4d0>
   11df1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11df4:	83 c0 01             	add    $0x1,%eax
   11df7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11dfb:	89 c2                	mov    %eax,%edx
   11dfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e00:	01 d0                	add    %edx,%eax
   11e02:	8d 50 01             	lea    0x1(%eax),%edx
   11e05:	8b 45 08             	mov    0x8(%ebp),%eax
   11e08:	01 c2                	add    %eax,%edx
   11e0a:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11e0d:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11e14:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e17:	01 c8                	add    %ecx,%eax
   11e19:	0f b6 00             	movzbl (%eax),%eax
   11e1c:	88 02                	mov    %al,(%edx)
   11e1e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e22:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e25:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e28:	75 c7                	jne    11df1 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11e2a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e31:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e34:	0f 85 7d fe ff ff    	jne    11cb7 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11e3a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11e41:	eb 1a                	jmp    11e5d <filter+0x50b>
   11e43:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11e46:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11e4d:	83 ec 0c             	sub    $0xc,%esp
   11e50:	50                   	push   %eax
   11e51:	e8 7d 15 ff ff       	call   33d3 <lodepng_free>
   11e56:	83 c4 10             	add    $0x10,%esp
   11e59:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11e5d:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11e61:	75 e0                	jne    11e43 <filter+0x4f1>
   11e63:	e9 c9 02 00 00       	jmp    12131 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11e68:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11e6c:	0f 85 89 00 00 00    	jne    11efb <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11e72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11e79:	eb 73                	jmp    11eee <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11e7b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e7e:	83 c0 01             	add    $0x1,%eax
   11e81:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e85:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11e88:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e8b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e8f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11e92:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e95:	8b 50 30             	mov    0x30(%eax),%edx
   11e98:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e9b:	01 d0                	add    %edx,%eax
   11e9d:	0f b6 00             	movzbl (%eax),%eax
   11ea0:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11ea3:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11ea6:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea9:	01 c2                	add    %eax,%edx
   11eab:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11eaf:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11eb1:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11eb5:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11eb8:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ebb:	01 d1                	add    %edx,%ecx
   11ebd:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11ec0:	8d 5a 01             	lea    0x1(%edx),%ebx
   11ec3:	8b 55 08             	mov    0x8(%ebp),%edx
   11ec6:	01 da                	add    %ebx,%edx
   11ec8:	83 ec 08             	sub    $0x8,%esp
   11ecb:	50                   	push   %eax
   11ecc:	ff 75 b0             	pushl  -0x50(%ebp)
   11ecf:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ed2:	ff 75 f4             	pushl  -0xc(%ebp)
   11ed5:	51                   	push   %ecx
   11ed6:	52                   	push   %edx
   11ed7:	e8 6c f6 ff ff       	call   11548 <filterScanline>
   11edc:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11edf:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11ee2:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ee5:	01 d0                	add    %edx,%eax
   11ee7:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11eea:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11eee:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11ef1:	3b 45 14             	cmp    0x14(%ebp),%eax
   11ef4:	75 85                	jne    11e7b <filter+0x529>
   11ef6:	e9 36 02 00 00       	jmp    12131 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11efb:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11eff:	0f 85 25 02 00 00    	jne    1212a <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11f05:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11f0c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f13:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11f1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11f1d:	83 ec 04             	sub    $0x4,%esp
   11f20:	6a 24                	push   $0x24
   11f22:	50                   	push   %eax
   11f23:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11f29:	50                   	push   %eax
   11f2a:	e8 c1 14 ff ff       	call   33f0 <lodepng_memcpy>
   11f2f:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11f32:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11f39:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11f3c:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11f43:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11f46:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11f4d:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11f50:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f57:	eb 33                	jmp    11f8c <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11f59:	83 ec 0c             	sub    $0xc,%esp
   11f5c:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f5f:	e8 4e 14 ff ff       	call   33b2 <lodepng_malloc>
   11f64:	83 c4 10             	add    $0x10,%esp
   11f67:	89 c2                	mov    %eax,%edx
   11f69:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f6c:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11f73:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f76:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f7d:	85 c0                	test   %eax,%eax
   11f7f:	75 07                	jne    11f88 <filter+0x636>
   11f81:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11f88:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11f8c:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11f90:	75 c7                	jne    11f59 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11f92:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11f96:	0f 85 63 01 00 00    	jne    120ff <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11f9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11fa3:	e9 4b 01 00 00       	jmp    120f3 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11fa8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11faf:	e9 c8 00 00 00       	jmp    1207c <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   11fb4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fb7:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11fba:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fbd:	0f b6 d0             	movzbl %al,%edx
   11fc0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fc3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11fc7:	89 c1                	mov    %eax,%ecx
   11fc9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fcc:	01 c1                	add    %eax,%ecx
   11fce:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fd1:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11fd8:	83 ec 08             	sub    $0x8,%esp
   11fdb:	52                   	push   %edx
   11fdc:	ff 75 b0             	pushl  -0x50(%ebp)
   11fdf:	ff 75 b4             	pushl  -0x4c(%ebp)
   11fe2:	ff 75 f4             	pushl  -0xc(%ebp)
   11fe5:	51                   	push   %ecx
   11fe6:	50                   	push   %eax
   11fe7:	e8 5c f5 ff ff       	call   11548 <filterScanline>
   11fec:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   11fef:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ff2:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   11ff9:	00 00 00 00 
          dummy = 0;
   11ffd:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   12004:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   12007:	8b 55 ac             	mov    -0x54(%ebp),%edx
   1200a:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1200d:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12014:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   1201a:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   1201d:	c1 e3 02             	shl    $0x2,%ebx
   12020:	01 cb                	add    %ecx,%ebx
   12022:	83 ec 0c             	sub    $0xc,%esp
   12025:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   1202b:	51                   	push   %ecx
   1202c:	52                   	push   %edx
   1202d:	50                   	push   %eax
   1202e:	53                   	push   %ebx
   1202f:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   12035:	50                   	push   %eax
   12036:	e8 87 60 ff ff       	call   80c2 <zlib_compress>
   1203b:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   1203e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12044:	83 ec 0c             	sub    $0xc,%esp
   12047:	50                   	push   %eax
   12048:	e8 86 13 ff ff       	call   33d3 <lodepng_free>
   1204d:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   12050:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   12054:	74 0f                	je     12065 <filter+0x713>
   12056:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12059:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12060:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   12063:	7d 13                	jge    12078 <filter+0x726>
            bestType = type;
   12065:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12068:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   1206b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1206e:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12075:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   12078:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   1207c:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12080:	0f 85 2e ff ff ff    	jne    11fb4 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   12086:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12089:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1208d:	89 c2                	mov    %eax,%edx
   1208f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12092:	01 d0                	add    %edx,%eax
   12094:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12097:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1209a:	83 c0 01             	add    $0x1,%eax
   1209d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120a1:	89 c2                	mov    %eax,%edx
   120a3:	8b 45 08             	mov    0x8(%ebp),%eax
   120a6:	01 d0                	add    %edx,%eax
   120a8:	8b 55 bc             	mov    -0x44(%ebp),%edx
   120ab:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   120ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   120b4:	eb 31                	jmp    120e7 <filter+0x795>
   120b6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120b9:	83 c0 01             	add    $0x1,%eax
   120bc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120c0:	89 c2                	mov    %eax,%edx
   120c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120c5:	01 d0                	add    %edx,%eax
   120c7:	8d 50 01             	lea    0x1(%eax),%edx
   120ca:	8b 45 08             	mov    0x8(%ebp),%eax
   120cd:	01 c2                	add    %eax,%edx
   120cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
   120d2:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   120d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120dc:	01 c8                	add    %ecx,%eax
   120de:	0f b6 00             	movzbl (%eax),%eax
   120e1:	88 02                	mov    %al,(%edx)
   120e3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   120e7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120ea:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   120ed:	75 c7                	jne    120b6 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   120ef:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   120f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120f6:	3b 45 14             	cmp    0x14(%ebp),%eax
   120f9:	0f 85 a9 fe ff ff    	jne    11fa8 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   120ff:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12106:	eb 1a                	jmp    12122 <filter+0x7d0>
   12108:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1210b:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12112:	83 ec 0c             	sub    $0xc,%esp
   12115:	50                   	push   %eax
   12116:	e8 b8 12 ff ff       	call   33d3 <lodepng_free>
   1211b:	83 c4 10             	add    $0x10,%esp
   1211e:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12122:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12126:	75 e0                	jne    12108 <filter+0x7b6>
   12128:	eb 07                	jmp    12131 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1212a:	b8 58 00 00 00       	mov    $0x58,%eax
   1212f:	eb 03                	jmp    12134 <filter+0x7e2>

  return error;
   12131:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12134:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12137:	c9                   	leave  
   12138:	c3                   	ret    

00012139 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   12139:	55                   	push   %ebp
   1213a:	89 e5                	mov    %esp,%ebp
   1213c:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   1213f:	8b 45 10             	mov    0x10(%ebp),%eax
   12142:	2b 45 14             	sub    0x14(%ebp),%eax
   12145:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   12148:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1214f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   12156:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1215d:	eb 65                	jmp    121c4 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1215f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12166:	eb 2a                	jmp    12192 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   12168:	ff 75 0c             	pushl  0xc(%ebp)
   1216b:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1216e:	50                   	push   %eax
   1216f:	e8 9d 60 ff ff       	call   8211 <readBitFromReversedStream>
   12174:	83 c4 08             	add    $0x8,%esp
   12177:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   1217a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1217e:	50                   	push   %eax
   1217f:	ff 75 08             	pushl  0x8(%ebp)
   12182:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12185:	50                   	push   %eax
   12186:	e8 08 61 ff ff       	call   8293 <setBitOfReversedStream>
   1218b:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1218e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12192:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12195:	3b 45 14             	cmp    0x14(%ebp),%eax
   12198:	7c ce                	jl     12168 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   1219a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   121a1:	eb 15                	jmp    121b8 <addPaddingBits+0x7f>
   121a3:	6a 00                	push   $0x0
   121a5:	ff 75 08             	pushl  0x8(%ebp)
   121a8:	8d 45 ec             	lea    -0x14(%ebp),%eax
   121ab:	50                   	push   %eax
   121ac:	e8 e2 60 ff ff       	call   8293 <setBitOfReversedStream>
   121b1:	83 c4 0c             	add    $0xc,%esp
   121b4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   121b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   121bb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   121be:	75 e3                	jne    121a3 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   121c0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   121c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121c7:	3b 45 18             	cmp    0x18(%ebp),%eax
   121ca:	75 93                	jne    1215f <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   121cc:	90                   	nop
   121cd:	c9                   	leave  
   121ce:	c3                   	ret    

000121cf <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   121cf:	55                   	push   %ebp
   121d0:	89 e5                	mov    %esp,%ebp
   121d2:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   121d8:	ff 75 18             	pushl  0x18(%ebp)
   121db:	ff 75 14             	pushl  0x14(%ebp)
   121de:	ff 75 10             	pushl  0x10(%ebp)
   121e1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   121e7:	50                   	push   %eax
   121e8:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   121ee:	50                   	push   %eax
   121ef:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   121f5:	50                   	push   %eax
   121f6:	8d 45 94             	lea    -0x6c(%ebp),%eax
   121f9:	50                   	push   %eax
   121fa:	8d 45 b0             	lea    -0x50(%ebp),%eax
   121fd:	50                   	push   %eax
   121fe:	e8 fc ae ff ff       	call   d0ff <Adam7_getpassvalues>
   12203:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12206:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1220a:	0f 86 0a 01 00 00    	jbe    1231a <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12210:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12217:	e9 ef 00 00 00       	jmp    1230b <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1221c:	8b 45 18             	mov    0x18(%ebp),%eax
   1221f:	c1 e8 03             	shr    $0x3,%eax
   12222:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12225:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1222c:	e9 c6 00 00 00       	jmp    122f7 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12231:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12238:	e9 a6 00 00 00       	jmp    122e3 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   1223d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12240:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
   12247:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1224a:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
   12251:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12255:	01 d0                	add    %edx,%eax
   12257:	0f af 45 10          	imul   0x10(%ebp),%eax
   1225b:	89 c2                	mov    %eax,%edx
   1225d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12260:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
   12267:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   1226b:	01 c2                	add    %eax,%edx
   1226d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12270:	8b 04 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%eax
   12277:	01 c2                	add    %eax,%edx
   12279:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1227c:	0f af c2             	imul   %edx,%eax
   1227f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   12282:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12285:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   1228c:	89 c1                	mov    %eax,%ecx
   1228e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12291:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12295:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12299:	89 c2                	mov    %eax,%edx
   1229b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1229e:	01 c2                	add    %eax,%edx
   122a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   122a3:	0f af c2             	imul   %edx,%eax
   122a6:	01 c8                	add    %ecx,%eax
   122a8:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   122ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   122b2:	eb 23                	jmp    122d7 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   122b4:	8b 55 d8             	mov    -0x28(%ebp),%edx
   122b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122ba:	01 c2                	add    %eax,%edx
   122bc:	8b 45 08             	mov    0x8(%ebp),%eax
   122bf:	01 c2                	add    %eax,%edx
   122c1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   122c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122c7:	01 c1                	add    %eax,%ecx
   122c9:	8b 45 0c             	mov    0xc(%ebp),%eax
   122cc:	01 c8                	add    %ecx,%eax
   122ce:	0f b6 00             	movzbl (%eax),%eax
   122d1:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   122d3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   122d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   122da:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   122dd:	72 d5                	jb     122b4 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   122df:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   122e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122e6:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   122ea:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   122ed:	0f 87 4a ff ff ff    	ja     1223d <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   122f3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   122f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122fa:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   122fe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12301:	0f 87 2a ff ff ff    	ja     12231 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12307:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1230b:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1230f:	0f 85 07 ff ff ff    	jne    1221c <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12315:	e9 22 01 00 00       	jmp    1243c <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1231a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12321:	e9 0c 01 00 00       	jmp    12432 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12326:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12329:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1232d:	0f af 45 18          	imul   0x18(%ebp),%eax
   12331:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12334:	8b 45 18             	mov    0x18(%ebp),%eax
   12337:	0f af 45 10          	imul   0x10(%ebp),%eax
   1233b:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1233e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12345:	e9 d4 00 00 00       	jmp    1241e <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   1234a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12351:	e9 b4 00 00 00       	jmp    1240a <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   12356:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12359:	8b 14 85 d8 a0 01 00 	mov    0x1a0d8(,%eax,4),%edx
   12360:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12363:	8b 04 85 10 a1 01 00 	mov    0x1a110(,%eax,4),%eax
   1236a:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   1236e:	01 d0                	add    %edx,%eax
   12370:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   12374:	89 c2                	mov    %eax,%edx
   12376:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12379:	8b 0c 85 bc a0 01 00 	mov    0x1a0bc(,%eax,4),%ecx
   12380:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12383:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
   1238a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1238e:	01 c8                	add    %ecx,%eax
   12390:	0f af 45 18          	imul   0x18(%ebp),%eax
   12394:	01 d0                	add    %edx,%eax
   12396:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   1239c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1239f:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   123a6:	c1 e0 03             	shl    $0x3,%eax
   123a9:	89 c1                	mov    %eax,%ecx
   123ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123ae:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   123b2:	89 c2                	mov    %eax,%edx
   123b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   123b7:	0f af 45 18          	imul   0x18(%ebp),%eax
   123bb:	01 d0                	add    %edx,%eax
   123bd:	01 c8                	add    %ecx,%eax
   123bf:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   123c5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   123cc:	eb 30                	jmp    123fe <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   123ce:	ff 75 0c             	pushl  0xc(%ebp)
   123d1:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   123d7:	50                   	push   %eax
   123d8:	e8 34 5e ff ff       	call   8211 <readBitFromReversedStream>
   123dd:	83 c4 08             	add    $0x8,%esp
   123e0:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   123e3:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   123e7:	50                   	push   %eax
   123e8:	ff 75 08             	pushl  0x8(%ebp)
   123eb:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   123f1:	50                   	push   %eax
   123f2:	e8 9c 5e ff ff       	call   8293 <setBitOfReversedStream>
   123f7:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   123fa:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   123fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12401:	3b 45 18             	cmp    0x18(%ebp),%eax
   12404:	72 c8                	jb     123ce <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12406:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1240a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1240d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12411:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12414:	0f 87 3c ff ff ff    	ja     12356 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1241a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1241e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12421:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12425:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   12428:	0f 87 1c ff ff ff    	ja     1234a <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1242e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12432:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12436:	0f 85 ea fe ff ff    	jne    12326 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1243c:	90                   	nop
   1243d:	c9                   	leave  
   1243e:	c3                   	ret    

0001243f <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   1243f:	55                   	push   %ebp
   12440:	89 e5                	mov    %esp,%ebp
   12442:	57                   	push   %edi
   12443:	56                   	push   %esi
   12444:	53                   	push   %ebx
   12445:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   1244b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1244e:	83 c0 0c             	add    $0xc,%eax
   12451:	50                   	push   %eax
   12452:	e8 77 6a ff ff       	call   8ece <lodepng_get_bpp>
   12457:	83 c4 04             	add    $0x4,%esp
   1245a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   1245d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   12464:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12467:	8b 40 08             	mov    0x8(%eax),%eax
   1246a:	85 c0                	test   %eax,%eax
   1246c:	0f 85 49 01 00 00    	jne    125bb <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   12472:	8b 45 14             	mov    0x14(%ebp),%eax
   12475:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12479:	83 c0 07             	add    $0x7,%eax
   1247c:	c1 e8 03             	shr    $0x3,%eax
   1247f:	83 c0 01             	add    $0x1,%eax
   12482:	0f af 45 18          	imul   0x18(%ebp),%eax
   12486:	89 c2                	mov    %eax,%edx
   12488:	8b 45 0c             	mov    0xc(%ebp),%eax
   1248b:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   1248d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12490:	8b 00                	mov    (%eax),%eax
   12492:	83 ec 0c             	sub    $0xc,%esp
   12495:	50                   	push   %eax
   12496:	e8 17 0f ff ff       	call   33b2 <lodepng_malloc>
   1249b:	83 c4 10             	add    $0x10,%esp
   1249e:	89 c2                	mov    %eax,%edx
   124a0:	8b 45 08             	mov    0x8(%ebp),%eax
   124a3:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   124a5:	8b 45 08             	mov    0x8(%ebp),%eax
   124a8:	8b 00                	mov    (%eax),%eax
   124aa:	85 c0                	test   %eax,%eax
   124ac:	75 10                	jne    124be <preProcessScanlines+0x7f>
   124ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   124b1:	8b 00                	mov    (%eax),%eax
   124b3:	85 c0                	test   %eax,%eax
   124b5:	74 07                	je     124be <preProcessScanlines+0x7f>
   124b7:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   124be:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   124c2:	0f 85 fb 02 00 00    	jne    127c3 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   124c8:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   124cc:	0f 87 bd 00 00 00    	ja     1258f <preProcessScanlines+0x150>
   124d2:	8b 45 14             	mov    0x14(%ebp),%eax
   124d5:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124d9:	89 c2                	mov    %eax,%edx
   124db:	8b 45 14             	mov    0x14(%ebp),%eax
   124de:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124e2:	83 c0 07             	add    $0x7,%eax
   124e5:	c1 e8 03             	shr    $0x3,%eax
   124e8:	c1 e0 03             	shl    $0x3,%eax
   124eb:	39 c2                	cmp    %eax,%edx
   124ed:	0f 84 9c 00 00 00    	je     1258f <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   124f3:	8b 45 14             	mov    0x14(%ebp),%eax
   124f6:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124fa:	83 c0 07             	add    $0x7,%eax
   124fd:	c1 e8 03             	shr    $0x3,%eax
   12500:	0f af 45 18          	imul   0x18(%ebp),%eax
   12504:	83 ec 0c             	sub    $0xc,%esp
   12507:	50                   	push   %eax
   12508:	e8 a5 0e ff ff       	call   33b2 <lodepng_malloc>
   1250d:	83 c4 10             	add    $0x10,%esp
   12510:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12513:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12517:	75 07                	jne    12520 <preProcessScanlines+0xe1>
   12519:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12520:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12524:	75 56                	jne    1257c <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12526:	8b 45 14             	mov    0x14(%ebp),%eax
   12529:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1252d:	89 c2                	mov    %eax,%edx
   1252f:	8b 45 14             	mov    0x14(%ebp),%eax
   12532:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12536:	83 c0 07             	add    $0x7,%eax
   12539:	c1 e8 03             	shr    $0x3,%eax
   1253c:	c1 e0 03             	shl    $0x3,%eax
   1253f:	83 ec 0c             	sub    $0xc,%esp
   12542:	ff 75 18             	pushl  0x18(%ebp)
   12545:	52                   	push   %edx
   12546:	50                   	push   %eax
   12547:	ff 75 10             	pushl  0x10(%ebp)
   1254a:	ff 75 d8             	pushl  -0x28(%ebp)
   1254d:	e8 e7 fb ff ff       	call   12139 <addPaddingBits>
   12552:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   12555:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12558:	8d 50 0c             	lea    0xc(%eax),%edx
   1255b:	8b 45 08             	mov    0x8(%ebp),%eax
   1255e:	8b 00                	mov    (%eax),%eax
   12560:	83 ec 08             	sub    $0x8,%esp
   12563:	ff 75 20             	pushl  0x20(%ebp)
   12566:	52                   	push   %edx
   12567:	ff 75 18             	pushl  0x18(%ebp)
   1256a:	ff 75 14             	pushl  0x14(%ebp)
   1256d:	ff 75 d8             	pushl  -0x28(%ebp)
   12570:	50                   	push   %eax
   12571:	e8 dc f3 ff ff       	call   11952 <filter>
   12576:	83 c4 20             	add    $0x20,%esp
   12579:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   1257c:	83 ec 0c             	sub    $0xc,%esp
   1257f:	ff 75 d8             	pushl  -0x28(%ebp)
   12582:	e8 4c 0e ff ff       	call   33d3 <lodepng_free>
   12587:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   1258a:	e9 34 02 00 00       	jmp    127c3 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   1258f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12592:	8d 50 0c             	lea    0xc(%eax),%edx
   12595:	8b 45 08             	mov    0x8(%ebp),%eax
   12598:	8b 00                	mov    (%eax),%eax
   1259a:	83 ec 08             	sub    $0x8,%esp
   1259d:	ff 75 20             	pushl  0x20(%ebp)
   125a0:	52                   	push   %edx
   125a1:	ff 75 18             	pushl  0x18(%ebp)
   125a4:	ff 75 14             	pushl  0x14(%ebp)
   125a7:	ff 75 10             	pushl  0x10(%ebp)
   125aa:	50                   	push   %eax
   125ab:	e8 a2 f3 ff ff       	call   11952 <filter>
   125b0:	83 c4 20             	add    $0x20,%esp
   125b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   125b6:	e9 08 02 00 00       	jmp    127c3 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   125bb:	ff 75 dc             	pushl  -0x24(%ebp)
   125be:	ff 75 18             	pushl  0x18(%ebp)
   125c1:	ff 75 14             	pushl  0x14(%ebp)
   125c4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   125ca:	50                   	push   %eax
   125cb:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   125d1:	50                   	push   %eax
   125d2:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   125d8:	50                   	push   %eax
   125d9:	8d 45 98             	lea    -0x68(%ebp),%eax
   125dc:	50                   	push   %eax
   125dd:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   125e0:	50                   	push   %eax
   125e1:	e8 19 ab ff ff       	call   d0ff <Adam7_getpassvalues>
   125e6:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   125e9:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   125ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   125f2:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   125f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   125f7:	8b 00                	mov    (%eax),%eax
   125f9:	83 ec 0c             	sub    $0xc,%esp
   125fc:	50                   	push   %eax
   125fd:	e8 b0 0d ff ff       	call   33b2 <lodepng_malloc>
   12602:	83 c4 10             	add    $0x10,%esp
   12605:	89 c2                	mov    %eax,%edx
   12607:	8b 45 08             	mov    0x8(%ebp),%eax
   1260a:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   1260c:	8b 45 08             	mov    0x8(%ebp),%eax
   1260f:	8b 00                	mov    (%eax),%eax
   12611:	85 c0                	test   %eax,%eax
   12613:	75 07                	jne    1261c <preProcessScanlines+0x1dd>
   12615:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   1261c:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1261f:	83 ec 0c             	sub    $0xc,%esp
   12622:	50                   	push   %eax
   12623:	e8 8a 0d ff ff       	call   33b2 <lodepng_malloc>
   12628:	83 c4 10             	add    $0x10,%esp
   1262b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   1262e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12632:	75 0e                	jne    12642 <preProcessScanlines+0x203>
   12634:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12637:	85 c0                	test   %eax,%eax
   12639:	74 07                	je     12642 <preProcessScanlines+0x203>
   1263b:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12642:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12646:	0f 85 69 01 00 00    	jne    127b5 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   1264c:	83 ec 0c             	sub    $0xc,%esp
   1264f:	ff 75 dc             	pushl  -0x24(%ebp)
   12652:	ff 75 18             	pushl  0x18(%ebp)
   12655:	ff 75 14             	pushl  0x14(%ebp)
   12658:	ff 75 10             	pushl  0x10(%ebp)
   1265b:	ff 75 d4             	pushl  -0x2c(%ebp)
   1265e:	e8 6c fb ff ff       	call   121cf <Adam7_interlace>
   12663:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   12666:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   1266d:	e9 36 01 00 00       	jmp    127a8 <preProcessScanlines+0x369>
        if(bpp < 8) {
   12672:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12676:	0f 87 d6 00 00 00    	ja     12752 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   1267c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1267f:	83 c0 01             	add    $0x1,%eax
   12682:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   12689:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1268c:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   12693:	29 c2                	sub    %eax,%edx
   12695:	89 d0                	mov    %edx,%eax
   12697:	83 ec 0c             	sub    $0xc,%esp
   1269a:	50                   	push   %eax
   1269b:	e8 12 0d ff ff       	call   33b2 <lodepng_malloc>
   126a0:	83 c4 10             	add    $0x10,%esp
   126a3:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   126a6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   126aa:	75 0c                	jne    126b8 <preProcessScanlines+0x279>
   126ac:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   126b3:	e9 fd 00 00 00       	jmp    127b5 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   126b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126bb:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   126bf:	8b 55 e0             	mov    -0x20(%ebp),%edx
   126c2:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   126c6:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   126ca:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   126cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
   126cf:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   126d3:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   126d7:	83 c2 07             	add    $0x7,%edx
   126da:	c1 ea 03             	shr    $0x3,%edx
   126dd:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   126e0:	89 d1                	mov    %edx,%ecx
   126e2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   126e5:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   126ec:	89 d6                	mov    %edx,%esi
   126ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   126f1:	01 f2                	add    %esi,%edx
   126f3:	83 ec 0c             	sub    $0xc,%esp
   126f6:	50                   	push   %eax
   126f7:	53                   	push   %ebx
   126f8:	51                   	push   %ecx
   126f9:	52                   	push   %edx
   126fa:	ff 75 d0             	pushl  -0x30(%ebp)
   126fd:	e8 37 fa ff ff       	call   12139 <addPaddingBits>
   12702:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12705:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12708:	8d 58 0c             	lea    0xc(%eax),%ebx
   1270b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1270e:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12712:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12715:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12719:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1271c:	8b 31                	mov    (%ecx),%esi
   1271e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12721:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12728:	01 f1                	add    %esi,%ecx
   1272a:	83 ec 08             	sub    $0x8,%esp
   1272d:	ff 75 20             	pushl  0x20(%ebp)
   12730:	53                   	push   %ebx
   12731:	52                   	push   %edx
   12732:	50                   	push   %eax
   12733:	ff 75 d0             	pushl  -0x30(%ebp)
   12736:	51                   	push   %ecx
   12737:	e8 16 f2 ff ff       	call   11952 <filter>
   1273c:	83 c4 20             	add    $0x20,%esp
   1273f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12742:	83 ec 0c             	sub    $0xc,%esp
   12745:	ff 75 d0             	pushl  -0x30(%ebp)
   12748:	e8 86 0c ff ff       	call   33d3 <lodepng_free>
   1274d:	83 c4 10             	add    $0x10,%esp
   12750:	eb 4c                	jmp    1279e <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   12752:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12755:	8d 70 0c             	lea    0xc(%eax),%esi
   12758:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1275b:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   1275f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12762:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12766:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12769:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   12770:	89 cb                	mov    %ecx,%ebx
   12772:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   12775:	01 cb                	add    %ecx,%ebx
   12777:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1277a:	8b 39                	mov    (%ecx),%edi
   1277c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1277f:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12786:	01 f9                	add    %edi,%ecx
   12788:	83 ec 08             	sub    $0x8,%esp
   1278b:	ff 75 20             	pushl  0x20(%ebp)
   1278e:	56                   	push   %esi
   1278f:	52                   	push   %edx
   12790:	50                   	push   %eax
   12791:	53                   	push   %ebx
   12792:	51                   	push   %ecx
   12793:	e8 ba f1 ff ff       	call   11952 <filter>
   12798:	83 c4 20             	add    $0x20,%esp
   1279b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   1279e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   127a2:	75 10                	jne    127b4 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   127a4:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   127a8:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   127ac:	0f 85 c0 fe ff ff    	jne    12672 <preProcessScanlines+0x233>
   127b2:	eb 01                	jmp    127b5 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   127b4:	90                   	nop
      }
    }

    lodepng_free(adam7);
   127b5:	83 ec 0c             	sub    $0xc,%esp
   127b8:	ff 75 d4             	pushl  -0x2c(%ebp)
   127bb:	e8 13 0c ff ff       	call   33d3 <lodepng_free>
   127c0:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   127c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   127c6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   127c9:	5b                   	pop    %ebx
   127ca:	5e                   	pop    %esi
   127cb:	5f                   	pop    %edi
   127cc:	5d                   	pop    %ebp
   127cd:	c3                   	ret    

000127ce <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   127ce:	55                   	push   %ebp
   127cf:	89 e5                	mov    %esp,%ebp
   127d1:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   127d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   127d7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   127da:	eb 47                	jmp    12823 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   127dc:	8b 45 08             	mov    0x8(%ebp),%eax
   127df:	8d 50 04             	lea    0x4(%eax),%edx
   127e2:	8b 45 08             	mov    0x8(%ebp),%eax
   127e5:	ff 75 fc             	pushl  -0x4(%ebp)
   127e8:	52                   	push   %edx
   127e9:	50                   	push   %eax
   127ea:	e8 73 5f ff ff       	call   8762 <lodepng_chunk_append>
   127ef:	83 c4 0c             	add    $0xc,%esp
   127f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
   127f5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   127f9:	74 05                	je     12800 <addUnknownChunks+0x32>
   127fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   127fe:	eb 37                	jmp    12837 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12800:	8b 45 08             	mov    0x8(%ebp),%eax
   12803:	8b 50 04             	mov    0x4(%eax),%edx
   12806:	8b 45 08             	mov    0x8(%ebp),%eax
   12809:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   1280c:	8b 55 10             	mov    0x10(%ebp),%edx
   1280f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12812:	01 d0                	add    %edx,%eax
   12814:	50                   	push   %eax
   12815:	ff 75 fc             	pushl  -0x4(%ebp)
   12818:	e8 ff 5c ff ff       	call   851c <lodepng_chunk_next>
   1281d:	83 c4 08             	add    $0x8,%esp
   12820:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12823:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12826:	8b 45 0c             	mov    0xc(%ebp),%eax
   12829:	29 c2                	sub    %eax,%edx
   1282b:	89 d0                	mov    %edx,%eax
   1282d:	3b 45 10             	cmp    0x10(%ebp),%eax
   12830:	7c aa                	jl     127dc <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12832:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12837:	c9                   	leave  
   12838:	c3                   	ret    

00012839 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12839:	55                   	push   %ebp
   1283a:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   1283c:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12840:	77 07                	ja     12849 <isGrayICCProfile+0x10>
   12842:	b8 00 00 00 00       	mov    $0x0,%eax
   12847:	eb 40                	jmp    12889 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12849:	8b 45 08             	mov    0x8(%ebp),%eax
   1284c:	83 c0 10             	add    $0x10,%eax
   1284f:	0f b6 00             	movzbl (%eax),%eax
   12852:	3c 47                	cmp    $0x47,%al
   12854:	75 2e                	jne    12884 <isGrayICCProfile+0x4b>
   12856:	8b 45 08             	mov    0x8(%ebp),%eax
   12859:	83 c0 11             	add    $0x11,%eax
   1285c:	0f b6 00             	movzbl (%eax),%eax
   1285f:	3c 52                	cmp    $0x52,%al
   12861:	75 21                	jne    12884 <isGrayICCProfile+0x4b>
   12863:	8b 45 08             	mov    0x8(%ebp),%eax
   12866:	83 c0 12             	add    $0x12,%eax
   12869:	0f b6 00             	movzbl (%eax),%eax
   1286c:	3c 41                	cmp    $0x41,%al
   1286e:	75 14                	jne    12884 <isGrayICCProfile+0x4b>
   12870:	8b 45 08             	mov    0x8(%ebp),%eax
   12873:	83 c0 13             	add    $0x13,%eax
   12876:	0f b6 00             	movzbl (%eax),%eax
   12879:	3c 59                	cmp    $0x59,%al
   1287b:	75 07                	jne    12884 <isGrayICCProfile+0x4b>
   1287d:	b8 01 00 00 00       	mov    $0x1,%eax
   12882:	eb 05                	jmp    12889 <isGrayICCProfile+0x50>
   12884:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12889:	5d                   	pop    %ebp
   1288a:	c3                   	ret    

0001288b <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   1288b:	55                   	push   %ebp
   1288c:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   1288e:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12892:	77 07                	ja     1289b <isRGBICCProfile+0x10>
   12894:	b8 00 00 00 00       	mov    $0x0,%eax
   12899:	eb 40                	jmp    128db <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   1289b:	8b 45 08             	mov    0x8(%ebp),%eax
   1289e:	83 c0 10             	add    $0x10,%eax
   128a1:	0f b6 00             	movzbl (%eax),%eax
   128a4:	3c 52                	cmp    $0x52,%al
   128a6:	75 2e                	jne    128d6 <isRGBICCProfile+0x4b>
   128a8:	8b 45 08             	mov    0x8(%ebp),%eax
   128ab:	83 c0 11             	add    $0x11,%eax
   128ae:	0f b6 00             	movzbl (%eax),%eax
   128b1:	3c 47                	cmp    $0x47,%al
   128b3:	75 21                	jne    128d6 <isRGBICCProfile+0x4b>
   128b5:	8b 45 08             	mov    0x8(%ebp),%eax
   128b8:	83 c0 12             	add    $0x12,%eax
   128bb:	0f b6 00             	movzbl (%eax),%eax
   128be:	3c 42                	cmp    $0x42,%al
   128c0:	75 14                	jne    128d6 <isRGBICCProfile+0x4b>
   128c2:	8b 45 08             	mov    0x8(%ebp),%eax
   128c5:	83 c0 13             	add    $0x13,%eax
   128c8:	0f b6 00             	movzbl (%eax),%eax
   128cb:	3c 20                	cmp    $0x20,%al
   128cd:	75 07                	jne    128d6 <isRGBICCProfile+0x4b>
   128cf:	b8 01 00 00 00       	mov    $0x1,%eax
   128d4:	eb 05                	jmp    128db <isRGBICCProfile+0x50>
   128d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   128db:	5d                   	pop    %ebp
   128dc:	c3                   	ret    

000128dd <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   128dd:	55                   	push   %ebp
   128de:	89 e5                	mov    %esp,%ebp
   128e0:	57                   	push   %edi
   128e1:	56                   	push   %esi
   128e2:	53                   	push   %ebx
   128e3:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   128e9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   128f0:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   128f7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   128fa:	6a 00                	push   $0x0
   128fc:	6a 00                	push   $0x0
   128fe:	50                   	push   %eax
   128ff:	e8 6f 0d ff ff       	call   3673 <ucvector_init>
   12904:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12907:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1290a:	05 98 00 00 00       	add    $0x98,%eax
   1290f:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12912:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12918:	50                   	push   %eax
   12919:	e8 3a 71 ff ff       	call   9a58 <lodepng_info_init>
   1291e:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12921:	8b 45 08             	mov    0x8(%ebp),%eax
   12924:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   1292a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1292d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12933:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12936:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   1293d:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   12940:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12943:	8b 40 0c             	mov    0xc(%eax),%eax
   12946:	83 f8 03             	cmp    $0x3,%eax
   12949:	74 0a                	je     12955 <lodepng_encode+0x78>
   1294b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1294e:	8b 40 6c             	mov    0x6c(%eax),%eax
   12951:	85 c0                	test   %eax,%eax
   12953:	74 29                	je     1297e <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12955:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12958:	8b 40 18             	mov    0x18(%eax),%eax
   1295b:	85 c0                	test   %eax,%eax
   1295d:	74 0d                	je     1296c <lodepng_encode+0x8f>
   1295f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12962:	8b 40 18             	mov    0x18(%eax),%eax
   12965:	3d 00 01 00 00       	cmp    $0x100,%eax
   1296a:	7e 12                	jle    1297e <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   1296c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1296f:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12976:	00 00 00 
    goto cleanup;
   12979:	e9 78 0c 00 00       	jmp    135f6 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   1297e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12981:	8b 40 38             	mov    0x38(%eax),%eax
   12984:	83 f8 02             	cmp    $0x2,%eax
   12987:	76 12                	jbe    1299b <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12989:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1298c:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12993:	00 00 00 
    goto cleanup;
   12996:	e9 5b 0c 00 00       	jmp    135f6 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   1299b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1299e:	8b 40 08             	mov    0x8(%eax),%eax
   129a1:	83 f8 01             	cmp    $0x1,%eax
   129a4:	76 12                	jbe    129b8 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   129a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129a9:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   129b0:	00 00 00 
    goto cleanup;
   129b3:	e9 3e 0c 00 00       	jmp    135f6 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   129b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129bb:	8b 50 10             	mov    0x10(%eax),%edx
   129be:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129c1:	8b 40 0c             	mov    0xc(%eax),%eax
   129c4:	52                   	push   %edx
   129c5:	50                   	push   %eax
   129c6:	e8 a4 5f ff ff       	call   896f <checkColorValidity>
   129cb:	83 c4 08             	add    $0x8,%esp
   129ce:	89 c2                	mov    %eax,%edx
   129d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129d3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   129d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129dc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   129e2:	85 c0                	test   %eax,%eax
   129e4:	0f 85 c6 0b 00 00    	jne    135b0 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   129ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129ed:	8b 50 7c             	mov    0x7c(%eax),%edx
   129f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129f3:	8b 40 78             	mov    0x78(%eax),%eax
   129f6:	52                   	push   %edx
   129f7:	50                   	push   %eax
   129f8:	e8 72 5f ff ff       	call   896f <checkColorValidity>
   129fd:	83 c4 08             	add    $0x8,%esp
   12a00:	89 c2                	mov    %eax,%edx
   12a02:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a05:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12a0b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a0e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a14:	85 c0                	test   %eax,%eax
   12a16:	0f 85 97 0b 00 00    	jne    135b3 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12a1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a1f:	05 98 00 00 00       	add    $0x98,%eax
   12a24:	83 ec 08             	sub    $0x8,%esp
   12a27:	50                   	push   %eax
   12a28:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12a2e:	50                   	push   %eax
   12a2f:	e8 58 71 ff ff       	call   9b8c <lodepng_info_copy>
   12a34:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12a37:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a3a:	8b 40 5c             	mov    0x5c(%eax),%eax
   12a3d:	85 c0                	test   %eax,%eax
   12a3f:	0f 84 3c 02 00 00    	je     12c81 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12a45:	83 ec 0c             	sub    $0xc,%esp
   12a48:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a4e:	50                   	push   %eax
   12a4f:	e8 5f 96 ff ff       	call   c0b3 <lodepng_color_stats_init>
   12a54:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12a57:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a5a:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12a60:	85 c0                	test   %eax,%eax
   12a62:	74 2d                	je     12a91 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12a64:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a67:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12a6d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a70:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12a76:	83 ec 08             	sub    $0x8,%esp
   12a79:	52                   	push   %edx
   12a7a:	50                   	push   %eax
   12a7b:	e8 b9 fd ff ff       	call   12839 <isGrayICCProfile>
   12a80:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12a83:	85 c0                	test   %eax,%eax
   12a85:	74 0a                	je     12a91 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12a87:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12a8e:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12a91:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a94:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12a9a:	85 c0                	test   %eax,%eax
   12a9c:	74 2d                	je     12acb <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12a9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12aa1:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12aa7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12aaa:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12ab0:	83 ec 08             	sub    $0x8,%esp
   12ab3:	52                   	push   %edx
   12ab4:	50                   	push   %eax
   12ab5:	e8 d1 fd ff ff       	call   1288b <isRGBICCProfile>
   12aba:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12abd:	85 c0                	test   %eax,%eax
   12abf:	74 0a                	je     12acb <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12ac1:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12ac8:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12acb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ace:	83 c0 78             	add    $0x78,%eax
   12ad1:	83 ec 0c             	sub    $0xc,%esp
   12ad4:	50                   	push   %eax
   12ad5:	ff 75 18             	pushl  0x18(%ebp)
   12ad8:	ff 75 14             	pushl  0x14(%ebp)
   12adb:	ff 75 10             	pushl  0x10(%ebp)
   12ade:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12ae4:	50                   	push   %eax
   12ae5:	e8 e0 96 ff ff       	call   c1ca <lodepng_compute_color_stats>
   12aea:	83 c4 20             	add    $0x20,%esp
   12aed:	89 c2                	mov    %eax,%edx
   12aef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12af2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12af8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12afb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b01:	85 c0                	test   %eax,%eax
   12b03:	0f 85 ad 0a 00 00    	jne    135b6 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12b09:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b0c:	8b 40 2c             	mov    0x2c(%eax),%eax
   12b0f:	85 c0                	test   %eax,%eax
   12b11:	0f 84 be 00 00 00    	je     12bd5 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12b17:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12b1e:	00 00 00 
   12b21:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12b28:	00 00 00 
   12b2b:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12b32:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12b35:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12b3b:	83 ec 04             	sub    $0x4,%esp
   12b3e:	6a 10                	push   $0x10
   12b40:	6a 02                	push   $0x2
   12b42:	50                   	push   %eax
   12b43:	e8 15 61 ff ff       	call   8c5d <lodepng_color_mode_make>
   12b48:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12b4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b4e:	8d 58 0c             	lea    0xc(%eax),%ebx
   12b51:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b54:	8b 48 38             	mov    0x38(%eax),%ecx
   12b57:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b5a:	8b 50 34             	mov    0x34(%eax),%edx
   12b5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b60:	8b 40 30             	mov    0x30(%eax),%eax
   12b63:	53                   	push   %ebx
   12b64:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12b6a:	53                   	push   %ebx
   12b6b:	51                   	push   %ecx
   12b6c:	52                   	push   %edx
   12b6d:	50                   	push   %eax
   12b6e:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12b74:	50                   	push   %eax
   12b75:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12b7b:	50                   	push   %eax
   12b7c:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12b82:	50                   	push   %eax
   12b83:	e8 8a 92 ff ff       	call   be12 <lodepng_convert_rgb>
   12b88:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12b8b:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12b91:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12b97:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12b9d:	83 ec 0c             	sub    $0xc,%esp
   12ba0:	68 ff ff 00 00       	push   $0xffff
   12ba5:	51                   	push   %ecx
   12ba6:	52                   	push   %edx
   12ba7:	50                   	push   %eax
   12ba8:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12bae:	50                   	push   %eax
   12baf:	e8 26 a1 ff ff       	call   ccda <lodepng_color_stats_add>
   12bb4:	83 c4 20             	add    $0x20,%esp
   12bb7:	89 c2                	mov    %eax,%edx
   12bb9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bbc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12bc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bc5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12bcb:	85 c0                	test   %eax,%eax
   12bcd:	74 06                	je     12bd5 <lodepng_encode+0x2f8>
   12bcf:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12bd0:	e9 e1 09 00 00       	jmp    135b6 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12bd5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bd8:	8d 50 78             	lea    0x78(%eax),%edx
   12bdb:	83 ec 04             	sub    $0x4,%esp
   12bde:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12be4:	50                   	push   %eax
   12be5:	52                   	push   %edx
   12be6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bec:	83 c0 0c             	add    $0xc,%eax
   12bef:	50                   	push   %eax
   12bf0:	e8 79 a1 ff ff       	call   cd6e <auto_choose_color>
   12bf5:	83 c4 10             	add    $0x10,%esp
   12bf8:	89 c2                	mov    %eax,%edx
   12bfa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bfd:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12c03:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c06:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c0c:	85 c0                	test   %eax,%eax
   12c0e:	0f 85 a5 09 00 00    	jne    135b9 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12c14:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c17:	8b 40 2c             	mov    0x2c(%eax),%eax
   12c1a:	85 c0                	test   %eax,%eax
   12c1c:	74 63                	je     12c81 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12c1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c21:	8d 58 0c             	lea    0xc(%eax),%ebx
   12c24:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c27:	8b 48 38             	mov    0x38(%eax),%ecx
   12c2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c2d:	8b 50 34             	mov    0x34(%eax),%edx
   12c30:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c33:	8b 40 30             	mov    0x30(%eax),%eax
   12c36:	53                   	push   %ebx
   12c37:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12c3d:	83 c3 0c             	add    $0xc,%ebx
   12c40:	53                   	push   %ebx
   12c41:	51                   	push   %ecx
   12c42:	52                   	push   %edx
   12c43:	50                   	push   %eax
   12c44:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c4a:	83 c0 38             	add    $0x38,%eax
   12c4d:	50                   	push   %eax
   12c4e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c54:	83 c0 34             	add    $0x34,%eax
   12c57:	50                   	push   %eax
   12c58:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c5e:	83 c0 30             	add    $0x30,%eax
   12c61:	50                   	push   %eax
   12c62:	e8 ab 91 ff ff       	call   be12 <lodepng_convert_rgb>
   12c67:	83 c4 20             	add    $0x20,%esp
   12c6a:	85 c0                	test   %eax,%eax
   12c6c:	74 13                	je     12c81 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12c6e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c71:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12c78:	00 00 00 
        goto cleanup;
   12c7b:	90                   	nop
   12c7c:	e9 75 09 00 00       	jmp    135f6 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12c81:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c84:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12c8a:	85 c0                	test   %eax,%eax
   12c8c:	0f 84 b2 00 00 00    	je     12d44 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c92:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c95:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c9e:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12ca4:	83 ec 08             	sub    $0x8,%esp
   12ca7:	52                   	push   %edx
   12ca8:	50                   	push   %eax
   12ca9:	e8 8b fb ff ff       	call   12839 <isGrayICCProfile>
   12cae:	83 c4 10             	add    $0x10,%esp
   12cb1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12cb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cb7:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12cbd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cc0:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12cc6:	83 ec 08             	sub    $0x8,%esp
   12cc9:	52                   	push   %edx
   12cca:	50                   	push   %eax
   12ccb:	e8 bb fb ff ff       	call   1288b <isRGBICCProfile>
   12cd0:	83 c4 10             	add    $0x10,%esp
   12cd3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12cd6:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12cdc:	85 c0                	test   %eax,%eax
   12cde:	74 0b                	je     12ceb <lodepng_encode+0x40e>
   12ce0:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12ce6:	83 f8 04             	cmp    $0x4,%eax
   12ce9:	75 07                	jne    12cf2 <lodepng_encode+0x415>
   12ceb:	b8 01 00 00 00       	mov    $0x1,%eax
   12cf0:	eb 05                	jmp    12cf7 <lodepng_encode+0x41a>
   12cf2:	b8 00 00 00 00       	mov    $0x0,%eax
   12cf7:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12cfa:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12cfe:	75 18                	jne    12d18 <lodepng_encode+0x43b>
   12d00:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12d04:	75 12                	jne    12d18 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12d06:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d09:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12d10:	00 00 00 
      goto cleanup;
   12d13:	e9 de 08 00 00       	jmp    135f6 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12d18:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12d1b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12d1e:	74 24                	je     12d44 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12d20:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d23:	8b 40 5c             	mov    0x5c(%eax),%eax
   12d26:	85 c0                	test   %eax,%eax
   12d28:	74 07                	je     12d31 <lodepng_encode+0x454>
   12d2a:	ba 66 00 00 00       	mov    $0x66,%edx
   12d2f:	eb 05                	jmp    12d36 <lodepng_encode+0x459>
   12d31:	ba 65 00 00 00       	mov    $0x65,%edx
   12d36:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d39:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12d3f:	e9 b2 08 00 00       	jmp    135f6 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12d44:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d47:	83 c0 78             	add    $0x78,%eax
   12d4a:	83 ec 08             	sub    $0x8,%esp
   12d4d:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12d53:	83 c2 0c             	add    $0xc,%edx
   12d56:	52                   	push   %edx
   12d57:	50                   	push   %eax
   12d58:	e8 57 5f ff ff       	call   8cb4 <lodepng_color_mode_equal>
   12d5d:	83 c4 10             	add    $0x10,%esp
   12d60:	85 c0                	test   %eax,%eax
   12d62:	0f 85 f8 00 00 00    	jne    12e60 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12d68:	8b 55 14             	mov    0x14(%ebp),%edx
   12d6b:	8b 45 18             	mov    0x18(%ebp),%eax
   12d6e:	89 d3                	mov    %edx,%ebx
   12d70:	0f af d8             	imul   %eax,%ebx
   12d73:	83 ec 0c             	sub    $0xc,%esp
   12d76:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d7c:	83 c0 0c             	add    $0xc,%eax
   12d7f:	50                   	push   %eax
   12d80:	e8 49 61 ff ff       	call   8ece <lodepng_get_bpp>
   12d85:	83 c4 10             	add    $0x10,%esp
   12d88:	0f af c3             	imul   %ebx,%eax
   12d8b:	83 c0 07             	add    $0x7,%eax
   12d8e:	c1 e8 03             	shr    $0x3,%eax
   12d91:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12d94:	83 ec 0c             	sub    $0xc,%esp
   12d97:	ff 75 cc             	pushl  -0x34(%ebp)
   12d9a:	e8 13 06 ff ff       	call   33b2 <lodepng_malloc>
   12d9f:	83 c4 10             	add    $0x10,%esp
   12da2:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12da5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12da9:	75 13                	jne    12dbe <lodepng_encode+0x4e1>
   12dab:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12daf:	74 0d                	je     12dbe <lodepng_encode+0x4e1>
   12db1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12db4:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12dbb:	00 00 00 
    if(!state->error) {
   12dbe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12dc7:	85 c0                	test   %eax,%eax
   12dc9:	75 33                	jne    12dfe <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12dcb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dce:	83 c0 78             	add    $0x78,%eax
   12dd1:	83 ec 08             	sub    $0x8,%esp
   12dd4:	ff 75 18             	pushl  0x18(%ebp)
   12dd7:	ff 75 14             	pushl  0x14(%ebp)
   12dda:	50                   	push   %eax
   12ddb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12de1:	83 c0 0c             	add    $0xc,%eax
   12de4:	50                   	push   %eax
   12de5:	ff 75 10             	pushl  0x10(%ebp)
   12de8:	ff 75 c8             	pushl  -0x38(%ebp)
   12deb:	e8 c9 8c ff ff       	call   bab9 <lodepng_convert>
   12df0:	83 c4 20             	add    $0x20,%esp
   12df3:	89 c2                	mov    %eax,%edx
   12df5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12df8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12dfe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e01:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e07:	85 c0                	test   %eax,%eax
   12e09:	75 35                	jne    12e40 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12e0b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e0e:	83 c0 38             	add    $0x38,%eax
   12e11:	83 ec 04             	sub    $0x4,%esp
   12e14:	50                   	push   %eax
   12e15:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e1b:	50                   	push   %eax
   12e1c:	ff 75 18             	pushl  0x18(%ebp)
   12e1f:	ff 75 14             	pushl  0x14(%ebp)
   12e22:	ff 75 c8             	pushl  -0x38(%ebp)
   12e25:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12e28:	50                   	push   %eax
   12e29:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12e2c:	50                   	push   %eax
   12e2d:	e8 0d f6 ff ff       	call   1243f <preProcessScanlines>
   12e32:	83 c4 20             	add    $0x20,%esp
   12e35:	89 c2                	mov    %eax,%edx
   12e37:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e3a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12e40:	83 ec 0c             	sub    $0xc,%esp
   12e43:	ff 75 c8             	pushl  -0x38(%ebp)
   12e46:	e8 88 05 ff ff       	call   33d3 <lodepng_free>
   12e4b:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12e4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e51:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e57:	85 c0                	test   %eax,%eax
   12e59:	74 4b                	je     12ea6 <lodepng_encode+0x5c9>
   12e5b:	e9 96 07 00 00       	jmp    135f6 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12e60:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e63:	83 c0 38             	add    $0x38,%eax
   12e66:	83 ec 04             	sub    $0x4,%esp
   12e69:	50                   	push   %eax
   12e6a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e70:	50                   	push   %eax
   12e71:	ff 75 18             	pushl  0x18(%ebp)
   12e74:	ff 75 14             	pushl  0x14(%ebp)
   12e77:	ff 75 10             	pushl  0x10(%ebp)
   12e7a:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12e7d:	50                   	push   %eax
   12e7e:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12e81:	50                   	push   %eax
   12e82:	e8 b8 f5 ff ff       	call   1243f <preProcessScanlines>
   12e87:	83 c4 20             	add    $0x20,%esp
   12e8a:	89 c2                	mov    %eax,%edx
   12e8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e8f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e98:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e9e:	85 c0                	test   %eax,%eax
   12ea0:	0f 85 16 07 00 00    	jne    135bc <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12ea6:	83 ec 0c             	sub    $0xc,%esp
   12ea9:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12eac:	50                   	push   %eax
   12ead:	e8 21 d9 ff ff       	call   107d3 <writeSignature>
   12eb2:	83 c4 10             	add    $0x10,%esp
   12eb5:	89 c2                	mov    %eax,%edx
   12eb7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eba:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12ec0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ec3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ec9:	85 c0                	test   %eax,%eax
   12ecb:	0f 85 ee 06 00 00    	jne    135bf <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12ed1:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12ed7:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12edd:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12ee3:	83 ec 08             	sub    $0x8,%esp
   12ee6:	51                   	push   %ecx
   12ee7:	52                   	push   %edx
   12ee8:	50                   	push   %eax
   12ee9:	ff 75 18             	pushl  0x18(%ebp)
   12eec:	ff 75 14             	pushl  0x14(%ebp)
   12eef:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12ef2:	50                   	push   %eax
   12ef3:	e8 4a d9 ff ff       	call   10842 <addChunk_IHDR>
   12ef8:	83 c4 20             	add    $0x20,%esp
   12efb:	89 c2                	mov    %eax,%edx
   12efd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f00:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12f06:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f09:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f0f:	85 c0                	test   %eax,%eax
   12f11:	0f 85 ab 06 00 00    	jne    135c2 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12f17:	8b 45 98             	mov    -0x68(%ebp),%eax
   12f1a:	85 c0                	test   %eax,%eax
   12f1c:	74 33                	je     12f51 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12f1e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12f21:	8b 45 98             	mov    -0x68(%ebp),%eax
   12f24:	83 ec 04             	sub    $0x4,%esp
   12f27:	52                   	push   %edx
   12f28:	50                   	push   %eax
   12f29:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f2c:	50                   	push   %eax
   12f2d:	e8 9c f8 ff ff       	call   127ce <addUnknownChunks>
   12f32:	83 c4 10             	add    $0x10,%esp
   12f35:	89 c2                	mov    %eax,%edx
   12f37:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f3a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f40:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f43:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f49:	85 c0                	test   %eax,%eax
   12f4b:	0f 85 74 06 00 00    	jne    135c5 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12f51:	8b 45 88             	mov    -0x78(%ebp),%eax
   12f54:	85 c0                	test   %eax,%eax
   12f56:	74 39                	je     12f91 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12f58:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f5b:	83 c0 38             	add    $0x38,%eax
   12f5e:	83 ec 04             	sub    $0x4,%esp
   12f61:	50                   	push   %eax
   12f62:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f68:	50                   	push   %eax
   12f69:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f6c:	50                   	push   %eax
   12f6d:	e8 a4 e4 ff ff       	call   11416 <addChunk_iCCP>
   12f72:	83 c4 10             	add    $0x10,%esp
   12f75:	89 c2                	mov    %eax,%edx
   12f77:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f7a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f80:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f83:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f89:	85 c0                	test   %eax,%eax
   12f8b:	0f 85 37 06 00 00    	jne    135c8 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12f91:	8b 45 80             	mov    -0x80(%ebp),%eax
   12f94:	85 c0                	test   %eax,%eax
   12f96:	74 32                	je     12fca <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12f98:	83 ec 08             	sub    $0x8,%esp
   12f9b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fa1:	50                   	push   %eax
   12fa2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fa5:	50                   	push   %eax
   12fa6:	e8 41 e4 ff ff       	call   113ec <addChunk_sRGB>
   12fab:	83 c4 10             	add    $0x10,%esp
   12fae:	89 c2                	mov    %eax,%edx
   12fb0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fb3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fb9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fbc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fc2:	85 c0                	test   %eax,%eax
   12fc4:	0f 85 01 06 00 00    	jne    135cb <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   12fca:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   12fd0:	85 c0                	test   %eax,%eax
   12fd2:	74 32                	je     13006 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   12fd4:	83 ec 08             	sub    $0x8,%esp
   12fd7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fdd:	50                   	push   %eax
   12fde:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fe1:	50                   	push   %eax
   12fe2:	e8 a7 e2 ff ff       	call   1128e <addChunk_gAMA>
   12fe7:	83 c4 10             	add    $0x10,%esp
   12fea:	89 c2                	mov    %eax,%edx
   12fec:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fef:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ff5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ff8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ffe:	85 c0                	test   %eax,%eax
   13000:	0f 85 c8 05 00 00    	jne    135ce <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   13006:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   1300c:	85 c0                	test   %eax,%eax
   1300e:	74 32                	je     13042 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   13010:	83 ec 08             	sub    $0x8,%esp
   13013:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13019:	50                   	push   %eax
   1301a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1301d:	50                   	push   %eax
   1301e:	e8 c1 e2 ff ff       	call   112e4 <addChunk_cHRM>
   13023:	83 c4 10             	add    $0x10,%esp
   13026:	89 c2                	mov    %eax,%edx
   13028:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1302b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13031:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13034:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1303a:	85 c0                	test   %eax,%eax
   1303c:	0f 85 8f 05 00 00    	jne    135d1 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13042:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13048:	83 f8 03             	cmp    $0x3,%eax
   1304b:	75 35                	jne    13082 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   1304d:	83 ec 08             	sub    $0x8,%esp
   13050:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13056:	83 c0 0c             	add    $0xc,%eax
   13059:	50                   	push   %eax
   1305a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1305d:	50                   	push   %eax
   1305e:	e8 78 d8 ff ff       	call   108db <addChunk_PLTE>
   13063:	83 c4 10             	add    $0x10,%esp
   13066:	89 c2                	mov    %eax,%edx
   13068:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1306b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13071:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13074:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1307a:	85 c0                	test   %eax,%eax
   1307c:	0f 85 52 05 00 00    	jne    135d4 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   13082:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13085:	8b 40 6c             	mov    0x6c(%eax),%eax
   13088:	85 c0                	test   %eax,%eax
   1308a:	74 4b                	je     130d7 <lodepng_encode+0x7fa>
   1308c:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13092:	83 f8 02             	cmp    $0x2,%eax
   13095:	74 0b                	je     130a2 <lodepng_encode+0x7c5>
   13097:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1309d:	83 f8 06             	cmp    $0x6,%eax
   130a0:	75 35                	jne    130d7 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   130a2:	83 ec 08             	sub    $0x8,%esp
   130a5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130ab:	83 c0 0c             	add    $0xc,%eax
   130ae:	50                   	push   %eax
   130af:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130b2:	50                   	push   %eax
   130b3:	e8 23 d8 ff ff       	call   108db <addChunk_PLTE>
   130b8:	83 c4 10             	add    $0x10,%esp
   130bb:	89 c2                	mov    %eax,%edx
   130bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130c0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130c9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130cf:	85 c0                	test   %eax,%eax
   130d1:	0f 85 00 05 00 00    	jne    135d7 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   130d7:	83 ec 08             	sub    $0x8,%esp
   130da:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130e0:	83 c0 0c             	add    $0xc,%eax
   130e3:	50                   	push   %eax
   130e4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130e7:	50                   	push   %eax
   130e8:	e8 c4 d8 ff ff       	call   109b1 <addChunk_tRNS>
   130ed:	83 c4 10             	add    $0x10,%esp
   130f0:	89 c2                	mov    %eax,%edx
   130f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130f5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   130fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130fe:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13104:	85 c0                	test   %eax,%eax
   13106:	0f 85 ce 04 00 00    	jne    135da <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   1310c:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13112:	85 c0                	test   %eax,%eax
   13114:	74 32                	je     13148 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13116:	83 ec 08             	sub    $0x8,%esp
   13119:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1311f:	50                   	push   %eax
   13120:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13123:	50                   	push   %eax
   13124:	e8 e4 de ff ff       	call   1100d <addChunk_bKGD>
   13129:	83 c4 10             	add    $0x10,%esp
   1312c:	89 c2                	mov    %eax,%edx
   1312e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13131:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13137:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1313a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13140:	85 c0                	test   %eax,%eax
   13142:	0f 85 95 04 00 00    	jne    135dd <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   13148:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   1314e:	85 c0                	test   %eax,%eax
   13150:	74 32                	je     13184 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   13152:	83 ec 08             	sub    $0x8,%esp
   13155:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1315b:	50                   	push   %eax
   1315c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1315f:	50                   	push   %eax
   13160:	e8 ac e0 ff ff       	call   11211 <addChunk_pHYs>
   13165:	83 c4 10             	add    $0x10,%esp
   13168:	89 c2                	mov    %eax,%edx
   1316a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1316d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13173:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13176:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1317c:	85 c0                	test   %eax,%eax
   1317e:	0f 85 5c 04 00 00    	jne    135e0 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   13184:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13187:	85 c0                	test   %eax,%eax
   13189:	74 33                	je     131be <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   1318b:	8b 55 a8             	mov    -0x58(%ebp),%edx
   1318e:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13191:	83 ec 04             	sub    $0x4,%esp
   13194:	52                   	push   %edx
   13195:	50                   	push   %eax
   13196:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13199:	50                   	push   %eax
   1319a:	e8 2f f6 ff ff       	call   127ce <addUnknownChunks>
   1319f:	83 c4 10             	add    $0x10,%esp
   131a2:	89 c2                	mov    %eax,%edx
   131a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131a7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131ad:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131b0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131b6:	85 c0                	test   %eax,%eax
   131b8:	0f 85 25 04 00 00    	jne    135e3 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   131be:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131c1:	8d 48 38             	lea    0x38(%eax),%ecx
   131c4:	8b 55 bc             	mov    -0x44(%ebp),%edx
   131c7:	8b 45 c0             	mov    -0x40(%ebp),%eax
   131ca:	51                   	push   %ecx
   131cb:	52                   	push   %edx
   131cc:	50                   	push   %eax
   131cd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131d0:	50                   	push   %eax
   131d1:	e8 bd d9 ff ff       	call   10b93 <addChunk_IDAT>
   131d6:	83 c4 10             	add    $0x10,%esp
   131d9:	89 c2                	mov    %eax,%edx
   131db:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131de:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   131e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131e7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131ed:	85 c0                	test   %eax,%eax
   131ef:	0f 85 f1 03 00 00    	jne    135e6 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   131f5:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   131fb:	85 c0                	test   %eax,%eax
   131fd:	74 35                	je     13234 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   131ff:	83 ec 08             	sub    $0x8,%esp
   13202:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13208:	83 c0 60             	add    $0x60,%eax
   1320b:	50                   	push   %eax
   1320c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1320f:	50                   	push   %eax
   13210:	e8 5c df ff ff       	call   11171 <addChunk_tIME>
   13215:	83 c4 10             	add    $0x10,%esp
   13218:	89 c2                	mov    %eax,%edx
   1321a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1321d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13223:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13226:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1322c:	85 c0                	test   %eax,%eax
   1322e:	0f 85 b5 03 00 00    	jne    135e9 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13234:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1323b:	e9 12 01 00 00       	jmp    13352 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   13240:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13246:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13249:	c1 e2 02             	shl    $0x2,%edx
   1324c:	01 d0                	add    %edx,%eax
   1324e:	8b 00                	mov    (%eax),%eax
   13250:	83 ec 0c             	sub    $0xc,%esp
   13253:	50                   	push   %eax
   13254:	e8 f5 01 ff ff       	call   344e <lodepng_strlen>
   13259:	83 c4 10             	add    $0x10,%esp
   1325c:	83 f8 4f             	cmp    $0x4f,%eax
   1325f:	7e 12                	jle    13273 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   13261:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13264:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   1326b:	00 00 00 
        goto cleanup;
   1326e:	e9 83 03 00 00       	jmp    135f6 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   13273:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13279:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1327c:	c1 e2 02             	shl    $0x2,%edx
   1327f:	01 d0                	add    %edx,%eax
   13281:	8b 00                	mov    (%eax),%eax
   13283:	83 ec 0c             	sub    $0xc,%esp
   13286:	50                   	push   %eax
   13287:	e8 c2 01 ff ff       	call   344e <lodepng_strlen>
   1328c:	83 c4 10             	add    $0x10,%esp
   1328f:	85 c0                	test   %eax,%eax
   13291:	7f 12                	jg     132a5 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   13293:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13296:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1329d:	00 00 00 
        goto cleanup;
   132a0:	e9 51 03 00 00       	jmp    135f6 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   132a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a8:	8b 40 74             	mov    0x74(%eax),%eax
   132ab:	85 c0                	test   %eax,%eax
   132ad:	74 52                	je     13301 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   132af:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b2:	8d 48 38             	lea    0x38(%eax),%ecx
   132b5:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   132bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   132be:	c1 e2 02             	shl    $0x2,%edx
   132c1:	01 d0                	add    %edx,%eax
   132c3:	8b 10                	mov    (%eax),%edx
   132c5:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132cb:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   132ce:	c1 e3 02             	shl    $0x2,%ebx
   132d1:	01 d8                	add    %ebx,%eax
   132d3:	8b 00                	mov    (%eax),%eax
   132d5:	51                   	push   %ecx
   132d6:	52                   	push   %edx
   132d7:	50                   	push   %eax
   132d8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132db:	50                   	push   %eax
   132dc:	e8 fa d9 ff ff       	call   10cdb <addChunk_zTXt>
   132e1:	83 c4 10             	add    $0x10,%esp
   132e4:	89 c2                	mov    %eax,%edx
   132e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132e9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   132ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132f2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132f8:	85 c0                	test   %eax,%eax
   132fa:	74 52                	je     1334e <lodepng_encode+0xa71>
   132fc:	e9 f5 02 00 00       	jmp    135f6 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13301:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13307:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1330a:	c1 e2 02             	shl    $0x2,%edx
   1330d:	01 d0                	add    %edx,%eax
   1330f:	8b 10                	mov    (%eax),%edx
   13311:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13317:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1331a:	c1 e1 02             	shl    $0x2,%ecx
   1331d:	01 c8                	add    %ecx,%eax
   1331f:	8b 00                	mov    (%eax),%eax
   13321:	83 ec 04             	sub    $0x4,%esp
   13324:	52                   	push   %edx
   13325:	50                   	push   %eax
   13326:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13329:	50                   	push   %eax
   1332a:	e8 ec d8 ff ff       	call   10c1b <addChunk_tEXt>
   1332f:	83 c4 10             	add    $0x10,%esp
   13332:	89 c2                	mov    %eax,%edx
   13334:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13337:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1333d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13340:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13346:	85 c0                	test   %eax,%eax
   13348:	0f 85 9e 02 00 00    	jne    135ec <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   1334e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13352:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13358:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1335b:	0f 85 df fe ff ff    	jne    13240 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   13361:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13364:	8b 40 70             	mov    0x70(%eax),%eax
   13367:	85 c0                	test   %eax,%eax
   13369:	0f 84 e3 00 00 00    	je     13452 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   1336f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   13376:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1337d:	e9 85 00 00 00       	jmp    13407 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   13382:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13388:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1338b:	c1 e2 02             	shl    $0x2,%edx
   1338e:	01 d0                	add    %edx,%eax
   13390:	8b 00                	mov    (%eax),%eax
   13392:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13395:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13398:	0f b6 00             	movzbl (%eax),%eax
   1339b:	3c 4c                	cmp    $0x4c,%al
   1339d:	75 64                	jne    13403 <lodepng_encode+0xb26>
   1339f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133a2:	83 c0 01             	add    $0x1,%eax
   133a5:	0f b6 00             	movzbl (%eax),%eax
   133a8:	3c 6f                	cmp    $0x6f,%al
   133aa:	75 57                	jne    13403 <lodepng_encode+0xb26>
   133ac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133af:	83 c0 02             	add    $0x2,%eax
   133b2:	0f b6 00             	movzbl (%eax),%eax
   133b5:	3c 64                	cmp    $0x64,%al
   133b7:	75 4a                	jne    13403 <lodepng_encode+0xb26>
   133b9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133bc:	83 c0 03             	add    $0x3,%eax
   133bf:	0f b6 00             	movzbl (%eax),%eax
   133c2:	3c 65                	cmp    $0x65,%al
   133c4:	75 3d                	jne    13403 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   133c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133c9:	83 c0 04             	add    $0x4,%eax
   133cc:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   133cf:	3c 50                	cmp    $0x50,%al
   133d1:	75 30                	jne    13403 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   133d3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133d6:	83 c0 05             	add    $0x5,%eax
   133d9:	0f b6 00             	movzbl (%eax),%eax
   133dc:	3c 4e                	cmp    $0x4e,%al
   133de:	75 23                	jne    13403 <lodepng_encode+0xb26>
   133e0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133e3:	83 c0 06             	add    $0x6,%eax
   133e6:	0f b6 00             	movzbl (%eax),%eax
   133e9:	3c 47                	cmp    $0x47,%al
   133eb:	75 16                	jne    13403 <lodepng_encode+0xb26>
   133ed:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133f0:	83 c0 07             	add    $0x7,%eax
   133f3:	0f b6 00             	movzbl (%eax),%eax
   133f6:	84 c0                	test   %al,%al
   133f8:	75 09                	jne    13403 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   133fa:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13401:	eb 13                	jmp    13416 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13403:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13407:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1340d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13410:	0f 85 6c ff ff ff    	jne    13382 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13416:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1341a:	75 36                	jne    13452 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   1341c:	a1 e0 e1 01 00       	mov    0x1e1e0,%eax
   13421:	83 ec 04             	sub    $0x4,%esp
   13424:	50                   	push   %eax
   13425:	68 a4 a1 01 00       	push   $0x1a1a4
   1342a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1342d:	50                   	push   %eax
   1342e:	e8 e8 d7 ff ff       	call   10c1b <addChunk_tEXt>
   13433:	83 c4 10             	add    $0x10,%esp
   13436:	89 c2                	mov    %eax,%edx
   13438:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1343b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13441:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13444:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1344a:	85 c0                	test   %eax,%eax
   1344c:	0f 85 9d 01 00 00    	jne    135ef <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13452:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13459:	e9 e6 00 00 00       	jmp    13544 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   1345e:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13464:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13467:	c1 e2 02             	shl    $0x2,%edx
   1346a:	01 d0                	add    %edx,%eax
   1346c:	8b 00                	mov    (%eax),%eax
   1346e:	83 ec 0c             	sub    $0xc,%esp
   13471:	50                   	push   %eax
   13472:	e8 d7 ff fe ff       	call   344e <lodepng_strlen>
   13477:	83 c4 10             	add    $0x10,%esp
   1347a:	83 f8 4f             	cmp    $0x4f,%eax
   1347d:	7e 12                	jle    13491 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   1347f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13482:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13489:	00 00 00 
        goto cleanup;
   1348c:	e9 65 01 00 00       	jmp    135f6 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   13491:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13497:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1349a:	c1 e2 02             	shl    $0x2,%edx
   1349d:	01 d0                	add    %edx,%eax
   1349f:	8b 00                	mov    (%eax),%eax
   134a1:	83 ec 0c             	sub    $0xc,%esp
   134a4:	50                   	push   %eax
   134a5:	e8 a4 ff fe ff       	call   344e <lodepng_strlen>
   134aa:	83 c4 10             	add    $0x10,%esp
   134ad:	85 c0                	test   %eax,%eax
   134af:	7f 12                	jg     134c3 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   134b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134b4:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   134bb:	00 00 00 
        goto cleanup;
   134be:	e9 33 01 00 00       	jmp    135f6 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   134c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134c6:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   134c9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   134cf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134d2:	c1 e2 02             	shl    $0x2,%edx
   134d5:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   134d7:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   134d9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   134df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134e2:	c1 e2 02             	shl    $0x2,%edx
   134e5:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   134e7:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   134e9:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   134ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134f2:	c1 e2 02             	shl    $0x2,%edx
   134f5:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   134f7:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   134f9:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   134ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13502:	c1 e2 02             	shl    $0x2,%edx
   13505:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13507:	8b 10                	mov    (%eax),%edx
   13509:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1350c:	8b 40 74             	mov    0x74(%eax),%eax
   1350f:	83 ec 04             	sub    $0x4,%esp
   13512:	57                   	push   %edi
   13513:	56                   	push   %esi
   13514:	53                   	push   %ebx
   13515:	51                   	push   %ecx
   13516:	52                   	push   %edx
   13517:	50                   	push   %eax
   13518:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1351b:	50                   	push   %eax
   1351c:	e8 dc d8 ff ff       	call   10dfd <addChunk_iTXt>
   13521:	83 c4 20             	add    $0x20,%esp
   13524:	89 c2                	mov    %eax,%edx
   13526:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13529:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1352f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13532:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13538:	85 c0                	test   %eax,%eax
   1353a:	0f 85 b2 00 00 00    	jne    135f2 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13540:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13544:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   1354a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1354d:	0f 85 0b ff ff ff    	jne    1345e <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   13553:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13556:	85 c0                	test   %eax,%eax
   13558:	74 2f                	je     13589 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   1355a:	8b 55 ac             	mov    -0x54(%ebp),%edx
   1355d:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13560:	83 ec 04             	sub    $0x4,%esp
   13563:	52                   	push   %edx
   13564:	50                   	push   %eax
   13565:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13568:	50                   	push   %eax
   13569:	e8 60 f2 ff ff       	call   127ce <addUnknownChunks>
   1356e:	83 c4 10             	add    $0x10,%esp
   13571:	89 c2                	mov    %eax,%edx
   13573:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13576:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1357c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1357f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13585:	85 c0                	test   %eax,%eax
   13587:	75 6c                	jne    135f5 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   13589:	83 ec 0c             	sub    $0xc,%esp
   1358c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1358f:	50                   	push   %eax
   13590:	e8 6d d6 ff ff       	call   10c02 <addChunk_IEND>
   13595:	83 c4 10             	add    $0x10,%esp
   13598:	89 c2                	mov    %eax,%edx
   1359a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1359d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   135a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135a6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135ac:	85 c0                	test   %eax,%eax
   135ae:	eb 46                	jmp    135f6 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   135b0:	90                   	nop
   135b1:	eb 43                	jmp    135f6 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   135b3:	90                   	nop
   135b4:	eb 40                	jmp    135f6 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   135b6:	90                   	nop
   135b7:	eb 3d                	jmp    135f6 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   135b9:	90                   	nop
   135ba:	eb 3a                	jmp    135f6 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   135bc:	90                   	nop
   135bd:	eb 37                	jmp    135f6 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   135bf:	90                   	nop
   135c0:	eb 34                	jmp    135f6 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   135c2:	90                   	nop
   135c3:	eb 31                	jmp    135f6 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   135c5:	90                   	nop
   135c6:	eb 2e                	jmp    135f6 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   135c8:	90                   	nop
   135c9:	eb 2b                	jmp    135f6 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   135cb:	90                   	nop
   135cc:	eb 28                	jmp    135f6 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   135ce:	90                   	nop
   135cf:	eb 25                	jmp    135f6 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   135d1:	90                   	nop
   135d2:	eb 22                	jmp    135f6 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   135d4:	90                   	nop
   135d5:	eb 1f                	jmp    135f6 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   135d7:	90                   	nop
   135d8:	eb 1c                	jmp    135f6 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   135da:	90                   	nop
   135db:	eb 19                	jmp    135f6 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   135dd:	90                   	nop
   135de:	eb 16                	jmp    135f6 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   135e0:	90                   	nop
   135e1:	eb 13                	jmp    135f6 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   135e3:	90                   	nop
   135e4:	eb 10                	jmp    135f6 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   135e6:	90                   	nop
   135e7:	eb 0d                	jmp    135f6 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   135e9:	90                   	nop
   135ea:	eb 0a                	jmp    135f6 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   135ec:	90                   	nop
   135ed:	eb 07                	jmp    135f6 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   135ef:	90                   	nop
   135f0:	eb 04                	jmp    135f6 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   135f2:	90                   	nop
   135f3:	eb 01                	jmp    135f6 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   135f5:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   135f6:	83 ec 0c             	sub    $0xc,%esp
   135f9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   135ff:	50                   	push   %eax
   13600:	e8 34 65 ff ff       	call   9b39 <lodepng_info_cleanup>
   13605:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13608:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1360b:	83 ec 0c             	sub    $0xc,%esp
   1360e:	50                   	push   %eax
   1360f:	e8 bf fd fe ff       	call   33d3 <lodepng_free>
   13614:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   13617:	8b 55 b0             	mov    -0x50(%ebp),%edx
   1361a:	8b 45 08             	mov    0x8(%ebp),%eax
   1361d:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   1361f:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13622:	8b 45 0c             	mov    0xc(%ebp),%eax
   13625:	89 10                	mov    %edx,(%eax)

  return state->error;
   13627:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1362a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13630:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13633:	5b                   	pop    %ebx
   13634:	5e                   	pop    %esi
   13635:	5f                   	pop    %edi
   13636:	5d                   	pop    %ebp
   13637:	c3                   	ret    

00013638 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   13638:	55                   	push   %ebp
   13639:	89 e5                	mov    %esp,%ebp
   1363b:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   13641:	83 ec 0c             	sub    $0xc,%esp
   13644:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1364a:	50                   	push   %eax
   1364b:	e8 38 d0 ff ff       	call   10688 <lodepng_state_init>
   13650:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   13653:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13656:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   1365c:	8b 45 20             	mov    0x20(%ebp),%eax
   1365f:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   13665:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13668:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   1366e:	8b 45 20             	mov    0x20(%ebp),%eax
   13671:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   13677:	83 ec 08             	sub    $0x8,%esp
   1367a:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13680:	50                   	push   %eax
   13681:	ff 75 18             	pushl  0x18(%ebp)
   13684:	ff 75 14             	pushl  0x14(%ebp)
   13687:	ff 75 10             	pushl  0x10(%ebp)
   1368a:	ff 75 0c             	pushl  0xc(%ebp)
   1368d:	ff 75 08             	pushl  0x8(%ebp)
   13690:	e8 48 f2 ff ff       	call   128dd <lodepng_encode>
   13695:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   13698:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1369b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1369e:	83 ec 0c             	sub    $0xc,%esp
   136a1:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   136a7:	50                   	push   %eax
   136a8:	e8 35 d0 ff ff       	call   106e2 <lodepng_state_cleanup>
   136ad:	83 c4 10             	add    $0x10,%esp
  return error;
   136b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   136b3:	c9                   	leave  
   136b4:	c3                   	ret    

000136b5 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   136b5:	55                   	push   %ebp
   136b6:	89 e5                	mov    %esp,%ebp
   136b8:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   136bb:	83 ec 04             	sub    $0x4,%esp
   136be:	6a 08                	push   $0x8
   136c0:	6a 06                	push   $0x6
   136c2:	ff 75 18             	pushl  0x18(%ebp)
   136c5:	ff 75 14             	pushl  0x14(%ebp)
   136c8:	ff 75 10             	pushl  0x10(%ebp)
   136cb:	ff 75 0c             	pushl  0xc(%ebp)
   136ce:	ff 75 08             	pushl  0x8(%ebp)
   136d1:	e8 62 ff ff ff       	call   13638 <lodepng_encode_memory>
   136d6:	83 c4 20             	add    $0x20,%esp
}
   136d9:	c9                   	leave  
   136da:	c3                   	ret    

000136db <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   136db:	55                   	push   %ebp
   136dc:	89 e5                	mov    %esp,%ebp
   136de:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   136e1:	83 ec 04             	sub    $0x4,%esp
   136e4:	6a 08                	push   $0x8
   136e6:	6a 02                	push   $0x2
   136e8:	ff 75 18             	pushl  0x18(%ebp)
   136eb:	ff 75 14             	pushl  0x14(%ebp)
   136ee:	ff 75 10             	pushl  0x10(%ebp)
   136f1:	ff 75 0c             	pushl  0xc(%ebp)
   136f4:	ff 75 08             	pushl  0x8(%ebp)
   136f7:	e8 3c ff ff ff       	call   13638 <lodepng_encode_memory>
   136fc:	83 c4 20             	add    $0x20,%esp
}
   136ff:	c9                   	leave  
   13700:	c3                   	ret    

00013701 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13701:	55                   	push   %ebp
   13702:	89 e5                	mov    %esp,%ebp
   13704:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13707:	83 ec 04             	sub    $0x4,%esp
   1370a:	ff 75 1c             	pushl  0x1c(%ebp)
   1370d:	ff 75 18             	pushl  0x18(%ebp)
   13710:	ff 75 14             	pushl  0x14(%ebp)
   13713:	ff 75 10             	pushl  0x10(%ebp)
   13716:	ff 75 0c             	pushl  0xc(%ebp)
   13719:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1371c:	50                   	push   %eax
   1371d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13720:	50                   	push   %eax
   13721:	e8 12 ff ff ff       	call   13638 <lodepng_encode_memory>
   13726:	83 c4 20             	add    $0x20,%esp
   13729:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   1372c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13730:	75 19                	jne    1374b <lodepng_encode_file+0x4a>
   13732:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13735:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13738:	83 ec 04             	sub    $0x4,%esp
   1373b:	ff 75 08             	pushl  0x8(%ebp)
   1373e:	52                   	push   %edx
   1373f:	50                   	push   %eax
   13740:	e8 36 01 ff ff       	call   387b <lodepng_save_file>
   13745:	83 c4 10             	add    $0x10,%esp
   13748:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1374b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1374e:	83 ec 0c             	sub    $0xc,%esp
   13751:	50                   	push   %eax
   13752:	e8 7c fc fe ff       	call   33d3 <lodepng_free>
   13757:	83 c4 10             	add    $0x10,%esp
  return error;
   1375a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1375d:	c9                   	leave  
   1375e:	c3                   	ret    

0001375f <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1375f:	55                   	push   %ebp
   13760:	89 e5                	mov    %esp,%ebp
   13762:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   13765:	83 ec 08             	sub    $0x8,%esp
   13768:	6a 08                	push   $0x8
   1376a:	6a 06                	push   $0x6
   1376c:	ff 75 14             	pushl  0x14(%ebp)
   1376f:	ff 75 10             	pushl  0x10(%ebp)
   13772:	ff 75 0c             	pushl  0xc(%ebp)
   13775:	ff 75 08             	pushl  0x8(%ebp)
   13778:	e8 84 ff ff ff       	call   13701 <lodepng_encode_file>
   1377d:	83 c4 20             	add    $0x20,%esp
}
   13780:	c9                   	leave  
   13781:	c3                   	ret    

00013782 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13782:	55                   	push   %ebp
   13783:	89 e5                	mov    %esp,%ebp
   13785:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   13788:	83 ec 08             	sub    $0x8,%esp
   1378b:	6a 08                	push   $0x8
   1378d:	6a 02                	push   $0x2
   1378f:	ff 75 14             	pushl  0x14(%ebp)
   13792:	ff 75 10             	pushl  0x10(%ebp)
   13795:	ff 75 0c             	pushl  0xc(%ebp)
   13798:	ff 75 08             	pushl  0x8(%ebp)
   1379b:	e8 61 ff ff ff       	call   13701 <lodepng_encode_file>
   137a0:	83 c4 20             	add    $0x20,%esp
}
   137a3:	c9                   	leave  
   137a4:	c3                   	ret    

000137a5 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   137a5:	55                   	push   %ebp
   137a6:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   137a8:	8b 45 08             	mov    0x8(%ebp),%eax
   137ab:	50                   	push   %eax
   137ac:	e8 71 49 ff ff       	call   8122 <lodepng_compress_settings_init>
   137b1:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   137b4:	8b 45 08             	mov    0x8(%ebp),%eax
   137b7:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   137be:	8b 45 08             	mov    0x8(%ebp),%eax
   137c1:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   137c8:	8b 45 08             	mov    0x8(%ebp),%eax
   137cb:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   137d2:	8b 45 08             	mov    0x8(%ebp),%eax
   137d5:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   137dc:	8b 45 08             	mov    0x8(%ebp),%eax
   137df:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   137e6:	8b 45 08             	mov    0x8(%ebp),%eax
   137e9:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   137f0:	8b 45 08             	mov    0x8(%ebp),%eax
   137f3:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   137fa:	90                   	nop
   137fb:	c9                   	leave  
   137fc:	c3                   	ret    

000137fd <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   137fd:	55                   	push   %ebp
   137fe:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13800:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13804:	0f 87 c1 03 00 00    	ja     13bcb <lodepng_error_text+0x3ce>
   1380a:	8b 45 08             	mov    0x8(%ebp),%eax
   1380d:	c1 e0 02             	shl    $0x2,%eax
   13810:	05 e0 b4 01 00       	add    $0x1b4e0,%eax
   13815:	8b 00                	mov    (%eax),%eax
   13817:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13819:	b8 ac a1 01 00       	mov    $0x1a1ac,%eax
   1381e:	e9 ad 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13823:	b8 c9 a1 01 00       	mov    $0x1a1c9,%eax
   13828:	e9 a3 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   1382d:	b8 dc a1 01 00       	mov    $0x1a1dc,%eax
   13832:	e9 99 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13837:	b8 14 a2 01 00       	mov    $0x1a214,%eax
   1383c:	e9 8f 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   13841:	b8 4c a2 01 00       	mov    $0x1a24c,%eax
   13846:	e9 85 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   1384b:	b8 4c a2 01 00       	mov    $0x1a24c,%eax
   13850:	e9 7b 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13855:	b8 4c a2 01 00       	mov    $0x1a24c,%eax
   1385a:	e9 71 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   1385f:	b8 7c a2 01 00       	mov    $0x1a27c,%eax
   13864:	e9 67 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13869:	b8 b0 a2 01 00       	mov    $0x1a2b0,%eax
   1386e:	e9 5d 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13873:	b8 e4 a2 01 00       	mov    $0x1a2e4,%eax
   13878:	e9 53 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   1387d:	b8 b0 a2 01 00       	mov    $0x1a2b0,%eax
   13882:	e9 49 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13887:	b8 0c a3 01 00       	mov    $0x1a30c,%eax
   1388c:	e9 3f 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13891:	b8 44 a3 01 00       	mov    $0x1a344,%eax
   13896:	e9 35 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   1389b:	b8 b0 a2 01 00       	mov    $0x1a2b0,%eax
   138a0:	e9 2b 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   138a5:	b8 7c a3 01 00       	mov    $0x1a37c,%eax
   138aa:	e9 21 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   138af:	b8 ac a3 01 00       	mov    $0x1a3ac,%eax
   138b4:	e9 17 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   138b9:	b8 cc a3 01 00       	mov    $0x1a3cc,%eax
   138be:	e9 0d 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   138c3:	b8 f8 a3 01 00       	mov    $0x1a3f8,%eax
   138c8:	e9 03 03 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   138cd:	b8 38 a4 01 00       	mov    $0x1a438,%eax
   138d2:	e9 f9 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   138d7:	b8 60 a4 01 00       	mov    $0x1a460,%eax
   138dc:	e9 ef 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   138e1:	b8 94 a4 01 00       	mov    $0x1a494,%eax
   138e6:	e9 e5 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   138eb:	b8 b8 a4 01 00       	mov    $0x1a4b8,%eax
   138f0:	e9 db 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   138f5:	b8 f0 a4 01 00       	mov    $0x1a4f0,%eax
   138fa:	e9 d1 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   138ff:	b8 10 a5 01 00       	mov    $0x1a510,%eax
   13904:	e9 c7 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13909:	b8 2f a5 01 00       	mov    $0x1a52f,%eax
   1390e:	e9 bd 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13913:	b8 49 a5 01 00       	mov    $0x1a549,%eax
   13918:	e9 b3 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   1391d:	b8 68 a5 01 00       	mov    $0x1a568,%eax
   13922:	e9 a9 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13927:	b8 a4 a5 01 00       	mov    $0x1a5a4,%eax
   1392c:	e9 9f 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13931:	b8 c8 a5 01 00       	mov    $0x1a5c8,%eax
   13936:	e9 95 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   1393b:	b8 f4 a5 01 00       	mov    $0x1a5f4,%eax
   13940:	e9 8b 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13945:	b8 18 a6 01 00       	mov    $0x1a618,%eax
   1394a:	e9 81 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   1394f:	b8 58 a6 01 00       	mov    $0x1a658,%eax
   13954:	e9 77 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13959:	b8 88 a6 01 00       	mov    $0x1a688,%eax
   1395e:	e9 6d 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13963:	b8 b0 a6 01 00       	mov    $0x1a6b0,%eax
   13968:	e9 63 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   1396d:	b8 f4 a6 01 00       	mov    $0x1a6f4,%eax
   13972:	e9 59 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13977:	b8 20 a7 01 00       	mov    $0x1a720,%eax
   1397c:	e9 4f 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   13981:	b8 50 a7 01 00       	mov    $0x1a750,%eax
   13986:	e9 45 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   1398b:	b8 78 a7 01 00       	mov    $0x1a778,%eax
   13990:	e9 3b 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13995:	b8 c0 a7 01 00       	mov    $0x1a7c0,%eax
   1399a:	e9 31 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   1399f:	b8 c0 a7 01 00       	mov    $0x1a7c0,%eax
   139a4:	e9 27 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   139a9:	b8 fc a7 01 00       	mov    $0x1a7fc,%eax
   139ae:	e9 1d 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   139b3:	b8 30 a8 01 00       	mov    $0x1a830,%eax
   139b8:	e9 13 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   139bd:	b8 53 a8 01 00       	mov    $0x1a853,%eax
   139c2:	e9 09 02 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   139c7:	b8 70 a8 01 00       	mov    $0x1a870,%eax
   139cc:	e9 ff 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   139d1:	b8 ac a8 01 00       	mov    $0x1a8ac,%eax
   139d6:	e9 f5 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   139db:	b8 dc a8 01 00       	mov    $0x1a8dc,%eax
   139e0:	e9 eb 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   139e5:	b8 28 a9 01 00       	mov    $0x1a928,%eax
   139ea:	e9 e1 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   139ef:	b8 60 a9 01 00       	mov    $0x1a960,%eax
   139f4:	e9 d7 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   139f9:	b8 a0 a9 01 00       	mov    $0x1a9a0,%eax
   139fe:	e9 cd 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13a03:	b8 cc a9 01 00       	mov    $0x1a9cc,%eax
   13a08:	e9 c3 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13a0d:	b8 18 aa 01 00       	mov    $0x1aa18,%eax
   13a12:	e9 b9 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13a17:	b8 6c aa 01 00       	mov    $0x1aa6c,%eax
   13a1c:	e9 af 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13a21:	b8 a0 aa 01 00       	mov    $0x1aaa0,%eax
   13a26:	e9 a5 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13a2b:	b8 f0 aa 01 00       	mov    $0x1aaf0,%eax
   13a30:	e9 9b 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13a35:	b8 2c ab 01 00       	mov    $0x1ab2c,%eax
   13a3a:	e9 91 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13a3f:	b8 8c ab 01 00       	mov    $0x1ab8c,%eax
   13a44:	e9 87 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13a49:	b8 ec ab 01 00       	mov    $0x1abec,%eax
   13a4e:	e9 7d 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13a53:	b8 48 ac 01 00       	mov    $0x1ac48,%eax
   13a58:	e9 73 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13a5d:	b8 8c ac 01 00       	mov    $0x1ac8c,%eax
   13a62:	e9 69 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13a67:	b8 c8 ac 01 00       	mov    $0x1acc8,%eax
   13a6c:	e9 5f 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13a71:	b8 25 ad 01 00       	mov    $0x1ad25,%eax
   13a76:	e9 55 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13a7b:	b8 3d ad 01 00       	mov    $0x1ad3d,%eax
   13a80:	e9 4b 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13a85:	b8 58 ad 01 00       	mov    $0x1ad58,%eax
   13a8a:	e9 41 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13a8f:	b8 94 ad 01 00       	mov    $0x1ad94,%eax
   13a94:	e9 37 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13a99:	b8 c4 ad 01 00       	mov    $0x1adc4,%eax
   13a9e:	e9 2d 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13aa3:	b8 e4 ad 01 00       	mov    $0x1ade4,%eax
   13aa8:	e9 23 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13aad:	b8 04 ae 01 00       	mov    $0x1ae04,%eax
   13ab2:	e9 19 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13ab7:	b8 24 ae 01 00       	mov    $0x1ae24,%eax
   13abc:	e9 0f 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13ac1:	b8 48 ae 01 00       	mov    $0x1ae48,%eax
   13ac6:	e9 05 01 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13acb:	b8 70 ae 01 00       	mov    $0x1ae70,%eax
   13ad0:	e9 fb 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13ad5:	b8 cd ae 01 00       	mov    $0x1aecd,%eax
   13ada:	e9 f1 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13adf:	b8 e8 ae 01 00       	mov    $0x1aee8,%eax
   13ae4:	e9 e7 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13ae9:	b8 24 af 01 00       	mov    $0x1af24,%eax
   13aee:	e9 dd 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13af3:	b8 58 af 01 00       	mov    $0x1af58,%eax
   13af8:	e9 d3 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13afd:	b8 ac af 01 00       	mov    $0x1afac,%eax
   13b02:	e9 c9 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13b07:	b8 f8 af 01 00       	mov    $0x1aff8,%eax
   13b0c:	e9 bf 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13b11:	b8 34 b0 01 00       	mov    $0x1b034,%eax
   13b16:	e9 b5 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13b1b:	b8 58 b0 01 00       	mov    $0x1b058,%eax
   13b20:	e9 ab 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13b25:	b8 78 b0 01 00       	mov    $0x1b078,%eax
   13b2a:	e9 a1 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13b2f:	b8 a0 b0 01 00       	mov    $0x1b0a0,%eax
   13b34:	e9 97 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13b39:	b8 c0 b0 01 00       	mov    $0x1b0c0,%eax
   13b3e:	e9 8d 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13b43:	b8 ec b0 01 00       	mov    $0x1b0ec,%eax
   13b48:	e9 83 00 00 00       	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13b4d:	b8 1b b1 01 00       	mov    $0x1b11b,%eax
   13b52:	eb 7c                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13b54:	b8 33 b1 01 00       	mov    $0x1b133,%eax
   13b59:	eb 75                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13b5b:	b8 4b b1 01 00       	mov    $0x1b14b,%eax
   13b60:	eb 6e                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13b62:	b8 63 b1 01 00       	mov    $0x1b163,%eax
   13b67:	eb 67                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13b69:	b8 84 b1 01 00       	mov    $0x1b184,%eax
   13b6e:	eb 60                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13b70:	b8 d4 b1 01 00       	mov    $0x1b1d4,%eax
   13b75:	eb 59                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13b77:	b8 28 b2 01 00       	mov    $0x1b228,%eax
   13b7c:	eb 52                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13b7e:	b8 7c b2 01 00       	mov    $0x1b27c,%eax
   13b83:	eb 4b                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13b85:	b8 c4 b2 01 00       	mov    $0x1b2c4,%eax
   13b8a:	eb 44                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13b8c:	b8 08 b3 01 00       	mov    $0x1b308,%eax
   13b91:	eb 3d                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13b93:	b8 24 b3 01 00       	mov    $0x1b324,%eax
   13b98:	eb 36                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13b9a:	b8 5c b3 01 00       	mov    $0x1b35c,%eax
   13b9f:	eb 2f                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13ba1:	b8 b0 b3 01 00       	mov    $0x1b3b0,%eax
   13ba6:	eb 28                	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13ba8:	b8 e0 b3 01 00       	mov    $0x1b3e0,%eax
   13bad:	eb 21                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13baf:	b8 30 b4 01 00       	mov    $0x1b430,%eax
   13bb4:	eb 1a                	jmp    13bd0 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13bb6:	b8 5c b4 01 00       	mov    $0x1b45c,%eax
   13bbb:	eb 13                	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13bbd:	b8 88 b4 01 00       	mov    $0x1b488,%eax
   13bc2:	eb 0c                	jmp    13bd0 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13bc4:	b8 ac b4 01 00       	mov    $0x1b4ac,%eax
   13bc9:	eb 05                	jmp    13bd0 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13bcb:	b8 cb b4 01 00       	mov    $0x1b4cb,%eax
}
   13bd0:	5d                   	pop    %ebp
   13bd1:	c3                   	ret    

00013bd2 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13bd2:	55                   	push   %ebp
   13bd3:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13bd5:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd8:	8b 40 28             	mov    0x28(%eax),%eax
   13bdb:	83 f8 01             	cmp    $0x1,%eax
   13bde:	75 08                	jne    13be8 <GetImage+0x16>
   13be0:	8b 45 08             	mov    0x8(%ebp),%eax
   13be3:	8b 40 54             	mov    0x54(%eax),%eax
   13be6:	eb 09                	jmp    13bf1 <GetImage+0x1f>
   13be8:	8b 45 08             	mov    0x8(%ebp),%eax
   13beb:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13bf1:	5d                   	pop    %ebp
   13bf2:	c3                   	ret    

00013bf3 <GetWidth>:

int GetWidth(Context* ctx){
   13bf3:	55                   	push   %ebp
   13bf4:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13bf6:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf9:	8b 40 10             	mov    0x10(%eax),%eax
}
   13bfc:	5d                   	pop    %ebp
   13bfd:	c3                   	ret    

00013bfe <GetHeight>:

int GetHeight(Context* ctx){
   13bfe:	55                   	push   %ebp
   13bff:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13c01:	8b 45 08             	mov    0x8(%ebp),%eax
   13c04:	8b 40 14             	mov    0x14(%eax),%eax
}
   13c07:	5d                   	pop    %ebp
   13c08:	c3                   	ret    

00013c09 <GetImageSize>:

uint GetImageSize(Context* ctx){
   13c09:	55                   	push   %ebp
   13c0a:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13c0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c0f:	8b 50 10             	mov    0x10(%eax),%edx
   13c12:	8b 45 08             	mov    0x8(%ebp),%eax
   13c15:	8b 40 14             	mov    0x14(%eax),%eax
   13c18:	0f af d0             	imul   %eax,%edx
   13c1b:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1e:	8b 40 28             	mov    0x28(%eax),%eax
   13c21:	0f af c2             	imul   %edx,%eax
}
   13c24:	5d                   	pop    %ebp
   13c25:	c3                   	ret    

00013c26 <_Clip>:

uchar _Clip(const int x){
   13c26:	55                   	push   %ebp
   13c27:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13c29:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13c2d:	78 15                	js     13c44 <_Clip+0x1e>
   13c2f:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13c36:	7f 05                	jg     13c3d <_Clip+0x17>
   13c38:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3b:	eb 0c                	jmp    13c49 <_Clip+0x23>
   13c3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13c42:	eb 05                	jmp    13c49 <_Clip+0x23>
   13c44:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13c49:	5d                   	pop    %ebp
   13c4a:	c3                   	ret    

00013c4b <_Skip>:

void _Skip(Context* ctx, int c){
   13c4b:	55                   	push   %ebp
   13c4c:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13c4e:	8b 45 08             	mov    0x8(%ebp),%eax
   13c51:	8b 50 04             	mov    0x4(%eax),%edx
   13c54:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c57:	01 c2                	add    %eax,%edx
   13c59:	8b 45 08             	mov    0x8(%ebp),%eax
   13c5c:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13c5f:	8b 45 08             	mov    0x8(%ebp),%eax
   13c62:	8b 40 08             	mov    0x8(%eax),%eax
   13c65:	2b 45 0c             	sub    0xc(%ebp),%eax
   13c68:	89 c2                	mov    %eax,%edx
   13c6a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c6d:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13c70:	8b 45 08             	mov    0x8(%ebp),%eax
   13c73:	8b 40 0c             	mov    0xc(%eax),%eax
   13c76:	2b 45 0c             	sub    0xc(%ebp),%eax
   13c79:	89 c2                	mov    %eax,%edx
   13c7b:	8b 45 08             	mov    0x8(%ebp),%eax
   13c7e:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13c81:	8b 45 08             	mov    0x8(%ebp),%eax
   13c84:	8b 40 08             	mov    0x8(%eax),%eax
   13c87:	85 c0                	test   %eax,%eax
   13c89:	79 09                	jns    13c94 <_Skip+0x49>
   13c8b:	8b 45 08             	mov    0x8(%ebp),%eax
   13c8e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13c94:	90                   	nop
   13c95:	5d                   	pop    %ebp
   13c96:	c3                   	ret    

00013c97 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13c97:	55                   	push   %ebp
   13c98:	89 e5                	mov    %esp,%ebp
   13c9a:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13c9d:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca0:	8b 40 08             	mov    0x8(%eax),%eax
   13ca3:	83 f8 01             	cmp    $0x1,%eax
   13ca6:	7f 0b                	jg     13cb3 <_DecodeLength+0x1c>
   13ca8:	8b 45 08             	mov    0x8(%ebp),%eax
   13cab:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13cb1:	eb 45                	jmp    13cf8 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13cb3:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb6:	8b 40 04             	mov    0x4(%eax),%eax
   13cb9:	83 ec 0c             	sub    $0xc,%esp
   13cbc:	50                   	push   %eax
   13cbd:	e8 38 00 00 00       	call   13cfa <_Decode2Bytes>
   13cc2:	83 c4 10             	add    $0x10,%esp
   13cc5:	89 c2                	mov    %eax,%edx
   13cc7:	8b 45 08             	mov    0x8(%ebp),%eax
   13cca:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13ccd:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd0:	8b 50 0c             	mov    0xc(%eax),%edx
   13cd3:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd6:	8b 40 08             	mov    0x8(%eax),%eax
   13cd9:	39 c2                	cmp    %eax,%edx
   13cdb:	7e 0b                	jle    13ce8 <_DecodeLength+0x51>
   13cdd:	8b 45 08             	mov    0x8(%ebp),%eax
   13ce0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13ce6:	eb 10                	jmp    13cf8 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13ce8:	83 ec 08             	sub    $0x8,%esp
   13ceb:	6a 02                	push   $0x2
   13ced:	ff 75 08             	pushl  0x8(%ebp)
   13cf0:	e8 56 ff ff ff       	call   13c4b <_Skip>
   13cf5:	83 c4 10             	add    $0x10,%esp
}
   13cf8:	c9                   	leave  
   13cf9:	c3                   	ret    

00013cfa <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13cfa:	55                   	push   %ebp
   13cfb:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13cfd:	8b 45 08             	mov    0x8(%ebp),%eax
   13d00:	0f b6 00             	movzbl (%eax),%eax
   13d03:	0f b6 c0             	movzbl %al,%eax
   13d06:	c1 e0 08             	shl    $0x8,%eax
   13d09:	89 c2                	mov    %eax,%edx
   13d0b:	8b 45 08             	mov    0x8(%ebp),%eax
   13d0e:	83 c0 01             	add    $0x1,%eax
   13d11:	0f b6 00             	movzbl (%eax),%eax
   13d14:	0f b6 c0             	movzbl %al,%eax
   13d17:	09 d0                	or     %edx,%eax
}
   13d19:	5d                   	pop    %ebp
   13d1a:	c3                   	ret    

00013d1b <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13d1b:	55                   	push   %ebp
   13d1c:	89 e5                	mov    %esp,%ebp
   13d1e:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13d21:	8b 45 08             	mov    0x8(%ebp),%eax
   13d24:	8b 55 10             	mov    0x10(%ebp),%edx
   13d27:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13d2a:	8b 45 14             	mov    0x14(%ebp),%eax
   13d2d:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13d32:	89 c2                	mov    %eax,%edx
   13d34:	8b 45 08             	mov    0x8(%ebp),%eax
   13d37:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13d3a:	8b 45 08             	mov    0x8(%ebp),%eax
   13d3d:	8b 40 08             	mov    0x8(%eax),%eax
   13d40:	83 f8 01             	cmp    $0x1,%eax
   13d43:	7e 1d                	jle    13d62 <_DecodeJPEG+0x47>
   13d45:	8b 45 08             	mov    0x8(%ebp),%eax
   13d48:	8b 40 04             	mov    0x4(%eax),%eax
   13d4b:	0f b6 00             	movzbl (%eax),%eax
   13d4e:	3c ff                	cmp    $0xff,%al
   13d50:	75 10                	jne    13d62 <_DecodeJPEG+0x47>
   13d52:	8b 45 08             	mov    0x8(%ebp),%eax
   13d55:	8b 40 04             	mov    0x4(%eax),%eax
   13d58:	83 c0 01             	add    $0x1,%eax
   13d5b:	0f b6 00             	movzbl (%eax),%eax
   13d5e:	3c d8                	cmp    $0xd8,%al
   13d60:	74 0a                	je     13d6c <_DecodeJPEG+0x51>
   13d62:	b8 01 00 00 00       	mov    $0x1,%eax
   13d67:	e9 56 01 00 00       	jmp    13ec2 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13d6c:	6a 02                	push   $0x2
   13d6e:	ff 75 08             	pushl  0x8(%ebp)
   13d71:	e8 d5 fe ff ff       	call   13c4b <_Skip>
   13d76:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13d79:	e9 0a 01 00 00       	jmp    13e88 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   13d81:	8b 40 08             	mov    0x8(%eax),%eax
   13d84:	85 c0                	test   %eax,%eax
   13d86:	78 0d                	js     13d95 <_DecodeJPEG+0x7a>
   13d88:	8b 45 08             	mov    0x8(%ebp),%eax
   13d8b:	8b 40 04             	mov    0x4(%eax),%eax
   13d8e:	0f b6 00             	movzbl (%eax),%eax
   13d91:	3c ff                	cmp    $0xff,%al
   13d93:	74 0a                	je     13d9f <_DecodeJPEG+0x84>
   13d95:	b8 05 00 00 00       	mov    $0x5,%eax
   13d9a:	e9 23 01 00 00       	jmp    13ec2 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13d9f:	6a 02                	push   $0x2
   13da1:	ff 75 08             	pushl  0x8(%ebp)
   13da4:	e8 a2 fe ff ff       	call   13c4b <_Skip>
   13da9:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13dac:	8b 45 08             	mov    0x8(%ebp),%eax
   13daf:	8b 40 04             	mov    0x4(%eax),%eax
   13db2:	83 e8 01             	sub    $0x1,%eax
   13db5:	0f b6 00             	movzbl (%eax),%eax
   13db8:	0f b6 c0             	movzbl %al,%eax
   13dbb:	3d da 00 00 00       	cmp    $0xda,%eax
   13dc0:	74 71                	je     13e33 <_DecodeJPEG+0x118>
   13dc2:	3d da 00 00 00       	cmp    $0xda,%eax
   13dc7:	7f 10                	jg     13dd9 <_DecodeJPEG+0xbe>
   13dc9:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13dce:	74 20                	je     13df0 <_DecodeJPEG+0xd5>
   13dd0:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13dd5:	74 2c                	je     13e03 <_DecodeJPEG+0xe8>
   13dd7:	eb 7d                	jmp    13e56 <_DecodeJPEG+0x13b>
   13dd9:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13dde:	74 43                	je     13e23 <_DecodeJPEG+0x108>
   13de0:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13de5:	74 5f                	je     13e46 <_DecodeJPEG+0x12b>
   13de7:	3d db 00 00 00       	cmp    $0xdb,%eax
   13dec:	74 25                	je     13e13 <_DecodeJPEG+0xf8>
   13dee:	eb 66                	jmp    13e56 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13df0:	83 ec 0c             	sub    $0xc,%esp
   13df3:	ff 75 08             	pushl  0x8(%ebp)
   13df6:	e8 c9 00 00 00       	call   13ec4 <_DecodeSOF>
   13dfb:	83 c4 10             	add    $0x10,%esp
   13dfe:	e9 85 00 00 00       	jmp    13e88 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13e03:	83 ec 0c             	sub    $0xc,%esp
   13e06:	ff 75 08             	pushl  0x8(%ebp)
   13e09:	e8 28 05 00 00       	call   14336 <_DecodeDHT>
   13e0e:	83 c4 10             	add    $0x10,%esp
   13e11:	eb 75                	jmp    13e88 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13e13:	83 ec 0c             	sub    $0xc,%esp
   13e16:	ff 75 08             	pushl  0x8(%ebp)
   13e19:	e8 05 07 00 00       	call   14523 <_DecodeDQT>
   13e1e:	83 c4 10             	add    $0x10,%esp
   13e21:	eb 65                	jmp    13e88 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13e23:	83 ec 0c             	sub    $0xc,%esp
   13e26:	ff 75 08             	pushl  0x8(%ebp)
   13e29:	e8 ff 07 00 00       	call   1462d <_DecodeDRI>
   13e2e:	83 c4 10             	add    $0x10,%esp
   13e31:	eb 55                	jmp    13e88 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13e33:	83 ec 08             	sub    $0x8,%esp
   13e36:	ff 75 0c             	pushl  0xc(%ebp)
   13e39:	ff 75 08             	pushl  0x8(%ebp)
   13e3c:	e8 56 08 00 00       	call   14697 <_DecodeSOS>
   13e41:	83 c4 10             	add    $0x10,%esp
   13e44:	eb 42                	jmp    13e88 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13e46:	83 ec 0c             	sub    $0xc,%esp
   13e49:	ff 75 08             	pushl  0x8(%ebp)
   13e4c:	e8 a8 15 00 00       	call   153f9 <_SkipMarker>
   13e51:	83 c4 10             	add    $0x10,%esp
   13e54:	eb 32                	jmp    13e88 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13e56:	8b 45 08             	mov    0x8(%ebp),%eax
   13e59:	8b 40 04             	mov    0x4(%eax),%eax
   13e5c:	83 e8 01             	sub    $0x1,%eax
   13e5f:	0f b6 00             	movzbl (%eax),%eax
   13e62:	0f b6 c0             	movzbl %al,%eax
   13e65:	25 f0 00 00 00       	and    $0xf0,%eax
   13e6a:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13e6f:	75 10                	jne    13e81 <_DecodeJPEG+0x166>
   13e71:	83 ec 0c             	sub    $0xc,%esp
   13e74:	ff 75 08             	pushl  0x8(%ebp)
   13e77:	e8 7d 15 00 00       	call   153f9 <_SkipMarker>
   13e7c:	83 c4 10             	add    $0x10,%esp
   13e7f:	eb 07                	jmp    13e88 <_DecodeJPEG+0x16d>
                else return Unsupported;
   13e81:	b8 02 00 00 00       	mov    $0x2,%eax
   13e86:	eb 3a                	jmp    13ec2 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13e88:	8b 45 08             	mov    0x8(%ebp),%eax
   13e8b:	8b 00                	mov    (%eax),%eax
   13e8d:	85 c0                	test   %eax,%eax
   13e8f:	0f 84 e9 fe ff ff    	je     13d7e <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13e95:	8b 45 08             	mov    0x8(%ebp),%eax
   13e98:	8b 00                	mov    (%eax),%eax
   13e9a:	83 f8 06             	cmp    $0x6,%eax
   13e9d:	74 07                	je     13ea6 <_DecodeJPEG+0x18b>
   13e9f:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea2:	8b 00                	mov    (%eax),%eax
   13ea4:	eb 1c                	jmp    13ec2 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13ea6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13eaf:	83 ec 0c             	sub    $0xc,%esp
   13eb2:	ff 75 08             	pushl  0x8(%ebp)
   13eb5:	e8 6b 15 00 00       	call   15425 <_Convert>
   13eba:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13ebd:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec0:	8b 00                	mov    (%eax),%eax
 }
   13ec2:	c9                   	leave  
   13ec3:	c3                   	ret    

00013ec4 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13ec4:	55                   	push   %ebp
   13ec5:	89 e5                	mov    %esp,%ebp
   13ec7:	53                   	push   %ebx
   13ec8:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13ecb:	83 ec 0c             	sub    $0xc,%esp
   13ece:	ff 75 08             	pushl  0x8(%ebp)
   13ed1:	e8 c1 fd ff ff       	call   13c97 <_DecodeLength>
   13ed6:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13ed9:	8b 45 08             	mov    0x8(%ebp),%eax
   13edc:	8b 00                	mov    (%eax),%eax
   13ede:	85 c0                	test   %eax,%eax
   13ee0:	0f 85 4a 04 00 00    	jne    14330 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13ee6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee9:	8b 40 0c             	mov    0xc(%eax),%eax
   13eec:	83 f8 08             	cmp    $0x8,%eax
   13eef:	7f 0e                	jg     13eff <_DecodeSOF+0x3b>
   13ef1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ef4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13efa:	e9 32 04 00 00       	jmp    14331 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13eff:	8b 45 08             	mov    0x8(%ebp),%eax
   13f02:	8b 40 04             	mov    0x4(%eax),%eax
   13f05:	0f b6 00             	movzbl (%eax),%eax
   13f08:	3c 08                	cmp    $0x8,%al
   13f0a:	74 0e                	je     13f1a <_DecodeSOF+0x56>
   13f0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f15:	e9 17 04 00 00       	jmp    14331 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13f1a:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1d:	8b 40 04             	mov    0x4(%eax),%eax
   13f20:	83 c0 01             	add    $0x1,%eax
   13f23:	83 ec 0c             	sub    $0xc,%esp
   13f26:	50                   	push   %eax
   13f27:	e8 ce fd ff ff       	call   13cfa <_Decode2Bytes>
   13f2c:	83 c4 10             	add    $0x10,%esp
   13f2f:	89 c2                	mov    %eax,%edx
   13f31:	8b 45 08             	mov    0x8(%ebp),%eax
   13f34:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13f37:	8b 45 08             	mov    0x8(%ebp),%eax
   13f3a:	8b 40 04             	mov    0x4(%eax),%eax
   13f3d:	83 c0 03             	add    $0x3,%eax
   13f40:	83 ec 0c             	sub    $0xc,%esp
   13f43:	50                   	push   %eax
   13f44:	e8 b1 fd ff ff       	call   13cfa <_Decode2Bytes>
   13f49:	83 c4 10             	add    $0x10,%esp
   13f4c:	89 c2                	mov    %eax,%edx
   13f4e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f51:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13f54:	8b 45 08             	mov    0x8(%ebp),%eax
   13f57:	8b 40 04             	mov    0x4(%eax),%eax
   13f5a:	83 c0 05             	add    $0x5,%eax
   13f5d:	0f b6 00             	movzbl (%eax),%eax
   13f60:	0f b6 d0             	movzbl %al,%edx
   13f63:	8b 45 08             	mov    0x8(%ebp),%eax
   13f66:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13f69:	83 ec 08             	sub    $0x8,%esp
   13f6c:	6a 06                	push   $0x6
   13f6e:	ff 75 08             	pushl  0x8(%ebp)
   13f71:	e8 d5 fc ff ff       	call   13c4b <_Skip>
   13f76:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13f79:	8b 45 08             	mov    0x8(%ebp),%eax
   13f7c:	8b 40 28             	mov    0x28(%eax),%eax
   13f7f:	83 f8 01             	cmp    $0x1,%eax
   13f82:	74 13                	je     13f97 <_DecodeSOF+0xd3>
   13f84:	83 f8 03             	cmp    $0x3,%eax
   13f87:	74 0e                	je     13f97 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13f89:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f92:	e9 9a 03 00 00       	jmp    14331 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13f97:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13f98:	8b 45 08             	mov    0x8(%ebp),%eax
   13f9b:	8b 48 0c             	mov    0xc(%eax),%ecx
   13f9e:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa1:	8b 50 28             	mov    0x28(%eax),%edx
   13fa4:	89 d0                	mov    %edx,%eax
   13fa6:	01 c0                	add    %eax,%eax
   13fa8:	01 d0                	add    %edx,%eax
   13faa:	39 c1                	cmp    %eax,%ecx
   13fac:	7d 0e                	jge    13fbc <_DecodeSOF+0xf8>
   13fae:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fb7:	e9 75 03 00 00       	jmp    14331 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   13fbc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13fc3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   13fca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   13fd4:	83 c0 2c             	add    $0x2c,%eax
   13fd7:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13fda:	e9 50 01 00 00       	jmp    1412f <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   13fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   13fe2:	8b 40 04             	mov    0x4(%eax),%eax
   13fe5:	0f b6 00             	movzbl (%eax),%eax
   13fe8:	0f b6 d0             	movzbl %al,%edx
   13feb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fee:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   13ff0:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff3:	8b 40 04             	mov    0x4(%eax),%eax
   13ff6:	83 c0 01             	add    $0x1,%eax
   13ff9:	0f b6 00             	movzbl (%eax),%eax
   13ffc:	c0 e8 04             	shr    $0x4,%al
   13fff:	0f b6 d0             	movzbl %al,%edx
   14002:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14005:	89 50 04             	mov    %edx,0x4(%eax)
   14008:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1400b:	8b 40 04             	mov    0x4(%eax),%eax
   1400e:	85 c0                	test   %eax,%eax
   14010:	75 0e                	jne    14020 <_DecodeSOF+0x15c>
   14012:	8b 45 08             	mov    0x8(%ebp),%eax
   14015:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1401b:	e9 11 03 00 00       	jmp    14331 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   14020:	8b 45 08             	mov    0x8(%ebp),%eax
   14023:	8b 40 04             	mov    0x4(%eax),%eax
   14026:	83 c0 01             	add    $0x1,%eax
   14029:	0f b6 00             	movzbl (%eax),%eax
   1402c:	0f b6 c0             	movzbl %al,%eax
   1402f:	83 e0 0f             	and    $0xf,%eax
   14032:	89 c2                	mov    %eax,%edx
   14034:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14037:	89 50 08             	mov    %edx,0x8(%eax)
   1403a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1403d:	8b 40 08             	mov    0x8(%eax),%eax
   14040:	85 c0                	test   %eax,%eax
   14042:	75 0e                	jne    14052 <_DecodeSOF+0x18e>
   14044:	8b 45 08             	mov    0x8(%ebp),%eax
   14047:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1404d:	e9 df 02 00 00       	jmp    14331 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   14052:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14055:	8b 50 04             	mov    0x4(%eax),%edx
   14058:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1405b:	8b 40 04             	mov    0x4(%eax),%eax
   1405e:	83 e8 01             	sub    $0x1,%eax
   14061:	21 d0                	and    %edx,%eax
   14063:	85 c0                	test   %eax,%eax
   14065:	74 0e                	je     14075 <_DecodeSOF+0x1b1>
   14067:	8b 45 08             	mov    0x8(%ebp),%eax
   1406a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14070:	e9 bc 02 00 00       	jmp    14331 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   14075:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14078:	8b 50 08             	mov    0x8(%eax),%edx
   1407b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1407e:	8b 40 08             	mov    0x8(%eax),%eax
   14081:	83 e8 01             	sub    $0x1,%eax
   14084:	21 d0                	and    %edx,%eax
   14086:	85 c0                	test   %eax,%eax
   14088:	74 0e                	je     14098 <_DecodeSOF+0x1d4>
   1408a:	8b 45 08             	mov    0x8(%ebp),%eax
   1408d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14093:	e9 99 02 00 00       	jmp    14331 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   14098:	8b 45 08             	mov    0x8(%ebp),%eax
   1409b:	8b 40 04             	mov    0x4(%eax),%eax
   1409e:	83 c0 02             	add    $0x2,%eax
   140a1:	0f b6 00             	movzbl (%eax),%eax
   140a4:	0f b6 d0             	movzbl %al,%edx
   140a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140aa:	89 50 18             	mov    %edx,0x18(%eax)
   140ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140b0:	8b 40 18             	mov    0x18(%eax),%eax
   140b3:	25 fc 00 00 00       	and    $0xfc,%eax
   140b8:	85 c0                	test   %eax,%eax
   140ba:	74 0e                	je     140ca <_DecodeSOF+0x206>
   140bc:	8b 45 08             	mov    0x8(%ebp),%eax
   140bf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   140c5:	e9 67 02 00 00       	jmp    14331 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   140ca:	83 ec 08             	sub    $0x8,%esp
   140cd:	6a 03                	push   $0x3
   140cf:	ff 75 08             	pushl  0x8(%ebp)
   140d2:	e8 74 fb ff ff       	call   13c4b <_Skip>
   140d7:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   140da:	8b 45 08             	mov    0x8(%ebp),%eax
   140dd:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   140e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140e6:	8b 40 18             	mov    0x18(%eax),%eax
   140e9:	bb 01 00 00 00       	mov    $0x1,%ebx
   140ee:	89 c1                	mov    %eax,%ecx
   140f0:	d3 e3                	shl    %cl,%ebx
   140f2:	89 d8                	mov    %ebx,%eax
   140f4:	09 c2                	or     %eax,%edx
   140f6:	8b 45 08             	mov    0x8(%ebp),%eax
   140f9:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   140ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14102:	8b 40 04             	mov    0x4(%eax),%eax
   14105:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14108:	7e 09                	jle    14113 <_DecodeSOF+0x24f>
   1410a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1410d:	8b 40 04             	mov    0x4(%eax),%eax
   14110:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14113:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14116:	8b 40 08             	mov    0x8(%eax),%eax
   14119:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1411c:	7e 09                	jle    14127 <_DecodeSOF+0x263>
   1411e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14121:	8b 40 08             	mov    0x8(%eax),%eax
   14124:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14127:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1412b:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1412f:	8b 45 08             	mov    0x8(%ebp),%eax
   14132:	8b 40 28             	mov    0x28(%eax),%eax
   14135:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14138:	0f 8f a1 fe ff ff    	jg     13fdf <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   1413e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14141:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14148:	8b 45 08             	mov    0x8(%ebp),%eax
   1414b:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   1414e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14151:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14158:	8b 45 08             	mov    0x8(%ebp),%eax
   1415b:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   1415e:	8b 45 08             	mov    0x8(%ebp),%eax
   14161:	8b 50 10             	mov    0x10(%eax),%edx
   14164:	8b 45 08             	mov    0x8(%ebp),%eax
   14167:	8b 40 20             	mov    0x20(%eax),%eax
   1416a:	01 d0                	add    %edx,%eax
   1416c:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1416f:	8b 45 08             	mov    0x8(%ebp),%eax
   14172:	8b 58 20             	mov    0x20(%eax),%ebx
   14175:	89 c8                	mov    %ecx,%eax
   14177:	99                   	cltd   
   14178:	f7 fb                	idiv   %ebx
   1417a:	89 c2                	mov    %eax,%edx
   1417c:	8b 45 08             	mov    0x8(%ebp),%eax
   1417f:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   14182:	8b 45 08             	mov    0x8(%ebp),%eax
   14185:	8b 50 14             	mov    0x14(%eax),%edx
   14188:	8b 45 08             	mov    0x8(%ebp),%eax
   1418b:	8b 40 24             	mov    0x24(%eax),%eax
   1418e:	01 d0                	add    %edx,%eax
   14190:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14193:	8b 45 08             	mov    0x8(%ebp),%eax
   14196:	8b 58 24             	mov    0x24(%eax),%ebx
   14199:	89 c8                	mov    %ecx,%eax
   1419b:	99                   	cltd   
   1419c:	f7 fb                	idiv   %ebx
   1419e:	89 c2                	mov    %eax,%edx
   141a0:	8b 45 08             	mov    0x8(%ebp),%eax
   141a3:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   141a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   141ad:	8b 45 08             	mov    0x8(%ebp),%eax
   141b0:	83 c0 2c             	add    $0x2c,%eax
   141b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
   141b6:	e9 fd 00 00 00       	jmp    142b8 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   141bb:	8b 45 08             	mov    0x8(%ebp),%eax
   141be:	8b 50 10             	mov    0x10(%eax),%edx
   141c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141c4:	8b 40 04             	mov    0x4(%eax),%eax
   141c7:	0f af d0             	imul   %eax,%edx
   141ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
   141cd:	01 d0                	add    %edx,%eax
   141cf:	83 e8 01             	sub    $0x1,%eax
   141d2:	99                   	cltd   
   141d3:	f7 7d ec             	idivl  -0x14(%ebp)
   141d6:	89 c2                	mov    %eax,%edx
   141d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141db:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   141de:	8b 45 08             	mov    0x8(%ebp),%eax
   141e1:	8b 50 14             	mov    0x14(%eax),%edx
   141e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141e7:	8b 40 08             	mov    0x8(%eax),%eax
   141ea:	0f af d0             	imul   %eax,%edx
   141ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141f0:	01 d0                	add    %edx,%eax
   141f2:	83 e8 01             	sub    $0x1,%eax
   141f5:	99                   	cltd   
   141f6:	f7 7d f0             	idivl  -0x10(%ebp)
   141f9:	89 c2                	mov    %eax,%edx
   141fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141fe:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14201:	8b 45 08             	mov    0x8(%ebp),%eax
   14204:	8b 50 18             	mov    0x18(%eax),%edx
   14207:	8b 45 08             	mov    0x8(%ebp),%eax
   1420a:	8b 40 20             	mov    0x20(%eax),%eax
   1420d:	0f af d0             	imul   %eax,%edx
   14210:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14213:	8b 40 04             	mov    0x4(%eax),%eax
   14216:	0f af c2             	imul   %edx,%eax
   14219:	99                   	cltd   
   1421a:	f7 7d ec             	idivl  -0x14(%ebp)
   1421d:	89 c2                	mov    %eax,%edx
   1421f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14222:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14225:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14228:	8b 40 0c             	mov    0xc(%eax),%eax
   1422b:	83 f8 02             	cmp    $0x2,%eax
   1422e:	7f 0b                	jg     1423b <_DecodeSOF+0x377>
   14230:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14233:	8b 40 04             	mov    0x4(%eax),%eax
   14236:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14239:	75 16                	jne    14251 <_DecodeSOF+0x38d>
   1423b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1423e:	8b 40 10             	mov    0x10(%eax),%eax
   14241:	83 f8 02             	cmp    $0x2,%eax
   14244:	7f 19                	jg     1425f <_DecodeSOF+0x39b>
   14246:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14249:	8b 40 08             	mov    0x8(%eax),%eax
   1424c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1424f:	74 0e                	je     1425f <_DecodeSOF+0x39b>
   14251:	8b 45 08             	mov    0x8(%ebp),%eax
   14254:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1425a:	e9 d2 00 00 00       	jmp    14331 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   1425f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14262:	8b 48 14             	mov    0x14(%eax),%ecx
   14265:	8b 45 08             	mov    0x8(%ebp),%eax
   14268:	8b 50 1c             	mov    0x1c(%eax),%edx
   1426b:	8b 45 08             	mov    0x8(%ebp),%eax
   1426e:	8b 40 24             	mov    0x24(%eax),%eax
   14271:	0f af d0             	imul   %eax,%edx
   14274:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14277:	8b 40 08             	mov    0x8(%eax),%eax
   1427a:	0f af c2             	imul   %edx,%eax
   1427d:	99                   	cltd   
   1427e:	f7 7d f0             	idivl  -0x10(%ebp)
   14281:	0f af c1             	imul   %ecx,%eax
   14284:	83 ec 0c             	sub    $0xc,%esp
   14287:	50                   	push   %eax
   14288:	e8 45 c5 fe ff       	call   7d2 <malloc>
   1428d:	83 c4 10             	add    $0x10,%esp
   14290:	89 c2                	mov    %eax,%edx
   14292:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14295:	89 50 28             	mov    %edx,0x28(%eax)
   14298:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1429b:	8b 40 28             	mov    0x28(%eax),%eax
   1429e:	85 c0                	test   %eax,%eax
   142a0:	75 0e                	jne    142b0 <_DecodeSOF+0x3ec>
   142a2:	8b 45 08             	mov    0x8(%ebp),%eax
   142a5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   142ab:	e9 81 00 00 00       	jmp    14331 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   142b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   142b4:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   142b8:	8b 45 08             	mov    0x8(%ebp),%eax
   142bb:	8b 40 28             	mov    0x28(%eax),%eax
   142be:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   142c1:	0f 8f f4 fe ff ff    	jg     141bb <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   142c7:	8b 45 08             	mov    0x8(%ebp),%eax
   142ca:	8b 40 28             	mov    0x28(%eax),%eax
   142cd:	83 f8 03             	cmp    $0x3,%eax
   142d0:	75 47                	jne    14319 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   142d2:	8b 45 08             	mov    0x8(%ebp),%eax
   142d5:	8b 50 10             	mov    0x10(%eax),%edx
   142d8:	8b 45 08             	mov    0x8(%ebp),%eax
   142db:	8b 40 14             	mov    0x14(%eax),%eax
   142de:	0f af d0             	imul   %eax,%edx
   142e1:	8b 45 08             	mov    0x8(%ebp),%eax
   142e4:	8b 40 28             	mov    0x28(%eax),%eax
   142e7:	0f af c2             	imul   %edx,%eax
   142ea:	83 ec 0c             	sub    $0xc,%esp
   142ed:	50                   	push   %eax
   142ee:	e8 df c4 fe ff       	call   7d2 <malloc>
   142f3:	83 c4 10             	add    $0x10,%esp
   142f6:	89 c2                	mov    %eax,%edx
   142f8:	8b 45 08             	mov    0x8(%ebp),%eax
   142fb:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14301:	8b 45 08             	mov    0x8(%ebp),%eax
   14304:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1430a:	85 c0                	test   %eax,%eax
   1430c:	75 0b                	jne    14319 <_DecodeSOF+0x455>
   1430e:	8b 45 08             	mov    0x8(%ebp),%eax
   14311:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14317:	eb 18                	jmp    14331 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   14319:	8b 45 08             	mov    0x8(%ebp),%eax
   1431c:	8b 40 0c             	mov    0xc(%eax),%eax
   1431f:	83 ec 08             	sub    $0x8,%esp
   14322:	50                   	push   %eax
   14323:	ff 75 08             	pushl  0x8(%ebp)
   14326:	e8 20 f9 ff ff       	call   13c4b <_Skip>
   1432b:	83 c4 10             	add    $0x10,%esp
   1432e:	eb 01                	jmp    14331 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14330:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14331:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14334:	c9                   	leave  
   14335:	c3                   	ret    

00014336 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   14336:	55                   	push   %ebp
   14337:	89 e5                	mov    %esp,%ebp
   14339:	53                   	push   %ebx
   1433a:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   1433d:	83 ec 0c             	sub    $0xc,%esp
   14340:	ff 75 08             	pushl  0x8(%ebp)
   14343:	e8 4f f9 ff ff       	call   13c97 <_DecodeLength>
   14348:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1434b:	8b 45 08             	mov    0x8(%ebp),%eax
   1434e:	8b 00                	mov    (%eax),%eax
   14350:	85 c0                	test   %eax,%eax
   14352:	0f 85 c5 01 00 00    	jne    1451d <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   14358:	e9 9c 01 00 00       	jmp    144f9 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   1435d:	8b 45 08             	mov    0x8(%ebp),%eax
   14360:	8b 40 04             	mov    0x4(%eax),%eax
   14363:	0f b6 00             	movzbl (%eax),%eax
   14366:	0f b6 c0             	movzbl %al,%eax
   14369:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1436c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1436f:	25 ec 00 00 00       	and    $0xec,%eax
   14374:	85 c0                	test   %eax,%eax
   14376:	74 0e                	je     14386 <_DecodeDHT+0x50>
   14378:	8b 45 08             	mov    0x8(%ebp),%eax
   1437b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14381:	e9 98 01 00 00       	jmp    1451e <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   14386:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14389:	83 e0 02             	and    $0x2,%eax
   1438c:	85 c0                	test   %eax,%eax
   1438e:	74 0e                	je     1439e <_DecodeDHT+0x68>
   14390:	8b 45 08             	mov    0x8(%ebp),%eax
   14393:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14399:	e9 80 01 00 00       	jmp    1451e <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   1439e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143a1:	c1 f8 03             	sar    $0x3,%eax
   143a4:	0b 45 f4             	or     -0xc(%ebp),%eax
   143a7:	83 e0 03             	and    $0x3,%eax
   143aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   143ad:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   143b4:	eb 1c                	jmp    143d2 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   143b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143b9:	8d 50 ff             	lea    -0x1(%eax),%edx
   143bc:	8b 45 08             	mov    0x8(%ebp),%eax
   143bf:	8b 48 04             	mov    0x4(%eax),%ecx
   143c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143c5:	01 c8                	add    %ecx,%eax
   143c7:	0f b6 00             	movzbl (%eax),%eax
   143ca:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   143ce:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   143d2:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   143d6:	7e de                	jle    143b6 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   143d8:	83 ec 08             	sub    $0x8,%esp
   143db:	6a 11                	push   $0x11
   143dd:	ff 75 08             	pushl  0x8(%ebp)
   143e0:	e8 66 f8 ff ff       	call   13c4b <_Skip>
   143e5:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   143e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143eb:	c1 e0 11             	shl    $0x11,%eax
   143ee:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   143f4:	8b 45 08             	mov    0x8(%ebp),%eax
   143f7:	01 d0                	add    %edx,%eax
   143f9:	83 c0 08             	add    $0x8,%eax
   143fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   143ff:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14406:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14409:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1440c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14413:	e9 be 00 00 00       	jmp    144d6 <_DecodeDHT+0x1a0>
            spread >>= 1;
   14418:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   1441b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1441e:	83 e8 01             	sub    $0x1,%eax
   14421:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14426:	0f b6 c0             	movzbl %al,%eax
   14429:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1442c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14430:	0f 84 9b 00 00 00    	je     144d1 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   14436:	8b 45 08             	mov    0x8(%ebp),%eax
   14439:	8b 40 0c             	mov    0xc(%eax),%eax
   1443c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1443f:	7d 0e                	jge    1444f <_DecodeDHT+0x119>
   14441:	8b 45 08             	mov    0x8(%ebp),%eax
   14444:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1444a:	e9 cf 00 00 00       	jmp    1451e <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   1444f:	b8 10 00 00 00       	mov    $0x10,%eax
   14454:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14457:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1445a:	89 c1                	mov    %eax,%ecx
   1445c:	d3 e2                	shl    %cl,%edx
   1445e:	89 d0                	mov    %edx,%eax
   14460:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   14463:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14467:	79 0e                	jns    14477 <_DecodeDHT+0x141>
   14469:	8b 45 08             	mov    0x8(%ebp),%eax
   1446c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14472:	e9 a7 00 00 00       	jmp    1451e <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   14477:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1447e:	eb 36                	jmp    144b6 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   14480:	8b 45 08             	mov    0x8(%ebp),%eax
   14483:	8b 50 04             	mov    0x4(%eax),%edx
   14486:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14489:	01 d0                	add    %edx,%eax
   1448b:	0f b6 00             	movzbl (%eax),%eax
   1448e:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   14490:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   14493:	eb 14                	jmp    144a9 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14495:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14498:	89 c2                	mov    %eax,%edx
   1449a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1449d:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   1449f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   144a2:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   144a5:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   144a9:	89 d8                	mov    %ebx,%eax
   144ab:	8d 58 ff             	lea    -0x1(%eax),%ebx
   144ae:	85 c0                	test   %eax,%eax
   144b0:	75 e3                	jne    14495 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   144b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   144b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144b9:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   144bc:	7c c2                	jl     14480 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   144be:	83 ec 08             	sub    $0x8,%esp
   144c1:	ff 75 e0             	pushl  -0x20(%ebp)
   144c4:	ff 75 08             	pushl  0x8(%ebp)
   144c7:	e8 7f f7 ff ff       	call   13c4b <_Skip>
   144cc:	83 c4 10             	add    $0x10,%esp
   144cf:	eb 01                	jmp    144d2 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   144d1:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   144d2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   144d6:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   144da:	0f 8e 38 ff ff ff    	jle    14418 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   144e0:	eb 0a                	jmp    144ec <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   144e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   144e5:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   144e8:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   144ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144ef:	8d 50 ff             	lea    -0x1(%eax),%edx
   144f2:	89 55 ec             	mov    %edx,-0x14(%ebp)
   144f5:	85 c0                	test   %eax,%eax
   144f7:	75 e9                	jne    144e2 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   144f9:	8b 45 08             	mov    0x8(%ebp),%eax
   144fc:	8b 40 0c             	mov    0xc(%eax),%eax
   144ff:	83 f8 10             	cmp    $0x10,%eax
   14502:	0f 8f 55 fe ff ff    	jg     1435d <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14508:	8b 45 08             	mov    0x8(%ebp),%eax
   1450b:	8b 40 0c             	mov    0xc(%eax),%eax
   1450e:	85 c0                	test   %eax,%eax
   14510:	74 0c                	je     1451e <_DecodeDHT+0x1e8>
   14512:	8b 45 08             	mov    0x8(%ebp),%eax
   14515:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1451b:	eb 01                	jmp    1451e <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   1451d:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1451e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14521:	c9                   	leave  
   14522:	c3                   	ret    

00014523 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14523:	55                   	push   %ebp
   14524:	89 e5                	mov    %esp,%ebp
   14526:	53                   	push   %ebx
   14527:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1452a:	83 ec 0c             	sub    $0xc,%esp
   1452d:	ff 75 08             	pushl  0x8(%ebp)
   14530:	e8 62 f7 ff ff       	call   13c97 <_DecodeLength>
   14535:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14538:	8b 45 08             	mov    0x8(%ebp),%eax
   1453b:	8b 00                	mov    (%eax),%eax
   1453d:	85 c0                	test   %eax,%eax
   1453f:	0f 85 e2 00 00 00    	jne    14627 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   14545:	e9 b8 00 00 00       	jmp    14602 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   1454a:	8b 45 08             	mov    0x8(%ebp),%eax
   1454d:	8b 40 04             	mov    0x4(%eax),%eax
   14550:	0f b6 00             	movzbl (%eax),%eax
   14553:	0f b6 c0             	movzbl %al,%eax
   14556:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14559:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1455c:	25 ec 00 00 00       	and    $0xec,%eax
   14561:	85 c0                	test   %eax,%eax
   14563:	74 0e                	je     14573 <_DecodeDQT+0x50>
   14565:	8b 45 08             	mov    0x8(%ebp),%eax
   14568:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1456e:	e9 b5 00 00 00       	jmp    14628 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   14573:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14576:	83 e0 10             	and    $0x10,%eax
   14579:	85 c0                	test   %eax,%eax
   1457b:	74 0e                	je     1458b <_DecodeDQT+0x68>
   1457d:	8b 45 08             	mov    0x8(%ebp),%eax
   14580:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14586:	e9 9d 00 00 00       	jmp    14628 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   1458b:	8b 45 08             	mov    0x8(%ebp),%eax
   1458e:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   14594:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14597:	bb 01 00 00 00       	mov    $0x1,%ebx
   1459c:	89 c1                	mov    %eax,%ecx
   1459e:	d3 e3                	shl    %cl,%ebx
   145a0:	89 d8                	mov    %ebx,%eax
   145a2:	09 c2                	or     %eax,%edx
   145a4:	8b 45 08             	mov    0x8(%ebp),%eax
   145a7:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   145ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145b0:	c1 e0 06             	shl    $0x6,%eax
   145b3:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   145b9:	8b 45 08             	mov    0x8(%ebp),%eax
   145bc:	01 d0                	add    %edx,%eax
   145be:	83 c0 08             	add    $0x8,%eax
   145c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   145c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   145cb:	eb 1f                	jmp    145ec <_DecodeDQT+0xc9>
   145cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
   145d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145d3:	01 c2                	add    %eax,%edx
   145d5:	8b 45 08             	mov    0x8(%ebp),%eax
   145d8:	8b 40 04             	mov    0x4(%eax),%eax
   145db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   145de:	83 c1 01             	add    $0x1,%ecx
   145e1:	01 c8                	add    %ecx,%eax
   145e3:	0f b6 00             	movzbl (%eax),%eax
   145e6:	88 02                	mov    %al,(%edx)
   145e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   145ec:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   145f0:	7e db                	jle    145cd <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   145f2:	83 ec 08             	sub    $0x8,%esp
   145f5:	6a 41                	push   $0x41
   145f7:	ff 75 08             	pushl  0x8(%ebp)
   145fa:	e8 4c f6 ff ff       	call   13c4b <_Skip>
   145ff:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14602:	8b 45 08             	mov    0x8(%ebp),%eax
   14605:	8b 40 0c             	mov    0xc(%eax),%eax
   14608:	83 f8 40             	cmp    $0x40,%eax
   1460b:	0f 8f 39 ff ff ff    	jg     1454a <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14611:	8b 45 08             	mov    0x8(%ebp),%eax
   14614:	8b 40 0c             	mov    0xc(%eax),%eax
   14617:	85 c0                	test   %eax,%eax
   14619:	74 0d                	je     14628 <_DecodeDQT+0x105>
   1461b:	8b 45 08             	mov    0x8(%ebp),%eax
   1461e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14624:	90                   	nop
   14625:	eb 01                	jmp    14628 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14627:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14628:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1462b:	c9                   	leave  
   1462c:	c3                   	ret    

0001462d <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   1462d:	55                   	push   %ebp
   1462e:	89 e5                	mov    %esp,%ebp
   14630:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14633:	83 ec 0c             	sub    $0xc,%esp
   14636:	ff 75 08             	pushl  0x8(%ebp)
   14639:	e8 59 f6 ff ff       	call   13c97 <_DecodeLength>
   1463e:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14641:	8b 45 08             	mov    0x8(%ebp),%eax
   14644:	8b 00                	mov    (%eax),%eax
   14646:	85 c0                	test   %eax,%eax
   14648:	75 4a                	jne    14694 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   1464a:	8b 45 08             	mov    0x8(%ebp),%eax
   1464d:	8b 40 0c             	mov    0xc(%eax),%eax
   14650:	83 f8 01             	cmp    $0x1,%eax
   14653:	7f 0b                	jg     14660 <_DecodeDRI+0x33>
   14655:	8b 45 08             	mov    0x8(%ebp),%eax
   14658:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1465e:	eb 35                	jmp    14695 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   14660:	8b 45 08             	mov    0x8(%ebp),%eax
   14663:	8b 40 04             	mov    0x4(%eax),%eax
   14666:	83 ec 0c             	sub    $0xc,%esp
   14669:	50                   	push   %eax
   1466a:	e8 8b f6 ff ff       	call   13cfa <_Decode2Bytes>
   1466f:	83 c4 10             	add    $0x10,%esp
   14672:	89 c2                	mov    %eax,%edx
   14674:	8b 45 08             	mov    0x8(%ebp),%eax
   14677:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   1467d:	8b 45 08             	mov    0x8(%ebp),%eax
   14680:	8b 40 0c             	mov    0xc(%eax),%eax
   14683:	83 ec 08             	sub    $0x8,%esp
   14686:	50                   	push   %eax
   14687:	ff 75 08             	pushl  0x8(%ebp)
   1468a:	e8 bc f5 ff ff       	call   13c4b <_Skip>
   1468f:	83 c4 10             	add    $0x10,%esp
   14692:	eb 01                	jmp    14695 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   14694:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   14695:	c9                   	leave  
   14696:	c3                   	ret    

00014697 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   14697:	55                   	push   %ebp
   14698:	89 e5                	mov    %esp,%ebp
   1469a:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   1469d:	8b 45 08             	mov    0x8(%ebp),%eax
   146a0:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   146a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
   146a9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   146b0:	83 ec 0c             	sub    $0xc,%esp
   146b3:	ff 75 08             	pushl  0x8(%ebp)
   146b6:	e8 dc f5 ff ff       	call   13c97 <_DecodeLength>
   146bb:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   146be:	8b 45 08             	mov    0x8(%ebp),%eax
   146c1:	8b 00                	mov    (%eax),%eax
   146c3:	85 c0                	test   %eax,%eax
   146c5:	0f 85 c2 02 00 00    	jne    1498d <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   146cb:	8b 45 08             	mov    0x8(%ebp),%eax
   146ce:	8b 50 0c             	mov    0xc(%eax),%edx
   146d1:	8b 45 08             	mov    0x8(%ebp),%eax
   146d4:	8b 40 28             	mov    0x28(%eax),%eax
   146d7:	83 c0 02             	add    $0x2,%eax
   146da:	01 c0                	add    %eax,%eax
   146dc:	39 c2                	cmp    %eax,%edx
   146de:	7c 16                	jl     146f6 <_DecodeSOS+0x5f>
   146e0:	8b 45 08             	mov    0x8(%ebp),%eax
   146e3:	8b 40 04             	mov    0x4(%eax),%eax
   146e6:	0f b6 00             	movzbl (%eax),%eax
   146e9:	0f b6 d0             	movzbl %al,%edx
   146ec:	8b 45 08             	mov    0x8(%ebp),%eax
   146ef:	8b 40 28             	mov    0x28(%eax),%eax
   146f2:	39 c2                	cmp    %eax,%edx
   146f4:	74 0e                	je     14704 <_DecodeSOS+0x6d>
   146f6:	8b 45 08             	mov    0x8(%ebp),%eax
   146f9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146ff:	e9 8d 02 00 00       	jmp    14991 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14704:	83 ec 08             	sub    $0x8,%esp
   14707:	6a 01                	push   $0x1
   14709:	ff 75 08             	pushl  0x8(%ebp)
   1470c:	e8 3a f5 ff ff       	call   13c4b <_Skip>
   14711:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14714:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1471b:	8b 45 08             	mov    0x8(%ebp),%eax
   1471e:	83 c0 2c             	add    $0x2c,%eax
   14721:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14724:	e9 ba 00 00 00       	jmp    147e3 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   14729:	8b 45 08             	mov    0x8(%ebp),%eax
   1472c:	8b 40 04             	mov    0x4(%eax),%eax
   1472f:	0f b6 00             	movzbl (%eax),%eax
   14732:	0f b6 d0             	movzbl %al,%edx
   14735:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14738:	8b 00                	mov    (%eax),%eax
   1473a:	39 c2                	cmp    %eax,%edx
   1473c:	74 0e                	je     1474c <_DecodeSOS+0xb5>
   1473e:	8b 45 08             	mov    0x8(%ebp),%eax
   14741:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14747:	e9 45 02 00 00       	jmp    14991 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   1474c:	8b 45 08             	mov    0x8(%ebp),%eax
   1474f:	8b 40 04             	mov    0x4(%eax),%eax
   14752:	83 c0 01             	add    $0x1,%eax
   14755:	0f b6 00             	movzbl (%eax),%eax
   14758:	0f b6 c0             	movzbl %al,%eax
   1475b:	25 ec 00 00 00       	and    $0xec,%eax
   14760:	85 c0                	test   %eax,%eax
   14762:	74 0e                	je     14772 <_DecodeSOS+0xdb>
   14764:	8b 45 08             	mov    0x8(%ebp),%eax
   14767:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1476d:	e9 1f 02 00 00       	jmp    14991 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   14772:	8b 45 08             	mov    0x8(%ebp),%eax
   14775:	8b 40 04             	mov    0x4(%eax),%eax
   14778:	83 c0 01             	add    $0x1,%eax
   1477b:	0f b6 00             	movzbl (%eax),%eax
   1477e:	0f b6 c0             	movzbl %al,%eax
   14781:	83 e0 02             	and    $0x2,%eax
   14784:	85 c0                	test   %eax,%eax
   14786:	74 0e                	je     14796 <_DecodeSOS+0xff>
   14788:	8b 45 08             	mov    0x8(%ebp),%eax
   1478b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14791:	e9 fb 01 00 00       	jmp    14991 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14796:	8b 45 08             	mov    0x8(%ebp),%eax
   14799:	8b 40 04             	mov    0x4(%eax),%eax
   1479c:	83 c0 01             	add    $0x1,%eax
   1479f:	0f b6 00             	movzbl (%eax),%eax
   147a2:	c0 e8 04             	shr    $0x4,%al
   147a5:	0f b6 d0             	movzbl %al,%edx
   147a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147ab:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   147ae:	8b 45 08             	mov    0x8(%ebp),%eax
   147b1:	8b 40 04             	mov    0x4(%eax),%eax
   147b4:	83 c0 01             	add    $0x1,%eax
   147b7:	0f b6 00             	movzbl (%eax),%eax
   147ba:	0f b6 c0             	movzbl %al,%eax
   147bd:	83 e0 01             	and    $0x1,%eax
   147c0:	83 c8 02             	or     $0x2,%eax
   147c3:	89 c2                	mov    %eax,%edx
   147c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147c8:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   147cb:	83 ec 08             	sub    $0x8,%esp
   147ce:	6a 02                	push   $0x2
   147d0:	ff 75 08             	pushl  0x8(%ebp)
   147d3:	e8 73 f4 ff ff       	call   13c4b <_Skip>
   147d8:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   147db:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   147df:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   147e3:	8b 45 08             	mov    0x8(%ebp),%eax
   147e6:	8b 40 28             	mov    0x28(%eax),%eax
   147e9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   147ec:	0f 8f 37 ff ff ff    	jg     14729 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   147f2:	8b 45 08             	mov    0x8(%ebp),%eax
   147f5:	8b 40 04             	mov    0x4(%eax),%eax
   147f8:	0f b6 00             	movzbl (%eax),%eax
   147fb:	84 c0                	test   %al,%al
   147fd:	75 10                	jne    1480f <_DecodeSOS+0x178>
   147ff:	8b 45 08             	mov    0x8(%ebp),%eax
   14802:	8b 40 04             	mov    0x4(%eax),%eax
   14805:	83 c0 01             	add    $0x1,%eax
   14808:	0f b6 00             	movzbl (%eax),%eax
   1480b:	3c 3f                	cmp    $0x3f,%al
   1480d:	74 0e                	je     1481d <_DecodeSOS+0x186>
   1480f:	8b 45 08             	mov    0x8(%ebp),%eax
   14812:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14818:	e9 74 01 00 00       	jmp    14991 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   1481d:	8b 45 08             	mov    0x8(%ebp),%eax
   14820:	8b 40 04             	mov    0x4(%eax),%eax
   14823:	83 c0 02             	add    $0x2,%eax
   14826:	0f b6 00             	movzbl (%eax),%eax
   14829:	84 c0                	test   %al,%al
   1482b:	74 0e                	je     1483b <_DecodeSOS+0x1a4>
   1482d:	8b 45 08             	mov    0x8(%ebp),%eax
   14830:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14836:	e9 56 01 00 00       	jmp    14991 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   1483b:	8b 45 08             	mov    0x8(%ebp),%eax
   1483e:	8b 40 0c             	mov    0xc(%eax),%eax
   14841:	83 ec 08             	sub    $0x8,%esp
   14844:	50                   	push   %eax
   14845:	ff 75 08             	pushl  0x8(%ebp)
   14848:	e8 fe f3 ff ff       	call   13c4b <_Skip>
   1484d:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14850:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14857:	e9 17 01 00 00       	jmp    14973 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   1485c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14863:	e9 f8 00 00 00       	jmp    14960 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14868:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1486f:	8b 45 08             	mov    0x8(%ebp),%eax
   14872:	83 c0 2c             	add    $0x2c,%eax
   14875:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14878:	e9 8d 00 00 00       	jmp    1490a <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   1487d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14884:	eb 71                	jmp    148f7 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14886:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1488d:	eb 59                	jmp    148e8 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   1488f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14892:	8b 50 28             	mov    0x28(%eax),%edx
   14895:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14898:	8b 40 08             	mov    0x8(%eax),%eax
   1489b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1489f:	89 c1                	mov    %eax,%ecx
   148a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   148a4:	01 c1                	add    %eax,%ecx
   148a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148a9:	8b 40 14             	mov    0x14(%eax),%eax
   148ac:	0f af c8             	imul   %eax,%ecx
   148af:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148b2:	8b 40 04             	mov    0x4(%eax),%eax
   148b5:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   148b9:	01 c1                	add    %eax,%ecx
   148bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148be:	01 c8                	add    %ecx,%eax
   148c0:	c1 e0 03             	shl    $0x3,%eax
   148c3:	01 d0                	add    %edx,%eax
   148c5:	50                   	push   %eax
   148c6:	ff 75 dc             	pushl  -0x24(%ebp)
   148c9:	ff 75 0c             	pushl  0xc(%ebp)
   148cc:	ff 75 08             	pushl  0x8(%ebp)
   148cf:	e8 bf 00 00 00       	call   14993 <_DecodeBlock>
   148d4:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   148d7:	8b 45 08             	mov    0x8(%ebp),%eax
   148da:	8b 00                	mov    (%eax),%eax
   148dc:	85 c0                	test   %eax,%eax
   148de:	0f 85 ac 00 00 00    	jne    14990 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   148e4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   148e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148eb:	8b 40 04             	mov    0x4(%eax),%eax
   148ee:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   148f1:	7f 9c                	jg     1488f <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   148f3:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   148f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148fa:	8b 40 08             	mov    0x8(%eax),%eax
   148fd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14900:	7f 84                	jg     14886 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14902:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14906:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1490a:	8b 45 08             	mov    0x8(%ebp),%eax
   1490d:	8b 40 28             	mov    0x28(%eax),%eax
   14910:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14913:	0f 8f 64 ff ff ff    	jg     1487d <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14919:	8b 45 08             	mov    0x8(%ebp),%eax
   1491c:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14922:	85 c0                	test   %eax,%eax
   14924:	74 36                	je     1495c <_DecodeSOS+0x2c5>
   14926:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   1492a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1492e:	75 2c                	jne    1495c <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14930:	83 ec 0c             	sub    $0xc,%esp
   14933:	ff 75 08             	pushl  0x8(%ebp)
   14936:	e8 9f 0a 00 00       	call   153da <_ByteAlign>
   1493b:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   1493e:	83 ec 08             	sub    $0x8,%esp
   14941:	6a 10                	push   $0x10
   14943:	ff 75 08             	pushl  0x8(%ebp)
   14946:	e8 ce 04 00 00       	call   14e19 <_GetBits>
   1494b:	83 c4 10             	add    $0x10,%esp
   1494e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   14951:	8b 45 08             	mov    0x8(%ebp),%eax
   14954:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1495a:	eb 35                	jmp    14991 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   1495c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14960:	8b 45 08             	mov    0x8(%ebp),%eax
   14963:	8b 40 18             	mov    0x18(%eax),%eax
   14966:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14969:	0f 8f f9 fe ff ff    	jg     14868 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1496f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14973:	8b 45 08             	mov    0x8(%ebp),%eax
   14976:	8b 40 1c             	mov    0x1c(%eax),%eax
   14979:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1497c:	0f 8f da fe ff ff    	jg     1485c <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14982:	8b 45 08             	mov    0x8(%ebp),%eax
   14985:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   1498b:	eb 04                	jmp    14991 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1498d:	90                   	nop
   1498e:	eb 01                	jmp    14991 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14990:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14991:	c9                   	leave  
   14992:	c3                   	ret    

00014993 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14993:	55                   	push   %ebp
   14994:	89 e5                	mov    %esp,%ebp
   14996:	53                   	push   %ebx
   14997:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   1499a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   149a1:	8b 45 08             	mov    0x8(%ebp),%eax
   149a4:	05 c0 01 08 00       	add    $0x801c0,%eax
   149a9:	83 ec 04             	sub    $0x4,%esp
   149ac:	68 00 01 00 00       	push   $0x100
   149b1:	6a 00                	push   $0x0
   149b3:	50                   	push   %eax
   149b4:	e8 04 b8 fe ff       	call   1bd <memset>
   149b9:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   149bc:	8b 45 10             	mov    0x10(%ebp),%eax
   149bf:	8b 40 20             	mov    0x20(%eax),%eax
   149c2:	c1 e0 11             	shl    $0x11,%eax
   149c5:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   149cb:	8b 45 08             	mov    0x8(%ebp),%eax
   149ce:	01 d0                	add    %edx,%eax
   149d0:	83 c0 08             	add    $0x8,%eax
   149d3:	83 ec 04             	sub    $0x4,%esp
   149d6:	6a 00                	push   $0x0
   149d8:	50                   	push   %eax
   149d9:	ff 75 08             	pushl  0x8(%ebp)
   149dc:	e8 86 01 00 00       	call   14b67 <_GetVLC>
   149e1:	83 c4 10             	add    $0x10,%esp
   149e4:	89 c2                	mov    %eax,%edx
   149e6:	8b 45 10             	mov    0x10(%ebp),%eax
   149e9:	8b 40 24             	mov    0x24(%eax),%eax
   149ec:	01 c2                	add    %eax,%edx
   149ee:	8b 45 10             	mov    0x10(%ebp),%eax
   149f1:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   149f4:	8b 45 10             	mov    0x10(%ebp),%eax
   149f7:	8b 50 24             	mov    0x24(%eax),%edx
   149fa:	8b 45 10             	mov    0x10(%ebp),%eax
   149fd:	8b 48 18             	mov    0x18(%eax),%ecx
   14a00:	8b 45 08             	mov    0x8(%ebp),%eax
   14a03:	c1 e1 06             	shl    $0x6,%ecx
   14a06:	01 c8                	add    %ecx,%eax
   14a08:	05 b8 00 00 00       	add    $0xb8,%eax
   14a0d:	0f b6 00             	movzbl (%eax),%eax
   14a10:	0f b6 c0             	movzbl %al,%eax
   14a13:	0f af d0             	imul   %eax,%edx
   14a16:	8b 45 08             	mov    0x8(%ebp),%eax
   14a19:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14a1f:	8b 45 10             	mov    0x10(%ebp),%eax
   14a22:	8b 40 1c             	mov    0x1c(%eax),%eax
   14a25:	c1 e0 11             	shl    $0x11,%eax
   14a28:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14a2e:	8b 45 08             	mov    0x8(%ebp),%eax
   14a31:	01 d0                	add    %edx,%eax
   14a33:	8d 50 08             	lea    0x8(%eax),%edx
   14a36:	83 ec 04             	sub    $0x4,%esp
   14a39:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14a3c:	50                   	push   %eax
   14a3d:	52                   	push   %edx
   14a3e:	ff 75 08             	pushl  0x8(%ebp)
   14a41:	e8 21 01 00 00       	call   14b67 <_GetVLC>
   14a46:	83 c4 10             	add    $0x10,%esp
   14a49:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14a4c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a50:	84 c0                	test   %al,%al
   14a52:	0f 84 92 00 00 00    	je     14aea <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14a58:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a5c:	0f b6 c0             	movzbl %al,%eax
   14a5f:	83 e0 0f             	and    $0xf,%eax
   14a62:	85 c0                	test   %eax,%eax
   14a64:	75 16                	jne    14a7c <_DecodeBlock+0xe9>
   14a66:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a6a:	3c f0                	cmp    $0xf0,%al
   14a6c:	74 0e                	je     14a7c <_DecodeBlock+0xe9>
   14a6e:	8b 45 08             	mov    0x8(%ebp),%eax
   14a71:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a77:	e9 e6 00 00 00       	jmp    14b62 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14a7c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a80:	c0 e8 04             	shr    $0x4,%al
   14a83:	0f b6 c0             	movzbl %al,%eax
   14a86:	83 c0 01             	add    $0x1,%eax
   14a89:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14a8c:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a90:	7e 0e                	jle    14aa0 <_DecodeBlock+0x10d>
   14a92:	8b 45 08             	mov    0x8(%ebp),%eax
   14a95:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a9b:	e9 c2 00 00 00       	jmp    14b62 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14aa0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
   14aa6:	01 d0                	add    %edx,%eax
   14aa8:	0f b6 00             	movzbl (%eax),%eax
   14aab:	0f be c8             	movsbl %al,%ecx
   14aae:	8b 45 10             	mov    0x10(%ebp),%eax
   14ab1:	8b 50 18             	mov    0x18(%eax),%edx
   14ab4:	8b 45 08             	mov    0x8(%ebp),%eax
   14ab7:	c1 e2 06             	shl    $0x6,%edx
   14aba:	01 c2                	add    %eax,%edx
   14abc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14abf:	01 d0                	add    %edx,%eax
   14ac1:	05 b8 00 00 00       	add    $0xb8,%eax
   14ac6:	0f b6 00             	movzbl (%eax),%eax
   14ac9:	0f b6 c0             	movzbl %al,%eax
   14acc:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14ad0:	89 c2                	mov    %eax,%edx
   14ad2:	8b 45 08             	mov    0x8(%ebp),%eax
   14ad5:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14adb:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14ade:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14ae2:	0f 8e 37 ff ff ff    	jle    14a1f <_DecodeBlock+0x8c>
   14ae8:	eb 01                	jmp    14aeb <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14aea:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14aeb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14af2:	eb 24                	jmp    14b18 <_DecodeBlock+0x185>
   14af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14af7:	05 70 00 02 00       	add    $0x20070,%eax
   14afc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14b03:	8b 45 08             	mov    0x8(%ebp),%eax
   14b06:	01 d0                	add    %edx,%eax
   14b08:	83 ec 0c             	sub    $0xc,%esp
   14b0b:	50                   	push   %eax
   14b0c:	e8 32 03 00 00       	call   14e43 <_RowIDCT>
   14b11:	83 c4 10             	add    $0x10,%esp
   14b14:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14b18:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14b1c:	7e d6                	jle    14af4 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14b1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14b25:	eb 35                	jmp    14b5c <_DecodeBlock+0x1c9>
   14b27:	8b 45 10             	mov    0x10(%ebp),%eax
   14b2a:	8b 40 14             	mov    0x14(%eax),%eax
   14b2d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14b30:	8b 55 14             	mov    0x14(%ebp),%edx
   14b33:	01 d1                	add    %edx,%ecx
   14b35:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14b38:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14b3e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14b45:	8b 55 08             	mov    0x8(%ebp),%edx
   14b48:	01 da                	add    %ebx,%edx
   14b4a:	83 ec 04             	sub    $0x4,%esp
   14b4d:	50                   	push   %eax
   14b4e:	51                   	push   %ecx
   14b4f:	52                   	push   %edx
   14b50:	e8 7b 05 00 00       	call   150d0 <_ColIDCT>
   14b55:	83 c4 10             	add    $0x10,%esp
   14b58:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14b5c:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14b60:	7e c5                	jle    14b27 <_DecodeBlock+0x194>
}
   14b62:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14b65:	c9                   	leave  
   14b66:	c3                   	ret    

00014b67 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14b67:	55                   	push   %ebp
   14b68:	89 e5                	mov    %esp,%ebp
   14b6a:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14b6d:	83 ec 08             	sub    $0x8,%esp
   14b70:	6a 10                	push   $0x10
   14b72:	ff 75 08             	pushl  0x8(%ebp)
   14b75:	e8 c2 00 00 00       	call   14c3c <_ShowBits>
   14b7a:	83 c4 10             	add    $0x10,%esp
   14b7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14b80:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b83:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14b86:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b89:	01 d0                	add    %edx,%eax
   14b8b:	0f b6 00             	movzbl (%eax),%eax
   14b8e:	0f b6 c0             	movzbl %al,%eax
   14b91:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14b94:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b98:	75 13                	jne    14bad <_GetVLC+0x46>
   14b9a:	8b 45 08             	mov    0x8(%ebp),%eax
   14b9d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ba3:	b8 00 00 00 00       	mov    $0x0,%eax
   14ba8:	e9 8d 00 00 00       	jmp    14c3a <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14bad:	83 ec 08             	sub    $0x8,%esp
   14bb0:	ff 75 f0             	pushl  -0x10(%ebp)
   14bb3:	ff 75 08             	pushl  0x8(%ebp)
   14bb6:	e8 25 02 00 00       	call   14de0 <_SkipBits>
   14bbb:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bc1:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bc7:	01 d0                	add    %edx,%eax
   14bc9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14bcd:	0f b6 c0             	movzbl %al,%eax
   14bd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14bd3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14bd7:	74 0a                	je     14be3 <_GetVLC+0x7c>
   14bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bdc:	89 c2                	mov    %eax,%edx
   14bde:	8b 45 10             	mov    0x10(%ebp),%eax
   14be1:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14be3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14be6:	83 e0 0f             	and    $0xf,%eax
   14be9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14bec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14bf0:	75 07                	jne    14bf9 <_GetVLC+0x92>
   14bf2:	b8 00 00 00 00       	mov    $0x0,%eax
   14bf7:	eb 41                	jmp    14c3a <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14bf9:	83 ec 08             	sub    $0x8,%esp
   14bfc:	ff 75 f0             	pushl  -0x10(%ebp)
   14bff:	ff 75 08             	pushl  0x8(%ebp)
   14c02:	e8 12 02 00 00       	call   14e19 <_GetBits>
   14c07:	83 c4 10             	add    $0x10,%esp
   14c0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14c0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c10:	83 e8 01             	sub    $0x1,%eax
   14c13:	ba 01 00 00 00       	mov    $0x1,%edx
   14c18:	89 c1                	mov    %eax,%ecx
   14c1a:	d3 e2                	shl    %cl,%edx
   14c1c:	89 d0                	mov    %edx,%eax
   14c1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14c21:	7e 14                	jle    14c37 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14c23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c26:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14c2b:	89 c1                	mov    %eax,%ecx
   14c2d:	d3 e2                	shl    %cl,%edx
   14c2f:	89 d0                	mov    %edx,%eax
   14c31:	83 c0 01             	add    $0x1,%eax
   14c34:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14c3a:	c9                   	leave  
   14c3b:	c3                   	ret    

00014c3c <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14c3c:	55                   	push   %ebp
   14c3d:	89 e5                	mov    %esp,%ebp
   14c3f:	53                   	push   %ebx
   14c40:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14c43:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14c47:	0f 85 4f 01 00 00    	jne    14d9c <_ShowBits+0x160>
   14c4d:	b8 00 00 00 00       	mov    $0x0,%eax
   14c52:	e9 83 01 00 00       	jmp    14dda <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14c57:	8b 45 08             	mov    0x8(%ebp),%eax
   14c5a:	8b 40 08             	mov    0x8(%eax),%eax
   14c5d:	85 c0                	test   %eax,%eax
   14c5f:	7f 33                	jg     14c94 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14c61:	8b 45 08             	mov    0x8(%ebp),%eax
   14c64:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c6a:	c1 e0 08             	shl    $0x8,%eax
   14c6d:	0c ff                	or     $0xff,%al
   14c6f:	89 c2                	mov    %eax,%edx
   14c71:	8b 45 08             	mov    0x8(%ebp),%eax
   14c74:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14c7a:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7d:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14c83:	8d 50 08             	lea    0x8(%eax),%edx
   14c86:	8b 45 08             	mov    0x8(%ebp),%eax
   14c89:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14c8f:	e9 08 01 00 00       	jmp    14d9c <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14c94:	8b 45 08             	mov    0x8(%ebp),%eax
   14c97:	8b 40 04             	mov    0x4(%eax),%eax
   14c9a:	8d 48 01             	lea    0x1(%eax),%ecx
   14c9d:	8b 55 08             	mov    0x8(%ebp),%edx
   14ca0:	89 4a 04             	mov    %ecx,0x4(%edx)
   14ca3:	0f b6 00             	movzbl (%eax),%eax
   14ca6:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14ca9:	8b 45 08             	mov    0x8(%ebp),%eax
   14cac:	8b 40 08             	mov    0x8(%eax),%eax
   14caf:	8d 50 ff             	lea    -0x1(%eax),%edx
   14cb2:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb5:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14cb8:	8b 45 08             	mov    0x8(%ebp),%eax
   14cbb:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14cc1:	8d 50 08             	lea    0x8(%eax),%edx
   14cc4:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc7:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14ccd:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd0:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14cd6:	c1 e0 08             	shl    $0x8,%eax
   14cd9:	89 c2                	mov    %eax,%edx
   14cdb:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14cdf:	09 c2                	or     %eax,%edx
   14ce1:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce4:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14cea:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14cee:	0f 85 a8 00 00 00    	jne    14d9c <_ShowBits+0x160>
            if(ctx->size){
   14cf4:	8b 45 08             	mov    0x8(%ebp),%eax
   14cf7:	8b 40 08             	mov    0x8(%eax),%eax
   14cfa:	85 c0                	test   %eax,%eax
   14cfc:	0f 84 91 00 00 00    	je     14d93 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14d02:	8b 45 08             	mov    0x8(%ebp),%eax
   14d05:	8b 40 04             	mov    0x4(%eax),%eax
   14d08:	8d 48 01             	lea    0x1(%eax),%ecx
   14d0b:	8b 55 08             	mov    0x8(%ebp),%edx
   14d0e:	89 4a 04             	mov    %ecx,0x4(%edx)
   14d11:	0f b6 00             	movzbl (%eax),%eax
   14d14:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14d17:	8b 45 08             	mov    0x8(%ebp),%eax
   14d1a:	8b 40 08             	mov    0x8(%eax),%eax
   14d1d:	8d 50 ff             	lea    -0x1(%eax),%edx
   14d20:	8b 45 08             	mov    0x8(%ebp),%eax
   14d23:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14d26:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d2a:	85 c0                	test   %eax,%eax
   14d2c:	74 62                	je     14d90 <_ShowBits+0x154>
   14d2e:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14d33:	75 0c                	jne    14d41 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14d35:	8b 45 08             	mov    0x8(%ebp),%eax
   14d38:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14d3f:	eb 5b                	jmp    14d9c <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14d41:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d45:	25 f8 00 00 00       	and    $0xf8,%eax
   14d4a:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14d4f:	74 0b                	je     14d5c <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14d51:	8b 45 08             	mov    0x8(%ebp),%eax
   14d54:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14d5a:	eb 40                	jmp    14d9c <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14d5c:	8b 45 08             	mov    0x8(%ebp),%eax
   14d5f:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14d65:	c1 e0 08             	shl    $0x8,%eax
   14d68:	89 c2                	mov    %eax,%edx
   14d6a:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d6e:	09 c2                	or     %eax,%edx
   14d70:	8b 45 08             	mov    0x8(%ebp),%eax
   14d73:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14d79:	8b 45 08             	mov    0x8(%ebp),%eax
   14d7c:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d82:	8d 50 08             	lea    0x8(%eax),%edx
   14d85:	8b 45 08             	mov    0x8(%ebp),%eax
   14d88:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14d8e:	eb 0c                	jmp    14d9c <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14d90:	90                   	nop
   14d91:	eb 09                	jmp    14d9c <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14d93:	8b 45 08             	mov    0x8(%ebp),%eax
   14d96:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14d9c:	8b 45 08             	mov    0x8(%ebp),%eax
   14d9f:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14da5:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14da8:	0f 8c a9 fe ff ff    	jl     14c57 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14dae:	8b 45 08             	mov    0x8(%ebp),%eax
   14db1:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14db7:	8b 45 08             	mov    0x8(%ebp),%eax
   14dba:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14dc0:	2b 45 0c             	sub    0xc(%ebp),%eax
   14dc3:	89 c1                	mov    %eax,%ecx
   14dc5:	d3 fa                	sar    %cl,%edx
   14dc7:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dca:	bb 01 00 00 00       	mov    $0x1,%ebx
   14dcf:	89 c1                	mov    %eax,%ecx
   14dd1:	d3 e3                	shl    %cl,%ebx
   14dd3:	89 d8                	mov    %ebx,%eax
   14dd5:	83 e8 01             	sub    $0x1,%eax
   14dd8:	21 d0                	and    %edx,%eax
}
   14dda:	83 c4 10             	add    $0x10,%esp
   14ddd:	5b                   	pop    %ebx
   14dde:	5d                   	pop    %ebp
   14ddf:	c3                   	ret    

00014de0 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14de0:	55                   	push   %ebp
   14de1:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14de3:	8b 45 08             	mov    0x8(%ebp),%eax
   14de6:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14dec:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14def:	7d 0e                	jge    14dff <_SkipBits+0x1f>
   14df1:	ff 75 0c             	pushl  0xc(%ebp)
   14df4:	ff 75 08             	pushl  0x8(%ebp)
   14df7:	e8 40 fe ff ff       	call   14c3c <_ShowBits>
   14dfc:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14dff:	8b 45 08             	mov    0x8(%ebp),%eax
   14e02:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e08:	2b 45 0c             	sub    0xc(%ebp),%eax
   14e0b:	89 c2                	mov    %eax,%edx
   14e0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14e10:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14e16:	90                   	nop
   14e17:	c9                   	leave  
   14e18:	c3                   	ret    

00014e19 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14e19:	55                   	push   %ebp
   14e1a:	89 e5                	mov    %esp,%ebp
   14e1c:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14e1f:	ff 75 0c             	pushl  0xc(%ebp)
   14e22:	ff 75 08             	pushl  0x8(%ebp)
   14e25:	e8 12 fe ff ff       	call   14c3c <_ShowBits>
   14e2a:	83 c4 08             	add    $0x8,%esp
   14e2d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14e30:	ff 75 0c             	pushl  0xc(%ebp)
   14e33:	ff 75 08             	pushl  0x8(%ebp)
   14e36:	e8 a5 ff ff ff       	call   14de0 <_SkipBits>
   14e3b:	83 c4 08             	add    $0x8,%esp
    return res;
   14e3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14e41:	c9                   	leave  
   14e42:	c3                   	ret    

00014e43 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14e43:	55                   	push   %ebp
   14e44:	89 e5                	mov    %esp,%ebp
   14e46:	57                   	push   %edi
   14e47:	56                   	push   %esi
   14e48:	53                   	push   %ebx
   14e49:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14e4c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e4f:	83 c0 10             	add    $0x10,%eax
   14e52:	8b 00                	mov    (%eax),%eax
   14e54:	c1 e0 0b             	shl    $0xb,%eax
   14e57:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14e5a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e5d:	8b 40 18             	mov    0x18(%eax),%eax
   14e60:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14e63:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e66:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14e69:	8b 55 08             	mov    0x8(%ebp),%edx
   14e6c:	8b 52 08             	mov    0x8(%edx),%edx
   14e6f:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14e72:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14e75:	8b 55 08             	mov    0x8(%ebp),%edx
   14e78:	8b 52 04             	mov    0x4(%edx),%edx
   14e7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14e7e:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14e81:	8b 55 08             	mov    0x8(%ebp),%edx
   14e84:	8b 52 1c             	mov    0x1c(%edx),%edx
   14e87:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14e8a:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14e8d:	8b 55 08             	mov    0x8(%ebp),%edx
   14e90:	8b 52 14             	mov    0x14(%edx),%edx
   14e93:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14e96:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14e99:	8b 55 08             	mov    0x8(%ebp),%edx
   14e9c:	8b 52 0c             	mov    0xc(%edx),%edx
   14e9f:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14ea2:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14ea5:	85 c0                	test   %eax,%eax
   14ea7:	75 68                	jne    14f11 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14ea9:	8b 45 08             	mov    0x8(%ebp),%eax
   14eac:	8d 48 04             	lea    0x4(%eax),%ecx
   14eaf:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb2:	8d 58 08             	lea    0x8(%eax),%ebx
   14eb5:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb8:	8d 70 0c             	lea    0xc(%eax),%esi
   14ebb:	8b 45 08             	mov    0x8(%ebp),%eax
   14ebe:	8d 78 10             	lea    0x10(%eax),%edi
   14ec1:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec4:	83 c0 14             	add    $0x14,%eax
   14ec7:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14eca:	8b 45 08             	mov    0x8(%ebp),%eax
   14ecd:	83 c0 18             	add    $0x18,%eax
   14ed0:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14ed3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ed6:	8d 50 1c             	lea    0x1c(%eax),%edx
   14ed9:	8b 45 08             	mov    0x8(%ebp),%eax
   14edc:	8b 00                	mov    (%eax),%eax
   14ede:	c1 e0 03             	shl    $0x3,%eax
   14ee1:	89 02                	mov    %eax,(%edx)
   14ee3:	8b 02                	mov    (%edx),%eax
   14ee5:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14ee8:	89 02                	mov    %eax,(%edx)
   14eea:	89 d0                	mov    %edx,%eax
   14eec:	8b 00                	mov    (%eax),%eax
   14eee:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14ef1:	89 02                	mov    %eax,(%edx)
   14ef3:	89 d0                	mov    %edx,%eax
   14ef5:	8b 00                	mov    (%eax),%eax
   14ef7:	89 07                	mov    %eax,(%edi)
   14ef9:	8b 07                	mov    (%edi),%eax
   14efb:	89 06                	mov    %eax,(%esi)
   14efd:	8b 06                	mov    (%esi),%eax
   14eff:	89 03                	mov    %eax,(%ebx)
   14f01:	8b 03                	mov    (%ebx),%eax
   14f03:	89 01                	mov    %eax,(%ecx)
   14f05:	8b 11                	mov    (%ecx),%edx
   14f07:	8b 45 08             	mov    0x8(%ebp),%eax
   14f0a:	89 10                	mov    %edx,(%eax)
        return;
   14f0c:	e9 b7 01 00 00       	jmp    150c8 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14f11:	8b 45 08             	mov    0x8(%ebp),%eax
   14f14:	8b 00                	mov    (%eax),%eax
   14f16:	c1 e0 0b             	shl    $0xb,%eax
   14f19:	83 e8 80             	sub    $0xffffff80,%eax
   14f1c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14f1f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f22:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f25:	01 d0                	add    %edx,%eax
   14f27:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14f2d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14f30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f33:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14f39:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f3c:	01 d0                	add    %edx,%eax
   14f3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14f41:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f44:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14f4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f4d:	01 d0                	add    %edx,%eax
   14f4f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14f52:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14f55:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f58:	01 d0                	add    %edx,%eax
   14f5a:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14f60:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14f63:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f66:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14f6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f6f:	01 d0                	add    %edx,%eax
   14f71:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14f74:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f77:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14f7d:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f80:	01 d0                	add    %edx,%eax
   14f82:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14f85:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f88:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f8b:	01 d0                	add    %edx,%eax
   14f8d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14f90:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f93:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14f96:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14f99:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f9c:	01 d0                	add    %edx,%eax
   14f9e:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14fa4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14fa7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14faa:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   14fb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fb3:	01 d0                	add    %edx,%eax
   14fb5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   14fb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14fbb:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   14fc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fc4:	01 d0                	add    %edx,%eax
   14fc6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   14fc9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14fcc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14fcf:	01 d0                	add    %edx,%eax
   14fd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   14fd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14fd7:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   14fda:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14fdd:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14fe0:	01 d0                	add    %edx,%eax
   14fe2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   14fe5:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14fe8:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   14feb:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14fee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14ff1:	01 d0                	add    %edx,%eax
   14ff3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   14ff6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14ff9:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   14ffc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14fff:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15002:	01 d0                	add    %edx,%eax
   15004:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   15007:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1500a:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1500d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15010:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15013:	01 d0                	add    %edx,%eax
   15015:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1501b:	83 e8 80             	sub    $0xffffff80,%eax
   1501e:	c1 f8 08             	sar    $0x8,%eax
   15021:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15024:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15027:	2b 45 e0             	sub    -0x20(%ebp),%eax
   1502a:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15030:	83 e8 80             	sub    $0xffffff80,%eax
   15033:	c1 f8 08             	sar    $0x8,%eax
   15036:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   15039:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1503c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1503f:	01 d0                	add    %edx,%eax
   15041:	c1 f8 08             	sar    $0x8,%eax
   15044:	89 c2                	mov    %eax,%edx
   15046:	8b 45 08             	mov    0x8(%ebp),%eax
   15049:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   1504b:	8b 45 08             	mov    0x8(%ebp),%eax
   1504e:	83 c0 04             	add    $0x4,%eax
   15051:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15054:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15057:	01 ca                	add    %ecx,%edx
   15059:	c1 fa 08             	sar    $0x8,%edx
   1505c:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   1505e:	8b 45 08             	mov    0x8(%ebp),%eax
   15061:	83 c0 08             	add    $0x8,%eax
   15064:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   15067:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1506a:	01 ca                	add    %ecx,%edx
   1506c:	c1 fa 08             	sar    $0x8,%edx
   1506f:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   15071:	8b 45 08             	mov    0x8(%ebp),%eax
   15074:	83 c0 0c             	add    $0xc,%eax
   15077:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   1507a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1507d:	01 ca                	add    %ecx,%edx
   1507f:	c1 fa 08             	sar    $0x8,%edx
   15082:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   15084:	8b 45 08             	mov    0x8(%ebp),%eax
   15087:	8d 50 10             	lea    0x10(%eax),%edx
   1508a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1508d:	2b 45 dc             	sub    -0x24(%ebp),%eax
   15090:	c1 f8 08             	sar    $0x8,%eax
   15093:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15095:	8b 45 08             	mov    0x8(%ebp),%eax
   15098:	8d 50 14             	lea    0x14(%eax),%edx
   1509b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1509e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   150a1:	c1 f8 08             	sar    $0x8,%eax
   150a4:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   150a6:	8b 45 08             	mov    0x8(%ebp),%eax
   150a9:	8d 50 18             	lea    0x18(%eax),%edx
   150ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150af:	2b 45 ec             	sub    -0x14(%ebp),%eax
   150b2:	c1 f8 08             	sar    $0x8,%eax
   150b5:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   150b7:	8b 45 08             	mov    0x8(%ebp),%eax
   150ba:	8d 50 1c             	lea    0x1c(%eax),%edx
   150bd:	8b 45 d8             	mov    -0x28(%ebp),%eax
   150c0:	2b 45 f0             	sub    -0x10(%ebp),%eax
   150c3:	c1 f8 08             	sar    $0x8,%eax
   150c6:	89 02                	mov    %eax,(%edx)
}
   150c8:	83 c4 38             	add    $0x38,%esp
   150cb:	5b                   	pop    %ebx
   150cc:	5e                   	pop    %esi
   150cd:	5f                   	pop    %edi
   150ce:	5d                   	pop    %ebp
   150cf:	c3                   	ret    

000150d0 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   150d0:	55                   	push   %ebp
   150d1:	89 e5                	mov    %esp,%ebp
   150d3:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   150d6:	8b 45 08             	mov    0x8(%ebp),%eax
   150d9:	83 e8 80             	sub    $0xffffff80,%eax
   150dc:	8b 00                	mov    (%eax),%eax
   150de:	c1 e0 08             	shl    $0x8,%eax
   150e1:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   150e4:	8b 45 08             	mov    0x8(%ebp),%eax
   150e7:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   150ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
   150f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   150f3:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   150f6:	8b 55 08             	mov    0x8(%ebp),%edx
   150f9:	8b 52 40             	mov    0x40(%edx),%edx
   150fc:	89 55 f0             	mov    %edx,-0x10(%ebp)
   150ff:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15102:	8b 55 08             	mov    0x8(%ebp),%edx
   15105:	8b 52 20             	mov    0x20(%edx),%edx
   15108:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1510b:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   1510e:	8b 55 08             	mov    0x8(%ebp),%edx
   15111:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   15117:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1511a:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   1511d:	8b 55 08             	mov    0x8(%ebp),%edx
   15120:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15126:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15129:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1512c:	8b 55 08             	mov    0x8(%ebp),%edx
   1512f:	8b 52 60             	mov    0x60(%edx),%edx
   15132:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15135:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15138:	85 c0                	test   %eax,%eax
   1513a:	75 45                	jne    15181 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   1513c:	8b 45 08             	mov    0x8(%ebp),%eax
   1513f:	8b 00                	mov    (%eax),%eax
   15141:	83 c0 20             	add    $0x20,%eax
   15144:	c1 f8 06             	sar    $0x6,%eax
   15147:	83 e8 80             	sub    $0xffffff80,%eax
   1514a:	50                   	push   %eax
   1514b:	e8 d6 ea ff ff       	call   13c26 <_Clip>
   15150:	83 c4 04             	add    $0x4,%esp
   15153:	0f b6 c0             	movzbl %al,%eax
   15156:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   15159:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   15160:	eb 14                	jmp    15176 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   15162:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15165:	89 c2                	mov    %eax,%edx
   15167:	8b 45 0c             	mov    0xc(%ebp),%eax
   1516a:	88 10                	mov    %dl,(%eax)
            out += stride;
   1516c:	8b 45 10             	mov    0x10(%ebp),%eax
   1516f:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   15172:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   15176:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1517a:	75 e6                	jne    15162 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   1517c:	e9 57 02 00 00       	jmp    153d8 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   15181:	8b 45 08             	mov    0x8(%ebp),%eax
   15184:	8b 00                	mov    (%eax),%eax
   15186:	c1 e0 08             	shl    $0x8,%eax
   15189:	05 00 20 00 00       	add    $0x2000,%eax
   1518e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   15191:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15194:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15197:	01 d0                	add    %edx,%eax
   15199:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   1519f:	83 c0 04             	add    $0x4,%eax
   151a2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   151a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151a8:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   151ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
   151b1:	01 d0                	add    %edx,%eax
   151b3:	c1 f8 03             	sar    $0x3,%eax
   151b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   151b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151bc:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   151c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   151c5:	01 d0                	add    %edx,%eax
   151c7:	c1 f8 03             	sar    $0x3,%eax
   151ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   151cd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   151d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151d3:	01 d0                	add    %edx,%eax
   151d5:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   151db:	83 c0 04             	add    $0x4,%eax
   151de:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   151e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151e4:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   151ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
   151ed:	01 d0                	add    %edx,%eax
   151ef:	c1 f8 03             	sar    $0x3,%eax
   151f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   151f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151f8:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   151fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15201:	01 d0                	add    %edx,%eax
   15203:	c1 f8 03             	sar    $0x3,%eax
   15206:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   15209:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1520c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1520f:	01 d0                	add    %edx,%eax
   15211:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15214:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15217:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1521a:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1521d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15220:	01 d0                	add    %edx,%eax
   15222:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15228:	83 c0 04             	add    $0x4,%eax
   1522b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   1522e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15231:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15237:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1523a:	01 d0                	add    %edx,%eax
   1523c:	c1 f8 03             	sar    $0x3,%eax
   1523f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15242:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15245:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1524b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1524e:	01 d0                	add    %edx,%eax
   15250:	c1 f8 03             	sar    $0x3,%eax
   15253:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   15256:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15259:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1525c:	01 d0                	add    %edx,%eax
   1525e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   15261:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15264:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   15267:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1526a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1526d:	01 d0                	add    %edx,%eax
   1526f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   15272:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15275:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   15278:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1527b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1527e:	01 d0                	add    %edx,%eax
   15280:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   15283:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15286:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   15289:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1528c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1528f:	01 d0                	add    %edx,%eax
   15291:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   15294:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15297:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1529a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1529d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152a0:	01 d0                	add    %edx,%eax
   152a2:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   152a8:	83 e8 80             	sub    $0xffffff80,%eax
   152ab:	c1 f8 08             	sar    $0x8,%eax
   152ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   152b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   152b4:	2b 45 e8             	sub    -0x18(%ebp),%eax
   152b7:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   152bd:	83 e8 80             	sub    $0xffffff80,%eax
   152c0:	c1 f8 08             	sar    $0x8,%eax
   152c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   152c6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   152c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   152cc:	01 d0                	add    %edx,%eax
   152ce:	c1 f8 0e             	sar    $0xe,%eax
   152d1:	83 e8 80             	sub    $0xffffff80,%eax
   152d4:	50                   	push   %eax
   152d5:	e8 4c e9 ff ff       	call   13c26 <_Clip>
   152da:	83 c4 04             	add    $0x4,%esp
   152dd:	89 c2                	mov    %eax,%edx
   152df:	8b 45 0c             	mov    0xc(%ebp),%eax
   152e2:	88 10                	mov    %dl,(%eax)
   152e4:	8b 45 10             	mov    0x10(%ebp),%eax
   152e7:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   152ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
   152ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152f0:	01 d0                	add    %edx,%eax
   152f2:	c1 f8 0e             	sar    $0xe,%eax
   152f5:	83 e8 80             	sub    $0xffffff80,%eax
   152f8:	50                   	push   %eax
   152f9:	e8 28 e9 ff ff       	call   13c26 <_Clip>
   152fe:	83 c4 04             	add    $0x4,%esp
   15301:	89 c2                	mov    %eax,%edx
   15303:	8b 45 0c             	mov    0xc(%ebp),%eax
   15306:	88 10                	mov    %dl,(%eax)
   15308:	8b 45 10             	mov    0x10(%ebp),%eax
   1530b:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   1530e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15311:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15314:	01 d0                	add    %edx,%eax
   15316:	c1 f8 0e             	sar    $0xe,%eax
   15319:	83 e8 80             	sub    $0xffffff80,%eax
   1531c:	50                   	push   %eax
   1531d:	e8 04 e9 ff ff       	call   13c26 <_Clip>
   15322:	83 c4 04             	add    $0x4,%esp
   15325:	89 c2                	mov    %eax,%edx
   15327:	8b 45 0c             	mov    0xc(%ebp),%eax
   1532a:	88 10                	mov    %dl,(%eax)
   1532c:	8b 45 10             	mov    0x10(%ebp),%eax
   1532f:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15332:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15335:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15338:	01 d0                	add    %edx,%eax
   1533a:	c1 f8 0e             	sar    $0xe,%eax
   1533d:	83 e8 80             	sub    $0xffffff80,%eax
   15340:	50                   	push   %eax
   15341:	e8 e0 e8 ff ff       	call   13c26 <_Clip>
   15346:	83 c4 04             	add    $0x4,%esp
   15349:	89 c2                	mov    %eax,%edx
   1534b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1534e:	88 10                	mov    %dl,(%eax)
   15350:	8b 45 10             	mov    0x10(%ebp),%eax
   15353:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   15356:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15359:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1535c:	c1 f8 0e             	sar    $0xe,%eax
   1535f:	83 e8 80             	sub    $0xffffff80,%eax
   15362:	50                   	push   %eax
   15363:	e8 be e8 ff ff       	call   13c26 <_Clip>
   15368:	83 c4 04             	add    $0x4,%esp
   1536b:	89 c2                	mov    %eax,%edx
   1536d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15370:	88 10                	mov    %dl,(%eax)
   15372:	8b 45 10             	mov    0x10(%ebp),%eax
   15375:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   15378:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1537b:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1537e:	c1 f8 0e             	sar    $0xe,%eax
   15381:	83 e8 80             	sub    $0xffffff80,%eax
   15384:	50                   	push   %eax
   15385:	e8 9c e8 ff ff       	call   13c26 <_Clip>
   1538a:	83 c4 04             	add    $0x4,%esp
   1538d:	89 c2                	mov    %eax,%edx
   1538f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15392:	88 10                	mov    %dl,(%eax)
   15394:	8b 45 10             	mov    0x10(%ebp),%eax
   15397:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   1539a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1539d:	2b 45 f4             	sub    -0xc(%ebp),%eax
   153a0:	c1 f8 0e             	sar    $0xe,%eax
   153a3:	83 e8 80             	sub    $0xffffff80,%eax
   153a6:	50                   	push   %eax
   153a7:	e8 7a e8 ff ff       	call   13c26 <_Clip>
   153ac:	83 c4 04             	add    $0x4,%esp
   153af:	89 c2                	mov    %eax,%edx
   153b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   153b4:	88 10                	mov    %dl,(%eax)
   153b6:	8b 45 10             	mov    0x10(%ebp),%eax
   153b9:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   153bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153bf:	2b 45 f8             	sub    -0x8(%ebp),%eax
   153c2:	c1 f8 0e             	sar    $0xe,%eax
   153c5:	83 e8 80             	sub    $0xffffff80,%eax
   153c8:	50                   	push   %eax
   153c9:	e8 58 e8 ff ff       	call   13c26 <_Clip>
   153ce:	83 c4 04             	add    $0x4,%esp
   153d1:	89 c2                	mov    %eax,%edx
   153d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   153d6:	88 10                	mov    %dl,(%eax)
}
   153d8:	c9                   	leave  
   153d9:	c3                   	ret    

000153da <_ByteAlign>:

void _ByteAlign(Context* ctx){
   153da:	55                   	push   %ebp
   153db:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   153dd:	8b 45 08             	mov    0x8(%ebp),%eax
   153e0:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   153e6:	25 f8 00 00 00       	and    $0xf8,%eax
   153eb:	89 c2                	mov    %eax,%edx
   153ed:	8b 45 08             	mov    0x8(%ebp),%eax
   153f0:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   153f6:	90                   	nop
   153f7:	5d                   	pop    %ebp
   153f8:	c3                   	ret    

000153f9 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   153f9:	55                   	push   %ebp
   153fa:	89 e5                	mov    %esp,%ebp
   153fc:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   153ff:	83 ec 0c             	sub    $0xc,%esp
   15402:	ff 75 08             	pushl  0x8(%ebp)
   15405:	e8 8d e8 ff ff       	call   13c97 <_DecodeLength>
   1540a:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   1540d:	8b 45 08             	mov    0x8(%ebp),%eax
   15410:	8b 40 0c             	mov    0xc(%eax),%eax
   15413:	83 ec 08             	sub    $0x8,%esp
   15416:	50                   	push   %eax
   15417:	ff 75 08             	pushl  0x8(%ebp)
   1541a:	e8 2c e8 ff ff       	call   13c4b <_Skip>
   1541f:	83 c4 10             	add    $0x10,%esp
}
   15422:	90                   	nop
   15423:	c9                   	leave  
   15424:	c3                   	ret    

00015425 <_Convert>:

void _Convert(Context* ctx){
   15425:	55                   	push   %ebp
   15426:	89 e5                	mov    %esp,%ebp
   15428:	57                   	push   %edi
   15429:	56                   	push   %esi
   1542a:	53                   	push   %ebx
   1542b:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1542e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15435:	8b 45 08             	mov    0x8(%ebp),%eax
   15438:	83 c0 2c             	add    $0x2c,%eax
   1543b:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1543e:	e9 b2 00 00 00       	jmp    154f5 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15443:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15446:	8b 50 0c             	mov    0xc(%eax),%edx
   15449:	8b 45 08             	mov    0x8(%ebp),%eax
   1544c:	8b 40 10             	mov    0x10(%eax),%eax
   1544f:	39 c2                	cmp    %eax,%edx
   15451:	7d 11                	jge    15464 <_Convert+0x3f>
   15453:	83 ec 08             	sub    $0x8,%esp
   15456:	ff 75 e0             	pushl  -0x20(%ebp)
   15459:	ff 75 08             	pushl  0x8(%ebp)
   1545c:	e8 79 02 00 00       	call   156da <_UpsampleH>
   15461:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15464:	8b 45 08             	mov    0x8(%ebp),%eax
   15467:	8b 00                	mov    (%eax),%eax
   15469:	85 c0                	test   %eax,%eax
   1546b:	0f 85 5d 02 00 00    	jne    156ce <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   15471:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15474:	8b 50 10             	mov    0x10(%eax),%edx
   15477:	8b 45 08             	mov    0x8(%ebp),%eax
   1547a:	8b 40 14             	mov    0x14(%eax),%eax
   1547d:	39 c2                	cmp    %eax,%edx
   1547f:	7d 11                	jge    15492 <_Convert+0x6d>
   15481:	83 ec 08             	sub    $0x8,%esp
   15484:	ff 75 e0             	pushl  -0x20(%ebp)
   15487:	ff 75 08             	pushl  0x8(%ebp)
   1548a:	e8 db 05 00 00       	call   15a6a <_UpsampleV>
   1548f:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15492:	8b 45 08             	mov    0x8(%ebp),%eax
   15495:	8b 00                	mov    (%eax),%eax
   15497:	85 c0                	test   %eax,%eax
   15499:	0f 85 32 02 00 00    	jne    156d1 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   1549f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154a2:	8b 50 0c             	mov    0xc(%eax),%edx
   154a5:	8b 45 08             	mov    0x8(%ebp),%eax
   154a8:	8b 40 10             	mov    0x10(%eax),%eax
   154ab:	39 c2                	cmp    %eax,%edx
   154ad:	7c 94                	jl     15443 <_Convert+0x1e>
   154af:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154b2:	8b 50 10             	mov    0x10(%eax),%edx
   154b5:	8b 45 08             	mov    0x8(%ebp),%eax
   154b8:	8b 40 14             	mov    0x14(%eax),%eax
   154bb:	39 c2                	cmp    %eax,%edx
   154bd:	7c 84                	jl     15443 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   154bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154c2:	8b 50 0c             	mov    0xc(%eax),%edx
   154c5:	8b 45 08             	mov    0x8(%ebp),%eax
   154c8:	8b 40 10             	mov    0x10(%eax),%eax
   154cb:	39 c2                	cmp    %eax,%edx
   154cd:	7c 10                	jl     154df <_Convert+0xba>
   154cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154d2:	8b 50 10             	mov    0x10(%eax),%edx
   154d5:	8b 45 08             	mov    0x8(%ebp),%eax
   154d8:	8b 40 14             	mov    0x14(%eax),%eax
   154db:	39 c2                	cmp    %eax,%edx
   154dd:	7d 0e                	jge    154ed <_Convert+0xc8>
   154df:	8b 45 08             	mov    0x8(%ebp),%eax
   154e2:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   154e8:	e9 e5 01 00 00       	jmp    156d2 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   154ed:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   154f1:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   154f5:	8b 45 08             	mov    0x8(%ebp),%eax
   154f8:	8b 40 28             	mov    0x28(%eax),%eax
   154fb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   154fe:	7f 9f                	jg     1549f <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15500:	8b 45 08             	mov    0x8(%ebp),%eax
   15503:	8b 40 28             	mov    0x28(%eax),%eax
   15506:	83 f8 03             	cmp    $0x3,%eax
   15509:	0f 85 3d 01 00 00    	jne    1564c <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   1550f:	8b 45 08             	mov    0x8(%ebp),%eax
   15512:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15518:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   1551b:	8b 45 08             	mov    0x8(%ebp),%eax
   1551e:	8b 40 54             	mov    0x54(%eax),%eax
   15521:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15524:	8b 45 08             	mov    0x8(%ebp),%eax
   15527:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1552d:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15530:	8b 45 08             	mov    0x8(%ebp),%eax
   15533:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   15539:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   1553c:	8b 45 08             	mov    0x8(%ebp),%eax
   1553f:	8b 40 14             	mov    0x14(%eax),%eax
   15542:	89 45 d8             	mov    %eax,-0x28(%ebp)
   15545:	e9 f3 00 00 00       	jmp    1563d <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   1554a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   15551:	e9 b6 00 00 00       	jmp    1560c <_Convert+0x1e7>
                register int y = py[x] << 8;
   15556:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15559:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1555c:	01 d0                	add    %edx,%eax
   1555e:	0f b6 00             	movzbl (%eax),%eax
   15561:	0f b6 c0             	movzbl %al,%eax
   15564:	c1 e0 08             	shl    $0x8,%eax
   15567:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   15569:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1556c:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1556f:	01 d0                	add    %edx,%eax
   15571:	0f b6 00             	movzbl (%eax),%eax
   15574:	0f b6 c0             	movzbl %al,%eax
   15577:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   1557a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1557d:	8b 45 c8             	mov    -0x38(%ebp),%eax
   15580:	01 d0                	add    %edx,%eax
   15582:	0f b6 00             	movzbl (%eax),%eax
   15585:	0f b6 c0             	movzbl %al,%eax
   15588:	83 c0 80             	add    $0xffffff80,%eax
   1558b:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   1558d:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15590:	8d 46 01             	lea    0x1(%esi),%eax
   15593:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15596:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   15599:	89 c8                	mov    %ecx,%eax
   1559b:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   155a1:	01 d8                	add    %ebx,%eax
   155a3:	83 e8 80             	sub    $0xffffff80,%eax
   155a6:	c1 f8 08             	sar    $0x8,%eax
   155a9:	83 ec 0c             	sub    $0xc,%esp
   155ac:	50                   	push   %eax
   155ad:	e8 74 e6 ff ff       	call   13c26 <_Clip>
   155b2:	83 c4 10             	add    $0x10,%esp
   155b5:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   155b7:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   155ba:	8d 46 01             	lea    0x1(%esi),%eax
   155bd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   155c0:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   155c3:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   155c6:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   155cd:	01 d0                	add    %edx,%eax
   155cf:	83 e8 80             	sub    $0xffffff80,%eax
   155d2:	c1 f8 08             	sar    $0x8,%eax
   155d5:	83 ec 0c             	sub    $0xc,%esp
   155d8:	50                   	push   %eax
   155d9:	e8 48 e6 ff ff       	call   13c26 <_Clip>
   155de:	83 c4 10             	add    $0x10,%esp
   155e1:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   155e3:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   155e6:	8d 46 01             	lea    0x1(%esi),%eax
   155e9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   155ec:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   155f2:	01 d8                	add    %ebx,%eax
   155f4:	83 e8 80             	sub    $0xffffff80,%eax
   155f7:	c1 f8 08             	sar    $0x8,%eax
   155fa:	83 ec 0c             	sub    $0xc,%esp
   155fd:	50                   	push   %eax
   155fe:	e8 23 e6 ff ff       	call   13c26 <_Clip>
   15603:	83 c4 10             	add    $0x10,%esp
   15606:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15608:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1560c:	8b 45 08             	mov    0x8(%ebp),%eax
   1560f:	8b 40 10             	mov    0x10(%eax),%eax
   15612:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15615:	0f 8f 3b ff ff ff    	jg     15556 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   1561b:	8b 45 08             	mov    0x8(%ebp),%eax
   1561e:	8b 40 40             	mov    0x40(%eax),%eax
   15621:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15624:	8b 45 08             	mov    0x8(%ebp),%eax
   15627:	8b 40 6c             	mov    0x6c(%eax),%eax
   1562a:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   1562d:	8b 45 08             	mov    0x8(%ebp),%eax
   15630:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   15636:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   15639:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   1563d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15641:	0f 85 03 ff ff ff    	jne    1554a <_Convert+0x125>
   15647:	e9 86 00 00 00       	jmp    156d2 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   1564c:	8b 45 08             	mov    0x8(%ebp),%eax
   1564f:	8b 50 38             	mov    0x38(%eax),%edx
   15652:	8b 45 08             	mov    0x8(%ebp),%eax
   15655:	8b 40 40             	mov    0x40(%eax),%eax
   15658:	39 c2                	cmp    %eax,%edx
   1565a:	74 76                	je     156d2 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   1565c:	8b 45 08             	mov    0x8(%ebp),%eax
   1565f:	8b 50 54             	mov    0x54(%eax),%edx
   15662:	8b 45 08             	mov    0x8(%ebp),%eax
   15665:	8b 40 40             	mov    0x40(%eax),%eax
   15668:	01 d0                	add    %edx,%eax
   1566a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   1566d:	8b 45 08             	mov    0x8(%ebp),%eax
   15670:	8b 50 54             	mov    0x54(%eax),%edx
   15673:	8b 45 08             	mov    0x8(%ebp),%eax
   15676:	8b 40 38             	mov    0x38(%eax),%eax
   15679:	01 d0                	add    %edx,%eax
   1567b:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1567e:	8b 45 08             	mov    0x8(%ebp),%eax
   15681:	8b 40 3c             	mov    0x3c(%eax),%eax
   15684:	83 e8 01             	sub    $0x1,%eax
   15687:	89 45 bc             	mov    %eax,-0x44(%ebp)
   1568a:	eb 2e                	jmp    156ba <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   1568c:	8b 45 08             	mov    0x8(%ebp),%eax
   1568f:	8b 40 38             	mov    0x38(%eax),%eax
   15692:	83 ec 04             	sub    $0x4,%esp
   15695:	50                   	push   %eax
   15696:	ff 75 c4             	pushl  -0x3c(%ebp)
   15699:	ff 75 c0             	pushl  -0x40(%ebp)
   1569c:	e8 72 ac fe ff       	call   313 <memmove>
   156a1:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   156a4:	8b 45 08             	mov    0x8(%ebp),%eax
   156a7:	8b 40 40             	mov    0x40(%eax),%eax
   156aa:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   156ad:	8b 45 08             	mov    0x8(%ebp),%eax
   156b0:	8b 40 38             	mov    0x38(%eax),%eax
   156b3:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   156b6:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   156ba:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   156be:	75 cc                	jne    1568c <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   156c0:	8b 45 08             	mov    0x8(%ebp),%eax
   156c3:	8b 50 38             	mov    0x38(%eax),%edx
   156c6:	8b 45 08             	mov    0x8(%ebp),%eax
   156c9:	89 50 40             	mov    %edx,0x40(%eax)
   156cc:	eb 04                	jmp    156d2 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   156ce:	90                   	nop
   156cf:	eb 01                	jmp    156d2 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   156d1:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   156d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
   156d5:	5b                   	pop    %ebx
   156d6:	5e                   	pop    %esi
   156d7:	5f                   	pop    %edi
   156d8:	5d                   	pop    %ebp
   156d9:	c3                   	ret    

000156da <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   156da:	55                   	push   %ebp
   156db:	89 e5                	mov    %esp,%ebp
   156dd:	53                   	push   %ebx
   156de:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   156e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   156e4:	8b 40 0c             	mov    0xc(%eax),%eax
   156e7:	83 e8 03             	sub    $0x3,%eax
   156ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   156ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   156f0:	8b 50 0c             	mov    0xc(%eax),%edx
   156f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   156f6:	8b 40 10             	mov    0x10(%eax),%eax
   156f9:	0f af c2             	imul   %edx,%eax
   156fc:	01 c0                	add    %eax,%eax
   156fe:	83 ec 0c             	sub    $0xc,%esp
   15701:	50                   	push   %eax
   15702:	e8 cb b0 fe ff       	call   7d2 <malloc>
   15707:	83 c4 10             	add    $0x10,%esp
   1570a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1570d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15711:	75 0e                	jne    15721 <_UpsampleH+0x47>
   15713:	8b 45 08             	mov    0x8(%ebp),%eax
   15716:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1571c:	e9 44 03 00 00       	jmp    15a65 <_UpsampleH+0x38b>
    lin = c->pixels;
   15721:	8b 45 0c             	mov    0xc(%ebp),%eax
   15724:	8b 40 28             	mov    0x28(%eax),%eax
   15727:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1572a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1572d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15730:	8b 45 0c             	mov    0xc(%ebp),%eax
   15733:	8b 40 10             	mov    0x10(%eax),%eax
   15736:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   15739:	e9 e0 02 00 00       	jmp    15a1e <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   1573e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15741:	0f b6 00             	movzbl (%eax),%eax
   15744:	0f b6 c0             	movzbl %al,%eax
   15747:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1574d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15750:	83 c0 01             	add    $0x1,%eax
   15753:	0f b6 00             	movzbl (%eax),%eax
   15756:	0f b6 c0             	movzbl %al,%eax
   15759:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1575c:	01 d0                	add    %edx,%eax
   1575e:	83 ec 0c             	sub    $0xc,%esp
   15761:	50                   	push   %eax
   15762:	e8 c4 06 00 00       	call   15e2b <CF>
   15767:	83 c4 10             	add    $0x10,%esp
   1576a:	89 c2                	mov    %eax,%edx
   1576c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1576f:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   15771:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15774:	8d 58 01             	lea    0x1(%eax),%ebx
   15777:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1577a:	0f b6 00             	movzbl (%eax),%eax
   1577d:	0f b6 c0             	movzbl %al,%eax
   15780:	6b c8 68             	imul   $0x68,%eax,%ecx
   15783:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15786:	83 c0 01             	add    $0x1,%eax
   15789:	0f b6 00             	movzbl (%eax),%eax
   1578c:	0f b6 d0             	movzbl %al,%edx
   1578f:	89 d0                	mov    %edx,%eax
   15791:	01 c0                	add    %eax,%eax
   15793:	01 d0                	add    %edx,%eax
   15795:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1579c:	01 d0                	add    %edx,%eax
   1579e:	01 c1                	add    %eax,%ecx
   157a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157a3:	83 c0 02             	add    $0x2,%eax
   157a6:	0f b6 00             	movzbl (%eax),%eax
   157a9:	0f b6 d0             	movzbl %al,%edx
   157ac:	89 d0                	mov    %edx,%eax
   157ae:	01 c0                	add    %eax,%eax
   157b0:	01 d0                	add    %edx,%eax
   157b2:	f7 d8                	neg    %eax
   157b4:	01 c8                	add    %ecx,%eax
   157b6:	83 ec 0c             	sub    $0xc,%esp
   157b9:	50                   	push   %eax
   157ba:	e8 6c 06 00 00       	call   15e2b <CF>
   157bf:	83 c4 10             	add    $0x10,%esp
   157c2:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   157c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157c7:	8d 58 02             	lea    0x2(%eax),%ebx
   157ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157cd:	0f b6 00             	movzbl (%eax),%eax
   157d0:	0f b6 c0             	movzbl %al,%eax
   157d3:	c1 e0 02             	shl    $0x2,%eax
   157d6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   157dd:	29 c2                	sub    %eax,%edx
   157df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157e2:	83 c0 01             	add    $0x1,%eax
   157e5:	0f b6 00             	movzbl (%eax),%eax
   157e8:	0f b6 c0             	movzbl %al,%eax
   157eb:	6b c0 6d             	imul   $0x6d,%eax,%eax
   157ee:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   157f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157f4:	83 c0 02             	add    $0x2,%eax
   157f7:	0f b6 00             	movzbl (%eax),%eax
   157fa:	0f b6 d0             	movzbl %al,%edx
   157fd:	89 d0                	mov    %edx,%eax
   157ff:	c1 e0 03             	shl    $0x3,%eax
   15802:	01 d0                	add    %edx,%eax
   15804:	f7 d8                	neg    %eax
   15806:	01 c8                	add    %ecx,%eax
   15808:	83 ec 0c             	sub    $0xc,%esp
   1580b:	50                   	push   %eax
   1580c:	e8 1a 06 00 00       	call   15e2b <CF>
   15811:	83 c4 10             	add    $0x10,%esp
   15814:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15816:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1581d:	e9 fa 00 00 00       	jmp    1591c <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15822:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15825:	01 c0                	add    %eax,%eax
   15827:	8d 50 03             	lea    0x3(%eax),%edx
   1582a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1582d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15830:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15833:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15836:	01 d0                	add    %edx,%eax
   15838:	0f b6 00             	movzbl (%eax),%eax
   1583b:	0f b6 d0             	movzbl %al,%edx
   1583e:	89 d0                	mov    %edx,%eax
   15840:	c1 e0 03             	shl    $0x3,%eax
   15843:	01 d0                	add    %edx,%eax
   15845:	f7 d8                	neg    %eax
   15847:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1584a:	8d 4a 01             	lea    0x1(%edx),%ecx
   1584d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15850:	01 ca                	add    %ecx,%edx
   15852:	0f b6 12             	movzbl (%edx),%edx
   15855:	0f b6 d2             	movzbl %dl,%edx
   15858:	6b d2 6f             	imul   $0x6f,%edx,%edx
   1585b:	01 c2                	add    %eax,%edx
   1585d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15860:	8d 48 02             	lea    0x2(%eax),%ecx
   15863:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15866:	01 c8                	add    %ecx,%eax
   15868:	0f b6 00             	movzbl (%eax),%eax
   1586b:	0f b6 c0             	movzbl %al,%eax
   1586e:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15871:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15874:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15877:	8d 50 03             	lea    0x3(%eax),%edx
   1587a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1587d:	01 d0                	add    %edx,%eax
   1587f:	0f b6 00             	movzbl (%eax),%eax
   15882:	0f b6 d0             	movzbl %al,%edx
   15885:	89 d0                	mov    %edx,%eax
   15887:	01 c0                	add    %eax,%eax
   15889:	01 d0                	add    %edx,%eax
   1588b:	f7 d8                	neg    %eax
   1588d:	01 c8                	add    %ecx,%eax
   1588f:	83 ec 0c             	sub    $0xc,%esp
   15892:	50                   	push   %eax
   15893:	e8 93 05 00 00       	call   15e2b <CF>
   15898:	83 c4 10             	add    $0x10,%esp
   1589b:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   1589d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158a0:	01 c0                	add    %eax,%eax
   158a2:	8d 50 04             	lea    0x4(%eax),%edx
   158a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158a8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   158ab:	8b 55 ec             	mov    -0x14(%ebp),%edx
   158ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158b1:	01 d0                	add    %edx,%eax
   158b3:	0f b6 00             	movzbl (%eax),%eax
   158b6:	0f b6 d0             	movzbl %al,%edx
   158b9:	89 d0                	mov    %edx,%eax
   158bb:	01 c0                	add    %eax,%eax
   158bd:	01 d0                	add    %edx,%eax
   158bf:	f7 d8                	neg    %eax
   158c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   158c4:	8d 4a 01             	lea    0x1(%edx),%ecx
   158c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   158ca:	01 ca                	add    %ecx,%edx
   158cc:	0f b6 12             	movzbl (%edx),%edx
   158cf:	0f b6 d2             	movzbl %dl,%edx
   158d2:	6b d2 1d             	imul   $0x1d,%edx,%edx
   158d5:	01 c2                	add    %eax,%edx
   158d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158da:	8d 48 02             	lea    0x2(%eax),%ecx
   158dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158e0:	01 c8                	add    %ecx,%eax
   158e2:	0f b6 00             	movzbl (%eax),%eax
   158e5:	0f b6 c0             	movzbl %al,%eax
   158e8:	6b c0 6f             	imul   $0x6f,%eax,%eax
   158eb:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158f1:	8d 50 03             	lea    0x3(%eax),%edx
   158f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158f7:	01 d0                	add    %edx,%eax
   158f9:	0f b6 00             	movzbl (%eax),%eax
   158fc:	0f b6 d0             	movzbl %al,%edx
   158ff:	89 d0                	mov    %edx,%eax
   15901:	c1 e0 03             	shl    $0x3,%eax
   15904:	01 d0                	add    %edx,%eax
   15906:	f7 d8                	neg    %eax
   15908:	01 c8                	add    %ecx,%eax
   1590a:	83 ec 0c             	sub    $0xc,%esp
   1590d:	50                   	push   %eax
   1590e:	e8 18 05 00 00       	call   15e2b <CF>
   15913:	83 c4 10             	add    $0x10,%esp
   15916:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15918:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1591c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1591f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15922:	0f 8c fa fe ff ff    	jl     15822 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15928:	8b 45 0c             	mov    0xc(%ebp),%eax
   1592b:	8b 40 14             	mov    0x14(%eax),%eax
   1592e:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15931:	8b 45 0c             	mov    0xc(%ebp),%eax
   15934:	8b 40 0c             	mov    0xc(%eax),%eax
   15937:	01 c0                	add    %eax,%eax
   15939:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   1593c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1593f:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15942:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15945:	83 e8 01             	sub    $0x1,%eax
   15948:	0f b6 00             	movzbl (%eax),%eax
   1594b:	0f b6 c0             	movzbl %al,%eax
   1594e:	c1 e0 02             	shl    $0x2,%eax
   15951:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15958:	29 c2                	sub    %eax,%edx
   1595a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1595d:	83 e8 02             	sub    $0x2,%eax
   15960:	0f b6 00             	movzbl (%eax),%eax
   15963:	0f b6 c0             	movzbl %al,%eax
   15966:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15969:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1596c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1596f:	83 e8 03             	sub    $0x3,%eax
   15972:	0f b6 00             	movzbl (%eax),%eax
   15975:	0f b6 d0             	movzbl %al,%edx
   15978:	89 d0                	mov    %edx,%eax
   1597a:	c1 e0 03             	shl    $0x3,%eax
   1597d:	01 d0                	add    %edx,%eax
   1597f:	f7 d8                	neg    %eax
   15981:	01 c8                	add    %ecx,%eax
   15983:	83 ec 0c             	sub    $0xc,%esp
   15986:	50                   	push   %eax
   15987:	e8 9f 04 00 00       	call   15e2b <CF>
   1598c:	83 c4 10             	add    $0x10,%esp
   1598f:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15991:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15994:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15997:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1599a:	83 e8 01             	sub    $0x1,%eax
   1599d:	0f b6 00             	movzbl (%eax),%eax
   159a0:	0f b6 c0             	movzbl %al,%eax
   159a3:	6b c8 68             	imul   $0x68,%eax,%ecx
   159a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159a9:	83 e8 02             	sub    $0x2,%eax
   159ac:	0f b6 00             	movzbl (%eax),%eax
   159af:	0f b6 d0             	movzbl %al,%edx
   159b2:	89 d0                	mov    %edx,%eax
   159b4:	01 c0                	add    %eax,%eax
   159b6:	01 d0                	add    %edx,%eax
   159b8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   159bf:	01 d0                	add    %edx,%eax
   159c1:	01 c1                	add    %eax,%ecx
   159c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159c6:	83 e8 03             	sub    $0x3,%eax
   159c9:	0f b6 00             	movzbl (%eax),%eax
   159cc:	0f b6 d0             	movzbl %al,%edx
   159cf:	89 d0                	mov    %edx,%eax
   159d1:	01 c0                	add    %eax,%eax
   159d3:	01 d0                	add    %edx,%eax
   159d5:	f7 d8                	neg    %eax
   159d7:	01 c8                	add    %ecx,%eax
   159d9:	83 ec 0c             	sub    $0xc,%esp
   159dc:	50                   	push   %eax
   159dd:	e8 49 04 00 00       	call   15e2b <CF>
   159e2:	83 c4 10             	add    $0x10,%esp
   159e5:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   159e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159ea:	8d 58 ff             	lea    -0x1(%eax),%ebx
   159ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159f0:	83 e8 01             	sub    $0x1,%eax
   159f3:	0f b6 00             	movzbl (%eax),%eax
   159f6:	0f b6 c0             	movzbl %al,%eax
   159f9:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   159ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a02:	83 e8 02             	sub    $0x2,%eax
   15a05:	0f b6 00             	movzbl (%eax),%eax
   15a08:	0f b6 c0             	movzbl %al,%eax
   15a0b:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a0e:	01 d0                	add    %edx,%eax
   15a10:	83 ec 0c             	sub    $0xc,%esp
   15a13:	50                   	push   %eax
   15a14:	e8 12 04 00 00       	call   15e2b <CF>
   15a19:	83 c4 10             	add    $0x10,%esp
   15a1c:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15a1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15a21:	8d 50 ff             	lea    -0x1(%eax),%edx
   15a24:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15a27:	85 c0                	test   %eax,%eax
   15a29:	0f 85 0f fd ff ff    	jne    1573e <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15a2f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a32:	8b 40 0c             	mov    0xc(%eax),%eax
   15a35:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15a38:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a3b:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15a3e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a41:	8b 50 0c             	mov    0xc(%eax),%edx
   15a44:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a47:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15a4a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a4d:	8b 40 28             	mov    0x28(%eax),%eax
   15a50:	83 ec 0c             	sub    $0xc,%esp
   15a53:	50                   	push   %eax
   15a54:	e8 37 ac fe ff       	call   690 <free>
   15a59:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15a5c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a5f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15a62:	89 50 28             	mov    %edx,0x28(%eax)
}
   15a65:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15a68:	c9                   	leave  
   15a69:	c3                   	ret    

00015a6a <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15a6a:	55                   	push   %ebp
   15a6b:	89 e5                	mov    %esp,%ebp
   15a6d:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15a70:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a73:	8b 40 0c             	mov    0xc(%eax),%eax
   15a76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15a79:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a7c:	8b 40 14             	mov    0x14(%eax),%eax
   15a7f:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15a82:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15a85:	01 c0                	add    %eax,%eax
   15a87:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15a8a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a8d:	8b 50 0c             	mov    0xc(%eax),%edx
   15a90:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a93:	8b 40 10             	mov    0x10(%eax),%eax
   15a96:	0f af c2             	imul   %edx,%eax
   15a99:	01 c0                	add    %eax,%eax
   15a9b:	83 ec 0c             	sub    $0xc,%esp
   15a9e:	50                   	push   %eax
   15a9f:	e8 2e ad fe ff       	call   7d2 <malloc>
   15aa4:	83 c4 10             	add    $0x10,%esp
   15aa7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15aaa:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15aae:	75 0e                	jne    15abe <_UpsampleV+0x54>
   15ab0:	8b 45 08             	mov    0x8(%ebp),%eax
   15ab3:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15ab9:	e9 6b 03 00 00       	jmp    15e29 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15abe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15ac5:	e9 1d 03 00 00       	jmp    15de7 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15aca:	8b 45 0c             	mov    0xc(%ebp),%eax
   15acd:	8b 50 28             	mov    0x28(%eax),%edx
   15ad0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15ad3:	01 d0                	add    %edx,%eax
   15ad5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15ad8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15adb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15ade:	01 d0                	add    %edx,%eax
   15ae0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15ae3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ae6:	0f b6 00             	movzbl (%eax),%eax
   15ae9:	0f b6 c0             	movzbl %al,%eax
   15aec:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15af2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15af5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15af8:	01 c8                	add    %ecx,%eax
   15afa:	0f b6 00             	movzbl (%eax),%eax
   15afd:	0f b6 c0             	movzbl %al,%eax
   15b00:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15b03:	01 d0                	add    %edx,%eax
   15b05:	83 ec 0c             	sub    $0xc,%esp
   15b08:	50                   	push   %eax
   15b09:	e8 1d 03 00 00       	call   15e2b <CF>
   15b0e:	83 c4 10             	add    $0x10,%esp
   15b11:	89 c2                	mov    %eax,%edx
   15b13:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b16:	88 10                	mov    %dl,(%eax)
   15b18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b1b:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15b1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b21:	0f b6 00             	movzbl (%eax),%eax
   15b24:	0f b6 c0             	movzbl %al,%eax
   15b27:	6b c8 68             	imul   $0x68,%eax,%ecx
   15b2a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b30:	01 d0                	add    %edx,%eax
   15b32:	0f b6 00             	movzbl (%eax),%eax
   15b35:	0f b6 d0             	movzbl %al,%edx
   15b38:	89 d0                	mov    %edx,%eax
   15b3a:	01 c0                	add    %eax,%eax
   15b3c:	01 d0                	add    %edx,%eax
   15b3e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b45:	01 d0                	add    %edx,%eax
   15b47:	01 c1                	add    %eax,%ecx
   15b49:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b4f:	01 d0                	add    %edx,%eax
   15b51:	0f b6 00             	movzbl (%eax),%eax
   15b54:	0f b6 d0             	movzbl %al,%edx
   15b57:	89 d0                	mov    %edx,%eax
   15b59:	01 c0                	add    %eax,%eax
   15b5b:	01 d0                	add    %edx,%eax
   15b5d:	f7 d8                	neg    %eax
   15b5f:	01 c8                	add    %ecx,%eax
   15b61:	83 ec 0c             	sub    $0xc,%esp
   15b64:	50                   	push   %eax
   15b65:	e8 c1 02 00 00       	call   15e2b <CF>
   15b6a:	83 c4 10             	add    $0x10,%esp
   15b6d:	89 c2                	mov    %eax,%edx
   15b6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b72:	88 10                	mov    %dl,(%eax)
   15b74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b77:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15b7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b7d:	0f b6 00             	movzbl (%eax),%eax
   15b80:	0f b6 c0             	movzbl %al,%eax
   15b83:	c1 e0 02             	shl    $0x2,%eax
   15b86:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b8d:	89 d1                	mov    %edx,%ecx
   15b8f:	29 c1                	sub    %eax,%ecx
   15b91:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b94:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b97:	01 d0                	add    %edx,%eax
   15b99:	0f b6 00             	movzbl (%eax),%eax
   15b9c:	0f b6 c0             	movzbl %al,%eax
   15b9f:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15ba2:	01 c1                	add    %eax,%ecx
   15ba4:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15baa:	01 d0                	add    %edx,%eax
   15bac:	0f b6 00             	movzbl (%eax),%eax
   15baf:	0f b6 d0             	movzbl %al,%edx
   15bb2:	89 d0                	mov    %edx,%eax
   15bb4:	c1 e0 03             	shl    $0x3,%eax
   15bb7:	01 d0                	add    %edx,%eax
   15bb9:	f7 d8                	neg    %eax
   15bbb:	01 c8                	add    %ecx,%eax
   15bbd:	83 ec 0c             	sub    $0xc,%esp
   15bc0:	50                   	push   %eax
   15bc1:	e8 65 02 00 00       	call   15e2b <CF>
   15bc6:	83 c4 10             	add    $0x10,%esp
   15bc9:	89 c2                	mov    %eax,%edx
   15bcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bce:	88 10                	mov    %dl,(%eax)
   15bd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15bd3:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15bd6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bd9:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
   15bdf:	8b 40 10             	mov    0x10(%eax),%eax
   15be2:	83 e8 03             	sub    $0x3,%eax
   15be5:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15be8:	e9 e6 00 00 00       	jmp    15cd3 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15bed:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bf0:	f7 d8                	neg    %eax
   15bf2:	89 c2                	mov    %eax,%edx
   15bf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bf7:	01 d0                	add    %edx,%eax
   15bf9:	0f b6 00             	movzbl (%eax),%eax
   15bfc:	0f b6 d0             	movzbl %al,%edx
   15bff:	89 d0                	mov    %edx,%eax
   15c01:	c1 e0 03             	shl    $0x3,%eax
   15c04:	01 d0                	add    %edx,%eax
   15c06:	f7 d8                	neg    %eax
   15c08:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15c0b:	0f b6 12             	movzbl (%edx),%edx
   15c0e:	0f b6 d2             	movzbl %dl,%edx
   15c11:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15c14:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15c17:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c1d:	01 d0                	add    %edx,%eax
   15c1f:	0f b6 00             	movzbl (%eax),%eax
   15c22:	0f b6 c0             	movzbl %al,%eax
   15c25:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15c28:	01 c1                	add    %eax,%ecx
   15c2a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c30:	01 d0                	add    %edx,%eax
   15c32:	0f b6 00             	movzbl (%eax),%eax
   15c35:	0f b6 d0             	movzbl %al,%edx
   15c38:	89 d0                	mov    %edx,%eax
   15c3a:	01 c0                	add    %eax,%eax
   15c3c:	01 d0                	add    %edx,%eax
   15c3e:	f7 d8                	neg    %eax
   15c40:	01 c8                	add    %ecx,%eax
   15c42:	83 ec 0c             	sub    $0xc,%esp
   15c45:	50                   	push   %eax
   15c46:	e8 e0 01 00 00       	call   15e2b <CF>
   15c4b:	83 c4 10             	add    $0x10,%esp
   15c4e:	89 c2                	mov    %eax,%edx
   15c50:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c53:	88 10                	mov    %dl,(%eax)
   15c55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c58:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15c5b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c5e:	f7 d8                	neg    %eax
   15c60:	89 c2                	mov    %eax,%edx
   15c62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c65:	01 d0                	add    %edx,%eax
   15c67:	0f b6 00             	movzbl (%eax),%eax
   15c6a:	0f b6 d0             	movzbl %al,%edx
   15c6d:	89 d0                	mov    %edx,%eax
   15c6f:	01 c0                	add    %eax,%eax
   15c71:	01 d0                	add    %edx,%eax
   15c73:	f7 d8                	neg    %eax
   15c75:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15c78:	0f b6 12             	movzbl (%edx),%edx
   15c7b:	0f b6 d2             	movzbl %dl,%edx
   15c7e:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15c81:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15c84:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c87:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c8a:	01 d0                	add    %edx,%eax
   15c8c:	0f b6 00             	movzbl (%eax),%eax
   15c8f:	0f b6 c0             	movzbl %al,%eax
   15c92:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15c95:	01 c1                	add    %eax,%ecx
   15c97:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c9d:	01 d0                	add    %edx,%eax
   15c9f:	0f b6 00             	movzbl (%eax),%eax
   15ca2:	0f b6 d0             	movzbl %al,%edx
   15ca5:	89 d0                	mov    %edx,%eax
   15ca7:	c1 e0 03             	shl    $0x3,%eax
   15caa:	01 d0                	add    %edx,%eax
   15cac:	f7 d8                	neg    %eax
   15cae:	01 c8                	add    %ecx,%eax
   15cb0:	83 ec 0c             	sub    $0xc,%esp
   15cb3:	50                   	push   %eax
   15cb4:	e8 72 01 00 00       	call   15e2b <CF>
   15cb9:	83 c4 10             	add    $0x10,%esp
   15cbc:	89 c2                	mov    %eax,%edx
   15cbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15cc1:	88 10                	mov    %dl,(%eax)
   15cc3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15cc6:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15cc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ccc:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15ccf:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15cd3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15cd7:	0f 85 10 ff ff ff    	jne    15bed <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15cdd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ce0:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ce6:	0f b6 00             	movzbl (%eax),%eax
   15ce9:	0f b6 c0             	movzbl %al,%eax
   15cec:	c1 e0 02             	shl    $0x2,%eax
   15cef:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15cf6:	29 c2                	sub    %eax,%edx
   15cf8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cfb:	f7 d8                	neg    %eax
   15cfd:	89 c1                	mov    %eax,%ecx
   15cff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d02:	01 c8                	add    %ecx,%eax
   15d04:	0f b6 00             	movzbl (%eax),%eax
   15d07:	0f b6 c0             	movzbl %al,%eax
   15d0a:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15d0d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15d10:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15d13:	f7 d8                	neg    %eax
   15d15:	89 c2                	mov    %eax,%edx
   15d17:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d1a:	01 d0                	add    %edx,%eax
   15d1c:	0f b6 00             	movzbl (%eax),%eax
   15d1f:	0f b6 d0             	movzbl %al,%edx
   15d22:	89 d0                	mov    %edx,%eax
   15d24:	c1 e0 03             	shl    $0x3,%eax
   15d27:	01 d0                	add    %edx,%eax
   15d29:	f7 d8                	neg    %eax
   15d2b:	01 c8                	add    %ecx,%eax
   15d2d:	83 ec 0c             	sub    $0xc,%esp
   15d30:	50                   	push   %eax
   15d31:	e8 f5 00 00 00       	call   15e2b <CF>
   15d36:	83 c4 10             	add    $0x10,%esp
   15d39:	89 c2                	mov    %eax,%edx
   15d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d3e:	88 10                	mov    %dl,(%eax)
   15d40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d43:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15d46:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d49:	0f b6 00             	movzbl (%eax),%eax
   15d4c:	0f b6 c0             	movzbl %al,%eax
   15d4f:	6b c8 68             	imul   $0x68,%eax,%ecx
   15d52:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d55:	f7 d8                	neg    %eax
   15d57:	89 c2                	mov    %eax,%edx
   15d59:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d5c:	01 d0                	add    %edx,%eax
   15d5e:	0f b6 00             	movzbl (%eax),%eax
   15d61:	0f b6 d0             	movzbl %al,%edx
   15d64:	89 d0                	mov    %edx,%eax
   15d66:	01 c0                	add    %eax,%eax
   15d68:	01 d0                	add    %edx,%eax
   15d6a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15d71:	01 d0                	add    %edx,%eax
   15d73:	01 c1                	add    %eax,%ecx
   15d75:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15d78:	f7 d8                	neg    %eax
   15d7a:	89 c2                	mov    %eax,%edx
   15d7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d7f:	01 d0                	add    %edx,%eax
   15d81:	0f b6 00             	movzbl (%eax),%eax
   15d84:	0f b6 d0             	movzbl %al,%edx
   15d87:	89 d0                	mov    %edx,%eax
   15d89:	01 c0                	add    %eax,%eax
   15d8b:	01 d0                	add    %edx,%eax
   15d8d:	f7 d8                	neg    %eax
   15d8f:	01 c8                	add    %ecx,%eax
   15d91:	83 ec 0c             	sub    $0xc,%esp
   15d94:	50                   	push   %eax
   15d95:	e8 91 00 00 00       	call   15e2b <CF>
   15d9a:	83 c4 10             	add    $0x10,%esp
   15d9d:	89 c2                	mov    %eax,%edx
   15d9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15da2:	88 10                	mov    %dl,(%eax)
   15da4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15da7:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15daa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dad:	0f b6 00             	movzbl (%eax),%eax
   15db0:	0f b6 c0             	movzbl %al,%eax
   15db3:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15db9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15dbc:	f7 d8                	neg    %eax
   15dbe:	89 c1                	mov    %eax,%ecx
   15dc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dc3:	01 c8                	add    %ecx,%eax
   15dc5:	0f b6 00             	movzbl (%eax),%eax
   15dc8:	0f b6 c0             	movzbl %al,%eax
   15dcb:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15dce:	01 d0                	add    %edx,%eax
   15dd0:	83 ec 0c             	sub    $0xc,%esp
   15dd3:	50                   	push   %eax
   15dd4:	e8 52 00 00 00       	call   15e2b <CF>
   15dd9:	83 c4 10             	add    $0x10,%esp
   15ddc:	89 c2                	mov    %eax,%edx
   15dde:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15de1:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15de3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15de7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15dea:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15ded:	0f 8c d7 fc ff ff    	jl     15aca <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15df3:	8b 45 0c             	mov    0xc(%ebp),%eax
   15df6:	8b 40 10             	mov    0x10(%eax),%eax
   15df9:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15dfc:	8b 45 0c             	mov    0xc(%ebp),%eax
   15dff:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15e02:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e05:	8b 50 0c             	mov    0xc(%eax),%edx
   15e08:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e0b:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15e0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e11:	8b 40 28             	mov    0x28(%eax),%eax
   15e14:	83 ec 0c             	sub    $0xc,%esp
   15e17:	50                   	push   %eax
   15e18:	e8 73 a8 fe ff       	call   690 <free>
   15e1d:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15e20:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e23:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15e26:	89 50 28             	mov    %edx,0x28(%eax)
}
   15e29:	c9                   	leave  
   15e2a:	c3                   	ret    

00015e2b <CF>:

uchar CF(const int x){
   15e2b:	55                   	push   %ebp
   15e2c:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   15e31:	83 c0 40             	add    $0x40,%eax
   15e34:	c1 f8 07             	sar    $0x7,%eax
   15e37:	50                   	push   %eax
   15e38:	e8 e9 dd ff ff       	call   13c26 <_Clip>
   15e3d:	83 c4 04             	add    $0x4,%esp
}
   15e40:	c9                   	leave  
   15e41:	c3                   	ret    
